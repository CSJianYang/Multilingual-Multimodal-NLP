[
    {
        "title": "Rotate List",
        "question_content": "Given the head of a linked&nbsp;list, rotate the list to the right by k places.\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n\nExample 2:\n\nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is in the range [0, 500].\n\t-100 <= Node.val <= 100\n\t0 <= k <= 2 * 109",
        "solutions": [
            {
                "id": 22735,
                "title": "my-clean-c-code-quite-standard-find-tail-and-reconnect-the-list",
                "content": "There is no trick for this problem. Some people used slow/fast pointers to find the tail node but I don't see the benefit (in the sense that it doesn't reduce the pointer move op) to do so. So I just used one loop to find the length first.\\n\\n    class Solution {\\n    public:\\n        ListNode* rotateRight(ListNode* head, int k) {\\n            if(!head) return head;\\n            \\n            int len=1; // number of nodes\\n            ListNode *newH, *tail;\\n            newH=tail=head;\\n            \\n            while(tail->next)  // get the number of nodes in the list\\n            {\\n                tail = tail->next;\\n                len++;\\n            }\\n            tail->next = head; // circle the link\\n\\n            if(k %= len) \\n            {\\n                for(auto i=0; i<len-k; i++) tail = tail->next; // the tail node is the (len-k)-th node (1st node is head)\\n            }\\n            newH = tail->next; \\n            tail->next = NULL;\\n            return newH;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* rotateRight(ListNode* head, int k) {\\n            if(!head) return head;\\n            \\n            int len=1; // number of nodes\\n            ListNode *newH, *tail;\\n            newH=tail=head;\\n            \\n            while(tail->next)  // get the number of nodes in the list\\n            {\\n                tail = tail->next;\\n                len++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 348197,
                "title": "96-faster-simple-python-solution-with-explanation",
                "content": "Please upvote if you liked the solution \\n\\n\\n```\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if not head:\\n            return None\\n        \\n        lastElement = head\\n        length = 1\\n        # get the length of the list and the last node in the list\\n        while ( lastElement.next ):\\n            lastElement = lastElement.next\\n            length += 1\\n\\n        # If k is equal to the length of the list then k == 0\\n        # ElIf k is greater than the length of the list then k = k % length\\n        k = k % length\\n            \\n        # Set the last node to point to head node\\n        # The list is now a circular linked list with last node pointing to first node\\n        lastElement.next = head\\n        \\n        # Traverse the list to get to the node just before the ( length - k )th node.\\n        # Example: In 1->2->3->4->5, and k = 2\\n        #          we need to get to the Node(3)\\n        tempNode = head\\n        for _ in range( length - k - 1 ):\\n            tempNode = tempNode.next\\n        \\n        # Get the next node from the tempNode and then set the tempNode.next as None\\n        # Example: In 1->2->3->4->5, and k = 2\\n        #          tempNode = Node(3)\\n        #          answer = Node(3).next => Node(4)\\n        #          Node(3).next = None ( cut the linked list from here )\\n        answer = tempNode.next\\n        tempNode.next = None\\n        \\n        return answer\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if not head:\\n            return None\\n        \\n        lastElement = head\\n        length = 1\\n        # get the length of the list and the last node in the list\\n        while ( lastElement.next ):\\n            lastElement = lastElement.next\\n            length += 1\\n\\n        # If k is equal to the length of the list then k == 0\\n        # ElIf k is greater than the length of the list then k = k % length\\n        k = k % length\\n            \\n        # Set the last node to point to head node\\n        # The list is now a circular linked list with last node pointing to first node\\n        lastElement.next = head\\n        \\n        # Traverse the list to get to the node just before the ( length - k )th node.\\n        # Example: In 1->2->3->4->5, and k = 2\\n        #          we need to get to the Node(3)\\n        tempNode = head\\n        for _ in range( length - k - 1 ):\\n            tempNode = tempNode.next\\n        \\n        # Get the next node from the tempNode and then set the tempNode.next as None\\n        # Example: In 1->2->3->4->5, and k = 2\\n        #          tempNode = Node(3)\\n        #          answer = Node(3).next => Node(4)\\n        #          Node(3).next = None ( cut the linked list from here )\\n        answer = tempNode.next\\n        tempNode.next = None\\n        \\n        return answer\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22715,
                "title": "share-my-java-solution-with-explanation",
                "content": "Since n may be  a large number compared to the length of list. So we need to know the length of linked list.After that, move the list after the (l-n%l )th node to the front to finish the rotation.\\n\\nEx: {1,2,3} k=2 Move the list after the 1st node to the front\\n\\n\\nEx: {1,2,3} k=5, In this case Move the list after (3-5%3=1)st node to the front.\\n\\nSo  the code has three parts. \\n\\n1) Get the length\\n\\n2) Move to the (l-n%l)th node\\n\\n3)Do the rotation\\n\\n\\n\\n    public ListNode rotateRight(ListNode head, int n) {\\n        if (head==null||head.next==null) return head;\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode fast=dummy,slow=dummy;\\n\\n        int i;\\n        for (i=0;fast.next!=null;i++)//Get the total length \\n        \\tfast=fast.next;\\n        \\n        for (int j=i-n%i;j>0;j--) //Get the i-n%i th node\\n        \\tslow=slow.next;\\n        \\n        fast.next=dummy.next; //Do the rotation\\n        dummy.next=slow.next;\\n        slow.next=null;\\n        \\n        return dummy.next;\\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "Since n may be  a large number compared to the length of list. So we need to know the length of linked list.After that, move the list after the (l-n%l )th node to the front to finish the rotation.\\n\\nEx: {1,2,3} k=2 Move the list after the 1st node to the front\\n\\n\\nEx: {1,2,3} k=5, In this case Move the list after (3-5%3=1)st node to the front.\\n\\nSo  the code has three parts. \\n\\n1) Get the length\\n\\n2) Move to the (l-n%l)th node\\n\\n3)Do the rotation\\n\\n\\n\\n    public ListNode rotateRight(ListNode head, int n) {\\n        if (head==null||head.next==null) return head;\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode fast=dummy,slow=dummy;\\n\\n        int i;\\n        for (i=0;fast.next!=null;i++)//Get the total length \\n        \\tfast=fast.next;\\n        \\n        for (int j=i-n%i;j>0;j--) //Get the i-n%i th node\\n        \\tslow=slow.next;\\n        \\n        fast.next=dummy.next; //Do the rotation\\n        dummy.next=slow.next;\\n        slow.next=null;\\n        \\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 22827,
                "title": "java-clean-solution-only-one-pointer-used",
                "content": "I first used a ListNode p, and point it to the head, then move it to the end of the list, and at the same time get the length of the list.  Then `p.next = head;` gives me a circle.   At this time, by moving `p` for `len-k` times, it will be pointing to the node before the break point.  Then all we need to do is record the next node as head, and break the circle with `p.next = null.`  \\n\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || k == 0) {\\n            return head;\\n        }\\n        ListNode p = head;\\n        int len = 1;\\n        while(p.next != null) {\\n            p = p.next;\\n            len++;\\n        }\\n        p.next = head;\\n        k %= len;\\n        for(int i = 0; i < len - k; i++) {\\n            p = p.next;\\n        }\\n        head = p.next;\\n        p.next = null;\\n        return head;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I first used a ListNode p, and point it to the head, then move it to the end of the list, and at the same time get the length of the list.  Then `p.next = head;` gives me a circle.   At this time, by moving `p` for `len-k` times, it will be pointing to the node before the break point.  Then all we need to do is record the next node as head, and break the circle with `p.next = null.`  \\n\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || k == 0) {\\n            return head;\\n        }\\n        ListNode p = head;\\n        int len = 1;\\n        while(p.next != null) {\\n            p = p.next;\\n            len++;\\n        }\\n        p.next = head;\\n        k %= len;\\n        for(int i = 0; i < len - k; i++) {\\n            p = p.next;\\n        }\\n        head = p.next;\\n        p.next = null;\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 22726,
                "title": "anyone-solve-the-problem-without-counting-the-length-of-list",
                "content": "My solution has O(n) time complexity and O(1) memory.\\nThe basic idea is to connect the list into a circle. First, count the length of list while going through the list to find the end of it. Connect the tail to head. The problem asked to rotate k nodes, however, now the tail is at the end of the list and its difficult to move backward, so move *(k - len)* nodes along the list instead. *\"k = k % len\"* saves the unnecessary moves because rotate a list with length = *len* by *len* times doesn't change the list at all.\\n\\n    ListNode *rotateRight(ListNode *head, int k) {\\n            if (head == NULL || head->next == NULL || k == 0) return head;\\n            int len = 1;\\n            ListNode *tail = head;\\n\\n            /* find the end of list */\\n            while (tail->next != NULL) {\\n                tail = tail->next;\\n                len++;\\n            }\\n\\n            /* form a circle */\\n            tail->next = head;\\n            k = k % len;\\n            for (int i = 0; i < len - k; i++) {\\n                tail = tail->next;\\n            }\\n            head = tail->next;\\n            tail->next = NULL;\\n            return head;\\n        }",
                "solutionTags": [],
                "code": "My solution has O(n) time complexity and O(1) memory.\\nThe basic idea is to connect the list into a circle. First, count the length of list while going through the list to find the end of it. Connect the tail to head. The problem asked to rotate k nodes, however, now the tail is at the end of the list and its difficult to move backward, so move *(k - len)* nodes along the list instead. *\"k = k % len\"* saves the unnecessary moves because rotate a list with length = *len* by *len* times doesn't change the list at all.\\n\\n    ListNode *rotateRight(ListNode *head, int k) {\\n            if (head == NULL || head->next == NULL || k == 0) return head;\\n            int len = 1;\\n            ListNode *tail = head;\\n\\n            /* find the end of list */\\n            while (tail->next != NULL) {\\n                tail = tail->next;\\n                len++;\\n            }\\n\\n            /* form a circle */\\n            tail->next = head;\\n            k = k % len;\\n            for (int i = 0; i < len - k; i++) {\\n                tail = tail->next;\\n            }\\n            head = tail->next;\\n            tail->next = NULL;\\n            return head;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 22751,
                "title": "clean-java-solution-with-brief-explanation",
                "content": "The basic idea is to link the tail of the list with the head, make it a cycle. Then count to the rotate point and cut it.\\n\\n    if (head == null)\\n\\t\\t\\treturn head;\\n\\t\\t\\n\\t\\tListNode copyHead = head;\\n\\t\\t\\n\\t\\tint len = 1;\\n\\t\\twhile (copyHead.next != null) {\\n\\t\\t\\tcopyHead = copyHead.next;\\n\\t\\t\\tlen++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tcopyHead.next = head;\\n\\t\\t\\n\\t\\tfor (int i = len - k % len; i > 1; i--)\\n\\t\\t\\thead = head.next;\\n\\n\\t\\tcopyHead = head.next;\\n\\t\\thead.next = null;\\n\\n\\t\\treturn copyHead;\\n\\t}",
                "solutionTags": [],
                "code": "The basic idea is to link the tail of the list with the head, make it a cycle. Then count to the rotate point and cut it.\\n\\n    if (head == null)\\n\\t\\t\\treturn head;\\n\\t\\t\\n\\t\\tListNode copyHead = head;\\n\\t\\t\\n\\t\\tint len = 1;\\n\\t\\twhile (copyHead.next != null) {\\n\\t\\t\\tcopyHead = copyHead.next;\\n\\t\\t\\tlen++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tcopyHead.next = head;\\n\\t\\t\\n\\t\\tfor (int i = len - k % len; i > 1; i--)\\n\\t\\t\\thead = head.next;\\n\\n\\t\\tcopyHead = head.next;\\n\\t\\thead.next = null;\\n\\n\\t\\treturn copyHead;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 883252,
                "title": "python-o-n-solution-explained",
                "content": "What we need to do in this problem is to find `k`-th element from the end, cut list in two parts and put second part after the first one. Let us do in it several steps:\\n\\n1. Find `n`, length of our list, just traverse it until we reached end.\\n2. If `k % n == 0`, we do not need to rotate list, so return it as it is.\\n3. Find element where we need to cut our list: it has number `n - k%n`, but we need to cut previous connection, so we stop one element earlier.\\n4. Finally, put new head as `middle.next`, make connection between head and tail of original ist and remove connection between `middle` and its next, return new head.\\n\\n**Complexity** is `O(n)` for time: we traverse our list twice at most; space complexity is `O(1)`, we did not use any additional space.\\n\\n```\\nclass Solution:\\n    def rotateRight(self, head, k):\\n        if not head or not head.next: return head\\n        \\n        last, n = head, 1\\n        while last.next:\\n            last = last.next\\n            n += 1\\n            \\n        if k % n == 0: return head\\n        \\n        middle = head\\n        for i in range(n - k%n-1):\\n            middle = middle.next\\n            \\n        new_head = middle.next\\n        last.next = head\\n        middle.next = None\\n        return new_head\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotateRight(self, head, k):\\n        if not head or not head.next: return head\\n        \\n        last, n = head, 1\\n        while last.next:\\n            last = last.next\\n            n += 1\\n            \\n        if k % n == 0: return head\\n        \\n        middle = head\\n        for i in range(n - k%n-1):\\n            middle = middle.next\\n            \\n        new_head = middle.next\\n        last.next = head\\n        middle.next = None\\n        return new_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838907,
                "title": "python-visual-easy-to-understand-o-n-time-o-1-space",
                "content": "\\uD83D\\uDD3A**Please UPVOTE: Can we hit 20?**  \\uD83D\\uDD3A\\n\\n**Approach**\\nHere we modify the linked list in place by visiting the last node and then moving a certain number of nodes to find the new head of the linked list. The example below shows a visual of the algorithm working on the given example [1,2,3,4,5] k=2.\\n\\n![image](https://assets.leetcode.com/users/images/ea4cb812-2bf2-4246-955d-71521ebd787d_1646980729.443265.png)\\n\\n\\n\\n**Code**\\nSee the code below related to the visual above.\\n\\n<iframe src=\"https://leetcode.com/playground/WwHR5WaM/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\t\\nHope you enjoyed! Please leave a comment if anything is missed. Thanks!\\n\\uD83D\\uDD3A**Please UPVOTE: Can we hit 20?**  \\uD83D\\uDD3A",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "\\uD83D\\uDD3A**Please UPVOTE: Can we hit 20?**  \\uD83D\\uDD3A\\n\\n**Approach**\\nHere we modify the linked list in place by visiting the last node and then moving a certain number of nodes to find the new head of the linked list. The example below shows a visual of the algorithm working on the given example [1,2,3,4,5] k=2.\\n\\n![image](https://assets.leetcode.com/users/images/ea4cb812-2bf2-4246-955d-71521ebd787d_1646980729.443265.png)\\n\\n\\n\\n**Code**\\nSee the code below related to the visual above.\\n\\n<iframe src=\"https://leetcode.com/playground/WwHR5WaM/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\t\\nHope you enjoyed! Please leave a comment if anything is missed. Thanks!\\n\\uD83D\\uDD3A**Please UPVOTE: Can we hit 20?**  \\uD83D\\uDD3A",
                "codeTag": "Unknown"
            },
            {
                "id": 883486,
                "title": "simple-clean-c-code-with-comments",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        auto iter = head;\\n        auto len = 1;\\n        while (iter->next != nullptr) {\\n            iter = iter->next; ++len;\\n        }\\n        // close the list (create a ring)\\n        iter->next = head;\\n        iter = head;\\n        // find one element before the new head\\n        for (int i = 0; i < len - (k % len) - 1; ++i) {\\n            iter = iter->next;\\n        }\\n        head = iter->next;\\n        // open the list (break the ring)\\n        iter->next = nullptr;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        auto iter = head;\\n        auto len = 1;\\n        while (iter->next != nullptr) {\\n            iter = iter->next; ++len;\\n        }\\n        // close the list (create a ring)\\n        iter->next = head;\\n        iter = head;\\n        // find one element before the new head\\n        for (int i = 0; i < len - (k % len) - 1; ++i) {\\n            iter = iter->next;\\n        }\\n        head = iter->next;\\n        // open the list (break the ring)\\n        iter->next = nullptr;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22842,
                "title": "97-63-python-solution",
                "content": "    class Solution(object):\\n    def rotateRight(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head:\\n            return None\\n        \\n        if head.next == None:\\n            return head\\n            \\n        pointer = head\\n        length = 1\\n        \\n        while pointer.next:\\n            pointer = pointer.next\\n            length += 1\\n        \\n        rotateTimes = k%length\\n        \\n        if k == 0 or rotateTimes == 0:\\n            return head\\n        \\n        fastPointer = head\\n        slowPointer = head\\n        \\n        for a in range (rotateTimes):\\n            fastPointer = fastPointer.next\\n        \\n        \\n        while fastPointer.next:\\n            slowPointer = slowPointer.next\\n            fastPointer = fastPointer.next\\n        \\n        temp = slowPointer.next\\n        \\n        slowPointer.next = None\\n        fastPointer.next = head\\n        head = temp\\n        \\n        return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n    def rotateRight(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head:\\n            return None\\n        \\n        if head.next == None:\\n            return head\\n            \\n        pointer = head\\n        length = 1\\n        \\n        while pointer.next:\\n            pointer = pointer.next\\n            length += 1\\n        \\n        rotateTimes = k%length\\n        \\n        if k == 0 or rotateTimes == 0:\\n            return head\\n        \\n        fastPointer = head\\n        slowPointer = head\\n        \\n        for a in range (rotateTimes):\\n            fastPointer = fastPointer.next\\n        \\n        \\n        while fastPointer.next:\\n            slowPointer = slowPointer.next\\n            fastPointer = fastPointer.next\\n        \\n        temp = slowPointer.next\\n        \\n        slowPointer.next = None\\n        fastPointer.next = head\\n        head = temp\\n        \\n        return head",
                "codeTag": "Java"
            },
            {
                "id": 923222,
                "title": "java-0ms-faster-than-100-submissions-with-explanation",
                "content": "We can optimize the solution by finding (n-k)th element which is going to be the starting element. First we find the length of the list as n and make the list as a circular linked list. So to perform rotation on linked list, we first find (n-k-1)th element whose next element would be (n-k). Now set (n-k) as result(or head) and (n-k-1)\\'s next as null to break the loop of circular linked list. \\n![image](https://assets.leetcode.com/users/images/74e6013e-d76a-45df-beed-9168dfa854b8_1604495855.260614.png)\\n\\n\\n\\n\\n```\\npublic ListNode rotateRight(ListNode head, int k) {\\n        ListNode dummy = head;\\n        //for empty or list with 1 node return them as such         \\n        if(head == null || head.next == null)\\n            return head;\\n\\t\\t//length starts from 1 to include last element\\n        int n = 1;\\n\\t\\t//goes until last element\\n        while(dummy.next!=null){\\n            dummy = dummy.next;\\n            n++;\\n        }\\n        //Set the last node to head to form circular linked list\\n        dummy.next = head;\\n        dummy = head;\\n        // Rotating n*a times would just give the same linked list so remove them\\n        k = k%n;\\n        //  Since we rotate right we have to find the (n-k)th element which is the head      \\n        for(int i = 0;i<n-k-1;i++){\\n            dummy = dummy.next;\\n        }\\n        //Break the cycle by keeping head as (n-k) and setting (n-k-1)th element as tail\\n        head = dummy.next;\\n        dummy.next = null;\\n        return head;\\n    }\\n```\\n**P.S. Do upvote if you like this solution.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode rotateRight(ListNode head, int k) {\\n        ListNode dummy = head;\\n        //for empty or list with 1 node return them as such         \\n        if(head == null || head.next == null)\\n            return head;\\n\\t\\t//length starts from 1 to include last element\\n        int n = 1;\\n\\t\\t//goes until last element\\n        while(dummy.next!=null){\\n            dummy = dummy.next;\\n            n++;\\n        }\\n        //Set the last node to head to form circular linked list\\n        dummy.next = head;\\n        dummy = head;\\n        // Rotating n*a times would just give the same linked list so remove them\\n        k = k%n;\\n        //  Since we rotate right we have to find the (n-k)th element which is the head      \\n        for(int i = 0;i<n-k-1;i++){\\n            dummy = dummy.next;\\n        }\\n        //Break the cycle by keeping head as (n-k) and setting (n-k-1)th element as tail\\n        head = dummy.next;\\n        dummy.next = null;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22908,
                "title": "c-simple-algorithm-with-explanation",
                "content": " 1. Enumerate through the list to find the last node, count the size along the way.\\n 2. Make a loop, by connection last to first\\n 3. Get modulo of |k/size| - avoiding extra rotation\\n 4. Enumerate again *size-k* nodes\\n 5. Break the loop and return new head\\n\\ncode:\\n\\n     ListNode *rotateRight(ListNode *head, int k) \\n         {\\n            if(head == NULL || head->next == NULL||k==0) return head;\\n            \\n            ListNode* node = head;\\n            int size =1;\\n            \\n            while(node->next != NULL)\\n            {\\n                size++;\\n                node = node->next;\\n            }\\n            \\n            //loop the list\\n            node->next=head;\\n            \\n            //handle the case of k>size\\n            k = k%size;\\n            \\n            //find the node to break the loop at\\n            while(--size >= k)\\n            {\\n                node=node->next;\\n            }\\n            \\n            ListNode* first = node->next;\\n            node->next=NULL;\\n            \\n            return first;\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": " 1. Enumerate through the list to find the last node, count the size along the way.\\n 2. Make a loop, by connection last to first\\n 3. Get modulo of |k/size| - avoiding extra rotation\\n 4. Enumerate again *size-k* nodes\\n 5. Break the loop and return new head\\n\\ncode:\\n\\n     ListNode *rotateRight(ListNode *head, int k) \\n         {\\n            if(head == NULL || head->next == NULL||k==0) return head;\\n            \\n            ListNode* node = head;\\n            int size =1;\\n            \\n            while(node->next != NULL)\\n            {\\n                size++;\\n                node = node->next;\\n            }\\n            \\n            //loop the list\\n            node->next=head;\\n            \\n            //handle the case of k>size\\n            k = k%size;\\n            \\n            //find the node to break the loop at\\n            while(--size >= k)\\n            {\\n                node=node->next;\\n            }\\n            \\n            ListNode* first = node->next;\\n            node->next=NULL;\\n            \\n            return first;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1838152,
                "title": "python3-rotate-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nFirst of all, we notice that `k` can be greater than the length of the list. In this case, rotations will be repeated. To avoid useless operations, we convert `k` as follows: `k = k % length` (if `k` is equal to the length, the k becomes 0 so we don\\'t need to rotate anything). Thus, we need to know the length of the list and also the last element to attach it to the head.  After we figure out the true `k`, we can find the node where we have to cut the list.\\n\\nTime: **O(n)** - traversing\\nSpace: **O(1)**\\n\\nRuntime: 38 ms, faster than **86.22%** of Python3 online submissions for Rotate List.\\nMemory Usage: 13.9 MB, less than **88.66%** of Python3 online submissions for Rotate List.\\n\\n```\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head: return head\\n        \\n        zero = ListNode(next=head) # dummy node\\n        \\n        count, tail = 0, zero\\n        while tail.next:\\n            count, tail = count + 1, tail.next\\n            \\n        k = k % count\\n        if not k: return head\\n\\n        newTail = zero\\n        for _ in range(0, count - k):\\n            newTail = newTail.next\\n\\n        zero.next, tail.next, newTail.next = newTail.next, head, None\\n            \\n        return zero.next\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head: return head\\n        \\n        zero = ListNode(next=head) # dummy node\\n        \\n        count, tail = 0, zero\\n        while tail.next:\\n            count, tail = count + 1, tail.next\\n            \\n        k = k % count\\n        if not k: return head\\n\\n        newTail = zero\\n        for _ in range(0, count - k):\\n            newTail = newTail.next\\n\\n        zero.next, tail.next, newTail.next = newTail.next, head, None\\n            \\n        return zero.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838161,
                "title": "algo-explained-easy-js-97-fast-commented",
                "content": "```\\n/* \\nAlgorithm Explanation: (Image attached in comments)\\n1.  We count the total number of nodes in the list using count variable,\\n2.  Now the total rotations we have to do can be restricted to k= k % count.\\n3.  Now we move a pointer from head equal to k positions. This is necessary \\nfor the next interesting logic\\n4. Now since our ptr is k steps ahead then it will tell us the kth position from end\\ni.e we iterate until ptr.next !==null and we move our prev pointer. Once ptr.next===null\\ni.e ptr reaches the last node, out prev pointer will be exactly at the kth position from end\\nHere kth position from end is nothing but the number of k rotations\\n5. Now simply break the list after prev node. Last node i.e ptr will now point to head\\ni.e ptr.next=head, next node of prev becomes our new head and finally prev becomes our \\nlast node so prev.next=null\\n*/\\n![image](https://assets.leetcode.com/users/images/9971b712-d655-4a65-8820-5672c17d878c_1646963771.4553995.png)\\n\\nvar rotateRight = function (head, k) {\\n\\tif (!head) return head;\\n\\tlet count = 0,\\n\\t\\tptr = head;\\n\\n\\t//Step 1 of the algo, count list nodes\\n\\twhile (ptr) {\\n\\t\\tcount++;\\n\\t\\tptr = ptr.next;\\n\\t}\\n\\n\\t//Ste 2: Number of rotations are now restricted within limit\\n\\tk = k % count;\\n\\tlet prev = head;\\n\\tptr = head;\\n\\n\\t//Step 3: Moving one pointer k positions ahead\\n\\twhile (k--) {\\n\\t\\tptr = ptr.next;\\n\\t}\\n\\n\\t//Step 4: The actual magic, explained above\\n\\twhile (ptr.next) {\\n\\t\\tprev = prev.next;\\n\\t\\tptr = ptr.next;\\n\\t}\\n\\n\\t//Step 5: Simply modifying the head and last node\\n\\tptr.next = head;\\n\\thead = prev.next;\\n\\tprev.next = null;\\n\\treturn head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/* \\nAlgorithm Explanation: (Image attached in comments)\\n1.  We count the total number of nodes in the list using count variable,\\n2.  Now the total rotations we have to do can be restricted to k= k % count.\\n3.  Now we move a pointer from head equal to k positions. This is necessary \\nfor the next interesting logic\\n4. Now since our ptr is k steps ahead then it will tell us the kth position from end\\ni.e we iterate until ptr.next !==null and we move our prev pointer. Once ptr.next===null\\ni.e ptr reaches the last node, out prev pointer will be exactly at the kth position from end\\nHere kth position from end is nothing but the number of k rotations\\n5. Now simply break the list after prev node. Last node i.e ptr will now point to head\\ni.e ptr.next=head, next node of prev becomes our new head and finally prev becomes our \\nlast node so prev.next=null\\n*/\\n![image](https://assets.leetcode.com/users/images/9971b712-d655-4a65-8820-5672c17d878c_1646963771.4553995.png)\\n\\nvar rotateRight = function (head, k) {\\n\\tif (!head) return head;\\n\\tlet count = 0,\\n\\t\\tptr = head;\\n\\n\\t//Step 1 of the algo, count list nodes\\n\\twhile (ptr) {\\n\\t\\tcount++;\\n\\t\\tptr = ptr.next;\\n\\t}\\n\\n\\t//Ste 2: Number of rotations are now restricted within limit\\n\\tk = k % count;\\n\\tlet prev = head;\\n\\tptr = head;\\n\\n\\t//Step 3: Moving one pointer k positions ahead\\n\\twhile (k--) {\\n\\t\\tptr = ptr.next;\\n\\t}\\n\\n\\t//Step 4: The actual magic, explained above\\n\\twhile (ptr.next) {\\n\\t\\tprev = prev.next;\\n\\t\\tptr = ptr.next;\\n\\t}\\n\\n\\t//Step 5: Simply modifying the head and last node\\n\\tptr.next = head;\\n\\thead = prev.next;\\n\\tprev.next = null;\\n\\treturn head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1838092,
                "title": "c-easy-to-understand-simple-short-explained",
                "content": "**61. Rotate List**\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem with Initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n``` ```\\n[LeetCode](https://github.com/knockcat/Leetcode)         **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n``` ```\\n**EXPLANATION**\\n* To **rotate a linked list by k**, we can **first make the linked list circular**.\\n* And, **then moving k-1 steps forward from head node**, **making (k-1)th node\\u2019s next to null and make kth node as head.**\\n* Firstly **checking if list is empty** , we will **return NULL**.\\n* Second, **if list contain only node** than rotation doesn\\'t have any effect , **return head**.\\n* **Counting Number of Nodes.**\\n* Now c**onsider an eg.** Our List is \\n* **1 -> 3 -> 5 -> 5-> 8**\\n* so the **count of nodes is 5**; & **value of k given is 7**\\n* this means we have to **rotate list by 7 places**.\\n* so the list will become,\\n\\t*  8->1->3->->5->5, at **1st iteration**,\\n\\t*  **5->8->1->3->5**, at **2nd iteration**,\\n\\t*  5->5->8->1->3, at **3rd iteration**,\\n\\t*  3->5->5->8->1, at **4th iteration**,\\n\\t*  1->3->5->5->8, at **5th iteration**,\\n\\t*  8->1->3->5->5, at **6th iteration**,\\n\\t*  **5->8->1->3->5**, at **7th iteration**.\\n*  Therefore our list afte **7 rotaion is  5->8->1->3->5**.\\n*  Now  see at **7th and 2nd iteration the list is same**, so why we **need to rotate list** **when the outcome is same.**\\n*  Therefore we are taking **mod of count with k  as k = k % cnt.** this will give us the **valid minimum rotation we have to perform**.\\n* Now we will t**raverse list k times.**\\n* we will **first make list circular** and then **move the list 1 by 1 and last we will add NULL.**\\n* This process we will **repeat k times** as we have to **rotate by k places**.\\n* At last, **return head.**\\n``` ```\\n\\n**CODE WITH EXPLANATION**\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       \\n        ListNode *temp = head, *ptr = head;\\n        \\n\\t\\t// if  list is empty return NULL\\n        if(head == NULL)\\n            return NULL;\\n\\t\\t\\t\\n        // if  list contain 1 node return NULL\\n        if(head -> next == NULL)\\n            return head;\\n        \\n        int cnt = 1;\\n        \\n\\t\\t// counting nodes in list\\n        while(temp->next != NULL)\\n        {\\n            temp = temp -> next;\\n            cnt++;\\n        }\\n\\t\\t\\n\\t\\t// mod of k with cnt to find the minimum no of rotations.\\n        k = k % cnt;\\n        \\n        while(k--)\\n        {\\n            while(temp->next != NULL)\\n                temp = temp -> next;\\n        \\n            temp -> next = head;           //making it a circular linked list\\n\\t\\t\\t\\n\\t\\t\\t// making last node the new head\\n            head = temp;\\n            ptr = temp;\\n\\t\\t\\t\\n\\t\\t\\t// moving list values one by one\\n            while(temp -> next != head)\\n            {\\n                temp = temp -> next;\\n            }\\n            \\n\\t\\t\\t// adding NULL at end of list\\n            temp -> next = NULL;\\n\\t\\t\\t\\n            temp = ptr;\\n            \\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem with Initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n``` ```\n``` ```\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       \\n        ListNode *temp = head, *ptr = head;\\n        \\n\\t\\t// if  list is empty return NULL\\n        if(head == NULL)\\n            return NULL;\\n\\t\\t\\t\\n        // if  list contain 1 node return NULL\\n        if(head -> next == NULL)\\n            return head;\\n        \\n        int cnt = 1;\\n        \\n\\t\\t// counting nodes in list\\n        while(temp->next != NULL)\\n        {\\n            temp = temp -> next;\\n            cnt++;\\n        }\\n\\t\\t\\n\\t\\t// mod of k with cnt to find the minimum no of rotations.\\n        k = k % cnt;\\n        \\n        while(k--)\\n        {\\n            while(temp->next != NULL)\\n                temp = temp -> next;\\n        \\n            temp -> next = head;           //making it a circular linked list\\n\\t\\t\\t\\n\\t\\t\\t// making last node the new head\\n            head = temp;\\n            ptr = temp;\\n\\t\\t\\t\\n\\t\\t\\t// moving list values one by one\\n            while(temp -> next != head)\\n            {\\n                temp = temp -> next;\\n            }\\n            \\n\\t\\t\\t// adding NULL at end of list\\n            temp -> next = NULL;\\n\\t\\t\\t\\n            temp = ptr;\\n            \\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066492,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       if(!head)\\n           return NULL;\\n        int n = 1;\\n        ListNode* tail = head;\\n        while(tail->next){\\n            n++;\\n            tail = tail->next;\\n        }\\n        tail->next = head;\\n        int sz = n - k % n;\\n        for(int i = 0; i < sz; i++){\\n            tail = tail->next;\\n        }  \\n        head = tail->next;\\n        tail->next = NULL;\\n        return head;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       if(!head)\\n           return NULL;\\n        int n = 1;\\n        ListNode* tail = head;\\n        while(tail->next){\\n            n++;\\n            tail = tail->next;\\n        }\\n        tail->next = head;\\n        int sz = n - k % n;\\n        for(int i = 0; i < sz; i++){\\n            tail = tail->next;\\n        }  \\n        head = tail->next;\\n        tail->next = NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22839,
                "title": "clean-python-code",
                "content": "    class Solution(object):\\n        def rotateRight(self, head, k):\\n            n, pre, current = 0, None, head\\n            while current:\\n                pre, current = current, current.next\\n                n += 1\\n    \\n            if not n or not k % n:\\n                return head\\n    \\n            tail = head\\n            for _ in xrange(n - k % n - 1):\\n                tail = tail.next\\n    \\n            next, tail.next, pre.next = tail.next, None, head\\n            return next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def rotateRight(self, head, k):\\n            n, pre, current = 0, None, head\\n            while current:\\n                pre, current = current, current.next\\n                n += 1\\n    \\n            if not n or not k % n:\\n                return head\\n    \\n            tail = head\\n            for _ in xrange(n - k % n - 1):\\n                tail = tail.next\\n    \\n            next, tail.next, pre.next = tail.next, None, head\\n            return next",
                "codeTag": "Java"
            },
            {
                "id": 22905,
                "title": "my-short-java-solution-with-comments",
                "content": "\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null||head.next==null||k==0) return head;\\n        \\n        //make it a cricle, break from k postion far from the head\\n        ListNode index=head; int len=1;// int len to record the length of list\\n        while(index.next!=null)\\n        {index=index.next; len++;}\\n        index.next=head;\\n        \\n        for(int i=0;i<len-k%len;i++)\\n        {\\n           index=index.next;\\n        }\\n        ListNode result=index.next;\\n        index.next=null;\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null||head.next==null||k==0) return head;\\n        \\n        //make it a cricle, break from k postion far from the head\\n        ListNode index=head; int len=1;// int len to record the length of list\\n        while(index.next!=null)\\n        {index=index.next; len++;}\\n        index.next=head;\\n        \\n        for(int i=0;i<len-k%len;i++)\\n        {\\n           index=index.next;\\n        }\\n        ListNode result=index.next;\\n        index.next=null;\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 883117,
                "title": "java-solution-with-diagrammatic-explanation-0-ms",
                "content": "**EXPLANATION**\\n\\nLet\\'s take the following list as an example:\\n\\n**Node 1** -> **Node 2** -> **Node 3** -> **Node 4** -> **Node 5**\\nwith **K = 3**\\n\\nMake the list circular first and calculate the length of the actual linear list:\\n\\n**Node 1** -> **Node 2** -> **Node 3** -> **Node 4** -> **Node 5** -> **Node 1**\\n\\n**Length = 5**\\n\\nNow, our result after **K = 3** rotations should look like this:\\n\\n**Node 3** -> **Node 4** -> **Node 5** -> **Node 1** -> **Node 2**\\n\\nThat is, we need to break the link between **Node 2** and **Node 3**, in the circular linked list, which is at position **length - K** *(5 - 3 = 2)* from the start (**head**) of the list.\\n\\nSo start traversing until **cut = length - K** from the start.  After the traversal ends, make **Node 3** the head of the linked list and make the **next** node of **curr** (here **Node 2**) equal to **null**.\\n\\n**Note: *K can be greater than the length of the list so use the modulo (%) operation before starting the rotation.***\\n\\n***Edge Cases:  (Length of list is 0 or 1) and (K is 0 or a multiple of the length of the list)**.  In either case, return **head***.\\n\\n*------Please **upvote** if you liked the solution.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n```\\nclass Solution {\\n    public ListNode rotateRight (ListNode head, int k) {\\n        if (head == null)\\n            return head;\\n        ListNode curr = head;\\n        int length = 0;\\n        while (curr.next != null) {\\n            length++;\\n            curr = curr.next;\\n        }\\n        length++;\\n        if (length == 1)\\n            return head;\\n        k %= length;\\n        if (k == 0)\\n            return head;\\n        curr.next = head;\\n        curr = head;\\n        int cut = length - k;\\n        while (--cut > 0)\\n            curr = curr.next;\\n        head = curr.next;\\n        curr.next = null;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight (ListNode head, int k) {\\n        if (head == null)\\n            return head;\\n        ListNode curr = head;\\n        int length = 0;\\n        while (curr.next != null) {\\n            length++;\\n            curr = curr.next;\\n        }\\n        length++;\\n        if (length == 1)\\n            return head;\\n        k %= length;\\n        if (k == 0)\\n            return head;\\n        curr.next = head;\\n        curr = head;\\n        int cut = length - k;\\n        while (--cut > 0)\\n            curr = curr.next;\\n        head = curr.next;\\n        curr.next = null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839864,
                "title": "java-thought-process-explained-from-brute-force-to-optimized",
                "content": "**Brute Force Method**\\n1. Firstly, Let\\'s think about the brute force approach. \\n2. By taking a look on the problem, we can say that if simply rotate the array to right by 1 element and do this k times , then we will get the answer.  Time Complexity -> O(n * k)\\n3. Now, lets look at constraints, \\n\\t* \\tThe number of nodes in the list is in the range [0, 500].\\n\\t* \\t-100 <= Node.val <= 100\\n\\t* \\t0 <= k <= 2 * 10^9\\n4. So, if we go by the brute force method, it will take 500 * 10^9 operations in the worst case, which will not be accepted and will give TLE error. We can optimize it.\\n\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if( head == null || k==0) return head;  // if list is empty or if we don\\'t have to rotate the list, return it\\n        while(k-- > 0){  // repeating k times\\n            ListNode x = head;\\n            int preValue = x.val;\\n            x = x.next; // starting from 2nd node\\n            while( x != null ){\\n                // swapping x.val with preValue\\n                int temp = x.val;  \\n                x.val = preValue;\\n                preValue = temp;\\n\\t\\t\\t\\t// iterating to next node\\n                x= x.next;\\n            }\\n            head.val = preValue; //updating 1st node value to last\\n        }\\n        return head;\\n    }\\n}\\n```\\n**Optimized Brute Force**\\n5. Update k to k % n ( i.e k modulus n)\\n* \\twhy k%n? Because if k > n, let\\'s say,  n = 5 and k = 8 , so, we have to rotate list of 5 elements 8 times, if we break down 8 , 8 = 5 + 3 .\\n* If we rotate a list of 5 elements by 5 times, the result will be same, So, if instead of rotating that 8 times we rotate it 3 times, we still get the correct answer. \\n* So, now it will take 500 * 500 operations only which is 2.5 * 10^5 operations which is still large but can be accepted.\\n\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode x = head; // creating copy of head in x to iterate the list while keeping the head unchanged\\n        if( x == null || k==0) return head; // if list is empty or if we don\\'t have to rotate the list, return it\\n        int n = 1;  // counting no. of nodes in the list \\n        while( x.next != null){\\n            x = x.next;\\n            n++;\\n        }\\n        k = k% n; // updating k acc. to point 5\\n        while(k-- > 0){\\n            ListNode y = head;\\n            int preValue = y.val;\\n\\n            y = y.next; // starting from 2nd node\\n            while( y != null ){\\n                // swapping x.val with preValue\\n                int temp = y.val;  \\n                y.val = preValue;\\n                preValue = temp;\\n\\n                y= y.next;\\n            }\\n            head.val = preValue; //updating 1st node value to last\\n        }\\n        return head;\\n    }\\n}\\n```\\n\\n**A new Better Approach**\\n6. Now what we can do is that instead of changing the values, we change the structure of the List by changing the head pointer.\\n* which means that if instead of pointing to head, we point to the (n-k)th node , because after rotating it will become the first element. \\n* why (n-k)th and not kth ? because we are rotating to right, so, its kth element from last node, which is (n-k)th . If we want to rotate to left then it will be kth. E\\n* Suppose our list is like this :-   1 -> 2 -> 3 -> 4 -> 5 -> null\\n* and we need  4 -> 5-> 1 -> 2 -> 3-> null \\n* We can also see that 5 is pointing to null which is breaking the list, so we point 5 to 1 and point 3 to null, and we will return a new head pointer which is pointing to 4.\\n* So, we will get out ans with Time Complexity O(n)\\n\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode x = head; // creating copy of head in x to iterate the list while keeping the head unchanged\\n        if( x == null || k==0) return head; // if list is empty or if we don\\'t have to rotate the list, return it\\n        int n = 1;  // counting no. of nodes in the list \\n        while( x.next != null){\\n            x = x.next;\\n            n++;\\n        }\\n        int i = 1;\\n        k = k%n;  // updaing k acc. to point 5\\n        if(k==0 || n==1) return head; // list will not change in this case, so just return it\\n        ListNode y = head;\\n        while( i < n-k ){\\n            y = y.next;\\n            i++;\\n        }\\n        ListNode newHead = y.next; // Creating a new head point which points to (n-k)th node\\n        y.next = null;   // pointing the (n- k-1)th node to null\\n        x.next = head; // pointing the last pointer to first node.\\n        \\n        return newHead;\\n    }\\n}\\n```\\n\\nP.S : This is the first time I am trying to post a solution with a through explanation, so please comment if you liked it, if it helped you or to give your valuable feedback and suggestions.",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if( head == null || k==0) return head;  // if list is empty or if we don\\'t have to rotate the list, return it\\n        while(k-- > 0){  // repeating k times\\n            ListNode x = head;\\n            int preValue = x.val;\\n            x = x.next; // starting from 2nd node\\n            while( x != null ){\\n                // swapping x.val with preValue\\n                int temp = x.val;  \\n                x.val = preValue;\\n                preValue = temp;\\n\\t\\t\\t\\t// iterating to next node\\n                x= x.next;\\n            }\\n            head.val = preValue; //updating 1st node value to last\\n        }\\n        return head;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode x = head; // creating copy of head in x to iterate the list while keeping the head unchanged\\n        if( x == null || k==0) return head; // if list is empty or if we don\\'t have to rotate the list, return it\\n        int n = 1;  // counting no. of nodes in the list \\n        while( x.next != null){\\n            x = x.next;\\n            n++;\\n        }\\n        k = k% n; // updating k acc. to point 5\\n        while(k-- > 0){\\n            ListNode y = head;\\n            int preValue = y.val;\\n\\n            y = y.next; // starting from 2nd node\\n            while( y != null ){\\n                // swapping x.val with preValue\\n                int temp = y.val;  \\n                y.val = preValue;\\n                preValue = temp;\\n\\n                y= y.next;\\n            }\\n            head.val = preValue; //updating 1st node value to last\\n        }\\n        return head;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode x = head; // creating copy of head in x to iterate the list while keeping the head unchanged\\n        if( x == null || k==0) return head; // if list is empty or if we don\\'t have to rotate the list, return it\\n        int n = 1;  // counting no. of nodes in the list \\n        while( x.next != null){\\n            x = x.next;\\n            n++;\\n        }\\n        int i = 1;\\n        k = k%n;  // updaing k acc. to point 5\\n        if(k==0 || n==1) return head; // list will not change in this case, so just return it\\n        ListNode y = head;\\n        while( i < n-k ){\\n            y = y.next;\\n            i++;\\n        }\\n        ListNode newHead = y.next; // Creating a new head point which points to (n-k)th node\\n        y.next = null;   // pointing the (n- k-1)th node to null\\n        x.next = head; // pointing the last pointer to first node.\\n        \\n        return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828170,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given a linked list, we are required to rotate the linked list right by k places.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, we calculated the length of the linked list and after reaching the last node of the linked list we pointed its next to head making it a circular linked list. And then we forwarded temp k places ahead and set the head value to temp.next and then set temp.next to null. Thus, rotating the linked list to the right by k places.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next==null || k==0) return head;\\n\\n        ListNode temp = head;\\n        int count = 1;\\n        while(temp.next!=null){\\n            count++;\\n            temp = temp.next;\\n        }\\n        temp.next = head;\\n        k = k % count;\\n        k = count - k;\\n        while(k!=0){\\n            temp = temp.next;\\n            k--;\\n        }\\n        head = temp.next;\\n        temp.next = null;\\n\\n        return head;\\n    }\\n}\\n```\\n![oie_CksRiTNvbciG.jpg](https://assets.leetcode.com/users/images/3a11a14a-a573-47b3-82a6-3e37ee8d32c7_1690539034.4558487.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next==null || k==0) return head;\\n\\n        ListNode temp = head;\\n        int count = 1;\\n        while(temp.next!=null){\\n            count++;\\n            temp = temp.next;\\n        }\\n        temp.next = head;\\n        k = k % count;\\n        k = count - k;\\n        while(k!=0){\\n            temp = temp.next;\\n            k--;\\n        }\\n        head = temp.next;\\n        temp.next = null;\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490137,
                "title": "very-easy-explantation-c-with-comments-for-better-understanding",
                "content": "class Solution {\\npublic:\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        ListNode* temp = head;\\n        if(head== NULL || k == 0)\\n            return head;\\n        int n = 0;\\n        while(temp->next != NULL){\\n            temp = temp->next;\\n            n++;\\n        }\\n        temp->next = head;\\n        k = k%(n+1);  \\n        \\n        // ye isleye kia manlo linked list ka size ha 3 or app chle ho 4 bar rotate krne to vo to hum jante hi ha ji 4 bar rotate kro ya 1 bar kro agar size 3 ha to bat to same h islye koi faida nhi h 4 bar krne ka islye y line use krre h \\n        \\n        int x = n-k;\\n        \\n            // ye isleye kai h kyuki apko jump kitni bar krna h vo to pta chle app kis element ke bad sare elements ko hata ke agge lgare ho vo ye btaega ji \\n        \\n       \\n        temp = head;\\n        while(x){\\n            temp = temp->next;\\n            x--;\\n        }\\n        ListNode* head1 = temp->next ; \\n        \\n        //NULL krne se phe uske next ko store kralo kyuki abb vhi hoga apka head agar sidha apne temp ke next ko null krdia to jo value head honi chaiye vo lost oh jaegi \\n        \\n        \\n        temp->next = NULL;\\n            return head1;\\n        \\n            \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        ListNode* temp = head;\\n        if(head== NULL || k == 0)\\n            return head;\\n        int n = 0;\\n        while(temp->next != NULL){\\n            temp = temp->next;\\n            n++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1838877,
                "title": "javascript-easy-to-understand-2-solutions-detailed-explanation",
                "content": "## Core strategy\\n\\nFor this problem, in short words, we need to move the last `k` nodes to the start of the linked list. So, what we need to do is:\\n1. find the node of current tail\\n1. find the node before `k` nodes as the new tail\\n1. link the current tail to the original head\\n1. link the new tail to `null`\\n\\nBut there\\'s something else we need to take care:\\n- we don\\'t know the length of the linked list\\n- the linked list could be empty\\n- the `k` could be bigger than the length\\n- the `k` could be 0 or the multiple of the length\\n\\nSo, for step 1, we could traverse the linked list to find the current tail. And during this, we could get the length of the linked list.\\nFor step 2, we could calculate the index of that node by length and `k`, so what we need to do is traverse again.\\nFor step 3 and 4, we just need to change the value of `next` pointer.\\n\\n## With extra space\\n\\nIf we could use extra space, we may just put each node of linked list into an array. And with the length and `k`, we could easily calculate the index and get what we want. Just take care of some corner cases.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst rotateRight = (head, k) => {\\n  if (!head || !head.next || !k) return head;\\n  const list = [];\\n  let len = 0;\\n  // put linked list into array\\n  for (let cur = head; cur; cur = cur.next) {\\n    list[len++] = cur;\\n  }\\n  // calculate the break position\\n  const newHead = len - (k % len);\\n  if (newHead === len) return head;\\n  // change pointer\\n  list[len - 1].next = head;\\n  list[newHead - 1].next = null;\\n  return list[newHead];\\n};\\n```\\n\\n## Without extra space\\n\\nIf you don\\'t want to use extra space, then we need to traverse again to get the new tail node.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst rotateRight = (head, k) => {\\n  if (!head || !head.next || !k) return head;\\n  let newTail = head;\\n  let tail = head;\\n  let len = 1;\\n  // get current tail node and length of linked list\\n  while (tail.next) {\\n    tail = tail.next;\\n    ++len;\\n  }\\n  // link current tail to head\\n  tail.next = head;\\n  // get the new tail node\\n  for (let i = 1; i < len - (k % len); ++i) {\\n    newTail = newTail.next;\\n  }\\n  const ret = newTail.next;\\n  // change it into the real tail\\n  newTail.next = null;\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst rotateRight = (head, k) => {\\n  if (!head || !head.next || !k) return head;\\n  const list = [];\\n  let len = 0;\\n  // put linked list into array\\n  for (let cur = head; cur; cur = cur.next) {\\n    list[len++] = cur;\\n  }\\n  // calculate the break position\\n  const newHead = len - (k % len);\\n  if (newHead === len) return head;\\n  // change pointer\\n  list[len - 1].next = head;\\n  list[newHead - 1].next = null;\\n  return list[newHead];\\n};\\n```\n```js\\nconst rotateRight = (head, k) => {\\n  if (!head || !head.next || !k) return head;\\n  let newTail = head;\\n  let tail = head;\\n  let len = 1;\\n  // get current tail node and length of linked list\\n  while (tail.next) {\\n    tail = tail.next;\\n    ++len;\\n  }\\n  // link current tail to head\\n  tail.next = head;\\n  // get the new tail node\\n  for (let i = 1; i < len - (k % len); ++i) {\\n    newTail = newTail.next;\\n  }\\n  const ret = newTail.next;\\n  // change it into the real tail\\n  newTail.next = null;\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 199470,
                "title": "javascript-easy-way",
                "content": "```javascript\\nvar rotateRight = function(head, k) {\\n  let tail = head;\\n  if (head === null) return head;\\n  let len = 1;\\n  while (tail.next) {\\n    tail = tail.next;\\n    len++;\\n  }\\n  tail.next = head;\\n  let count = len - (k % len);\\n  while (count > 0) {\\n    head = head.next;\\n    tail = tail.next;\\n    count--;\\n  }\\n  tail.next = null;\\n  return head;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar rotateRight = function(head, k) {\\n  let tail = head;\\n  if (head === null) return head;\\n  let len = 1;\\n  while (tail.next) {\\n    tail = tail.next;\\n    len++;\\n  }\\n  tail.next = head;\\n  let count = len - (k % len);\\n  while (count > 0) {\\n    head = head.next;\\n    tail = tail.next;\\n    count--;\\n  }\\n  tail.next = null;\\n  return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3172692,
                "title": "85-67-acceptable-beginner-level-js-solution-explained-with-proper-intuition-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n1. The solution uses **two pointers** to find the tail of the linked list and then creates a loop to make the rotation more efficient.\\n\\n2. After finding the new head, it breaks the loop and returns the new head.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe below code implements a solution to rotate a linked list to the right by a specified number of steps (k).\\n\\nHere\\'s how the below code works :-\\n\\n1. The code first checks if the linked list is empty or has only one node, in which case it returns the head of the list as the result.\\n\\n2. Then, it finds the tail node of the linked list and the length of the linked list.\\n\\n3.  The tail node is found by iterating through the linked list and updating the tail variable until there is no next node.\\n\\n4. Next, the code calculates the number of steps to rotate the linked list to the right. This is done by subtracting k modulo the length of the linked list from the length of the linked list.\\n\\n5. Then, the code creates a circular linked list by connecting the tail node to the head node.\\n\\n6. Finally, the code breaks the circular linked list back into a linear linked list by setting the next node of the tail node to null and returning the head node of the rotated linked list.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here n is the number of nodes in the linked list. \\n\\n2. This is because the code iterates through the linked list to find the tail and the length of the linked list, and then iterates through the linked list again to find the new head.\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. Because it only uses a few pointers to keep track of the head, tail, and length of the linked list, and it doesn\\'t use any additional data structures. \\n\\n2. The solution only uses a constant amount of extra memory regardless of the size of the linked list.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\n\\n\\nvar rotateRight = function(head, k) {\\n\\n    if (!head || !head.next) return head;\\n    \\n    let tail = head;\\n\\n    let length = 1;\\n    \\n    while (tail.next) {\\n\\n        tail = tail.next;\\n\\n        length++;\\n\\n    }\\n\\n    tail.next = head;\\n\\n    k = length - k % length;\\n\\n    for (let i = 0; i < k; i++) {\\n\\n    tail = tail.next;\\n\\n    head = tail.next;\\n    \\n    }\\n    \\n    tail.next = null;\\n    \\n    return head;\\n\\n};\\n\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/9e228812-daf6-4f4f-bbe8-4e4cd8039cf2_1676133046.0874872.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\n\\n\\nvar rotateRight = function(head, k) {\\n\\n    if (!head || !head.next) return head;\\n    \\n    let tail = head;\\n\\n    let length = 1;\\n    \\n    while (tail.next) {\\n\\n        tail = tail.next;\\n\\n        length++;\\n\\n    }\\n\\n    tail.next = head;\\n\\n    k = length - k % length;\\n\\n    for (let i = 0; i < k; i++) {\\n\\n    tail = tail.next;\\n\\n    head = tail.next;\\n    \\n    }\\n    \\n    tail.next = null;\\n    \\n    return head;\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1912571,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        guard head?.next != nil else { return head }\\n\\n        var curr = head\\n        var len = 1\\n\\n        while curr?.next != nil {\\n            curr = curr?.next\\n            len += 1\\n        }\\n        curr?.next = head\\n\\n        for _ in 0..<(len - k % len) { curr = curr?.next }\\n\\n        var newHead = curr?.next\\n        curr?.next = nil\\n\\n        return newHead\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        guard head?.next != nil else { return head }\\n\\n        var curr = head\\n        var len = 1\\n\\n        while curr?.next != nil {\\n            curr = curr?.next\\n            len += 1\\n        }\\n        curr?.next = head\\n\\n        for _ in 0..<(len - k % len) { curr = curr?.next }\\n\\n        var newHead = curr?.next\\n        curr?.next = nil\\n\\n        return newHead\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838477,
                "title": "c-java-easy-to-understand-iterative-simple-explanation",
                "content": "**61. Rotate List**\\n\\n##### **APPROACH -**\\n* **Take last k nodes from the end and put them at the front**\\n\\n*First calculate the length of the linked list\\nUpdate **k = k % len** for optimization\\nCreate `slow` and `fast` pointers\\nIterate to make **fast point to the last node**  and **slow to (k+1)th node from end**\\nForm the required new pointer links*\\n</br>\\n\\n##### **COMPLEXITY -**\\n* **Time Complexity : O(N)**, where N = number of nodes in the list\\n* **Space Complexity : O(1)**\\n</br>\\n\\n##### **CODE -**\\n\\n**C++**\\n```\\nclass Solution {\\n    inline int getLength(ListNode* head) {\\n        int len = 0;\\n        while(head) {\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head)   return head;\\n        \\n        // calculate length and update k\\n        int len = getLength(head);\\n        k = k % len;\\n        \\n        // get the required nodes\\n        ListNode *fast = head, *slow = head;\\n        while(k--)\\n            fast = fast->next;\\n        while(fast->next) {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n        \\n        // form the new links\\n        fast->next = head;\\n        head = slow->next;\\n        slow->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    private int getLength(ListNode head) {\\n        int len = 0;\\n        while(head != null) {\\n            len++;\\n            head = head.next;\\n        }\\n        return len;\\n    }\\n    \\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null)   return head;\\n        \\n        // calculate length and update k\\n        int len = getLength(head);\\n        k = k % len;\\n        \\n        // get the required nodes\\n        ListNode fast = head, slow = head;\\n        while(k != 0) {\\n            fast = fast.next;\\n            k--;\\n        }\\n        while(fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        \\n        // form the new links\\n        fast.next = head;\\n        head = slow.next;\\n        slow.next = null;\\n        \\n        return head;\\n    }\\n}\\n```\\n\\n**If you found this helpful, please Upvote \\u2B06\\uFE0F**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    inline int getLength(ListNode* head) {\\n        int len = 0;\\n        while(head) {\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head)   return head;\\n        \\n        // calculate length and update k\\n        int len = getLength(head);\\n        k = k % len;\\n        \\n        // get the required nodes\\n        ListNode *fast = head, *slow = head;\\n        while(k--)\\n            fast = fast->next;\\n        while(fast->next) {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n        \\n        // form the new links\\n        fast->next = head;\\n        head = slow->next;\\n        slow->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private int getLength(ListNode head) {\\n        int len = 0;\\n        while(head != null) {\\n            len++;\\n            head = head.next;\\n        }\\n        return len;\\n    }\\n    \\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null)   return head;\\n        \\n        // calculate length and update k\\n        int len = getLength(head);\\n        k = k % len;\\n        \\n        // get the required nodes\\n        ListNode fast = head, slow = head;\\n        while(k != 0) {\\n            fast = fast.next;\\n            k--;\\n        }\\n        while(fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        \\n        // form the new links\\n        fast.next = head;\\n        head = slow.next;\\n        slow.next = null;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630272,
                "title": "c-2-approaches",
                "content": "**Method-1 : (Effecient Approach 7ms)**\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head == NULL || head->next == NULL || k == 0) return head;\\n        int len = 1;\\n        ListNode *tail = head;\\n        while (tail->next != NULL)\\n            tail = tail->next, len++;\\n\\n        /* form a circle */\\n        tail->next = head;\\n        k = k % len;\\n        for (int i = 0; i < len - k; i++)\\n            tail = tail->next;\\n            \\n        head = tail->next;\\n        tail->next = NULL;\\n        return head;\\n    }\\n};\\n```\\n**Time-Complexity : 0(n)\\nSpace-Complexity : 0(1)**\\n\\n**Method -2: (Using Vector 4ms)**\\n```\\nclass Solution {\\npublic:\\n    \\n    void reverse(vector<int>& nums, int left, int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next || k <= 0)  return head;\\n        \\n        vector<int> nums;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        k = k % nums.size();\\n        reverse(nums, 0, nums.size()-1);\\n        reverse(nums, 0, k-1);\\n        reverse(nums, k, nums.size()-1);\\n        \\n        temp = head;\\n        int i = 0;\\n        while(temp != NULL){\\n            temp->val = nums[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\nTime-Complexity : 0(n)\\nSpace-Complexity : 0(n)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head == NULL || head->next == NULL || k == 0) return head;\\n        int len = 1;\\n        ListNode *tail = head;\\n        while (tail->next != NULL)\\n            tail = tail->next, len++;\\n\\n        /* form a circle */\\n        tail->next = head;\\n        k = k % len;\\n        for (int i = 0; i < len - k; i++)\\n            tail = tail->next;\\n            \\n        head = tail->next;\\n        tail->next = NULL;\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void reverse(vector<int>& nums, int left, int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next || k <= 0)  return head;\\n        \\n        vector<int> nums;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        k = k % nums.size();\\n        reverse(nums, 0, nums.size()-1);\\n        reverse(nums, 0, k-1);\\n        reverse(nums, k, nums.size()-1);\\n        \\n        temp = head;\\n        int i = 0;\\n        while(temp != NULL){\\n            temp->val = nums[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186709,
                "title": "short-python-solution-99-7",
                "content": "```\nclass Solution:\n    def rotateRight(self, head, k):\n        if not head:\n            return None\n        p=q=head\n        l=1\n        while p.next:\n            p=p.next\n            l+=1\n        p.next=head\n        k%=l\n        for _ in range(l-k-1):\n            q=q.next\n        ans=q.next\n        q.next=None\n        return ans\t\t\n",
                "solutionTags": [],
                "code": "class Solution:\n    def rotateRight(self, head, k):\n        p=q=head\n        l=1\n            p=p.next\n            l+=1\n        p.next=head\n        k%=l\n        for _ in range(l-k-1):\n            q=q.next\n        ans=q.next\n        q.next=None",
                "codeTag": "Java"
            },
            {
                "id": 1838527,
                "title": "java-c-best-diagramatic-explanation",
                "content": "```\\nThis ques is all about converting a single linkedlist into a circular linkedlist after rotating the nodes k times.\\nLets first understand about the k .\\n```\\nLet assume the length of the linked list given is L.\\nso,there can be 2 possible cases;\\n1-**When k < L**\\nEx: {1,2,3} k=2 Move the list after the 1st node to the front\\n\\n2-**When k > L**\\nEx: {1,2,3} k=5, In this case Move the list after 1 st node to the front.\\n\\nSo, to calculate after rotation of nodes which node to be use as the head of the node we can use the formula\\n***[ L-k%L ]*** which is valid for both the upr cases .\\n\\nNow we came to a conclusion that this conde consist of 3 major parts:\\n* Converting singly Linkedlist to a circular:-\\n         which means last nodes points toward the head of the link list\\n* Calculating the length of the Linnkedlist :-\\n         we can use a pointer `curr` in a while loop in which we will forward the curr pointer till it reaches the end of              the list and every time it moves forward we store it in a `count` variable which give us the length\\n* Calculating  `k=Count -(k %Count)` \\n* Rotate the nodes;\\n\\n```\\nLet\\'s understand it visually :-\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7b371609-3a96-4f58-b17d-b7495bb75ca8_1646973846.1428955.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/0044ac8a-f761-45c7-a971-6dedd4c1110c_1646974034.2282662.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/91b1f303-4668-4c32-949b-3066d3b276c0_1646974086.2907307.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/fac99020-40bf-4d3a-9cdb-da5fcca55da0_1646974132.3556378.jpeg)\\n\\n***SO , LETS CODE IT ***\\n\\n***JAVA***\\n\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        // Base Condition OR edge case\\n        if(head == null || head.next == null || k == 0) return head;\\n        \\n        ListNode curr = head; // pointer current\\n        int count = 1; // here count is length\\n        while(curr.next != null){ // reach end of list, and have the count\\n            count++;\\n            curr = curr.next;\\n        }\\n        curr.next = head; // connect last node to head node to make it circular\\n        k = count - (k % count); // get the length\\n        while(k--> 0) curr = curr.next; // now move pointer, to the kth node\\n        head = curr.next; // make the head \\n        curr.next = null; // and point that curr to null\\n        \\n        return head;\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL || k == 0) return head;\\n        \\n        ListNode *curr = head;\\n        int count = 1;\\n        while(curr->next != NULL){\\n            count++;\\n            curr = curr->next;\\n        }\\n        curr->next = head;\\n        k = count - (k % count);\\n        while(k--> 0) curr = curr->next;\\n        head = curr->next;\\n        curr->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```\\n<hr>\\n<hr>\\n\\nANALYSIS\\n* **Time Complexity :-** O( N - ( N % K )) = O(N)\\n\\n\\n* **Space Complexity :-** O(1)\\n\\n\\n<hr>\\n<hr>\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nThis ques is all about converting a single linkedlist into a circular linkedlist after rotating the nodes k times.\\nLets first understand about the k .\\n```\n```\\nLet\\'s understand it visually :-\\n```\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        // Base Condition OR edge case\\n        if(head == null || head.next == null || k == 0) return head;\\n        \\n        ListNode curr = head; // pointer current\\n        int count = 1; // here count is length\\n        while(curr.next != null){ // reach end of list, and have the count\\n            count++;\\n            curr = curr.next;\\n        }\\n        curr.next = head; // connect last node to head node to make it circular\\n        k = count - (k % count); // get the length\\n        while(k--> 0) curr = curr.next; // now move pointer, to the kth node\\n        head = curr.next; // make the head \\n        curr.next = null; // and point that curr to null\\n        \\n        return head;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL || k == 0) return head;\\n        \\n        ListNode *curr = head;\\n        int count = 1;\\n        while(curr->next != NULL){\\n            count++;\\n            curr = curr->next;\\n        }\\n        curr->next = head;\\n        k = count - (k % count);\\n        while(k--> 0) curr = curr->next;\\n        head = curr->next;\\n        curr->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883159,
                "title": "rotate-list-java-c-o-n",
                "content": "\\nTime: O(N) \\nSpace O(1)\\n\\nIf you like it, please upvote it. Thanks.\\n\\nJava\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        // handle special case length is 0 or 1\\n        if (head == null || head.next == null) return head;\\n\\n        // calculate list length\\n\\t\\t// we also need to find the tail node and point it to head at the end\\n        int length = 1;\\n        ListNode tail = head;\\n        while (tail.next != null)\\n        {\\n            tail = tail.next;\\n            length ++;\\n        }\\n        \\n        //calcualte k so rotate at most length-1 steps\\n        k = k % length;\\n        if (k == 0) return head;\\n        \\n\\t\\t//split the list to two lists.\\n        ListNode newHead = head;\\n        ListNode newTail = head;; \\n        while (length > k)\\n        {\\n            newTail = newHead;\\n            newHead = newHead.next;\\n            length --;\\n        }\\n        newTail.next = null;\\n        tail.next = head;\\n        return newHead;\\n    }\\n}\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // handle special case length is 0 or 1\\n        if (head == nullptr || head->next == nullptr) return head;\\n\\n        // calculate list length\\n\\t\\t// we also need to find the tail node and point it to head at the end\\n        int length = 1;\\n        ListNode* tail = head;\\n        while (tail->next != nullptr)\\n        {\\n            tail = tail->next;\\n            length ++;\\n        }\\n        \\n        //calcualte k so rotate at most length-1 steps\\n        k = k % length;\\n        if (k == 0) return head;\\n        \\n\\t\\t//split the list to two lists.\\n        ListNode* newHead = head;\\n        ListNode* newTail = head;; \\n        while (length > k)\\n        {\\n            newTail = newHead;\\n            newHead = newHead->next;\\n            length --;\\n        }\\n        newTail->next = nullptr;\\n        tail->next = head;\\n        return newHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        // handle special case length is 0 or 1\\n        if (head == null || head.next == null) return head;\\n\\n        // calculate list length\\n\\t\\t// we also need to find the tail node and point it to head at the end\\n        int length = 1;\\n        ListNode tail = head;\\n        while (tail.next != null)\\n        {\\n            tail = tail.next;\\n            length ++;\\n        }\\n        \\n        //calcualte k so rotate at most length-1 steps\\n        k = k % length;\\n        if (k == 0) return head;\\n        \\n\\t\\t//split the list to two lists.\\n        ListNode newHead = head;\\n        ListNode newTail = head;; \\n        while (length > k)\\n        {\\n            newTail = newHead;\\n            newHead = newHead.next;\\n            length --;\\n        }\\n        newTail.next = null;\\n        tail.next = head;\\n        return newHead;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // handle special case length is 0 or 1\\n        if (head == nullptr || head->next == nullptr) return head;\\n\\n        // calculate list length\\n\\t\\t// we also need to find the tail node and point it to head at the end\\n        int length = 1;\\n        ListNode* tail = head;\\n        while (tail->next != nullptr)\\n        {\\n            tail = tail->next;\\n            length ++;\\n        }\\n        \\n        //calcualte k so rotate at most length-1 steps\\n        k = k % length;\\n        if (k == 0) return head;\\n        \\n\\t\\t//split the list to two lists.\\n        ListNode* newHead = head;\\n        ListNode* newTail = head;; \\n        while (length > k)\\n        {\\n            newTail = newHead;\\n            newHead = newHead->next;\\n            length --;\\n        }\\n        newTail->next = nullptr;\\n        tail->next = head;\\n        return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838171,
                "title": "c-iterative-2-approaches",
                "content": "**Approach - 1 Basic**\\n```\\n1.Make a for loop , Each time go to the last second node and make last node as head\\n\\nhow to do -->\\n1. Calculate the length of linked list\\n2. take the mod of k with length as k is very large and if k > n its same as list rotating k/n + k%n\\n times which is same as k%n times\\n```\\n**TC - O(n^2)** -- as we can rotate the whole linked list this is worst\\n**CODE**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // if head is null or head next is null \\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        \\n        // calculating length and taking mod of k with n\\n        ListNode * temp = head;\\n        int length =0;\\n        while(temp!= NULL){\\n            temp = temp->next;\\n            length++;\\n        }\\n        if ( k%length == 0){\\n            return head;\\n        }\\n        int n ;\\n        n = k%length;\\n        \\n        \\n        // each time loop goes to last second element and attached it to head\\n        for(int i = 1 ; i <= n ; i++ ){\\n            temp = head;\\n            while(temp->next->next!=NULL){\\n                temp = temp->next;\\n            }\\n            temp->next->next = head;\\n            head = temp->next;\\n            temp->next = NULL;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\\n\\n**Approach 2**\\n```\\n1. Take a temp pointer taking it to node which is (length - k)th node\\n2. Point the end of linked list to head and next of temp as NULL\\n```\\n\\n**Example**\\n```\\nk = 2\\nMake another pointer  p\\ntake temp to length - k\\n1-->2-->3-->4-->5\\nt,p\\n1-->2-->3-->4-->5\\n   t,p\\n1-->2-->3-->4-->5\\n       t,p\\n1-->2-->3-->4-->5\\n         t  p\\n1-->2-->3-->4-->5\\n        t       p\\n\\t\\t\\n\\t\\t\\n4-->5-->1--->2--->3\\n\\n```\\n\\n**TC - O(n)**\\n\\n**CODE**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // if head is null or head next is null \\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        \\n        // calculating length and taking mod of k with n\\n        ListNode * temp = head;\\n        int length =0;\\n        while(temp!= NULL){\\n            temp = temp->next;\\n            length++;\\n        }\\n        if ( k%length == 0){\\n            return head;\\n        }\\n        int n ;\\n        n = k%length;\\n        \\n        \\n        \\n        ListNode* temp1 = head;\\n        ListNode * temp2 = head;\\n        \\n        \\n        \\n        for(int i = 1 ; i < (length-n) ; i++){\\n            temp1 = temp1->next;\\n            temp2 = temp2->next;\\n        }\\n        while(temp1->next != NULL){\\n            temp1 = temp1->next;\\n            \\n        }\\n        temp1->next = head;\\n        head = temp2->next;\\n        temp2->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n1.Make a for loop , Each time go to the last second node and make last node as head\\n\\nhow to do -->\\n1. Calculate the length of linked list\\n2. take the mod of k with length as k is very large and if k > n its same as list rotating k/n + k%n\\n times which is same as k%n times\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // if head is null or head next is null \\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        \\n        // calculating length and taking mod of k with n\\n        ListNode * temp = head;\\n        int length =0;\\n        while(temp!= NULL){\\n            temp = temp->next;\\n            length++;\\n        }\\n        if ( k%length == 0){\\n            return head;\\n        }\\n        int n ;\\n        n = k%length;\\n        \\n        \\n        // each time loop goes to last second element and attached it to head\\n        for(int i = 1 ; i <= n ; i++ ){\\n            temp = head;\\n            while(temp->next->next!=NULL){\\n                temp = temp->next;\\n            }\\n            temp->next->next = head;\\n            head = temp->next;\\n            temp->next = NULL;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\n```\\n1. Take a temp pointer taking it to node which is (length - k)th node\\n2. Point the end of linked list to head and next of temp as NULL\\n```\n```\\nk = 2\\nMake another pointer  p\\ntake temp to length - k\\n1-->2-->3-->4-->5\\nt,p\\n1-->2-->3-->4-->5\\n   t,p\\n1-->2-->3-->4-->5\\n       t,p\\n1-->2-->3-->4-->5\\n         t  p\\n1-->2-->3-->4-->5\\n        t       p\\n\\t\\t\\n\\t\\t\\n4-->5-->1--->2--->3\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // if head is null or head next is null \\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        \\n        // calculating length and taking mod of k with n\\n        ListNode * temp = head;\\n        int length =0;\\n        while(temp!= NULL){\\n            temp = temp->next;\\n            length++;\\n        }\\n        if ( k%length == 0){\\n            return head;\\n        }\\n        int n ;\\n        n = k%length;\\n        \\n        \\n        \\n        ListNode* temp1 = head;\\n        ListNode * temp2 = head;\\n        \\n        \\n        \\n        for(int i = 1 ; i < (length-n) ; i++){\\n            temp1 = temp1->next;\\n            temp2 = temp2->next;\\n        }\\n        while(temp1->next != NULL){\\n            temp1 = temp1->next;\\n            \\n        }\\n        temp1->next = head;\\n        head = temp2->next;\\n        temp2->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592889,
                "title": "0-ms-easy-to-undertsand-breaking-and-re-connecting-the-list",
                "content": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || head.next == null)\\n            return head;\\n        ListNode count = head; // counting the list size\\n        int size = 0;\\n        while(count!=null){\\n            size++;\\n            count = count.next;\\n        }\\n        k=k%size;  // adjusting number of rotations\\n        if(k == 0)\\n            return head;\\n        ListNode x = head; // setting the pointer to the position of breaking the list\\n        int a=0;\\n        while(x != null){\\n            a++;\\n            if(a == (size-k)){\\n                break;\\n            }\\n            x=x.next;\\n        }\\n        ListNode newList = new ListNode(-1); // New listnode to point the head of the answer list\\n        newList.next = x.next;                //\\n        ListNode newx = x.next;              //\\n        x.next = null;                      //\\n        while(newx.next != null){          //\\n            newx=newx.next;               //\\n        }                                //\\n        newx.next = head;               //  setting up the new list\\n        return newList.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || head.next == null)\\n            return head;\\n        ListNode count = head; // counting the list size\\n        int size = 0;\\n        while(count!=null){\\n            size++;\\n            count = count.next;\\n        }\\n        k=k%size;  // adjusting number of rotations\\n        if(k == 0)\\n            return head;\\n        ListNode x = head; // setting the pointer to the position of breaking the list\\n        int a=0;\\n        while(x != null){\\n            a++;\\n            if(a == (size-k)){\\n                break;\\n            }\\n            x=x.next;\\n        }\\n        ListNode newList = new ListNode(-1); // New listnode to point the head of the answer list\\n        newList.next = x.next;                //\\n        ListNode newx = x.next;              //\\n        x.next = null;                      //\\n        while(newx.next != null){          //\\n            newx=newx.next;               //\\n        }                                //\\n        newx.next = head;               //  setting up the new list\\n        return newList.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22909,
                "title": "4ms-c-solution",
                "content": "    struct ListNode *rotateRight(struct ListNode *head, int k) {\\n        if (!head || k == 0) return head;\\n    \\n    \\tstruct ListNode* lastNode = head;\\n    \\tint n = 1;\\n    \\twhile (lastNode->next)\\n    \\t{\\n    \\t\\tlastNode = lastNode->next;\\n    \\t\\tn++;\\n    \\t}\\n    \\n    \\tk = k%n;\\t\\t\\n    \\tif (k == 0) return head;\\n    \\tk = n - k;\\n    \\n    \\tlastNode->next = head;\\n    \\tstruct ListNode *newHead = head;\\n    \\n    \\tfor (int i = 0; i < k - 1; i++)\\n    \\t\\tnewHead = newHead->next;\\n    \\t\\t\\n    \\thead = newHead->next;\\n    \\tnewHead->next = NULL;\\n    \\treturn head;\\n    }",
                "solutionTags": [],
                "code": "    struct ListNode *rotateRight(struct ListNode *head, int k) {\\n        if (!head || k == 0) return head;\\n    \\n    \\tstruct ListNode* lastNode = head;\\n    \\tint n = 1;\\n    \\twhile (lastNode->next)\\n    \\t{\\n    \\t\\tlastNode = lastNode->next;\\n    \\t\\tn++;\\n    \\t}\\n    \\n    \\tk = k%n;\\t\\t\\n    \\tif (k == 0) return head;\\n    \\tk = n - k;\\n    \\n    \\tlastNode->next = head;\\n    \\tstruct ListNode *newHead = head;\\n    \\n    \\tfor (int i = 0; i < k - 1; i++)\\n    \\t\\tnewHead = newHead->next;\\n    \\t\\t\\n    \\thead = newHead->next;\\n    \\tnewHead->next = NULL;\\n    \\treturn head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3772637,
                "title": "easy-java-solution-beats-100-clean-code-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        if(head == null) {\\n            return head;\\n        }\\n\\n        int length = 1;\\n        ListNode tail = head;\\n\\n        while(tail.next != null) {\\n            tail = tail.next;\\n            length++;\\n        }\\n\\n        int rotations = k % length;\\n        int newLastIndex = length - rotations;\\n\\n        if(rotations == 0) {\\n            return head;\\n        }\\n\\n        ListNode newLastNode = head;\\n        \\n        while(newLastIndex > 1) {\\n            newLastNode = newLastNode.next;\\n            newLastIndex--;\\n        }\\n\\n        ListNode newHead = newLastNode.next;\\n        newLastNode.next = null;\\n        tail.next = head;\\n        head = newHead;\\n\\n        return head;\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/947f4334-522b-4a30-a0cc-389cc044ab13_1689496489.2165964.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        if(head == null) {\\n            return head;\\n        }\\n\\n        int length = 1;\\n        ListNode tail = head;\\n\\n        while(tail.next != null) {\\n            tail = tail.next;\\n            length++;\\n        }\\n\\n        int rotations = k % length;\\n        int newLastIndex = length - rotations;\\n\\n        if(rotations == 0) {\\n            return head;\\n        }\\n\\n        ListNode newLastNode = head;\\n        \\n        while(newLastIndex > 1) {\\n            newLastNode = newLastNode.next;\\n            newLastIndex--;\\n        }\\n\\n        ListNode newHead = newLastNode.next;\\n        newLastNode.next = null;\\n        tail.next = head;\\n        head = newHead;\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430870,
                "title": "easy-cpp-step-wise-explanation",
                "content": "# Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to rotate the linked list k time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nCheck if the linked list is empty or has only one node. If true, return the linked list as it is.\\n\\nCount the total number of nodes in the linked list using a while loop.\\n\\nIf the given value of k is greater than the total number of nodes, find the remainder of k divided by the total number of nodes.\\n\\nIf the remainder is 0, it means that there is no need to rotate the linked list as the new linked list would be the same as the original linked list. Return the original linked list.\\n\\nIf the remainder is not 0, set k to the remainder value.\\nCalculate the index of the node up to which the linked list has to be rotated, using the formula cnt - k where cnt is the total number of nodes in the linked list.\\n\\nTraverse the linked list till the node at the calculated index.\\nStore the next node of the node at the calculated index in a temporary variable and set the next of this node to NULL.\\n\\nTraverse the temporary node till the last node of the linked list.\\nSet the next of the last node of the linked list to the original head of the linked list.\\n\\nReturn the temporary node, which is the new head of the rotated linked list.\\n\\nThe overall logic of the code is to rotate the linked list to the right by k nodes.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n        int cnt = 1;\\n        ListNode* temp = head;\\n        while(temp->next!=NULL)\\n        {\\n            temp=temp->next;\\n            cnt++;\\n        }\\n        \\n          k=k%cnt;\\n          if(k==0) return head;\\n\\n        temp->next = head;\\n        \\n        int res = cnt - k;\\n        temp = head;\\n        int i=1;\\n        while(i<res)\\n        {\\n            temp=temp->next;\\n            i++;\\n        }\\n        ListNode* prev = temp->next;\\n        temp->next = NULL;\\n        return prev;\\n    }\\n};\\n```\\n![PLEASE UPVOTE.jpg](https://assets.leetcode.com/users/images/9edd6e7c-23ce-4cf2-9d7c-c2e9475d16e1_1681820118.7475502.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n        int cnt = 1;\\n        ListNode* temp = head;\\n        while(temp->next!=NULL)\\n        {\\n            temp=temp->next;\\n            cnt++;\\n        }\\n        \\n          k=k%cnt;\\n          if(k==0) return head;\\n\\n        temp->next = head;\\n        \\n        int res = cnt - k;\\n        temp = head;\\n        int i=1;\\n        while(i<res)\\n        {\\n            temp=temp->next;\\n            i++;\\n        }\\n        ListNode* prev = temp->next;\\n        temp->next = NULL;\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793419,
                "title": "c-o-n-t-c-and-o-1-s-c",
                "content": "```\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        int c=0;\\n        ListNode *A=head;\\n        if(A==NULL || A->next==NULL || k==0) return A;\\n        while(A)\\n        {\\n            c++;\\n            A=A->next;\\n        }\\n        k=k%c;\\n        if(k==0)return head;\\n        k=c-k;\\n        int n=0;\\n        A=head;\\n        ListNode * x,*y,*prv=NULL;\\n        cout<<k<<endl;\\n        while(A)\\n        {\\n            n++;\\n            if(n==k)\\n            {\\n                y=A;\\n                x=A->next;\\n            }\\n            prv=A;\\n            A=A->next;\\n        }\\n        y->next=NULL;\\n        prv->next=head;\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        int c=0;\\n        ListNode *A=head;\\n        if(A==NULL || A->next==NULL || k==0) return A;\\n        while(A)\\n        {\\n            c++;\\n            A=A->next;\\n        }\\n        k=k%c;\\n        if(k==0)return head;\\n        k=c-k;\\n        int n=0;\\n        A=head;\\n        ListNode * x,*y,*prv=NULL;\\n        cout<<k<<endl;\\n        while(A)\\n        {\\n            n++;\\n            if(n==k)\\n            {\\n                y=A;\\n                x=A->next;\\n            }\\n            prv=A;\\n            A=A->next;\\n        }\\n        y->next=NULL;\\n        prv->next=head;\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1259556,
                "title": "javascript-time-o-n-space-o-1",
                "content": "```\\nvar rotateRight = function(head, k){\\n    //find the length\\n    let length = 1 \\n    let pt = head\\n    while(pt && pt.next){\\n          length++\\n          pt = pt.next \\n          }\\n    \\n    //we\\'re using modulo for the edge case of if the length is smaller than k\\n    k = k % length \\n    \\n    //edge case -> if k is 0, we don\\'t need a rotation\\n    if(k === 0){\\n        return head \\n    } \\n    \\n    //find the new tail\\n    let newTail = head\\n    let spaces = length - k \\n    while(spaces > 1){\\n        spaces--\\n        newTail = newTail.next  \\n          }\\n    \\n    //save the new head and reset appropriately \\n    let newHead = newTail.next \\n    newTail.next = null\\n    pt.next = head\\n    return newHead  \\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotateRight = function(head, k){\\n    //find the length\\n    let length = 1 \\n    let pt = head\\n    while(pt && pt.next){\\n          length++\\n          pt = pt.next \\n          }\\n    \\n    //we\\'re using modulo for the edge case of if the length is smaller than k\\n    k = k % length \\n    \\n    //edge case -> if k is 0, we don\\'t need a rotation\\n    if(k === 0){\\n        return head \\n    } \\n    \\n    //find the new tail\\n    let newTail = head\\n    let spaces = length - k \\n    while(spaces > 1){\\n        spaces--\\n        newTail = newTail.next  \\n          }\\n    \\n    //save the new head and reset appropriately \\n    let newHead = newTail.next \\n    newTail.next = null\\n    pt.next = head\\n    return newHead  \\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 888503,
                "title": "pyhton-easy-to-understand-i-promise-o-n-time-complexity",
                "content": "```\\nclass Solution(object):\\n    def rotateRight(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        #if no head, return head\\n        \\n        if not head:\\n            return head\\n        \\n        #make the tail point to the last node while calculating the length of LL\\n        #calculate relative position of k as 0 < k < infinity\\n        #if k is found to have value 0, then return the head as is\\n        \\n        length = 1\\n        tail = head\\n        \\n        while tail.next:\\n            tail = tail.next\\n            length += 1\\n        \\n        k %= length\\n        \\n        if k == 0:\\n            return head\\n        \\n        #new head will always start from length - k\\n        #attach tail->next to head and find new head now relative to tail position \\n        \\n        steps_to_new_head = length - k\\n        tail.next = head\\n        \\n        while steps_to_new_head > 0:\\n            tail = tail.next\\n            steps_to_new_head -= 1\\n        \\n        #make new_head point to tail.next\\n        #and point tail->next to NULL\\n        \\n        new_head = tail.next\\n        tail.next = None\\n        \\n        return new_head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def rotateRight(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        #if no head, return head\\n        \\n        if not head:\\n            return head\\n        \\n        #make the tail point to the last node while calculating the length of LL\\n        #calculate relative position of k as 0 < k < infinity\\n        #if k is found to have value 0, then return the head as is\\n        \\n        length = 1\\n        tail = head\\n        \\n        while tail.next:\\n            tail = tail.next\\n            length += 1\\n        \\n        k %= length\\n        \\n        if k == 0:\\n            return head\\n        \\n        #new head will always start from length - k\\n        #attach tail->next to head and find new head now relative to tail position \\n        \\n        steps_to_new_head = length - k\\n        tail.next = head\\n        \\n        while steps_to_new_head > 0:\\n            tail = tail.next\\n            steps_to_new_head -= 1\\n        \\n        #make new_head point to tail.next\\n        #and point tail->next to NULL\\n        \\n        new_head = tail.next\\n        tail.next = None\\n        \\n        return new_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883826,
                "title": "c-straightforward-algorithm-with-brief-explanation-create-the-circle-then-break-it",
                "content": "**Brief Explanation**\\n* *Return if list is empty or singleton or if k is 0.*\\n* Compute the size of the list.\\n* Link the last node of the list with head. (*A circular list is created*)\\n* If k is greater than size of the list, take modulus. `k = k % size`\\n* Find the position (**p<sub>i</sub>**) from where to break the circle. `size - k % size`\\n* Mark next element (**p<sub>i+1</sub>**) the new head.\\n* Break the circle!\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (!head || !head->next || !k) return head;\\n        \\n        auto temp = head;\\n        \\n        // Compute the size of the linked list.\\n        int size = 1;\\n        while (temp->next) {\\n            temp = temp->next;\\n            ++size;\\n        }\\n        \\n        // Circular linked list is created.\\n        temp->next = head;\\n        \\n        // If k is greater than size of the linked list then take modulus.\\n        k %= size;\\n        \\n        // Find the last node in the list after k rotations.\\n        while(--size >= k) {\\n            temp = temp->next;\\n        }\\n        \\n        // Make the next of last the new head.\\n        head = temp->next;\\n        \\n        // Break the circle.\\n        temp->next = nullptr;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (!head || !head->next || !k) return head;\\n        \\n        auto temp = head;\\n        \\n        // Compute the size of the linked list.\\n        int size = 1;\\n        while (temp->next) {\\n            temp = temp->next;\\n            ++size;\\n        }\\n        \\n        // Circular linked list is created.\\n        temp->next = head;\\n        \\n        // If k is greater than size of the linked list then take modulus.\\n        k %= size;\\n        \\n        // Find the last node in the list after k rotations.\\n        while(--size >= k) {\\n            temp = temp->next;\\n        }\\n        \\n        // Make the next of last the new head.\\n        head = temp->next;\\n        \\n        // Break the circle.\\n        temp->next = nullptr;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22834,
                "title": "sharing-my-8ms-c-solution",
                "content": "    /**\\n     * 1) connect the head with the tail, and form a closed circle\\n     * 2) rotate (n-k%n) times\\n     * 3) find the new head and tail, break them apart, and return the new head\\n     */\\n     \\n    class Solution{\\n    public:\\n        ListNode* rotateRight(ListNode* head, int k) {\\n            if(head==NULL || head->next==NULL)\\n                return head;\\n                \\n            ListNode* last;\\n            int n = 1;\\n            ListNode* p = head;\\n            while(p->next)\\n            {\\n                n++;\\n                p=p->next;\\n            }\\n            p->next = head;\\n            last = p;\\n            k = k%n;\\n            k = n-k;\\n            ListNode* current = head;\\n            for(int i=0; i<k; i++)\\n            {\\n                last = current;\\n                current = current->next;\\n            }\\n            \\n            last->next = NULL;\\n            return current;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution{\\n    public:\\n        ListNode* rotateRight(ListNode* head, int k) {\\n            if(head==NULL || head->next==NULL)\\n                return head;\\n                \\n            ListNode* last;\\n            int n = 1;\\n            ListNode* p = head;\\n            while(p->next)\\n            {\\n                n++;\\n                p=p->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1838659,
                "title": "rotate-list-very-simple-and-easy-solution-c",
                "content": "****EAsy to understand solution with comments for understanding the Logic ***\\n\\n   ****PLEASE UP VOTE IF YOU THINK IT HELPS YOU !!!\\n\\n\\n```\\nListNode* rotateRight(ListNode* head, int k) {\\n        \\n        ListNode *ptr=head;\\n    // if ther is no node than just return 0\\n            if(head==NULL)\\n                return NULL;\\n        // if ther is only one node than return head;\\n           if(head->next==NULL|| k==0 )\\n                return head;\\n         ListNode *temp=head->next;\\n        // l is actually a counter for counting no. of nodes l=2 since the pointer to the linked list is placed and 2nd position  \\n            int l=2;\\n            while(temp->next!=NULL)\\n            {\\n                l++;\\n                temp=temp->next;\\n                ptr=ptr->next;\\n            }\\n        k=k%l;\\n        // if no. of nodes is equal to no. of rotation or no. of node is a multiple of no. rotation than just return head\\n        if(l==k || k==0)\\n            return head;\\n        temp->next=head;\\n        head=temp;\\n        k=k%l;\\n        \\n        int j=1;\\n        // just for no. of rotation\\n        while(j!=k)\\n        {\\n        while(ptr->next->next!=head )\\n        {\\n           ptr=ptr->next; \\n        }\\n            head=ptr->next;\\n            j++;\\n        }\\n        ptr->next=NULL;\\n        return head;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nListNode* rotateRight(ListNode* head, int k) {\\n        \\n        ListNode *ptr=head;\\n    // if ther is no node than just return 0\\n            if(head==NULL)\\n                return NULL;\\n        // if ther is only one node than return head;\\n           if(head->next==NULL|| k==0 )\\n                return head;\\n         ListNode *temp=head->next;\\n        // l is actually a counter for counting no. of nodes l=2 since the pointer to the linked list is placed and 2nd position  \\n            int l=2;\\n            while(temp->next!=NULL)\\n            {\\n                l++;\\n                temp=temp->next;\\n                ptr=ptr->next;\\n            }\\n        k=k%l;\\n        // if no. of nodes is equal to no. of rotation or no. of node is a multiple of no. rotation than just return head\\n        if(l==k || k==0)\\n            return head;\\n        temp->next=head;\\n        head=temp;\\n        k=k%l;\\n        \\n        int j=1;\\n        // just for no. of rotation\\n        while(j!=k)\\n        {\\n        while(ptr->next->next!=head )\\n        {\\n           ptr=ptr->next; \\n        }\\n            head=ptr->next;\\n            j++;\\n        }\\n        ptr->next=NULL;\\n        return head;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730890,
                "title": "beats-99-59-less-code-and-easy-to-understand-solutions-without-and-with-extra-space",
                "content": "![image](https://assets.leetcode.com/users/images/f7ace022-a799-4545-97d4-f78d9a4ee790_1643529593.6388466.png)\\n\\n\\n# First solution T O(N) and M O(1)\\nclass Solution:\\n    \\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        n, tail = 1, head\\n\\n        while tail.next:\\n            tail = tail.next\\n            n += 1\\n            \\n        k = k % n\\n        \\n        # k is equal or bigger than return head\\n        if k == 0:\\n            return head\\n        \\n        \\n        cur = head\\n        for i in range(n - k - 1):\\n            cur = cur.next\\n        \\n        # New head is now pivot next\\n        newHead = cur.next\\n        # piviot next after assigning new head is null\\n        cur.next = None\\n        # tail which is pointing last node is now connected to head \\n        tail.next = head\\n        # newhead is piviot point\\n        return newHead\\n        \\n# Second solution with T O(N) and M O(N)\\n\\nclass Solution:\\n\\n    def rotateRight(self, head, k):\\n\\n        if not head:\\n            return None\\n        \\n        arr = []\\n        \\n        while head:\\n            arr.append(head.val)\\n            head = head.next\\n\\n        k = k % len(arr)\\n        \\n        l, r = 0, len(arr) - 1\\n        while l < r:\\n            arr[l], arr[r] = arr[r], arr[l]\\n            l, r = l + 1, r - 1\\n            \\n        l, r = 0, k - 1\\n        while l < r:\\n            arr[l], arr[r] = arr[r], arr[l]\\n            l, r = l + 1, r - 1\\n\\n        l, r = k, len(arr) - 1\\n        while l < r:\\n            arr[l], arr[r] = arr[r], arr[l]\\n            l, r = l + 1, r - 1\\n\\n        dummy = ListNode(0)\\n        tmp = dummy\\n        \\n        for i in arr:\\n            tmp.next = ListNode(i)\\n            tmp = tmp.next\\n            \\n        return dummy.next\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Linked List"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/f7ace022-a799-4545-97d4-f78d9a4ee790_1643529593.6388466.png)\\n\\n\\n# First solution T O(N) and M O(1)\\nclass Solution:\\n    \\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        n, tail = 1, head\\n\\n        while tail.next:\\n            tail = tail.next\\n            n += 1\\n            \\n        k = k % n\\n        \\n        # k is equal or bigger than return head\\n        if k == 0:\\n            return head\\n        \\n        \\n        cur = head\\n        for i in range(n - k - 1):\\n            cur = cur.next\\n        \\n        # New head is now pivot next\\n        newHead = cur.next\\n        # piviot next after assigning new head is null\\n        cur.next = None\\n        # tail which is pointing last node is now connected to head \\n        tail.next = head\\n        # newhead is piviot point\\n        return newHead\\n        \\n# Second solution with T O(N) and M O(N)\\n\\nclass Solution:\\n\\n    def rotateRight(self, head, k):\\n\\n        if not head:\\n            return None\\n        \\n        arr = []\\n        \\n        while head:\\n            arr.append(head.val)\\n            head = head.next\\n\\n        k = k % len(arr)\\n        \\n        l, r = 0, len(arr) - 1\\n        while l < r:\\n            arr[l], arr[r] = arr[r], arr[l]\\n            l, r = l + 1, r - 1\\n            \\n        l, r = 0, k - 1\\n        while l < r:\\n            arr[l], arr[r] = arr[r], arr[l]\\n            l, r = l + 1, r - 1\\n\\n        l, r = k, len(arr) - 1\\n        while l < r:\\n            arr[l], arr[r] = arr[r], arr[l]\\n            l, r = l + 1, r - 1\\n\\n        dummy = ListNode(0)\\n        tmp = dummy\\n        \\n        for i in arr:\\n            tmp.next = ListNode(i)\\n            tmp = tmp.next\\n            \\n        return dummy.next\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1723555,
                "title": "easy-c-code-100-faster",
                "content": "```\\nListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL || k==0){\\n            return head;\\n        }\\n        ListNode *cur=head;\\n        int len=1;\\n        while(cur->next!=NULL){\\n            cur=cur->next;\\n            len++;\\n        }\\n        cur->next=head;\\n        k=k%len;\\n        k=len-k; \\n        \\n        while(k--){\\n            cur=cur->next;\\n        }\\n        head=cur->next;\\n        cur->next=NULL;\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL || k==0){\\n            return head;\\n        }\\n        ListNode *cur=head;\\n        int len=1;\\n        while(cur->next!=NULL){\\n            cur=cur->next;\\n            len++;\\n        }\\n        cur->next=head;\\n        k=k%len;\\n        k=len-k; \\n        \\n        while(k--){\\n            cur=cur->next;\\n        }\\n        head=cur->next;\\n        cur->next=NULL;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22756,
                "title": "golang-concise-solution-using-two-pointers",
                "content": "To simplify, let's assume `k` is less than a number of ListNode first.  \\nThen we need to do is let a fast pointer move to the `k` th node first, then set a slow pointer to the head and move both slow and fast pointers until the fast pointer reach to the end.\\n\\nAs a result, we can get the situation like below:\\n```\\n+---+    +---+    +---+    +---+    +---+    +---+\\n|   +--->+   +--->+   +--->+   +--->+   +--->+   |\\n+---+    +---+    +---+    +---+    +---+    +---+\\n                   slow                       fast\\n```\\nfast is on the last node and slow is `k` th point before the fast one. So we can arrange the node like so that:\\n1. a new head is positioned at the next node of slow.\\n2. `slow.Next` should `nil`, means an end.\\n3. `fast.Next` should an original head.\\n\\nSo...remaining tricky part is when `k` is more than a length of the list. To handle this, I calculate the remaining rotation number and call another `rotateRight`.\\n\\n```\\nfunc rotateRight(head *ListNode, k int) *ListNode {\\n\\tif k == 0 || head == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tslow, fast := head, head\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tif fast.Next == nil {\\n\\t\\t\\treturn rotateRight(head, k%(i+1))\\n\\t\\t}\\n\\t\\tfast = fast.Next\\n\\t}\\n\\n\\tfor fast.Next != nil {\\n\\t\\tslow, fast = slow.Next, fast.Next\\n\\t}\\n\\tnewHead := slow.Next\\n\\tslow.Next, fast.Next = nil, head\\n\\treturn newHead\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n+---+    +---+    +---+    +---+    +---+    +---+\\n|   +--->+   +--->+   +--->+   +--->+   +--->+   |\\n+---+    +---+    +---+    +---+    +---+    +---+\\n                   slow                       fast\\n```\n```\\nfunc rotateRight(head *ListNode, k int) *ListNode {\\n\\tif k == 0 || head == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tslow, fast := head, head\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tif fast.Next == nil {\\n\\t\\t\\treturn rotateRight(head, k%(i+1))\\n\\t\\t}\\n\\t\\tfast = fast.Next\\n\\t}\\n\\n\\tfor fast.Next != nil {\\n\\t\\tslow, fast = slow.Next, fast.Next\\n\\t}\\n\\tnewHead := slow.Next\\n\\tslow.Next, fast.Next = nil, head\\n\\treturn newHead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3782214,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe code starts with a helper function GetLength which recursively calculates the length of the linked list. It traverses the list until it reaches the end (NULL) and returns the count of nodes encountered.\\n\\nThe rotateRight function takes the head of the linked list and the rotation value k as input. It performs the following steps:\\n\\nCheck for base cases:\\n\\nIf the head is NULL or k is 0, return the head as no rotation is needed.\\nIf the length of the list is 1, return the head as there\\'s only one node and no rotation can be performed.\\nCalculate the length of the list by calling the GetLength helper function.\\n\\nAdjust k to be within the range of the list length by taking the modulus (k % length).\\n\\nPerform the rotation k % length times:\\n\\nStart a loop from 0 to k % length - 1.\\nInitialize a pointer p to the head of the list.\\nTraverse the list until p reaches the second-to-last node (p->next->next == NULL).\\nCreate a new node a using dynamic memory allocation (malloc) and assign the value of the last node (p->next->val) to it.\\nSet the next pointer of a to the current head of the list (a->next = head).\\nUpdate the head to be the new node a (head = a).\\nSet the next pointer of the second-to-last node (p->next) to NULL to disconnect the last node from the list.\\nReturn the new head of the rotated list.\\n\\nThe time complexity of the code is O(n), where n is the length of the linked list. This is because we traverse the list twice: once to calculate the length and again to perform the rotation. The space complexity is O(1) as we are using a constant amount of additional space for the pointers and variables.\\n\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n int GetLength(struct ListNode* head)\\n{\\n\\tif (head == NULL)\\n\\t\\treturn 0;\\n\\n\\treturn 1 + GetLength(head->next);\\n}\\nstruct ListNode* rotateRight(struct ListNode* head, int k){\\n        if (head == NULL || k == 0)\\n\\t\\treturn head;\\n    int length = GetLength(head);\\n\\n\\tif (length == 1)\\n\\t\\treturn head;\\n    for(int i=0;i<k%length;i++)\\n    {\\n        struct ListNode *p=head;\\n        while(p->next->next!=NULL)\\n        {\\n            p=p->next;\\n        }\\n        struct ListNode *a=(struct ListNode *)malloc(sizeof(struct ListNode));\\n        a->val=p->next->val;\\n        a->next=head;\\n        head=a;\\n        p->next=NULL;\\n    }\\n    return head;\\n\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n int GetLength(struct ListNode* head)\\n{\\n\\tif (head == NULL)\\n\\t\\treturn 0;\\n\\n\\treturn 1 + GetLength(head->next);\\n}\\nstruct ListNode* rotateRight(struct ListNode* head, int k){\\n        if (head == NULL || k == 0)\\n\\t\\treturn head;\\n    int length = GetLength(head);\\n\\n\\tif (length == 1)\\n\\t\\treturn head;\\n    for(int i=0;i<k%length;i++)\\n    {\\n        struct ListNode *p=head;\\n        while(p->next->next!=NULL)\\n        {\\n            p=p->next;\\n        }\\n        struct ListNode *a=(struct ListNode *)malloc(sizeof(struct ListNode));\\n        a->val=p->next->val;\\n        a->next=head;\\n        head=a;\\n        p->next=NULL;\\n    }\\n    return head;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3579199,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head == NULL || head->next == NULL) {\\n            return head;\\n        }\\n        ListNode* dummy = head;\\n        int len = 1;\\n        while (dummy->next != NULL) {\\n            len++;\\n            dummy = dummy->next;\\n        }\\n        dummy->next = head;\\n        k = k % len;\\n        int end = len - k;\\n        dummy = head;\\n        while (end > 1) {\\n            end--;\\n            dummy = dummy->next;\\n        }\\n        head = dummy->next;\\n        dummy->next = NULL;\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head == NULL || head->next == NULL) {\\n            return head;\\n        }\\n        ListNode* dummy = head;\\n        int len = 1;\\n        while (dummy->next != NULL) {\\n            len++;\\n            dummy = dummy->next;\\n        }\\n        dummy->next = head;\\n        k = k % len;\\n        int end = len - k;\\n        dummy = head;\\n        while (end > 1) {\\n            end--;\\n            dummy = dummy->next;\\n        }\\n        head = dummy->next;\\n        dummy->next = NULL;\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446807,
                "title": "0ms-100-faster-solution-in-java-using-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        ListNode temp = new ListNode();\\n        temp = head;\\n        if(head==null || head.next==null || k==0) return head;\\n        int count = 1;\\n        while(temp.next!=null){\\n            temp = temp.next;\\n            count++;\\n        }\\n\\n        temp.next = head;\\n        k = k%count;\\n        k = count-k;\\n\\n        while(k-->0){\\n            temp = temp.next;\\n        }\\n        head = temp.next;\\n        temp.next = null;\\n        return head;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        ListNode temp = new ListNode();\\n        temp = head;\\n        if(head==null || head.next==null || k==0) return head;\\n        int count = 1;\\n        while(temp.next!=null){\\n            temp = temp.next;\\n            count++;\\n        }\\n\\n        temp.next = head;\\n        k = k%count;\\n        k = count-k;\\n\\n        while(k-->0){\\n            temp = temp.next;\\n        }\\n        head = temp.next;\\n        temp.next = null;\\n        return head;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838726,
                "title": "simple-solution-easy-to-understand",
                "content": "\\n\\n     if(head == NULL || head->next == NULL)\\n        return head;\\n    else{\\n        struct ListNode *prev = NULL;\\n        struct ListNode *temp = NULL;\\n        temp = head;\\n        int c = 0;\\n        while(temp != NULL){\\n            c++;\\n            temp = temp->next;\\n        }\\n        k %= c;\\n    temp = head;\\n    while(k-- > 0){\\n        while(temp->next != NULL){\\n            prev = temp;\\n            temp = temp->next;\\n        }\\n        temp->next = head;\\n        prev->next = NULL;\\n        head = temp;\\n        temp = head;\\n    }\\n    return head;",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Linked List"
                ],
                "code": "\\n\\n     if(head == NULL || head->next == NULL)\\n        return head;\\n    else{\\n        struct ListNode *prev = NULL;\\n        struct ListNode *temp = NULL;\\n        temp = head;\\n        int c = 0;\\n        while(temp != NULL){\\n            c++;\\n            temp = temp->next;\\n        }\\n        k %= c;\\n    temp = head;\\n    while(k-- > 0){\\n        while(temp->next != NULL){\\n            prev = temp;\\n            temp = temp->next;\\n        }\\n        temp->next = head;\\n        prev->next = NULL;\\n        head = temp;\\n        temp = head;\\n    }\\n    return head;",
                "codeTag": "Unknown"
            },
            {
                "id": 1699839,
                "title": "c-optimized-fast-and-easy-to-understand-code-for-rotating-the-list",
                "content": "**Here\\'s the well commented code for rotating the linked list**\\n\\n```\\nListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||head->next==NULL||k==0)                   //return head for empty list or list with single node\\n            return head;\\n        int count=1;                                             //initialize counter to find length of list with 1\\n        ListNode*cur=head;\\n        while(cur->next!=NULL){                                  //traverse till the last node of the list\\n            count++;\\n            cur=cur->next;\\n        }\\n        cur->next=head;                                          //link the last node with the first node making it a circular list\\n\\t\\t/*\\n\\t\\tNow, note the fact that after rotating the list in a multiple of its on length, it with result in\\n\\t\\tthe original list itself. So, we can do modulo arithmatic on k and reduce the number of k\\n\\t\\tto k modulus length\\n\\t\\t*/\\n        k=k%count;\\n        k=count-k;                                              //finding the position of the last node of the resulting list\\n        while(k--){                                             //traversing circular list k number of times\\n            cur=cur->next;\\n        }\\n\\t\\t//pointing new head and changing it back to linear list\\n        head=cur->next;\\n        cur->next=NULL;\\n        return head;\\n}",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "**Here\\'s the well commented code for rotating the linked list**\\n\\n```\\nListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||head->next==NULL||k==0)                   //return head for empty list or list with single node\\n            return head;\\n        int count=1;                                             //initialize counter to find length of list with 1\\n        ListNode*cur=head;\\n        while(cur->next!=NULL){                                  //traverse till the last node of the list\\n            count++;\\n            cur=cur->next;\\n        }\\n        cur->next=head;                                          //link the last node with the first node making it a circular list\\n\\t\\t/*\\n\\t\\tNow, note the fact that after rotating the list in a multiple of its on length, it with result in\\n\\t\\tthe original list itself. So, we can do modulo arithmatic on k and reduce the number of k\\n\\t\\tto k modulus length\\n\\t\\t*/\\n        k=k%count;\\n        k=count-k;                                              //finding the position of the last node of the resulting list\\n        while(k--){                                             //traversing circular list k number of times\\n            cur=cur->next;\\n        }\\n\\t\\t//pointing new head and changing it back to linear list\\n        head=cur->next;\\n        cur->next=NULL;\\n        return head;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1684600,
                "title": "c-soln-using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int key) {\\n        if(!head || !head->next)return head;\\n        ListNode* temp = head;\\n        vector<int> order;\\n        while(temp!=NULL)order.push_back(temp->val),temp = temp->next;\\n        temp = head;\\n        int index = 0;\\n          key = key % order.size();\\n        if(key < 0)\\n         key = key + order.size();\\n   \\n   reverse(order.begin(),order.begin() + order.size() - key);\\n   reverse(order.begin() ,order.end());\\n   reverse(order.begin(),order.begin() + key);\\n        while(temp!=NULL)temp->val = order[index++],temp=temp->next;\\n        return head;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int key) {\\n        if(!head || !head->next)return head;\\n        ListNode* temp = head;\\n        vector<int> order;\\n        while(temp!=NULL)order.push_back(temp->val),temp = temp->next;\\n        temp = head;\\n        int index = 0;\\n          key = key % order.size();\\n        if(key < 0)\\n         key = key + order.size();\\n   \\n   reverse(order.begin(),order.begin() + order.size() - key);\\n   reverse(order.begin() ,order.end());\\n   reverse(order.begin(),order.begin() + key);\\n        while(temp!=NULL)temp->val = order[index++],temp=temp->next;\\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664174,
                "title": "my-clean-c-code-with-explanation",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head){\\n            return head;\\n        }\\n        int size = 1;\\n        //size started with one because we need to stop at temp not at temp->next\\n        ListNode* temp = head;\\n        while(temp->next){\\n            temp = temp->next;\\n            size++;\\n        }\\n        // making the list circular \\n        temp->next = head ;\\n        //making k less than the size of linked list\\n        k = k%size;\\n        // checking how many elements should be sent forward \\n        k = size-k;\\n        // running the while loop till k =0\\n         while(k--){\\n            temp = temp->next;\\n        }\\n        head = temp->next;\\n        temp->next = NULL;\\n        return head;\\n    }\\n        \\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head){\\n            return head;\\n        }\\n        int size = 1;\\n        //size started with one because we need to stop at temp not at temp->next\\n        ListNode* temp = head;\\n        while(temp->next){\\n            temp = temp->next;\\n            size++;\\n        }\\n        // making the list circular \\n        temp->next = head ;\\n        //making k less than the size of linked list\\n        k = k%size;\\n        // checking how many elements should be sent forward \\n        k = size-k;\\n        // running the while loop till k =0\\n         while(k--){\\n            temp = temp->next;\\n        }\\n        head = temp->next;\\n        temp->next = NULL;\\n        return head;\\n    }\\n        \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581632,
                "title": "c-beats-100-with-explaination",
                "content": "**Approach : We first find out the length of our linked list, here we can see that if our \"k\" value is lesser than the size of our linked list, let`s say our linked list is : 1->2->3->4->5 and \"k\" value is 2 then we append last 2 nodes at the beginning. So, our resultant linked list will become 4->5->1->2->3. In other case if our \"k\" value is greater than the length of our linked list then we only consider the (k % length) nodes from right because all the other (length=k) times rotations will simply return our original linked list. if we take our list as 1->2 and k = 3. Then after k = 1 rotations our linked list will become 2->1 and on further k=2 rotations our linked list will become 1->2(original list). Thus we will only rotate for length%k times from right. Here length =2 and k= 3, So , k % length = 1, there fore our final list will become 2->1.**\\n```\\nclass Solution {\\npublic:\\n    //Function to calculate the length of our linked list\\n    int length(ListNode *head){\\n        if(head==nullptr){\\n            return 0;\\n        }\\n        int count =1;\\n        while(head->next!=nullptr){\\n            head = head->next;\\n           count++;\\n        }\\n        return count;\\n    }\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       int len = length(head);\\n       ListNode* Newhead;\\n        if(head==nullptr || len==1){\\n            return head;\\n        }\\n        k = k % len;\\n        if(k==len || k==0){\\n            return head;\\n        }\\n            int n = len-k-1;\\n            ListNode* temp = head;\\n            while(temp->next!=nullptr){\\n                temp = temp->next;\\n            }\\n            ListNode* temp1 = head;\\n            for(int i=1;i<=n;i++){\\n                temp1 = temp1->next;\\n            }\\n        Newhead = temp1->next;\\n        temp1->next = nullptr;\\n            temp->next = head;\\n         return Newhead;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    //Function to calculate the length of our linked list\\n    int length(ListNode *head){\\n        if(head==nullptr){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1319291,
                "title": "clean-and-easy-java-solution",
                "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        if(head == null || head.next == null || k == 0) return head;\\n        \\n        ListNode curr = head;\\n        int length = 1;\\n        \\n\\t\\t// calculate the length of the LinkedList//\\n        while(curr.next != null) {\\n            curr = curr.next;\\n            length++;\\n        }\\n        \\n        curr.next = head;\\n\\t\\t// if the value of k is greater than length , we dont have to calculate that many times because if k = 5 we will end up having the same LinkedList// \\n\\t\\t//So to avoid that just modulo k with length//\\n\\t\\tk = k % length;\\n        k = length - k;\\n        while(k-->0) {\\n            curr = curr.next;\\n        }\\n\\t\\t// head->4->5 //\\n        head = curr.next;\\n\\t\\t// 1->2->3-> null //\\n        curr.next = null;\\n        \\n\\t\\t// head->4->5->1->2->3->null //\\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        if(head == null || head.next == null || k == 0) return head;\\n        \\n        ListNode curr = head;\\n        int length = 1;\\n        \\n\\t\\t// calculate the length of the LinkedList//\\n        while(curr.next != null) {\\n            curr = curr.next;\\n            length++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4060553,
                "title": "beginner-explanation-with-diagram",
                "content": "# Intuition\\n\\n![first.jpg](https://assets.leetcode.com/users/images/db16bc4e-a758-4fdc-ad89-6643f88850b2_1695049094.776298.jpeg)\\n\\n![second.jpg](https://assets.leetcode.com/users/images/8367aa8f-e20d-4dc0-8580-e211079a0981_1695049132.0701945.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next ==null || k==0 ) return head;\\n\\n        ListNode curr = head;\\n\\n        // step 1  -  calculate the  size of linked list\\n        int size = 1;\\n        while(curr.next!=null){\\n            size++;\\n            curr=curr.next;\\n        }\\n\\n        // step 2  -  pointer curr to head of LL\\n        \\n        curr.next = head;\\n\\n        k = k % size;\\n        k = size - k;\\n\\n        // step 3  -  move curr til k > 0 and make head to curr.next and curr.next = null;\\n\\n        while(k>0){\\n            curr=curr.next;\\n            k--;\\n        }\\n        \\n        // step - 4 \\n\\n        head=curr.next;\\n        curr.next = null;\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next ==null || k==0 ) return head;\\n\\n        ListNode curr = head;\\n\\n        // step 1  -  calculate the  size of linked list\\n        int size = 1;\\n        while(curr.next!=null){\\n            size++;\\n            curr=curr.next;\\n        }\\n\\n        // step 2  -  pointer curr to head of LL\\n        \\n        curr.next = head;\\n\\n        k = k % size;\\n        k = size - k;\\n\\n        // step 3  -  move curr til k > 0 and make head to curr.next and curr.next = null;\\n\\n        while(k>0){\\n            curr=curr.next;\\n            k--;\\n        }\\n        \\n        // step - 4 \\n\\n        head=curr.next;\\n        curr.next = null;\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943977,
                "title": "easy-c-solution-beats-100-users-0ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next||k==0)\\n        {\\n            return head;\\n        }\\n        ListNode* temp=head;\\n        int len=1;\\n        while(temp->next)\\n        {\\n            len++;\\n            temp=temp->next;\\n        }\\n        temp->next=head;\\n        k=k%len;\\n        k=len-k;\\n        while(k>0)\\n        {\\n            temp=temp->next;\\n            k--;\\n        }\\n        head=temp->next;\\n        temp->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next||k==0)\\n        {\\n            return head;\\n        }\\n        ListNode* temp=head;\\n        int len=1;\\n        while(temp->next)\\n        {\\n            len++;\\n            temp=temp->next;\\n        }\\n        temp->next=head;\\n        k=k%len;\\n        k=len-k;\\n        while(k>0)\\n        {\\n            temp=temp->next;\\n            k--;\\n        }\\n        head=temp->next;\\n        temp->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800460,
                "title": "clean-c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // edge cases\\n        if (!head || !head->next || !k) {\\n            return head;\\n        }\\n        // dummy curr\\n        ListNode* curr = head;\\n        // finding length\\n        int len = 1;\\n        while(curr->next) {\\n            curr = curr->next;\\n            ++len;\\n        }\\n        curr->next = head;\\n        // we will traverse from start instead so take len - k instead\\n        k = k % len;\\n        k = len - k;\\n        // lets start traversing\\n        while(k--) {\\n            curr = curr->next;\\n        }\\n        head = curr->next;\\n        curr->next = NULL;\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // edge cases\\n        if (!head || !head->next || !k) {\\n            return head;\\n        }\\n        // dummy curr\\n        ListNode* curr = head;\\n        // finding length\\n        int len = 1;\\n        while(curr->next) {\\n            curr = curr->next;\\n            ++len;\\n        }\\n        curr->next = head;\\n        // we will traverse from start instead so take len - k instead\\n        k = k % len;\\n        k = len - k;\\n        // lets start traversing\\n        while(k--) {\\n            curr = curr->next;\\n        }\\n        head = curr->next;\\n        curr->next = NULL;\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262985,
                "title": "java-0ms-100-faster-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null ||k==0) return head;\\n        \\n        ListNode cur=head;\\n        int len=1;\\n        while(cur.next!=null){\\n            len++;\\n            cur=cur.next;\\n        }\\n\\n        cur.next=head;\\n        k=k%len;\\n        k=len-k;\\n        while(k!=0){\\n            cur=cur.next;\\n            k--;\\n        } \\n\\n        head=cur.next;\\n        cur.next=null;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null ||k==0) return head;\\n        \\n        ListNode cur=head;\\n        int len=1;\\n        while(cur.next!=null){\\n            len++;\\n            cur=cur.next;\\n        }\\n\\n        cur.next=head;\\n        k=k%len;\\n        k=len-k;\\n        while(k!=0){\\n            cur=cur.next;\\n            k--;\\n        } \\n\\n        head=cur.next;\\n        cur.next=null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207879,
                "title": "java-0ms-100-simple-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode tem1 = head;\\n        int count = 0;\\n        while(tem1 != null)\\n        {\\n            count++;\\n            tem1 = tem1.next;\\n        }\\n        if(k==0 || head==null)\\n        return head;\\n        k = k % count;\\n        int m = count - k;\\n        int m1 = m;\\n        ListNode tem2 = head;\\n        ListNode tem3 = new ListNode(-1);\\n        ListNode ans = tem3;\\n        ListNode first = new ListNode(-1);\\n        ListNode fir = first;\\n        while(m-- > 0)\\n        {\\n            first.next = new ListNode(tem2.val);\\n            tem2 = tem2.next;\\n            first = first.next;\\n        }\\n        while(tem2 != null)\\n        {\\n            tem3.next = tem2;\\n            tem2 = tem2.next;\\n            tem3 = tem3.next;\\n        }\\n        ListNode tem4 = head;\\n        tem3.next = fir.next;\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode tem1 = head;\\n        int count = 0;\\n        while(tem1 != null)\\n        {\\n            count++;\\n            tem1 = tem1.next;\\n        }\\n        if(k==0 || head==null)\\n        return head;\\n        k = k % count;\\n        int m = count - k;\\n        int m1 = m;\\n        ListNode tem2 = head;\\n        ListNode tem3 = new ListNode(-1);\\n        ListNode ans = tem3;\\n        ListNode first = new ListNode(-1);\\n        ListNode fir = first;\\n        while(m-- > 0)\\n        {\\n            first.next = new ListNode(tem2.val);\\n            tem2 = tem2.next;\\n            first = first.next;\\n        }\\n        while(tem2 != null)\\n        {\\n            tem3.next = tem2;\\n            tem2 = tem2.next;\\n            tem3 = tem3.next;\\n        }\\n        ListNode tem4 = head;\\n        tem3.next = fir.next;\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138302,
                "title": "clean-optimized-java-sol-0ms-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N) + O(N-(k%N)) --> O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n      if(head==null || head.next==null || k==0)  return head;\\n\\n      ListNode curr = head;  int len=1;\\n      while(curr.next!=null){\\n          len++;  curr = curr.next;     //counting the length of list.\\n      }\\n      curr.next = head;                 // joining last node to first making it a circular list.\\n      k = len-(k%len);                  // doing K%len as any rotation in multiple of len will give same list.Ex- k=12 and len is 5 then we need\\n                                        // to rotate 2 times.  len-(k%len) is to go till node from start to node where we have to break list.\\n                                      \\n      while(k>0){\\n          curr = curr.next;\\n          k--;\\n      }\\n      head = curr.next;                  // making new head which will be the node after the breaking point;\\n      curr.next = null;                  // now curr is the last node with its next value as null.\\n      return head;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n      if(head==null || head.next==null || k==0)  return head;\\n\\n      ListNode curr = head;  int len=1;\\n      while(curr.next!=null){\\n          len++;  curr = curr.next;     //counting the length of list.\\n      }\\n      curr.next = head;                 // joining last node to first making it a circular list.\\n      k = len-(k%len);                  // doing K%len as any rotation in multiple of len will give same list.Ex- k=12 and len is 5 then we need\\n                                        // to rotate 2 times.  len-(k%len) is to go till node from start to node where we have to break list.\\n                                      \\n      while(k>0){\\n          curr = curr.next;\\n          k--;\\n      }\\n      head = curr.next;                  // making new head which will be the node after the breaking point;\\n      curr.next = null;                  // now curr is the last node with its next value as null.\\n      return head;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060311,
                "title": "c-92-faster-easy-approach-o-n-o-1",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head -> next || k == 0)\\n            return head;\\n        int size = 1;\\n        ListNode* tail = head;\\n        while(tail->next){\\n            tail = tail -> next;\\n            size++;\\n        }\\n\\n        int rotate = k%size;\\n        if(rotate == 0)\\n            return head;\\n            \\n        tail -> next = head;\\n        rotate = size - rotate - 1;\\n        ListNode* temp = head;\\n\\n        while(rotate--){\\n            temp = temp -> next;\\n        }\\n        ListNode* forward = temp->next;\\n        temp -> next = NULL;\\n\\n        return forward;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head -> next || k == 0)\\n            return head;\\n        int size = 1;\\n        ListNode* tail = head;\\n        while(tail->next){\\n            tail = tail -> next;\\n            size++;\\n        }\\n\\n        int rotate = k%size;\\n        if(rotate == 0)\\n            return head;\\n            \\n        tail -> next = head;\\n        rotate = size - rotate - 1;\\n        ListNode* temp = head;\\n\\n        while(rotate--){\\n            temp = temp -> next;\\n        }\\n        ListNode* forward = temp->next;\\n        temp -> next = NULL;\\n\\n        return forward;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890931,
                "title": "o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       if(!head)return head;\\n       ListNode*ptr=head;\\n        int n=1;\\n        while(ptr->next){\\n            ptr=ptr->next;\\n            n++;\\n         }\\n        k=k%n;\\n        if( k==0 || n==1)return head;\\n        int s=n-k;//where the list is cut it out\\n        ListNode*ptr1=NULL;\\n        ListNode*ptr2=head;\\n        while(s--){\\n            ptr1=ptr2;\\n            ptr2=ptr2->next;\\n        }\\n        ptr->next=head;\\n        ptr1->next=NULL;\\n      return ptr2;\\n    }    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       if(!head)return head;\\n       ListNode*ptr=head;\\n        int n=1;\\n        while(ptr->next){\\n            ptr=ptr->next;\\n            n++;\\n         }\\n        k=k%n;\\n        if( k==0 || n==1)return head;\\n        int s=n-k;//where the list is cut it out\\n        ListNode*ptr1=NULL;\\n        ListNode*ptr2=head;\\n        while(s--){\\n            ptr1=ptr2;\\n            ptr2=ptr2->next;\\n        }\\n        ptr->next=head;\\n        ptr1->next=NULL;\\n      return ptr2;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673151,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(!head || !head->next ||k==0)\\n        {\\n            return head;\\n        }\\n        ListNode *curr=head;\\n        int count=1;\\n        while(curr->next && ++count)\\n        {\\n            curr=curr->next;\\n        }\\n        curr->next=head;\\n        k=k%count;\\n        k=count-k;\\n        while(k--)\\n        {\\n            curr=curr->next;\\n        }\\n        head=curr->next;\\n        curr->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(!head || !head->next ||k==0)\\n        {\\n            return head;\\n        }\\n        ListNode *curr=head;\\n        int count=1;\\n        while(curr->next && ++count)\\n        {\\n            curr=curr->next;\\n        }\\n        curr->next=head;\\n        k=k%count;\\n        k=count-k;\\n        while(k--)\\n        {\\n            curr=curr->next;\\n        }\\n        head=curr->next;\\n        curr->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565572,
                "title": "java-o-n-complexity-o-1-space",
                "content": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        if(head == null)\\n            return head;\\n        \\n        int len= findLength(head);\\n        k = k % len ;\\n        \\n        if( k ==0 )\\n            return head;\\n        \\n        ListNode temp = head;\\n        \\n        for(int i=1; i<len-k; i++){\\n            temp = temp.next;\\n        }\\n        \\n        ListNode store = temp.next;\\n        temp.next = null;\\n        \\n        temp =  store;\\n        \\n        while(temp.next != null){\\n            temp = temp.next;\\n        }\\n        \\n        temp.next = head;\\n       return store;\\n    }\\n    \\n    int findLength(ListNode head){\\n        int len = 0;\\n        \\n        while(head!= null ){\\n            len ++;\\n            head = head.next;\\n        }\\n        \\n        return len;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        if(head == null)\\n            return head;\\n        \\n        int len= findLength(head);\\n        k = k % len ;\\n        \\n        if( k ==0 )\\n            return head;\\n        \\n        ListNode temp = head;\\n        \\n        for(int i=1; i<len-k; i++){\\n            temp = temp.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2378138,
                "title": "easy-c-bring-the-tail-ahead-clean-fast-and-efficient-code-o-n-tc-o-1-sc",
                "content": "The idea is to reach the **\\'starting point of tail\\'** and point it to the **head** of the linked list. During this process, we also need to store the node \\'just before tail\\' and point it to **\\'null\\'**. That\\'s all. \\nFeel free to ask me anything in the comments below.\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) { \\n\\t    // base cases\\n        if (!head)                             \\n            return head;\\n        else if (!head -> next)\\n            return head;\\n\\t\\t\\t\\n\\t\\t// counting the nodes in linked list\\n        int count = 0;                 \\n        ListNode *temp = head;\\n        while (temp){\\n            temp = temp -> next;\\n            count++;\\n        }\\n\\t\\t\\n\\t\\t// some more base cases\\n        if (k >= count)         // if you need to rotate the list more times than number of number of nodes present\\n            k %= count;        // then reduce the k to an equivalent number less than count (the remainder)\\n        if (k == 0)\\n            return head;\\n\\t\\t\\t\\n        ListNode * previous = nullptr, *current = head;    \\n\\t\\t// reaching the  starting point of tail\\n        for (int i = 0; current != nullptr && i < count-k; i++){       \\n            previous = current;\\n            current = current -> next;\\n        }\\n\\t\\t\\n        ListNode *lastNodeOfSecondPart = current;\\n\\t\\t// connecting the end to the start\\n        for (int i = 0; lastNodeOfSecondPart != nullptr &&  i < k-1; i++)\\n            lastNodeOfSecondPart = lastNodeOfSecondPart -> next;\\n        lastNodeOfSecondPart -> next = head;\\n\\t\\t\\n\\t\\t// point node just before tail to null\\n        previous -> next = nullptr;\\n\\t\\t\\n\\t\\t// return the current node\\n        return current;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) { \\n\\t    // base cases\\n        if (!head)                             \\n            return head;\\n        else if (!head -> next)\\n            return head;\\n\\t\\t\\t\\n\\t\\t// counting the nodes in linked list\\n        int count = 0;                 \\n        ListNode *temp = head;\\n        while (temp){\\n            temp = temp -> next;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2118203,
                "title": "c-easy-soln-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL ||k==0) return head;\\n        \\n        ListNode* cur = head;\\n        int len =1;\\n        while(cur->next){\\n            len++;\\n            cur=cur->next;\\n        }\\n        cur->next=head;\\n        k=k%len;\\n        k = len-k;\\n        while(k--)\\n            cur=cur->next;\\n        \\n        head=cur->next;\\n        cur->next=NULL;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL ||k==0) return head;\\n        \\n        ListNode* cur = head;\\n        int len =1;\\n        while(cur->next){\\n            len++;\\n            cur=cur->next;\\n        }\\n        cur->next=head;\\n        k=k%len;\\n        k = len-k;\\n        while(k--)\\n            cur=cur->next;\\n        \\n        head=cur->next;\\n        cur->next=NULL;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868989,
                "title": "java-c-o-n-simple-to-understand-with-diagrammatic-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/bc6fee45-30b8-4e82-8455-5e1d7b48d782_1647833259.269898.png)\\n![image](https://assets.leetcode.com/users/images/4dac0e08-6ed7-4d4c-9384-663577277c6c_1647833836.224485.jpeg)\\n\\n\\nclass Solution {\\n  \\n    \\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        \\n        if(head == null){\\n            return head;\\n        }\\n        \\n        //First total length of linked list is calculated\\n        int size = 0;\\n    \\n        ListNode curr = head;\\n        \\n        while(curr!=null){\\n            size++;\\n            curr = curr.next;\\n            \\n        }\\n        \\n        \\n        if(size == 1 || k==0 || k%size == 0){\\n            return head;\\n        }\\n        \\n        curr = head;\\n        ListNode temp1 =  curr;\\n        \\n        //This will handle the case if k>size\\n        int n = k%size;\\n        \\n        //Traversing till the kth value \\n        int i = 0;\\n        while(i<size-n-1){\\n            \\n            curr = curr.next;\\n            i++;\\n        }\\n        \\n        //temp2 will store the last element till k where we have to break the linked list ;\\n         ListNode temp2 = curr;\\n        \\n        \\n        //Creating a dummy node that will store the part whuch is to be rotated\\n        ListNode dummy = new ListNode(-1);\\n        ListNode temp  = dummy;//to store the initial position of dummy node;\\n        \\n        //traversing till the last element and attaching with dummy\\n        while(curr.next!=null){\\n            dummy.next = curr.next;\\n            dummy = curr.next;\\n            curr = curr.next;\\n        }\\n        \\n        //joining the last element with the first element\\n        curr.next = temp1;\\n        \\n        //breaking at the kth position;\\n        temp2.next = null;\\n        \\n        return temp.next;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n  \\n    \\n    public ListNode rotateRight(ListNode head, int k) {\\n        \\n        \\n        if(head == null){\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1839874,
                "title": "python-t-o-n-s-o-1-simple-comments",
                "content": "```\\n\\'\\'\\'\\n1. Approach is to link last node with first node\\n2. Then disconnect at a point size of the list - k\\n\\nExample : 1->2->3-4>5  , k = 2\\n\\n step 1 ,  1->2->3->4->5\\n           ^___________|\\n\\nlink the last index with first\\n\\n\\nstep 2,    1->2->3  x 4->5\\n           ^_____________|\\n\\ncut the link at size-k th index \\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head or not k:\\n            return head\\n        # capture the length of the list\\n        copy = head\\n        size = 1\\n        while copy.next:\\n            size+=1\\n            copy = copy.next\\n        # sometimes k > size, in such case perform modulo to reduce the value\\n        k = k%size if k>=size else k\\n        # k = 0 means performing rotation will bring same arrangement, hence return head\\n        if k==0:\\n            return head\\n        else:\\n            copy.next = head\\n        \\n        # move to a point where we need to cut the link\\n        ctr = 1\\n        while ctr<size-k:\\n            head = head.next\\n            ctr+=1\\n        # store the value to return and remove the link\\n        temp = head.next\\n        head.next = None\\n        return temp\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n\\'\\'\\'\\n1. Approach is to link last node with first node\\n2. Then disconnect at a point size of the list - k\\n\\nExample : 1->2->3-4>5  , k = 2\\n\\n step 1 ,  1->2->3->4->5\\n           ^___________|\\n\\nlink the last index with first\\n\\n\\nstep 2,    1->2->3  x 4->5\\n           ^_____________|\\n\\ncut the link at size-k th index \\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head or not k:\\n            return head\\n        # capture the length of the list\\n        copy = head\\n        size = 1\\n        while copy.next:\\n            size+=1\\n            copy = copy.next\\n        # sometimes k > size, in such case perform modulo to reduce the value\\n        k = k%size if k>=size else k\\n        # k = 0 means performing rotation will bring same arrangement, hence return head\\n        if k==0:\\n            return head\\n        else:\\n            copy.next = head\\n        \\n        # move to a point where we need to cut the link\\n        ctr = 1\\n        while ctr<size-k:\\n            head = head.next\\n            ctr+=1\\n        # store the value to return and remove the link\\n        temp = head.next\\n        head.next = None\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839705,
                "title": "java-100",
                "content": "\\tclass Solution {\\n\\t\\tpublic ListNode rotateRight(ListNode head, int k) {\\n\\t\\t\\tif(head==null) return null;\\n\\t\\t\\tint l=0;ListNode h=head;\\n\\t\\t\\tListNode last=null;\\n\\t\\t\\twhile(h!=null){\\n\\t\\t\\t\\tlast=h;\\n\\t\\t\\t\\th=h.next;l++;\\n\\t\\t\\t}\\n\\t\\t\\tk=k%l;\\n\\t\\t\\tk=l-k;\\n\\t\\t\\th=head;\\n\\t\\t\\twhile(k-->1){\\n\\t\\t\\t\\th=h.next;\\n\\t\\t\\t}\\n\\t\\t\\tlast.next=head;\\n\\t\\t\\thead=h.next;\\n\\t\\t\\th.next=null;\\n\\t\\t\\treturn head;\\n\\n\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic ListNode rotateRight(ListNode head, int k) {\\n\\t\\t\\tif(head==null) return null;\\n\\t\\t\\tint l=0;ListNode h=head;\\n\\t\\t\\tListNode last=null;\\n\\t\\t\\twhile(h!=null){\\n\\t\\t\\t\\tlast=h;\\n\\t\\t\\t\\th=h.next;l++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1839646,
                "title": "very-easy-solution-with-hand-written-steps",
                "content": "\\n![image](https://assets.leetcode.com/users/images/0b7c5a19-711d-4919-af67-8ec13a74acd0_1647002665.5356383.jpeg)\\n![image](https://assets.leetcode.com/users/images/c968364a-521f-463f-af31-2ff047ada9e5_1647002691.5484843.jpeg)\\n\\n\\n```\\n\\nclass Solution {\\n    public int getLength(ListNode head){\\n        int len=0;\\n        while(head!=null){\\n            len++;\\n            head=head.next;\\n        }\\n          \\n        \\n        return len;\\n    }\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)return null;\\n        int len=getLength(head);\\n        k=k%len;\\n        ListNode fast=head,slow=head;\\n        while(k!=0){\\n           fast=fast.next;\\n            k--;\\n        }\\n            \\n        \\n        while(fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next;\\n        }\\n        fast.next=head;\\n        head=slow.next;\\n        slow.next=null;\\n        \\n        return head;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int getLength(ListNode head){\\n        int len=0;\\n        while(head!=null){\\n            len++;\\n            head=head.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1838559,
                "title": "c-easy-to-understand-with-image-and-proper-explanation",
                "content": "# Daily Challenge:-11/03/2022.\\n**Approach:**-Apply Following steps:\\n-->Count the number of Nodes in Link-List.\\n-->Find the end of Link-List and name it as tail.\\n-->Update K by k= k%Node_count.\\n-->If updated k is 0 then return same Link-List.\\n\\n**Otherwise :-**\\n-->Break the Link List from (k)th node from end.\\n-->Attach the next of the tail to head of Link-List.\\n-->Make that k th node from end as new head of Link-Lis\\n-->return that head.\\n\\n***Understand the Concept From Image:-***\\n![image](https://assets.leetcode.com/users/images/a9cc929a-ef56-45a5-a559-10c5137a9900_1646975087.9075916.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||head->next==NULL) //If this simply return head.\\n            return head;\\n        \\n        int Node_count=0; //Keep Node Count.\\n        ListNode* curr=head; \\n        ListNode* tail=NULL; //Keep the record of end of given Link-List.\\n        ListNode* new_head; //Keep the record of new head.\\n        while(curr!=NULL)\\n        {\\n            Node_count++;\\n            tail=curr; //Keep the record of tail.\\n            curr=curr->next;\\n        }\\n        \\n        if(k%Node_count==0) //If this means no rotation is necessary.\\n            return head;\\n        \\n        k=k%Node_count; // Actual rotation require. -->Updated k.\\n        int count=0; // it will keep the record of  kth node from end.\\n        curr=head; //For calculation.\\n        while(true)\\n        {\\n          count++; //Increment the count.\\n            if(count==Node_count-k) //If we find k th node from end (cuur->next is our kth node from end ,means curr is one node before it.)\\n            {\\n                new_head=curr->next; //Update our new head, with kth node from end.\\n                curr->next=NULL; //MAke the curr-Next null.\\n                tail->next=head; //Attach head to next of tail.\\n                head=new_head; //Update the head with new head.\\n                break; //Break the Loop\\n            }\\n            curr=curr->next; //Jump to next node\\n        }\\n        \\n        return head; //Return the Updated head.\\n    }\\n};\\n```\\nIf you find it helpful . Please Upvote .",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||head->next==NULL) //If this simply return head.\\n            return head;\\n        \\n        int Node_count=0; //Keep Node Count.\\n        ListNode* curr=head; \\n        ListNode* tail=NULL; //Keep the record of end of given Link-List.\\n        ListNode* new_head; //Keep the record of new head.\\n        while(curr!=NULL)\\n        {\\n            Node_count++;\\n            tail=curr; //Keep the record of tail.\\n            curr=curr->next;\\n        }\\n        \\n        if(k%Node_count==0) //If this means no rotation is necessary.\\n            return head;\\n        \\n        k=k%Node_count; // Actual rotation require. -->Updated k.\\n        int count=0; // it will keep the record of  kth node from end.\\n        curr=head; //For calculation.\\n        while(true)\\n        {\\n          count++; //Increment the count.\\n            if(count==Node_count-k) //If we find k th node from end (cuur->next is our kth node from end ,means curr is one node before it.)\\n            {\\n                new_head=curr->next; //Update our new head, with kth node from end.\\n                curr->next=NULL; //MAke the curr-Next null.\\n                tail->next=head; //Attach head to next of tail.\\n                head=new_head; //Update the head with new head.\\n                break; //Break the Loop\\n            }\\n            curr=curr->next; //Jump to next node\\n        }\\n        \\n        return head; //Return the Updated head.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838466,
                "title": "c-3-approaches-full-explanation-o-n-simple",
                "content": "```\\n//We can use array to rotate the linked list.\\n//Time complexity: O(N)\\n//Space complexity: O(N)\\n\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL){\\n            return 0;\\n        }\\n        vector<int> nums;\\n        ListNode* node=head;\\n        while(node){\\n            nums.push_back(node->val);\\n            node=node->next;\\n        }\\n        k=k%nums.size();\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n        node=head;\\n        int i=0;\\n        while(node){\\n            node->val=nums[i++];\\n            node=node->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/66fec479-dac2-4495-8d05-7ca2b5327046_1646972684.798328.jpeg)\\n\\n```\\n//Another approach is to \\n//1. Reverse the full list\\n//2. reverse first k size list\\n//3. reverse remaning list i:e (n-k)\\n//You will get the result\\n//Time complexity: O(N)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    //Reverse a linked list\\n    ListNode* reverseList(ListNode* root) {\\n        ListNode* prev = NULL;\\n        ListNode* curr = root;\\n        while (curr != NULL) {\\n            ListNode* nextTemp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nextTemp;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        //If the node is NULL\\n        if(head==NULL)\\n            return 0;\\n        \\n        //Calculate the length of linked list\\n        \\n        ListNode* newhead = head;\\n        int length=0;\\n        while(newhead!=NULL){\\n            length++;\\n            newhead=newhead->next;\\n        }\\n        \\n        \\n        k = k%length;\\n        if(k==0)\\n            return head;\\n        \\n        //Reverse list\\n        head=reverseList(head);\\n        \\n        //Find the kth node \\n        ListNode* kthnode=head;\\n        while(k>1 && kthnode){\\n            kthnode=kthnode->next;\\n            k--;\\n        }\\n\\n        if(kthnode==NULL || kthnode->next==NULL)\\n            return head;\\n        \\n        //Reverse second list\\n        ListNode* secondhalf=reverseList(kthnode->next);\\n        kthnode->next=NULL;\\n        \\n        //Reverse first list\\n        ListNode* firsthalfend=reverseList(head);\\n        ListNode* result=firsthalfend;\\n        \\n        //Link firlt list to second list\\n        while(firsthalfend && firsthalfend->next){\\n            firsthalfend=firsthalfend->next;\\n        }\\n        firsthalfend->next=secondhalf;\\n        \\n        return result;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/5d8db2bc-2985-4351-9e87-7dd7336d07b0_1646972712.8995314.jpeg)\\n\\n```\\n//Another approach is to make list cyclic\\n//Time complexity: O(N)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        int length = 0;\\n        ListNode* newhead = head;\\n        while(newhead!=NULL){\\n            length++;\\n            if(newhead->next==NULL){\\n                newhead->next=head;\\n                break;\\n            }\\n            newhead=newhead->next;\\n        }\\n        k = length - k%length;\\n        for(int i=0;i<k;i++){\\n            newhead=newhead->next;\\n        }\\n        head=newhead->next;\\n        newhead->next=NULL;\\n        return head;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/17287e7c-db7e-4dfc-861f-92b396321022_1646972720.9260263.jpeg)\\n\\n**Please upvote if you like the solution**\\n\\nCheck my git hub repo: [Link](https://t.co/fWekOVcKHC)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//We can use array to rotate the linked list.\\n//Time complexity: O(N)\\n//Space complexity: O(N)\\n\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL){\\n            return 0;\\n        }\\n        vector<int> nums;\\n        ListNode* node=head;\\n        while(node){\\n            nums.push_back(node->val);\\n            node=node->next;\\n        }\\n        k=k%nums.size();\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n        node=head;\\n        int i=0;\\n        while(node){\\n            node->val=nums[i++];\\n            node=node->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\n//Another approach is to \\n//1. Reverse the full list\\n//2. reverse first k size list\\n//3. reverse remaning list i:e (n-k)\\n//You will get the result\\n//Time complexity: O(N)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    //Reverse a linked list\\n    ListNode* reverseList(ListNode* root) {\\n        ListNode* prev = NULL;\\n        ListNode* curr = root;\\n        while (curr != NULL) {\\n            ListNode* nextTemp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nextTemp;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        //If the node is NULL\\n        if(head==NULL)\\n            return 0;\\n        \\n        //Calculate the length of linked list\\n        \\n        ListNode* newhead = head;\\n        int length=0;\\n        while(newhead!=NULL){\\n            length++;\\n            newhead=newhead->next;\\n        }\\n        \\n        \\n        k = k%length;\\n        if(k==0)\\n            return head;\\n        \\n        //Reverse list\\n        head=reverseList(head);\\n        \\n        //Find the kth node \\n        ListNode* kthnode=head;\\n        while(k>1 && kthnode){\\n            kthnode=kthnode->next;\\n            k--;\\n        }\\n\\n        if(kthnode==NULL || kthnode->next==NULL)\\n            return head;\\n        \\n        //Reverse second list\\n        ListNode* secondhalf=reverseList(kthnode->next);\\n        kthnode->next=NULL;\\n        \\n        //Reverse first list\\n        ListNode* firsthalfend=reverseList(head);\\n        ListNode* result=firsthalfend;\\n        \\n        //Link firlt list to second list\\n        while(firsthalfend && firsthalfend->next){\\n            firsthalfend=firsthalfend->next;\\n        }\\n        firsthalfend->next=secondhalf;\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Another approach is to make list cyclic\\n//Time complexity: O(N)\\n//Space complexity: O(1)\\n\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        int length = 0;\\n        ListNode* newhead = head;\\n        while(newhead!=NULL){\\n            length++;\\n            if(newhead->next==NULL){\\n                newhead->next=head;\\n                break;\\n            }\\n            newhead=newhead->next;\\n        }\\n        k = length - k%length;\\n        for(int i=0;i<k;i++){\\n            newhead=newhead->next;\\n        }\\n        head=newhead->next;\\n        newhead->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838446,
                "title": "easy-cycle-link-list-approach-o-n-solution",
                "content": "\\n     if(head==NULL || head->next==NULL || k==0){\\n           return head;\\n       }\\n        int n=1; \\n        ListNode*temp=head->next;\\n        ListNode* he=head;\\n        ListNode* curr=head;\\n        while(curr->next!=NULL){\\n            n++;\\n            curr=curr->next;\\n        }\\n        curr->next=head;\\n        k=k%n;\\n        k=n-k-1;\\n        while(k!=0){\\n            he=he->next;\\n            temp=temp->next;\\n            k--;\\n        }\\n        he->next=NULL;\\n        \\n       \\n        return temp;\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "\\n     if(head==NULL || head->next==NULL || k==0){\\n           return head;\\n       }\\n        int n=1; \\n        ListNode*temp=head->next;\\n        ListNode* he=head;\\n        ListNode* curr=head;\\n        while(curr->next!=NULL){\\n            n++;\\n            curr=curr->next;\\n        }\\n        curr->next=head;\\n        k=k%n;\\n        k=n-k-1;\\n        while(k!=0){\\n            he=he->next;\\n            temp=temp->next;\\n            k--;\\n        }\\n        he->next=NULL;\\n        \\n       \\n        return temp;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1431369,
                "title": "c-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        \\n        if (!head || !head->next) \\n            return head;\\n       \\n        ListNode* p = head;\\n        ListNode* res;\\n        int l = 1;\\n        \\n        while(p->next != NULL) {\\n            l++; \\n            p = p->next; \\n        }\\n        \\n        k = k%l;\\n        int x = l-k;\\n        \\n        p->next = head;\\n        \\n        while(x--)\\n            p = p->next;\\n        \\n        res = p->next;\\n        p->next = NULL;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        \\n        if (!head || !head->next) \\n            return head;\\n       \\n        ListNode* p = head;\\n        ListNode* res;\\n        int l = 1;\\n        \\n        while(p->next != NULL) {\\n            l++; \\n            p = p->next; \\n        }\\n        \\n        k = k%l;\\n        int x = l-k;\\n        \\n        p->next = head;\\n        \\n        while(x--)\\n            p = p->next;\\n        \\n        res = p->next;\\n        p->next = NULL;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391679,
                "title": "95-time-o-n-space-o-1",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n\\n**Explanation :-**\\n1. Count the total number of nodes present in the original list.\\n2. Traverse (count - k) times and maintain a prev pointer which will keep track of the previous node.\\n3. After traversing , we will reach at the position from where we need to rotate the list.\\n4. Store reference of that node using curr pointer.\\n5. Now, traverse till end of the list and the last node will point to the start of the original list or the head of the list. \\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head -> next == NULL)\\n        {\\n            return head;\\n        }\\n        ListNode* temp = head;\\n        ListNode* prev;\\n        int i = 0 , count = 0;\\n        while(temp != NULL) // Count total nodes\\n        {\\n            temp = temp -> next;\\n            count++;\\n        }\\n        temp = head;\\n        k = k % count;\\n        while(temp != NULL && i < count - k) // Reach at the node from where we want to rotate\\n        {\\n            i++;\\n            prev = temp;\\n            temp = temp -> next;\\n        }\\n        if(temp == NULL)\\n        {\\n            return head;\\n        }\\n        ListNode* curr = temp; // curr wil hold the start of the list\\n        prev -> next = NULL; // Previous node of temp i.e. prev will point to NULL\\n        while(temp -> next != NULL)\\n        {\\n            temp = temp -> next;\\n        }\\n        temp -> next = head; // Last node will point to start to the original list\\n       return curr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head -> next == NULL)\\n        {\\n            return head;\\n        }\\n        ListNode* temp = head;\\n        ListNode* prev;\\n        int i = 0 , count = 0;\\n        while(temp != NULL) // Count total nodes\\n        {\\n            temp = temp -> next;\\n            count++;\\n        }\\n        temp = head;\\n        k = k % count;\\n        while(temp != NULL && i < count - k) // Reach at the node from where we want to rotate\\n        {\\n            i++;\\n            prev = temp;\\n            temp = temp -> next;\\n        }\\n        if(temp == NULL)\\n        {\\n            return head;\\n        }\\n        ListNode* curr = temp; // curr wil hold the start of the list\\n        prev -> next = NULL; // Previous node of temp i.e. prev will point to NULL\\n        while(temp -> next != NULL)\\n        {\\n            temp = temp -> next;\\n        }\\n        temp -> next = head; // Last node will point to start to the original list\\n       return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337678,
                "title": "java-solution-100-o-n",
                "content": "```\\n public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || head.next==null || k==0) return head;\\n        int len =0;\\n        \\n        ListNode node = head;\\n        while(node!=null){\\n            node = node.next;\\n            len++;\\n        }\\n        \\n        k = k%len;\\n        \\n        if(k==0){\\n            return head;\\n        }\\n        node = head;\\n        for(int i=1;i<len-k;i++){\\n            node = node.next;\\n        }\\n        \\n        ListNode temp =node.next;\\n        node.next = null;\\n        node = temp;\\n        \\n        while(temp.next!=null){\\n            temp = temp.next;\\n        }\\n        \\n        temp.next =head;\\n        return node;\\n        \\n        \\n    }\\n```\\n\\nTime complexity: O(N)\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || head.next==null || k==0) return head;\\n        int len =0;\\n        \\n        ListNode node = head;\\n        while(node!=null){\\n            node = node.next;\\n            len++;\\n        }\\n        \\n        k = k%len;\\n        \\n        if(k==0){\\n            return head;\\n        }\\n        node = head;\\n        for(int i=1;i<len-k;i++){\\n            node = node.next;\\n        }\\n        \\n        ListNode temp =node.next;\\n        node.next = null;\\n        node = temp;\\n        \\n        while(temp.next!=null){\\n            temp = temp.next;\\n        }\\n        \\n        temp.next =head;\\n        return node;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1164698,
                "title": "python3-simple-solution-using-circular-linked-list-with-figure-explanation",
                "content": "**Idea**\\nAssuming the length of linked list is `size`, rotate the list to the right by `k` places\\n- After `size` times rotation, the list is same as the original list\\n\\t- Therefore, we just need to perform `k = k % size` rotations\\n- Rotation of list to the right by `k` places is equivalent to \\n\\t1. Connect the tail and head of the list to create a circular list\\n\\t2. Split list after the (`size-k`)-th node\\n\\n**Implementation**\\n```python\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        # If list is empty or contains only one element,\\n        # no need to rotate\\n        if not head or not head.next:\\n            return head\\n        \\n        # Iterate to the list tail and get list size\\n        cur = head\\n        size = 1\\n        while cur.next:\\n            size += 1\\n            cur = cur.next \\n            \\n        # Compute the actual number that need to be rotated\\n        k %= size\\n        # If k = n * size, then no need to rotate\\n        if k == 0:\\n            return head\\n        \\n        # Connect tail and head to create a circular list\\n        cur.next = head \\n        \\n        # Iterate to the node which should be the new tail after rotation,\\n        # and split the list \\n        cur = head\\n        for _ in range(size - k - 1):\\n            cur = cur.next\\n        new_head = cur.next\\n        cur.next = None\\n        \\n        return new_head\\n```\\n\\n**Visualization**\\n`k = 2`\\n![image](https://assets.leetcode.com/users/images/7afc23b3-6827-4e82-bdc5-15df448b8ae4_1618738444.142348.png)\\n\\n**Complexity**\\n- Time: O(n)\\n- Space: O(1)\\n\\n\\n\\nIf you think this is helpful, please give it a vote.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        # If list is empty or contains only one element,\\n        # no need to rotate\\n        if not head or not head.next:\\n            return head\\n        \\n        # Iterate to the list tail and get list size\\n        cur = head\\n        size = 1\\n        while cur.next:\\n            size += 1\\n            cur = cur.next \\n            \\n        # Compute the actual number that need to be rotated\\n        k %= size\\n        # If k = n * size, then no need to rotate\\n        if k == 0:\\n            return head\\n        \\n        # Connect tail and head to create a circular list\\n        cur.next = head \\n        \\n        # Iterate to the node which should be the new tail after rotation,\\n        # and split the list \\n        cur = head\\n        for _ in range(size - k - 1):\\n            cur = cur.next\\n        new_head = cur.next\\n        cur.next = None\\n        \\n        return new_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884232,
                "title": "python-tricky-but-neat-solution-with-explanation",
                "content": "The little trick here is to put the `tail` back to `head` so that the list becomes a circle. \\nThen we just need to find the cut point and change the circle back to normal list, which is the final result.\\n\\nFor example: given list `[1, 2, 3, 4, 5]` and `k=2`, \\n- put list tail back to head, we get an unlimited list `[..., 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...]` and origin list length = 5.\\n- find correct cut point, 5 - 2 = 3, thus we cut at the third place,  `[..., 1, 2, 3, |4, 5, 1, 2, 3,| 4, 5, ...]`. The circle list becomes back to normal list: `[4, 5, 1, 2, 3]`.\\n\\n```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if not head:\\n            return \\n        \\n        runner = head\\n        length = 1\\n        while runner.next:\\n            runner = runner.next\\n            length += 1\\n\\t\\t# KEY: put the tail back to head so that the list becomes a circle.\\n        runner.next = head\\n        \\n        for i in range(length - k % length - 1):\\n            head = head.next\\n\\t\\t\\t\\n        # Cut the circle list at `head`.\\n        ans, head.next = head.next, None\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if not head:\\n            return \\n        \\n        runner = head\\n        length = 1\\n        while runner.next:\\n            runner = runner.next\\n            length += 1\\n\\t\\t# KEY: put the tail back to head so that the list becomes a circle.\\n        runner.next = head\\n        \\n        for i in range(length - k % length - 1):\\n            head = head.next\\n\\t\\t\\t\\n        # Cut the circle list at `head`.\\n        ans, head.next = head.next, None\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883266,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (!head)\\n            return NULL;\\n        \\n        ListNode *cur = head;\\n        int len = 1;        \\n        \\n        while (cur->next) \\n            len++,\\n            cur = cur->next;\\n        \\n        cur->next = head;\\n        \\n        k = k % len;\\n        int m = len - k - 1;\\n        \\n        while (m--)\\n            head = head->next;\\n        \\n        auto newHead = head->next;\\n        head->next = NULL;\\n        \\n        return newHead;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (!head)\\n            return NULL;\\n        \\n        ListNode *cur = head;\\n        int len = 1;        \\n        \\n        while (cur->next) \\n            len++,\\n            cur = cur->next;\\n        \\n        cur->next = head;\\n        \\n        k = k % len;\\n        int m = len - k - 1;\\n        \\n        while (m--)\\n            head = head->next;\\n        \\n        auto newHead = head->next;\\n        head->next = NULL;\\n        \\n        return newHead;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 883100,
                "title": "java-2-easy-solution-with-and-w-o-counting-length",
                "content": "**#if helpful please do Upvote#**\\n\\n**Solution 1:  With Counting length**\\nTime Complexity : O(n)\\nSpace Complexity : O(1)\\n**0ms faster than 100%**\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null) return head;\\n        int len=1;\\n        ListNode tail=head;\\n\\t\\t//calculate length\\n        while(tail.next!=null){\\n            tail=tail.next;\\n            len++;\\n        }\\n        tail.next=head; //loop back to root\\n        k%=len; //avoid unnecessary moves\\n        for(int i=0;i<len-k;i++){\\n            tail=tail.next;\\n        }\\n        ListNode NewHead=tail.next; //calculate new Head\\n        tail.next=null;\\n        return NewHead;\\n        \\n    }\\n}\\n```\\n\\n**Solution 2 : Without counting the length**\\n**But this is slow :-(**\\n```\\npublic ListNode rotateRight(ListNode head, int n) {\\n    if (head == null || head.next == null || n == 0) {\\n         return head;\\n    }\\n    ListNode fast = head;\\n    ListNode slow = head;\\n    ListNode newHead;\\n    for (int i = 0; i < n; i++) {\\n        if (fast.next == null) {\\n            fast = head;\\n        } else {\\n            fast = fast.next;\\n        }\\n    }\\n    while (fast.next != null) {\\n        fast = fast.next;\\n        slow = slow.next;\\n    }\\n    fast.next = head;\\n    newHead = slow.next;\\n    slow.next = null;\\n    return newHead;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null) return head;\\n        int len=1;\\n        ListNode tail=head;\\n\\t\\t//calculate length\\n        while(tail.next!=null){\\n            tail=tail.next;\\n            len++;\\n        }\\n        tail.next=head; //loop back to root\\n        k%=len; //avoid unnecessary moves\\n        for(int i=0;i<len-k;i++){\\n            tail=tail.next;\\n        }\\n        ListNode NewHead=tail.next; //calculate new Head\\n        tail.next=null;\\n        return NewHead;\\n        \\n    }\\n}\\n```\n```\\npublic ListNode rotateRight(ListNode head, int n) {\\n    if (head == null || head.next == null || n == 0) {\\n         return head;\\n    }\\n    ListNode fast = head;\\n    ListNode slow = head;\\n    ListNode newHead;\\n    for (int i = 0; i < n; i++) {\\n        if (fast.next == null) {\\n            fast = head;\\n        } else {\\n            fast = fast.next;\\n        }\\n    }\\n    while (fast.next != null) {\\n        fast = fast.next;\\n        slow = slow.next;\\n    }\\n    fast.next = head;\\n    newHead = slow.next;\\n    slow.next = null;\\n    return newHead;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802313,
                "title": "c-super-simple-solution-with-explanations-4ms-faster-than-97",
                "content": "**Like it? please upvote...**\\n```\\nint get_len(ListNode* head){\\n        int res=0;\\n        while(head!=NULL)\\n        {\\n            res++;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if ((!head) || (!head->next) || (k==0)) return head;\\n        ListNode* ptr = head;\\n        int len = get_len(ptr);\\n        k = k%len;\\n        if (k==0) // no need to rotate\\n            return head;\\n        ptr = head;\\n        for (int i=0; i<len-k-1; i++) // go to node which will be the head\\n            ptr = ptr->next;\\n        \\n        ListNode* new_tail = ptr; // we split the list\\n        ListNode* new_head = ptr->next;\\n        ptr = ptr->next;\\n        new_tail->next = NULL;\\n        \\n        while (ptr->next!=NULL) // connect second part to first part\\n            ptr = ptr->next;\\n        ptr->next = head;\\n        return new_head;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint get_len(ListNode* head){\\n        int res=0;\\n        while(head!=NULL)\\n        {\\n            res++;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if ((!head) || (!head->next) || (k==0)) return head;\\n        ListNode* ptr = head;\\n        int len = get_len(ptr);\\n        k = k%len;\\n        if (k==0) // no need to rotate\\n            return head;\\n        ptr = head;\\n        for (int i=0; i<len-k-1; i++) // go to node which will be the head\\n            ptr = ptr->next;\\n        \\n        ListNode* new_tail = ptr; // we split the list\\n        ListNode* new_head = ptr->next;\\n        ptr = ptr->next;\\n        new_tail->next = NULL;\\n        \\n        while (ptr->next!=NULL) // connect second part to first part\\n            ptr = ptr->next;\\n        ptr->next = head;\\n        return new_head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796748,
                "title": "c-faster-than-97-73-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {   \\n        if (head == NULL) // If the list is empty\\n            return head;\\n        \\n        ListNode *itr = head, *fwd, *new_head;\\n        int len = 0, kFront, ctr=0;\\n        while (itr != NULL) { // To get the length of the list\\n            itr = itr->next;\\n            len++;\\n        }\\n        \\n        k = k%len; // To avoid unnecessary rotations\\n        \\n        if (k == 0) // If no rotation is needed\\n            return head;\\n        \\n        kFront = len - (k+1);\\n        itr = head;\\n        while (ctr < kFront) { // Iterate to element before the K th rotation \\n            itr = itr->next;\\n            ctr++;\\n        }\\n        \\n        new_head = itr->next; \\n        itr->next = NULL; // Setting the next of node before k th rotation to NULL\\n        fwd = new_head;\\n        \\n        while (fwd->next) {\\n            fwd = fwd->next;\\n        }\\n        fwd->next = head;\\n        \\n        return new_head;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {   \\n        if (head == NULL) // If the list is empty\\n            return head;\\n        \\n        ListNode *itr = head, *fwd, *new_head;\\n        int len = 0, kFront, ctr=0;\\n        while (itr != NULL) { // To get the length of the list\\n            itr = itr->next;\\n            len++;\\n        }\\n        \\n        k = k%len; // To avoid unnecessary rotations\\n        \\n        if (k == 0) // If no rotation is needed\\n            return head;\\n        \\n        kFront = len - (k+1);\\n        itr = head;\\n        while (ctr < kFront) { // Iterate to element before the K th rotation \\n            itr = itr->next;\\n            ctr++;\\n        }\\n        \\n        new_head = itr->next; \\n        itr->next = NULL; // Setting the next of node before k th rotation to NULL\\n        fwd = new_head;\\n        \\n        while (fwd->next) {\\n            fwd = fwd->next;\\n        }\\n        fwd->next = head;\\n        \\n        return new_head;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738991,
                "title": "java-a-clear-solution-only-with-tail-node",
                "content": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null) return null;\\n        int len = 1;\\n        ListNode tail = head;\\n        while (tail.next != null) {\\n            tail = tail.next;\\n            len = len + 1;\\n        }\\n        tail.next = head;\\n\\t\\t// find the pre node of Kth from end\\n        for (int i = len - k%len; i > 0; --i) {\\n            tail = tail.next;\\n        }\\n        ListNode res = tail.next;\\n        tail.next = null;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null) return null;\\n        int len = 1;\\n        ListNode tail = head;\\n        while (tail.next != null) {\\n            tail = tail.next;\\n            len = len + 1;\\n        }\\n        tail.next = head;\\n\\t\\t// find the pre node of Kth from end\\n        for (int i = len - k%len; i > 0; --i) {\\n            tail = tail.next;\\n        }\\n        ListNode res = tail.next;\\n        tail.next = null;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330828,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null) return null;\\n        \\n        int len = 1;\\n        ListNode fast = head, slow = head;\\n        while(fast.next != null){\\n            len++;\\n            fast = fast.next;\\n        }\\n        \\n        for(int i = 1; i < len - k % len; i++)\\n            slow = slow.next;\\n        \\n        fast.next = head;\\n        head = slow.next;\\n        slow.next = null;\\n        \\n        return head;\\n    }\\n}\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Rotate List.\\nMemory Usage: 39.2 MB, less than 39.66% of Java online submissions for Rotate List.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null) return null;\\n        \\n        int len = 1;\\n        ListNode fast = head, slow = head;\\n        while(fast.next != null){\\n            len++;\\n            fast = fast.next;\\n        }\\n        \\n        for(int i = 1; i < len - k % len; i++)\\n            slow = slow.next;\\n        \\n        fast.next = head;\\n        head = slow.next;\\n        slow.next = null;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330439,
                "title": "js-solution-beat-97-20-super-easy-understand",
                "content": "```\\nvar rotateRight = function(head, k) {\\n    if(!head || !head.next) return head\\n    dummy = head;\\n    depth = 0;\\n    while(dummy){\\n        depth += 1\\n        dummy = dummy.next\\n    }\\n    k = k%depth\\n    while(k > 0){\\n        node = head;\\n        while(node.next.next !== null){\\n            node = node.next\\n        }\\n        temp = node.next;\\n        node.next = null;\\n        temp.next = head;\\n        head = temp;\\n        k -= 1\\n    }\\n    return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotateRight = function(head, k) {\\n    if(!head || !head.next) return head\\n    dummy = head;\\n    depth = 0;\\n    while(dummy){\\n        depth += 1\\n        dummy = dummy.next\\n    }\\n    k = k%depth\\n    while(k > 0){\\n        node = head;\\n        while(node.next.next !== null){\\n            node = node.next\\n        }\\n        temp = node.next;\\n        node.next = null;\\n        temp.next = head;\\n        head = temp;\\n        k -= 1\\n    }\\n    return head\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 246743,
                "title": "c-6-lines-head-and-tail",
                "content": "Intuition: right shift is tricky, but left shift follows the list direction. So, let\\'s rotate list ```len - k``` times left instead.\\n\\n- Count nodes (len) until we reach the tail.\\n- Connect head to tail (the list is short-circuited now).\\n- Then, move head and tail ```len - k``` times.\\n> Tip: use ```k % len``` to optimize for large ```k```.\\n- Finally, break the list at tail and return head.\\n```\\nListNode* rotateRight(ListNode* head, int k, int len = 1) {\\n  for (auto tail = head; tail != nullptr; tail = tail->next, ++len)\\n    if (tail->next == nullptr) {\\n      tail->next = head;\\n      for (k = len - k % len; k > 0; --k) head = head->next, tail = tail->next;\\n      tail->next = nullptr;\\n    }\\n  return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```len - k```\n```len - k```\n```k % len```\n```k```\n```\\nListNode* rotateRight(ListNode* head, int k, int len = 1) {\\n  for (auto tail = head; tail != nullptr; tail = tail->next, ++len)\\n    if (tail->next == nullptr) {\\n      tail->next = head;\\n      for (k = len - k % len; k > 0; --k) head = head->next, tail = tail->next;\\n      tail->next = nullptr;\\n    }\\n  return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181728,
                "title": "c-8ms",
                "content": "1.\\u8BB0\\u4F4Fhead\\u7684\\u4F4D\\u7F6E\\uFF0C\\u7136\\u540E\\u5C06\\u5355\\u5411\\u94FE\\u8868\\u641E\\u6210\\u73AF\\uFF0C\\u90A3\\u4E48\\u53EA\\u8981\\u5C06head\\u7684\\u4F4D\\u7F6E\\u5411\\u53F3\\u79FB\\u52A8(n-k%n)\\u4E2A\\u4F4D\\u7F6E\\uFF0C\\u7136\\u540E\\u518D\\u5C06\\u73AF\\u89E3\\u5F00\\u6210\\u5355\\u5411\\u94FE\\u8868\\uFF0C\\u6700\\u540E\\u8FD4\\u56DE\\u3002\\n\\n```\\nclass Solution {\\npublic:\\nListNode* rotateRight(ListNode* head, int k) {\\n\\tif(!head) return NULL;\\n\\tint n=1;\\n\\tListNode* cur = head;\\n\\tListNode* res = head;\\n\\twhile(cur->next){\\n\\t\\tn++;\\n\\t\\tcur = cur->next;\\n\\t}\\n\\tcur->next = head; //\\u641E\\u6210\\u5FAA\\u73AF\\n\\tk=k%n;\\n\\twhile((n-k) > 0){\\n\\t\\tk++;\\n\\t\\tres = res->next;\\n\\t}\\n\\tcur = res;\\n\\twhile(cur->next != res){\\n\\t\\tcur = cur->next;\\n\\t}\\n\\tcur->next = NULL;\\n\\n\\t\\t\\treturn res;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nListNode* rotateRight(ListNode* head, int k) {\\n\\tif(!head) return NULL;\\n\\tint n=1;\\n\\tListNode* cur = head;\\n\\tListNode* res = head;\\n\\twhile(cur->next){\\n\\t\\tn++;\\n\\t\\tcur = cur->next;\\n\\t}\\n\\tcur->next = head; //\\u641E\\u6210\\u5FAA\\u73AF\\n\\tk=k%n;\\n\\twhile((n-k) > 0){\\n\\t\\tk++;\\n\\t\\tres = res->next;\\n\\t}\\n\\tcur = res;\\n\\twhile(cur->next != res){\\n\\t\\tcur = cur->next;\\n\\t}\\n\\tcur->next = NULL;\\n\\n\\t\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22729,
                "title": "clean-c-9ms-step-by-step-solution",
                "content": "**Solution 1.**\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next) return head;\\n\\n        int len = 0;\\n        ListNode* p = head;\\n        while(p) p = p->next, len++;\\n        k = k % len;\\n        if(k == 0) return head;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(k > 0) fast = fast->next, k--;\\n        while(fast->next) fast = fast->next, slow = slow->next;\\n        \\n        ListNode* res = slow->next;\\n        \\n        slow->next = NULL;\\n        fast->next = head;\\n        \\n        return res;\\n    }\\n};\\n```\\n***\\n**Solution 2.**\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !k) return head;\\n        ListNode* tail(head), *cur(head), *res;\\n        \\n        int len = 1;\\n        while(tail->next) tail = tail->next, len++;\\n        \\n        k = k % len;\\n        if(!k) return head;\\n        k = len - k;\\n        \\n        while(--k) cur = cur->next;\\n        \\n        res = cur->next;\\n        cur->next = NULL;\\n        tail->next = head;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next) return head;\\n\\n        int len = 0;\\n        ListNode* p = head;\\n        while(p) p = p->next, len++;\\n        k = k % len;\\n        if(k == 0) return head;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(k > 0) fast = fast->next, k--;\\n        while(fast->next) fast = fast->next, slow = slow->next;\\n        \\n        ListNode* res = slow->next;\\n        \\n        slow->next = NULL;\\n        fast->next = head;\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !k) return head;\\n        ListNode* tail(head), *cur(head), *res;\\n        \\n        int len = 1;\\n        while(tail->next) tail = tail->next, len++;\\n        \\n        k = k % len;\\n        if(!k) return head;\\n        k = len - k;\\n        \\n        while(--k) cur = cur->next;\\n        \\n        res = cur->next;\\n        cur->next = NULL;\\n        tail->next = head;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22813,
                "title": "clear-python-solution",
                "content": "    class Solution(object):\\n        def rotateRight(self, head, k):\\n            \"\"\"\\n            :type head: ListNode\\n            :type k: int\\n            :rtype: ListNode\\n            \"\"\"\\n            if head is None:\\n                return head\\n            l, p = 1, head\\n            while p.next:\\n                p = p.next\\n                l += 1\\n            k = k % l\\n            if k == 0:\\n                return head\\n            \\n            q, n = head, l - k - 1\\n            while n:\\n                q = q.next\\n                n -= 1\\n            \\n            p.next = head\\n            head = q.next\\n            q.next = None\\n            return head",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def rotateRight(self, head, k):\\n            \"\"\"\\n            :type head: ListNode\\n            :type k: int\\n            :rtype: ListNode\\n            \"\"\"\\n            if head is None:\\n                return head\\n            l, p = 1, head\\n            while p.next:\\n                p = p.next\\n                l += 1\\n            k = k % l\\n            if k == 0:\\n                return head\\n            \\n            q, n = head, l - k - 1\\n            while n:\\n                q = q.next\\n                n -= 1\\n            \\n            p.next = head\\n            head = q.next\\n            q.next = None\\n            return head",
                "codeTag": "Java"
            },
            {
                "id": 22816,
                "title": "a-golang-solution",
                "content": "    func rotateRight(head *ListNode, k int) *ListNode {\\n        if head == nil {\\n    \\t\\treturn head\\n    \\t}\\n    \\n    \\tvar count int\\n    \\tm := make(map[int]*ListNode)\\n    \\n    \\tfor head != nil {\\n    \\t\\tm[count] = head\\n    \\t\\tcount++\\n    \\t\\thead = head.Next\\n    \\t}\\n    \\n    \\tk = k % count\\n    \\tif k == 0 {\\n    \\t    return m[0]\\n    \\t}\\n    \\n    \\tm[count - 1].Next = m[0]\\n    \\tm[count - k - 1].Next = nil\\n    \\treturn m[count - k]\\n    }",
                "solutionTags": [
                    "Go"
                ],
                "code": "    func rotateRight(head *ListNode, k int) *ListNode {\\n        if head == nil {\\n    \\t\\treturn head\\n    \\t}\\n    \\n    \\tvar count int\\n    \\tm := make(map[int]*ListNode)\\n    \\n    \\tfor head != nil {\\n    \\t\\tm[count] = head\\n    \\t\\tcount++\\n    \\t\\thead = head.Next\\n    \\t}\\n    \\n    \\tk = k % count\\n    \\tif k == 0 {\\n    \\t    return m[0]\\n    \\t}\\n    \\n    \\tm[count - 1].Next = m[0]\\n    \\tm[count - k - 1].Next = nil\\n    \\treturn m[count - k]\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3913844,
                "title": "beats-100-striver-s-approach-explained-clean-code",
                "content": "# Approach\\n![image.png](https://assets.leetcode.com/users/images/2045c536-b1e2-403e-a7e7-3aff7c040ba4_1692104707.3630223.png)\\n\\nMain idea is to convert Singly Linked List into a Circular Linked List. \\nFor that, we traverse till `curr -> next != NULL` which is the last node, and then point it to the head : `curr -> next = head`\\n\\nThen instead of rotating the list k times, we would rotate it 0 times if k = 5 for length = 5, rotate it once it k = 6 such that, twice if k = 7 and so on. So we count total rotations to be made as `k = k % length`\\n\\nThe pointer currently points to the tail of the SLL which is now connected to the head. We now move it to `k = length - k`\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || k == 0 || head->next == NULL)    return head;\\n\\n        ListNode* curr = head;\\n        int length = 1;\\n\\n        while(curr->next != NULL) {\\n            curr = curr->next;\\n            length++;\\n        }\\n\\n        curr->next = head;\\n        k = k % length;\\n        k = length - k;\\n        while(k--)  curr = curr->next;\\n\\n        head = curr->next;\\n        curr->next = NULL;\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || k == 0 || head->next == NULL)    return head;\\n\\n        ListNode* curr = head;\\n        int length = 1;\\n\\n        while(curr->next != NULL) {\\n            curr = curr->next;\\n            length++;\\n        }\\n\\n        curr->next = head;\\n        k = k % length;\\n        k = length - k;\\n        while(k--)  curr = curr->next;\\n\\n        head = curr->next;\\n        curr->next = NULL;\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860256,
                "title": "best-and-easiest-2-c-solutions-simple-two-pointer-approach-beats-100",
                "content": "\\n\\n# Complexity\\n### - Time complexity: O(N)\\n\\n### - Space complexity: O(1)\\n# Code\\n```\\n// Approach 1 - Two pointer\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n            \\n        ListNode *p1 = head, *p2 = head, *prev1 = head, *prev2 = head;\\n        int len = 0;\\n        while(p1 != NULL){\\n            len++;\\n            p1 = p1->next;\\n        }\\n        k = k % len;\\n        if(k==0)    return head;\\n        p1 = head;\\n\\n        while(k-- && p1!= NULL){\\n            p1 = p1->next;\\n        }\\n\\n        while(p1 != NULL){\\n            prev1 = p1;\\n            prev2 = p2;\\n\\n            p1 = p1->next;\\n            p2 = p2->next;\\n        }\\n\\n        prev1->next = head;\\n        prev2->next = NULL;\\n        return p2;\\n    }\\n};\\n\\n// Approach 2 = Reverse the list\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        ListNode *curr = head, *prev = NULL, *forward = NULL;\\n        while(curr != NULL){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        return prev;\\n    }\\n\\n    int getLength(ListNode *head){\\n        int len = 0;\\n        while(head != NULL){\\n            head= head->next;\\n            len++;\\n        }\\n        return len;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n\\n        int len = getLength(head);\\n        k = k%len;\\n        if(k==0)\\n            return head;\\n        \\n        ListNode *newHead = reverse(head);\\n        ListNode *p1 = newHead, *p2 = newHead, *prev1 = newHead;\\n        \\n        while(k--){\\n            prev1 = p1;\\n            p1 = p1->next;\\n        }\\n        prev1->next = NULL;\\n        ListNode *finalHead = reverse(p2);\\n        ListNode *joinHead = reverse(p1);\\n\\n        p1 = finalHead;\\n        while(p1->next != NULL)\\n            p1 = p1->next;\\n\\n        p1->next = joinHead;\\n        return finalHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n// Approach 1 - Two pointer\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n            \\n        ListNode *p1 = head, *p2 = head, *prev1 = head, *prev2 = head;\\n        int len = 0;\\n        while(p1 != NULL){\\n            len++;\\n            p1 = p1->next;\\n        }\\n        k = k % len;\\n        if(k==0)    return head;\\n        p1 = head;\\n\\n        while(k-- && p1!= NULL){\\n            p1 = p1->next;\\n        }\\n\\n        while(p1 != NULL){\\n            prev1 = p1;\\n            prev2 = p2;\\n\\n            p1 = p1->next;\\n            p2 = p2->next;\\n        }\\n\\n        prev1->next = head;\\n        prev2->next = NULL;\\n        return p2;\\n    }\\n};\\n\\n// Approach 2 = Reverse the list\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        ListNode *curr = head, *prev = NULL, *forward = NULL;\\n        while(curr != NULL){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        return prev;\\n    }\\n\\n    int getLength(ListNode *head){\\n        int len = 0;\\n        while(head != NULL){\\n            head= head->next;\\n            len++;\\n        }\\n        return len;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n\\n        int len = getLength(head);\\n        k = k%len;\\n        if(k==0)\\n            return head;\\n        \\n        ListNode *newHead = reverse(head);\\n        ListNode *p1 = newHead, *p2 = newHead, *prev1 = newHead;\\n        \\n        while(k--){\\n            prev1 = p1;\\n            p1 = p1->next;\\n        }\\n        prev1->next = NULL;\\n        ListNode *finalHead = reverse(p2);\\n        ListNode *joinHead = reverse(p1);\\n\\n        p1 = finalHead;\\n        while(p1->next != NULL)\\n            p1 = p1->next;\\n\\n        p1->next = joinHead;\\n        return finalHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788502,
                "title": "easy-java-sol-circular-linked-list-concept-0ms-beats-100",
                "content": "\\n\\n# Approach\\nThe approach is making the list into circular list and then traversing the list till len-k-1 and then initialising its next to null.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nIF YOU LIKE THE SOLUTION, PLEASE UPVOTE.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n         if (head == null) {\\n            return head;\\n        }\\n        int len = 1;\\n        ListNode curr = head;\\n        while (curr.next != null) {\\n            curr = curr.next;\\n            len++;\\n        }\\n        k = k % len;\\n        if (k == 0) {\\n            return head;\\n        }\\n        curr.next = head;\\n        ListNode newHead = head;\\n        for (int i = 0; i < len - k - 1; i++) {\\n            newHead = newHead.next;\\n        }\\n        ListNode temp = newHead.next;\\n        newHead.next = null;\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n         if (head == null) {\\n            return head;\\n        }\\n        int len = 1;\\n        ListNode curr = head;\\n        while (curr.next != null) {\\n            curr = curr.next;\\n            len++;\\n        }\\n        k = k % len;\\n        if (k == 0) {\\n            return head;\\n        }\\n        curr.next = head;\\n        ListNode newHead = head;\\n        for (int i = 0; i < len - k - 1; i++) {\\n            newHead = newHead.next;\\n        }\\n        ListNode temp = newHead.next;\\n        newHead.next = null;\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747143,
                "title": "simple-java-solution-0ms-100-beats",
                "content": "# Approach\\n-Count the no of nodes in the list.\\n-divide them into two lists where second list contains k elements.\\n-if k > no of nodes make k as k % (no of nodes).\\n-add second list\\'s end to first list\\'s head and return second list head. \\n# Complexity\\n- Time complexity:\\n    O(N),N=no of nodes.\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next==null || k==0)\\n        return head;\\n        ListNode prev,temp;\\n        int x=0,y=0;\\n        prev=temp=head;\\n        while(temp!=null)\\n        {\\n            x++;\\n            temp=temp.next;\\n        }\\n        if(k>=x)\\n        k=k%x;\\n        if(k==0)\\n        return head;\\n        temp=head;\\n        while(y<x-k)\\n        {\\n            prev=temp;\\n            temp=temp.next;\\n            y++;\\n        }\\n        while(temp!=null)\\n        {\\n            if(temp.next==null)\\n            {\\n                temp.next=head;\\n                break;\\n            }\\n            temp=temp.next;\\n        }\\n        head=prev.next;\\n        prev.next=null;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next==null || k==0)\\n        return head;\\n        ListNode prev,temp;\\n        int x=0,y=0;\\n        prev=temp=head;\\n        while(temp!=null)\\n        {\\n            x++;\\n            temp=temp.next;\\n        }\\n        if(k>=x)\\n        k=k%x;\\n        if(k==0)\\n        return head;\\n        temp=head;\\n        while(y<x-k)\\n        {\\n            prev=temp;\\n            temp=temp.next;\\n            y++;\\n        }\\n        while(temp!=null)\\n        {\\n            if(temp.next==null)\\n            {\\n                temp.next=head;\\n                break;\\n            }\\n            temp=temp.next;\\n        }\\n        head=prev.next;\\n        prev.next=null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739814,
                "title": "easy-to-understand-97-beats-c",
                "content": "\\n\\n# Approach\\n1. Create a function to get length pf LL.\\n2. Create a function for single rotation.\\n3. Simply make the value of k smaller : to avoide repeated effect of rotation (k=k%n).\\n4. Now find the NewLast node and NewHead node and perform opreation acc to the question.\\n5. return newhead\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //find lenght of linked list \\n    int length(ListNode* head){\\n        int len =0;\\n        while(head){\\n            head=head->next;\\n            len++;\\n        }\\n        return len;\\n    }\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL) return NULL;\\n        int len = length(head);\\n        int actualk = k%len;\\n        if(actualk == 0) return head;\\n\\n        int pos = len-actualk-1;\\n\\n        ListNode* newlast=head;\\n        ListNode* newhead=nullptr;\\n\\n        //finding new LastNode \\n        for(int i=0;i<pos;i++){\\n            newlast=newlast->next;\\n        }\\n        newhead = newlast->next; // new head mil gya \\n        newlast->next = NULL;  // new last ko NULL kr de\\n        //find linkes list last node and connect it with first node \\n        \\n        ListNode* it = newhead;\\n        while(it->next != NULL){\\n            it=it->next;\\n        }\\n        it->next=head;\\n        return newhead;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //find lenght of linked list \\n    int length(ListNode* head){\\n        int len =0;\\n        while(head){\\n            head=head->next;\\n            len++;\\n        }\\n        return len;\\n    }\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL) return NULL;\\n        int len = length(head);\\n        int actualk = k%len;\\n        if(actualk == 0) return head;\\n\\n        int pos = len-actualk-1;\\n\\n        ListNode* newlast=head;\\n        ListNode* newhead=nullptr;\\n\\n        //finding new LastNode \\n        for(int i=0;i<pos;i++){\\n            newlast=newlast->next;\\n        }\\n        newhead = newlast->next; // new head mil gya \\n        newlast->next = NULL;  // new last ko NULL kr de\\n        //find linkes list last node and connect it with first node \\n        \\n        ListNode* it = newhead;\\n        while(it->next != NULL){\\n            it=it->next;\\n        }\\n        it->next=head;\\n        return newhead;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682484,
                "title": "using-queue-and-single-pass-no-need-to-count-first-beats-98-6-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing queue with maximum length of k to store items which should move to the begining of the list\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n![Screenshot 2023-06-25 at 3.37.08 PM.png](https://assets.leetcode.com/users/images/a9521192-2c95-4016-b891-a1b0d2cf73f5_1687732658.799979.png)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode RotateRight(ListNode head, int k) {\\n        var queue = new Queue<ListNode>();\\n        if(k == 0) return head;\\n        var first = head;\\n        while(head != null)\\n        {\\n            if(head.next == null && queue.Count == k){\\n                head.next = first;\\n                queue.Dequeue().next = null;\\n                first = queue.Count > 0 ? queue.Peek() : head;\\n                break;\\n            }\\n            if(queue.Count == k) queue.Dequeue(); // We do n\\'t need to keep more than k items in the queue\\n            queue.Enqueue(head);\\n            if(head.next == null && queue.Count != k){\\n                k = k % queue.Count;// To avoid repeating if k is greater than items in the list\\n                if(k == 0) break;\\n                queue.Clear();\\n            } \\n            head=head.next ?? first;\\n        }\\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode RotateRight(ListNode head, int k) {\\n        var queue = new Queue<ListNode>();\\n        if(k == 0) return head;\\n        var first = head;\\n        while(head != null)\\n        {\\n            if(head.next == null && queue.Count == k){\\n                head.next = first;\\n                queue.Dequeue().next = null;\\n                first = queue.Count > 0 ? queue.Peek() : head;\\n                break;\\n            }\\n            if(queue.Count == k) queue.Dequeue(); // We do n\\'t need to keep more than k items in the queue\\n            queue.Enqueue(head);\\n            if(head.next == null && queue.Count != k){\\n                k = k % queue.Count;// To avoid repeating if k is greater than items in the list\\n                if(k == 0) break;\\n                queue.Clear();\\n            } \\n            head=head.next ?? first;\\n        }\\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651799,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null){\\n            return null;\\n        }\\n        int n =0;\\n        ListNode l = head;\\n        while(l!=null){\\n            l = l.next;\\n            n++;\\n        }\\n        k = k%n;\\n        for(int i=0 ; i<k ; i++){\\n            ListNode dum = head;\\n            ListNode prev=null;\\n            while(dum.next!=null){\\n                prev = dum;\\n                dum = dum.next;\\n            }\\n            if(prev!=null){\\n                prev.next = null;\\n                dum.next = head;\\n                head = dum;\\n\\n            }\\n        }\\n        return head;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null){\\n            return null;\\n        }\\n        int n =0;\\n        ListNode l = head;\\n        while(l!=null){\\n            l = l.next;\\n            n++;\\n        }\\n        k = k%n;\\n        for(int i=0 ; i<k ; i++){\\n            ListNode dum = head;\\n            ListNode prev=null;\\n            while(dum.next!=null){\\n                prev = dum;\\n                dum = dum.next;\\n            }\\n            if(prev!=null){\\n                prev.next = null;\\n                dum.next = head;\\n                head = dum;\\n\\n            }\\n        }\\n        return head;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583834,
                "title": "o-n-time-very-easy-c-11-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        //Boundary Case\\n        if(!head||!head->next||k==0){return head;}\\n        ListNode* cur=head;\\n        int len=1;\\n        //Iterating to last node\\n        while(cur->next && ++len){cur=cur->next;}\\n        //Creating a circular link list\\n        cur->next=head;\\n        k=k%len;\\n        k=len-k;\\n        //Iterating to rotated list \\n        while(k--){cur=cur->next;}\\n        //Cutting circular link list and adding headl\\n        head=cur->next;\\n        cur->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        //Boundary Case\\n        if(!head||!head->next||k==0){return head;}\\n        ListNode* cur=head;\\n        int len=1;\\n        //Iterating to last node\\n        while(cur->next && ++len){cur=cur->next;}\\n        //Creating a circular link list\\n        cur->next=head;\\n        k=k%len;\\n        k=len-k;\\n        //Iterating to rotated list \\n        while(k--){cur=cur->next;}\\n        //Cutting circular link list and adding headl\\n        head=cur->next;\\n        cur->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541946,
                "title": "61-rotate-list",
                "content": "class Solution {\\nprivate:\\n    void insertAthead(ListNode* & head,int val)\\n        \\n    {\\n        ListNode* newhead=new ListNode(val);\\n            if(head==NULL)\\n            {\\n             head=newhead;   \\n            }\\n        else\\n        {\\n            newhead->next=head;\\n            head=newhead;\\n        }\\n        \\n    }\\n    int lastval(ListNode* & head)\\n    {\\n        ListNode* curr=head;\\n        while(curr->next->next!=NULL)\\n        {\\n            curr=curr->next;\\n        }\\n        int v=curr->next->val;\\n        curr->next=NULL;\\n            return v;\\n    }\\n    \\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        int len=0;\\n            ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            len++;\\n            curr=curr->next;\\n        }\\n        k=k%len;\\n        for(int i=0;i<k;i++)\\n        {\\n            int val=lastval(head);\\n            insertAthead(head,val);\\n        }\\n        return head;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\nprivate:\\n    void insertAthead(ListNode* & head,int val)\\n        \\n    {\\n        ListNode* newhead=new ListNode(val);\\n            if(head==NULL)\\n            {\\n             head=newhead;   \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3508848,
                "title": "beats-100-simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if( k == 0 || head ==null || head.next == null) return head;\\n\\n        int len=1;\\n        ListNode cur=head;\\n        //count and travel to the last node;\\n        while(cur.next != null){\\n            len++;\\n            cur=cur.next;\\n        }\\n        //when k=len we get the same linked list\\n        k = len - (k%len);\\n        //make a loop by attaching last to first\\n        cur.next = head;\\n\\n        while(k > 0){\\n            cur=cur.next;\\n            k--;\\n        } \\n        //get the head and break the link\\n        head = cur.next;\\n        cur.next = null;\\n\\n        return head;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if( k == 0 || head ==null || head.next == null) return head;\\n\\n        int len=1;\\n        ListNode cur=head;\\n        //count and travel to the last node;\\n        while(cur.next != null){\\n            len++;\\n            cur=cur.next;\\n        }\\n        //when k=len we get the same linked list\\n        k = len - (k%len);\\n        //make a loop by attaching last to first\\n        cur.next = head;\\n\\n        while(k > 0){\\n            cur=cur.next;\\n            k--;\\n        } \\n        //get the head and break the link\\n        head = cur.next;\\n        cur.next = null;\\n\\n        return head;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316060,
                "title": "c-code-simple-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        ListNode* temp1=head;\\n        int size=1;\\n        while(temp1->next){\\n           temp1=temp1->next; \\n            size++;\\n        } \\n        temp1->next=head;\\n        \\n        k=k%size;\\n        int val=size-k-1;\\n        ListNode* temp2=head, *temp3=head;\\n        while(val--)\\n        {\\n            temp2=temp2->next;\\n        } \\n        temp3=temp2->next;\\n        temp2->next=NULL;\\n        \\n        return temp3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        ListNode* temp1=head;\\n        int size=1;\\n        while(temp1->next){\\n           temp1=temp1->next; \\n            size++;\\n        } \\n        temp1->next=head;\\n        \\n        k=k%size;\\n        int val=size-k-1;\\n        ListNode* temp2=head, *temp3=head;\\n        while(val--)\\n        {\\n            temp2=temp2->next;\\n        } \\n        temp3=temp2->next;\\n        temp2->next=NULL;\\n        \\n        return temp3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307764,
                "title": "rotate-linked-list-by-k-position-easy-java-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nlet\\'s use two pointer as start and end. From start to end will be the rotating part that will come first.\\n    so, end will be the last element and find start with the help of\\n```\\n        int i = 0;\\n        k %= count;\\n        while(i < count - k - 1){\\n            i++;\\n            start = start.next;\\n        }\\n```\\nnow we just need to point end node to original first ```end.next = head;```\\nNow make a new head in start pointer and start.next will be null.\\n\\nAs a first example start is 3 and end is 5.\\nso after start 3 will point to null.\\nand ```newHead = start.next``` will point to 4.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode start = head, end = head, curr = head;\\n        int count = 0;\\n        if(head == null || head.next == null)\\n            return head;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n        while(end.next != null){\\n            end = end.next;\\n        }\\n        end.next = head; //ending point\\n        int i = 0;\\n        k %= count;\\n        while(i < count - k - 1){\\n            i++;\\n            start = start.next;\\n        }\\n        ListNode newhead = start.next;\\n        start.next = null;\\n        return newhead;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        int i = 0;\\n        k %= count;\\n        while(i < count - k - 1){\\n            i++;\\n            start = start.next;\\n        }\\n```\n```end.next = head;```\n```newHead = start.next```\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        ListNode start = head, end = head, curr = head;\\n        int count = 0;\\n        if(head == null || head.next == null)\\n            return head;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n        while(end.next != null){\\n            end = end.next;\\n        }\\n        end.next = head; //ending point\\n        int i = 0;\\n        k %= count;\\n        while(i < count - k - 1){\\n            i++;\\n            start = start.next;\\n        }\\n        ListNode newhead = start.next;\\n        start.next = null;\\n        return newhead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285408,
                "title": "c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem , we have find the last node of the linked list and always try to rotate it with joining lastnode to head and previous of last to NULL; \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function first checks if the input linked list is empty or if k is zero. If either of these conditions is true, the function returns the input list as it is.\\n\\nThe function then computes the length of the linked list by traversing it using a temporary pointer temp that starts from the head of the list. The length c of the list is incremented for each node encountered.\\n\\nThe function then computes the actual number of positions z by which the list should be rotated. This is done by taking the remainder of k divided by c. This ensures that if k is greater than c, the function rotates the list by only the necessary amount.\\n\\nThe function then enters a loop that rotates the list by z positions. In each iteration, the function traverses the list using a pointer curr that starts from the head of the list and stops at the second-last node. This is because we need to change the next pointer of the second-last node to point to NULL in order to make it the last node of the rotated list. The function then saves the next pointer of the second-last node in a temporary pointer next, sets the next pointer of the second-last node to NULL, and sets the next pointer of next to point to the original head of the list. Finally, the function updates the head of the list to point to next.\\n\\nThe loop runs z times, so the final result is a rotated list.\\n\\nThe function returns a pointer to the new head of the rotated list.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(k*n)  \\nwhere \\nk= no of rotations. k is always k <= n.\\nn= length of linked list;\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1);\\nwe are not using extra space;\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n     if(!head || k==0)\\n     {\\n         return head;\\n     }\\n       int c=0;\\n       ListNode* temp=head;\\n       while(temp)\\n       {\\n           c++;\\n           temp=temp->next;\\n       }\\n\\n       int z=k%c;\\n    //    cout<<c<<\" \"<<z<<\"\\\\n\";\\n    //   cout<<temp->val<<\"\\\\n\";\\n       while(z--)\\n       {\\n           ListNode* curr=head;\\n           while(curr->next->next)\\n           {\\n               \\n               curr=curr->next;\\n           }\\n            ListNode* next=curr->next;\\n           curr->next=next->next;\\n           next->next=head;\\n           head=next;\\n\\n       }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n     if(!head || k==0)\\n     {\\n         return head;\\n     }\\n       int c=0;\\n       ListNode* temp=head;\\n       while(temp)\\n       {\\n           c++;\\n           temp=temp->next;\\n       }\\n\\n       int z=k%c;\\n    //    cout<<c<<\" \"<<z<<\"\\\\n\";\\n    //   cout<<temp->val<<\"\\\\n\";\\n       while(z--)\\n       {\\n           ListNode* curr=head;\\n           while(curr->next->next)\\n           {\\n               \\n               curr=curr->next;\\n           }\\n            ListNode* next=curr->next;\\n           curr->next=next->next;\\n           next->next=head;\\n           head=next;\\n\\n       }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3228968,
                "title": "easy-to-understand-c-solution",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public ListNode RotateRight(ListNode head, int k)\\n    {\\n        if (head == null)\\n        {\\n            return null;\\n        }\\n        \\n        var length = 1;\\n        var tail = head;\\n    \\n        while (tail.next != null)\\n        {\\n            length++;\\n            tail = tail.next;\\n        }\\n\\n        tail.next = head;\\n        \\n        k = length - k % length;\\n\\n        for (var i = 0; i < k; i++)\\n        {\\n            head = head.next;\\n            tail = tail.next;\\n        }\\n\\n        tail.next = null;\\n\\n        return head;\\n    }\\n}\\n```\\n\\n![pleaseupvote.jpg](https://assets.leetcode.com/users/images/67e97d5d-9eeb-4160-a966-5534f748b3f5_1677333688.581251.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public ListNode RotateRight(ListNode head, int k)\\n    {\\n        if (head == null)\\n        {\\n            return null;\\n        }\\n        \\n        var length = 1;\\n        var tail = head;\\n    \\n        while (tail.next != null)\\n        {\\n            length++;\\n            tail = tail.next;\\n        }\\n\\n        tail.next = head;\\n        \\n        k = length - k % length;\\n\\n        for (var i = 0; i < k; i++)\\n        {\\n            head = head.next;\\n            tail = tail.next;\\n        }\\n\\n        tail.next = null;\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211274,
                "title": "java-easy-0ms-beats-100-simple",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (k==0 || head==null) return head;\\n        int count = 1;\\n        ListNode temp = head;\\n        while (temp.next!=null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        if (k>count) k = k%count;\\n        if (k==count) return head;\\n        k = count-k-1;\\n        temp.next = head;\\n        temp = head;\\n        while (k>0) {\\n            k--;\\n            temp = temp.next;\\n        }\\n        head = temp.next;\\n        temp.next = null;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (k==0 || head==null) return head;\\n        int count = 1;\\n        ListNode temp = head;\\n        while (temp.next!=null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        if (k>count) k = k%count;\\n        if (k==count) return head;\\n        k = count-k-1;\\n        temp.next = head;\\n        temp = head;\\n        while (k>0) {\\n            k--;\\n            temp = temp.next;\\n        }\\n        head = temp.next;\\n        temp.next = null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199897,
                "title": "0ms-java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next==null ||k==0){\\n            return head;\\n        }\\n        //count the length\\n        ListNode cur=head;\\n        int len=1;\\n        while(cur.next!=null){\\n            len++;\\n            cur=cur.next;\\n        }\\n        //go till that node\\n        cur.next=head;\\n        k=k%len;\\n        k=len-k;\\n        while(k-- >0){\\n            cur=cur.next;\\n        }\\n        //make the node head and break connection\\n        head=cur.next;\\n        cur.next=null;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || head.next==null ||k==0){\\n            return head;\\n        }\\n        //count the length\\n        ListNode cur=head;\\n        int len=1;\\n        while(cur.next!=null){\\n            len++;\\n            cur=cur.next;\\n        }\\n        //go till that node\\n        cur.next=head;\\n        k=k%len;\\n        k=len-k;\\n        while(k-- >0){\\n            cur=cur.next;\\n        }\\n        //make the node head and break connection\\n        head=cur.next;\\n        cur.next=null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182224,
                "title": "100-faster-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int len(ListNode* p){\\n        int x = 0;\\n        while(p){\\n            x++;\\n            p = p->next;\\n        }\\n        return x;\\n    }\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||head->next==NULL)return head;\\n        int l = len(head);\\n        k = k%l;\\n        if(k==0)return head;\\n        k = l-k;\\n        ListNode* p = head;\\n        while(--k){\\n            p = p->next;\\n        }\\n        ListNode* q = p->next;\\n        p->next = NULL;\\n        ListNode* ans = q;\\n        while(q->next != NULL){\\n            q = q->next;\\n        }\\n        q->next = head;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int len(ListNode* p){\\n        int x = 0;\\n        while(p){\\n            x++;\\n            p = p->next;\\n        }\\n        return x;\\n    }\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||head->next==NULL)return head;\\n        int l = len(head);\\n        k = k%l;\\n        if(k==0)return head;\\n        k = l-k;\\n        ListNode* p = head;\\n        while(--k){\\n            p = p->next;\\n        }\\n        ListNode* q = p->next;\\n        p->next = NULL;\\n        ListNode* ans = q;\\n        while(q->next != NULL){\\n            q = q->next;\\n        }\\n        q->next = head;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127739,
                "title": "c-o-n-solution-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is a solution in C++ to the problem of rotating a linked list to the right by a certain number of places. The solution uses a private helper function \"getLength\" to get the length of the linked list. Then, in the public function \"rotateRight\", it calculates the new head of the rotated linked list, by traversing the original list until reaching a node \"k\" places from the end, where \"k\" is the number of places to rotate. The node \"k\" places from the end becomes the new head, and the original head is appended to the end of the new list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code implements a solution to the problem of rotating a linked list to the right by a certain number of places. The linked list is represented by a chain of nodes, each node having a value and a pointer to the next node. The code uses a singly linked list representation, meaning that each node only points to the next node in the list, and not to the previous node.\\n\\nThe solution consists of two functions:\\n\\n1) getLength: This is a private helper function that calculates the length of the linked list. It does this by iterating through the linked list, starting from the head, and counting the number of nodes until it reaches the end of the list (when the current node\\'s next pointer is NULL).\\n\\n2) rotateRight: This is the public function that implements the rotation of the linked list. It takes as inputs the head of the linked list (head) and the number of places to rotate (k).\\n\\nHere are the steps that the code follows in the rotateRight function:\\n\\n1) Check if the linked list is empty or has only one node. If either of these conditions is true, then there is no need to rotate the list, so the function returns the head of the list.\\n\\n2) Calculate the length of the linked list by calling the getLength helper function.\\n\\n3) While k is greater than the length of the list, reduce k by the length of the list. This is to ensure that we only rotate the list by a number of places that is less than or equal to its length.\\n\\n4) Check if k is equal to the length of the list or 0. If either of these conditions is true, then there is no need to rotate the list, so the function returns the head of the list.\\n\\n5) Create a temporary pointer temp that starts at the head of the list.\\n\\n6) Traverse the list until temp points to the node k places from the end of the list. To do this, we iterate temp k times, starting from 1, and incrementing by 1 each time.\\n\\n7) The node temp points to is now the end of the original list, and the node after it is the new head of the rotated list. So we set ansHead to the node after temp and set temp->next to NULL to separate the two parts of the list.\\n\\n8) Create a new pointer forward that starts at the new head of the rotated list (ansHead).\\n\\n9) Traverse the new list until forward points to the last node. To do this, we iterate forward until its next pointer is NULL.\\n\\n10) Finally, set the next pointer of the last node of the new list to the original head of the list, so that the original head is appended to the end of the new list.\\n\\n11) Return the new head of the rotated list (ansHead).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe algorithm\\'s time complexity is O(n), where n is the length of the linked list, since we need to traverse the list once to calculate its length and once to perform the rotation.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1), since it uses a constant amount of additional memory regardless of the size of the input linked list. The code only uses a few pointers (head, temp, ansHead, and forward) to traverse and manipulate the linked list, and the memory usage of these pointers is constant. The helper function getLength also uses a constant amount of memory. Hence, the overall space complexity of the code is O(1).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int getLength(ListNode* head){\\n        int counter = 0;\\n        while(head!=NULL){\\n            counter++;\\n            head=head->next;\\n        }\\n        return counter;\\n    }\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        ios_base::sync_with_stdio(false);\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int len = getLength(head);\\n        while(k>len){\\n            k-=len;\\n        }\\n        if(k==len || k==0){\\n            return head;\\n        }\\n        ListNode* temp = head;\\n        k=len-k;\\n        int cnt = 1;\\n        while(cnt<k){\\n            temp=temp->next;\\n            cnt++;\\n        }\\n        ListNode* ansHead = temp->next;\\n        temp->next=NULL;\\n        ListNode* forward = ansHead;\\n        while(forward->next!=NULL){\\n            forward=forward->next;\\n        }\\n        forward->next=head;\\n        return ansHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int getLength(ListNode* head){\\n        int counter = 0;\\n        while(head!=NULL){\\n            counter++;\\n            head=head->next;\\n        }\\n        return counter;\\n    }\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        ios_base::sync_with_stdio(false);\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int len = getLength(head);\\n        while(k>len){\\n            k-=len;\\n        }\\n        if(k==len || k==0){\\n            return head;\\n        }\\n        ListNode* temp = head;\\n        k=len-k;\\n        int cnt = 1;\\n        while(cnt<k){\\n            temp=temp->next;\\n            cnt++;\\n        }\\n        ListNode* ansHead = temp->next;\\n        temp->next=NULL;\\n        ListNode* forward = ansHead;\\n        while(forward->next!=NULL){\\n            forward=forward->next;\\n        }\\n        forward->next=head;\\n        return ansHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888598,
                "title": "java-brute-force-optimal-clean-and-simple",
                "content": "# **Please Upvote** :D\\n##### 1. Brute force approach:\\n![image.png](https://assets.leetcode.com/users/images/7cddfd0b-ecdd-49bf-a69e-f0d3be8165a7_1670446044.8196685.png)\\n\\n```java []\\n\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null || head.next == null) return head;\\n\\n        ListNode curr = head;\\n        int size = 0;\\n\\n        while (curr != null) {\\n            size++;\\n            curr = curr.next;\\n        }\\n\\n        k %= size;\\n        int count = 0;\\n\\n        while (count++ != k) {\\n            curr = head;\\n            while (curr.next.next != null) {\\n                curr = curr.next;\\n            }\\n\\n            ListNode end = curr.next;\\n            curr.next = null;\\n            end.next = head;\\n            head = end;\\n        }\\n\\n        return head;\\n    }\\n}\\n\\n// TC: O(n) + O(n ^ 2) => O(n ^ 2)\\n\\n// In case our k is greater than n,\\n// we mod k by n to make it less than n,\\n// so at max k can be n - 1\\n// So O(k * n) => O((n-1) * n) => O(n ^ 2)\\n// If we don\\'t do it, we will get a TLE\\n\\n// SC: O(1)\\n```\\n\\n##### 2. Optimal approach:\\n![image.png](https://assets.leetcode.com/users/images/dc81f6a7-0b37-4a25-9d34-c5ea496d0b22_1670445816.6215196.png)\\n\\n``` java []\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null || head.next == null || k == 0) return head;\\n\\n        ListNode curr = head;\\n        int size = 1;\\n\\n        while (curr.next != null) {\\n            size++;\\n            curr = curr.next;\\n        }\\n\\n        curr.next = head;\\n        k %= size;\\n        k = size - k;\\n        // or k = size - (k % size);\\n\\n        while (k-- > 0) {\\n            curr = curr.next;\\n        }\\n\\n        head = curr.next;\\n        curr.next = null;\\n\\n        return head;\\n    }\\n}\\n\\n// TC: O(n) + O(n - k%n) => O(n)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```java []\\n\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null || head.next == null) return head;\\n\\n        ListNode curr = head;\\n        int size = 0;\\n\\n        while (curr != null) {\\n            size++;\\n            curr = curr.next;\\n        }\\n\\n        k %= size;\\n        int count = 0;\\n\\n        while (count++ != k) {\\n            curr = head;\\n            while (curr.next.next != null) {\\n                curr = curr.next;\\n            }\\n\\n            ListNode end = curr.next;\\n            curr.next = null;\\n            end.next = head;\\n            head = end;\\n        }\\n\\n        return head;\\n    }\\n}\\n\\n// TC: O(n) + O(n ^ 2) => O(n ^ 2)\\n\\n// In case our k is greater than n,\\n// we mod k by n to make it less than n,\\n// so at max k can be n - 1\\n// So O(k * n) => O((n-1) * n) => O(n ^ 2)\\n// If we don\\'t do it, we will get a TLE\\n\\n// SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null || head.next == null || k == 0) return head;\\n\\n        ListNode curr = head;\\n        int size = 1;\\n\\n        while (curr.next != null) {\\n            size++;\\n            curr = curr.next;\\n        }\\n\\n        curr.next = head;\\n        k %= size;\\n        k = size - k;\\n        // or k = size - (k % size);\\n\\n        while (k-- > 0) {\\n            curr = curr.next;\\n        }\\n\\n        head = curr.next;\\n        curr.next = null;\\n\\n        return head;\\n    }\\n}\\n\\n// TC: O(n) + O(n - k%n) => O(n)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777504,
                "title": "easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head ==NULL)return NULL;\\n        vector<int> nums;\\n        ListNode* p = head;\\n        while(p){\\n            nums.push_back(p->val);\\n            p = p->next;\\n        }\\n        k = k%nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n        ListNode* a = new ListNode(nums[0]);\\n        ListNode* b = a;\\n        for(int i =1; i<nums.size(); i++){\\n            b->next = new ListNode(nums[i]);\\n            b = b->next;\\n        }\\n        return a;\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (head ==NULL)return NULL;\\n        vector<int> nums;\\n        ListNode* p = head;\\n        while(p){\\n            nums.push_back(p->val);\\n            p = p->next;\\n        }\\n        k = k%nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n        ListNode* a = new ListNode(nums[0]);\\n        ListNode* b = a;\\n        for(int i =1; i<nums.size(); i++){\\n            b->next = new ListNode(nums[i]);\\n            b = b->next;\\n        }\\n        return a;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681554,
                "title": "java-easy-explained",
                "content": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\t// If no rotation is required\\n     if (k<=0 || head==null|| head.next==null){\\n            return head;\\n        }\\n\\n        int length=1;\\n        ListNode last=head;\\n\\t\\t\\n\\t\\t// For reaching to last Node and getting lenght\\n        while (last.next!=null){\\n            last=last.next;\\n            length++;\\n        }\\n\\t\\t// Now point last node to current head\\n        last.next=head;\\n\\t\\t// if k<6\\n        int roatations=k%length;\\n\\t\\t// no of skip need to made get desired new last node \\n        int skip=length-roatations;\\n        ListNode newLast=head;\\n\\t\\t\\n\\t\\t// Traversing till new last\\n        for (int i = 0; i < skip-1; i++) {\\n            newLast=newLast.next;\\n        }\\n\\t\\t// Now Pointing , new Last to new head;\\n        head=newLast.next;\\n\\t\\t// At last put new last point to null\\n        newLast.next=null;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\t// If no rotation is required\\n     if (k<=0 || head==null|| head.next==null){\\n            return head;\\n        }\\n\\n        int length=1;\\n        ListNode last=head;\\n\\t\\t\\n\\t\\t// For reaching to last Node and getting lenght\\n        while (last.next!=null){\\n            last=last.next;\\n            length++;\\n        }\\n\\t\\t// Now point last node to current head\\n        last.next=head;\\n\\t\\t// if k<6\\n        int roatations=k%length;\\n\\t\\t// no of skip need to made get desired new last node \\n        int skip=length-roatations;\\n        ListNode newLast=head;\\n\\t\\t\\n\\t\\t// Traversing till new last\\n        for (int i = 0; i < skip-1; i++) {\\n            newLast=newLast.next;\\n        }\\n\\t\\t// Now Pointing , new Last to new head;\\n        head=newLast.next;\\n\\t\\t// At last put new last point to null\\n        newLast.next=null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266975,
                "title": "rotate-list",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        ListNode* temp = head;\\n        ListNode* curr = head;\\n        \\n        if(!head or !head->next)\\n            return head;\\n        int len = 1;\\n        while(temp->next){\\n            temp = temp -> next;\\n            len++;\\n        }\\n        // mod of k with cnt to find the minimum no of rotations.\\n        k = k % len;\\n        while(k--){\\n            temp = head;\\n            curr = head;\\n            while(curr -> next){\\n                temp = curr;\\n                curr = curr->next;\\n            }\\n            temp->next = NULL;\\n            curr->next = head;\\n            head = curr;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        ListNode* temp = head;\\n        ListNode* curr = head;\\n        \\n        if(!head or !head->next)\\n            return head;\\n        int len = 1;\\n        while(temp->next){\\n            temp = temp -> next;\\n            len++;\\n        }\\n        // mod of k with cnt to find the minimum no of rotations.\\n        k = k % len;\\n        while(k--){\\n            temp = head;\\n            curr = head;\\n            while(curr -> next){\\n                temp = curr;\\n                curr = curr->next;\\n            }\\n            temp->next = NULL;\\n            curr->next = head;\\n            head = curr;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235034,
                "title": "c-easy-explanation-with-pen-paper-optimal-approach",
                "content": "![image](https://assets.leetcode.com/users/images/8ed378f1-5f24-458c-a49f-0c5da71021a6_1656911105.8269634.jpeg)\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // Edge cases\\n        if(!head || !head->next || k==0)return head;\\n        \\n        //compute length of the list \\n        ListNode *cur=head;\\n        int length=1;\\n        while(cur->next)\\n        {\\n            cur=cur->next;\\n            ++length;\\n        }  // after this loop cur will be on last node\\n        \\n        // join last node with first Node\\n        cur->next=head;\\n        if(k>=length)    \\n         k=k%length;\\n        \\n        // main logic start from here\\n        k=length-k;      // k=(length-k)th node\\n        while(k--)     //go upto (length-k)th node \\n        {\\n            cur=cur->next;   \\n        }\\n        \\n        head=cur->next; // make head to point on  (length-k)th->next  node\\n        cur->next=NULL; // and then make  (length-k)th node null\\n        \\n        return head;\\n    }\\n};\\n//======================\\uD83D\\uDC4D\\uD83E\\uDD17Do upvote if you got the logic =========================\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        // Edge cases\\n        if(!head || !head->next || k==0)return head;\\n        \\n        //compute length of the list \\n        ListNode *cur=head;\\n        int length=1;\\n        while(cur->next)\\n        {\\n            cur=cur->next;\\n            ++length;\\n        }  // after this loop cur will be on last node\\n        \\n        // join last node with first Node\\n        cur->next=head;\\n        if(k>=length)    \\n         k=k%length;\\n        \\n        // main logic start from here\\n        k=length-k;      // k=(length-k)th node\\n        while(k--)     //go upto (length-k)th node \\n        {\\n            cur=cur->next;   \\n        }\\n        \\n        head=cur->next; // make head to point on  (length-k)th->next  node\\n        cur->next=NULL; // and then make  (length-k)th node null\\n        \\n        return head;\\n    }\\n};\\n//======================\\uD83D\\uDC4D\\uD83E\\uDD17Do upvote if you got the logic =========================\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124136,
                "title": "simple-js-solution-w-comments-iterative",
                "content": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(1)\\n */\\n// Runtime: 84 ms, faster than 66.96% of JavaScript online submissions for Rotate List.\\n// Memory Usage: 44.8 MB, less than 6.85% of JavaScript online submissions for Rotate List.\\nconst rotateRight = (head, k) => {\\n\\tif (!head) return null;\\n\\n\\tlet tail = head;\\n\\tlet len = 1; // 1-index based\\n\\n\\t// get tail node and length of LL\\n\\twhile (tail.next) {\\n\\t\\ttail = tail.next;\\n\\t\\tlen++;\\n\\t}\\n\\n\\ttail.next = head; // create cycle: connect to head\\n\\tlen = len - (k % len);\\n\\n\\t// if len === k: rotates to original LL\\n\\tif (len === 0) return head;\\n\\n\\t// find point of reverse\\n\\twhile (len--) {\\n\\t\\ttail = tail.next;\\n\\t}\\n\\n\\thead = tail.next; // set as new head\\n\\ttail.next = null; // server connection\\n\\n\\treturn head;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(1)\\n */\\n// Runtime: 84 ms, faster than 66.96% of JavaScript online submissions for Rotate List.\\n// Memory Usage: 44.8 MB, less than 6.85% of JavaScript online submissions for Rotate List.\\nconst rotateRight = (head, k) => {\\n\\tif (!head) return null;\\n\\n\\tlet tail = head;\\n\\tlet len = 1; // 1-index based\\n\\n\\t// get tail node and length of LL\\n\\twhile (tail.next) {\\n\\t\\ttail = tail.next;\\n\\t\\tlen++;\\n\\t}\\n\\n\\ttail.next = head; // create cycle: connect to head\\n\\tlen = len - (k % len);\\n\\n\\t// if len === k: rotates to original LL\\n\\tif (len === 0) return head;\\n\\n\\t// find point of reverse\\n\\twhile (len--) {\\n\\t\\ttail = tail.next;\\n\\t}\\n\\n\\thead = tail.next; // set as new head\\n\\ttail.next = null; // server connection\\n\\n\\treturn head;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2093972,
                "title": "easy-c-solution-with-o-1-space-complexity-and-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n\\t\\n\\t\\t// if linked list is NULL or k is 0 than return head\\n        if(k == 0 or head == NULL) return head;\\n\\t\\t\\n\\t\\t// first find the size of the linked list, and point tail at the end of the linked list\\n        int size = 0;\\n        ListNode* tail = new ListNode(0, head);\\n        while(tail->next)\\n        {\\n            tail = tail->next;\\n            size++;\\n        }\\n\\t\\t\\n\\t\\t// now if the value of k is greater than size than update it, as after this we need not to rotate list more than size time\\n        k %= size;\\n\\t\\t\\n\\t\\t// if k is zero than return head as we need not to rotate the list\\n        if(k == 0) return head;\\n\\t\\t\\n\\t\\t// now we need to rotate the linked list so we point our linked list tail to head\\n        tail -> next = head;\\n\\t\\t\\n\\t\\t// subtract k from the size to find the rotation point from the start and make it head and its tail equal to NULL\\n        k = size - k;\\n        ListNode* temp = new ListNode(0, head);\\n        while(k--)\\n        {\\n            temp = temp->next;\\n        }\\n        head = temp->next;\\n        temp->next = NULL;\\n\\t\\t\\n\\t\\t// return the new head\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n\\t\\n\\t\\t// if linked list is NULL or k is 0 than return head\\n        if(k == 0 or head == NULL) return head;\\n\\t\\t\\n\\t\\t// first find the size of the linked list, and point tail at the end of the linked list\\n        int size = 0;\\n        ListNode* tail = new ListNode(0, head);\\n        while(tail->next)\\n        {\\n            tail = tail->next;\\n            size++;\\n        }\\n\\t\\t\\n\\t\\t// now if the value of k is greater than size than update it, as after this we need not to rotate list more than size time\\n        k %= size;\\n\\t\\t\\n\\t\\t// if k is zero than return head as we need not to rotate the list\\n        if(k == 0) return head;\\n\\t\\t\\n\\t\\t// now we need to rotate the linked list so we point our linked list tail to head\\n        tail -> next = head;\\n\\t\\t\\n\\t\\t// subtract k from the size to find the rotation point from the start and make it head and its tail equal to NULL\\n        k = size - k;\\n        ListNode* temp = new ListNode(0, head);\\n        while(k--)\\n        {\\n            temp = temp->next;\\n        }\\n        head = temp->next;\\n        temp->next = NULL;\\n\\t\\t\\n\\t\\t// return the new head\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083741,
                "title": "explained-using-images-c-solution-well-explained-readable-code",
                "content": "![image](https://assets.leetcode.com/users/images/aa09ab34-01a7-4428-a8d8-7d1b38e4816e_1653753173.8543854.jpeg)\\n![image](https://assets.leetcode.com/users/images/dec10784-08c0-4062-9289-516db336490b_1653753188.5238533.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthofll(ListNode*head){                     // FUNCTION FOR FINDING NUMBER OF NODES\\n        int cnt=0;\\n        while(head){\\n            cnt++;\\n            head = head->next;\\n        }\\n        return cnt;\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next || k==0) return head; // STEP 1  BASE CASE   \\n        int n = lengthofll(head);                     // STEP 2  FINDING NO OF NODES\\n        if(n==k || k%n==0) return head;               // STEP 3  AGAIN CHECKING REFER IMAGES FOR WHY\\n        int k1;                                      //  STEP 4  SIMPLIFYING K  \\n        if(k>n){\\n            k1 = k%n;\\n        }\\n        else if(k < n){\\n            k1 = k;\\n        }\\n        ListNode*curr_head,*last;\\n        ListNode*curr = head;\\n        int cnt = 0;\\n        for(int i=1;i<n;i++){                       // STEP 5 FINAL ROTATION\\n            if(i==n-k1){\\n                last = curr;\\n            }\\n            curr = curr->next;\\n        }\\n        curr->next = head;\\n        curr_head = last->next;\\n        last->next = nullptr;\\n        return curr_head;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthofll(ListNode*head){                     // FUNCTION FOR FINDING NUMBER OF NODES\\n        int cnt=0;\\n        while(head){\\n            cnt++;\\n            head = head->next;\\n        }\\n        return cnt;\\n    }\\n    \\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next || k==0) return head; // STEP 1  BASE CASE   \\n        int n = lengthofll(head);                     // STEP 2  FINDING NO OF NODES\\n        if(n==k || k%n==0) return head;               // STEP 3  AGAIN CHECKING REFER IMAGES FOR WHY\\n        int k1;                                      //  STEP 4  SIMPLIFYING K  \\n        if(k>n){\\n            k1 = k%n;\\n        }\\n        else if(k < n){\\n            k1 = k;\\n        }\\n        ListNode*curr_head,*last;\\n        ListNode*curr = head;\\n        int cnt = 0;\\n        for(int i=1;i<n;i++){                       // STEP 5 FINAL ROTATION\\n            if(i==n-k1){\\n                last = curr;\\n            }\\n            curr = curr->next;\\n        }\\n        curr->next = head;\\n        curr_head = last->next;\\n        last->next = nullptr;\\n        return curr_head;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869972,
                "title": "c-easiest-solution",
                "content": "This approach is applicable to a lot of scenarios where rotation is needed. Let me know if you need help or unsure about my approach, I will gladly help you!!! Please give me an upvote as your token of appreciation if you find this helpful XD.\\n\\n```\\nListNode* rotateRight(ListNode* head, int k) {\\n        if (!head)\\n            return head;\\n        \\n        ListNode* current = head;\\n        ListNode* ans = new ListNode;\\n        ListNode* currAns = ans;\\n        \\n        std::vector<int> temp;\\n        \\n        while (current)\\n        {\\n            temp.push_back(current->val);\\n            current = current->next;\\n        }\\n        \\n        std::rotate(temp.begin(), temp.end() - (k > temp.size() ? k % temp.size() : k), temp.end());\\n        \\n        for(int i = 0; i < temp.size(); ++i)\\n        {\\n            currAns->next = new ListNode(temp[i]);\\n            currAns = currAns->next;\\n        }\\n        \\n        return ans->next;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* rotateRight(ListNode* head, int k) {\\n        if (!head)\\n            return head;\\n        \\n        ListNode* current = head;\\n        ListNode* ans = new ListNode;\\n        ListNode* currAns = ans;\\n        \\n        std::vector<int> temp;\\n        \\n        while (current)\\n        {\\n            temp.push_back(current->val);\\n            current = current->next;\\n        }\\n        \\n        std::rotate(temp.begin(), temp.end() - (k > temp.size() ? k % temp.size() : k), temp.end());\\n        \\n        for(int i = 0; i < temp.size(); ++i)\\n        {\\n            currAns->next = new ListNode(temp[i]);\\n            currAns = currAns->next;\\n        }\\n        \\n        return ans->next;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1839920,
                "title": "c-efficient-tc-o-n-sc-o-1-easy-short-clean-solution-with-exp",
                "content": "#### if you find its Helpful, please UPVOTE :)\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next || k==0) return head;//edge case\\n        int len=1;\\n        ListNode* curr=head;\\n        while(curr->next){//counting length of ll\\n            len++;\\n            curr=curr->next;\\n        }\\n        curr->next=head;//connecting the last node to the head(makingcircular linked list) \\n        k=k%len;//\\n        k=len-k;\\n        while(k--)curr=curr->next;//travers to the (len-k) th node\\n        head=curr->next;//move the head to the new head\\n        curr->next=NULL;//break the list \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next || k==0) return head;//edge case\\n        int len=1;\\n        ListNode* curr=head;\\n        while(curr->next){//counting length of ll\\n            len++;\\n            curr=curr->next;\\n        }\\n        curr->next=head;//connecting the last node to the head(makingcircular linked list) \\n        k=k%len;//\\n        k=len-k;\\n        while(k--)curr=curr->next;//travers to the (len-k) th node\\n        head=curr->next;//move the head to the new head\\n        curr->next=NULL;//break the list \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839100,
                "title": "go-0ms-solution",
                "content": "**Runtime:** 0 ms, faster than **100.00%** of Go online submissions for Rotate List.\\n**Memory Usage:** 2.6 MB, less than **30.22%** of Go online submissions for Rotate List.\\n\\n```go\\nfunc rotateRight( head *ListNode, k int ) *ListNode {\\n\\n    if k == 0 || head == nil{\\n        return head\\n    }\\n    var dummy  = &ListNode{Next: head}\\n    count, tail, sp := 0, head, head\\n    \\n    for tail.Next != nil {\\n        count++\\n        tail = tail.Next\\n    }\\n    count++\\n    j := k%count\\n    for i:=1; i < count-j;i++{\\n        sp = sp.Next\\n    }\\n    \\n    tail.Next = head\\n    dummy.Next = sp.Next\\n    sp.Next = nil\\n    \\n    return dummy.Next\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc rotateRight( head *ListNode, k int ) *ListNode {\\n\\n    if k == 0 || head == nil{\\n        return head\\n    }\\n    var dummy  = &ListNode{Next: head}\\n    count, tail, sp := 0, head, head\\n    \\n    for tail.Next != nil {\\n        count++\\n        tail = tail.Next\\n    }\\n    count++\\n    j := k%count\\n    for i:=1; i < count-j;i++{\\n        sp = sp.Next\\n    }\\n    \\n    tail.Next = head\\n    dummy.Next = sp.Next\\n    sp.Next = nil\\n    \\n    return dummy.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1838844,
                "title": "python-go-c-rotate-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python/GO/C++] \\uD83C\\uDF1F Rotate Solution and Explanation \\uD83D\\uDC95\\n## 1\\uFE0F\\u20E3 Main Idea:\\nBy example```[1,2,3,4,5], k = 2``` The answer will be move length = 2 tail to head ```[4,5,  1,2,3]```.\\nSince it\\'s a linked-list, we can only traverse whole linked-list from head to tail. So we have to find the length before **k length tail** first.\\nBut in example 2 ```head = [0,1,2], k = 4``` We can k mod 3 = 1, to calculate new k value. And move 2 to be new head ```[2,0,1]```\\n\\n**Algo**\\n1. Calculate **length** of linked-list, and make it **circular** (We will break circular at final step)\\n2. Make k %= length, and calculate **lengthPrev** to be length before k element => lengthPrev = length - k - 1 (1 will be initial length when we start from head)\\n3. Traverse linked-list from head, once curr in the lengthPrev node, we know it\\'s new tail of result\\n\\tnewHead = curr.next, and make curr.next = None\\n4. return newHead\\n## Complexity Analysis\\n* Time: O(N): Let N be the length of linked list\\n* Space: O(1)\\n\\n## Code\\n\\n**Python**\\n```python\\n# O(N) | O(1)\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n        length = 1\\n        curr = head\\n        # Calculate length of linked-list\\n        while curr.next is not None:\\n            length += 1\\n            curr = curr.next\\n        curr.next = head\\n        \\n        # Calculate length before k element\\n        k %= length\\n        lengthPrev = length - k - 1\\n        curr = head\\n        # Move curr to new tail\\n        for _ in range(lengthPrev):\\n            curr = curr.next\\n        # New head would be tail.next\\n        res = curr.next\\n        # Make tali point to None\\n        curr.next = None\\n        \\n        return res\\n```\\n**Go**\\n```go\\nfunc rotateRight(head *ListNode, k int) *ListNode {\\n    if head == nil || head.Next == nil{\\n        return head\\n    }\\n    \\n    length := 1\\n    curr := head\\n    // Calculate length of linked-list and make it circular\\n    for curr.Next != nil{\\n        length += 1\\n        curr = curr.Next\\n    }\\n    curr.Next = head\\n    // Calculate length before k element\\n    k %= length\\n    lengthPrev := length - k - 1\\n    curr = head\\n    // Move curr to new tail\\n    for i := 0; i < lengthPrev; i++{\\n        curr = curr.Next\\n    }\\n    // New head would be tail.next\\n    res := curr.Next\\n    // Make tali point to None\\n    curr.Next = nil\\n    \\n    return res\\n}\\n```\\n**C++**\\n```C++\\n// O(N) | O(1)\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (!head || !head->next) return head;\\n        int length = 1;\\n        ListNode* curr = head;\\n        while (curr->next){\\n            length++;\\n            curr = curr->next;\\n        }\\n        curr->next = head;\\n        \\n        k %= length;\\n        int lengthPrev = length - k - 1;\\n        curr = head;\\n        for (int i = 0; i < lengthPrev; i++){\\n            curr = curr->next;\\n        }\\n        ListNode* res = curr->next;\\n        curr->next = nullptr;\\n        return res;\\n    }\\n};\\n```\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [
                    "Python",
                    "C",
                    "Go"
                ],
                "code": "```[1,2,3,4,5], k = 2```\n```[4,5,  1,2,3]```\n```head = [0,1,2], k = 4```\n```[2,0,1]```\n```python\\n# O(N) | O(1)\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n        length = 1\\n        curr = head\\n        # Calculate length of linked-list\\n        while curr.next is not None:\\n            length += 1\\n            curr = curr.next\\n        curr.next = head\\n        \\n        # Calculate length before k element\\n        k %= length\\n        lengthPrev = length - k - 1\\n        curr = head\\n        # Move curr to new tail\\n        for _ in range(lengthPrev):\\n            curr = curr.next\\n        # New head would be tail.next\\n        res = curr.next\\n        # Make tali point to None\\n        curr.next = None\\n        \\n        return res\\n```\n```go\\nfunc rotateRight(head *ListNode, k int) *ListNode {\\n    if head == nil || head.Next == nil{\\n        return head\\n    }\\n    \\n    length := 1\\n    curr := head\\n    // Calculate length of linked-list and make it circular\\n    for curr.Next != nil{\\n        length += 1\\n        curr = curr.Next\\n    }\\n    curr.Next = head\\n    // Calculate length before k element\\n    k %= length\\n    lengthPrev := length - k - 1\\n    curr = head\\n    // Move curr to new tail\\n    for i := 0; i < lengthPrev; i++{\\n        curr = curr.Next\\n    }\\n    // New head would be tail.next\\n    res := curr.Next\\n    // Make tali point to None\\n    curr.Next = nil\\n    \\n    return res\\n}\\n```\n```C++\\n// O(N) | O(1)\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (!head || !head->next) return head;\\n        int length = 1;\\n        ListNode* curr = head;\\n        while (curr->next){\\n            length++;\\n            curr = curr->next;\\n        }\\n        curr->next = head;\\n        \\n        k %= length;\\n        int lengthPrev = length - k - 1;\\n        curr = head;\\n        for (int i = 0; i < lengthPrev; i++){\\n            curr = curr->next;\\n        }\\n        ListNode* res = curr->next;\\n        curr->next = nullptr;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838430,
                "title": "converting-into-circular-list-then-rotating-by-k",
                "content": "Converted the list into circular list then traversed find the (size-k)th node and delink it i.e, make it point to NULL, but before doing this store next node in ans variable and return it.\\n```\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next){\\n            return head;\\n        }\\n        \\n        int len=0,last=0;\\n        ListNode *temp=head,*ans=head,*t1=head;\\n        while(temp->next){\\n            len++;\\n            temp=temp->next;\\n        }\\n        \\n        len++;\\n        k=k%len; \\n        if(k==0){               //no rotation\\n            return head;\\n        }\\n        \\n        //converting list into circular list\\n        temp->next=head;\\n        \\n        //rotate list by delinking (len-k)th node and setting it to null\\n        k=(len-k);\\n        k--;\\n        while(k>0){\\n            k--;\\n            t1=t1->next;\\n        }\\n        ans=t1->next;\\n        t1->next=NULL;\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head || !head->next){\\n            return head;\\n        }\\n        \\n        int len=0,last=0;\\n        ListNode *temp=head,*ans=head,*t1=head;\\n        while(temp->next){\\n            len++;\\n            temp=temp->next;\\n        }\\n        \\n        len++;\\n        k=k%len; \\n        if(k==0){               //no rotation\\n            return head;\\n        }\\n        \\n        //converting list into circular list\\n        temp->next=head;\\n        \\n        //rotate list by delinking (len-k)th node and setting it to null\\n        k=(len-k);\\n        k--;\\n        while(k>0){\\n            k--;\\n            t1=t1->next;\\n        }\\n        ans=t1->next;\\n        t1->next=NULL;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1790963,
                "title": "solution-swift-rotate-list",
                "content": "```swift\\nclass Solution {\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        if head == nil { return nil }\\n        \\n        var prev = head, post = head\\n        \\n        var len: Int {\\n            get {\\n                var value = 0\\n                var dummy = head\\n                while let node = dummy {\\n                    dummy = node.next\\n                    value += 1\\n                }\\n                return value\\n            }\\n        }\\n        \\n        var places = (k % len)\\n        \\n        while places > 0 {\\n            post = post?.next\\n            places -= 1\\n        }\\n        \\n        while let postnext = post?.next {\\n            post = postnext\\n            prev = prev?.next\\n        }\\n        \\n        post?.next = head\\n        post = prev?.next\\n        prev?.next = nil\\n        \\n        return post\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><b>ListNode</b></summary>\\n\\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n}\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        if head == nil { return nil }\\n        \\n        var prev = head, post = head\\n        \\n        var len: Int {\\n            get {\\n                var value = 0\\n                var dummy = head\\n                while let node = dummy {\\n                    dummy = node.next\\n                    value += 1\\n                }\\n                return value\\n            }\\n        }\\n        \\n        var places = (k % len)\\n        \\n        while places > 0 {\\n            post = post?.next\\n            places -= 1\\n        }\\n        \\n        while let postnext = post?.next {\\n            post = postnext\\n            prev = prev?.next\\n        }\\n        \\n        post?.next = head\\n        post = prev?.next\\n        prev?.next = nil\\n        \\n        return post\\n    }\\n}\\n```\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727748,
                "title": "68-ms-faster-than-99-52-of-javascript-code",
                "content": "```\\nvar rotateRight = function(head, k) {\\n     \\n    if(!head || !head.next)return head;\\n    let pointer=head;\\n    let prevNode=null;\\n    let count=1;\\n    while(pointer.next){\\n        prevNode=pointer;\\n        pointer=pointer.next;\\n        count++;\\n    }\\n    k=k%count;\\n    if(k===0){\\n        return head;\\n    }\\n    prevNode.next=null;\\n    pointer.next=head;\\n    head=pointer;\\n    return rotateRight(head,k-1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar rotateRight = function(head, k) {\\n     \\n    if(!head || !head.next)return head;\\n    let pointer=head;\\n    let prevNode=null;\\n    let count=1;\\n    while(pointer.next){\\n        prevNode=pointer;\\n        pointer=pointer.next;\\n        count++;\\n    }\\n    k=k%count;\\n    if(k===0){\\n        return head;\\n    }\\n    prevNode.next=null;\\n    pointer.next=head;\\n    head=pointer;\\n    return rotateRight(head,k-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1422635,
                "title": "0ms-100-c-solution-with-clear-explanation",
                "content": "```\\nstruct ListNode* rotateRight(struct ListNode* head, int k){\\n     if (!head || !head->next || !k ) return head;\\n \\n    // find the tail, compute the len to find k.\\n    // since were not iterate the whole list to NULL\\n    // len starts from 1.\\n    int len = 1;\\n    struct ListNode *curr = head;\\n    while (curr->next != NULL) {\\n        len++;\\n        curr = curr->next;\\n    }\\n    // Now curr points to last node, circle the list.\\n    curr->next = head;\\n    // Find the rotate position.\\n    int position = len - k % len;\\n    for (int i = 0; i < position; i++) {\\n        // Since list is circled, move the curr to position.\\n        curr = curr->next;\\n    } \\n    // Since the list is circled, change head to (position+1)th node.\\n    head = curr->next;\\n    // Change the next of curr node to NULL to uncircle the list.\\n    curr->next = NULL;\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ListNode* rotateRight(struct ListNode* head, int k){\\n     if (!head || !head->next || !k ) return head;\\n \\n    // find the tail, compute the len to find k.\\n    // since were not iterate the whole list to NULL\\n    // len starts from 1.\\n    int len = 1;\\n    struct ListNode *curr = head;\\n    while (curr->next != NULL) {\\n        len++;\\n        curr = curr->next;\\n    }\\n    // Now curr points to last node, circle the list.\\n    curr->next = head;\\n    // Find the rotate position.\\n    int position = len - k % len;\\n    for (int i = 0; i < position; i++) {\\n        // Since list is circled, move the curr to position.\\n        curr = curr->next;\\n    } \\n    // Since the list is circled, change head to (position+1)th node.\\n    head = curr->next;\\n    // Change the next of curr node to NULL to uncircle the list.\\n    curr->next = NULL;\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1383821,
                "title": "java-solution-beats-100-in-time-and-93-in-memory",
                "content": "Java Solution \\nBeats 100% in time and 93% in memory.\\n\\n\\n```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        // handle the edge cases\\n        if (head == null) return null;\\n        //iterating pointer\\n        ListNode itr = head;\\n        //length of list\\n        int len = 1;\\n        //get the length of the list and set last nodes pointer to head.\\n        while(itr.next != null){\\n            len++;\\n            itr = itr.next;\\n        }\\n        //set the pointer to head\\n        itr.next = head;\\n        //reset pointer\\n        itr = head;\\n        //mathematical formula to determine where the head should be pointing\\n        int headpointer = len + 1 - (k%len);\\n        //travel to the node previous to headpointer\\n        for(int i = 1; i < headpointer -1; i++){\\n            itr = itr.next;\\n        }\\n        //set the curr node as head node and prev nodes next pointer to null to break the cycle.\\n        head = itr.next;\\n        itr.next = null;\\n        return head;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        // handle the edge cases\\n        if (head == null) return null;\\n        //iterating pointer\\n        ListNode itr = head;\\n        //length of list\\n        int len = 1;\\n        //get the length of the list and set last nodes pointer to head.\\n        while(itr.next != null){\\n            len++;\\n            itr = itr.next;\\n        }\\n        //set the pointer to head\\n        itr.next = head;\\n        //reset pointer\\n        itr = head;\\n        //mathematical formula to determine where the head should be pointing\\n        int headpointer = len + 1 - (k%len);\\n        //travel to the node previous to headpointer\\n        for(int i = 1; i < headpointer -1; i++){\\n            itr = itr.next;\\n        }\\n        //set the curr node as head node and prev nodes next pointer to null to break the cycle.\\n        head = itr.next;\\n        itr.next = null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354375,
                "title": "c-easy-solution-optimal",
                "content": "```\\nListNode* rotateRight(ListNode* head, int k) {\\n        \\n        if( head == NULL || head->next == NULL ) return head;\\n        \\n        \\n        ListNode *temp = head;\\n        int len = 1;\\n        while( temp->next && ++len ){\\n            temp = temp->next;\\n         }\\n        \\n        \\n        //point last node to first node \\n        temp->next = head;\\n        int actual_rotation = k%len;\\n        actual_rotation = len - actual_rotation;\\n        \\n        while( actual_rotation-- ){\\n            temp = temp->next;\\n        }\\n        \\n        head = temp->next;\\n        temp->next = NULL;\\n        return head;\\n    }\\n```\\n\\nIdea is to make circular linked list and then singly linked list. If you got any query feel free to ask query.And if you like my solution please upvote.",
                "solutionTags": [],
                "code": "```\\nListNode* rotateRight(ListNode* head, int k) {\\n        \\n        if( head == NULL || head->next == NULL ) return head;\\n        \\n        \\n        ListNode *temp = head;\\n        int len = 1;\\n        while( temp->next && ++len ){\\n            temp = temp->next;\\n         }\\n        \\n        \\n        //point last node to first node \\n        temp->next = head;\\n        int actual_rotation = k%len;\\n        actual_rotation = len - actual_rotation;\\n        \\n        while( actual_rotation-- ){\\n            temp = temp->next;\\n        }\\n        \\n        head = temp->next;\\n        temp->next = NULL;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1337323,
                "title": "0-ms-c-100-simple-and-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        \\n        int len = 0, rotation = 0;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            len++;\\n            temp = temp->next;\\n        }\\n        \\n        k = k % len;\\n        \\n        ListNode *preTail = head, *tail = head;\\n        for(int i = 0; i < k; i++){\\n            while(tail->next != NULL){\\n                preTail = tail;\\n                tail = tail->next;\\n            }\\n            preTail->next = NULL;\\n            tail->next = head;\\n            head = tail;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        \\n        int len = 0, rotation = 0;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            len++;\\n            temp = temp->next;\\n        }\\n        \\n        k = k % len;\\n        \\n        ListNode *preTail = head, *tail = head;\\n        for(int i = 0; i < k; i++){\\n            while(tail->next != NULL){\\n                preTail = tail;\\n                tail = tail->next;\\n            }\\n            preTail->next = NULL;\\n            tail->next = head;\\n            head = tail;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184214,
                "title": "python-3-simple-2-pointers-approach-w-comments",
                "content": "**IDEA**\\nIdea here is to first compute the length of list and maintain 2 pointers -  one at (length-k) node and other at tail node. Now,\\n1. Attach the tail node to head node.\\n2. Make the next node to (length-k)th node as the new head node.\\n3. Make the next of (length-k)th node None.\\n\\n**CAUTION**\\n**Avoid rotating each and every node k number of times in a loop. This wil cause TLE.**\\n\\n```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        # Base case\\n\\t\\tif head is None or head.next is None:\\n            return head\\n        \\n\\t\\t# Compute the length of list and maintain a pointer for the tail of list.\\n        curr = head\\n        length = 0\\n        while curr.next is not None:\\n            length += 1\\n            curr = curr.next\\n        length += 1\\n        \\n\\t\\t# No. of rotations cannot be greater than the length of list. Hence, the modulo operation.\\n        k = k%length\\n        \\n\\t\\t# Return head if k is equal to 0 or the length of list i.e. no rotation case.\\n        if k == length or k == 0:\\n            return head\\n           \\n\\t\\t# Maintain a pointer for the (length-k)th node.\\n        prev = head\\n        for i in range(1, length-k):\\n            prev = prev.next\\n\\t\\t\\t\\n\\t\\t# Perform the 3 step operation given in the Idea section.\\n        curr.next = head\\n        head = prev.next\\n        prev.next = None\\n\\t\\t\\n        return head\\n            \\n```\\n\\nFeel free to comment down your answers or post your query, doubt or question :)",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        # Base case\\n\\t\\tif head is None or head.next is None:\\n            return head\\n        \\n\\t\\t# Compute the length of list and maintain a pointer for the tail of list.\\n        curr = head\\n        length = 0\\n        while curr.next is not None:\\n            length += 1\\n            curr = curr.next\\n        length += 1\\n        \\n\\t\\t# No. of rotations cannot be greater than the length of list. Hence, the modulo operation.\\n        k = k%length\\n        \\n\\t\\t# Return head if k is equal to 0 or the length of list i.e. no rotation case.\\n        if k == length or k == 0:\\n            return head\\n           \\n\\t\\t# Maintain a pointer for the (length-k)th node.\\n        prev = head\\n        for i in range(1, length-k):\\n            prev = prev.next\\n\\t\\t\\t\\n\\t\\t# Perform the 3 step operation given in the Idea section.\\n        curr.next = head\\n        head = prev.next\\n        prev.next = None\\n\\t\\t\\n        return head\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180024,
                "title": "python-simplest-solution-100-faster",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if head is None or head.next is None:\\n            return head\\n        \\n        length=0\\n        start=head\\n        prev=None\\n        \\n        while start :\\n            \\n            length+=1\\n            prev=start\\n            start=start.next\\n        \\n        k=k%length\\n        \\n        if k==length or k==0:\\n            return head \\n        \\n        \\n        prev.next=head\\n        prev=None\\n        \\n      \\n        \\n        for i in range(length-k):\\n            prev=head\\n            head=head.next\\n        \\n        prev.next=None\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        \\n        if head is None or head.next is None:\\n            return head\\n        \\n        length=0\\n        start=head\\n        prev=None\\n        \\n        while start :\\n            \\n            length+=1\\n            prev=start\\n            start=start.next\\n        \\n        k=k%length\\n        \\n        if k==length or k==0:\\n            return head \\n        \\n        \\n        prev.next=head\\n        prev=None\\n        \\n      \\n        \\n        for i in range(length-k):\\n            prev=head\\n            head=head.next\\n        \\n        prev.next=None\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156321,
                "title": "c-solution-with-explanation",
                "content": "\\n To rotate element right by k places we first attach head to last node of head.\\n then we will make the head as node at n-k+1 position and assign null to the node at n-k position.\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       //If head is null return empty.\\n        if(!head) return NULL;\\n        \\n        ListNode* temp = head,*ans = head;\\n        //Find the size, here we do size is 1 as we will go from first node to second last node. The loop will not run for last node\\n        int size=1;\\n        while(head->next){ \\n            head=head->next;\\n            size++;\\n        }\\n        \\n        // Now we assign first element to the last node\\n        head->next=temp;\\n        //We use this since if k is greater than size rotation will be same as remainder of k%size\\n        k=k%size;\\n        //We do size-k-1 since we need to stop at a mode earlier to node at position n-k+1. Since we have to make it null.\\n        k=size-k-1;\\n        while(k>0){\\n            ans=ans->next;\\n            k--;\\n        }\\n        //\\n        temp = ans;\\n        ans=ans->next;\\n        temp->next=NULL;\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n       //If head is null return empty.\\n        if(!head) return NULL;\\n        \\n        ListNode* temp = head,*ans = head;\\n        //Find the size, here we do size is 1 as we will go from first node to second last node. The loop will not run for last node\\n        int size=1;\\n        while(head->next){ \\n            head=head->next;\\n            size++;\\n        }\\n        \\n        // Now we assign first element to the last node\\n        head->next=temp;\\n        //We use this since if k is greater than size rotation will be same as remainder of k%size\\n        k=k%size;\\n        //We do size-k-1 since we need to stop at a mode earlier to node at position n-k+1. Since we have to make it null.\\n        k=size-k-1;\\n        while(k>0){\\n            ans=ans->next;\\n            k--;\\n        }\\n        //\\n        temp = ans;\\n        ans=ans->next;\\n        temp->next=NULL;\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100806,
                "title": "c-easy-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head) return NULL;\\n        ListNode* ans = head;\\n        int size=1;\\n        while(head->next){ \\n            head=head->next;\\n            size++;\\n        }\\n        head->next=ans;\\n        k=k%size;\\n        k=size-k;\\n        while(--k>0){\\n            ans=ans->next;\\n        }\\n        head = ans;\\n        ans=ans->next;\\n        head->next=NULL;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(!head) return NULL;\\n        ListNode* ans = head;\\n        int size=1;\\n        while(head->next){ \\n            head=head->next;\\n            size++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 919353,
                "title": "faster-than-99-56-of-python3-memory-usage-less-than-100-00-of-python3",
                "content": "The thing you should notice here is to rotate a list k time, you only need to cut the last (k % list_length) element of that list and bring it to the front.\\nBellow is the solution by using two pointer approach.\\n\\n```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        c, h = 0, head\\n        while h is not None:\\n            c += 1\\n            h = h.next\\n        if c == 0 or k % c == 0:\\n            return head\\n        k = k % c\\n        s, f = head, head\\n        for _ in range(k):\\n            f = f.next\\n        while f.next is not None:\\n            f = f.next\\n            s = s.next\\n        nh = s.next\\n        s.next = None\\n        f.next = head\\n        return nh\\n\\t\\t\\n",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "The thing you should notice here is to rotate a list k time, you only need to cut the last (k % list_length) element of that list and bring it to the front.\\nBellow is the solution by using two pointer approach.\\n\\n```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        c, h = 0, head\\n        while h is not None:\\n            c += 1\\n            h = h.next\\n        if c == 0 or k % c == 0:\\n            return head\\n        k = k % c\\n        s, f = head, head\\n        for _ in range(k):\\n            f = f.next\\n        while f.next is not None:\\n            f = f.next\\n            s = s.next\\n        nh = s.next\\n        s.next = None\\n        f.next = head\\n        return nh\\n\\t\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 885653,
                "title": "modular-rust-solution-60-lines-of-code",
                "content": "Since the linked list is built with `Box<T>` instead of `Rc<RefCell<T>>`, the compiler will not allow an ownership cycle. So we have to break the list in two before adding the extra link. We transfer ownership between temporary variables with `take()` (`Option<T>::take(&mut self) -> Option<T>`).\\n\\n```\\n/*\\n// Definition for singly-linked list.\\n#[derive(PartialEq, Eq, Clone, Debug)]\\npub struct ListNode {\\n    pub val: i32,\\n    pub next: Option<Box<ListNode>>,\\n}\\n\\nimpl ListNode {\\n    #[inline]\\n    pub fn new(val: i32) -> Self {\\n        ListNode { next: None, val }\\n    }\\n}\\n\\npub struct Solution;\\n*/\\n\\ntype Node = ListNode;\\n\\ntype Link = Option<Box<Node>>;\\n\\nimpl Solution {\\n    pub fn rotate_right(head: Link, k: i32) -> Link {\\n        let mut list = List { head };\\n        list.rotate(k as isize);\\n        list.head\\n    }\\n}\\n\\nstruct List {\\n    head: Link,\\n}\\n\\nimpl List {\\n    fn rotate(&mut self, k: isize) {\\n        let n = self.len();\\n        if n == 0 {\\n            return;\\n        }\\n        let k = k.rem_euclid(n as isize) as usize;\\n        if k == 0 {\\n            return;\\n        }\\n\\n        debug_assert!(0 < k && k < n);\\n\\n        let mut old_head = self.head.take().unwrap();\\n\\n        let new_tail = old_head.get_node(n - k - 1).unwrap();\\n        let mut new_head = new_tail.next.take().unwrap();\\n        let tail = new_head.get_node(k - 1).unwrap();\\n        tail.next = Some(old_head);\\n\\n        self.head = Some(new_head);\\n    }\\n\\n    fn len(&self) -> usize {\\n        let mut count = 0;\\n        let mut link = &self.head;\\n        while let Some(node) = link {\\n            count += 1;\\n            link = &node.next;\\n        }\\n        count\\n    }\\n}\\n\\nimpl Node {\\n    /// Walk `i` steps forward in the linked list.\\n    fn get_node(&mut self, i: usize) -> Option<&mut Node> {\\n        let mut node = self;\\n        for _ in 0..i {\\n            node = node.next.as_mut()?;\\n        }\\n        Some(node)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Linked List"
                ],
                "code": "```\\n/*\\n// Definition for singly-linked list.\\n#[derive(PartialEq, Eq, Clone, Debug)]\\npub struct ListNode {\\n    pub val: i32,\\n    pub next: Option<Box<ListNode>>,\\n}\\n\\nimpl ListNode {\\n    #[inline]\\n    pub fn new(val: i32) -> Self {\\n        ListNode { next: None, val }\\n    }\\n}\\n\\npub struct Solution;\\n*/\\n\\ntype Node = ListNode;\\n\\ntype Link = Option<Box<Node>>;\\n\\nimpl Solution {\\n    pub fn rotate_right(head: Link, k: i32) -> Link {\\n        let mut list = List { head };\\n        list.rotate(k as isize);\\n        list.head\\n    }\\n}\\n\\nstruct List {\\n    head: Link,\\n}\\n\\nimpl List {\\n    fn rotate(&mut self, k: isize) {\\n        let n = self.len();\\n        if n == 0 {\\n            return;\\n        }\\n        let k = k.rem_euclid(n as isize) as usize;\\n        if k == 0 {\\n            return;\\n        }\\n\\n        debug_assert!(0 < k && k < n);\\n\\n        let mut old_head = self.head.take().unwrap();\\n\\n        let new_tail = old_head.get_node(n - k - 1).unwrap();\\n        let mut new_head = new_tail.next.take().unwrap();\\n        let tail = new_head.get_node(k - 1).unwrap();\\n        tail.next = Some(old_head);\\n\\n        self.head = Some(new_head);\\n    }\\n\\n    fn len(&self) -> usize {\\n        let mut count = 0;\\n        let mut link = &self.head;\\n        while let Some(node) = link {\\n            count += 1;\\n            link = &node.next;\\n        }\\n        count\\n    }\\n}\\n\\nimpl Node {\\n    /// Walk `i` steps forward in the linked list.\\n    fn get_node(&mut self, i: usize) -> Option<&mut Node> {\\n        let mut node = self;\\n        for _ in 0..i {\\n            node = node.next.as_mut()?;\\n        }\\n        Some(node)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 883145,
                "title": "rotate-list-python-99-6",
                "content": "```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        if not head:\\n            return head\\n        dic={1:head}\\n        length=1\\n        node=head\\n        while node.next:\\n            length+=1\\n            node=node.next\\n            dic[length]=node\\n\\n        rotate=k%length\\n        if not rotate:\\n            return head\\n        dic[length-rotate].next=None\\n        dic[length].next=head\\n        return dic[length-rotate+1]\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        if not head:\\n            return head\\n        dic={1:head}\\n        length=1\\n        node=head\\n        while node.next:\\n            length+=1\\n            node=node.next\\n            dic[length]=node\\n\\n        rotate=k%length\\n        if not rotate:\\n            return head\\n        dic[length-rotate].next=None\\n        dic[length].next=head\\n        return dic[length-rotate+1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 883079,
                "title": "c-o-n-solution-with-explanations",
                "content": "**The main idea is to iterate the list till we get to the node that will be the head after rotating, and to then take that part from new head till tail and reconnect it to previous head**\\n\\nif helpful please upvote\\n```\\n\\nstruct ListNode* rotateRight(struct ListNode* head, int k)\\n{\\n        struct ListNode* iter = head, *prev, *iter2;\\n    \\n        // if list needs no rotation or head is null (checking these conditions makes the solution more efficient)\\n        if (k == 0 || !head)\\n\\t\\t\\treturn head;\\n    \\n        // counting number of nodes in list\\n        size_t num_nodes = 0;\\n        while (iter)\\n        {\\n            iter = iter->next;\\n            num_nodes++;\\n        }\\n    \\n        // if there is one node in list or after rotation the list will be same as given list then there is no need to rotate list \\n\\t    // (checking these conditions makes the solution more efficient)\\n        if (num_nodes == 1 || k % num_nodes == 0)\\n\\t\\t\\treturn head;\\n    \\n        // rotating:\\n\\t\\t\\n        iter = head;\\n        k %= num_nodes;\\n\\t\\t// find node that will be head\\n        while (num_nodes - k)\\n        {\\n            prev = iter;\\n            iter = iter->next;\\n            num_nodes--;\\n        }\\n        prev->next = NULL;\\n\\t\\t// attach the previous tail to the previous head\\n        iter2 = iter;\\n\\t\\t\\n        while (iter2->next)\\n\\t\\t\\titer2 = iter2->next;\\n\\t\\t\\n        iter2->next = head;\\n        head = iter;\\n    \\n        return head;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nstruct ListNode* rotateRight(struct ListNode* head, int k)\\n{\\n        struct ListNode* iter = head, *prev, *iter2;\\n    \\n        // if list needs no rotation or head is null (checking these conditions makes the solution more efficient)\\n        if (k == 0 || !head)\\n\\t\\t\\treturn head;\\n    \\n        // counting number of nodes in list\\n        size_t num_nodes = 0;\\n        while (iter)\\n        {\\n            iter = iter->next;\\n            num_nodes++;\\n        }\\n    \\n        // if there is one node in list or after rotation the list will be same as given list then there is no need to rotate list \\n\\t    // (checking these conditions makes the solution more efficient)\\n        if (num_nodes == 1 || k % num_nodes == 0)\\n\\t\\t\\treturn head;\\n    \\n        // rotating:\\n\\t\\t\\n        iter = head;\\n        k %= num_nodes;\\n\\t\\t// find node that will be head\\n        while (num_nodes - k)\\n        {\\n            prev = iter;\\n            iter = iter->next;\\n            num_nodes--;\\n        }\\n        prev->next = NULL;\\n\\t\\t// attach the previous tail to the previous head\\n        iter2 = iter;\\n\\t\\t\\n        while (iter2->next)\\n\\t\\t\\titer2 = iter2->next;\\n\\t\\t\\n        iter2->next = head;\\n        head = iter;\\n    \\n        return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 829575,
                "title": "python-o-n",
                "content": "O(kn) if we do it naively, rotating the list k times. We notice that the list rotation is modular in fashion. That is, given the length of the list n, there can be at most k % n rotations. As a result, we can reduce the problem down to O((k % n)n). k %n is some constant << k, so the solution is O(n).\\n\\n```\\ndef rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        prev = None\\n        cur = head\\n        \\n        if not head or not head.next:\\n            return head\\n        \\n        # first get length of list\\n        length = 0\\n        while cur:\\n            length += 1\\n            cur = cur.next\\n        cur = head\\n        \\n        for i in range(k % length):\\n            while cur.next:\\n                prev = cur\\n                cur = cur.next\\n            cur.next = head\\n            head = cur\\n            prev.next = None\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\ndef rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        prev = None\\n        cur = head\\n        \\n        if not head or not head.next:\\n            return head\\n        \\n        # first get length of list\\n        length = 0\\n        while cur:\\n            length += 1\\n            cur = cur.next\\n        cur = head\\n        \\n        for i in range(k % length):\\n            while cur.next:\\n                prev = cur\\n                cur = cur.next\\n            cur.next = head\\n            head = cur\\n            prev.next = None\\n        return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 721448,
                "title": "python-fast-solution",
                "content": "Python fast solution\\n```\\n    length = 1\\n    node = head\\n    while node.next:\\n        node = node.next\\n        length += 1\\n    tail = node\\n\\n    offset = abs(k) % length\\n\\tif offset == 0:\\n        return head\\n\\n    new_tail_position = length - offset if k > 0 else offset\\n\\t\\t\\n    counter = 1\\n    node = head\\n    while node.next:\\n        if counter ==new_tail_position:\\n            final_tail = node\\n            break\\n        node = node.next\\n        counter += 1\\n\\n    tail.next = head\\n    head = final_tail.next\\n    final_tail.next = None\\n\\n    return head\\n```",
                "solutionTags": [],
                "code": "```\\n    length = 1\\n    node = head\\n    while node.next:\\n        node = node.next\\n        length += 1\\n    tail = node\\n\\n    offset = abs(k) % length\\n\\tif offset == 0:\\n        return head\\n\\n    new_tail_position = length - offset if k > 0 else offset\\n\\t\\t\\n    counter = 1\\n    node = head\\n    while node.next:\\n        if counter ==new_tail_position:\\n            final_tail = node\\n            break\\n        node = node.next\\n        counter += 1\\n\\n    tail.next = head\\n    head = final_tail.next\\n    final_tail.next = None\\n\\n    return head\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 687535,
                "title": "swift-rotate-list-with-comments",
                "content": "```\\nclass Solution {\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        if head == nil {\\n            return head\\n        }\\n        // To get length of list\\n        var length = 1\\n        // To find tail of list\\n        var tail : ListNode? = head \\n        \\n        while tail?.next !=  nil {\\n            length += 1\\n            tail = tail?.next\\n        }\\n        // if K == length in that case we have to rotate entire list to return same original list\\n        var k =  k % length\\n        if k == 0 {\\n            return head\\n        }\\n        \\n        // Steps to find new head will be length - k \\n        var stepsToNewHead = length - k\\n        \\n        // Connet Tail to head to form cycle list\\n        tail?.next = head\\n        \\n        // Find New tail after rotating stepsToNewHead th time\\n        var newTail = tail\\n        \\n        while stepsToNewHead > 0 {\\n            stepsToNewHead -= 1\\n            newTail = newTail?.next\\n        }\\n        // New head\\n        let newHead = newTail?.next\\n        // Break cycle\\n        newTail?.next = nil\\n        \\n        return newHead\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        if head == nil {\\n            return head\\n        }\\n        // To get length of list\\n        var length = 1\\n        // To find tail of list\\n        var tail : ListNode? = head \\n        \\n        while tail?.next !=  nil {\\n            length += 1\\n            tail = tail?.next\\n        }\\n        // if K == length in that case we have to rotate entire list to return same original list\\n        var k =  k % length\\n        if k == 0 {\\n            return head\\n        }\\n        \\n        // Steps to find new head will be length - k \\n        var stepsToNewHead = length - k\\n        \\n        // Connet Tail to head to form cycle list\\n        tail?.next = head\\n        \\n        // Find New tail after rotating stepsToNewHead th time\\n        var newTail = tail\\n        \\n        while stepsToNewHead > 0 {\\n            stepsToNewHead -= 1\\n            newTail = newTail?.next\\n        }\\n        // New head\\n        let newHead = newTail?.next\\n        // Break cycle\\n        newTail?.next = nil\\n        \\n        return newHead\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685024,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def rotateRight(self, head: \\'ListNode\\', k: \\'int\\') -> \\'ListNode\\':\\n        \\n        ## RC ##\\n        ## APPROACH  : LINKED LIST ##\\n        ## 1. Find first length of the linkedlist.\\n        ## 2. when you found that next node is null while doing 1, make it a circular linked list, connecting it to head\\n        ## 3. Now move n - k positions forward and break the circle.\\n        ## 4. step 3 can be reduced to (n-k) % (n - 1)\\n        \\n        if not head or not head.next:\\n            return head\\n        \\n        old_tail = head\\n        n = 1\\n        while old_tail.next:\\n            old_tail = old_tail.next\\n            n += 1\\n        old_tail.next = head\\n        \\n        new_tail = head\\n        for i in range(n - k % n - 1):\\n            new_tail = new_tail.next\\n        new_head = new_tail.next\\n        \\n        new_tail.next = None\\n        return new_head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotateRight(self, head: \\'ListNode\\', k: \\'int\\') -> \\'ListNode\\':\\n        \\n        ## RC ##\\n        ## APPROACH  : LINKED LIST ##\\n        ## 1. Find first length of the linkedlist.\\n        ## 2. when you found that next node is null while doing 1, make it a circular linked list, connecting it to head\\n        ## 3. Now move n - k positions forward and break the circle.\\n        ## 4. step 3 can be reduced to (n-k) % (n - 1)\\n        \\n        if not head or not head.next:\\n            return head\\n        \\n        old_tail = head\\n        n = 1\\n        while old_tail.next:\\n            old_tail = old_tail.next\\n            n += 1\\n        old_tail.next = head\\n        \\n        new_tail = head\\n        for i in range(n - k % n - 1):\\n            new_tail = new_tail.next\\n        new_head = new_tail.next\\n        \\n        new_tail.next = None\\n        return new_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509348,
                "title": "python3-o-n-time",
                "content": "```\\nclass Solution:\\n    \\n    def get_length(self,head):\\n        count = 0\\n        while head:\\n            count+=1\\n            head = head.next\\n        return count\\n    \\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        length = self.get_length(head)\\n        if length==0:\\n            return head\\n        k = k%length\\n        if k==0:\\n            return head\\n        temp = head\\n        i = 0\\n        while i<length-k-1:\\n            temp = temp.next\\n            i+=1\\n        next = temp.next\\n        temp.next = None\\n        temp = next\\n        while temp.next:\\n            temp = temp.next\\n        temp.next = head\\n        return next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def get_length(self,head):\\n        count = 0\\n        while head:\\n            count+=1\\n            head = head.next\\n        return count\\n    \\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        length = self.get_length(head)\\n        if length==0:\\n            return head\\n        k = k%length\\n        if k==0:\\n            return head\\n        temp = head\\n        i = 0\\n        while i<length-k-1:\\n            temp = temp.next\\n            i+=1\\n        next = temp.next\\n        temp.next = None\\n        temp = next\\n        while temp.next:\\n            temp = temp.next\\n        temp.next = head\\n        return next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330145,
                "title": "easy-and-clean-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        //first,calculate the length of list        \\n        int len = 1;\\n        ListNode *p = head;\\n        while(p->next!=NULL)\\n        {\\n            len++;\\n            p = p->next;\\n        }\\n        \\n        //second,connect tail to head\\n        p->next = head;\\n        \\n        int forward_step = len - k%len;\\n        \\n        //third,forward in the circle. backward k step is equal to forward len-k step.And we can only forward.\\n        for(int i=0; i<forward_step;i++)\\n            p = p->next;  //finally, p is the pointer pointing to hte previous node of the head we want\\n        \\n        head = p->next;\\n        p->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        //first,calculate the length of list        \\n        int len = 1;\\n        ListNode *p = head;\\n        while(p->next!=NULL)\\n        {\\n            len++;\\n            p = p->next;\\n        }\\n        \\n        //second,connect tail to head\\n        p->next = head;\\n        \\n        int forward_step = len - k%len;\\n        \\n        //third,forward in the circle. backward k step is equal to forward len-k step.And we can only forward.\\n        for(int i=0; i<forward_step;i++)\\n            p = p->next;  //finally, p is the pointer pointing to hte previous node of the head we want\\n        \\n        head = p->next;\\n        p->next = NULL;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312039,
                "title": "swift-99-beat-o-n-linear-speed-must-traverse-whole-list",
                "content": "```\\nclass Solution {\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        \\n        if head == nil { return nil }\\n        \\n        var tail: ListNode?\\n        var node = head\\n        var count = 0\\n        while node != nil {\\n            tail = node\\n            node = node!.next\\n            count += 1\\n        }\\n        \\n        var k = k % count\\n        if k == 0 { return head }\\n        \\n        var slice = count - k\\n        \\n        var prev: ListNode?\\n        node = head\\n        while slice > 0 {\\n            prev = node\\n            node = node!.next\\n            slice -= 1\\n        }\\n        \\n        prev!.next = nil\\n        tail!.next = head \\n        return node\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        \\n        if head == nil { return nil }\\n        \\n        var tail: ListNode?\\n        var node = head\\n        var count = 0\\n        while node != nil {\\n            tail = node\\n            node = node!.next\\n            count += 1\\n        }\\n        \\n        var k = k % count\\n        if k == 0 { return head }\\n        \\n        var slice = count - k\\n        \\n        var prev: ListNode?\\n        node = head\\n        while slice > 0 {\\n            prev = node\\n            node = node!.next\\n            slice -= 1\\n        }\\n        \\n        prev!.next = nil\\n        tail!.next = head \\n        return node\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309400,
                "title": "easiest-java-beats-100",
                "content": "```java\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || head.next == null) return head;\\n        int count = 1;\\n        ListNode runner = head;\\n        for(; runner.next != null; runner = runner.next, count++);\\n        runner.next = head;\\n        k = count - (k % count);\\n        for(int i=1; i<=k; i++, runner = runner.next);\\n        head = runner.next;\\n        runner.next = null;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || head.next == null) return head;\\n        int count = 1;\\n        ListNode runner = head;\\n        for(; runner.next != null; runner = runner.next, count++);\\n        runner.next = head;\\n        k = count - (k % count);\\n        for(int i=1; i<=k; i++, runner = runner.next);\\n        head = runner.next;\\n        runner.next = null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22714,
                "title": "rotate-list-solution-in-c-in-o-n-linear-time-and-o-1-constant-space-complexity",
                "content": "'''\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        \\n        if (!head || !head->next || k == 0)\\n            return head;\\n        ListNode* temp = head;\\n        ListNode* curr = head;\\n        ListNode* headN = head;\\n        int n = 0;\\n        \\n        while (temp) {\\n            temp = temp->next;\\n            n++;\\n        }\\n        \\n        int shift = (n - k % n) - 1;\\n        \\n        while (shift) {\\n            curr = curr->next;\\n            shift--;\\n        }\\n        \\n        ListNode* KthNode = curr;\\n\\n        while (curr->next)\\n            curr = curr->next;\\n        \\n        curr->next = head;\\n        headN = KthNode->next;\\n        KthNode->next = NULL;\\n        \\n        return headN;\\n    }\\n};\\n'''",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        \\n        if (!head || !head->next || k == 0)\\n            return head;\\n        ListNode* temp = head;\\n        ListNode* curr = head;\\n        ListNode* headN = head;\\n        int n = 0;\\n        \\n        while (temp) {\\n            temp = temp->next;\\n            n++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 22796,
                "title": "python-solution-only-go-through-ll-once",
                "content": "This one requires extra memory space to store refs to all nodes, but no need to iterate through it again.\\n\\n\\n```\\nclass Solution(object):\\n    def rotateRight(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if head is None:\\n            return None\\n        if head.next is None:\\n            return head\\n        nodes = []\\n        p = ListNode(None)\\n        p.next = head\\n        q = p\\n        while q.next is not None:\\n            q = q.next\\n            nodes.append(q)\\n        k %= len(nodes)\\n        if k == 0:\\n            return head\\n        newHead = nodes[-k]\\n        nodes[-k - 1].next = None\\n        nodes[-1].next = head\\n        return newHead\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rotateRight(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if head is None:\\n            return None\\n        if head.next is None:\\n            return head\\n        nodes = []\\n        p = ListNode(None)\\n        p.next = head\\n        q = p\\n        while q.next is not None:\\n            q = q.next\\n            nodes.append(q)\\n        k %= len(nodes)\\n        if k == 0:\\n            return head\\n        newHead = nodes[-k]\\n        nodes[-k - 1].next = None\\n        nodes[-1].next = head\\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22818,
                "title": "c-12-ms-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode* rotateRight(ListNode* head, int k) {\\n            if(head == NULL || head->next == NULL) return head;\\n            ListNode *tail;\\n            int n=1,j;\\n            for(tail = head;tail->next!=NULL;tail=tail->next) n++;\\n            j = (n-k%n)%n;\\n            tail->next = head;\\n            for(int i=0;i<j;i++){\\n                head = head->next;\\n                tail = tail->next;\\n            }\\n            tail->next = NULL;\\n            return head;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* rotateRight(ListNode* head, int k) {\\n            if(head == NULL || head->next == NULL) return head;\\n            ListNode *tail;\\n            int n=1,j;\\n            for(tail = head;tail->next!=NULL;tail=tail->next) n++;\\n            j = (n-k%n)%n;\\n            tail->next = head;\\n            for(int i=0;i<j;i++){\\n                head = head->next;\\n                tail = tail->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 22885,
                "title": "simple-java-solution",
                "content": "\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null) return head;\\n        k = k % getLen(head);\\n        ListNode p1 = new ListNode(0);\\n        ListNode p2 = new ListNode(0);\\n        p1.next = head;\\n        p2.next = head;\\n        for (int i = 0; i < k; i++) {\\n            p2 = p2.next;\\n        }\\n        while (p2.next != null) {\\n            p1 = p1.next;\\n            p2 = p2.next;\\n        }\\n        p2.next = head;\\n        ListNode res = p1.next;\\n        p1.next = null;\\n        return res;\\n    }\\n    \\n    private int getLen(ListNode node) {\\n        int count = 0;\\n        while (node != null) {\\n            count++;\\n            node = node.next;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if (head == null) return head;\\n        k = k % getLen(head);\\n        ListNode p1 = new ListNode(0);\\n        ListNode p2 = new ListNode(0);\\n        p1.next = head;\\n        p2.next = head;\\n        for (int i = 0; i < k; i++) {\\n            p2 = p2.next;\\n        }\\n        while (p2.next != null) {\\n            p1 = p1.next;\\n            p2 = p2.next;\\n        }\\n        p2.next = head;\\n        ListNode res = p1.next;\\n        p1.next = null;\\n        return res;\\n    }\\n    \\n    private int getLen(ListNode node) {\\n        int count = 0;\\n        while (node != null) {\\n            count++;\\n            node = node.next;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 22910,
                "title": "simple-java-solution-with-explanation",
                "content": " My idea is, first concat the tail to the head, building a cycle, then decide where to break the cycle to get the resulting list. The advantage of the method is, you dont need to worry about n being larger than the length of the list.\\n\\n       public ListNode rotateRight(ListNode head, int n) {\\n            if (head == null) return null;\\n            ListNode tail = head;                       //first, build a cycle\\n            while (tail.next != null){\\n                tail = tail.next;\\n            }\\n            tail.next = head;                          //cycle built.\\n            ListNode fast = head, slow = head;         //now find where to break the cycle\\n            while (n-->0){\\n                fast = fast.next;                      //move the fast runner first\\n            }\\n            while (fast!=tail){\\n                fast = fast.next;                      //then move the fast and the slow runners together\\n                slow = slow.next;\\n            }\\n            head = slow.next;                          //break the cycle at after the slow runner\\n            slow.next = null;\\n            return head;                              // return the new head\\n        }",
                "solutionTags": [],
                "code": " My idea is, first concat the tail to the head, building a cycle, then decide where to break the cycle to get the resulting list. The advantage of the method is, you dont need to worry about n being larger than the length of the list.\\n\\n       public ListNode rotateRight(ListNode head, int n) {\\n            if (head == null) return null;\\n            ListNode tail = head;                       //first, build a cycle\\n            while (tail.next != null){\\n                tail = tail.next;\\n            }\\n            tail.next = head;                          //cycle built.\\n            ListNode fast = head, slow = head;         //now find where to break the cycle\\n            while (n-->0){\\n                fast = fast.next;                      //move the fast runner first\\n            }\\n            while (fast!=tail){\\n                fast = fast.next;                      //then move the fast and the slow runners together\\n                slow = slow.next;\\n            }\\n            head = slow.next;                          //break the cycle at after the slow runner\\n            slow.next = null;\\n            return head;                              // return the new head\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 4050522,
                "title": "rotate-list-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getlength(ListNode* head1)\\n    {\\n        int count=1;\\n        while(head1->next!=NULL)\\n        {\\n            count++;\\n            head1=head1->next;\\n        }\\n        return count;\\n    }\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL)return head;\\n        int l=getlength(head);\\n        k=k%l;\\n    for(int i=1;i<=k;i++)\\n    { \\n        ListNode* tail=head;\\n        ListNode* tailprev=NULL;\\n        while(tail->next!=NULL)\\n        {\\n            tailprev=tail;\\n            tail=tail->next;\\n\\n        }\\n        tail->next=head;\\n        tailprev->next=NULL;\\n        head=tail;\\n    }\\n    return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getlength(ListNode* head1)\\n    {\\n        int count=1;\\n        while(head1->next!=NULL)\\n        {\\n            count++;\\n            head1=head1->next;\\n        }\\n        return count;\\n    }\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL)return head;\\n        int l=getlength(head);\\n        k=k%l;\\n    for(int i=1;i<=k;i++)\\n    { \\n        ListNode* tail=head;\\n        ListNode* tailprev=NULL;\\n        while(tail->next!=NULL)\\n        {\\n            tailprev=tail;\\n            tail=tail->next;\\n\\n        }\\n        tail->next=head;\\n        tailprev->next=NULL;\\n        head=tail;\\n    }\\n    return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041577,
                "title": "best-python-solution-o-n-time-beats-90-two-pointers",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe create two pointers f and s initially we send f to k moves forward. If k exceeds the length of list then we take k % length to get the exact number of moves f should move. And finally we start moving both s and f until f reaches the end then just cut the list from s to f and attach it in the front :) \\n\\nComment down for more clarification and please Upvote if like the solution\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head or not head.next or k==0:\\n            return head\\n        f = s = head\\n        count  = 0\\n        for i in range(k):\\n            count +=1\\n            if not f.next:\\n                f = s\\n                break\\n            f = f.next \\n        for i in range(k%count):\\n            f = f.next\\n        if f == s:\\n            return f\\n        while f.next:\\n            f = f.next\\n            s = s.next\\n        temp = s.next\\n        s.next = None\\n        f.next = head\\n        return temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head or not head.next or k==0:\\n            return head\\n        f = s = head\\n        count  = 0\\n        for i in range(k):\\n            count +=1\\n            if not f.next:\\n                f = s\\n                break\\n            f = f.next \\n        for i in range(k%count):\\n            f = f.next\\n        if f == s:\\n            return f\\n        while f.next:\\n            f = f.next\\n            s = s.next\\n        temp = s.next\\n        s.next = None\\n        f.next = head\\n        return temp\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565004,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1582109,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1565003,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1940800,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1966760,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1565927,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1573278,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1572794,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1567829,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1568880,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1565004,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1582109,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1565003,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1940800,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1966760,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1565927,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1573278,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1572794,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1567829,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1568880,
                "content": [
                    {
                        "username": "uncle_cat",
                        "content": "Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Just a tip but whenever you see rotation type position swapping , remember there will be a pattern and it can be used to optimize your code. In this case you dont have to count k rotations every time , you just have to calculate k%n rotations ,where is n is number of nodes."
                    },
                    {
                        "username": "rforritz",
                        "content": "i am not getting that what i should do when K is greater than size of the list."
                    },
                    {
                        "username": "LordHoboDojo",
                        "content": "What happens when you rotate by n? Nothing right. "
                    },
                    {
                        "username": "bharg4vi",
                        "content": "Use modulus"
                    },
                    {
                        "username": "AshishYadav952",
                        "content": "take modulus by size of list.\\n"
                    },
                    {
                        "username": "user0788OT",
                        "content": "use modulas"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "It does not matter if k is greater than the length of LinkedList just try taking k modulo of length of linked list"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Hint: Convert the LL to Circular Linked List and then just shift head (n-k) times and then fetch end node and make its next == NULL "
                    },
                    {
                        "username": "kundan_",
                        "content": "Nice"
                    },
                    {
                        "username": "eedi",
                        "content": "bc 2 lakh baar kaun rotate krta ha!! \\nchutiya log"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "lol "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "naeemk",
                        "content": "I am new to LeetCode, and I see many thumbs down in this question (and some other questions). However, I could not find any post on the discussion section regarding why people do not like this question (or some others). I understand, sometimes,  input format or test cases are problomatic. However, I would like to sincerely ask from experienced software engineers to share their thoughts about these type questions. Thanks."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "The number of thumbs down is not really important: the ultimate goal is that ***you*** can solve the problem, not what people generally think about it."
                    },
                    {
                        "username": "ROFEL",
                        "content": "I was looking at the ratings and saw that this problem had more downvotes than upvotes.  Why is everyone downvoting this problem?  What\\'s wrong with it?"
                    },
                    {
                        "username": "satanwoo",
                        "content": "Is K places here means the time of rotation. For example,  k = 2 and the result is 4->5->1->2->3->NULL, how doest it rotate to achieve such result?"
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "the last node will point towards the first and the second last will point towards null and the process is repeated k times"
                    },
                    {
                        "username": "yuhc",
                        "content": "I'm wondering why we need execute k %= (length of list). Should we return the ordinary list when k >= length? This is not a circular list.\\n\\nDo anyone know what does the \"rotate\" mean? Thank you very much!"
                    },
                    {
                        "username": "aakarshanraj",
                        "content": "[@billyokra](/billyokra) great explanation but, you made a mistake in rotation, in all the examples the output would be [2,3,1]"
                    },
                    {
                        "username": "billyokra",
                        "content": "Why not do an experiment on that?!\\n\\nExample 1:\\nInput: head = [1,2,3], k = 2\\nOutput: [3,2,1]\\n\\nExample 2:\\nInput: head = [1,2,3], k = 5\\nOutput: [3,2,1]\\n\\nOne more example!\\n\\nExample 3:\\nInput: head = [1,2,3], k = 8\\nOutput: [3,2,1]\\n\\nDid you notice that, all the outputs are the same even when the k are different? \\n\\nAnother observation is that, when k == length, yes, you can return the  original list. But, when k > length, no, you cannot return the original list. Take a look at the Example 2 and 3.\\n\\nSo, when k >= length, we need to do the (k % length). This way, the k in Example 2 & Example 3 will becomes 5%3 or 8%3, they both becomes 2.\\n\\nHope this answer reaches you and other in need well."
                    }
                ]
            },
            {
                "id": 1989135,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 1918540,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 1677536,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 1571145,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 2071608,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 2045061,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 2015354,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 1974403,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 1933543,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 1925587,
                "content": [
                    {
                        "username": "Akash_Verma2000",
                        "content": "FOLLOW THESE STEPS TO SOLVE THIS PROBLEM\\n //connect the tail to the head\\n        //figure out the optimum value of k BY K=K%length of list\\n        //pointer=length-k\\n        //travel till pointer\\n        //secure the ListNode at the next of the pointer in another ListNode \\n        //point the same to null"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "OPTIMAL SOLUTION :C++\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL || head->next == NULL ||k==0)\\n     {\\n          return head ;\\n     }\\n\\n     //Compute the length of the linked list \\n     ListNode* cur = head ;\\n     int len = 1;\\n     while(cur->next!=NULL)\\n     {\\n          ++len ;\\n          cur = cur->next ;\\n     }\\n\\n     //Pointing the last node to the head;\\n     cur->next = head ;\\n     k = k % len ;//Like if we have 12 rotation and k = 5 then till 10 rotation its same as the original linked list , so we do this .\\n     k = len - k ; // So that we can able to know how much we have to traverse from the head .\\n     while(k--)\\n     {\\n          cur = cur->next ;\\n     }\\n\\n     //Make the node to the head and break the connection\\n     head = cur->next ;\\n     cur->next = NULL ;\\n\\n\\n     return head;\\n\\n    }\\n}; \\nTC : O(N). , SC: O(1).   "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Optimal rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jyotiraditya",
                        "content": "Hint : Take an example of rotating a cirucular linked list. "
                    },
                    {
                        "username": "nafSadh",
                        "content": "In most (if not all) questions, OJ defined struct/class use NULL instead of nullptr. Why is that?"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "Probably author preference, but I would guess some authors use nullptr instead of NULL because nullptr was inroduced in C++ to remove the ambiguity of the C NULL which is 0."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach for Beginners:-)**\\n- Calculate the length of the linked list while keeping track of the tail node.\\n- Adjust k by taking its modulo with the list length to find the effective rotation amount.\\n- If k becomes zero, return the original head; no rotation is needed.\\n- Find the new head and new tail nodes after rotation:\\n  - The new tail is k nodes from the end of the list.\\n  - The new head is the node after the new tail.\\n- Break the list at the new tail and reconnect it to the original head, completing the rotation.\\n- Return the new head as the result of the rotation."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/rotate-list/solutions/4087567/easiest-solution-beginner-friendly-straight-forward/?envType=study-plan-v2&envId=top-interview-150"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Rotating Linked List is very similar to rotating array. I am sure that you might be worked on sorted rotated array while learning on Binary search. The approach will same. let\\'s code it.\\n# Approach\\n1 : Find Last node and connect with head.\\n2 : How many times need to skip or rotate, skip = length - k.\\n3 : Find the rotation that how many times it rotated (k). mean skip = length - rotation.\\n4 : Once you found the last node connect with head and put null in last node.\\n5 : return head."
                    },
                    {
                        "username": "user8272RT",
                        "content": "I struggled to write clean code for this problem. Need more practice! "
                    },
                    {
                        "username": "SiddhantP",
                        "content": "If Anyone is struggling,\\n\\n1. Get the List Length, and Do k % length to find out how much rotation is needed.\\n2. Traverse using 2 Pointers (Difference between them == k % length).\\n3. When fast pointer hits null, Just Append anything after slow pointer before head. (This part is bit tricky, take care that you don\\'t accidently create Infinite Linked list).\\n\\nHope this helps...\\n\\nRef : [My Submission - O(n)](https://leetcode.com/problems/rotate-list/solutions/3778788/c-2-pointers-faster-than-90-of-the-submissions/)"
                    },
                    {
                        "username": "Abhaydeep_Sharma",
                        "content": "Can any body tell whats wrong in this code\\n\\n ListNode* rotateRight(ListNode* head, int k) \\n    {\\n        if(k==0|| head == NULL|| head->next==NULL)return head;\\n\\n         ListNode*end = head;\\n        ListNode* temp;\\n        int len =0;\\n\\n        while(end->next)\\n        {\\n             end = end->next;\\n             len++;\\n        }\\n        len++;\\n\\n        cout<<len<<endl;\\n        \\n        k = k%len;\\n        \\n        int cnt=0;\\n        \\n        while(--k)\\n        {\\n            temp = head->next;\\n            end->next = head;\\n            \\n            head->next=NULL;\\n            \\n            end = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "What the fuck is wrong with test case 12??? k=2000000000??? WTF!!! Seriously LeetCode"
                    },
                    {
                        "username": "anshul_0077",
                        "content": "bro u dont have to run loop k times . k rotations and k%size rotation will give the same link list\\n"
                    }
                ]
            },
            {
                "id": 1922249,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1900433,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1898535,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1893809,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1820728,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1803655,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1783054,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1776911,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1761133,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1760988,
                "content": [
                    {
                        "username": "anshul_0077",
                        "content": "I DONT KNOW WHY ITS THROWING RUNTIME ERROR SOMEONE PLS HELP :(\\n\\n      class Solution {\\n     public:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n         \\n           if(head==NULL) return NULL;\\n          if(head->next==NULL) return head;\\n        vector<ListNode*> v;\\n        ListNode* temp=head;\\n\\n        while(temp){\\n            v.push_back(temp);\\n            temp=temp->next;\\n        }\\n        int n=v.size()-1;\\n        int indx=abs(n-k)+1;\\n        \\n        if(indx==0) return head;\\n        else{\\n            v[indx-1]->next=NULL;\\n            v[n]->next=head;\\n            head=v[indx];\\n            return head;\\n        }\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n\\n        if(head==null || head.next==null){\\n            return head;\\n        }\\n        while(k!=0){\\n            ListNode current = head;\\n            ListNode previous = null;\\n\\n            while (current.next != null) {\\n            previous = current;\\n            current = current.next;\\n        }\\n\\n            previous.next = null;\\n            current.next = head;\\n            head = current;\\n            k--;\\n        }\\n        return head;\\n    }\\n}\\nTry this one..."
                    },
                    {
                        "username": "utkarshcs",
                        "content": "Very Easy Solution In JAVA\n\nclass Solution {\n    public ListNode rr(ListNode head, int k){\n        if(k==0){\n            return head;\n        }\n        ListNode prev = null;\n        ListNode current = head;\n        while(current.next!=null){\n            prev = current;\n            current = current.next;\n        }\n\n\n        prev.next = null;\n        current.next = head;\n        head = current;\n        ListNode aa = rr(head,--k);\n\n        return aa;\n\n    }\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null || k==0){\n            return head;\n        }\n        int a=0;\n        ListNode temp = head;\n        while(temp!=null){\n            a++;\n            temp = temp.next;\n        }\n        k = k%a;\n        ListNode ans = rr(head,k);\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case no 12 ,k\\'s value is 200000000 \\n"
                    },
                    {
                        "username": "kingofjong",
                        "content": "In PHP I get the error Uncaught Error: Attempt to assign property \"next\" on null in solution.php. I am not trying to assign a null to value. I am assigning a variable which was set to null to another value. I assign variable to null and then reassign them bunch times in PHP at my job. Why is the error showing up?"
                    },
                    {
                        "username": "kamrantaslimdos",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n     if(head == null || head.next == null) return head;\\n\\n     ListNode pre = null,cur = head;\\n     int size = 0;\\n\\n     while(cur != null){\\n         pre = cur;\\n         cur = cur.next; \\n         size++;\\n\\n     }   \\n     cur = head;\\n     pre.next = cur;\\n     \\n     int rotate = k % size;\\n\\n     int location = size - rotate;\\n\\n     for(int i=0; i< location; i++){\\n         pre = cur;\\n         cur = cur.next;\\n     } \\n     pre.next = null;\\n     return cur;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "my code is say time limit  exceeded what should i do"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/rotate-list/solutions/3125965/js-linear-time-linear-space-doubly-linked-list/\\n\\nLinear time and space"
                    },
                    {
                        "username": "thisisankit_27",
                        "content": "Can the Approach we used in Reverse Array be used in Array List?\\n\\nreverse (nums.begin() , nums.end());\\nreverse (nums.begin() , nums.begin() + k);\\nreverse (nums.begin() + k , nums.end());"
                    },
                    {
                        "username": "apurvakhatri2011",
                        "content": "Why is my head not changing? At the end it returns the old head.\\n\\nclass Solution {\\npublic:\\n    \\n    ListNode* findLengthAndTail(ListNode* head, int* ptr){\\n        ListNode* tail;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            *ptr+=1;\\n            if(curr->next == NULL) tail = curr;\\n            curr = curr->next;\\n        }\\n        return tail;\\n    }\\n\\n    void rotate(ListNode* head, ListNode* tail, int* pos){\\n        cout<<\"Inside head address is: \"<<head<<endl;\\n        int k = 1;\\n        ListNode* curr = head;\\n        while(k!=*pos){\\n            curr = curr->next;\\n            k+=1;\\n        }\\n        //cout<<\"Curr is at: \"<<curr->val<<endl;\\n        tail->next = head;\\n        //cout<<\"Tail and its next are: \"<<tail->val<<\" \"<<tail->next->val<<endl;\\n        head = curr->next;\\n        //cout<<\"New head is: \"<<head->val<<endl;\\n        curr->next = NULL;\\n        //cout<<\"Curr is: \"<<curr->val<<endl;\\n    }\\n\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL) return head;\\n        \\n        int length = 0;\\n        int* ptr = &length;\\n        ListNode* tail = findLengthAndTail(head, ptr);\\n        //cout<<\"Length and tail are: \"<<length<<\" \"<<tail->val<<endl;\\n        if(k%length==0) return head;\\n        int pos = (length - k%length);\\n        cout<<\"Head address is: \"<<head<<endl;\\n        rotate(head, tail, &pos);\\n        //cout<<\"Head here is: \"<<head->val<<endl;\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1759017,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1750297,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1749436,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1745710,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1733208,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1727187,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1722427,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1704362,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1703078,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1628069,
                "content": [
                    {
                        "username": "ashu_2206",
                        "content": "class Solution { public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null)\\n      return head;\\n      ListNode tail=head;\\n      ListNode newHead=head;\\n      \\n           int len=1;\\n             while(tail.next!=null)\\n             {\\n                 len++;\\n                 tail=tail.next;\\n\\n             }\\n        tail.next=head;\\n        k=k%len;\\n        for(int i=0;i<len-k;i++)   tail=tail.next;\\n        newHead=tail.next;\\n        tail.next=null;\\n        return newHead;\\n        \\n         \\n         \\n\\n        \\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "why take length 1\\n"
                    },
                    {
                        "username": "ryabkin",
                        "content": "k is up to 10^9 - nice joke =)"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "  ListNode* rotateRight(ListNode* head, int k) {\\n        if(head==NULL||k==0){\\n            return head;\\n        }\\n        ListNode*temp=head;\\n        int n=0;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            n++;\\n        }\\n        temp->next=head;\\n        k=k%(n+1);\\n        int jump=n-k;\\n        temp=head;\\n        while(jump){\\n            temp=temp->next;\\n            jump--;\\n        }\\n        ListNode*returnHead=temp->next;\\n        temp->next=NULL;\\n        return returnHead;\\n\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        int len=1;\\n        ListNode iter=head;\\n        ListNode iter1=head;\\n        if(head==null){\\n            return head;\\n        }\\n        while(iter.next!=null){\\n          len++;\\n          iter=iter.next;\\n        }\\n        k=k%len;\\n        if(k==0){\\n           return head;\\n        }\\n        \\n        int skip=len-k-1;\\n        \\n        \\n        while(skip-- >0){\\n            iter1=iter1.next;\\n        }\\n\\n        iter.next=head;\\n        head=iter1.next;\\n        iter1.next=null;\\n        \\n        \\n        return head;\\n    }   \\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "In my opinion, linked lists such as this problem have always been very annoying problems to deal with. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Learning to program in LISP has increased my skills with linked lists to the nth degree."
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head==null || k==0 || head.next==null)\\n           return head;\\n        ListNode currentNode=head;\\n        int n=1;\\n        while(currentNode.next!=null){\\n            n++;\\n            currentNode=currentNode.next;\\n        }\\n      \\n        k=k%n;\\n        if(k==0)\\n          return head; \\n        ListNode secondNode=head;\\n        ListNode newnode=secondNode.next;\\n        int i=1;\\n        int j=n-k;\\n        while(i<j){\\n            secondNode=secondNode.next;\\n            newnode=secondNode.next;\\n            i++;\\n        }\\n        currentNode.next=head;\\n        secondNode.next=null;\\n        head=newnode;\\n        return head;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Well this took me far more attempts than it should have..."
                    },
                    {
                        "username": "deleted_user",
                        "content": "C++ solution[leetcode](https://leetcode.com)https://github.com/lets-do-code/rotate-list-leetcode-solution"
                    },
                    {
                        "username": "om_prakash9-",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if(k==0){\\n            return head;\\n        }\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        else if(head->next==NULL){\\n            return head;\\n        }\\n        int n=0;\\n        ListNode*iter=head;\\n        while(iter!=NULL){\\n            n++;\\n            iter=iter->next;\\n        }\\n        int rotate=0;\\n        if(k<n){\\n            rotate=k;\\n        }\\n        else{\\n            rotate=k%n;\\n        }\\n        int target=n-rotate;\\n        if(k%n==0){\\n            return head;\\n        }\\n        cout<<\"target\"<<target<<endl;\\n        int flag=1;\\n        ListNode *temp=head,*nh,*null;\\n        while(temp!=NULL){\\n            if(flag==target){\\n                nh=temp->next;\\n                null=temp;\\n                break;\\n            }\\n            flag++;\\n            temp=temp->next;\\n        }\\n        ListNode* op=nh;\\n        null->next=NULL;\\n        while(op!=NULL){\\n            if(op->next==NULL){\\n                op->next=head;\\n                break;\\n            }\\n            op=op->next;\\n        }\\n        return nh;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ablinux",
                        "content": "100% fast 0ms run time..\\n\\n `struct ListNode* rotateRight(struct ListNode* head, int k){\\n    /* here we need 3 pointer 1, head, tail and prv pointer */\\n    struct ListNode *newHead,*prvNode,*endNode,*temp = NULL;\\n    \\n    if(!head) return NULL;\\n    if(head->next == NULL) return head;\\n    /* 1st approch */\\n\\n    /* let travel the list and find th last element */\\n    temp = head;\\n    int nodeCount = 0;\\n    while(temp)\\n    {\\n        nodeCount ++; /* stored count */\\n        temp = temp->next;\\n        if(temp)\\n            endNode = temp; /* stored end node */\\n    }\\n\\n    /* lets find out the number of rotation needed */\\n    if(k%nodeCount)\\n    {\\n        k = k%nodeCount;\\n        k = nodeCount - k ; /* here the actual number from where we can split the list and joint with head\\n        which in sense looks like a rotation of list */\\n        k = nodeCount - k;\\n    }\\n    else\\n    {\\n        k = 0;\\n    }\\n    printf(\"k = %d  nodeCount = %d\",k,nodeCount);\\n    temp = head;\\n    while(temp)\\n    {\\n        prvNode = temp;\\n        if(k == nodeCount-1)\\n        {\\n            endNode->next = head;\\n            head = prvNode->next;\\n            prvNode->next = NULL;\\n            return head;\\n        }\\n        nodeCount --;\\n        temp = temp->next;\\n    }\\n\\n\\n    return head;\\n\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% fast rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    },
    {
        "title": "Erect the Fence",
        "question_content": "<p>You are given an array <code>trees</code> where <code>trees[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents the location of a tree in the garden.</p>\n\n<p>Fence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if <strong>all the trees are enclosed</strong>.</p>\n\n<p>Return <em>the coordinates of trees that are exactly located on the fence perimeter</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/erect2-plane.jpg\" style=\"width: 400px; height: 393px;\" />\n<pre>\n<strong>Input:</strong> trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\n<strong>Output:</strong> [[1,1],[2,0],[4,2],[3,3],[2,4]]\n<strong>Explanation:</strong> All the trees will be on the perimeter of the fence except the tree at [2, 2], which will be inside the fence.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/erect1-plane.jpg\" style=\"width: 400px; height: 393px;\" />\n<pre>\n<strong>Input:</strong> trees = [[1,2],[2,2],[4,2]]\n<strong>Output:</strong> [[4,2],[2,2],[1,2]]\n<strong>Explanation:</strong> The fence forms a line that passes through all the trees.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= trees.length &lt;= 3000</code></li>\n\t<li><code>trees[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 100</code></li>\n\t<li>All the given positions are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1442266,
                "title": "a-detailed-explanation-with-diagrams-graham-scan",
                "content": "***LOGIC***\\nWe look at the logic in 4 parts.\\n\\n**PART 0: INTUITIONS**\\nLet\\'s say that we have a structure as seen below.\\n![image](https://assets.leetcode.com/users/images/a008ebc4-1669-4754-9fda-1e326e31e82d_1630671027.1734948.png)\\n\\nIn this case I have marked the perimeter with dotted green lines. It looks as if we have a \"wrapping\" of all the points inside - the \"gift\" with the outer path as the \"wrapper\".\\n\\nMathematically speaking, we are looking at a convex hull. This is different from the non-convex hull which has this one angle > 180 degrees. It is marked in red.\\n\\n![image](https://assets.leetcode.com/users/images/8da70041-687f-4044-9b7e-3e6c0ac1d801_1630671156.7263188.png)\\n\\n**PART 1: Finding the Angle**\\nIt is clear that finding the angle is important. So, let\\'s do that. But immediately, we are faced with a problem.\\n\\n![image](https://assets.leetcode.com/users/images/2f4f0f4c-2628-478f-9635-55c02490232c_1630671202.0250647.png)\\n\\nIs this green or red? We have no way of telling. So, we need to first introduce some order in the nodes. The blue arrows represent the order. \\n![image](https://assets.leetcode.com/users/images/dcf2f8e8-dfaf-44f2-b6ce-a30696a8ca32_1630671264.799218.png)\\n\\nThis makes it clear as to which side to select. Thus, we **sort** the points. This allows us to go in the clockwise direction. Its also clear that `m23 > m12` holds. At this point, finding the exact angle would be a pain, so let\\'s endure the pain of some basic algebra instead.\\n\\n![image](https://assets.leetcode.com/users/images/d65bc1be-3d71-47ed-93ac-aac395c8ab22_1630671371.658808.png)\\n\\nNote that because of sorting, we could get rid of the denominator.\\n\\n**PART 2: ITERATE**\\nNow, the question is, how do we iterate over the nodes? We see that atleast 3 points are required to make a judgement of two slopes. One point is the current one, and let the other two be the last we have considered.\\n\\n![image](https://assets.leetcode.com/users/images/56ab054b-9c1f-4c9b-aa9c-897ab7ea3ba5_1630671469.2642884.png)\\n\\nA case like the above shows that `x3, y3` and `x2, y2` are important, as we thought. Also, `m34 < m23`, which does not sound good. It makes the point `x3, y3` a bad node, since it is giving us the non-convex hull. So, we remove it. Easy!\\n\\nNote that we may need to remove multiple \"bad\" points once we get a point like `x4, y4`. Think why.\\n\\n**PART 3: WHERE TO START?**\\nThere\\'s a big flaw in the current approach. Given our assumption of going clockwise, what do we do if we have a case like below?\\n\\n![image](https://assets.leetcode.com/users/images/ae07a15f-1175-4a0c-897f-7858a4feebe7_1630671689.2201905.png)\\n\\nClearly, this is also a part of the valid convex hull. The directions however have been reversed. It looks like we need to take care of the two cases:\\n\\n![image](https://assets.leetcode.com/users/images/4ae30ac4-6e6f-47fa-9528-7f725735cbbf_1630671725.490843.png)\\n\\nAnd this is it. I have coded the solution up in python, which is a direct translation of the logic we have seen.\\n\\n***CODE***\\n```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        def cmp(p1, p2, p3):\\n            x1, y1 = p1\\n            x2, y2 = p2            \\n            x3, y3 = p3\\n            \\n            return (y3-y2)*(x2-x1) - (y2-y1)*(x3-x2)\\n        \\n        points = sorted(trees)\\n        \\n        lower = []\\n        upper = []\\n        for point in points:\\n            while len(lower) >= 2 and cmp(lower[-2], lower[-1], point) > 0:\\n                lower.pop()\\n            while len(upper) >= 2 and cmp(upper[-2], upper[-1], point) < 0:\\n                upper.pop()\\n            \\n            lower.append(tuple(point))\\n            upper.append(tuple(point))\\n        \\n        return list(set(lower+upper))\\n```\\n\\n***REFERENCES***\\nhttps://commons.wikimedia.org/wiki/File:Animation_depicting_the_Monotone_algorithm.gif\\nhttps://algorithmist.com/wiki/Monotone_chain_convex_hull\\nhttps://cp-algorithms.com/geometry/grahams-scan-convex-hull.html\\n\\n\\n**An Upvote means a lot to me. So smash that button! Feedback, comments and criticisms are most welcome.**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        def cmp(p1, p2, p3):\\n            x1, y1 = p1\\n            x2, y2 = p2            \\n            x3, y3 = p3\\n            \\n            return (y3-y2)*(x2-x1) - (y2-y1)*(x3-x2)\\n        \\n        points = sorted(trees)\\n        \\n        lower = []\\n        upper = []\\n        for point in points:\\n            while len(lower) >= 2 and cmp(lower[-2], lower[-1], point) > 0:\\n                lower.pop()\\n            while len(upper) >= 2 and cmp(upper[-2], upper[-1], point) < 0:\\n                upper.pop()\\n            \\n            lower.append(tuple(point))\\n            upper.append(tuple(point))\\n        \\n        return list(set(lower+upper))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103306,
                "title": "c-and-python-easy-wiki-solution",
                "content": "C++ version:\\n`````\\n// Ref: http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull.cpp\\nclass Solution {\\n public:\\n  typedef int coord_t;  // coordinate type\\n  typedef long long coord2_t;  // must be big enough to hold 2*max(|coordinate|)^2\\n  // 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross\\n  // product. Returns a positive value, if OAB makes a counter-clockwise turn,\\n  // negative for clockwise turn, and zero if the points are collinear.\\n  coord2_t cross(const Point &O, const Point &A, const Point &B) {\\n    return (A.x - O.x) * (coord2_t)(B.y - O.y) -\\n           (A.y - O.y) * (coord2_t)(B.x - O.x);\\n  }\\n\\n  static bool cmp(Point &p1, Point &p2) {\\n    return p1.x < p2.x || (p1.x == p2.x && p1.y < p2.y);\\n  }\\n\\n  static bool equ(Point &p1, Point &p2) { return p1.x == p2.x && p1.y == p2.y; }\\n  // Returns a list of points on the convex hull in counter-clockwise order.\\n  // Note: the last point in the returned list is the same as the first one.\\n  vector<Point> outerTrees(vector<Point> &P) {\\n    int n = P.size(), k = 0;\\n    vector<Point> H(2 * n);\\n\\n    // Sort points lexicographically\\n    sort(P.begin(), P.end(), cmp);\\n\\n    // Build lower hull\\n    for (int i = 0; i < n; i++) {\\n      while (k >= 2 && cross(H[k - 2], H[k - 1], P[i]) < 0) k--;\\n      H[k++] = P[i];\\n    }\\n\\n    // Build upper hull\\n    for (int i = n - 2, t = k + 1; i >= 0; i--) {\\n      while (k >= t && cross(H[k - 2], H[k - 1], P[i]) < 0) k--;\\n      H[k++] = P[i];\\n    }\\n\\n    // Remove duplicates\\n    H.resize(k);\\n    sort(H.begin(), H.end(), cmp);\\n    H.erase(unique(H.begin(), H.end(), equ), H.end());\\n    return H;\\n  }\\n};\\n`````\\n\\nPython version:\\n````\\n# http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull.py\\n\\n\\nclass Solution(object):\\n\\n    def outerTrees(self, points):\\n        \"\"\"Computes the convex hull of a set of 2D points.\\n\\n        Input: an iterable sequence of (x, y) pairs representing the points.\\n        Output: a list of vertices of the convex hull in counter-clockwise order,\\n          starting from the vertex with the lexicographically smallest coordinates.\\n        Implements Andrew's monotone chain algorithm. O(n log n) complexity.\\n        \"\"\"\\n\\n        # Sort the points lexicographically (tuples are compared lexicographically).\\n        # Remove duplicates to detect the case we have just one unique point.\\n        # points = sorted(set(points))\\n        points = sorted(points, key=lambda p: (p.x, p.y))\\n\\n        # Boring case: no points or a single point, possibly repeated multiple times.\\n        if len(points) <= 1:\\n            return points\\n\\n        # 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross product.\\n        # Returns a positive value, if OAB makes a counter-clockwise turn,\\n        # negative for clockwise turn, and zero if the points are collinear.\\n        def cross(o, a, b):\\n            # return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\\n            return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)\\n\\n        # Build lower hull\\n        lower = []\\n        for p in points:\\n            while len(lower) >= 2 and cross(lower[-2], lower[-1], p) < 0:\\n                lower.pop()\\n            lower.append(p)\\n\\n        # Build upper hull\\n        upper = []\\n        for p in reversed(points):\\n            while len(upper) >= 2 and cross(upper[-2], upper[-1], p) < 0:\\n                upper.pop()\\n            upper.append(p)\\n\\n        # Concatenation of the lower and upper hulls gives the convex hull.\\n        # Last point of each list is omitted because it is repeated at the\\n        # beginning of the other list.\\n        # return lower[:-1] + upper[:-1]\\n        return list(set(lower[:-1] + upper[:-1]))\\n````",
                "solutionTags": [],
                "code": "`````\\n// Ref: http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull.cpp\\nclass Solution {\\n public:\\n  typedef int coord_t;  // coordinate type\\n  typedef long long coord2_t;  // must be big enough to hold 2*max(|coordinate|)^2\\n  // 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross\\n  // product. Returns a positive value, if OAB makes a counter-clockwise turn,\\n  // negative for clockwise turn, and zero if the points are collinear.\\n  coord2_t cross(const Point &O, const Point &A, const Point &B) {\\n    return (A.x - O.x) * (coord2_t)(B.y - O.y) -\\n           (A.y - O.y) * (coord2_t)(B.x - O.x);\\n  }\\n\\n  static bool cmp(Point &p1, Point &p2) {\\n    return p1.x < p2.x || (p1.x == p2.x && p1.y < p2.y);\\n  }\\n\\n  static bool equ(Point &p1, Point &p2) { return p1.x == p2.x && p1.y == p2.y; }\\n  // Returns a list of points on the convex hull in counter-clockwise order.\\n  // Note: the last point in the returned list is the same as the first one.\\n  vector<Point> outerTrees(vector<Point> &P) {\\n    int n = P.size(), k = 0;\\n    vector<Point> H(2 * n);\\n\\n    // Sort points lexicographically\\n    sort(P.begin(), P.end(), cmp);\\n\\n    // Build lower hull\\n    for (int i = 0; i < n; i++) {\\n      while (k >= 2 && cross(H[k - 2], H[k - 1], P[i]) < 0) k--;\\n      H[k++] = P[i];\\n    }\\n\\n    // Build upper hull\\n    for (int i = n - 2, t = k + 1; i >= 0; i--) {\\n      while (k >= t && cross(H[k - 2], H[k - 1], P[i]) < 0) k--;\\n      H[k++] = P[i];\\n    }\\n\\n    // Remove duplicates\\n    H.resize(k);\\n    sort(H.begin(), H.end(), cmp);\\n    H.erase(unique(H.begin(), H.end(), equ), H.end());\\n    return H;\\n  }\\n};\\n```\n````\\n# http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull.py\\n\\n\\nclass Solution(object):\\n\\n    def outerTrees(self, points):\\n        \"\"\"Computes the convex hull of a set of 2D points.\\n\\n        Input: an iterable sequence of (x, y) pairs representing the points.\\n        Output: a list of vertices of the convex hull in counter-clockwise order,\\n          starting from the vertex with the lexicographically smallest coordinates.\\n        Implements Andrew's monotone chain algorithm. O(n log n) complexity.\\n        \"\"\"\\n\\n        # Sort the points lexicographically (tuples are compared lexicographically).\\n        # Remove duplicates to detect the case we have just one unique point.\\n        # points = sorted(set(points))\\n        points = sorted(points, key=lambda p: (p.x, p.y))\\n\\n        # Boring case: no points or a single point, possibly repeated multiple times.\\n        if len(points) <= 1:\\n            return points\\n\\n        # 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross product.\\n        # Returns a positive value, if OAB makes a counter-clockwise turn,\\n        # negative for clockwise turn, and zero if the points are collinear.\\n        def cross(o, a, b):\\n            # return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\\n            return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)\\n\\n        # Build lower hull\\n        lower = []\\n        for p in points:\\n            while len(lower) >= 2 and cross(lower[-2], lower[-1], p) < 0:\\n                lower.pop()\\n            lower.append(p)\\n\\n        # Build upper hull\\n        upper = []\\n        for p in reversed(points):\\n            while len(upper) >= 2 and cross(upper[-2], upper[-1], p) < 0:\\n                upper.pop()\\n            upper.append(p)\\n\\n        # Concatenation of the lower and upper hulls gives the convex hull.\\n        # Last point of each list is omitted because it is repeated at the\\n        # beginning of the other list.\\n        # return lower[:-1] + upper[:-1]\\n        return list(set(lower[:-1] + upper[:-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828904,
                "title": "python3-monotone-chain-with-detailed-explanations-o-nlogn",
                "content": "The problem is asking us to find the convex hull given a set of 2D points.\\n\\nYou will need to know the following 2 things to better understand the Monotone Chain Algorithm:\\n(1) Meaning of cross product in 2D **([Video](https://www.google.com/search?q=cross+product&source=lnms&tbm=vid&sa=X&ved=2ahUKEwie8rePwLn7AhXqJ0QIHbnoBTUQ_AUoAnoECAIQBA&biw=960&bih=488&dpr=2#fpstate=ive&vld=cid:51ae99dc,vid:eu6i7WJeinw))** (Time: 00:40 to 02:20).\\n(2) Monotonic Stack algorithm **([link](https://liuzhenglaichn.gitbook.io/algorithm/monotonic-stack))**.\\n\\n**Monotone Chain algorithm:**\\n(1) Sort the ```points``` by ```x```. (moving from left to right)\\n(2) Initialize a ```stack``` with the first 2 points.\\n(3) Starting from the thrid point (```P3```) in points , ```P1 = stack[-2]``` and ```P2 = stack[-1]```, if ```P3``` is less counterclockwise to ```P1``` than ```P2```, pop ```P2``` from the stack, keep doing this until ```P3``` is more counterclockwise to ```P1``` than ```P2``` or if there is only one point left in the ```stack```.\\n(4) Append the current point to the ```stack``` and go to the next one.\\n(5) Reverse ```points``` (moving from right to left), and repeat (2) - (4) to get the second Monotone Chain Stack.\\n\\n```\\nP3 is more counterclockwise to P1 than P2\\n                   P3\\n                  /\\n                 /\\n        P1 ---- P2\\n\\nP3 is less counterclockwise to P1 than P2\\n        P1 ---- P2\\n                  \\\\\\n                   \\\\\\n                    P3\\n```\\n**What this algorithm does** is, first going from left to right of the points, construct the lower hull (the bottom half of the hull). Then, going from right to left, construct the upper hull (top half of the hull). \\n\\nThe process (2)-(4) is very similar to construct a regular Monotonic Stack, but instead of mataining the stack monotonically increasing, **we maintain the chain fromed by the points in the stack moving counterclockwise!**\\n\\n**Now the problem is given 3 points (P1, P2, P3), how to figure out if the chain P1->P2->P3 is moving counterclockwise.** This is done by doing a **Cross Product** of the two vectors formed by V1 = (P2,P3) and V2 = (P1,P2). If you forgot the meaning of cross product please take 2 minutes and watch this video **[HERE](https://www.google.com/search?q=cross+product&source=lnms&tbm=vid&sa=X&ved=2ahUKEwie8rePwLn7AhXqJ0QIHbnoBTUQ_AUoAnoECAIQBA&biw=960&bih=488&dpr=2#fpstate=ive&vld=cid:51ae99dc,vid:eu6i7WJeinw)** (Time: 00:40 to 02:20). So basically, if the cross product of V1 and V2 is positive, this chain is not moving counterclockwise (pop P2 from the stack). And if the cross product is negtive, this chain is moving counterclockwise (append P3 to the stack).\\n\\n**Cross product formula:** \\nV1 = (a,b), V2 = (c,d)\\nV1 X V2 = ad - bc\\n\\n```python\\nclass Solution:\\n    def outerTrees(self, points: List[List[int]]) -> List[List[int]]:\\n        \\n        def crossProduct(p1,p2,p3):\\n            ### V1 = (a,b), V2 = (c,d)\\n            ### V1 X V2 = a*d - b*c\\n            \\n            ### V1 = (P2,P3)\\n            ### V2 = (P1,P2)\\n            \\n            a = p3[0]-p2[0]\\n            b = p3[1]-p2[1]\\n            c = p2[0]-p1[0]\\n            d = p2[1]-p1[1]\\n            \\n            return  a*d - b*c\\n        \\n        def constructHalfHull(points):\\n            stack = []\\n            for p in points:\\n                ### if the chain formed by the current point\\n                ### and the last two points in the stack is not counterclockwise, pop it\\n                while len(stack)>=2 and crossProduct(stack[-2],stack[-1],p)>0:\\n                    stack.pop()\\n                ### append the current point.\\n                stack.append(tuple(p))\\n            return stack\\n        \\n        ### sort points by x, so we are moving from left to right\\n        points.sort()\\n        leftToRight = constructHalfHull(points)\\n        ### reverse points, so we are moving from right to left\\n        rightToLeft = constructHalfHull(points[::-1])\\n        \\n        ### it is posible that the top and bottom parts have same points (e.g., all points form a line)\\n        ### we remove the duplicated points using a set\\n        return list(set(leftToRight + rightToLeft))\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```points```\n```x```\n```stack```\n```P3```\n```P1 = stack[-2]```\n```P2 = stack[-1]```\n```P3```\n```P1```\n```P2```\n```P2```\n```P3```\n```P1```\n```P2```\n```stack```\n```stack```\n```points```\n```\\nP3 is more counterclockwise to P1 than P2\\n                   P3\\n                  /\\n                 /\\n        P1 ---- P2\\n\\nP3 is less counterclockwise to P1 than P2\\n        P1 ---- P2\\n                  \\\\\\n                   \\\\\\n                    P3\\n```\n```python\\nclass Solution:\\n    def outerTrees(self, points: List[List[int]]) -> List[List[int]]:\\n        \\n        def crossProduct(p1,p2,p3):\\n            ### V1 = (a,b), V2 = (c,d)\\n            ### V1 X V2 = a*d - b*c\\n            \\n            ### V1 = (P2,P3)\\n            ### V2 = (P1,P2)\\n            \\n            a = p3[0]-p2[0]\\n            b = p3[1]-p2[1]\\n            c = p2[0]-p1[0]\\n            d = p2[1]-p1[1]\\n            \\n            return  a*d - b*c\\n        \\n        def constructHalfHull(points):\\n            stack = []\\n            for p in points:\\n                ### if the chain formed by the current point\\n                ### and the last two points in the stack is not counterclockwise, pop it\\n                while len(stack)>=2 and crossProduct(stack[-2],stack[-1],p)>0:\\n                    stack.pop()\\n                ### append the current point.\\n                stack.append(tuple(p))\\n            return stack\\n        \\n        ### sort points by x, so we are moving from left to right\\n        points.sort()\\n        leftToRight = constructHalfHull(points)\\n        ### reverse points, so we are moving from right to left\\n        rightToLeft = constructHalfHull(points[::-1])\\n        \\n        ### it is posible that the top and bottom parts have same points (e.g., all points form a line)\\n        ### we remove the duplicated points using a set\\n        return list(set(leftToRight + rightToLeft))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442271,
                "title": "day-3-erect-the-fence-convex-hull-algorithm-c-with-graphical-explanation",
                "content": "There is no point in solving this problem in a Brute force method. \\nThis is an implementation of a Convex Hull algorithm, where we instead of sorting the array based on angles the points creates with X-axis, we sort the array lexicographically and construct two `Upper HULL and Bottom HULL` and merge them together.\\nThe algorithm in itself is quite beautiful!\\n\\n*The main idea whether to consider the point as part of the hull or not is dependant of the  determining whether three points constitute a \"left turn\" or a \"right turn\" i.e. by computing the z-coordinate of the cross product of the two vectors, we can tell if the new point is* `collinear == 0, left turn > 0 or right turn < 0`\\n\\nFor example:\\nTake the `trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]`\\n1. Base case: If the number of elements in array <= 3, then all those trees will fall on the edge of the fence.\\n1. Sort the array based on the `x-axis` values (lexicographical).\\n2. We first create a `upper list` and insert the first two sorted elements in them.\\n3. Then we compute the angle the 3rd point creates with these two points i.e. a left turn or a right turn. If it is a left turn, `we pop the list and insert the present element` else we `add the present element to the list`.\\n![image](https://assets.leetcode.com/users/images/f92753a8-1daa-4f0a-a0a1-4ec8dec2ee67_1630671714.2272766.png)\\n![image](https://assets.leetcode.com/users/images/d0872b94-13ec-4983-9c08-d247ae783e25_1630671691.5702815.png)\\n![image](https://assets.leetcode.com/users/images/2f0a56bf-3704-4c87-ac6e-a4544720418a_1630671735.944018.png)\\n![image](https://assets.leetcode.com/users/images/c434ddb5-6d1d-422c-9595-398dcd872220_1630671761.360228.png)\\n![image](https://assets.leetcode.com/users/images/e4aa50dd-9223-4b33-b500-66447c2ff2a0_1630671778.5195985.png)\\n4. Once, the TOP HULL is created, we focus on the bottom HULL.\\n5. Same logic as before. We first create a `lower list` and insert the **last two** sorted elements in them.\\n6. Then we compute the angle the 3rd point creates with these two points i.e. a left turn or a right turn. If it is a left turn, `we pop the list and insert the present element` else we `add the present element to the list`.\\n![image](https://assets.leetcode.com/users/images/6f8bd4d1-6043-4090-9411-22178fde168f_1630671857.4362123.png)\\n![image](https://assets.leetcode.com/users/images/98499bb2-1d56-4191-bcf4-0545fe92bd31_1630671868.539188.png)\\n![image](https://assets.leetcode.com/users/images/58d307e0-22d6-4270-8468-d3db57879a97_1630671880.666919.png)\\n7. Finally merge both the lists and remove duplicate elements in them as they would\\'ve occurred twice.\\n\\nThat\\'s it once, you get this intuition the problem is solved for all possible cases!\\n\\n```\\nclass Solution {\\npublic:\\n    int getRotationAngle(vector<int> A, vector<int> B, vector<int> C) {\\n        // (x2-x1)(y3-y1) - (y2-y1)(x3-x1) -> 3D Cross-product of AB and AC vectors\\n        return ((B[0] - A[0]) * (C[1] - A[1])) - ((B[1] - A[1]) * (C[0] - A[0]));\\n    }\\n    \\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        if (trees.size() <= 3) return trees;\\n        sort(trees.begin(), trees.end());\\n        \\n\\t\\t// Upper HULL construction\\n        vector<vector<int>> lTrees;\\n        lTrees.push_back(trees[0]);\\n        lTrees.push_back(trees[1]);\\n        for (int i = 2; i < trees.size(); i++) {\\n            int ls = lTrees.size();\\n            while (lTrees.size() >= 2 && getRotationAngle(lTrees[ls-2], lTrees[ls-1], trees[i]) > 0) {\\n                lTrees.pop_back();\\n                ls--;\\n            }\\n            lTrees.push_back(trees[i]);\\n        }\\n        \\n\\t\\t// Lower HULL construction\\n        vector<vector<int>> rTrees;\\n        rTrees.push_back(trees[trees.size() - 1]);\\n        rTrees.push_back(trees[trees.size() - 2]);\\n        for (int i = trees.size() - 3; i >= 0; --i) {\\n            int rs = rTrees.size(); \\n            while (rTrees.size() >= 2 && getRotationAngle(rTrees[rs-2], rTrees[rs-1], trees[i]) > 0) {\\n                rTrees.pop_back();\\n                rs--;\\n            }\\n            rTrees.push_back(trees[i]);\\n        }\\n        \\n\\t\\t// Pop the last elements as they would\\'ve occurred in both lists\\n        rTrees.pop_back();\\n        lTrees.pop_back();\\n        for (int i = 0; i < rTrees.size(); i++) {\\n            lTrees.push_back(rTrees[i]);\\n        }\\n        \\n\\t\\t// Sort and remove duplicate elements. (It is begging for a different approach!!)\\n        sort(lTrees.begin(), lTrees.end());\\n        lTrees.erase(std::unique(lTrees.begin(), lTrees.end()), lTrees.end());\\n        \\n        return lTrees;\\n    }\\n};\\n```\\n\\nIf you find it helpful, please upvote!\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getRotationAngle(vector<int> A, vector<int> B, vector<int> C) {\\n        // (x2-x1)(y3-y1) - (y2-y1)(x3-x1) -> 3D Cross-product of AB and AC vectors\\n        return ((B[0] - A[0]) * (C[1] - A[1])) - ((B[1] - A[1]) * (C[0] - A[0]));\\n    }\\n    \\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        if (trees.size() <= 3) return trees;\\n        sort(trees.begin(), trees.end());\\n        \\n\\t\\t// Upper HULL construction\\n        vector<vector<int>> lTrees;\\n        lTrees.push_back(trees[0]);\\n        lTrees.push_back(trees[1]);\\n        for (int i = 2; i < trees.size(); i++) {\\n            int ls = lTrees.size();\\n            while (lTrees.size() >= 2 && getRotationAngle(lTrees[ls-2], lTrees[ls-1], trees[i]) > 0) {\\n                lTrees.pop_back();\\n                ls--;\\n            }\\n            lTrees.push_back(trees[i]);\\n        }\\n        \\n\\t\\t// Lower HULL construction\\n        vector<vector<int>> rTrees;\\n        rTrees.push_back(trees[trees.size() - 1]);\\n        rTrees.push_back(trees[trees.size() - 2]);\\n        for (int i = trees.size() - 3; i >= 0; --i) {\\n            int rs = rTrees.size(); \\n            while (rTrees.size() >= 2 && getRotationAngle(rTrees[rs-2], rTrees[rs-1], trees[i]) > 0) {\\n                rTrees.pop_back();\\n                rs--;\\n            }\\n            rTrees.push_back(trees[i]);\\n        }\\n        \\n\\t\\t// Pop the last elements as they would\\'ve occurred in both lists\\n        rTrees.pop_back();\\n        lTrees.pop_back();\\n        for (int i = 0; i < rTrees.size(); i++) {\\n            lTrees.push_back(rTrees[i]);\\n        }\\n        \\n\\t\\t// Sort and remove duplicate elements. (It is begging for a different approach!!)\\n        sort(lTrees.begin(), lTrees.end());\\n        lTrees.erase(std::unique(lTrees.begin(), lTrees.end()), lTrees.end());\\n        \\n        return lTrees;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828910,
                "title": "python-c-rust-upper-lower-convex-hulls-bonus-scipy-numpy-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs [**Andrew\\'s monotone chain convex hull algorithm**](https://algorithmist.com/wiki/Monotone_chain_convex_hull). Time complexity is log-linear: **O(N\\\\*logN)**. Space complexity is linear: **O(N)**.\\n****\\n\\n**Comment.** What\\'s being asked in the problem (in mathematical terms) is basically constructing a convex hull (but I\\'ll keep calling it a fence). The list of key ideas here is the following:\\n1. First, locate a starting tree, namely, the one that **definitely** belongs to the fence. To do that, we *x*-sort the trees and take the leftmost one (i.e., with the minimal *x*). This will be the beginning of the fence.\\n2. But now we have a problem, namely, that there are trees that may lie both below and above that starting tree. Thus, we\\'ll be constructing two fences, upper and lower, then joining them.\\n3. To construct an upper fence, we will iterate through the x-ordered list of points and check whether the addition of each new tree **T** will force us to make a left (counterclockwise) or a right (clockwise) turn with respect to the direction specified by the last 2 trees (the last one **B** and the next to the last one **A**) in the fence. \\n4. This data is enconded in the angle between two vectors (**BT** and **AB**). We call this angle positive (negative, zero) if **BT** lies to the right of (lies to the left of, is collinear to) **AB**. This angle (to be more precise, it\\'s  [**sine**](https://en.wikipedia.org/wiki/Sine_and_cosine)) can be extracted from the [**cross product**](https://en.wikipedia.org/wiki/Cross_product) of vectors  **BT** and **AB**, namely, from **BT x AB = |BT| \\\\* |AB| \\\\* sin(BT,AB)**. Sine function has the same sign as the angle, thus, taking the sign of the cross product is our way to detect the change in direction. (It is known from geometry that cross product can be computed from the coordinates of the vectors, see code.)\\n5. Once we have a way to check that a new tree breaks a correct arrangement of the fence (i.e., breaks convexity), we can iteratively build up a fence. For this, we\\'ll use a stack to: \\n\\t* add (push) new trees that respect convexity (namely, those that force us making right turns or staying on track);\\n\\t* discard (pop) all previous trees that do not respect convexity given a newly added tree (i.e., we will pop trees from the stack until convexity is restored)\\n6. The same should be done for the lower fence, however, with the opposite sign convention.\\n7. Given that fences have shared trees (at least the starting tree), we join only unique of them.\\n\\n**Python.** Note that we can use numpy here for cross product, but for some reason it\\'s slow and gives TLE.\\n```\\n# import numpy as np\\n\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        \\n        trees = sorted(trees)                                    # [1] make an x-ordered list of points\\n        #trees = [np.array(t) for t in sorted(trees)]            #     (for a numpy solution, use this)\\n        U, L = [], []\\n        \\n        def cross(B, A, T):                                      # [2] this function computes cross product\\n            Bx, By, Ax, Ay, Tx, Ty = chain(B, A, T)              #     between vectors BT=T-B and AB=B-A\\n            return (Ty-By)*(Bx-Ax) - (By-Ay)*(Tx-Bx)\\n            #return np.cross(T-B,B-A)                            #     (for a numpy solution, use this)\\n                \\n        for T in trees:                                          # [3] according to Andrew\\'s algorithm,\\n            while len(U) >= 2 and cross(U[-1],U[-2],T) < 0:      #     we add points to upper (lower)\\n                U.pop()                                          #     convex hulls if they make a\\n            U.append(T)                                          #     clockwise (counterclockwise) turn\\n                                                                 #     with respect to the last two trees\\n            while len(L) >= 2 and cross(L[-1],L[-2],T) > 0:      #     in the convex hull; if that\\'s not\\n                L.pop()                                          #     possible, we first remove all previous\\n            L.append(T)                                          #     trees that break the convexity\\n\\n        return set(tuple(T) for T in (U+L))                      # [4] join convex hulls, with only unique trees\\n```\\n\\nI also provide this solution in other languages. Please note that we can use *deque* to store both stacks. It\\'s a convenient trick to quickly build a set from a single iterator.\\n\\n<iframe src=\"https://leetcode.com/playground/62E2uSCo/shared\" frameBorder=\"0\" width=\"800\" height=\"650\"></iframe>\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python**.  Use Delaunay triangulation (a way to construct convex hulls) then check whether each tree belongs to the fence by slightly moving it away from the center of mass and searching for a simplex to fit into. If no such simplex was found, the tree must have been ON the hull/fence (and NOT IN the bulk). This approach works becuase *eps* is small and all coordinates are integers.\\n```\\nfrom scipy.spatial import Delaunay\\nfrom numpy import array, average, polyfit\\n\\nclass Solution:\\n    def outerTrees(self, trees, eps=10**-10):\\n        \\n        T = array(trees)                                    # [1] convert to numpy array for convenience\\n        \\n        if len(T) < 4: return trees                         # [2] consider trivial cases when either there\\n        if polyfit(T[:,0], T[:,1], 1, full=True)[1] < eps:  #     are less than 4 trees or all of them lie\\n            return trees                                    #     on the same line (sum of residuals < eps)\\n        \\n        cm = average(T, axis=0)                             # [3] compute center of mass of all trees\\n        F = Delaunay(T)                                     # [4] triangulate (it\\'s a way to make a convex hull)\\n        \\n        def on_fence(t):                                    # [5] if a tree is ON fence, then by moving it away from\\n            return F.find_simplex(t+(t-cm)*eps) < 0         #     the center of mass, we\\'ll expell it from all simplices\\n\\n        return [t for t in T if on_fence(t)]                # [6] return trees that satisfy the \\'on_fence\\' criterion\\n\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# import numpy as np\\n\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        \\n        trees = sorted(trees)                                    # [1] make an x-ordered list of points\\n        #trees = [np.array(t) for t in sorted(trees)]            #     (for a numpy solution, use this)\\n        U, L = [], []\\n        \\n        def cross(B, A, T):                                      # [2] this function computes cross product\\n            Bx, By, Ax, Ay, Tx, Ty = chain(B, A, T)              #     between vectors BT=T-B and AB=B-A\\n            return (Ty-By)*(Bx-Ax) - (By-Ay)*(Tx-Bx)\\n            #return np.cross(T-B,B-A)                            #     (for a numpy solution, use this)\\n                \\n        for T in trees:                                          # [3] according to Andrew\\'s algorithm,\\n            while len(U) >= 2 and cross(U[-1],U[-2],T) < 0:      #     we add points to upper (lower)\\n                U.pop()                                          #     convex hulls if they make a\\n            U.append(T)                                          #     clockwise (counterclockwise) turn\\n                                                                 #     with respect to the last two trees\\n            while len(L) >= 2 and cross(L[-1],L[-2],T) > 0:      #     in the convex hull; if that\\'s not\\n                L.pop()                                          #     possible, we first remove all previous\\n            L.append(T)                                          #     trees that break the convexity\\n\\n        return set(tuple(T) for T in (U+L))                      # [4] join convex hulls, with only unique trees\\n```\n```\\nfrom scipy.spatial import Delaunay\\nfrom numpy import array, average, polyfit\\n\\nclass Solution:\\n    def outerTrees(self, trees, eps=10**-10):\\n        \\n        T = array(trees)                                    # [1] convert to numpy array for convenience\\n        \\n        if len(T) < 4: return trees                         # [2] consider trivial cases when either there\\n        if polyfit(T[:,0], T[:,1], 1, full=True)[1] < eps:  #     are less than 4 trees or all of them lie\\n            return trees                                    #     on the same line (sum of residuals < eps)\\n        \\n        cm = average(T, axis=0)                             # [3] compute center of mass of all trees\\n        F = Delaunay(T)                                     # [4] triangulate (it\\'s a way to make a convex hull)\\n        \\n        def on_fence(t):                                    # [5] if a tree is ON fence, then by moving it away from\\n            return F.find_simplex(t+(t-cm)*eps) < 0         #     the center of mass, we\\'ll expell it from all simplices\\n\\n        return [t for t in T if on_fence(t)]                # [6] return trees that satisfy the \\'on_fence\\' criterion\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 103302,
                "title": "java-graham-scan-with-adapted-sorting-to-deal-with-collinear-points",
                "content": "The trick is that once all points are sorted by polar angle with respect to the reference point:\\n* For collinear points in the begin positions, make sure they are sorted by distance to reference point in **ascending** order.\\n* For collinear points in the end positions, make sure they are sorted by distance to reference point in **descending** order.\\n\\nFor example:\\n```(0, 0), (2, 0), (3, 0), (3, 1), (3, 2), (2, 2), (1, 2), (0, 2), (0, 1)```\\nThese points are sorted by polar angle\\nThe reference point (bottom left point) is ```(0, 0)```\\n* In the begin positions ```(0, 0)``` collinear with ```(2, 0), (3, 0)``` sorted by distance to reference point in **ascending** order.\\n* In the end positions ```(0, 0)``` collinear with ```(0, 2), (0, 1)``` sorted by distance to reference point in **descending** order.\\n\\nNow we can run the standard Graham scan to give us the desired result.\\n```\\npublic class Solution {\\n\\n    public List<Point> outerTrees(Point[] points) {\\n        if (points.length <= 1)\\n            return Arrays.asList(points);\\n        sortByPolar(points, bottomLeft(points));\\n        Stack<Point> stack = new Stack<>(); \\n        stack.push(points[0]);                      \\n        stack.push(points[1]);                              \\n        for (int i = 2; i < points.length; i++) {\\n            Point top = stack.pop();                                \\n            while (ccw(stack.peek(), top, points[i]) < 0)\\n                top = stack.pop();\\n            stack.push(top);\\n            stack.push(points[i]);\\n        }       \\n        return new ArrayList<>(stack);\\n    }                               \\n\\n    private static Point bottomLeft(Point[] points) {\\n        Point bottomLeft = points[0];\\n        for (Point p : points)          \\n            if (p.y < bottomLeft.y || p.y == bottomLeft.y && p.x < bottomLeft.x)\\n                bottomLeft = p;                 \\n        return bottomLeft;                                                  \\n    }\\n\\n    /**\\n     * @return positive if counter-clockwise, negative if clockwise, 0 if collinear\\n     */\\n    private static int ccw(Point a, Point b, Point c) {\\n        return a.x * b.y - a.y * b.x + b.x * c.y - b.y * c.x + c.x * a.y - c.y * a.x;       \\n    }\\n\\n    /**\\n     * @return distance square of |p - q|\\n     */\\n    private static int dist(Point p, Point q) {\\n        return (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\\n    }\\n                              \\n    private static void sortByPolar(Point[] points, Point r) {\\n        Arrays.sort(points, (p, q) -> {\\n            int compPolar = ccw(p, r, q);\\n            int compDist = dist(p, r) - dist(q, r); \\n            return compPolar == 0 ? compDist : compPolar;\\n        });     \\n        // find collinear points in the end positions\\n        Point p = points[0], q = points[points.length - 1];\\n        int i = points.length - 2;\\n        while (i >= 0 && ccw(p, q, points[i]) == 0)\\n            i--;    \\n        // reverse sort order of collinear points in the end positions\\n        for (int l = i + 1, h = points.length - 1; l < h; l++, h--) {\\n            Point tmp = points[l];\\n            points[l] = points[h];\\n            points[h] = tmp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```(0, 0), (2, 0), (3, 0), (3, 1), (3, 2), (2, 2), (1, 2), (0, 2), (0, 1)```\n```(0, 0)```\n```(0, 0)```\n```(2, 0), (3, 0)```\n```(0, 0)```\n```(0, 2), (0, 1)```\n```\\npublic class Solution {\\n\\n    public List<Point> outerTrees(Point[] points) {\\n        if (points.length <= 1)\\n            return Arrays.asList(points);\\n        sortByPolar(points, bottomLeft(points));\\n        Stack<Point> stack = new Stack<>(); \\n        stack.push(points[0]);                      \\n        stack.push(points[1]);                              \\n        for (int i = 2; i < points.length; i++) {\\n            Point top = stack.pop();                                \\n            while (ccw(stack.peek(), top, points[i]) < 0)\\n                top = stack.pop();\\n            stack.push(top);\\n            stack.push(points[i]);\\n        }       \\n        return new ArrayList<>(stack);\\n    }                               \\n\\n    private static Point bottomLeft(Point[] points) {\\n        Point bottomLeft = points[0];\\n        for (Point p : points)          \\n            if (p.y < bottomLeft.y || p.y == bottomLeft.y && p.x < bottomLeft.x)\\n                bottomLeft = p;                 \\n        return bottomLeft;                                                  \\n    }\\n\\n    /**\\n     * @return positive if counter-clockwise, negative if clockwise, 0 if collinear\\n     */\\n    private static int ccw(Point a, Point b, Point c) {\\n        return a.x * b.y - a.y * b.x + b.x * c.y - b.y * c.x + c.x * a.y - c.y * a.x;       \\n    }\\n\\n    /**\\n     * @return distance square of |p - q|\\n     */\\n    private static int dist(Point p, Point q) {\\n        return (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\\n    }\\n                              \\n    private static void sortByPolar(Point[] points, Point r) {\\n        Arrays.sort(points, (p, q) -> {\\n            int compPolar = ccw(p, r, q);\\n            int compDist = dist(p, r) - dist(q, r); \\n            return compPolar == 0 ? compDist : compPolar;\\n        });     \\n        // find collinear points in the end positions\\n        Point p = points[0], q = points[points.length - 1];\\n        int i = points.length - 2;\\n        while (i >= 0 && ccw(p, q, points[i]) == 0)\\n            i--;    \\n        // reverse sort order of collinear points in the end positions\\n        for (int l = i + 1, h = points.length - 1; l < h; l++, h--) {\\n            Point tmp = points[l];\\n            points[l] = points[h];\\n            points[h] = tmp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103299,
                "title": "java-solution-convex-hull-algorithm-gift-wrapping-aka-jarvis-march",
                "content": "There are couple of ways to solve Convex Hull problem. https://en.wikipedia.org/wiki/Convex_hull_algorithms\\nThe following code implements ```Gift wrapping aka Jarvis march``` algorithm https://en.wikipedia.org/wiki/Gift_wrapping_algorithm and also added logic to handle case of ```multiple Points in a line``` because original Jarvis march algorithm assumes ```no three points are collinear```.\\nIt also uses knowledge in this problem https://leetcode.com/problems/convex-polygon . Disscussion: https://discuss.leetcode.com/topic/70706/beyond-my-knowledge-java-solution-with-in-line-explanation\\n```\\npublic class Solution {\\n    public List<Point> outerTrees(Point[] points) {\\n        Set<Point> result = new HashSet<>();\\n        \\n        // Find the leftmost point\\n        Point first = points[0];\\n        int firstIndex = 0;\\n        for (int i = 1; i < points.length; i++) {\\n            if (points[i].x < first.x) {\\n                first = points[i];\\n                firstIndex = i;\\n            }\\n        }\\n        result.add(first);\\n        \\n        Point cur = first;\\n        int curIndex = firstIndex;\\n        do {\\n            Point next = points[0];\\n            int nextIndex = 0;\\n            for (int i = 1; i < points.length; i++) {\\n                if (i == curIndex) continue;\\n                int cross = crossProductLength(cur, points[i], next);\\n                if (nextIndex == curIndex || cross > 0 ||\\n                        // Handle collinear points\\n                        (cross == 0 && distance(points[i], cur) > distance(next, cur))) {\\n                    next = points[i];\\n                    nextIndex = i;\\n                }\\n            }\\n            // Handle collinear points\\n            for (int i = 0; i < points.length; i++) {\\n                if (i == curIndex) continue;\\n                int cross = crossProductLength(cur, points[i], next);\\n                if (cross == 0) {\\n                    result.add(points[i]);\\n                }\\n            }\\n\\n            cur = next;\\n            curIndex = nextIndex;\\n            \\n        } while (curIndex != firstIndex);\\n        \\n        return new ArrayList<Point>(result);\\n    }\\n    \\n    private int crossProductLength(Point A, Point B, Point C) {\\n        // Get the vectors' coordinates.\\n        int BAx = A.x - B.x;\\n        int BAy = A.y - B.y;\\n        int BCx = C.x - B.x;\\n        int BCy = C.y - B.y;\\n    \\n        // Calculate the Z coordinate of the cross product.\\n        return (BAx * BCy - BAy * BCx);\\n    }\\n\\n    private int distance(Point p1, Point p2) {\\n        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Gift wrapping aka Jarvis march```\n```multiple Points in a line```\n```no three points are collinear```\n```\\npublic class Solution {\\n    public List<Point> outerTrees(Point[] points) {\\n        Set<Point> result = new HashSet<>();\\n        \\n        // Find the leftmost point\\n        Point first = points[0];\\n        int firstIndex = 0;\\n        for (int i = 1; i < points.length; i++) {\\n            if (points[i].x < first.x) {\\n                first = points[i];\\n                firstIndex = i;\\n            }\\n        }\\n        result.add(first);\\n        \\n        Point cur = first;\\n        int curIndex = firstIndex;\\n        do {\\n            Point next = points[0];\\n            int nextIndex = 0;\\n            for (int i = 1; i < points.length; i++) {\\n                if (i == curIndex) continue;\\n                int cross = crossProductLength(cur, points[i], next);\\n                if (nextIndex == curIndex || cross > 0 ||\\n                        // Handle collinear points\\n                        (cross == 0 && distance(points[i], cur) > distance(next, cur))) {\\n                    next = points[i];\\n                    nextIndex = i;\\n                }\\n            }\\n            // Handle collinear points\\n            for (int i = 0; i < points.length; i++) {\\n                if (i == curIndex) continue;\\n                int cross = crossProductLength(cur, points[i], next);\\n                if (cross == 0) {\\n                    result.add(points[i]);\\n                }\\n            }\\n\\n            cur = next;\\n            curIndex = nextIndex;\\n            \\n        } while (curIndex != firstIndex);\\n        \\n        return new ArrayList<Point>(result);\\n    }\\n    \\n    private int crossProductLength(Point A, Point B, Point C) {\\n        // Get the vectors' coordinates.\\n        int BAx = A.x - B.x;\\n        int BAy = A.y - B.y;\\n        int BCx = C.x - B.x;\\n        int BCy = C.y - B.y;\\n    \\n        // Calculate the Z coordinate of the cross product.\\n        return (BAx * BCy - BAy * BCx);\\n    }\\n\\n    private int distance(Point p1, Point p2) {\\n        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442027,
                "title": "python-short-graham-scan-follow-up-explained",
                "content": "What we actually need to find is convex hull of given points. There are different ways how to do it: the simplest is Jarvis Algorithm with `O(mn)` complexity, where `n` is total number of points and `m` is number of points in convex hull. I prefer **Graham scan**, which use the idea of angle sweep. We need to choose the most left point as starting point. Then we need to sort points with respect to its angle, and if we have the same angle, then we need to sort points by **(-p[1], p[0])** - in this way we can be sure that we traverse points in correct order, also we need to make sure that for the first points if they have the same angle, we need to sort them in **increasing order by distance** and for the last one in the **decreasing order by distance**. I did not found elegant way to code this, so what I do is just check last points and look for points lying on the same line and then sort them in correct way. Then we keep stack with points and check orientation of triangle, using `cross` function and if orientation is negative, then we pop the point `ans[-2]`. Please go to wikipedia for more details.\\n\\nNote, that in this problem our convex hull contains point on border, if we do not need it we need to use  `cross(*ans[-3:]) <= 0` instead and `points.sort(key=lambda p: (atan2(p[1]-start[1], p[0]-start[0]), p[0]))`, I am not 100 sure though, I did not test it a lot.\\n\\n#### Complexity\\nTime complexity is `O(n log n)`, space complexity is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def outerTrees(self, points):\\n        def cross(p1, p2, p3):\\n            return (p2[0]-p1[0])*(p3[1]-p1[1])-(p2[1]-p1[1])*(p3[0]-p1[0])\\n\\n        start = min(points)\\n        points.pop(points.index(start))\\n        points.sort(key=lambda p: (atan2(p[1]-start[1], p[0]-start[0]), -p[1], p[0]))\\n        \\n        last = len(points) - 1\\n        while last > 0 and cross(start, points[-1], points[last - 1]) == 0:\\n            last -= 1\\n            \\n        points[last:] = sorted(points[last:], key = lambda p: (-p[0]))\\n\\n        ans = [start]\\n        for p in points:\\n            ans.append(p)\\n            while len(ans) > 2 and cross(*ans[-3:]) < 0:\\n                ans.pop(-2)\\n        return ans\\n```\\n\\n#### Solution 2\\nWhen I solved this problem, I was not fully satisfied, because of `atan2` function: given problem constraints, all absolute values `<= 100` it will work fine. But if we have bigger coordinates, it can wrong incorrectly, because `3` points can lie almost on the same line and we can not be sure if it is convex or concave. To compare points we need to first check the quater it is inside and then if they are in the same quater, check `p1[1]/p1[0] > p2[1]/p2[0]`, which can be written without divisions. Function `compare` will compare points, usch that angle lies in (-180, 180) without rounding errors.\\n\\nNow, we use the similar logic as in solution 1, but we need to **normalize** points, that is subtract `start` from all of them, then perfrom sort and in the end add `start` back.\\n\\n#### Complexity\\nIt is still `O(n log n)` for time and `O(n)` for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def outerTrees(self, points):\\n        def quater(p):\\n            x, y = p\\n            if x >= 0 and y >= 0: return 2\\n            if x < 0 and y >= 0: return 1\\n            if x < 0 and y < 0: return 4\\n            if x >= 0 and y < 0: return 3\\n\\n        def compare(p1, p2):\\n            if quater(p1) == quater(p2):\\n                t1 = p1[1]*p2[0] - p2[1]*p1[0]\\n                return  1 - 2*int((-p1[1], p1[0]) < (-p2[1], p2[0])) if t1 == 0 else 1 if t1 > 0 else -1\\n            else:\\n                return 1 if quater(p1) < quater(p2) else -1\\n        \\n        def cross(p1, p2, p3):\\n            return (p2[0]-p1[0])*(p3[1]-p1[1])-(p2[1]-p1[1])*(p3[0]-p1[0])\\n\\n        start = min(points)\\n        points.pop(points.index(start))\\n        points = [[x - start[0], y - start[1]] for x, y in points]\\n        points.sort(key = cmp_to_key(compare))\\n        \\n        last = len(points) - 1\\n        while last > 0 and cross([0, 0], points[-1], points[last - 1]) == 0:\\n            last -= 1\\n            \\n        points[last:] = sorted(points[last:], key = lambda p: (-p[0]))\\n\\n        ans = [[0, 0]]\\n        for p in points:\\n            ans.append(p)\\n            while len(ans) > 2 and cross(*ans[-3:]) < 0:\\n                ans.pop(-2)\\n        \\n        return [[x + start[0], y + start[1]] for x, y in ans]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def outerTrees(self, points):\\n        def cross(p1, p2, p3):\\n            return (p2[0]-p1[0])*(p3[1]-p1[1])-(p2[1]-p1[1])*(p3[0]-p1[0])\\n\\n        start = min(points)\\n        points.pop(points.index(start))\\n        points.sort(key=lambda p: (atan2(p[1]-start[1], p[0]-start[0]), -p[1], p[0]))\\n        \\n        last = len(points) - 1\\n        while last > 0 and cross(start, points[-1], points[last - 1]) == 0:\\n            last -= 1\\n            \\n        points[last:] = sorted(points[last:], key = lambda p: (-p[0]))\\n\\n        ans = [start]\\n        for p in points:\\n            ans.append(p)\\n            while len(ans) > 2 and cross(*ans[-3:]) < 0:\\n                ans.pop(-2)\\n        return ans\\n```\n```python\\nclass Solution:\\n    def outerTrees(self, points):\\n        def quater(p):\\n            x, y = p\\n            if x >= 0 and y >= 0: return 2\\n            if x < 0 and y >= 0: return 1\\n            if x < 0 and y < 0: return 4\\n            if x >= 0 and y < 0: return 3\\n\\n        def compare(p1, p2):\\n            if quater(p1) == quater(p2):\\n                t1 = p1[1]*p2[0] - p2[1]*p1[0]\\n                return  1 - 2*int((-p1[1], p1[0]) < (-p2[1], p2[0])) if t1 == 0 else 1 if t1 > 0 else -1\\n            else:\\n                return 1 if quater(p1) < quater(p2) else -1\\n        \\n        def cross(p1, p2, p3):\\n            return (p2[0]-p1[0])*(p3[1]-p1[1])-(p2[1]-p1[1])*(p3[0]-p1[0])\\n\\n        start = min(points)\\n        points.pop(points.index(start))\\n        points = [[x - start[0], y - start[1]] for x, y in points]\\n        points.sort(key = cmp_to_key(compare))\\n        \\n        last = len(points) - 1\\n        while last > 0 and cross([0, 0], points[-1], points[last - 1]) == 0:\\n            last -= 1\\n            \\n        points[last:] = sorted(points[last:], key = lambda p: (-p[0]))\\n\\n        ans = [[0, 0]]\\n        for p in points:\\n            ans.append(p)\\n            while len(ans) > 2 and cross(*ans[-3:]) < 0:\\n                ans.pop(-2)\\n        \\n        return [[x + start[0], y + start[1]] for x, y in ans]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829276,
                "title": "c-clean-and-concise-o-nlogn",
                "content": "\\nUpvote if you like it! \\uD83D\\uDC4D\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n      int n = trees.size();\\n      if (n <= 3) return trees;\\n      sort(trees.begin(), trees.end(), [](const vector<int>& a, const vector<int>& b) {\\n        return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\\n      });\\n      vector<vector<int>> hull;\\n      for (int i = 0; i < n; ++i) {\\n        while (hull.size() >= 2 && cross(hull[hull.size() - 2], hull.back(), trees[i]) < 0) {\\n          hull.pop_back();\\n        }\\n        hull.push_back(trees[i]);\\n      }\\n      hull.pop_back();\\n      for (int i = n - 1; i >= 0; --i) {\\n        while (hull.size() >= 2 && cross(hull[hull.size() - 2], hull.back(), trees[i]) < 0) {\\n          hull.pop_back();\\n        }\\n        hull.push_back(trees[i]);\\n      }\\n      hull.pop_back();\\n      sort(hull.begin(), hull.end());\\n      hull.erase(unique(hull.begin(), hull.end()), hull.end());\\n      return hull;\\n    }\\nprivate:\\n    int cross(const vector<int>& a, const vector<int>& b, const vector<int>& c) {\\n      return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\\n    }\\n};\\n```\\n----\\n**Time Complexity : O(NLogN)\\nSpace Complexity: O(N)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n      int n = trees.size();\\n      if (n <= 3) return trees;\\n      sort(trees.begin(), trees.end(), [](const vector<int>& a, const vector<int>& b) {\\n        return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\\n      });\\n      vector<vector<int>> hull;\\n      for (int i = 0; i < n; ++i) {\\n        while (hull.size() >= 2 && cross(hull[hull.size() - 2], hull.back(), trees[i]) < 0) {\\n          hull.pop_back();\\n        }\\n        hull.push_back(trees[i]);\\n      }\\n      hull.pop_back();\\n      for (int i = n - 1; i >= 0; --i) {\\n        while (hull.size() >= 2 && cross(hull[hull.size() - 2], hull.back(), trees[i]) < 0) {\\n          hull.pop_back();\\n        }\\n        hull.push_back(trees[i]);\\n      }\\n      hull.pop_back();\\n      sort(hull.begin(), hull.end());\\n      hull.erase(unique(hull.begin(), hull.end()), hull.end());\\n      return hull;\\n    }\\nprivate:\\n    int cross(const vector<int>& a, const vector<int>& b, const vector<int>& c) {\\n      return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103320,
                "title": "python-am-chain-with-explanation",
                "content": "Based on the formula for the signed area of a triangle, we can find whether a triangle PQR has vertices which are counter-clockwise (sign 1), collinear (sign 0), or clockwise (sign -1).\\n\\nWe will now perform the AM-Chain algorithm for finding the lower and upper hulls which together form the convex hull of these points.\\n\\nTo find the lower hull of points, we process the points in sorted order.  Focus on the function ```drive```.  Our loop invariant is that we started the function ```drive``` with a lower hull, and we return a lower hull.  This answer must include the new right-most point ```r``` as it cannot be contained by some points below it.  During the while loop, whenever our last turn XYZ was clockwise, the middle point Y cannot be part of the lower hull, as it is contained by WXZ (where W is the point in the hull before X.)\\n\\nWe can do this process again with the points sorted in reverse to find the upper hull.  Both hulls combined is the total convex hull as desired.\\n```\\ndef outerTrees(self, A):\\n    def sign(p, q, r):\\n        return cmp((p.x - r.x)*(q.y - r.y), (p.y - r.y)*(q.x - r.x))\\n    \\n    def drive(hull, r):\\n        hull.append(r)\\n        while len(hull) >= 3 and sign(*hull[-3:]) < 0:\\n            hull.pop(-2)\\n        return hull\\n    \\n    A.sort(key = lambda p: (p.x, p.y))\\n    lower = reduce(drive, A, [])\\n    upper = reduce(drive, A[::-1], [])\\n    return list(set(lower + upper))\\n```",
                "solutionTags": [],
                "code": "```drive```\n```drive```\n```r```\n```\\ndef outerTrees(self, A):\\n    def sign(p, q, r):\\n        return cmp((p.x - r.x)*(q.y - r.y), (p.y - r.y)*(q.x - r.x))\\n    \\n    def drive(hull, r):\\n        hull.append(r)\\n        while len(hull) >= 3 and sign(*hull[-3:]) < 0:\\n            hull.pop(-2)\\n        return hull\\n    \\n    A.sort(key = lambda p: (p.x, p.y))\\n    lower = reduce(drive, A, [])\\n    upper = reduce(drive, A[::-1], [])\\n    return list(set(lower + upper))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2828698,
                "title": "java-using-stack-short-code-fast",
                "content": "**Please upvote the solution**\\n```\\nclass Solution {\\n    private int orientation(int[] p,int[] q,int[] r){\\n        return (r[1]-q[1]) * (q[0]-p[0]) - ( (q[1]-p[1]) * (r[0]-q[0])); \\n    }\\n    public int[][] outerTrees(int[][] trees) {\\n        Stack<int[]> upper= new Stack<>();\\n        Stack<int[]> lower= new Stack<>();\\n        Arrays.sort(trees,(p,q) ->\\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0] );\\n        for(int i=0;i<trees.length;i++){\\n            while(lower.size()>= 2 && orientation(lower.get(lower.size()-2),lower.get(lower.size()-1),trees[i]) >0){\\n                lower.pop();\\n            }\\n            while(upper.size()>= 2 && orientation(upper.get(upper.size()-2),upper.get(upper.size()-1),trees[i])<0){\\n                upper.pop();\\n            }\\n            lower.push(trees[i]);\\n            upper.push(trees[i]);\\n            \\n        }\\n        Set<int[]> res= new HashSet<>(lower);\\n        res.addAll(upper);\\n        return res.toArray(new int[res.size()][]);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int orientation(int[] p,int[] q,int[] r){\\n        return (r[1]-q[1]) * (q[0]-p[0]) - ( (q[1]-p[1]) * (r[0]-q[0])); \\n    }\\n    public int[][] outerTrees(int[][] trees) {\\n        Stack<int[]> upper= new Stack<>();\\n        Stack<int[]> lower= new Stack<>();\\n        Arrays.sort(trees,(p,q) ->\\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0] );\\n        for(int i=0;i<trees.length;i++){\\n            while(lower.size()>= 2 && orientation(lower.get(lower.size()-2),lower.get(lower.size()-1),trees[i]) >0){\\n                lower.pop();\\n            }\\n            while(upper.size()>= 2 && orientation(upper.get(upper.size()-2),upper.get(upper.size()-1),trees[i])<0){\\n                upper.pop();\\n            }\\n            lower.push(trees[i]);\\n            upper.push(trees[i]);\\n            \\n        }\\n        Set<int[]> res= new HashSet<>(lower);\\n        res.addAll(upper);\\n        return res.toArray(new int[res.size()][]);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829600,
                "title": "c-andrew-s-monotone-chain-method",
                "content": "There are a few different ways to compute the convex hulll. Time permitting I\\'ll add more different approaches.\\n\\n# Approach 1: Andrew\\'s monotone chain method\\nPlease read up on your favorite algo reference site why and how this works, I am not adding a link as the leedcode automatic moderation system is easly upset with any link to an external reference.\\n\\n```cpp\\n    static vector<vector<int>> outerTrees(vector<vector<int>>& points) {\\n        // Andrew\\'s monotone chain method.\\n        sort(begin(points), end(points), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\\n        });\\n        // left to right\\n        const int n = size(points);\\n        vector<vector<int>> ans;\\n        ans.reserve(n);\\n        for (int i = 0; i < n; ++i) {\\n            while (size(ans) > 1 && orientation(ans[size(ans) - 2], ans.back(), points[i]) < 0) \\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        // If all points are along a line, size(ans) is n after left to right procedure.\\n        if (size(ans) == n) return ans;\\n\\n        // right to left\\n        for (int i = n - 2; i >= 0; --i) {\\n            while (size(ans) > 1 && orientation(ans[size(ans) - 2], ans.back(), points[i]) < 0) \\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n\\n    static int orientation(const vector<int>& a, const vector<int>& b, const vector<int>& c) {\\n        return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0]);\\n    }\\n```\\n\\n**Complexity Analsysis**\\n  * Time Complexity: $$O(n \\\\log n)$$, because we need to sort ```points```.\\n  * Space Complexity: $$O(n)$$ for the answer.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static vector<vector<int>> outerTrees(vector<vector<int>>& points) {\\n        // Andrew\\'s monotone chain method.\\n        sort(begin(points), end(points), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\\n        });\\n        // left to right\\n        const int n = size(points);\\n        vector<vector<int>> ans;\\n        ans.reserve(n);\\n        for (int i = 0; i < n; ++i) {\\n            while (size(ans) > 1 && orientation(ans[size(ans) - 2], ans.back(), points[i]) < 0) \\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        // If all points are along a line, size(ans) is n after left to right procedure.\\n        if (size(ans) == n) return ans;\\n\\n        // right to left\\n        for (int i = n - 2; i >= 0; --i) {\\n            while (size(ans) > 1 && orientation(ans[size(ans) - 2], ans.back(), points[i]) < 0) \\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n\\n    static int orientation(const vector<int>& a, const vector<int>& b, const vector<int>& c) {\\n        return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0]);\\n    }\\n```\n```points```",
                "codeTag": "Unknown"
            },
            {
                "id": 1442042,
                "title": "erect-the-fence-convex-hull-jarvis-algorithm-full-explanation",
                "content": "***Jarvis Algorithm***\\n\\n*The idea of Jarvis\\u2019s Algorithm is simple,\\nWe start from the leftmost point (or point with minimum x coordinate value) and we keep wrapping points in counterclockwise direction.\\nThe big question is, given a point p as current point, how to find the next point in output?*\\n\\n*The idea is to use* ***cross-product*** *here. Next point is selected as the point that beats all other points at clockwise orientation, i.e., next point is q if q is the* ***rightmost point from our current point\\'s perspective.***\\n\\n___\\n\\n\\nIn this problem, we are trying to draw a boundary around all points such that all points are covered & boundary is minimum.\\n\\nWe start with the leftmost point as the boundary has to go through it and declare it as the starting point. The starting point will be our current tree for first iteration.\\n\\nNow, we have to find the next rightmost tree with respect to our current tree. Rightmost tree can be understood from the below image.\\n![image](https://assets.leetcode.com/users/images/9cd14676-8511-4c95-8026-77187dbd8322_1630658011.2310672.png)\\n*Here ***Tree 1*** is our current tree and then ***Tree 2*** will be the rightmost tree with respect to ***Tree 1****\\n\\n![image](https://assets.leetcode.com/users/images/abe6e16a-d88d-42d9-9806-78b286416466_1630658524.890353.png)\\n*Topview of trees*\\n.\\nFor finding which trees are to the right or left we use cross product.\\n\\nFor the current tree, we iterate till we find the rightmost tree.\\n\\nIn some cases, we may get more than one tree. In that situation, the trees will be collinear and the farthest tree is used as our next point. This is done by calculating the distance between the collinear points.\\n\\n**Time Complexity**: ```O(n*h), Where n = Total number of points, h = total number of points on boundary```\\n\\n\\n**Java Solution**\\n```\\n public int crossProduct(int[] p, int[] q, int[] r) {\\n\\treturn (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\\n}\\n\\npublic boolean distance(int[] p, int[] i, int[] q) {\\n\\tboolean a = i[0] >= p[0] && i[0] <= q[0] || i[0] <= p[0] && i[0] >= q[0];\\n\\tboolean b = i[1] >= p[1] && i[1] <= q[1] || i[1] <= p[1] && i[1] >= q[1];\\n\\treturn a && b;\\n}\\n\\npublic int[][] outerTrees(int[][] points) {\\n\\t//use set because this algorithm might try to insert duplicate point.\\n\\tHashSet<int[]> set = new HashSet<> ();\\n\\tif (points.length < 4) {\\n\\t\\tfor (int[] p: points)\\n\\t\\t\\tset.add(p);\\n\\t\\treturn set.toArray(new int[set.size()][]);\\n\\t}\\n\\tint left_most = 0;\\n\\tfor (int i = 0; i < points.length; i++)\\n\\t\\tif (points[i][0] < points[left_most][0])\\n\\t\\t\\tleft_most = i;\\n\\t\\t\\t\\n\\t//first find leftmost point to start the march.\\n\\tint p = left_most;\\n\\tdo {\\n\\t\\tint q = (p + 1) % points.length;\\n\\n\\t\\tfor (int i = 0; i < points.length; i++) {\\n\\t\\t\\t//if crossProduct < 0 it means points[i] is on right of current point -> nextPoint. Make him the next point.\\n\\t\\t\\tif (crossProduct(points[p], points[i], points[q]) < 0) {\\n\\t\\t\\t\\tq = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < points.length; i++) {\\n\\t\\t\\tif (i != p && i != q && crossProduct(points[p], points[i], points[q]) == 0 && distance(points[p], points[i], points[q])) {\\n\\t\\t\\t\\t// if more than one points are on the rightmost, then insert all the collinear points in the set\\n\\t\\t\\t\\tset.add(points[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tset.add(points[q]);\\n\\t\\tp = q;\\n\\t}\\n\\twhile (p != left_most);\\n\\treturn set.toArray(new int[set.size()][]);\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```O(n*h), Where n = Total number of points, h = total number of points on boundary```\n```\\n public int crossProduct(int[] p, int[] q, int[] r) {\\n\\treturn (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\\n}\\n\\npublic boolean distance(int[] p, int[] i, int[] q) {\\n\\tboolean a = i[0] >= p[0] && i[0] <= q[0] || i[0] <= p[0] && i[0] >= q[0];\\n\\tboolean b = i[1] >= p[1] && i[1] <= q[1] || i[1] <= p[1] && i[1] >= q[1];\\n\\treturn a && b;\\n}\\n\\npublic int[][] outerTrees(int[][] points) {\\n\\t//use set because this algorithm might try to insert duplicate point.\\n\\tHashSet<int[]> set = new HashSet<> ();\\n\\tif (points.length < 4) {\\n\\t\\tfor (int[] p: points)\\n\\t\\t\\tset.add(p);\\n\\t\\treturn set.toArray(new int[set.size()][]);\\n\\t}\\n\\tint left_most = 0;\\n\\tfor (int i = 0; i < points.length; i++)\\n\\t\\tif (points[i][0] < points[left_most][0])\\n\\t\\t\\tleft_most = i;\\n\\t\\t\\t\\n\\t//first find leftmost point to start the march.\\n\\tint p = left_most;\\n\\tdo {\\n\\t\\tint q = (p + 1) % points.length;\\n\\n\\t\\tfor (int i = 0; i < points.length; i++) {\\n\\t\\t\\t//if crossProduct < 0 it means points[i] is on right of current point -> nextPoint. Make him the next point.\\n\\t\\t\\tif (crossProduct(points[p], points[i], points[q]) < 0) {\\n\\t\\t\\t\\tq = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < points.length; i++) {\\n\\t\\t\\tif (i != p && i != q && crossProduct(points[p], points[i], points[q]) == 0 && distance(points[p], points[i], points[q])) {\\n\\t\\t\\t\\t// if more than one points are on the rightmost, then insert all the collinear points in the set\\n\\t\\t\\t\\tset.add(points[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tset.add(points[q]);\\n\\t\\tp = q;\\n\\t}\\n\\twhile (p != left_most);\\n\\treturn set.toArray(new int[set.size()][]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2753400,
                "title": "python-convex-hull-graham-s-scan-algorithm",
                "content": "```\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        def compare_slopes(p1, p2, p3):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            x3, y3 = p3\\n            return (y3-y2)*(x2-x1) - (y2-y1)*(x3-x2) \\n        upper, lower  = [], []\\n        for point in sorted(trees):\\n            while len(lower) >= 2 and compare_slopes(lower[-2], lower[-1], point) < 0: lower.pop()\\n            while len(upper) >= 2 and compare_slopes(upper[-2], upper[-1], point) > 0: upper.pop()\\n            lower.append(tuple(point))\\n            upper.append(tuple(point))   \\n        return list(set(lower + upper))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        def compare_slopes(p1, p2, p3):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            x3, y3 = p3\\n            return (y3-y2)*(x2-x1) - (y2-y1)*(x3-x2) \\n        upper, lower  = [], []\\n        for point in sorted(trees):\\n            while len(lower) >= 2 and compare_slopes(lower[-2], lower[-1], point) < 0: lower.pop()\\n            while len(upper) >= 2 and compare_slopes(upper[-2], upper[-1], point) > 0: upper.pop()\\n            lower.append(tuple(point))\\n            upper.append(tuple(point))   \\n        return list(set(lower + upper))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2828942,
                "title": "golang-monotone-chain",
                "content": "```go\\nfunc outerTrees(trees [][]int) [][]int {\\n\\tsortT(trees)\\n\\ttrees = build(trees)\\n\\n\\tout, set := [][]int{}, map[[2]int]bool{}\\n\\tfor _, t := range trees {\\n\\t\\tif k := [2]int{t[0], t[1]}; !set[k] {\\n\\t\\t\\tout = append(out, t)\\n\\t\\t\\tset[k] = true\\n\\t\\t}\\n\\t}\\n\\treturn out\\n}\\n\\nfunc build(points [][]int) [][]int {\\n\\tcross := func(o, a, b []int) int {\\n\\t\\treturn (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0])\\n\\t}\\n\\tt, b := [][]int{}, [][]int{}\\n\\tfor _, p := range points {\\n\\t\\tfor len(t) >= 2 && cross(t[len(t)-2], t[len(t)-1], p) > 0 {\\n\\t\\t\\tt = t[:len(t)-1]\\n\\t\\t}\\n\\t\\tfor len(b) >= 2 && cross(b[len(b)-2], b[len(b)-1], p) < 0 {\\n\\t\\t\\tb = b[:len(b)-1]\\n\\t\\t}\\n\\t\\tt, b = append(t, p), append(b, p)\\n\\t}\\n\\treturn append(t, b...)\\n}\\n\\nfunc sortT(trees [][]int) {\\n\\tsort.Slice(trees, func(i, j int) bool {\\n\\t\\tif trees[i][0] != trees[j][0] {\\n\\t\\t\\treturn trees[i][0] < trees[j][0]\\n\\t\\t}\\n\\t\\treturn trees[i][1] < trees[j][1]\\n\\t})\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc outerTrees(trees [][]int) [][]int {\\n\\tsortT(trees)\\n\\ttrees = build(trees)\\n\\n\\tout, set := [][]int{}, map[[2]int]bool{}\\n\\tfor _, t := range trees {\\n\\t\\tif k := [2]int{t[0], t[1]}; !set[k] {\\n\\t\\t\\tout = append(out, t)\\n\\t\\t\\tset[k] = true\\n\\t\\t}\\n\\t}\\n\\treturn out\\n}\\n\\nfunc build(points [][]int) [][]int {\\n\\tcross := func(o, a, b []int) int {\\n\\t\\treturn (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0])\\n\\t}\\n\\tt, b := [][]int{}, [][]int{}\\n\\tfor _, p := range points {\\n\\t\\tfor len(t) >= 2 && cross(t[len(t)-2], t[len(t)-1], p) > 0 {\\n\\t\\t\\tt = t[:len(t)-1]\\n\\t\\t}\\n\\t\\tfor len(b) >= 2 && cross(b[len(b)-2], b[len(b)-1], p) < 0 {\\n\\t\\t\\tb = b[:len(b)-1]\\n\\t\\t}\\n\\t\\tt, b = append(t, p), append(b, p)\\n\\t}\\n\\treturn append(t, b...)\\n}\\n\\nfunc sortT(trees [][]int) {\\n\\tsort.Slice(trees, func(i, j int) bool {\\n\\t\\tif trees[i][0] != trees[j][0] {\\n\\t\\t\\treturn trees[i][0] < trees[j][0]\\n\\t\\t}\\n\\t\\treturn trees[i][1] < trees[j][1]\\n\\t})\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103300,
                "title": "detailed-explanation-of-graham-scan-in-14-lines-python",
                "content": "Graham scan is an O(n log n) algorithm to find the convex hull of a set of points, which is exactly what this problem entails.  The idea is to start at one extreme point in the set (I chose the bottom most point on the left edge) and sweep in a circle.  Going counterclockwise is convenient due to the convention in trigonometry that polar angles in the unit circle increase as you move counterclockwise with respect to the positive x-axis, but this algorithm could potentially be performed sweeping clockwise as well.  As you perform this sweep, add the encountered points to the solution set.  After each addition check the last three points in the solution set.  If these points rotate in a direction opposite of the direct of your sweep, you know that the second to last point cannot be correct (assuming there are more than 3 points in your solution set).  What does it mean for points to rotate?  Imagine yourself starting at the first point, walking directly to the second point, and then directly to the third point.  The rotation of the points is the rotation you had to make at point 2 in order to face point 3.  It is easy to intuit that if you are walking a giant counterclockwise circle around the boundary of the points, then turning clockwise at any point puts you inside the absolute outside boundary (i.e. inside the convex hull).\\n\\nThere are two details to be sorted out:\\n\\n* How do we know what direction the last three points turn in?  Let's call them `p1`,`p2`, and `p3` in order of their appearance in the solution set.  Let the vector from `p1` to `p2` be `v1`; from `p2` to `p3`, be `v2`.  The cross product of `v1` and `v2` give the direction that points turn in.  If the cross product is negative, it is a right hand / clockwise turn; if it is positive, left hand / counterclockwise turn.  If the cross product is zero, the three points are colinear.\\n* How do we traverse the points in a circular fashion?  Sure you can import trigonometric functions to help you find the polar angle of the line formed between each point and the start.  Maybe a simpler, more intuitive approach, is to simply sort the points by the slope of the line made with the start point.  Incidentally, this is also why I chose the smallest left point in the set as my start.  It is now convenient  that all the slopes monotonically increase in the (-infinity, infinity] domain as you traverse counterclockwise from the negative verticle.  If two slopes are equivalent, take the point with the higher y-coordinate.  If two slopes are both zero, take the point with smaller x-coordinate.\\n\\n\\n    def outerTrees(self, points):\\n        # Computes the cross product of vectors p1p2 and p2p3\\n        # value of 0 means points are colinear; < 0, cw; > 0, ccw\\n        def cross(p1, p2, p3):\\n            return (p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x)\\n            \\n        # Computes slope of line between p1 and p2\\n        def slope(p1, p2):\\n            return 1.0*(p1.y-p2.y)/(p1.x-p2.x) if p1.x != p2.x else float('inf')\\n            \\n        # Find the smallest left point and remove it from points\\n        start = min(points, key=lambda p: (p.x, p.y))\\n        points.pop(points.index(start))\\n        \\n        # Sort points so that traversal is from start in a ccw circle.\\n        points.sort(key=lambda p: (slope(p, start), -p.y, p.x))\\n        \\n        # Add each point to the convex hull.\\n        # If the last 3 points make a cw turn, the second to last point is wrong. \\n        ans = [start]\\n        for p in points:\\n            ans.append(p)\\n            while len(ans) > 2 and cross(ans[-3], ans[-2], ans[-1]) < 0:\\n                ans.pop(-2)\\n        \\n        return ans",
                "solutionTags": [],
                "code": "Graham scan is an O(n log n) algorithm to find the convex hull of a set of points, which is exactly what this problem entails.  The idea is to start at one extreme point in the set (I chose the bottom most point on the left edge) and sweep in a circle.  Going counterclockwise is convenient due to the convention in trigonometry that polar angles in the unit circle increase as you move counterclockwise with respect to the positive x-axis, but this algorithm could potentially be performed sweeping clockwise as well.  As you perform this sweep, add the encountered points to the solution set.  After each addition check the last three points in the solution set.  If these points rotate in a direction opposite of the direct of your sweep, you know that the second to last point cannot be correct (assuming there are more than 3 points in your solution set).  What does it mean for points to rotate?  Imagine yourself starting at the first point, walking directly to the second point, and then directly to the third point.  The rotation of the points is the rotation you had to make at point 2 in order to face point 3.  It is easy to intuit that if you are walking a giant counterclockwise circle around the boundary of the points, then turning clockwise at any point puts you inside the absolute outside boundary (i.e. inside the convex hull).\\n\\nThere are two details to be sorted out:\\n\\n* How do we know what direction the last three points turn in?  Let's call them `p1`,`p2`, and `p3` in order of their appearance in the solution set.  Let the vector from `p1` to `p2` be `v1`; from `p2` to `p3`, be `v2`.  The cross product of `v1` and `v2` give the direction that points turn in.  If the cross product is negative, it is a right hand / clockwise turn; if it is positive, left hand / counterclockwise turn.  If the cross product is zero, the three points are colinear.\\n* How do we traverse the points in a circular fashion?  Sure you can import trigonometric functions to help you find the polar angle of the line formed between each point and the start.  Maybe a simpler, more intuitive approach, is to simply sort the points by the slope of the line made with the start point.  Incidentally, this is also why I chose the smallest left point in the set as my start.  It is now convenient  that all the slopes monotonically increase in the (-infinity, infinity] domain as you traverse counterclockwise from the negative verticle.  If two slopes are equivalent, take the point with the higher y-coordinate.  If two slopes are both zero, take the point with smaller x-coordinate.\\n\\n\\n    def outerTrees(self, points):\\n        # Computes the cross product of vectors p1p2 and p2p3\\n        # value of 0 means points are colinear; < 0, cw; > 0, ccw\\n        def cross(p1, p2, p3):\\n            return (p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x)\\n            \\n        # Computes slope of line between p1 and p2\\n        def slope(p1, p2):\\n            return 1.0*(p1.y-p2.y)/(p1.x-p2.x) if p1.x != p2.x else float('inf')\\n            \\n        # Find the smallest left point and remove it from points\\n        start = min(points, key=lambda p: (p.x, p.y))\\n        points.pop(points.index(start))\\n        \\n        # Sort points so that traversal is from start in a ccw circle.\\n        points.sort(key=lambda p: (slope(p, start), -p.y, p.x))\\n        \\n        # Add each point to the convex hull.\\n        # If the last 3 points make a cw turn, the second to last point is wrong. \\n        ans = [start]\\n        for p in points:\\n            ans.append(p)\\n            while len(ans) > 2 and cross(ans[-3], ans[-2], ans[-1]) < 0:\\n                ans.pop(-2)\\n        \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 103305,
                "title": "find-convex-hull-using-scipy-with-explanation",
                "content": "```scipy.spatial.ConvexHull(points)``` returns all points that form the hull.\\nIt helps a lot already. However, in this question, we need to return all points on the hull.\\nI write a funciton ```isHull(point, hull)``` to check if a point is on the hull.\\nWhen ConvexHull throws a exception, it means the points can not form a hull.\\nIn this case, I return all points.\\n\\n`````\\ndef outerTrees(self, points):\\n        from scipy.spatial import ConvexHull\\n        import numpy as np\\n\\n        def isHull(point, hull, tol=1e-12):\\n            return any((abs(np.dot(eq[:-1], point) + eq[-1]) < tol) for eq in hull.equations)\\n        try:\\n            hull = ConvexHull([(p.x, p.y) for p in points])\\n            return [p for p in points if isHull((p.x, p.y), hull)]\\n        except:\\n            return points",
                "solutionTags": [],
                "code": "```scipy.spatial.ConvexHull(points)```\n```isHull(point, hull)```",
                "codeTag": "Unknown"
            },
            {
                "id": 103301,
                "title": "share-my-youtube-solution",
                "content": "This solution is based on Jarvis march gift wrapping algorithm.\\n\\nhttps://www.youtube.com/watch?v=Vu84lmMzP2o\\n\\nLink to the code is at https://github.com/mission-peace/interview/blob/master/src/com/interview/geometry/JarvisMarchConvexHull.java",
                "solutionTags": [],
                "code": "This solution is based on Jarvis march gift wrapping algorithm.\\n\\nhttps://www.youtube.com/watch?v=Vu84lmMzP2o\\n\\nLink to the code is at https://github.com/mission-peace/interview/blob/master/src/com/interview/geometry/JarvisMarchConvexHull.java",
                "codeTag": "Unknown"
            },
            {
                "id": 2828854,
                "title": "golang-using-stack",
                "content": "```\\nfunc outerTrees(trees [][]int) [][]int {\\n\\tif len(trees) == 1 {\\n\\t\\treturn trees\\n\\t}\\n\\n\\tupper, lower := make([][]int, 0), make([][]int, 0)\\n\\n\\tsort.Slice(trees, func(q, p int) bool {\\n\\t\\tif trees[q][0]-trees[p][0] == 0 {\\n\\t\\t\\treturn trees[q][1] < trees[p][1]\\n\\t\\t}\\n\\n\\t\\treturn trees[q][0] < trees[p][0]\\n\\t})\\n\\n\\tfor i := 0; i < len(trees); i++ {\\n\\t\\tfor len(lower) >= 2 && orientation(lower[len(lower)-2], lower[len(lower)-1], trees[i]) > 0 {\\n\\t\\t\\tlower = lower[:len(lower)-1]\\n\\t\\t}\\n\\t\\tfor len(upper) >= 2 && orientation(upper[len(upper)-2], upper[len(upper)-1], trees[i]) < 0 {\\n\\t\\t\\tupper = upper[:len(upper)-1]\\n\\t\\t}\\n\\t\\tlower = append(lower, trees[i])\\n\\t\\tupper = append(upper, trees[i])\\n\\t}\\n\\n\\tresult := make([][]int, 0)\\n\\nloop:\\n\\tfor _, set := range append(upper, lower...) {\\n\\t\\tfor _, res := range result {\\n\\t\\t\\tif set[0] == res[0] && set[1] == res[1] {\\n\\t\\t\\t\\tcontinue loop\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult = append(result, set)\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc orientation(p, q, r []int) int {\\n\\treturn (r[1]-q[1])*(q[0]-p[0]) - (q[1]-p[1])*(r[0]-q[0])\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc outerTrees(trees [][]int) [][]int {\\n\\tif len(trees) == 1 {\\n\\t\\treturn trees\\n\\t}\\n\\n\\tupper, lower := make([][]int, 0), make([][]int, 0)\\n\\n\\tsort.Slice(trees, func(q, p int) bool {\\n\\t\\tif trees[q][0]-trees[p][0] == 0 {\\n\\t\\t\\treturn trees[q][1] < trees[p][1]\\n\\t\\t}\\n\\n\\t\\treturn trees[q][0] < trees[p][0]\\n\\t})\\n\\n\\tfor i := 0; i < len(trees); i++ {\\n\\t\\tfor len(lower) >= 2 && orientation(lower[len(lower)-2], lower[len(lower)-1], trees[i]) > 0 {\\n\\t\\t\\tlower = lower[:len(lower)-1]\\n\\t\\t}\\n\\t\\tfor len(upper) >= 2 && orientation(upper[len(upper)-2], upper[len(upper)-1], trees[i]) < 0 {\\n\\t\\t\\tupper = upper[:len(upper)-1]\\n\\t\\t}\\n\\t\\tlower = append(lower, trees[i])\\n\\t\\tupper = append(upper, trees[i])\\n\\t}\\n\\n\\tresult := make([][]int, 0)\\n\\nloop:\\n\\tfor _, set := range append(upper, lower...) {\\n\\t\\tfor _, res := range result {\\n\\t\\t\\tif set[0] == res[0] && set[1] == res[1] {\\n\\t\\t\\t\\tcontinue loop\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult = append(result, set)\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc orientation(p, q, r []int) int {\\n\\treturn (r[1]-q[1])*(q[0]-p[0]) - (q[1]-p[1])*(r[0]-q[0])\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2828763,
                "title": "implementation-using-c",
                "content": "```\\npublic class Solution {\\n    public int[][] OuterTrees(int[][] trees) {\\n        if (trees.Length <= 1) {\\n            return trees;\\n        }\\n        int[] bm = BottomLeft(trees);\\n        Array.Sort(trees, (int[] p, int[] q) => {\\n            double diff = Orientation(bm, p, q) - Orientation(bm, q, p);\\n            if (diff == 0) {\\n                return Distance(bm, p) - Distance(bm, q);\\n            } else {\\n                return diff > 0 ? 1 : -1;\\n            }\\n        });\\n        int i = trees.Length - 1;\\n        while (i >= 0 && Orientation(bm, trees[trees.Length - 1], trees[i]) == 0) {\\n            i--;\\n        }\\n        for (int l = i + 1, h = trees.Length - 1; l < h; l++, h--) {\\n            int[] temp = trees[l];\\n            trees[l] = trees[h];\\n            trees[h] = temp;\\n        }\\n        var stack = new Stack<int[]>();\\n        stack.Push(trees[0]);\\n        stack.Push(trees[1]);\\n        for (int j = 2; j < trees.Length; j++) {\\n            int[] top = stack.Pop();\\n            while (Orientation(stack.Peek(), top, trees[j]) > 0) {\\n                top = stack.Pop();\\n            }\\n            stack.Push(top);\\n            stack.Push(trees[j]);\\n        }\\n        var result = new List<int[]>();\\n        while (stack.Count > 0) {\\n            result.Add(stack.Pop());\\n        }\\n        return result.ToArray();        \\n    }\\n\\n    public int Orientation(int[] p, int[] q, int[] r) {\\n        return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\\n    }\\n    public int Distance(int[] p, int[] q) {\\n        return (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\\n    }\\n\\n    private static int[] BottomLeft(int[][] trees) {\\n        int[] bottomLeft = trees[0];\\n        foreach (int[] p in trees) {\\n            if (p[1] < bottomLeft[1]) {\\n                bottomLeft = p;\\n            }\\n        }\\n        return bottomLeft;\\n    }\\n      \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] OuterTrees(int[][] trees) {\\n        if (trees.Length <= 1) {\\n            return trees;\\n        }\\n        int[] bm = BottomLeft(trees);\\n        Array.Sort(trees, (int[] p, int[] q) => {\\n            double diff = Orientation(bm, p, q) - Orientation(bm, q, p);\\n            if (diff == 0) {\\n                return Distance(bm, p) - Distance(bm, q);\\n            } else {\\n                return diff > 0 ? 1 : -1;\\n            }\\n        });\\n        int i = trees.Length - 1;\\n        while (i >= 0 && Orientation(bm, trees[trees.Length - 1], trees[i]) == 0) {\\n            i--;\\n        }\\n        for (int l = i + 1, h = trees.Length - 1; l < h; l++, h--) {\\n            int[] temp = trees[l];\\n            trees[l] = trees[h];\\n            trees[h] = temp;\\n        }\\n        var stack = new Stack<int[]>();\\n        stack.Push(trees[0]);\\n        stack.Push(trees[1]);\\n        for (int j = 2; j < trees.Length; j++) {\\n            int[] top = stack.Pop();\\n            while (Orientation(stack.Peek(), top, trees[j]) > 0) {\\n                top = stack.Pop();\\n            }\\n            stack.Push(top);\\n            stack.Push(trees[j]);\\n        }\\n        var result = new List<int[]>();\\n        while (stack.Count > 0) {\\n            result.Add(stack.Pop());\\n        }\\n        return result.ToArray();        \\n    }\\n\\n    public int Orientation(int[] p, int[] q, int[] r) {\\n        return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\\n    }\\n    public int Distance(int[] p, int[] q) {\\n        return (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\\n    }\\n\\n    private static int[] BottomLeft(int[][] trees) {\\n        int[] bottomLeft = trees[0];\\n        foreach (int[] p in trees) {\\n            if (p[1] < bottomLeft[1]) {\\n                bottomLeft = p;\\n            }\\n        }\\n        return bottomLeft;\\n    }\\n      \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616715,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\n    public:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& points) {\\n        // Andrew\\'s monotone chain method\\n        int n = points.size();\\n        vector<vector<int>> ans;\\n        sort(points.begin(), points.end(), mycompare);\\n        // left to right\\n        for (int i = 0; i < n; ++i) {\\n            while (ans.size() > 1 && orientation(ans[ans.size()-2], ans.back(), points[i]) < 0) \\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        // if all points along a line, ans.size() is n after left to right procedure\\n        if (ans.size() == n) return ans;\\n        // right to left\\n        for (int i = n-2; i >= 0; --i) {\\n            while (ans.size() > 1 && orientation(ans[ans.size()-2], ans.back(), points[i]) < 0) \\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n    static bool mycompare(vector<int>& a, vector<int>& b) {\\n        return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\\n    }\\n    int orientation(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        return (b[0] - a[0])*(c[1] - b[1]) - (b[1] - a[1])*(c[0] - b[0]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& points) {\\n        // Andrew\\'s monotone chain method\\n        int n = points.size();\\n        vector<vector<int>> ans;\\n        sort(points.begin(), points.end(), mycompare);\\n        // left to right\\n        for (int i = 0; i < n; ++i) {\\n            while (ans.size() > 1 && orientation(ans[ans.size()-2], ans.back(), points[i]) < 0) \\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        // if all points along a line, ans.size() is n after left to right procedure\\n        if (ans.size() == n) return ans;\\n        // right to left\\n        for (int i = n-2; i >= 0; --i) {\\n            while (ans.size() > 1 && orientation(ans[ans.size()-2], ans.back(), points[i]) < 0) \\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n    static bool mycompare(vector<int>& a, vector<int>& b) {\\n        return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\\n    }\\n    int orientation(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        return (b[0] - a[0])*(c[1] - b[1]) - (b[1] - a[1])*(c[0] - b[0]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828951,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isClockwiseTurn(vector<int> &a, vector<int> &b, vector<int> &c) {\\n        int xa = a[0], xb = b[0], xc = c[0];\\n        int ya = a[1], yb = b[1], yc = c[1];\\n        bool isConvex = (((yc - yb) * (xb - xa)) - ((yb - ya) * (xc - xb))) >= 0;\\n        return isConvex;\\n    }\\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        vector<vector<int>> convexHull;\\n        int n = trees.size();\\n       \\n        auto cmp = [&](vector<int> &a, vector<int> &b) {\\n            if(a[0] < b[0]) {\\n                return true;\\n            } else if (a[0] == b[0] && a[1] < b[1]) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        \\n        sort(trees.begin(), trees.end(), cmp);\\n        \\n        for(int i = 0; i < n; i++) {\\n            while(convexHull.size() > 1 && !isClockwiseTurn(convexHull[convexHull.size() - 2], convexHull[convexHull.size() - 1], trees[i])) {\\n                convexHull.pop_back();\\n            }\\n            convexHull.push_back(trees[i]);\\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            while(convexHull.size() > 1 && !isClockwiseTurn(convexHull[convexHull.size() - 2], convexHull[convexHull.size() - 1], trees[i])) {\\n                convexHull.pop_back();\\n            }\\n            convexHull.push_back(trees[i]);\\n        }\\n        convexHull.pop_back(); \\n        sort(convexHull.begin(), convexHull.end(), cmp);\\n        convexHull.erase(unique(convexHull.begin(), convexHull.end()), convexHull.end());\\n        return convexHull;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isClockwiseTurn(vector<int> &a, vector<int> &b, vector<int> &c) {\\n        int xa = a[0], xb = b[0], xc = c[0];\\n        int ya = a[1], yb = b[1], yc = c[1];\\n        bool isConvex = (((yc - yb) * (xb - xa)) - ((yb - ya) * (xc - xb))) >= 0;\\n        return isConvex;\\n    }\\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        vector<vector<int>> convexHull;\\n        int n = trees.size();\\n       \\n        auto cmp = [&](vector<int> &a, vector<int> &b) {\\n            if(a[0] < b[0]) {\\n                return true;\\n            } else if (a[0] == b[0] && a[1] < b[1]) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        \\n        sort(trees.begin(), trees.end(), cmp);\\n        \\n        for(int i = 0; i < n; i++) {\\n            while(convexHull.size() > 1 && !isClockwiseTurn(convexHull[convexHull.size() - 2], convexHull[convexHull.size() - 1], trees[i])) {\\n                convexHull.pop_back();\\n            }\\n            convexHull.push_back(trees[i]);\\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            while(convexHull.size() > 1 && !isClockwiseTurn(convexHull[convexHull.size() - 2], convexHull[convexHull.size() - 1], trees[i])) {\\n                convexHull.pop_back();\\n            }\\n            convexHull.push_back(trees[i]);\\n        }\\n        convexHull.pop_back(); \\n        sort(convexHull.begin(), convexHull.end(), cmp);\\n        convexHull.erase(unique(convexHull.begin(), convexHull.end()), convexHull.end());\\n        return convexHull;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828945,
                "title": "rust-monotone-chain",
                "content": "\\n```\\nimpl Solution {\\n    pub fn outer_trees(mut trees: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        fn orientation(p: &Vec<i32>, q: &Vec<i32>, r: &Vec<i32>) -> bool {\\n            (q[0]-p[0])*(r[1]-q[1])-(q[1]-p[1])*(r[0]-q[0]) > 0\\n        }\\n        trees.sort_unstable();\\n        let mut l2r = Vec::with_capacity(trees.len());\\n        for v in trees.iter() {\\n            l2r.push((*v).clone());\\n            while l2r.len() >= 3 && orientation(&l2r[l2r.len() - 3],&l2r[l2r.len() - 2],&l2r[l2r.len() - 1]) {\\n                l2r.remove(l2r.len() - 2);\\n            }\\n        }\\n        trees.reverse();\\n        let mut r2l = Vec::with_capacity(trees.len());\\n        for v in trees.iter() {\\n            r2l.push((*v).clone());\\n            while r2l.len() >= 3 && orientation(&r2l[r2l.len() - 3],&r2l[r2l.len() - 2],&r2l[r2l.len() - 1]) {\\n                r2l.remove(r2l.len() - 2);\\n            }\\n        }\\n        let mut ans = l2r.into_iter().chain(r2l.into_iter()).collect::<Vec<Vec<i32>>>();\\n        ans.sort_unstable();\\n        ans.dedup();\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn outer_trees(mut trees: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        fn orientation(p: &Vec<i32>, q: &Vec<i32>, r: &Vec<i32>) -> bool {\\n            (q[0]-p[0])*(r[1]-q[1])-(q[1]-p[1])*(r[0]-q[0]) > 0\\n        }\\n        trees.sort_unstable();\\n        let mut l2r = Vec::with_capacity(trees.len());\\n        for v in trees.iter() {\\n            l2r.push((*v).clone());\\n            while l2r.len() >= 3 && orientation(&l2r[l2r.len() - 3],&l2r[l2r.len() - 2],&l2r[l2r.len() - 1]) {\\n                l2r.remove(l2r.len() - 2);\\n            }\\n        }\\n        trees.reverse();\\n        let mut r2l = Vec::with_capacity(trees.len());\\n        for v in trees.iter() {\\n            r2l.push((*v).clone());\\n            while r2l.len() >= 3 && orientation(&r2l[r2l.len() - 3],&r2l[r2l.len() - 2],&r2l[r2l.len() - 1]) {\\n                r2l.remove(r2l.len() - 2);\\n            }\\n        }\\n        let mut ans = l2r.into_iter().chain(r2l.into_iter()).collect::<Vec<Vec<i32>>>();\\n        ans.sort_unstable();\\n        ans.dedup();\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103307,
                "title": "c-graham-scan-monotone-chain-dealing-with-collinear-cases",
                "content": "I implemented two different approach: 1.Graham Scan; 2. Andrew's monotone chain.\\n\\nFor the Graham Scan, here is the modified implementation discussed in the following link:\\nhttp://www.geeksforgeeks.org/convex-hull-set-2-graham-scan/\\nThe modified part is to deal with the degenerate case. As the original algorithm outputs the extreme points instead of vertices (the difference is that a vertex can lie in between two extreme points), I added the logic for output all the vertices. \\nThere are two parts:\\n1. During the Graham scan after the radial sorting, we don't pop the points if p[i], top, next_to_top are collinear;\\n2. A special case is that in the largest radial angle, there may be several points lies on a line, we need to reverse the order of these points. In the initial radial sorting, a tie is broke by closer one comes first. But for the points in the largest radial angle, the closer one comes last.\\n```\\nclass Solution {\\npublic:\\n    // A utility function to return square of distance\\n    // between p1 and p2\\n    static int distSq(Point p1, Point p2) {\\n        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\\n    }\\n \\n    // To find orientation of ordered triplet (p, q, r).\\n    // The function returns following values\\n    // 0 --> p, q and r are colinear\\n    // 1 --> Clockwise\\n    // 2 --> Counterclockwise\\n    static int orientation(Point p, Point q, Point r) {\\n        int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\\n        if (val == 0) {\\n            return 0;  // colinear\\n        }\\n        return (val > 0) ? 1 : 2; // clock or counterclock wise\\n    }\\n\\n    // A comparison function object using specified reference point\\n    struct pointsComparator {\\n        Point p0;\\n        bool operator() (const Point& p1, const Point& p2) {\\n \\n            // Find orientation\\n            int o = orientation(p0, p1, p2);\\n            if (o == 0) {\\n                return distSq(p0, p2) >= distSq(p0, p1);\\n            }\\n            return o == 2;\\n        }\\n        pointsComparator(Point p) : p0(p) {}\\n    };\\n    \\n    // Prints convex hull of a set of n points.\\n    vector<Point> outerTrees(vector<Point> points) {\\n        int n = points.size();\\n        if (n <= 3) {\\n            return points;\\n        }\\n        // Find the bottommost point\\n        int ymin = points[0].y, min = 0;\\n        for (int i = 1; i < n; i++) {\\n            int y = points[i].y;\\n            // Pick the bottom-most or chose the left most point in case of tie\\n            if ((y < ymin) || (ymin == y && points[i].x < points[min].x)) {\\n                ymin = points[i].y, min = i;\\n            }\\n        }\\n \\n        // Place the bottom-most point at first position\\n        Point temp = points[0];\\n        points[0] = points[min];\\n        points[min] = temp;\\n        \\n        // Sort n-1 points with respect to the first point.\\n        // A point p1 comes before p2 in sorted ouput \\n        // if p2 has larger polar angle (in counterclockwise direction) than p1\\n        // In the tied case, the one has smaller distance from p0 comes first\\n        Point p0 = points[0];\\n        sort(points.begin(), points.end(), pointsComparator(p0));\\n        //As we need to output all the vertices instead of extreme points\\n        //We need to sort the points with the same largest polar angle w.r.p. p0 in another way to break tie\\n        //Closer one comes last\\n        Point pn = points.back();        \\n        if (orientation(p0, points[1], pn) != 0) {\\n            int idx = n-1;\\n            while (orientation(p0, points[idx], pn) == 0) {\\n                idx--;\\n            }\\n            reverse(points.begin() + idx + 1, points.end());\\n        }\\n \\n        // Create an empty stack and push first three points to it.\\n        vector<Point> vertices;\\n        vertices.push_back(points[0]);\\n        vertices.push_back(points[1]);\\n        vertices.push_back(points[2]);\\n        // Process remaining n-3 points\\n        for (int i = 3; i < n; i++) {\\n            // Keep removing top while the angle formed by\\n            // points next-to-top, top, and points[i] makes a right (in clockwise) turn\\n            while (orientation(vertices[vertices.size() - 2], vertices.back(), points[i]) == 1) {\\n                vertices.pop_back();\\n            }\\n            vertices.push_back(points[i]);\\n        }\\n        return vertices;\\n    }\\n};\\n```\\n\\nFor the Andrew's monotone chain method, the only part you need to take care is one degenerate case: all the vertices lie on a single line. The others is basically two Graham Scans for upper hull and lower hull. Of course, we don't pop the top point in the stack if three points are collinear.\\n\\n```\\nclass Solution {\\npublic:\\n    static bool pointCompare(const Point& a, const Point& b) {\\n        //Sort the points by x-coordinates, break a tie by y-coordinate\\n        return (a.x < b.x) || ((a.x == b.x) && (a.y < b.y));\\n    }\\n    \\n    bool isEqual(const Point& a, const Point& b) {\\n        return (a.x == b.x) && (a.y == b.y);    \\n    }\\n    \\n    int crossProduct(const Point& a, const Point& b, const Point& c) {\\n        // > 0 if a,b,c forms a counter clockwise turn\\n        // < 0 if a,b,c forms a clockwise turn\\n        // = 0 if a,b,c are collinear\\n        return (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);\\n    }\\n    \\n    vector<Point> outerTrees(vector<Point>& points) {\\n        //Sort the points\\n        sort(points.begin(), points.end(), pointCompare);\\n        vector<Point> upper;\\n        vector<Point> lower;\\n        //Find upper hull, in the dereasing order of x-coordinate\\n        for (int i = points.size() - 1; i >= 0; --i) {\\n            //Pop the top point if next_to_top, top, points[i] forms a right turn (in clockwise turn)\\n            while ((upper.size() > 1) \\n                && (crossProduct(upper[upper.size() - 2], upper[upper.size() - 1], points[i]) < 0)) {\\n                upper.pop_back();\\n            }\\n            upper.push_back(points[i]);\\n        }\\n        //Find lower hull, in the increasing order of x-coordinate \\n        for (int i=0; i<points.size(); i++) {\\n            //Pop the top point if next_to_top, top, points[i] forms a right turn (in clockwise turn)\\n            while ((lower.size() > 1) \\n                && (crossProduct(lower[lower.size() - 2], lower[lower.size() - 1], points[i]) < 0)) {\\n                lower.pop_back();\\n            }\\n            lower.push_back(points[i]);            \\n        }\\n        //Check the degenerate case if the convex hull is a line\\n        //In this case, lower == upper, we only need to check if upper[1] == lower[lower.size() - 2]\\n        if ((points.size() == 1) || (isEqual(upper[1],lower[lower.size() - 2]))) {\\n            return vector<Point>(upper.begin(), upper.end());\\n        }\\n        //In non-degenerate case, remove the starting point for both hulls\\n        //The right most one and the left most one is duplicated in both hulls\\n        vector<Point> vertices(upper.begin() + 1, upper.end());\\n        vertices.insert(vertices.end(), lower.begin() + 1, lower.end());\\n        return vertices;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // A utility function to return square of distance\\n    // between p1 and p2\\n    static int distSq(Point p1, Point p2) {\\n        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\\n    }\\n \\n    // To find orientation of ordered triplet (p, q, r).\\n    // The function returns following values\\n    // 0 --> p, q and r are colinear\\n    // 1 --> Clockwise\\n    // 2 --> Counterclockwise\\n    static int orientation(Point p, Point q, Point r) {\\n        int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\\n        if (val == 0) {\\n            return 0;  // colinear\\n        }\\n        return (val > 0) ? 1 : 2; // clock or counterclock wise\\n    }\\n\\n    // A comparison function object using specified reference point\\n    struct pointsComparator {\\n        Point p0;\\n        bool operator() (const Point& p1, const Point& p2) {\\n \\n            // Find orientation\\n            int o = orientation(p0, p1, p2);\\n            if (o == 0) {\\n                return distSq(p0, p2) >= distSq(p0, p1);\\n            }\\n            return o == 2;\\n        }\\n        pointsComparator(Point p) : p0(p) {}\\n    };\\n    \\n    // Prints convex hull of a set of n points.\\n    vector<Point> outerTrees(vector<Point> points) {\\n        int n = points.size();\\n        if (n <= 3) {\\n            return points;\\n        }\\n        // Find the bottommost point\\n        int ymin = points[0].y, min = 0;\\n        for (int i = 1; i < n; i++) {\\n            int y = points[i].y;\\n            // Pick the bottom-most or chose the left most point in case of tie\\n            if ((y < ymin) || (ymin == y && points[i].x < points[min].x)) {\\n                ymin = points[i].y, min = i;\\n            }\\n        }\\n \\n        // Place the bottom-most point at first position\\n        Point temp = points[0];\\n        points[0] = points[min];\\n        points[min] = temp;\\n        \\n        // Sort n-1 points with respect to the first point.\\n        // A point p1 comes before p2 in sorted ouput \\n        // if p2 has larger polar angle (in counterclockwise direction) than p1\\n        // In the tied case, the one has smaller distance from p0 comes first\\n        Point p0 = points[0];\\n        sort(points.begin(), points.end(), pointsComparator(p0));\\n        //As we need to output all the vertices instead of extreme points\\n        //We need to sort the points with the same largest polar angle w.r.p. p0 in another way to break tie\\n        //Closer one comes last\\n        Point pn = points.back();        \\n        if (orientation(p0, points[1], pn) != 0) {\\n            int idx = n-1;\\n            while (orientation(p0, points[idx], pn) == 0) {\\n                idx--;\\n            }\\n            reverse(points.begin() + idx + 1, points.end());\\n        }\\n \\n        // Create an empty stack and push first three points to it.\\n        vector<Point> vertices;\\n        vertices.push_back(points[0]);\\n        vertices.push_back(points[1]);\\n        vertices.push_back(points[2]);\\n        // Process remaining n-3 points\\n        for (int i = 3; i < n; i++) {\\n            // Keep removing top while the angle formed by\\n            // points next-to-top, top, and points[i] makes a right (in clockwise) turn\\n            while (orientation(vertices[vertices.size() - 2], vertices.back(), points[i]) == 1) {\\n                vertices.pop_back();\\n            }\\n            vertices.push_back(points[i]);\\n        }\\n        return vertices;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    static bool pointCompare(const Point& a, const Point& b) {\\n        //Sort the points by x-coordinates, break a tie by y-coordinate\\n        return (a.x < b.x) || ((a.x == b.x) && (a.y < b.y));\\n    }\\n    \\n    bool isEqual(const Point& a, const Point& b) {\\n        return (a.x == b.x) && (a.y == b.y);    \\n    }\\n    \\n    int crossProduct(const Point& a, const Point& b, const Point& c) {\\n        // > 0 if a,b,c forms a counter clockwise turn\\n        // < 0 if a,b,c forms a clockwise turn\\n        // = 0 if a,b,c are collinear\\n        return (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);\\n    }\\n    \\n    vector<Point> outerTrees(vector<Point>& points) {\\n        //Sort the points\\n        sort(points.begin(), points.end(), pointCompare);\\n        vector<Point> upper;\\n        vector<Point> lower;\\n        //Find upper hull, in the dereasing order of x-coordinate\\n        for (int i = points.size() - 1; i >= 0; --i) {\\n            //Pop the top point if next_to_top, top, points[i] forms a right turn (in clockwise turn)\\n            while ((upper.size() > 1) \\n                && (crossProduct(upper[upper.size() - 2], upper[upper.size() - 1], points[i]) < 0)) {\\n                upper.pop_back();\\n            }\\n            upper.push_back(points[i]);\\n        }\\n        //Find lower hull, in the increasing order of x-coordinate \\n        for (int i=0; i<points.size(); i++) {\\n            //Pop the top point if next_to_top, top, points[i] forms a right turn (in clockwise turn)\\n            while ((lower.size() > 1) \\n                && (crossProduct(lower[lower.size() - 2], lower[lower.size() - 1], points[i]) < 0)) {\\n                lower.pop_back();\\n            }\\n            lower.push_back(points[i]);            \\n        }\\n        //Check the degenerate case if the convex hull is a line\\n        //In this case, lower == upper, we only need to check if upper[1] == lower[lower.size() - 2]\\n        if ((points.size() == 1) || (isEqual(upper[1],lower[lower.size() - 2]))) {\\n            return vector<Point>(upper.begin(), upper.end());\\n        }\\n        //In non-degenerate case, remove the starting point for both hulls\\n        //The right most one and the left most one is duplicated in both hulls\\n        vector<Point> vertices(upper.begin() + 1, upper.end());\\n        vertices.insert(vertices.end(), lower.begin() + 1, lower.end());\\n        return vertices;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442803,
                "title": "detailed-explaination-c-convex-hull",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nstruct point {\\n\\tint x, y;\\n\\n\\tbool operator < (point &O) {\\n\\t\\tif (O.x == x) return y < O.y;  // if x pts are same then compare according to y\\n\\t\\telse return x < O.x;\\n\\t}\\n\\tbool operator == (point &O) {  // operator overloading for unique() func\\n\\t\\treturn (x == O.x && y == O.y);\\n\\t}\\n};\\n\\n// if a, b, c are 3 three points then condition for clockwise angle is\\n// (b.x-a.x)/(b.y-a.y) > (c.x-b.x)/(c.y-b.y)\\nbool cw(point a, point b, point c) {  // clock wise\\n\\n\\treturn a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) > 0;\\n}\\n\\nbool ccw(point a, point b, point c) {   // counter clock wise\\n\\n\\treturn a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) < 0;\\n}\\n\\nvoid convec_hull(vector<point> &p) {\\n   // if there are atmost 2 pts\\n\\tif (p.size() <= 2) return;\\n\\n\\tsort(p.begin(), p.end());\\n\\n\\tint i, n = p.size();\\n\\n\\tpoint p1 = p[0], p2 = p[n - 1];\\n\\t// p1 is bottom left point and p2 is top right point\\n\\tvector<point> up, down;\\n\\tup.push_back(p1);\\n\\tdown.push_back(p1);\\n    \\n\\t// divide the all pts in 2 parts - lower half and upper half of p1 and p2\\n\\tfor (i = 1; i < n; i++) {\\n\\t\\t// now check whether my current p is in lower half\\n\\t\\t// or upper half\\n\\n\\t\\tif (i == n - 1 || !ccw(p1, p[i], p2)) { // check if not counter clock wise (it consider both clock wise and collinear pts)\\n\\t\\t\\twhile (up.size() >= 2 && ccw(up[up.size() - 2], up[up.size() - 1], p[i])) {  // check angle b/w (2nd last pt, last pt, current pt) from up vector\\n\\t\\t\\t\\tup.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\tup.push_back(p[i]);\\n\\t\\t}\\n\\t\\tif (i == n - 1 || !cw(p1, p[i], p2)) { // check if not clock wise  (it consider both counter clock wise and collinear pts)\\n\\t\\t\\twhile (down.size() >= 2 && cw(down[down.size() - 2], down[down.size() - 1], p[i])) { // check angle b/w (2nd last pt, last pt, current pt) from down vector\\n\\t\\t\\t\\tdown.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\tdown.push_back(p[i]);\\n\\t\\t}\\n\\t}\\n\\n\\tp.clear();\\n\\tfor (i = 0; i < up.size(); i++) {\\n\\t\\tp.push_back(up[i]);\\n\\t}\\n\\n\\tfor (i = 0; i < down.size(); i++) {\\n\\t\\tp.push_back(down[i]);\\n\\t}\\n\\n\\tsort(p.begin(), p.end());\\n\\tp.resize(unique(p.begin(), p.end()) - p.begin());  // take only unique values\\n}\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        int n = trees.size();\\n        vector<point> p(n);\\n\\n\\tfor (int i = 0; i < trees.size(); i++) {\\n\\t\\t p[i].x = trees[i][0];\\n         p[i].y = trees[i][1];\\n\\t}\\n        \\n\\tconvec_hull(p);\\n        vector<vector<int>> ans;\\n        \\n        for(auto j: p){\\n            ans.push_back({j.x,j.y});\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nstruct point {\\n\\tint x, y;\\n\\n\\tbool operator < (point &O) {\\n\\t\\tif (O.x == x) return y < O.y;  // if x pts are same then compare according to y\\n\\t\\telse return x < O.x;\\n\\t}\\n\\tbool operator == (point &O) {  // operator overloading for unique() func\\n\\t\\treturn (x == O.x && y == O.y);\\n\\t}\\n};\\n\\n// if a, b, c are 3 three points then condition for clockwise angle is\\n// (b.x-a.x)/(b.y-a.y) > (c.x-b.x)/(c.y-b.y)\\nbool cw(point a, point b, point c) {  // clock wise\\n\\n\\treturn a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) > 0;\\n}\\n\\nbool ccw(point a, point b, point c) {   // counter clock wise\\n\\n\\treturn a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) < 0;\\n}\\n\\nvoid convec_hull(vector<point> &p) {\\n   // if there are atmost 2 pts\\n\\tif (p.size() <= 2) return;\\n\\n\\tsort(p.begin(), p.end());\\n\\n\\tint i, n = p.size();\\n\\n\\tpoint p1 = p[0], p2 = p[n - 1];\\n\\t// p1 is bottom left point and p2 is top right point\\n\\tvector<point> up, down;\\n\\tup.push_back(p1);\\n\\tdown.push_back(p1);\\n    \\n\\t// divide the all pts in 2 parts - lower half and upper half of p1 and p2\\n\\tfor (i = 1; i < n; i++) {\\n\\t\\t// now check whether my current p is in lower half\\n\\t\\t// or upper half\\n\\n\\t\\tif (i == n - 1 || !ccw(p1, p[i], p2)) { // check if not counter clock wise (it consider both clock wise and collinear pts)\\n\\t\\t\\twhile (up.size() >= 2 && ccw(up[up.size() - 2], up[up.size() - 1], p[i])) {  // check angle b/w (2nd last pt, last pt, current pt) from up vector\\n\\t\\t\\t\\tup.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\tup.push_back(p[i]);\\n\\t\\t}\\n\\t\\tif (i == n - 1 || !cw(p1, p[i], p2)) { // check if not clock wise  (it consider both counter clock wise and collinear pts)\\n\\t\\t\\twhile (down.size() >= 2 && cw(down[down.size() - 2], down[down.size() - 1], p[i])) { // check angle b/w (2nd last pt, last pt, current pt) from down vector\\n\\t\\t\\t\\tdown.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\tdown.push_back(p[i]);\\n\\t\\t}\\n\\t}\\n\\n\\tp.clear();\\n\\tfor (i = 0; i < up.size(); i++) {\\n\\t\\tp.push_back(up[i]);\\n\\t}\\n\\n\\tfor (i = 0; i < down.size(); i++) {\\n\\t\\tp.push_back(down[i]);\\n\\t}\\n\\n\\tsort(p.begin(), p.end());\\n\\tp.resize(unique(p.begin(), p.end()) - p.begin());  // take only unique values\\n}\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        int n = trees.size();\\n        vector<point> p(n);\\n\\n\\tfor (int i = 0; i < trees.size(); i++) {\\n\\t\\t p[i].x = trees[i][0];\\n         p[i].y = trees[i][1];\\n\\t}\\n        \\n\\tconvec_hull(p);\\n        vector<vector<int>> ans;\\n        \\n        for(auto j: p){\\n            ans.push_back({j.x,j.y});\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830229,
                "title": "java-solution-with-comments-80-faster-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int isGreater(int a[],int b[],int c[]){\\n        return ((b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])); //slope formula transformed version\\n        // slope=y2-y1/x2-x1 so we are comapring slope of 2 different line where first line is a to b second is a to c so if slope of a to c is greater here +ve number will get returned\\n    }\\n    public int[][] outerTrees(int[][] trees) {\\n        Arrays.sort(trees,(a,b)->a[0]==b[0]?a[1]-b[1]:a[0]-b[0]);\\n        ArrayList<int[]> upper=new ArrayList<>();\\n        ArrayList<int[]> lower=new ArrayList<>();\\n        HashSet<int[]> result=new HashSet<>();\\n        // fense will connect the first tree with highest treee and  highest lastlowest and lastlowest to bottom highest or lowest forming a barfi aur rohmbus shape\\n        for(int i=0;i<trees.length;i++){\\n            int lastUpper=upper.size()-1;\\n            int lastLower=lower.size()-1;\\n            //upper fense or hull\\n            //if the current tree is at highest rest all will be removed  except firstand this will be addded\\n            while(upper.size()>=2 && isGreater(upper.get(lastUpper-1),upper.get(lastUpper),trees[i])>0){\\n                 upper.remove(lastUpper);\\n                 lastUpper--;\\n            }\\n            //lower fense or hull\\n            //if current tree is at lowest then rest all will be removed  except first and this will be added\\n            while(lower.size()>=2 && isGreater(lower.get(lastLower-1),lower.get(lastLower),trees[i])<0){\\n                lower.remove(lastLower);\\n                lastLower--;\\n            }\\n            //adding the current highest and lowest tree\\n            upper.add(trees[i]);\\n            lower.add(trees[i]);\\n        }\\n        result.addAll(lower);\\n        result.addAll(upper);\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```\\n**upvote please!!!!**",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int isGreater(int a[],int b[],int c[]){\\n        return ((b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])); //slope formula transformed version\\n        // slope=y2-y1/x2-x1 so we are comapring slope of 2 different line where first line is a to b second is a to c so if slope of a to c is greater here +ve number will get returned\\n    }\\n    public int[][] outerTrees(int[][] trees) {\\n        Arrays.sort(trees,(a,b)->a[0]==b[0]?a[1]-b[1]:a[0]-b[0]);\\n        ArrayList<int[]> upper=new ArrayList<>();\\n        ArrayList<int[]> lower=new ArrayList<>();\\n        HashSet<int[]> result=new HashSet<>();\\n        // fense will connect the first tree with highest treee and  highest lastlowest and lastlowest to bottom highest or lowest forming a barfi aur rohmbus shape\\n        for(int i=0;i<trees.length;i++){\\n            int lastUpper=upper.size()-1;\\n            int lastLower=lower.size()-1;\\n            //upper fense or hull\\n            //if the current tree is at highest rest all will be removed  except firstand this will be addded\\n            while(upper.size()>=2 && isGreater(upper.get(lastUpper-1),upper.get(lastUpper),trees[i])>0){\\n                 upper.remove(lastUpper);\\n                 lastUpper--;\\n            }\\n            //lower fense or hull\\n            //if current tree is at lowest then rest all will be removed  except first and this will be added\\n            while(lower.size()>=2 && isGreater(lower.get(lastLower-1),lower.get(lastLower),trees[i])<0){\\n                lower.remove(lastLower);\\n                lastLower--;\\n            }\\n            //adding the current highest and lowest tree\\n            upper.add(trees[i]);\\n            lower.add(trees[i]);\\n        }\\n        result.addAll(lower);\\n        result.addAll(upper);\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442137,
                "title": "c-convex-hull",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        vector<vector<int>> points;\\n        \\n        sort(trees.begin(), trees.end(), [](auto& a, auto& b) {\\n            if (a[0] == b[0]) {\\n                return a[1] > b[1];\\n            } else {\\n                return a[0] < b[0];\\n            }\\n        });\\n        \\n        int n = trees.size();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            while (points.size() >= 2 \\n                   && orientation(points[points.size() - 2], points[points.size() - 1], trees[i]) > 0) {\\n                points.pop_back();\\n            }\\n            \\n            points.push_back(trees[i]);\\n        }\\n        \\n        points.pop_back();\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (points.size() >= 2 \\n                   && orientation(points[points.size() - 2], points[points.size() - 1], trees[i]) > 0) {\\n                points.pop_back();\\n            }\\n            \\n            points.push_back(trees[i]);\\n        }\\n        \\n        sort(points.begin(), points.end());\\n        \\n        vector<vector<int>> ans;\\n        \\n        for (auto& p : points) {\\n            if (ans.size() > 0 && p == ans.back()) {\\n                continue;\\n            }\\n            \\n            ans.push_back(p);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int orientation(vector<int>& p, vector<int>& q, vector<int>& r) {\\n        return (q[1] - p[1]) * (r[0] - p[0]) - (r[1] - p[1]) * (q[0] - p[0]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        vector<vector<int>> points;\\n        \\n        sort(trees.begin(), trees.end(), [](auto& a, auto& b) {\\n            if (a[0] == b[0]) {\\n                return a[1] > b[1];\\n            } else {\\n                return a[0] < b[0];\\n            }\\n        });\\n        \\n        int n = trees.size();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            while (points.size() >= 2 \\n                   && orientation(points[points.size() - 2], points[points.size() - 1], trees[i]) > 0) {\\n                points.pop_back();\\n            }\\n            \\n            points.push_back(trees[i]);\\n        }\\n        \\n        points.pop_back();\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (points.size() >= 2 \\n                   && orientation(points[points.size() - 2], points[points.size() - 1], trees[i]) > 0) {\\n                points.pop_back();\\n            }\\n            \\n            points.push_back(trees[i]);\\n        }\\n        \\n        sort(points.begin(), points.end());\\n        \\n        vector<vector<int>> ans;\\n        \\n        for (auto& p : points) {\\n            if (ans.size() > 0 && p == ans.back()) {\\n                continue;\\n            }\\n            \\n            ans.push_back(p);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int orientation(vector<int>& p, vector<int>& q, vector<int>& r) {\\n        return (q[1] - p[1]) * (r[0] - p[0]) - (r[1] - p[1]) * (q[0] - p[0]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829126,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n        int n = trees.length;\\n        if (n < 4) {\\n            return trees;\\n        }\\n        Arrays.sort(trees, (a, b) -> { return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]; });\\n        boolean[] vis = new boolean[n];\\n        int[] stk = new int[n + 10];\\n        int cnt = 1;\\n        for (int i = 1; i < n; ++i) {\\n            while (cnt > 1 && cross(trees[stk[cnt - 1]], trees[stk[cnt - 2]], trees[i]) < 0) {\\n                vis[stk[--cnt]] = false;\\n            }\\n            vis[i] = true;\\n            stk[cnt++] = i;\\n        }\\n        int m = cnt;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (vis[i]) {\\n                continue;\\n            }\\n            while (cnt > m && cross(trees[stk[cnt - 1]], trees[stk[cnt - 2]], trees[i]) < 0) {\\n                --cnt;\\n            }\\n            stk[cnt++] = i;\\n        }\\n        int[][] ans = new int[cnt - 1][2];\\n        for (int i = 0; i < ans.length; ++i) {\\n            ans[i] = trees[stk[i]];\\n        }\\n        return ans;\\n    }\\n\\n    private int cross(int[] a, int[] b, int[] c) {\\n        return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n        int n = trees.length;\\n        if (n < 4) {\\n            return trees;\\n        }\\n        Arrays.sort(trees, (a, b) -> { return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]; });\\n        boolean[] vis = new boolean[n];\\n        int[] stk = new int[n + 10];\\n        int cnt = 1;\\n        for (int i = 1; i < n; ++i) {\\n            while (cnt > 1 && cross(trees[stk[cnt - 1]], trees[stk[cnt - 2]], trees[i]) < 0) {\\n                vis[stk[--cnt]] = false;\\n            }\\n            vis[i] = true;\\n            stk[cnt++] = i;\\n        }\\n        int m = cnt;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (vis[i]) {\\n                continue;\\n            }\\n            while (cnt > m && cross(trees[stk[cnt - 1]], trees[stk[cnt - 2]], trees[i]) < 0) {\\n                --cnt;\\n            }\\n            stk[cnt++] = i;\\n        }\\n        int[][] ans = new int[cnt - 1][2];\\n        for (int i = 0; i < ans.length; ++i) {\\n            ans[i] = trees[stk[i]];\\n        }\\n        return ans;\\n    }\\n\\n    private int cross(int[] a, int[] b, int[] c) {\\n        return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828902,
                "title": "convex-hull-jarvis-march-algorithm-detailed-explanation-c-with-complexity",
                "content": "# Convex Hull \\nOne might think of the points as being nails sticking out of a wooden board: then the convex hull is the shape formed by a tight rubber band that surrounds all the nails.\\n\\n# Jarvis March Algorithm -\\nThis algorithm matches the working of selection sort \\nWe  simply find the leftmost point and add it to the convex hull vertices in each pass.\\n\\n1.From the given set of points P, we find a point with minimum x-coordinates ( or leftmost point with reference to the x-axis). Let\\u2019s call this point l. Since this point is guaranteed to be in the convex hull, we add this point to the list of convex hull vertices.\\n2.From l, find the leftmost point. For this, we do the following. We select the vertex following l and call it q. We check if q is turning right from the line joining l and every other point one at a time. If q is turning right, we move q to the point from where it was turning right. This way we move q towards left in each iteration and finally stop when q is in the leftmost position from l. We add q to the list of convex hull vertices.\\n3.Now q becomes l and we repeat the step (2).\\n4.Repeat step (2) and (3) until we reach the point where we started.\\n\\n# Complexity\\nThe algorithm spends O(n) time on each convex hull vertex. If there are h convex hull vertices, the total time complexity of the algorithm would be O(nh). Since h is the number of output of the algorithm, this algorithm is also called output sensitive algorithm since the complexity also depends on the number of output.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> cross_product(pair<int, int> p, pair<int, int> q) {\\n        return {0, 0, p.first*q.second-p.second*q.first};\\n    }\\n    \\n    int direction(vector<int> a, vector<int> b, vector<int> c) {\\n        vector<int> cp = cross_product({b[0]-a[0], b[1]-a[1]}, {c[0]-b[0], c[1]-b[1]});\\n        if(cp[2] > 0) return 1;\\n        else if(cp[2] < 0) return -1;\\n        return 0;\\n    }\\n    \\n    long long dot(vector<int> a, vector<int> b) {\\n        return pow(a[0]-b[0], 2) + pow(a[1]-b[1], 2);\\n    }\\n    \\n    void print(vector<int> v) {\\n        for(auto& e: v) cout << e << \\' \\';\\n        cout << endl;\\n    }\\n    \\n    \\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        int n = trees.size();\\n        \\n        // start = bottom leftmost point\\n        int start = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(trees[i][0] < trees[start][0] || (trees[i][0] == trees[start][0] && trees[i][1] < trees[start][1])) {\\n                start = i;\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        vector<bool> done(n, false);\\n        // ans stores leftmost point\\n        ans.push_back(trees[start]);\\n        done[start] = true;\\n        \\n        while(true) {\\n            int pt = 0;\\n            vector<int> temp;\\n            for(int i = 0; i < n; i++) {\\n                if(trees[i] == ans.back() || pt == i) continue;\\n                int d = direction(ans.back(), trees[pt], trees[i]);\\n                if(d == -1) {\\n                    pt = i;\\n                    temp.clear();\\n                }\\n                if(d == 0) {\\n                    if(dot(ans.back(), trees[i]) > dot(ans.back(), trees[pt])) {\\n                        if(ans.back() != trees[pt]) temp.push_back(pt);\\n                        pt=i;\\n                    } else {\\n                        temp.push_back(i);\\n                    }\\n                }\\n            }\\n            vector<int> c = {10,0};\\n           \\n            for(int idx: temp) if(!done[idx]) {ans.push_back(trees[idx]); done[idx]= true;}\\n            \\n            if(trees[pt] == ans.front()) break;\\n            if(!done[pt]) ans.push_back(trees[pt]);\\n            done[pt] = true;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> cross_product(pair<int, int> p, pair<int, int> q) {\\n        return {0, 0, p.first*q.second-p.second*q.first};\\n    }\\n    \\n    int direction(vector<int> a, vector<int> b, vector<int> c) {\\n        vector<int> cp = cross_product({b[0]-a[0], b[1]-a[1]}, {c[0]-b[0], c[1]-b[1]});\\n        if(cp[2] > 0) return 1;\\n        else if(cp[2] < 0) return -1;\\n        return 0;\\n    }\\n    \\n    long long dot(vector<int> a, vector<int> b) {\\n        return pow(a[0]-b[0], 2) + pow(a[1]-b[1], 2);\\n    }\\n    \\n    void print(vector<int> v) {\\n        for(auto& e: v) cout << e << \\' \\';\\n        cout << endl;\\n    }\\n    \\n    \\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        int n = trees.size();\\n        \\n        // start = bottom leftmost point\\n        int start = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(trees[i][0] < trees[start][0] || (trees[i][0] == trees[start][0] && trees[i][1] < trees[start][1])) {\\n                start = i;\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        vector<bool> done(n, false);\\n        // ans stores leftmost point\\n        ans.push_back(trees[start]);\\n        done[start] = true;\\n        \\n        while(true) {\\n            int pt = 0;\\n            vector<int> temp;\\n            for(int i = 0; i < n; i++) {\\n                if(trees[i] == ans.back() || pt == i) continue;\\n                int d = direction(ans.back(), trees[pt], trees[i]);\\n                if(d == -1) {\\n                    pt = i;\\n                    temp.clear();\\n                }\\n                if(d == 0) {\\n                    if(dot(ans.back(), trees[i]) > dot(ans.back(), trees[pt])) {\\n                        if(ans.back() != trees[pt]) temp.push_back(pt);\\n                        pt=i;\\n                    } else {\\n                        temp.push_back(i);\\n                    }\\n                }\\n            }\\n            vector<int> c = {10,0};\\n           \\n            for(int idx: temp) if(!done[idx]) {ans.push_back(trees[idx]); done[idx]= true;}\\n            \\n            if(trees[pt] == ans.front()) break;\\n            if(!done[pt]) ans.push_back(trees[pt]);\\n            done[pt] = true;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1443175,
                "title": "java-version-of-convex-hull-graham-scan",
                "content": "##### Java version of Graham scan using two stack lower bound and upper bound.\\n inspired by @chaudhary1337 :)\\n```\\n\\tclass Solution {\\n    \\n    private int orientation(int[] p,int[] q,int[] r){\\n        return (r[1]-q[1]) * (q[0]-p[0]) - ( (q[1]-p[1]) * (r[0]-q[0]));\\n        \\n    }\\n    public int[][] outerTrees(int[][] trees) {\\n        \\n        Stack<int[]> upper= new Stack<>();\\n        Stack<int[]> lower= new Stack<>();\\n        Arrays.sort(trees,(p,q) ->\\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0] );\\n        \\n        for(int i=0;i<trees.length;i++){\\n            \\n            while(lower.size()>= 2 && orientation(lower.get(lower.size()-2),lower.get(lower.size()-1),trees[i]) >0){\\n                lower.pop();\\n            }\\n            while(upper.size()>= 2 && orientation(upper.get(upper.size()-2),upper.get(upper.size()-1),trees[i])<0){\\n                upper.pop();\\n            }\\n            lower.push(trees[i]);\\n            upper.push(trees[i]);\\n            \\n        }\\n        Set<int[]> res= new HashSet<>(lower);\\n        // res.addAll(lower);\\n        res.addAll(upper);\\n        return res.toArray(new int[res.size()][]);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tclass Solution {\\n    \\n    private int orientation(int[] p,int[] q,int[] r){\\n        return (r[1]-q[1]) * (q[0]-p[0]) - ( (q[1]-p[1]) * (r[0]-q[0]));\\n        \\n    }\\n    public int[][] outerTrees(int[][] trees) {\\n        \\n        Stack<int[]> upper= new Stack<>();\\n        Stack<int[]> lower= new Stack<>();\\n        Arrays.sort(trees,(p,q) ->\\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0] );\\n        \\n        for(int i=0;i<trees.length;i++){\\n            \\n            while(lower.size()>= 2 && orientation(lower.get(lower.size()-2),lower.get(lower.size()-1),trees[i]) >0){\\n                lower.pop();\\n            }\\n            while(upper.size()>= 2 && orientation(upper.get(upper.size()-2),upper.get(upper.size()-1),trees[i])<0){\\n                upper.pop();\\n            }\\n            lower.push(trees[i]);\\n            upper.push(trees[i]);\\n            \\n        }\\n        Set<int[]> res= new HashSet<>(lower);\\n        // res.addAll(lower);\\n        res.addAll(upper);\\n        return res.toArray(new int[res.size()][]);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442440,
                "title": "c-gift-wrapping",
                "content": "Approach 1: Gift wrapping (Jarvis march) Algorithm [1][2]\\nTime complexity : O(m*n). For every point on the hull we examine all the other points to determine the next point. Here n is number of input points and m is number of output or hull points (m<=n).\\n\\nSpace complexity : O(m). List hullhull grows upto size mm.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        vector<vector<int>> res;\\n        vector<int> first = trees[0];\\n        int firstIdx = 0, n = trees.size();\\n        for (int i = 1; i < n; ++i) {\\n            if (trees[i][0] < first[0]) {\\n                first = trees[i];\\n                firstIdx = i;\\n            }\\n        }\\n        res.push_back(first);\\n        vector<int> cur = first;\\n        int curIdx = firstIdx;\\n        while (true) {\\n            vector<int> next = trees[0];\\n            int nextIdx = 0;\\n            for (int i = 1; i < n; ++i) {\\n                if (i == curIdx) continue;\\n                int cross = crossProduct(cur, trees[i], next);\\n                if (nextIdx == curIdx || cross > 0 || (cross == 0 && dist(trees[i], cur) > dist(next, cur))) {\\n                    next = trees[i];\\n                    nextIdx = i;\\n                }\\n            }\\n            for (int i = 0; i < n; ++i) {\\n                if (i == curIdx) continue;\\n                int cross = crossProduct(cur, trees[i], next);\\n                if (cross == 0) {\\n                    if (check(res, trees[i])) res.push_back(trees[i]);\\n                }\\n            }\\n            cur = next;\\n            curIdx = nextIdx;\\n            if (curIdx == firstIdx) break;\\n        }\\n        return res;\\n    }\\n    int crossProduct(vector<int> A, vector<int> B, vector<int> C) {\\n        int BAx = A[0] - B[0];\\n        int BAy = A[1] - B[1];\\n        int BCx = C[0] - B[0];\\n        int BCy = C[1] - B[1];\\n        return BAx * BCy - BAy * BCx;\\n    }\\n    int dist(vector<int> A, vector<int> B) {\\n        return (A[0] - B[0]) * (A[0] - B[0]) + (A[1] - B[1]) * (A[1] - B[1]);\\n    }\\n    bool check(vector<vector<int>>& res, vector<int> p) {\\n        for (vector<int> r : res) {\\n            if (r[0] == p[0] && r[1] == p[1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nReference:\\n[1] https://www.cnblogs.com/grandyang/p/7745697.html",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        vector<vector<int>> res;\\n        vector<int> first = trees[0];\\n        int firstIdx = 0, n = trees.size();\\n        for (int i = 1; i < n; ++i) {\\n            if (trees[i][0] < first[0]) {\\n                first = trees[i];\\n                firstIdx = i;\\n            }\\n        }\\n        res.push_back(first);\\n        vector<int> cur = first;\\n        int curIdx = firstIdx;\\n        while (true) {\\n            vector<int> next = trees[0];\\n            int nextIdx = 0;\\n            for (int i = 1; i < n; ++i) {\\n                if (i == curIdx) continue;\\n                int cross = crossProduct(cur, trees[i], next);\\n                if (nextIdx == curIdx || cross > 0 || (cross == 0 && dist(trees[i], cur) > dist(next, cur))) {\\n                    next = trees[i];\\n                    nextIdx = i;\\n                }\\n            }\\n            for (int i = 0; i < n; ++i) {\\n                if (i == curIdx) continue;\\n                int cross = crossProduct(cur, trees[i], next);\\n                if (cross == 0) {\\n                    if (check(res, trees[i])) res.push_back(trees[i]);\\n                }\\n            }\\n            cur = next;\\n            curIdx = nextIdx;\\n            if (curIdx == firstIdx) break;\\n        }\\n        return res;\\n    }\\n    int crossProduct(vector<int> A, vector<int> B, vector<int> C) {\\n        int BAx = A[0] - B[0];\\n        int BAy = A[1] - B[1];\\n        int BCx = C[0] - B[0];\\n        int BCy = C[1] - B[1];\\n        return BAx * BCy - BAy * BCx;\\n    }\\n    int dist(vector<int> A, vector<int> B) {\\n        return (A[0] - B[0]) * (A[0] - B[0]) + (A[1] - B[1]) * (A[1] - B[1]);\\n    }\\n    bool check(vector<vector<int>>& res, vector<int> p) {\\n        for (vector<int> r : res) {\\n            if (r[0] == p[0] && r[1] == p[1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122604,
                "title": "python-gift-mapping-algorithm",
                "content": "```\\nclass Solution(object):\\n    def outerTrees(self, points):\\n        #start with the leftmost point on the map\\n        leftmost = [float(\\'inf\\'), float(\\'inf\\')]\\n        for x,y in points:\\n            if x < leftmost[0]:\\n                leftmost = [x,y]\\n        #set this leftmost point as a starter\\n        current = leftmost\\n        \\n        res = set()\\n        res.add((leftmost[0],leftmost[1]))\\n        while True:\\n            target = points[0]\\n            linenodes = []\\n            for node in points:\\n                if node != current:\\n                    val = self.crossproduct(current,target,node)\\n                    if val > 0: #node is on the left of target\\n                        target = node \\n                        linenodes = []\\n                    elif val == 0: #node is inline with the target\\n                        if ((node[0]-current[0])**2+((node[1]-current[1])**2)) < ((target[0]-current[0])**2+((target[1]-current[1])**2)):\\n                            linenodes.append(node) \\n                        else:\\n                            linenodes.append(target)\\n                            target = node\\n                    else: #node is on the right of target, we don\\'t care\\n                        continue \\n            for linenode in linenodes:\\n                res.add((linenode[0],linenode[1]))\\n            if target == leftmost: #we encounter the start point, let\\'s break \\n                break\\n            res.add((target[0],target[1]))\\n\\n            current = target\\n        return [[x,y] for x,y in res]\\n    \\n    def crossproduct(self,origin, target, node):\\n        x1 = origin[0] - target[0]\\n        y1 = origin[1] - target[1]\\n        x2 = origin[0] - node[0]\\n        y2 = origin[1] - node[1]\\n        return y2*x1 - y1*x2\\n        \\n```\\nTime complexity O(N*H), H means the number of nodes on the fence, Space complexity O(N), the worst case is all nodes are on the fence",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def outerTrees(self, points):\\n        #start with the leftmost point on the map\\n        leftmost = [float(\\'inf\\'), float(\\'inf\\')]\\n        for x,y in points:\\n            if x < leftmost[0]:\\n                leftmost = [x,y]\\n        #set this leftmost point as a starter\\n        current = leftmost\\n        \\n        res = set()\\n        res.add((leftmost[0],leftmost[1]))\\n        while True:\\n            target = points[0]\\n            linenodes = []\\n            for node in points:\\n                if node != current:\\n                    val = self.crossproduct(current,target,node)\\n                    if val > 0: #node is on the left of target\\n                        target = node \\n                        linenodes = []\\n                    elif val == 0: #node is inline with the target\\n                        if ((node[0]-current[0])**2+((node[1]-current[1])**2)) < ((target[0]-current[0])**2+((target[1]-current[1])**2)):\\n                            linenodes.append(node) \\n                        else:\\n                            linenodes.append(target)\\n                            target = node\\n                    else: #node is on the right of target, we don\\'t care\\n                        continue \\n            for linenode in linenodes:\\n                res.add((linenode[0],linenode[1]))\\n            if target == leftmost: #we encounter the start point, let\\'s break \\n                break\\n            res.add((target[0],target[1]))\\n\\n            current = target\\n        return [[x,y] for x,y in res]\\n    \\n    def crossproduct(self,origin, target, node):\\n        x1 = origin[0] - target[0]\\n        y1 = origin[1] - target[1]\\n        x2 = origin[0] - node[0]\\n        y2 = origin[1] - node[1]\\n        return y2*x1 - y1*x2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829068,
                "title": "c-easy-solution-upper-hull-lower-hull",
                "content": "[**587. Erect the Fence**](https://leetcode.com/problems/erect-the-fence/)\\n\\n**`Time Complexity : O(nlogn)`**\\n**`Space Complexity : O(n)`**\\n\\n```\\n\\tint angle(vector<int>&x, vector<int>&y, vector<int>&z){\\n        // (x2-x1)(y3-y1) - (y2-y1)(x3-x1) \\n        return (y[0]-x[0])*(z[1]-x[1])-(y[1]-x[1])*(z[0]-x[0]);\\n    }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        int n=trees.size();\\n        if(n<=3)return trees;\\n        sort(trees.begin(), trees.end());\\n        //upper hull\\n        vector<vector<int>>up;\\n        up.push_back(trees[0]);\\n        up.push_back(trees[1]);\\n        for(int i=2; i<n; i++){\\n            int sz=up.size();\\n            while(sz>=2 and angle(up[sz-2],up[sz-1],trees[i])>0){\\n                up.pop_back();\\n                sz--;\\n            }\\n            up.push_back(trees[i]);\\n        }\\n        //lower hull\\n        vector<vector<int>>down;\\n        down.push_back(trees[trees.size()-1]);\\n        down.push_back(trees[trees.size()-2]);\\n        for(int i=n-3; i>=0; i--){\\n            int sz=down.size();\\n            while(sz>=2 and angle(down[sz-2],down[sz-1],trees[i])>0){\\n                down.pop_back();\\n                sz--;\\n            }\\n            down.push_back(trees[i]);\\n        }\\n        // remove duplicates\\n        for(auto x:down)up.push_back(x);\\n        sort(up.begin(), up.end());\\n        up.erase(unique(up.begin(), up.end()), up.end());\\n        return up;\\n    }\\n```\\n***Happy Coding :)***\\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint angle(vector<int>&x, vector<int>&y, vector<int>&z){\\n        // (x2-x1)(y3-y1) - (y2-y1)(x3-x1) \\n        return (y[0]-x[0])*(z[1]-x[1])-(y[1]-x[1])*(z[0]-x[0]);\\n    }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        int n=trees.size();\\n        if(n<=3)return trees;\\n        sort(trees.begin(), trees.end());\\n        //upper hull\\n        vector<vector<int>>up;\\n        up.push_back(trees[0]);\\n        up.push_back(trees[1]);\\n        for(int i=2; i<n; i++){\\n            int sz=up.size();\\n            while(sz>=2 and angle(up[sz-2],up[sz-1],trees[i])>0){\\n                up.pop_back();\\n                sz--;\\n            }\\n            up.push_back(trees[i]);\\n        }\\n        //lower hull\\n        vector<vector<int>>down;\\n        down.push_back(trees[trees.size()-1]);\\n        down.push_back(trees[trees.size()-2]);\\n        for(int i=n-3; i>=0; i--){\\n            int sz=down.size();\\n            while(sz>=2 and angle(down[sz-2],down[sz-1],trees[i])>0){\\n                down.pop_back();\\n                sz--;\\n            }\\n            down.push_back(trees[i]);\\n        }\\n        // remove duplicates\\n        for(auto x:down)up.push_back(x);\\n        sort(up.begin(), up.end());\\n        up.erase(unique(up.begin(), up.end()), up.end());\\n        return up;\\n    }\\n```\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2828878,
                "title": "c-convexhull-great-question",
                "content": "```\\nFor reference : \\nhttps://algorithmist.com/wiki/Monotone_chain_convex_hull\\n\\n\\nclass Solution {\\npublic:\\n    \\n    // convex condition m2 > m1 \\n    bool isCounterClockwiseTurn(vector<int> &a, vector<int> &b, vector<int> &c) {\\n        int xa = a[0], xb = b[0], xc = c[0];\\n        int ya = a[1], yb = b[1], yc = c[1];\\n        bool isConvex = (((yc - yb) * (xb - xa)) - ((yb - ya) * (xc - xb))) >= 0;\\n        return isConvex;\\n    }\\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        vector<vector<int>> convexHull;\\n        int n = trees.size();\\n       \\n        auto cmp = [&](vector<int> &a, vector<int> &b) {\\n            if(a[0] < b[0]) {\\n                return true;\\n            } else if (a[0] == b[0] && a[1] < b[1]) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        \\n        sort(trees.begin(), trees.end(), cmp);\\n        \\n        for(int i = 0; i < n; i++) {\\n            while(convexHull.size() > 1 && !isCounterClockwiseTurn(convexHull[convexHull.size() - 2], convexHull[convexHull.size() - 1], trees[i])) {\\n                convexHull.pop_back();\\n            }\\n            convexHull.push_back(trees[i]);\\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            while(convexHull.size() > 1 && !isCounterClockwiseTurn(convexHull[convexHull.size() - 2], convexHull[convexHull.size() - 1], trees[i])) {\\n                convexHull.pop_back();\\n            }\\n            convexHull.push_back(trees[i]);\\n        }\\n        convexHull.pop_back(); // remove duplicate first and last point.\\n\\t\\t// Sorting and removing duplicates (when in a straight line)\\n        sort(convexHull.begin(), convexHull.end(), cmp);\\n        convexHull.erase(unique(convexHull.begin(), convexHull.end()), convexHull.end());\\n        return convexHull;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nFor reference : \\nhttps://algorithmist.com/wiki/Monotone_chain_convex_hull\\n\\n\\nclass Solution {\\npublic:\\n    \\n    // convex condition m2 > m1 \\n    bool isCounterClockwiseTurn(vector<int> &a, vector<int> &b, vector<int> &c) {\\n        int xa = a[0], xb = b[0], xc = c[0];\\n        int ya = a[1], yb = b[1], yc = c[1];\\n        bool isConvex = (((yc - yb) * (xb - xa)) - ((yb - ya) * (xc - xb))) >= 0;\\n        return isConvex;\\n    }\\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        vector<vector<int>> convexHull;\\n        int n = trees.size();\\n       \\n        auto cmp = [&](vector<int> &a, vector<int> &b) {\\n            if(a[0] < b[0]) {\\n                return true;\\n            } else if (a[0] == b[0] && a[1] < b[1]) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        \\n        sort(trees.begin(), trees.end(), cmp);\\n        \\n        for(int i = 0; i < n; i++) {\\n            while(convexHull.size() > 1 && !isCounterClockwiseTurn(convexHull[convexHull.size() - 2], convexHull[convexHull.size() - 1], trees[i])) {\\n                convexHull.pop_back();\\n            }\\n            convexHull.push_back(trees[i]);\\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            while(convexHull.size() > 1 && !isCounterClockwiseTurn(convexHull[convexHull.size() - 2], convexHull[convexHull.size() - 1], trees[i])) {\\n                convexHull.pop_back();\\n            }\\n            convexHull.push_back(trees[i]);\\n        }\\n        convexHull.pop_back(); // remove duplicate first and last point.\\n\\t\\t// Sorting and removing duplicates (when in a straight line)\\n        sort(convexHull.begin(), convexHull.end(), cmp);\\n        convexHull.erase(unique(convexHull.begin(), convexHull.end()), convexHull.end());\\n        return convexHull;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830536,
                "title": "java-easy-solution-using-stack-faster-than-80",
                "content": "```\\nclass Solution {\\n    \\n    public int[][] outerTrees(int[][] trees) {\\n        if(trees.length == 3){\\n            return trees;\\n        }\\n        Stack<int[]> upper = new Stack<>();\\n        Stack<int[]> lower = new Stack<>();\\n        \\n        Arrays.sort(trees,(p,q) ->\\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\\n        \\n        for(int i = 0 ; i < trees.length ; i++){\\n            int size = trees.length;\\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\\n                upper.pop();  \\n                }\\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\\n                 lower.pop();  \\n              }\\n            upper.push(trees[i]);\\n            lower.push(trees[i]);\\n        }\\n        \\n        \\n        Set<int[]> res= new HashSet<>(lower);\\n        res.addAll(upper);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n    \\n    public int angle(int[] A , int[] B , int[] C){\\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\\n    }\\n}\\n```\\n\\n**Upvote Please**",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[][] outerTrees(int[][] trees) {\\n        if(trees.length == 3){\\n            return trees;\\n        }\\n        Stack<int[]> upper = new Stack<>();\\n        Stack<int[]> lower = new Stack<>();\\n        \\n        Arrays.sort(trees,(p,q) ->\\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\\n        \\n        for(int i = 0 ; i < trees.length ; i++){\\n            int size = trees.length;\\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\\n                upper.pop();  \\n                }\\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\\n                 lower.pop();  \\n              }\\n            upper.push(trees[i]);\\n            lower.push(trees[i]);\\n        }\\n        \\n        \\n        Set<int[]> res= new HashSet<>(lower);\\n        res.addAll(upper);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n    \\n    public int angle(int[] A , int[] B , int[] C){\\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829902,
                "title": "c-sorting-convex-hull-algorithm-geometry-easy-explanation",
                "content": "# Approach\\n**1) Geometry, Sorting and Maths Based Problem!!\\n2) Convex Hull Algorithm is Used!!**\\n\\n# Algorithm and other Requirements:-\\n- Convex Hull Algorithm (For Polygon) - IMP\\n- Cross Product is Used\\n- Sorting \\n- Removing Duplicates\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     \\n    // Geometry and Maths Problem\\n    // Convex Hull Algorithm is Used\\n\\n    // Cross Product we are doing\\n    int Cross_Product_fun(vector<int> p,vector<int> q,vector<int> r){\\n        int ans = ((q[0]-p[0])*(r[1]-p[1]))-((q[1]-p[1])*(r[0]-p[0]));\\n\\n        return ans;\\n\\n    }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        int sz = trees.size();\\n\\n        if(sz<=3){\\n            return trees;\\n        }\\n        else{\\n\\n            sort(trees.begin(),trees.end());\\n\\n            vector<vector<int>> up_hull;\\n            vector<vector<int>> low_hull;\\n\\n            // for Upper Hull\\n\\n            up_hull.push_back(trees[0]);\\n            up_hull.push_back(trees[1]);\\n\\n            for(int j=2;j<sz;j++){\\n                int n = up_hull.size();\\n\\n                while(n>=2 && Cross_Product_fun(up_hull[n-2],up_hull[n-1],trees[j]) > 0){\\n                    up_hull.pop_back();\\n                    n--;\\n                }\\n\\n                up_hull.push_back(trees[j]);\\n            }\\n\\n            // for Lower Hull\\n\\n            low_hull.push_back(trees[sz-1]);\\n            low_hull.push_back(trees[sz-2]);\\n\\n            for(int j=sz-3;j>=0;j--){\\n                int m = low_hull.size();\\n\\n                while(m>=2 && Cross_Product_fun(low_hull[m-2],low_hull[m-1],trees[j]) > 0){\\n                    low_hull.pop_back();\\n                    m--;\\n                }\\n\\n                low_hull.push_back(trees[j]);\\n            }\\n\\n            // Finally Connecting our Upper Hull and Lower Hull\\n\\n            up_hull.insert(up_hull.end(),low_hull.begin(),low_hull.end());\\n\\n            sort(up_hull.begin(),up_hull.end());\\n\\n            up_hull.erase(unique(up_hull.begin(),up_hull.end()),up_hull.end());\\n\\n            return up_hull;\\n\\n        }\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Geometry",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     \\n    // Geometry and Maths Problem\\n    // Convex Hull Algorithm is Used\\n\\n    // Cross Product we are doing\\n    int Cross_Product_fun(vector<int> p,vector<int> q,vector<int> r){\\n        int ans = ((q[0]-p[0])*(r[1]-p[1]))-((q[1]-p[1])*(r[0]-p[0]));\\n\\n        return ans;\\n\\n    }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        int sz = trees.size();\\n\\n        if(sz<=3){\\n            return trees;\\n        }\\n        else{\\n\\n            sort(trees.begin(),trees.end());\\n\\n            vector<vector<int>> up_hull;\\n            vector<vector<int>> low_hull;\\n\\n            // for Upper Hull\\n\\n            up_hull.push_back(trees[0]);\\n            up_hull.push_back(trees[1]);\\n\\n            for(int j=2;j<sz;j++){\\n                int n = up_hull.size();\\n\\n                while(n>=2 && Cross_Product_fun(up_hull[n-2],up_hull[n-1],trees[j]) > 0){\\n                    up_hull.pop_back();\\n                    n--;\\n                }\\n\\n                up_hull.push_back(trees[j]);\\n            }\\n\\n            // for Lower Hull\\n\\n            low_hull.push_back(trees[sz-1]);\\n            low_hull.push_back(trees[sz-2]);\\n\\n            for(int j=sz-3;j>=0;j--){\\n                int m = low_hull.size();\\n\\n                while(m>=2 && Cross_Product_fun(low_hull[m-2],low_hull[m-1],trees[j]) > 0){\\n                    low_hull.pop_back();\\n                    m--;\\n                }\\n\\n                low_hull.push_back(trees[j]);\\n            }\\n\\n            // Finally Connecting our Upper Hull and Lower Hull\\n\\n            up_hull.insert(up_hull.end(),low_hull.begin(),low_hull.end());\\n\\n            sort(up_hull.begin(),up_hull.end());\\n\\n            up_hull.erase(unique(up_hull.begin(),up_hull.end()),up_hull.end());\\n\\n            return up_hull;\\n\\n        }\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828998,
                "title": "python-simple-and-easy-way-to-solve-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nimport itertools\\n\\n# Monotone Chain Algorithm\\nclass Solution(object):\\n    def outerTrees(self, points):\\n\\t\\n        def ccw(A, B, C):\\n            return (B[0]-A[0])*(C[1]-A[1]) - (B[1]-A[1])*(C[0]-A[0])\\n\\n        if len(points) <= 1:\\n            return points\\n\\n        hull = []\\n        points.sort()\\n        for i in itertools.chain(range(len(points)), reversed(range(len(points)-1))):\\n            while len(hull) >= 2 and ccw(hull[-2], hull[-1], points[i]) < 0:\\n                hull.pop()\\n            hull.append(points[i])\\n        hull.pop()\\n\\n        for i in range(1, (len(hull)+1)//2):\\n            if hull[i] != hull[-1]:\\n                break\\n            hull.pop()\\n        return hull\\n```\\n\\n**For Leetcode Solution with Explanation Visit this Blog:\\nhttps://www.python-techs.com/\\n(Please open this link in new tab)**\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport itertools\\n\\n# Monotone Chain Algorithm\\nclass Solution(object):\\n    def outerTrees(self, points):\\n\\t\\n        def ccw(A, B, C):\\n            return (B[0]-A[0])*(C[1]-A[1]) - (B[1]-A[1])*(C[0]-A[0])\\n\\n        if len(points) <= 1:\\n            return points\\n\\n        hull = []\\n        points.sort()\\n        for i in itertools.chain(range(len(points)), reversed(range(len(points)-1))):\\n            while len(hull) >= 2 and ccw(hull[-2], hull[-1], points[i]) < 0:\\n                hull.pop()\\n            hull.append(points[i])\\n        hull.pop()\\n\\n        for i in range(1, (len(hull)+1)//2):\\n            if hull[i] != hull[-1]:\\n                break\\n            hull.pop()\\n        return hull\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443353,
                "title": "javascript-convex-hull-with-graham-scan-127ms",
                "content": "```\\nconst outerTrees = (trees) => {\\n    trees.sort((x, y) => {\\n        if (x[0] == y[0]) return x[1] - y[1];\\n        return x[0] - y[0];\\n    });\\n    let lower = [], upper = [];\\n    for (const tree of trees) {\\n        while (lower.length >= 2 && cmp(lower[lower.length - 2], lower[lower.length - 1], tree) > 0) lower.pop();\\n        while (upper.length >= 2 && cmp(upper[upper.length - 2], upper[upper.length - 1], tree) < 0) upper.pop();\\n        lower.push(tree);\\n        upper.push(tree);\\n\\n    }\\n    return [...new Set(lower.concat(upper))];\\n};\\n\\nconst cmp = (p1, p2, p3) => {\\n    let [x1, y1] = p1;\\n    let [x2, y2] = p2;\\n    let [x3, y3] = p3;\\n    return (y3 - y2) * (x2 - x1) - (y2 - y1) * (x3 - x2);\\n};\\n```\\nreference: https://leetcode.com/problems/erect-the-fence/discuss/1442266/A-Detailed-Explanation-with-Diagrams-(Graham-Scan)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst outerTrees = (trees) => {\\n    trees.sort((x, y) => {\\n        if (x[0] == y[0]) return x[1] - y[1];\\n        return x[0] - y[0];\\n    });\\n    let lower = [], upper = [];\\n    for (const tree of trees) {\\n        while (lower.length >= 2 && cmp(lower[lower.length - 2], lower[lower.length - 1], tree) > 0) lower.pop();\\n        while (upper.length >= 2 && cmp(upper[upper.length - 2], upper[upper.length - 1], tree) < 0) upper.pop();\\n        lower.push(tree);\\n        upper.push(tree);\\n\\n    }\\n    return [...new Set(lower.concat(upper))];\\n};\\n\\nconst cmp = (p1, p2, p3) => {\\n    let [x1, y1] = p1;\\n    let [x2, y2] = p2;\\n    let [x3, y3] = p3;\\n    return (y3 - y2) * (x2 - x1) - (y2 - y1) * (x3 - x2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 864619,
                "title": "python-solution-with-monotone-chain-algorithm",
                "content": "```\\nclass Solution:\\n    def outerTrees(self, points: List[List[int]]) -> List[List[int]]:\\n        \"\"\"\\n        Use Monotone Chain algorithm.\\n        \"\"\"\\n        def is_clockwise(\\n                p0: List[int], p1: List[int], p2: List[int]) -> bool:\\n            \"\"\"\\n            Determine the orientation the slope p0p2 is on the clockwise\\n            orientation of the slope p0p1.\\n            \"\"\"\\n            return (p1[1] - p0[1]) * (p2[0] - p0[0]) > \\\\\\n                (p2[1] - p0[1]) * (p1[0] - p0[0])\\n\\n        sortedPoints = sorted(points)\\n\\n        # Scan from left to right to generate the lower part of the hull.\\n        hull = []\\n        for p in sortedPoints:\\n            while len(hull) > 1 and is_clockwise(hull[-2], hull[-1], p):\\n                hull.pop()\\n\\n            hull.append(p)\\n\\n        if len(hull) == len(points):  # All the points are on the perimeter now.\\n            return hull\\n\\n        # Scan from right to left to generate the higher part of the hull.\\n        # Remove the last point first as it will be scanned again.\\n        hull.pop()\\n        for p in reversed(sortedPoints):\\n            while len(hull) > 1 and is_clockwise(hull[-2], hull[-1], p):\\n                hull.pop()\\n\\n            hull.append(p)\\n\\n        # Pop the first point as it is already added to hull when processing\\n        # the lower part.\\n        hull.pop()\\n\\n        return hull\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def outerTrees(self, points: List[List[int]]) -> List[List[int]]:\\n        \"\"\"\\n        Use Monotone Chain algorithm.\\n        \"\"\"\\n        def is_clockwise(\\n                p0: List[int], p1: List[int], p2: List[int]) -> bool:\\n            \"\"\"\\n            Determine the orientation the slope p0p2 is on the clockwise\\n            orientation of the slope p0p1.\\n            \"\"\"\\n            return (p1[1] - p0[1]) * (p2[0] - p0[0]) > \\\\\\n                (p2[1] - p0[1]) * (p1[0] - p0[0])\\n\\n        sortedPoints = sorted(points)\\n\\n        # Scan from left to right to generate the lower part of the hull.\\n        hull = []\\n        for p in sortedPoints:\\n            while len(hull) > 1 and is_clockwise(hull[-2], hull[-1], p):\\n                hull.pop()\\n\\n            hull.append(p)\\n\\n        if len(hull) == len(points):  # All the points are on the perimeter now.\\n            return hull\\n\\n        # Scan from right to left to generate the higher part of the hull.\\n        # Remove the last point first as it will be scanned again.\\n        hull.pop()\\n        for p in reversed(sortedPoints):\\n            while len(hull) > 1 and is_clockwise(hull[-2], hull[-1], p):\\n                hull.pop()\\n\\n            hull.append(p)\\n\\n        # Pop the first point as it is already added to hull when processing\\n        # the lower part.\\n        hull.pop()\\n\\n        return hull\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480279,
                "title": "short-and-concise-java-solution",
                "content": "```\\n public int[][] outerTrees(int[][] points) {\\n        if(points==null || points.length==0) return new int[][]{};\\n        Arrays.sort(points,(x,y)->x[0]==y[0]?y[1]-x[1]:x[0]-y[0]);\\n        Stack<int[]> stack = new Stack<>();\\n\\t\\t// scan from left to right find first part \\n        for(int i=0; i<points.length; i++){\\n            while(stack.size()>=2 && crossProduct(stack.get(stack.size()-2),stack.peek(),points[i])>0){\\n                stack.pop();\\n            }\\n            stack.push(points[i]);\\n        }\\n        stack.pop();\\n\\t\\t// scan from right to left find second part\\n        for(int i=points.length-1; i>=0;i--){\\n            while(stack.size()>=2 && crossProduct(stack.get(stack.size()-2),stack.peek(),points[i])>0){\\n                stack.pop();\\n            }\\n            stack.push(points[i]);\\n        }\\n        Set<int[]> set = new HashSet<>(stack);\\n        Iterator<int[]> iterator = set.iterator();\\n        int[][] ans = new int[set.size()][2];\\n        for(int i=0;i<set.size();i++) ans[i] = iterator.next();\\n        return ans;\\n    }\\n    // if result >0 then q-o located in counterclockwise direction of   p-0 \\n    private int crossProduct(int[] o,int[] p,int[] q){\\n        return (p[1] - o[1]) * (q[0] - o[0]) - (q[1] - o[1]) * (p[0] - o[0]);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int[][] outerTrees(int[][] points) {\\n        if(points==null || points.length==0) return new int[][]{};\\n        Arrays.sort(points,(x,y)->x[0]==y[0]?y[1]-x[1]:x[0]-y[0]);\\n        Stack<int[]> stack = new Stack<>();\\n\\t\\t// scan from left to right find first part \\n        for(int i=0; i<points.length; i++){\\n            while(stack.size()>=2 && crossProduct(stack.get(stack.size()-2),stack.peek(),points[i])>0){\\n                stack.pop();\\n            }\\n            stack.push(points[i]);\\n        }\\n        stack.pop();\\n\\t\\t// scan from right to left find second part\\n        for(int i=points.length-1; i>=0;i--){\\n            while(stack.size()>=2 && crossProduct(stack.get(stack.size()-2),stack.peek(),points[i])>0){\\n                stack.pop();\\n            }\\n            stack.push(points[i]);\\n        }\\n        Set<int[]> set = new HashSet<>(stack);\\n        Iterator<int[]> iterator = set.iterator();\\n        int[][] ans = new int[set.size()][2];\\n        for(int i=0;i<set.size();i++) ans[i] = iterator.next();\\n        return ans;\\n    }\\n    // if result >0 then q-o located in counterclockwise direction of   p-0 \\n    private int crossProduct(int[] o,int[] p,int[] q){\\n        return (p[1] - o[1]) * (q[0] - o[0]) - (q[1] - o[1]) * (p[0] - o[0]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2833816,
                "title": "java-math-slope-calculation-fully-explained",
                "content": "# Intuition\\nWe must use the minimum number of straight lines to cover the points represented by the `trees` array, which just resembles points on a coordinate plane `(x, y)`.\\n\\nInitially lets sort the points by X axis ascending, Y axis descending. This way we will have all points left to right.\\n\\nThe trick for solving this question is to figure out what is the point we need to cover next.\\n\\n**The observation** we need to make is that we need to take the next point that forms the biggest slope, because all other points are covered within it.\\n\\n![image.png](https://assets.leetcode.com/users/images/dea5e80d-7239-4c80-83b2-c339383fe6ef_1668962168.7907205.png)\\n\\nTake a look at this example. If we take the green point with slope `m3`, we will contain the 2 other green points when we extend our covered area to the blue points. The other 2 green points will be contained within the area.\\n\\nSo the idea is to iterate the array twice, going right-to-left and left-to-right and move to the points that form the best slope.\\n\\n**Note: ** I\\'ve created a Point class to have a unique hashcode and equals method in Java. This is not requried in python for a `set` data structure.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n\\n        // Sort by x asc and then by y desc\\n        Arrays.sort(trees, (p1, p2) -> {\\n            if (p1[0] == p2[0]) {\\n                return p2[1] - p1[1];\\n                // return p1[1] - p2[1];\\n            }\\n            return p1[0] - p2[0];\\n        });\\n\\n        Set<Point> res = new HashSet<>();\\n        res.add(new Point(trees[0]));\\n\\n        int n = trees.length;\\n        int i = 0;\\n        while (i != n - 1) {\\n            // find the next best slope\\n            double bestSlope = Integer.MIN_VALUE;\\n            int[] nextPoint = trees[i + 1];\\n            int jCandidate = i + 1;\\n\\n            for (int j = i + 1; j < n; j++) {\\n                double slope = calculateSlope(trees[i], trees[j]);\\n                if (slope > bestSlope) {\\n                    bestSlope = slope;\\n                    nextPoint = trees[j];\\n                    jCandidate = j;\\n                }\\n            }\\n\\n            i = jCandidate;\\n            res.add(new Point(nextPoint));\\n        }\\n\\n        // Reverse it\\n        i = n - 1;\\n        while (i != 0) {\\n            // find the next best slope\\n            double bestSlope = Integer.MIN_VALUE;\\n             int[] nextPoint = trees[i - 1];\\n            int jCandidate = i - 1;\\n\\n            for (int j = i - 1; j >= 0; j--) {\\n                double slope = calculateSlope(trees[j], trees[i]);\\n                if (slope > bestSlope) {\\n                    bestSlope = slope;\\n                    nextPoint = trees[j];\\n                    jCandidate = j;\\n                }\\n            }\\n\\n            i = jCandidate;\\n            res.add(new Point(nextPoint));\\n        }\\n\\n        return res.stream().map(p -> new int[]{p.x, p.y}).toArray(int[][]::new);\\n    }\\n\\n    private double calculateSlope(int[] p1, int[] p2) {\\n        if (p1[0] == p2[0]) { // 0 division\\n            return Integer.MIN_VALUE;\\n        }\\n        return (double) (p2[1] - p1[1]) / (double) (p2[0] - p1[0]);\\n    }\\n\\n    private static class Point {\\n        public int x;\\n        public int y;\\n\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        public Point(int[] p) {\\n            this.x = p[0];\\n            this.y = p[1];\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Point{\" +\\n                    \"x=\" + x +\\n                    \", y=\" + y +\\n                    \\'}\\';\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Point point = (Point) o;\\n            return x == point.x && y == point.y;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(x, y);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n\\n        // Sort by x asc and then by y desc\\n        Arrays.sort(trees, (p1, p2) -> {\\n            if (p1[0] == p2[0]) {\\n                return p2[1] - p1[1];\\n                // return p1[1] - p2[1];\\n            }\\n            return p1[0] - p2[0];\\n        });\\n\\n        Set<Point> res = new HashSet<>();\\n        res.add(new Point(trees[0]));\\n\\n        int n = trees.length;\\n        int i = 0;\\n        while (i != n - 1) {\\n            // find the next best slope\\n            double bestSlope = Integer.MIN_VALUE;\\n            int[] nextPoint = trees[i + 1];\\n            int jCandidate = i + 1;\\n\\n            for (int j = i + 1; j < n; j++) {\\n                double slope = calculateSlope(trees[i], trees[j]);\\n                if (slope > bestSlope) {\\n                    bestSlope = slope;\\n                    nextPoint = trees[j];\\n                    jCandidate = j;\\n                }\\n            }\\n\\n            i = jCandidate;\\n            res.add(new Point(nextPoint));\\n        }\\n\\n        // Reverse it\\n        i = n - 1;\\n        while (i != 0) {\\n            // find the next best slope\\n            double bestSlope = Integer.MIN_VALUE;\\n             int[] nextPoint = trees[i - 1];\\n            int jCandidate = i - 1;\\n\\n            for (int j = i - 1; j >= 0; j--) {\\n                double slope = calculateSlope(trees[j], trees[i]);\\n                if (slope > bestSlope) {\\n                    bestSlope = slope;\\n                    nextPoint = trees[j];\\n                    jCandidate = j;\\n                }\\n            }\\n\\n            i = jCandidate;\\n            res.add(new Point(nextPoint));\\n        }\\n\\n        return res.stream().map(p -> new int[]{p.x, p.y}).toArray(int[][]::new);\\n    }\\n\\n    private double calculateSlope(int[] p1, int[] p2) {\\n        if (p1[0] == p2[0]) { // 0 division\\n            return Integer.MIN_VALUE;\\n        }\\n        return (double) (p2[1] - p1[1]) / (double) (p2[0] - p1[0]);\\n    }\\n\\n    private static class Point {\\n        public int x;\\n        public int y;\\n\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        public Point(int[] p) {\\n            this.x = p[0];\\n            this.y = p[1];\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Point{\" +\\n                    \"x=\" + x +\\n                    \", y=\" + y +\\n                    \\'}\\';\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Point point = (Point) o;\\n            return x == point.x && y == point.y;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(x, y);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833356,
                "title": "java-jarvis-march-solution-graham-scan-beats-91-94",
                "content": "In this problem, we need to find the convex hull of all the *trees*. But the twist is that we also need to include the ***collinear*** points on the convex hull in our answer, which in most implementations are ignored as typical implementations find the minimum number of points for the convex hull.\\n\\n1. **Using Jarvis March Algorithm**\\nTo solve this we can store the *collinear point in a different list* and when the ***orientation*** changes we push the collinear points upto now in the answer *set*.\\nTime Complexity: `O(h*n)` where h is the number of points on the *convex hull*\\nSpace Complexity: `O(n)`\\nRuntime: `14ms`\\nBeats: `91.94%`\\n***Code:***  \\n```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n        Set<HullPoint> hull = new HashSet<>();\\n        List<HullPoint> collinear = new ArrayList<>();\\n        HullPoint[] a = new HullPoint[trees.length];\\n        for(int i=0;i<trees.length;i++) {\\n            //make a new array of hullpoint objects using trees array\\n            a[i] = new HullPoint(trees[i][0], trees[i][1]);\\n        }\\n        HullPoint curr = a[0];\\n        //find hullpoint with smallest x-coordinate\\n        for(int i=0;i<a.length;i++) {\\n            if(a[i].x < curr.x) {\\n                curr = a[i];\\n            }\\n        }\\n        //store the starting tree\\n        HullPoint start = curr;\\n        \\n        do {\\n            hull.add(curr);\\n            HullPoint next = a[0];\\n            for(int i=0;i<a.length;i++) {\\n                HullPoint point = a[i];\\n                if(point.equals(curr))\\n                    continue;\\n                int orientation = getOrientation(curr, next, point);\\n                //counter-clockwise or next == curr\\n                if(orientation > 0 || next.equals(curr)) {\\n                    next = point;\\n                    collinear.clear();\\n                }else if(orientation == 0) {//collinear\\n                    //set next to farthest point and push middle point to collinear list\\n                    if(getDistance(curr, next) < getDistance(curr, point)) {\\n                        collinear.add(next);\\n                        next = point;\\n                    }else {\\n                        collinear.add(point);\\n                    }\\n                }\\n            }\\n            //add collinear points to convex hull\\n            hull.addAll(collinear);\\n            curr = next;\\n        }while(!curr.equals(start) && hull.size() != a.length);\\n        \\n        //converting our set convex hull to required array output form\\n        int size = hull.size();\\n        List<HullPoint> temp = hull.stream().toList();\\n        int[][] ans = new int[size][2];\\n        \\n        for(int i=0;i<size;i++) {\\n            ans[i][0] = temp.get(i).x;\\n            ans[i][1] = temp.get(i).y;\\n        }\\n        return ans;\\n    }\\n    /**\\n    * Finds the orientation of three HullPoints\\n    */\\n    static int getOrientation(HullPoint start, HullPoint middle, HullPoint last) {\\n        int temp = (\\n            ((last.y - start.y) * (middle.x - start.x)) - \\n            ((middle.y - start.y) * (last.x - start.x))\\n            );\\n        return temp;    \\n    }\\n    /**\\n    * Finds the euclidean distance between two HullPoints\\n    */\\n    static double getDistance(HullPoint a, HullPoint b) {\\n        double distance = Math.sqrt(\\n            ((a.x - b.x) * (a.x - b.x)) + \\n            ((a.y - b.y) * (a.y - b.y))\\n            );\\n        return distance;\\n    }\\n    /**\\n    *User-Defined class for Convex HullPoints with their x and y coordinates\\n    */\\n    static class HullPoint {\\n        int x;\\n        int y;\\n        \\n        HullPoint(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        \\n        public boolean equals(HullPoint h) {\\n            return this.x == h.x && this.y == h.y;\\n        }\\n    }\\n}\\n```\\n\\n2. **Using Graham-Scan Algorithm**\\nTime Complexity: `O(n*log(n))` \\nSpace Complexity: `O(n)`\\nRuntime: `16ms`\\nBeats: `91.94%`\\n***Code:***\\n```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n        HullPoint[] a = new HullPoint[trees.length];\\n        for(int i=0;i<trees.length;i++) {\\n            //make a new array of hullpoint objects using trees array\\n            a[i] = new HullPoint(trees[i][0], trees[i][1]);\\n        }\\n        //Start with the tree with minimum y coordinate\\n        HullPoint[] start = {a[0]};\\n        for(int i=1;i<a.length;i++) {\\n            if(a[i].y < start[0].y) {\\n                start[0] = a[i];\\n            }\\n        }\\n        \\n        //Sort the points first on the basis of polar angle and then on the basis of distance from starting point\\n        Arrays.sort(a, (a1, a2) -> {\\n            int temp = getOrientation(start[0], a1, a2);\\n            if(temp < 0)\\n                return 1;\\n            else if(temp > 0)\\n                return -1;\\n            else\\n                return Double.compare(getDistance(a1, start[0]), getDistance(a2, start[0]));\\n        });\\n        \\n        ArrayDeque<HullPoint> ad = new ArrayDeque<>();\\n        //Find points with same polar angle as the last point\\n        int left = a.length - 1;\\n        while (left >= 0 && getOrientation(start[0], a[a.length - 1], a[left]) == 0) {\\n            left--;\\n        }\\n        left++;\\n        int right = a.length - 1;\\n        //reverse them\\n        while(left < right) {\\n            HullPoint temp = a[left];\\n            a[left] = a[right];\\n            a[right] = temp;\\n            left++;\\n            right--;\\n        }\\n        //typical graham-scan \\n        for(int i=0;i<a.length;i++) {\\n            while(ad.size() >= 2) {\\n                HullPoint last = ad.pop();\\n                HullPoint secondLast = ad.pop();\\n                \\n                if(getOrientation(secondLast, last, a[i]) < 0) {\\n                    ad.push(secondLast);\\n                }else {\\n                    ad.push(secondLast);\\n                    ad.push(last);\\n                    break;\\n                }\\n            }\\n            ad.push(a[i]);\\n        }\\n        //copy the stack to answer array\\n        int k = ad.size();\\n        int[][] ans = new int[k][2];\\n        k--;\\n        \\n        while(!ad.isEmpty()) {\\n            HullPoint h = ad.pop();\\n            ans[k][0] = h.x;\\n            ans[k][1] = h.y;\\n            k--;\\n        }\\n        return ans;\\n    }\\n    /**\\n    * Finds the orientation of three HullPoints\\n    */\\n    static int getOrientation(HullPoint start, HullPoint middle, HullPoint last) {\\n        int temp = (\\n            ((last.y - start.y) * (middle.x - start.x)) - \\n            ((middle.y - start.y) * (last.x - start.x))\\n            );\\n        return temp;    \\n    }\\n    /**\\n    * Finds the euclidean distance between two HullPoints\\n    */\\n    static double getDistance(HullPoint a, HullPoint b) {\\n        double distance = Math.sqrt(\\n            ((a.x - b.x) * (a.x - b.x)) + \\n            ((a.y - b.y) * (a.y - b.y))\\n            );\\n        return distance;\\n    }\\n    /**\\n    *User-Defined class for Convex HullPoints with their x and y coordinates\\n    */\\n    static class HullPoint {\\n        int x;\\n        int y;\\n        \\n        HullPoint(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        \\n        public boolean equals(HullPoint h) {\\n            return this.x == h.x && this.y == h.y;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n        Set<HullPoint> hull = new HashSet<>();\\n        List<HullPoint> collinear = new ArrayList<>();\\n        HullPoint[] a = new HullPoint[trees.length];\\n        for(int i=0;i<trees.length;i++) {\\n            //make a new array of hullpoint objects using trees array\\n            a[i] = new HullPoint(trees[i][0], trees[i][1]);\\n        }\\n        HullPoint curr = a[0];\\n        //find hullpoint with smallest x-coordinate\\n        for(int i=0;i<a.length;i++) {\\n            if(a[i].x < curr.x) {\\n                curr = a[i];\\n            }\\n        }\\n        //store the starting tree\\n        HullPoint start = curr;\\n        \\n        do {\\n            hull.add(curr);\\n            HullPoint next = a[0];\\n            for(int i=0;i<a.length;i++) {\\n                HullPoint point = a[i];\\n                if(point.equals(curr))\\n                    continue;\\n                int orientation = getOrientation(curr, next, point);\\n                //counter-clockwise or next == curr\\n                if(orientation > 0 || next.equals(curr)) {\\n                    next = point;\\n                    collinear.clear();\\n                }else if(orientation == 0) {//collinear\\n                    //set next to farthest point and push middle point to collinear list\\n                    if(getDistance(curr, next) < getDistance(curr, point)) {\\n                        collinear.add(next);\\n                        next = point;\\n                    }else {\\n                        collinear.add(point);\\n                    }\\n                }\\n            }\\n            //add collinear points to convex hull\\n            hull.addAll(collinear);\\n            curr = next;\\n        }while(!curr.equals(start) && hull.size() != a.length);\\n        \\n        //converting our set convex hull to required array output form\\n        int size = hull.size();\\n        List<HullPoint> temp = hull.stream().toList();\\n        int[][] ans = new int[size][2];\\n        \\n        for(int i=0;i<size;i++) {\\n            ans[i][0] = temp.get(i).x;\\n            ans[i][1] = temp.get(i).y;\\n        }\\n        return ans;\\n    }\\n    /**\\n    * Finds the orientation of three HullPoints\\n    */\\n    static int getOrientation(HullPoint start, HullPoint middle, HullPoint last) {\\n        int temp = (\\n            ((last.y - start.y) * (middle.x - start.x)) - \\n            ((middle.y - start.y) * (last.x - start.x))\\n            );\\n        return temp;    \\n    }\\n    /**\\n    * Finds the euclidean distance between two HullPoints\\n    */\\n    static double getDistance(HullPoint a, HullPoint b) {\\n        double distance = Math.sqrt(\\n            ((a.x - b.x) * (a.x - b.x)) + \\n            ((a.y - b.y) * (a.y - b.y))\\n            );\\n        return distance;\\n    }\\n    /**\\n    *User-Defined class for Convex HullPoints with their x and y coordinates\\n    */\\n    static class HullPoint {\\n        int x;\\n        int y;\\n        \\n        HullPoint(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        \\n        public boolean equals(HullPoint h) {\\n            return this.x == h.x && this.y == h.y;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n        HullPoint[] a = new HullPoint[trees.length];\\n        for(int i=0;i<trees.length;i++) {\\n            //make a new array of hullpoint objects using trees array\\n            a[i] = new HullPoint(trees[i][0], trees[i][1]);\\n        }\\n        //Start with the tree with minimum y coordinate\\n        HullPoint[] start = {a[0]};\\n        for(int i=1;i<a.length;i++) {\\n            if(a[i].y < start[0].y) {\\n                start[0] = a[i];\\n            }\\n        }\\n        \\n        //Sort the points first on the basis of polar angle and then on the basis of distance from starting point\\n        Arrays.sort(a, (a1, a2) -> {\\n            int temp = getOrientation(start[0], a1, a2);\\n            if(temp < 0)\\n                return 1;\\n            else if(temp > 0)\\n                return -1;\\n            else\\n                return Double.compare(getDistance(a1, start[0]), getDistance(a2, start[0]));\\n        });\\n        \\n        ArrayDeque<HullPoint> ad = new ArrayDeque<>();\\n        //Find points with same polar angle as the last point\\n        int left = a.length - 1;\\n        while (left >= 0 && getOrientation(start[0], a[a.length - 1], a[left]) == 0) {\\n            left--;\\n        }\\n        left++;\\n        int right = a.length - 1;\\n        //reverse them\\n        while(left < right) {\\n            HullPoint temp = a[left];\\n            a[left] = a[right];\\n            a[right] = temp;\\n            left++;\\n            right--;\\n        }\\n        //typical graham-scan \\n        for(int i=0;i<a.length;i++) {\\n            while(ad.size() >= 2) {\\n                HullPoint last = ad.pop();\\n                HullPoint secondLast = ad.pop();\\n                \\n                if(getOrientation(secondLast, last, a[i]) < 0) {\\n                    ad.push(secondLast);\\n                }else {\\n                    ad.push(secondLast);\\n                    ad.push(last);\\n                    break;\\n                }\\n            }\\n            ad.push(a[i]);\\n        }\\n        //copy the stack to answer array\\n        int k = ad.size();\\n        int[][] ans = new int[k][2];\\n        k--;\\n        \\n        while(!ad.isEmpty()) {\\n            HullPoint h = ad.pop();\\n            ans[k][0] = h.x;\\n            ans[k][1] = h.y;\\n            k--;\\n        }\\n        return ans;\\n    }\\n    /**\\n    * Finds the orientation of three HullPoints\\n    */\\n    static int getOrientation(HullPoint start, HullPoint middle, HullPoint last) {\\n        int temp = (\\n            ((last.y - start.y) * (middle.x - start.x)) - \\n            ((middle.y - start.y) * (last.x - start.x))\\n            );\\n        return temp;    \\n    }\\n    /**\\n    * Finds the euclidean distance between two HullPoints\\n    */\\n    static double getDistance(HullPoint a, HullPoint b) {\\n        double distance = Math.sqrt(\\n            ((a.x - b.x) * (a.x - b.x)) + \\n            ((a.y - b.y) * (a.y - b.y))\\n            );\\n        return distance;\\n    }\\n    /**\\n    *User-Defined class for Convex HullPoints with their x and y coordinates\\n    */\\n    static class HullPoint {\\n        int x;\\n        int y;\\n        \\n        HullPoint(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        \\n        public boolean equals(HullPoint h) {\\n            return this.x == h.x && this.y == h.y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828941,
                "title": "java-solution-using-graham-scan-with-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n       if(trees.length <= 3) \\n           return trees;\\n        Arrays.sort(trees, (a, b) -> {\\n            if(a[0] == b[0]) {\\n                return a[1] - b[1];\\n            } else {\\n                return a[0] - b[0];\\n        }\\n    });\\n     \\n        List<int[]> lower = new ArrayList<>();\\n        List<int[]> upper = new ArrayList<>();\\n        \\n        for(int[] tree: trees) {\\n            while(lower.size() >= 2 && compare(lower.get(lower.size() - 2), lower.get(lower.size() - 1), tree) > 0) {\\n                lower.remove(lower.size() - 1);\\n            }\\n            \\n            while(upper.size() >= 2 && compare(upper.get(upper.size() - 2), upper.get(upper.size() - 1), tree) < 0) {\\n                upper.remove(upper.size() - 1);\\n            }\\n            \\n            lower.add(tree);\\n            upper.add(tree);\\n        }\\n        \\n        Set<int[]> set = new HashSet<>();\\n        for(int[] l : lower) {\\n            set.add(l);\\n        }\\n        \\n        for(int[] u : upper) {\\n            set.add(u);\\n        }\\n        \\n        int[][] result = new int[set.size()][2];\\n        \\n        int index = 0;\\n        for(int[] s: set) {\\n            result[index++] = s;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // < 0: clockwise\\n    // > 0: counterclockwise\\n    // == 0 : collinear\\n    private int compare(int[] p1, int[] p2, int[] p3) {\\n        int x1 = p1[0];\\n        int y1 = p1[1];\\n        int x2 = p2[0];\\n        int y2 = p2[1];\\n        int x3 = p3[0];\\n        int y3 = p3[1];\\n        \\n        return (y3 - y2) * (x2 - x1) - (y2 - y1) * (x3 - x2);\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n       if(trees.length <= 3) \\n           return trees;\\n        Arrays.sort(trees, (a, b) -> {\\n            if(a[0] == b[0]) {\\n                return a[1] - b[1];\\n            } else {\\n                return a[0] - b[0];\\n        }\\n    });\\n     \\n        List<int[]> lower = new ArrayList<>();\\n        List<int[]> upper = new ArrayList<>();\\n        \\n        for(int[] tree: trees) {\\n            while(lower.size() >= 2 && compare(lower.get(lower.size() - 2), lower.get(lower.size() - 1), tree) > 0) {\\n                lower.remove(lower.size() - 1);\\n            }\\n            \\n            while(upper.size() >= 2 && compare(upper.get(upper.size() - 2), upper.get(upper.size() - 1), tree) < 0) {\\n                upper.remove(upper.size() - 1);\\n            }\\n            \\n            lower.add(tree);\\n            upper.add(tree);\\n        }\\n        \\n        Set<int[]> set = new HashSet<>();\\n        for(int[] l : lower) {\\n            set.add(l);\\n        }\\n        \\n        for(int[] u : upper) {\\n            set.add(u);\\n        }\\n        \\n        int[][] result = new int[set.size()][2];\\n        \\n        int index = 0;\\n        for(int[] s: set) {\\n            result[index++] = s;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // < 0: clockwise\\n    // > 0: counterclockwise\\n    // == 0 : collinear\\n    private int compare(int[] p1, int[] p2, int[] p3) {\\n        int x1 = p1[0];\\n        int y1 = p1[1];\\n        int x2 = p2[0];\\n        int y2 = p2[1];\\n        int x3 = p3[0];\\n        int y3 = p3[1];\\n        \\n        return (y3 - y2) * (x2 - x1) - (y2 - y1) * (x3 - x2);\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828937,
                "title": "python3-graham-s-scan-method",
                "content": "```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        \\n\\n        def check_clockwise(p1,p2,p3):\\n            \\n            x1,y1 = p1\\n            x2,y2 = p2\\n            x3,y3 = p3\\n            \"\"\"\\n            slope of p1 and p2 will be y2-y1/x2-x1\\n            \\n            slope of p2 and p3 will be y3-y2/x3-x2\\n            \\n            combining them both gives\\n            \\n            y3-y2/x3-x2   -   y2-y1/x2-x1 \\n            \\n            this eqn represents the resultant formed by those two\\n            if this is greater than 0 then direction will be counter clockwise else clockwise\\n            \"\"\"\\n            return (y3-y2)*(x2-x1)-(y2-y1)*(x3-x2) #return <0 if clockwise\\n        \\n        \\n        trees.sort()\\n        upper = []\\n        lower = []\\n        \\n        for t in trees:\\n            \\n            while len(upper)>1 and check_clockwise(upper[-1],upper[-2],t)>0:\\n                upper.pop()\\n            \\n            while len(lower)>1 and check_clockwise(lower[-1],lower[-2],t)<0:\\n                lower.pop()\\n            \\n            upper.append(tuple(t))\\n            lower.append(tuple(t))\\n        \\n        return list(set(upper+lower))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        \\n\\n        def check_clockwise(p1,p2,p3):\\n            \\n            x1,y1 = p1\\n            x2,y2 = p2\\n            x3,y3 = p3\\n            \"\"\"\\n            slope of p1 and p2 will be y2-y1/x2-x1\\n            \\n            slope of p2 and p3 will be y3-y2/x3-x2\\n            \\n            combining them both gives\\n            \\n            y3-y2/x3-x2   -   y2-y1/x2-x1 \\n            \\n            this eqn represents the resultant formed by those two\\n            if this is greater than 0 then direction will be counter clockwise else clockwise\\n            \"\"\"\\n            return (y3-y2)*(x2-x1)-(y2-y1)*(x3-x2) #return <0 if clockwise\\n        \\n        \\n        trees.sort()\\n        upper = []\\n        lower = []\\n        \\n        for t in trees:\\n            \\n            while len(upper)>1 and check_clockwise(upper[-1],upper[-2],t)>0:\\n                upper.pop()\\n            \\n            while len(lower)>1 and check_clockwise(lower[-1],lower[-2],t)<0:\\n                lower.pop()\\n            \\n            upper.append(tuple(t))\\n            lower.append(tuple(t))\\n        \\n        return list(set(upper+lower))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828875,
                "title": "clean-code",
                "content": "```\\nvar outerTrees = function(trees) {\\n    function cmp (p1, p2, p3) {\\n        let [x1, y1] = p1;\\n        let [x2, y2] = p2;\\n        let [x3, y3] = p3;\\n        return (y3 - y2)*(x2 - x1) - (y2 - y1)*(x3 - x2);\\n    }\\n    \\n    trees.sort((a, b)=> {\\n        let diff = a[0] - b[0];\\n        if (diff === 0) return a[1] - b[1];\\n        return diff});\\n    \\n    const upper = [];\\n    const lower = [];\\n    \\n    for (let point of trees) {\\n        while (lower.length > 1 && cmp(lower[lower.length - 2], lower[lower.length - 1], point) > 0) {\\n            lower.pop()\\n        }\\n         while (upper.length > 1 && cmp(upper[upper.length - 2], upper[upper.length - 1], point) < 0) {\\n            upper.pop()\\n        }\\n        upper.push(point);\\n        lower.push(point);\\n    }\\n    \\n    return Array.from(new Set(upper.concat(lower)))\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar outerTrees = function(trees) {\\n    function cmp (p1, p2, p3) {\\n        let [x1, y1] = p1;\\n        let [x2, y2] = p2;\\n        let [x3, y3] = p3;\\n        return (y3 - y2)*(x2 - x1) - (y2 - y1)*(x3 - x2);\\n    }\\n    \\n    trees.sort((a, b)=> {\\n        let diff = a[0] - b[0];\\n        if (diff === 0) return a[1] - b[1];\\n        return diff});\\n    \\n    const upper = [];\\n    const lower = [];\\n    \\n    for (let point of trees) {\\n        while (lower.length > 1 && cmp(lower[lower.length - 2], lower[lower.length - 1], point) > 0) {\\n            lower.pop()\\n        }\\n         while (upper.length > 1 && cmp(upper[upper.length - 2], upper[upper.length - 1], point) < 0) {\\n            upper.pop()\\n        }\\n        upper.push(point);\\n        lower.push(point);\\n    }\\n    \\n    return Array.from(new Set(upper.concat(lower)))\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2828682,
                "title": "daily-leetcoding-challenge-november-day-19",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/erect-the-fence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Jarvis Algorithm\n\n  \n**Approach 2:** Graham Scan\n\n  \n**Approach 3:** Monotone Chain\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/erect-the-fence/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1099952,
                "title": "c-48ms-93-time-onlogn-my-idea-large-code",
                "content": "Runtime: 48 ms, faster than 93.18% of C++ online submissions for Erect the Fence.\\nMemory Usage: 25.1 MB, less than 39.77% of C++ online submissions for Erect the Fence.\\n![image](https://assets.leetcode.com/users/images/8f269742-307a-4358-9c7f-34dc6ad143c3_1615221221.7002864.png)\\n\\n**General Idea :**\\n**From the course in analytical geometry on a plane, we know that the most convex polygon has the largest coverage area and the largest perimeter: the idea of the solution is to find the smallest rectangle containing all points (with sides parallel to the coordinate axes), and by the method of successive approximation, construct convex curves at the corners of this rectangle.**\\n**1** we put all vertex into set vert < pair<x of vertex, y of vertex >> and in the same time will find maximum(h) and minimum(b) y (and retain x coordinates for this numbers in sets tmpxu and tmpxd) . After traversal we have in tmpxu and tmpxd all vertex for maximum(h) and minimum(b)   and  we put it into perim (where perim is answer) if h == b we have case where Fence is horizontal line. \\n**2** Create set for all 8 apexes of our poligonal figure (because we have cases where some of this apexes wont present ) \\n**3** After traversal into begining of set vert we will have all vertex from maximum and minimum x coordinates so we will know all apexes for our poligonal figure\\n**4**And after this we will 4 traversal (I explain first from (xl,lup) to(hl,h))\\na. first we consider have we this case in our poligonal figure or not ?\\n   if(itl->first < hl && itl->second < h) if not we dont consider this case if yes :\\n   construct point (xxx,yyy) - this point in this traversal will be work point and for beginning it have coordinates (xl, lup) we fetch next point from our set and will view will be this fetched point higher or lower for line from (xxx,yyy) - (hl,h). for this purpose we use equation of line (x - x1)(x2 - x1) - (y - y1)(y2 - y1) (if answer for this temp point < 0 point below line if > 0 point under line). If point under line we also view previous point for it (and if previous point not sutusfact us we push previous point and so etc).\\n   \\n   **And This idea can be improve till time On , but code for it will be VERY LARGE. but I wrote this for task where I was asked to write programm for culculate area of very large poligonal figur\\u0443 (because my method can calculate area and perimeter of this poligonal for VERY MANY points with time that have time On * k, where constant k isn\\'t large ). And if some of You is interested with tasks of this sorts I with pleasure share my information**\\n```\\nclass Solution {\\npublic:\\n  vector <vector<int>> MaxPerimetr(vector<vector<int>> &points){\\n    int h = INT_MIN,hl = INT_MAX, hr = INT_MIN, b = INT_MAX, bl = INT_MAX, br = INT_MIN;       \\n    multiset<pair<int,int>> vert;\\n    vector<vector<int>> perim;\\n    set<pair<int,int>> apex;\\n    set<int> tmpxu,tmpxd;\\n    \\n///////////////////////////////// first part    \\n    for(auto i : points){                                       \\n      vert.insert({i[0],i[1]});\\n      if(h < i[1]) {h = i[1];tmpxu.clear();tmpxu.insert(i[0]);}\\n      else {if(h == i[1]) tmpxu.insert(i[0]);}\\n      if(b > i[1]) {b = i[1];tmpxd.clear();tmpxd.insert(i[0]);}\\n      else if(b == i[1]) tmpxd.insert(i[0]);\\n    }\\n    \\n    auto itxl = tmpxu.begin(); hl = *itxl;\\n    auto itxr = tmpxu.end(); itxr--; hr = *itxr;\\n    apex.insert({hl,h});apex.insert({hr,h});\\n    itxl++;\\n    if(tmpxu.size() > 2)\\n      for(;itxl != itxr;itxl++) perim.push_back({*itxl,h});      //between hl -> hr\\n    \\n    if(h == b){\\n      perim.push_back({hl,h});\\n      perim.push_back({hr,h});\\n      return perim;\\n    }\\n    \\n    itxl = tmpxd.begin();bl = *itxl;\\n    itxr = tmpxd.end(); itxr--; br = *itxr;\\n    apex.insert({bl,b});apex.insert({br,b});\\n    itxl++;\\n    if(tmpxd.size() > 2)\\n      for(;itxl != itxr;itxl++) perim.push_back({*itxl,b});             //between bl -> br\\n\\n    \\n//////////////////////////////////////////////////////////////// second part     \\n    multiset<pair<int,int>>::iterator itl = vert.begin(); \\n    int lbo = itl->second ,lup = itl->second, xl = itl->first;\\n    apex.insert({xl,lbo});itl++;\\n    \\n    int step = 0;\\n    for(;itl->first == xl; itl++,step++) perim.push_back({xl,itl->second});\\n    if(step)  {lup = perim[perim.size()-1][1];perim.pop_back();}          //xl,lup  --->  hl , h\\n    apex.insert({xl,lup});\\n    \\n    \\n    multiset<pair<int,int>>::iterator itl2 = itl;\\n\\n    int dx, dy, xxx, yyy, idx;\\n    \\n    if(itl->first < hl && itl->second < h){\\n      dx = hl - xl, dy = h - lup, xxx = xl, yyy = lup, idx = perim.size() - 1;\\n      \\n      for(;itl->second != h;itl++)\\n        if(itl->second > yyy)\\n          if(dx*(itl->second - yyy) - dy*(itl->first - xxx) >= 0){\\n            xxx = itl->first, yyy = itl->second;\\n            dx = hl - xxx, dy = h - yyy;\\n            for(int j = perim.size() - 1; j > idx; j--)\\n              if(j - 1 > idx){\\n                if((perim[j][1] - perim[j-1][1])*(xxx - perim[j-1][0]) - \\n                  (perim[j][0] -perim[j-1][0])*(yyy - perim[j-1][1]) < 0) perim.pop_back();\\n                else break;\\n              }else if((perim[j][1] - lup)*(xxx - xl) - \\n                (perim[j][0] - xl)*(yyy - lup) < 0) perim.pop_back();\\n                    else break;\\n            perim.push_back({itl->first,itl->second});       \\n          }\\n    }  \\n   \\n    multiset<pair<int,int>>::reverse_iterator itr = vert.rbegin();\\n    int rbo = itr->second,  rup = itr->second, xr = itr->first;\\n    apex.insert({xr,rup});itr++;\\n    \\n    step = 0;\\n    for(;itr->first == xr; itr++,step++) perim.push_back({xr,itr->second});\\n    if(step)  {rbo = perim[perim.size()-1][1];perim.pop_back();}    //xr,lup  --->  hl , h\\n    apex.insert({xr,rbo});\\n  \\n    \\n    if(itl2->first < bl && itl2->second > b){\\n      dx = bl - xl, dy = b - lbo, xxx = xl, yyy = lbo, idx = perim.size() - 1;\\n    \\n      for(;itl2->second != b ;itl2++)\\n        if(itl2->second < yyy)\\n          if(dx*(itl2->second - yyy) - dy*(itl2->first - xxx) <= 0){\\n            xxx = itl2->first, yyy = itl2->second;\\n            dx = bl - xxx, dy = b - yyy;\\n            for(int j = perim.size() - 1; j > idx; j--)\\n              if(j - 1 > idx){\\n                if((perim[j][1] - perim[j-1][1])*(xxx - perim[j-1][0]) - \\n                  (perim[j][0] -perim[j-1][0])*(yyy - perim[j-1][1]) > 0) perim.pop_back();\\n                else break;\\n              }else if((perim[j][1] - lbo)*(xxx - xl) - \\n                  (perim[j][0] - xl)*(yyy - lbo) > 0) perim.pop_back();\\n                  else break;\\n            perim.push_back({itl2->first,itl2->second});       \\n          }\\n    }  \\n    \\n///////////////////////////////////////////////////////////////////////third part\\n    multiset<pair<int,int>>::reverse_iterator itr2 = itr;\\n   \\n    if(itr->first > hr && itr->second < h){\\n      dx = hr - xr, dy = h - rup, xxx = xr, yyy = rup, idx = perim.size() - 1;\\n    \\n      for(;itr->second != h;itr++)\\n        if(itr->second > yyy)\\n          if(dx*(itr->second - yyy) - dy*(itr->first - xxx) <= 0){\\n            xxx = itr->first, yyy = itr->second;\\n            dx = hr - xxx, dy = h - yyy;\\n            for(int j = perim.size() - 1; j > idx; j--)\\n              if(j - 1 > idx){\\n                if((perim[j][1] - perim[j-1][1])*(xxx - perim[j-1][0]) - \\n                  (perim[j][0] -perim[j-1][0])*(yyy - perim[j-1][1]) > 0) perim.pop_back();\\n                else break;\\n              }else if((perim[j][1] - rup)*(xxx - xr) - \\n                  (perim[j][0] - xr)*(yyy - rup) > 0) perim.pop_back();\\n                  else break;\\n            perim.push_back({itr->first,itr->second});       \\n        }\\n    }\\n\\n    \\n    if(itr2->first > br && itr2->second > b){\\n      dx = br - xr, dy = b - rbo, xxx = xr, yyy = rbo, idx = perim.size() - 1;\\n    \\n      for(;itr2->second != b;itr2++)\\n        if(itr2->second < yyy)\\n          if(dx*(itr2->second - yyy) - dy*(itr2->first - xxx) >= 0){\\n            xxx = itr2->first, yyy = itr2->second;\\n            dx = br - xxx, dy = b - yyy;\\n            for(int j = perim.size() - 1; j > idx; j--)\\n              if(j - 1 > idx){\\n                if((perim[j][1] - perim[j-1][1])*(xxx - perim[j-1][0]) - \\n                  (perim[j][0] -perim[j-1][0])*(yyy - perim[j-1][1]) < 0) perim.pop_back();\\n                else break;\\n              }else if((perim[j][1] - rbo)*(xxx - xr) - \\n                  (perim[j][0] - xr)*(yyy - rbo) < 0) perim.pop_back();\\n                else break;\\n            perim.push_back({itr2->first,itr2->second});       \\n        }\\n    }\\n    \\n    \\n    for(auto i : apex) perim.push_back({i.first,i.second});\\n    return perim;\\n  }\\n  \\n  \\n  vector<vector<int>> outerTrees(vector<vector<int>>& points) {\\n      if(points.size() < 4) return points ;\\n    return MaxPerimetr(points);\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector <vector<int>> MaxPerimetr(vector<vector<int>> &points){\\n    int h = INT_MIN,hl = INT_MAX, hr = INT_MIN, b = INT_MAX, bl = INT_MAX, br = INT_MIN;       \\n    multiset<pair<int,int>> vert;\\n    vector<vector<int>> perim;\\n    set<pair<int,int>> apex;\\n    set<int> tmpxu,tmpxd;\\n    \\n///////////////////////////////// first part    \\n    for(auto i : points){                                       \\n      vert.insert({i[0],i[1]});\\n      if(h < i[1]) {h = i[1];tmpxu.clear();tmpxu.insert(i[0]);}\\n      else {if(h == i[1]) tmpxu.insert(i[0]);}\\n      if(b > i[1]) {b = i[1];tmpxd.clear();tmpxd.insert(i[0]);}\\n      else if(b == i[1]) tmpxd.insert(i[0]);\\n    }\\n    \\n    auto itxl = tmpxu.begin(); hl = *itxl;\\n    auto itxr = tmpxu.end(); itxr--; hr = *itxr;\\n    apex.insert({hl,h});apex.insert({hr,h});\\n    itxl++;\\n    if(tmpxu.size() > 2)\\n      for(;itxl != itxr;itxl++) perim.push_back({*itxl,h});      //between hl -> hr\\n    \\n    if(h == b){\\n      perim.push_back({hl,h});\\n      perim.push_back({hr,h});\\n      return perim;\\n    }\\n    \\n    itxl = tmpxd.begin();bl = *itxl;\\n    itxr = tmpxd.end(); itxr--; br = *itxr;\\n    apex.insert({bl,b});apex.insert({br,b});\\n    itxl++;\\n    if(tmpxd.size() > 2)\\n      for(;itxl != itxr;itxl++) perim.push_back({*itxl,b});             //between bl -> br\\n\\n    \\n//////////////////////////////////////////////////////////////// second part     \\n    multiset<pair<int,int>>::iterator itl = vert.begin(); \\n    int lbo = itl->second ,lup = itl->second, xl = itl->first;\\n    apex.insert({xl,lbo});itl++;\\n    \\n    int step = 0;\\n    for(;itl->first == xl; itl++,step++) perim.push_back({xl,itl->second});\\n    if(step)  {lup = perim[perim.size()-1][1];perim.pop_back();}          //xl,lup  --->  hl , h\\n    apex.insert({xl,lup});\\n    \\n    \\n    multiset<pair<int,int>>::iterator itl2 = itl;\\n\\n    int dx, dy, xxx, yyy, idx;\\n    \\n    if(itl->first < hl && itl->second < h){\\n      dx = hl - xl, dy = h - lup, xxx = xl, yyy = lup, idx = perim.size() - 1;\\n      \\n      for(;itl->second != h;itl++)\\n        if(itl->second > yyy)\\n          if(dx*(itl->second - yyy) - dy*(itl->first - xxx) >= 0){\\n            xxx = itl->first, yyy = itl->second;\\n            dx = hl - xxx, dy = h - yyy;\\n            for(int j = perim.size() - 1; j > idx; j--)\\n              if(j - 1 > idx){\\n                if((perim[j][1] - perim[j-1][1])*(xxx - perim[j-1][0]) - \\n                  (perim[j][0] -perim[j-1][0])*(yyy - perim[j-1][1]) < 0) perim.pop_back();\\n                else break;\\n              }else if((perim[j][1] - lup)*(xxx - xl) - \\n                (perim[j][0] - xl)*(yyy - lup) < 0) perim.pop_back();\\n                    else break;\\n            perim.push_back({itl->first,itl->second});       \\n          }\\n    }  \\n   \\n    multiset<pair<int,int>>::reverse_iterator itr = vert.rbegin();\\n    int rbo = itr->second,  rup = itr->second, xr = itr->first;\\n    apex.insert({xr,rup});itr++;\\n    \\n    step = 0;\\n    for(;itr->first == xr; itr++,step++) perim.push_back({xr,itr->second});\\n    if(step)  {rbo = perim[perim.size()-1][1];perim.pop_back();}    //xr,lup  --->  hl , h\\n    apex.insert({xr,rbo});\\n  \\n    \\n    if(itl2->first < bl && itl2->second > b){\\n      dx = bl - xl, dy = b - lbo, xxx = xl, yyy = lbo, idx = perim.size() - 1;\\n    \\n      for(;itl2->second != b ;itl2++)\\n        if(itl2->second < yyy)\\n          if(dx*(itl2->second - yyy) - dy*(itl2->first - xxx) <= 0){\\n            xxx = itl2->first, yyy = itl2->second;\\n            dx = bl - xxx, dy = b - yyy;\\n            for(int j = perim.size() - 1; j > idx; j--)\\n              if(j - 1 > idx){\\n                if((perim[j][1] - perim[j-1][1])*(xxx - perim[j-1][0]) - \\n                  (perim[j][0] -perim[j-1][0])*(yyy - perim[j-1][1]) > 0) perim.pop_back();\\n                else break;\\n              }else if((perim[j][1] - lbo)*(xxx - xl) - \\n                  (perim[j][0] - xl)*(yyy - lbo) > 0) perim.pop_back();\\n                  else break;\\n            perim.push_back({itl2->first,itl2->second});       \\n          }\\n    }  \\n    \\n///////////////////////////////////////////////////////////////////////third part\\n    multiset<pair<int,int>>::reverse_iterator itr2 = itr;\\n   \\n    if(itr->first > hr && itr->second < h){\\n      dx = hr - xr, dy = h - rup, xxx = xr, yyy = rup, idx = perim.size() - 1;\\n    \\n      for(;itr->second != h;itr++)\\n        if(itr->second > yyy)\\n          if(dx*(itr->second - yyy) - dy*(itr->first - xxx) <= 0){\\n            xxx = itr->first, yyy = itr->second;\\n            dx = hr - xxx, dy = h - yyy;\\n            for(int j = perim.size() - 1; j > idx; j--)\\n              if(j - 1 > idx){\\n                if((perim[j][1] - perim[j-1][1])*(xxx - perim[j-1][0]) - \\n                  (perim[j][0] -perim[j-1][0])*(yyy - perim[j-1][1]) > 0) perim.pop_back();\\n                else break;\\n              }else if((perim[j][1] - rup)*(xxx - xr) - \\n                  (perim[j][0] - xr)*(yyy - rup) > 0) perim.pop_back();\\n                  else break;\\n            perim.push_back({itr->first,itr->second});       \\n        }\\n    }\\n\\n    \\n    if(itr2->first > br && itr2->second > b){\\n      dx = br - xr, dy = b - rbo, xxx = xr, yyy = rbo, idx = perim.size() - 1;\\n    \\n      for(;itr2->second != b;itr2++)\\n        if(itr2->second < yyy)\\n          if(dx*(itr2->second - yyy) - dy*(itr2->first - xxx) >= 0){\\n            xxx = itr2->first, yyy = itr2->second;\\n            dx = br - xxx, dy = b - yyy;\\n            for(int j = perim.size() - 1; j > idx; j--)\\n              if(j - 1 > idx){\\n                if((perim[j][1] - perim[j-1][1])*(xxx - perim[j-1][0]) - \\n                  (perim[j][0] -perim[j-1][0])*(yyy - perim[j-1][1]) < 0) perim.pop_back();\\n                else break;\\n              }else if((perim[j][1] - rbo)*(xxx - xr) - \\n                  (perim[j][0] - xr)*(yyy - rbo) < 0) perim.pop_back();\\n                else break;\\n            perim.push_back({itr2->first,itr2->second});       \\n        }\\n    }\\n    \\n    \\n    for(auto i : apex) perim.push_back({i.first,i.second});\\n    return perim;\\n  }\\n  \\n  \\n  vector<vector<int>> outerTrees(vector<vector<int>>& points) {\\n      if(points.size() < 4) return points ;\\n    return MaxPerimetr(points);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478387,
                "title": "python-simple-and-intuitive-solution-nlogn-15-lines",
                "content": "```python\\nfrom fractions import Fraction\\n\\ndef outerTrees(self, points: List[List[int]]) -> List[List[int]]:\\n\\n\\tdef slope(a, b):\\n\\t\\tnum, denom = b[1] - a[1], b[0] - a[0]\\n\\t\\treturn Fraction(num, denom) if denom else float(\"inf\")\\n\\n\\tdef hull(pts, comp=operator.lt):\\n\\t\\thull = [pts[0]]\\n\\t\\tfor pt in pts[1:]:\\n\\t\\t\\tprev = hull.pop()\\n\\t\\t\\twhile hull and comp(slope(hull[-1], prev), slope(prev, pt)):\\n\\t\\t\\t\\tprev = hull.pop()\\n\\t\\t\\thull.extend([prev, pt])\\n\\t\\treturn hull\\n\\n\\tpoints.sort()\\n\\tupper_hull = hull(points)\\n\\tlower_hull = hull(points, operator.gt)\\n\\treturn set(map(tuple, lower_hull + upper_hull))\\n```\\n\\nIf we imagine the tangent line to the convex polygon, as it moves from edge to edge clockwise, it must also rotate clockwise. We can encode this by saying the slope of the tangent line must always decrease for the upper hull, and increase for the lower hull. Returning `float(\"inf\")` if the points are vertical works out nicely because a) you can compare it with fractions and b) it gives the right result for both upper and lower hull since the points will also be sorted by increasing y co-ordinate.\\n\\nThus, we can keep a resultant array that is kept in decreasing slope order, and when we add a new point we delete all the points in the array that invalidate this order. It is `O(nlogn)` because the time for sorting dominates the time for processing the hull (which is `O(n)`, since we process each point at most 2 times (one for adding it and one for deleting it)).",
                "solutionTags": [],
                "code": "```python\\nfrom fractions import Fraction\\n\\ndef outerTrees(self, points: List[List[int]]) -> List[List[int]]:\\n\\n\\tdef slope(a, b):\\n\\t\\tnum, denom = b[1] - a[1], b[0] - a[0]\\n\\t\\treturn Fraction(num, denom) if denom else float(\"inf\")\\n\\n\\tdef hull(pts, comp=operator.lt):\\n\\t\\thull = [pts[0]]\\n\\t\\tfor pt in pts[1:]:\\n\\t\\t\\tprev = hull.pop()\\n\\t\\t\\twhile hull and comp(slope(hull[-1], prev), slope(prev, pt)):\\n\\t\\t\\t\\tprev = hull.pop()\\n\\t\\t\\thull.extend([prev, pt])\\n\\t\\treturn hull\\n\\n\\tpoints.sort()\\n\\tupper_hull = hull(points)\\n\\tlower_hull = hull(points, operator.gt)\\n\\treturn set(map(tuple, lower_hull + upper_hull))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 477986,
                "title": "accepted-c-solution-jarvis-algorithm-impl",
                "content": "```\\n    public class Solution\\n    {\\n        private static int CalculateOrientation((int, int) p, (int, int) q, (int, int) r)\\n        {\\n            int val = (q.Item2 - p.Item2) * (r.Item1 - q.Item1) -\\n                      (q.Item1 - p.Item1) * (r.Item2 - q.Item2);\\n            if (val == 0)\\n            {\\n                return 0; // collinear \\n            }\\n\\n            return (val > 0) ? 1 : 2; // clock or counterclock wise\\n        }\\n\\n        private static ISet<(int, int)> Jarvis(IList<(int, int)> points)\\n        {\\n            if (points.Count < 3)\\n            {\\n                return new HashSet<(int, int)>();\\n            }\\n\\n            ISet<(int, int)> res = new HashSet<(int, int)>();\\n\\n\\n            int leftmostPointIdx = 0;\\n            for (int i = 1; i < points.Count; i++)\\n            {\\n                if (points[i].Item1 < points[leftmostPointIdx].Item1)\\n                {\\n                    leftmostPointIdx = i;\\n                }\\n            }\\n\\n            int idx = leftmostPointIdx;\\n            do\\n            {\\n                int next = (idx + 1) % points.Count;\\n\\n                for (int i = 0; i < points.Count; i++)\\n                {\\n                    if (CalculateOrientation(points[idx], points[i], points[next]) == 2)\\n                    {\\n                        next = i;\\n                    }\\n                }\\n\\n                for (int i = 0; i < points.Count; i++)\\n                {\\n                    if (CalculateOrientation(points[idx], points[i], points[next]) == 0)\\n                    {\\n                        res.Add(points[i]);\\n                    }\\n                }\\n\\n\\n                idx = next;\\n\\n            } while (idx != leftmostPointIdx);\\n\\n            return res;\\n        }\\n\\n        public int[][] OuterTrees(int[][] points)\\n        {\\n            if (points.Length <= 3)\\n            {\\n                return points;\\n            }\\n\\n            return Jarvis(points.Select(p => (p[0], p[1])).ToList())\\n                .Select(p => new[] { p.Item1, p.Item2 }).ToArray();\\n        } \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        private static int CalculateOrientation((int, int) p, (int, int) q, (int, int) r)\\n        {\\n            int val = (q.Item2 - p.Item2) * (r.Item1 - q.Item1) -\\n                      (q.Item1 - p.Item1) * (r.Item2 - q.Item2);\\n            if (val == 0)\\n            {\\n                return 0; // collinear \\n            }\\n\\n            return (val > 0) ? 1 : 2; // clock or counterclock wise\\n        }\\n\\n        private static ISet<(int, int)> Jarvis(IList<(int, int)> points)\\n        {\\n            if (points.Count < 3)\\n            {\\n                return new HashSet<(int, int)>();\\n            }\\n\\n            ISet<(int, int)> res = new HashSet<(int, int)>();\\n\\n\\n            int leftmostPointIdx = 0;\\n            for (int i = 1; i < points.Count; i++)\\n            {\\n                if (points[i].Item1 < points[leftmostPointIdx].Item1)\\n                {\\n                    leftmostPointIdx = i;\\n                }\\n            }\\n\\n            int idx = leftmostPointIdx;\\n            do\\n            {\\n                int next = (idx + 1) % points.Count;\\n\\n                for (int i = 0; i < points.Count; i++)\\n                {\\n                    if (CalculateOrientation(points[idx], points[i], points[next]) == 2)\\n                    {\\n                        next = i;\\n                    }\\n                }\\n\\n                for (int i = 0; i < points.Count; i++)\\n                {\\n                    if (CalculateOrientation(points[idx], points[i], points[next]) == 0)\\n                    {\\n                        res.Add(points[i]);\\n                    }\\n                }\\n\\n\\n                idx = next;\\n\\n            } while (idx != leftmostPointIdx);\\n\\n            return res;\\n        }\\n\\n        public int[][] OuterTrees(int[][] points)\\n        {\\n            if (points.Length <= 3)\\n            {\\n                return points;\\n            }\\n\\n            return Jarvis(points.Select(p => (p[0], p[1])).ToList())\\n                .Select(p => new[] { p.Item1, p.Item2 }).ToArray();\\n        } \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302429,
                "title": "587-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create an empty list hull to store the points on the hull.\\n2. Sort the trees list by x-coordinate first, and then y-coordinate (in case of ties).\\n3. Define a helper function cross that takes three points as input and returns the cross product of the vectors formed by the three points.\\n4. Build the lower hull using a left-to-right scan. For each point tree in trees, check if the last two points in hull and tree form a right turn (i.e., if the cross product of the two vectors is negative). If they do, remove the second-to-last point in hull and repeat until the last two points in hull and tree form a left turn (i.e., if the cross product of the two vectors is non-negative). Finally, add tree to hull.\\n5. Build the upper hull using a right-to-left scan. For each point tree in trees (in reverse order), check if the last two points in hull and tree form a right turn (i.e., if the cross product of the two vectors is negative). If they do, remove the second-to-last point in hull and repeat until the last two points in hull and tree form a left turn (i.e., if the cross product of the two vectors is non-negative). Finally, add tree to hull.\\n6. Remove duplicates from hull and return it as a list of lists.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        hull = []\\n\\n        # Sort trees by x-coordinate first, and then y-coordinate (in case of ties)\\n        trees.sort(key=lambda x: (x[0], x[1]))\\n\\n        def cross(p: List[int], q: List[int], r: List[int]) -> int:\\n            # Simplify the cross product calculation using tuple unpacking\\n            px, py = p\\n            qx, qy = q\\n            rx, ry = r\\n            return (qy - py) * (rx - qx) - (qx - px) * (ry - qy)\\n\\n        # Build lower hull: left-to-right scan\\n        for tree in trees:\\n            # Use a while loop instead of a for loop to simplify the code\\n            while len(hull) > 1 and cross(hull[-2], hull[-1], tree) < 0:\\n                hull.pop()\\n            hull.append(tree)\\n\\n        # Build upper hull: right-to-left scan\\n        for tree in reversed(trees):\\n            while len(hull) > 1 and cross(hull[-2], hull[-1], tree) < 0:\\n                hull.pop()\\n            hull.append(tree)\\n\\n        # Remove duplicates and return the hull as a list of lists\\n        return [list(x) for x in set(tuple(x) for x in hull)]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        hull = []\\n\\n        # Sort trees by x-coordinate first, and then y-coordinate (in case of ties)\\n        trees.sort(key=lambda x: (x[0], x[1]))\\n\\n        def cross(p: List[int], q: List[int], r: List[int]) -> int:\\n            # Simplify the cross product calculation using tuple unpacking\\n            px, py = p\\n            qx, qy = q\\n            rx, ry = r\\n            return (qy - py) * (rx - qx) - (qx - px) * (ry - qy)\\n\\n        # Build lower hull: left-to-right scan\\n        for tree in trees:\\n            # Use a while loop instead of a for loop to simplify the code\\n            while len(hull) > 1 and cross(hull[-2], hull[-1], tree) < 0:\\n                hull.pop()\\n            hull.append(tree)\\n\\n        # Build upper hull: right-to-left scan\\n        for tree in reversed(trees):\\n            while len(hull) > 1 and cross(hull[-2], hull[-1], tree) < 0:\\n                hull.pop()\\n            hull.append(tree)\\n\\n        # Remove duplicates and return the hull as a list of lists\\n        return [list(x) for x in set(tuple(x) for x in hull)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830913,
                "title": "javascript-solution-faster-than-100-of-javascript-submissions-monotone-chain-algorithm",
                "content": "```\\n/**\\n * @param {number[]} a\\n * @param {number[]} b\\n * @param {number[]} o\\n * @return {number}\\n */\\nvar cross = (a, b, o) => {\\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\\n}\\n\\n/**\\n * @param {number[][]} trees\\n * @return {number[][]}\\n */\\nvar convexHull = (trees) => {\\n    trees.sort((a, b) => {\\n      return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\\n   });\\n\\n   let lower = [];\\n   for (let point of trees) {\\n      while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], point) > 0) {\\n         lower.pop();\\n      }\\n      lower.push(point);\\n   }\\n\\n   let upper = [];\\n   for (let point of trees.reverse()) {\\n      while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], point) > 0) {\\n         upper.pop();\\n      }\\n      upper.push(point);\\n   }\\n\\n   return lower.concat(upper);\\n}\\n\\n/**\\n * @param {number[][]} trees\\n * @return {number[][]}\\n */\\nvar outerTrees = function(trees) {\\n    if (trees.length == 1)\\n        return trees;\\n    \\n    return [... new Set(convexHull(trees))];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} a\\n * @param {number[]} b\\n * @param {number[]} o\\n * @return {number}\\n */\\nvar cross = (a, b, o) => {\\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\\n}\\n\\n/**\\n * @param {number[][]} trees\\n * @return {number[][]}\\n */\\nvar convexHull = (trees) => {\\n    trees.sort((a, b) => {\\n      return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\\n   });\\n\\n   let lower = [];\\n   for (let point of trees) {\\n      while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], point) > 0) {\\n         lower.pop();\\n      }\\n      lower.push(point);\\n   }\\n\\n   let upper = [];\\n   for (let point of trees.reverse()) {\\n      while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], point) > 0) {\\n         upper.pop();\\n      }\\n      upper.push(point);\\n   }\\n\\n   return lower.concat(upper);\\n}\\n\\n/**\\n * @param {number[][]} trees\\n * @return {number[][]}\\n */\\nvar outerTrees = function(trees) {\\n    if (trees.length == 1)\\n        return trees;\\n    \\n    return [... new Set(convexHull(trees))];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2829651,
                "title": "convex-hull-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvex hull , union of upper and lower half.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfind the upper half and the lower half and then union it to get the full convex hull.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    class pair implements Comparable<pair>{\\n        int x,y;\\n        pair(int x,int y)\\n        {\\n            this.x=x;\\n            this.y=y;\\n        }\\n    public int compareTo(pair p)\\n    {\\n        if(this.x==p.x)\\n        return this.y-p.y;\\n        return this.x-p.x;\\n    }\\n    }\\n    public boolean cw(int x1,int x2,int x3,int y1,int y2,int y3)\\n    {\\n        return x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)>0;\\n    }\\n    public boolean aw(int x1,int x2,int x3,int y1,int y2,int y3)\\n    {\\n        return x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)<0;\\n    }\\n    public boolean cl(int x1,int x2,int x3,int y1,int y2,int y3)\\n    {\\n        return x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)==0;\\n    }\\n    public int[][] outerTrees(int[][] trees) \\n    {\\n       Arrays.sort(trees,(a,b)->(a[0]-b[0]==0?a[1]-b[1]:a[0]-b[0]));\\n       Stack<pair> up=new Stack<>();\\n       Stack<pair> dn=new Stack<>();\\n       up.push(new pair(trees[0][0],trees[0][1]));\\n       dn.push(new pair(trees[0][0],trees[0][1]));\\n       int sx=trees[0][0];\\n       int sy=trees[0][1];\\n       int ex=trees[trees.length-1][0];\\n       int ey=trees[trees.length-1][1];\\n       for(int i=1;i<trees.length;i++)\\n       {\\n           int x=trees[i][0];\\n           int y=trees[i][1];\\n           if(i==trees.length-1||!aw(sx,x,ex,sy,y,ey))\\n           {\\n               pair aux=up.pop();\\n               int axx=aux.x;\\n               int axy=aux.y;\\n               while(up.size()>=1&&aw(up.peek().x,axx,x,up.peek().y,axy,y))\\n               {\\n                   aux=up.pop();\\n                   axx=aux.x;\\n                   axy=aux.y;\\n               }\\n               up.push(aux);\\n               up.push(new pair(x,y));\\n           }\\n           if(i==trees.length-1||!cw(sx,x,ex,sy,y,ey))\\n           {\\n               pair aux=dn.pop();\\n               int axx=aux.x;\\n               int axy=aux.y;\\n               while(dn.size()>=1&&cw(dn.peek().x,axx,x,dn.peek().y,axy,y))\\n               {\\n                   aux=dn.pop();\\n                   axx=aux.x;\\n                   axy=aux.y;\\n               }\\n               dn.push(aux);\\n               dn.push(new pair(x,y));\\n           }\\n       }\\n       pair a[]=new pair[dn.size()+up.size()];\\n       int k=0;\\n       while(!dn.isEmpty())\\n       a[k++]=dn.pop();\\n       while(!up.isEmpty())\\n       a[k++]=up.pop();\\n       for(;k<a.length-1;)\\n       a[k++]=new pair(-1,-1);\\n       Arrays.sort(a);\\n       ArrayList<pair> arr=new ArrayList<>();\\n       int i=0;\\n       while(a[i].x==-1)\\n       i++;\\n       int c=0;\\n       int f=i;\\n       for(;i<a.length-1;i++)\\n       {\\n          if(a[i].x!=a[i+1].x)\\n           c++;\\n          else if(a[i].y!=a[i+1].y)\\n          c++;\\n       }\\n       c++;\\n       int ans[][]=new int[c][2];\\n       int in=0;\\n       for(int j=f;j<a.length-1;j++)\\n       {\\n          if(a[j].x!=a[j+1].x)\\n           {\\n               ans[in][0]=a[j].x;\\n               ans[in++][1]=a[j].y;\\n           }\\n          else if(a[j].y!=a[j+1].y)\\n          {\\n                 ans[in][0]=a[j].x;\\n               ans[in++][1]=a[j].y;\\n          }\\n       \\n       }\\n       ans[in][0]=a[a.length-1].x;\\n       ans[in++][1]=a[a.length-1].y;\\n       //System.out.println(a.length);\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    class pair implements Comparable<pair>{\\n        int x,y;\\n        pair(int x,int y)\\n        {\\n            this.x=x;\\n            this.y=y;\\n        }\\n    public int compareTo(pair p)\\n    {\\n        if(this.x==p.x)\\n        return this.y-p.y;\\n        return this.x-p.x;\\n    }\\n    }\\n    public boolean cw(int x1,int x2,int x3,int y1,int y2,int y3)\\n    {\\n        return x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)>0;\\n    }\\n    public boolean aw(int x1,int x2,int x3,int y1,int y2,int y3)\\n    {\\n        return x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)<0;\\n    }\\n    public boolean cl(int x1,int x2,int x3,int y1,int y2,int y3)\\n    {\\n        return x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)==0;\\n    }\\n    public int[][] outerTrees(int[][] trees) \\n    {\\n       Arrays.sort(trees,(a,b)->(a[0]-b[0]==0?a[1]-b[1]:a[0]-b[0]));\\n       Stack<pair> up=new Stack<>();\\n       Stack<pair> dn=new Stack<>();\\n       up.push(new pair(trees[0][0],trees[0][1]));\\n       dn.push(new pair(trees[0][0],trees[0][1]));\\n       int sx=trees[0][0];\\n       int sy=trees[0][1];\\n       int ex=trees[trees.length-1][0];\\n       int ey=trees[trees.length-1][1];\\n       for(int i=1;i<trees.length;i++)\\n       {\\n           int x=trees[i][0];\\n           int y=trees[i][1];\\n           if(i==trees.length-1||!aw(sx,x,ex,sy,y,ey))\\n           {\\n               pair aux=up.pop();\\n               int axx=aux.x;\\n               int axy=aux.y;\\n               while(up.size()>=1&&aw(up.peek().x,axx,x,up.peek().y,axy,y))\\n               {\\n                   aux=up.pop();\\n                   axx=aux.x;\\n                   axy=aux.y;\\n               }\\n               up.push(aux);\\n               up.push(new pair(x,y));\\n           }\\n           if(i==trees.length-1||!cw(sx,x,ex,sy,y,ey))\\n           {\\n               pair aux=dn.pop();\\n               int axx=aux.x;\\n               int axy=aux.y;\\n               while(dn.size()>=1&&cw(dn.peek().x,axx,x,dn.peek().y,axy,y))\\n               {\\n                   aux=dn.pop();\\n                   axx=aux.x;\\n                   axy=aux.y;\\n               }\\n               dn.push(aux);\\n               dn.push(new pair(x,y));\\n           }\\n       }\\n       pair a[]=new pair[dn.size()+up.size()];\\n       int k=0;\\n       while(!dn.isEmpty())\\n       a[k++]=dn.pop();\\n       while(!up.isEmpty())\\n       a[k++]=up.pop();\\n       for(;k<a.length-1;)\\n       a[k++]=new pair(-1,-1);\\n       Arrays.sort(a);\\n       ArrayList<pair> arr=new ArrayList<>();\\n       int i=0;\\n       while(a[i].x==-1)\\n       i++;\\n       int c=0;\\n       int f=i;\\n       for(;i<a.length-1;i++)\\n       {\\n          if(a[i].x!=a[i+1].x)\\n           c++;\\n          else if(a[i].y!=a[i+1].y)\\n          c++;\\n       }\\n       c++;\\n       int ans[][]=new int[c][2];\\n       int in=0;\\n       for(int j=f;j<a.length-1;j++)\\n       {\\n          if(a[j].x!=a[j+1].x)\\n           {\\n               ans[in][0]=a[j].x;\\n               ans[in++][1]=a[j].y;\\n           }\\n          else if(a[j].y!=a[j+1].y)\\n          {\\n                 ans[in][0]=a[j].x;\\n               ans[in++][1]=a[j].y;\\n          }\\n       \\n       }\\n       ans[in][0]=a[a.length-1].x;\\n       ans[in++][1]=a[a.length-1].y;\\n       //System.out.println(a.length);\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829538,
                "title": "python-js-explained-graham-scan-algo-compare-slopes-finding-convex-hull",
                "content": "**Logic:** We compare slopes formed by previous point (point2) and current point (point3) (wrt. point1 stored in stack) and if slope 13 > slope 12, then line 13 **must be** on top of the other line 12 (i.e. line 13 encloses the point 2) - **provided we sort the points according to x axis**. Same thing happens vice-versa.\\n\\n**Read the comments to understand even better.**\\n\\n**Upvote if you understood the logic :)**\\n## Python\\n```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        trees.sort() # sort trees according to x axis\\n        \\n        def cmpSlopes(p1, p2, p3):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            x3, y3 = p3\\n            return (y3 - y1) * (x2 - x1) - (y2 - y1) * (x3 - x1) # if slope13 - slope12 > 0 => point 2 is under the line 13\\n        \\n        higher, lower  = [], []\\n        \\n        for point in trees:\\n            while len(higher) >= 2 and cmpSlopes(higher[-2], higher[-1], point) > 0: higher.pop() # pop point2 if slope12 < slope13\\n            while len(lower) >= 2 and cmpSlopes(lower[-2], lower[-1], point) < 0: lower.pop() # pop point2 if slope13 < slope12\\n            \\n            lower.append(tuple(point)) # append point 3 since last point in x-axis will always be part of boundary\\n            higher.append(tuple(point))   \\n        \\n        return set(lower + higher)\\n```\\n## Javascript\\n```\\nvar outerTrees = function(trees) {\\n    trees.sort((a, b) => a[0] - b[0] == 0 ? a[1] - b[1] : a[0] - b[0])\\n    const cmpSlopes = ([x1, y1], [x2, y2], [x3, y3]) => (y3 - y1) * (x2 - x1) - (y2 - y1) * (x3 - x1)\\n    const higher = []\\n    const lower = []\\n    \\n    for (let point of trees) {\\n        while (higher.length > 1 && cmpSlopes(higher[higher.length - 2], higher[higher.length - 1], point) > 0) \\n            higher.pop();\\n        while (lower.length > 1 && cmpSlopes(lower[lower.length - 2], lower[lower.length - 1], point) < 0) \\n            lower.pop();\\n        \\n        higher.push(point);\\n        lower.push(point);\\n    }\\n    \\n    return [...new Set([...higher, ...lower])];\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        trees.sort() # sort trees according to x axis\\n        \\n        def cmpSlopes(p1, p2, p3):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            x3, y3 = p3\\n            return (y3 - y1) * (x2 - x1) - (y2 - y1) * (x3 - x1) # if slope13 - slope12 > 0 => point 2 is under the line 13\\n        \\n        higher, lower  = [], []\\n        \\n        for point in trees:\\n            while len(higher) >= 2 and cmpSlopes(higher[-2], higher[-1], point) > 0: higher.pop() # pop point2 if slope12 < slope13\\n            while len(lower) >= 2 and cmpSlopes(lower[-2], lower[-1], point) < 0: lower.pop() # pop point2 if slope13 < slope12\\n            \\n            lower.append(tuple(point)) # append point 3 since last point in x-axis will always be part of boundary\\n            higher.append(tuple(point))   \\n        \\n        return set(lower + higher)\\n```\n```\\nvar outerTrees = function(trees) {\\n    trees.sort((a, b) => a[0] - b[0] == 0 ? a[1] - b[1] : a[0] - b[0])\\n    const cmpSlopes = ([x1, y1], [x2, y2], [x3, y3]) => (y3 - y1) * (x2 - x1) - (y2 - y1) * (x3 - x1)\\n    const higher = []\\n    const lower = []\\n    \\n    for (let point of trees) {\\n        while (higher.length > 1 && cmpSlopes(higher[higher.length - 2], higher[higher.length - 1], point) > 0) \\n            higher.pop();\\n        while (lower.length > 1 && cmpSlopes(lower[lower.length - 2], lower[lower.length - 1], point) < 0) \\n            lower.pop();\\n        \\n        higher.push(point);\\n        lower.push(point);\\n    }\\n    \\n    return [...new Set([...higher, ...lower])];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829491,
                "title": "c-convex-hull-fully-explained-solution",
                "content": "\\u25BA IF YOU UNDERSTAND THE SOLUTION PLEASE UPVOTE \\u2705 \\u2705\\n\\n-> Its a solution based on Convex hull Algorithm\\n> step1 : If tree length is <= 3 then all tress are located on fence retrun trees \\n> step 2: If tree length is greater than 3 then we need to use this approach\\n1. We surround the fence in clockwise direction, so any three consecutive points taken on the fence their cross product would be negative\\n2. Cross product > 0\\nindicates the 3 points are connected in anticlockwise fashion , we dont consider them\\n3. Cross product < 0\\nindicates the 3 points are connected in anticlockwise fashion and those points add up to the answer\\n4. Cross product == 0\\nindicates 3 points are collinear or on same line, which are also considered\\n\\n> step 3 : we create an Upper hull ( connecting all points left most to right most of tree in clockwise sense )\\n\\t\\n\\t        5\\n\\t\\t  /    \\\\               // in Upper hull we start the fence from point 1 to end at point 5 traversing \\n\\t\\t2   7    4           // through 2,3,5 only in clockwise direction \\n\\t  /           \\\\         \\n\\t 1    3         5 \\n\\t \\n![image](https://assets.leetcode.com/users/images/76781a0d-bcd1-4455-8369-5cd020c7824a_1668844731.8626356.png)\\n![image](https://assets.leetcode.com/users/images/df9776a7-fa5d-4c9d-b358-ffbebbc40ad1_1668844744.5294092.png)\\nstep 4 : we create an lower hull ( connecting all points right most to left most of tree in clockwise sense\\n\\n![image](https://assets.leetcode.com/users/images/95a56542-d374-4d9b-8f11-8fcf2f49500e_1668844776.1911314.png)\\n![image](https://assets.leetcode.com/users/images/a6df5f12-f6fc-4d2b-8e3f-333a78a5a29e_1668844787.2933488.png)\\n\\nstep 5 : we all the elements in upper hull and lower hull and remove the duplicates and return it\\nupper = upper + lower\\n\\n1. Now we sort the upper\\n2. we use unique( vector.begin(), vector.end() )\\n> Unique function pushes all the duplicate elements to the end , it doesnot remove elements in vector\\n> So some part of vector is removed from duplicates and other part has all the duplicates\\n> Unique returns a pointer that points to the beginning of the duplicate part of vector\\nEg : vector v1 = { 1,1,4,4,5,6,6,7,8,9,9,9 }\\nAfter unique v1 = { 1,4,5,6,7,8,9,1,4,6,9,9}\\nPointer that it returns ..................\\u2191\\n\\n> up.erase( unique(up.begin(), up.end()) , up.end() ) ; removes all duplicates and returns the vector\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint angle(vector<int>& A, vector<int>& B, vector<int>& C){\\n    \\n\\t\\t// A[x1,y1] , B[x2,y2] , C[x3,y3]\\n\\t\\t// A[0,1]     B[0,1]    C[0,1]\\n\\t\\t// AB = [ x2-x1 , y2-y1]  BC = [ x3-x2, y3-y2 ]\\n\\t\\t// Cross product of AB and BC = ( X1*Y2 - X2*Y1 )\\n\\t\\t// crossproduct of AB and BC = ((x2-x1)*(y3-y2) - (x3-x2)*(y2-y1))\\n    \\n\\t\\treturn ( (B[0]-A[0])*(C[1]-B[1]) - (C[0]-B[0])*(B[1]-A[1])) ;\\n\\t}\\n\\tvector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n\\t\\tint n=trees.size();\\n\\t\\tif(n<=3)return trees;\\n\\t\\tsort(trees.begin(), trees.end());\\n    \\n\\t\\t//upper hull\\n\\t\\tvector<vector<int>>up;\\n\\t\\tup.push_back(trees[0]);\\n\\t\\tup.push_back(trees[1]);\\n\\t\\tfor(int i=2; i<n; i++){\\n\\t\\t\\tint s=up.size();\\n\\t\\t\\twhile(s>=2 and angle(up[s-2],up[s-1],trees[i])>0){\\n\\t\\t\\t\\tup.pop_back();\\n\\t\\t\\t\\ts--;\\n\\t\\t\\t}\\n\\t\\t\\tup.push_back(trees[i]);\\n\\t\\t}\\n    \\n\\t\\t//lower hull\\n\\t\\tvector<vector<int>>down;\\n\\t\\tdown.push_back(trees[trees.size()-1]);\\n\\t\\tdown.push_back(trees[trees.size()-2]);\\n\\t\\tfor(int i=n-3; i>=0; i--){\\n\\t\\t\\tint s=down.size();\\n\\t\\t\\twhile(s>=2 and angle(down[s-2],down[s-1],trees[i])>0){\\n\\t\\t\\t\\tdown.pop_back();\\n\\t\\t\\t\\ts--;\\n\\t\\t\\t}\\n\\t\\t\\tdown.push_back(trees[i]);\\n\\t\\t}\\n    \\n\\t\\t// remove duplicates\\n\\t\\tfor(int i = 0; i < down.size(); i++)\\n\\t\\t\\tup.push_back(down[i]);\\n\\t\\tsort(up.begin(), up.end());\\n\\t\\tup.erase(unique(up.begin(), up.end()), up.end());\\n\\t\\treturn up;\\n\\t}\\n\\t};\\nHope you understand the solution \\uD83D\\uDE42\\nIf yes please upvote \\u2705 \\uD83E\\uDD79",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint angle(vector<int>& A, vector<int>& B, vector<int>& C){\\n    \\n\\t\\t// A[x1,y1] , B[x2,y2] , C[x3,y3]\\n\\t\\t// A[0,1]     B[0,1]    C[0,1]\\n\\t\\t// AB = [ x2-x1 , y2-y1]  BC = [ x3-x2, y3-y2 ]\\n\\t\\t// Cross product of AB and BC = ( X1*Y2 - X2*Y1 )\\n\\t\\t// crossproduct of AB and BC = ((x2-x1)*(y3-y2) - (x3-x2)*(y2-y1))\\n    \\n\\t\\treturn ( (B[0]-A[0])*(C[1]-B[1]) - (C[0]-B[0])*(B[1]-A[1])) ;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2829045,
                "title": "erect-the-fence-4-approaches-simple-fast-and-easy-with-explanation",
                "content": "# \\uD83D\\uDD25 Erect the Fence \\uD83D\\uDD25 || 4 Approaches || Simple Fast and Easy || with Explanation\\n\\n## Solution - 1 Convex Hull | Graham Scan\\n\\n```dart\\nclass Solution {\\n// Runtime: 668 ms, faster than 100.00% of Dart online submissions for Erect the Fence.\\n// Memory Usage: 152.4 MB, less than 100.00% of Dart online submissions for Erect the Fence.\\n  int orientation(List<int> p, List<int> q, List<int> r) {\\n    return (r[1] - q[1]) * (q[0] - p[0]) - ((q[1] - p[1]) * (r[0] - q[0]));\\n  }\\n\\n  List<List<int>> outerTrees(List<List<int>> trees) {\\n    List<List<int>> upper = [];\\n    List<List<int>> lower = [];\\n    trees.sort((p, q) => q[0] - p[0] == 0 ? q[1] - p[1] : q[0] - p[0]);\\n    for (int i = 0; i < trees.length; i++) {\\n      while (lower.length >= 2 &&\\n          orientation(lower.elementAt(lower.length - 2),\\n                  lower.elementAt(lower.length - 1), trees[i]) >\\n              0) {\\n        lower.removeLast();\\n      }\\n      while (upper.length >= 2 &&\\n          orientation(upper.elementAt(upper.length - 2),\\n                  upper.elementAt(upper.length - 1), trees[i]) <\\n              0) {\\n        upper.removeLast();\\n      }\\n      lower.add(trees[i]);\\n      upper.add(trees[i]);\\n    }\\n    HashSet<List<int>> res = HashSet();\\n    res.addAll(lower);\\n    res.addAll(upper);\\n    return res.toList();\\n  }\\n}\\n```\\n\\n## Solution - 2 Convex Hull | Jarvis Algorithm\\n\\n```dart\\nclass Solution {\\n  // TLE\\n  int crossProduct(List<int> p, List<int> q, List<int> r) {\\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\\n  }\\n\\n  bool distance(List<int> p, List<int> i, List<int> q) {\\n    bool a = i[0] >= p[0] && i[0] <= q[0] || i[0] <= p[0] && i[0] >= q[0];\\n    bool b = i[1] >= p[1] && i[1] <= q[1] || i[1] <= p[1] && i[1] >= q[1];\\n    return a && b;\\n  }\\n\\n  List<List<int>> outerTrees(List<List<int>> trees) {\\n    //use hashSet because this algorithm might try to insert duplicate point.\\n    HashSet<List<int>> hashSet = HashSet();\\n    if (trees.length < 4) {\\n      for (List<int> p in trees) hashSet.add(p);\\n      return hashSet.toList();\\n    }\\n    int leftMost = 0;\\n    for (int i = 0; i < trees.length; i++)\\n      if (trees[i][0] < trees[leftMost][0]) leftMost = i;\\n\\n    //first find leftmost point to start the march.\\n    int p = leftMost;\\n    do {\\n      int q = (p + 1) % trees.length;\\n\\n      for (int i = 0; i < trees.length; i++) {\\n        //if crossProduct < 0 it means trees[i] is on right of current point -> nextPoint. Make him the next point.\\n        if (crossProduct(trees[p], trees[i], trees[q]) < 0) {\\n          q = i;\\n        }\\n      }\\n\\n      for (int i = 0; i < trees.length; i++) {\\n        if (i != p &&\\n            i != q &&\\n            crossProduct(trees[p], trees[i], trees[q]) == 0 &&\\n            distance(trees[p], trees[i], trees[q])) {\\n          // if more than one trees are on the rightmost, then insert all the collinear trees in the hashSet\\n          hashSet.add(trees[i]);\\n        }\\n      }\\n\\n      hashSet.add(trees[q]);\\n      p = q;\\n    } while (p != leftMost);\\n    return hashSet.toList();\\n  }\\n}\\n```\\n\\n## Solution - 3 Gift Wrapping\\n\\n## Approach\\n\\nThe idea is that we start from a corner point, and we use a rope (fixed length, long enough), and we go as far as we can, since the length is fixed and we start from a corner point, we will go back to the origin point finally.\\n\\nThe first step is how to find such a corner point, this can be done by choosing the left most point, it must be a corner point.\\nThe second step is find the next corner point, we will explain this later in detail.\\nThe third step is checking if we have returned to the original point.\\nNow, we focus on the problem of finding the next corner point front one conner point.\\n\\nNow, suppose we are now in the corner point A, we want to find the next corner point D, how do we do it: The idea is we start from a random point, say B, and select a random point, say C, and we compare B and C, find the outer one, where outer means C will be on the convex hull more likely than B in the anti-clockwise direction. If C is indeed outer than B, then we update B<-C, and find a new one, until all points has been visited.\\nNow our problem becomes: How to describe outer formally, or codable? The answer is outer product, I will not use mathematical definition here, but the property of outer product is that: if the crossProduct(AB, AC)>0, it means the vector B is in clockwise direction of C respect to A(as shown in figure above), otherwise B is in anti-clockwise direction of C respect to A (for example, D and C or C and B).\\nFinally, we need to check the case when three points are colinear, since we need to chose the farthest one.\\n\\n```dart\\nclass Solution {\\n  int crossProduct(List<int> A, List<int> B, List<int> C) {\\n    int BA_x = A[0] - B[0];\\n    int BC_x = C[0] - B[0];\\n    int BA_y = A[1] - B[1];\\n    int BC_y = C[1] - B[1];\\n    return BA_x * BC_y - BA_y * BC_x;\\n  }\\n\\n  int distance(List<int> A, List<int> B) {\\n    return (A[0] - B[0]) * (A[0] - B[0]) + (A[1] - B[1]) * (A[1] - B[1]);\\n  }\\n\\n  bool isNotInPointList(List<List<int>> pointList, List<int> point) {\\n    for (var point_ in pointList) {\\n      if (point_[0] == point[0] && point_[1] == point[1]) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  List<List<int>> outerTrees(List<List<int>> trees) {\\n    List<List<int>> result = [].map((e) => <int>[]).toList();\\n    int size = trees.length;\\n    // find the left most point and its index\\n    List<int> firstPoint = List.filled(2, 101);\\n    int firstIndex = 0;\\n    for (int i = 0; i < size; ++i) {\\n      if (trees[i][0] < firstPoint[0]) {\\n        firstPoint = trees[i];\\n        firstIndex = i;\\n      }\\n    }\\n    result.add(firstPoint);\\n\\n    List<int> currentPoint = firstPoint;\\n    int currentIndex = firstIndex;\\n    while (true) {\\n      // find the most outer point\\n      List<int> nextPoint = trees[0];\\n      int nextIndex = 0;\\n      for (int index = 0; index < size; ++index) {\\n        if (index == currentIndex) continue;\\n        int crossPRODUCT = crossProduct(currentPoint, trees[index], nextPoint);\\n        if (nextIndex == currentIndex ||\\n            crossPRODUCT > 0 ||\\n            (crossPRODUCT == 0 &&\\n                distance(trees[index], currentPoint) >\\n                    distance(nextPoint, currentPoint))) {\\n          nextPoint = trees[index];\\n          nextIndex = index;\\n        }\\n      }\\n      // sanity check\\n      for (int index = 0; index < size; ++index) {\\n        if (index == currentIndex) continue;\\n        int crossPRODUCT = crossProduct(currentPoint, trees[index], nextPoint);\\n        if (crossPRODUCT == 0 && isNotInPointList(result, trees[index]))\\n          result.add(trees[index]);\\n      }\\n      currentPoint = nextPoint;\\n      currentIndex = nextIndex;\\n      if (currentIndex == firstIndex) break;\\n    }\\n    return result;\\n  }\\n}\\n```\\n\\n## Solution - 4 Monotone Chain Algorithm\\n\\n```dart\\nclass Solution {\\n  int Orientation(List<int> p, List<int> q, List<int> r) =>\\n      (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\\n  List<List<int>> outerTrees(List<List<int>> trees) {\\n    //  Array.Sort(trees, (p,q) => q[0] - p[0] == 0 ? q[1] - p[1] : q[0] - p[0]);\\n    trees.sort((p, q) => q[0] - p[0] == 0 ? q[1] - p[1] : q[0] - p[0]);\\n\\n    List<List<int>> hull = [];\\n    for (int i = 0; i < trees.length; i++) {\\n      while (hull.length >= 2 &&\\n          Orientation(hull.elementAt(1), hull.first, trees[i]) > 0)\\n        hull.removeLast();\\n      hull.add(trees[i]);\\n    }\\n\\n    hull.removeLast();\\n\\n    for (int i = trees.length - 1; i >= 0; i--) {\\n      while (hull.length >= 2 &&\\n          Orientation(hull.elementAt(1), hull.first, trees[i]) > 0)\\n        hull.removeLast();\\n      hull.add(trees[i]);\\n    }\\n\\n    HashSet<List<int>> hashSet = HashSet();\\n    hashSet.addAll(hull);\\n    return hashSet.toList();\\n  }\\n}\\n```\\n### [GitHub Link](https://github.com/ayoubzulfiqar/leetcode)",
                "solutionTags": [
                    "Geometry"
                ],
                "code": "```dart\\nclass Solution {\\n// Runtime: 668 ms, faster than 100.00% of Dart online submissions for Erect the Fence.\\n// Memory Usage: 152.4 MB, less than 100.00% of Dart online submissions for Erect the Fence.\\n  int orientation(List<int> p, List<int> q, List<int> r) {\\n    return (r[1] - q[1]) * (q[0] - p[0]) - ((q[1] - p[1]) * (r[0] - q[0]));\\n  }\\n\\n  List<List<int>> outerTrees(List<List<int>> trees) {\\n    List<List<int>> upper = [];\\n    List<List<int>> lower = [];\\n    trees.sort((p, q) => q[0] - p[0] == 0 ? q[1] - p[1] : q[0] - p[0]);\\n    for (int i = 0; i < trees.length; i++) {\\n      while (lower.length >= 2 &&\\n          orientation(lower.elementAt(lower.length - 2),\\n                  lower.elementAt(lower.length - 1), trees[i]) >\\n              0) {\\n        lower.removeLast();\\n      }\\n      while (upper.length >= 2 &&\\n          orientation(upper.elementAt(upper.length - 2),\\n                  upper.elementAt(upper.length - 1), trees[i]) <\\n              0) {\\n        upper.removeLast();\\n      }\\n      lower.add(trees[i]);\\n      upper.add(trees[i]);\\n    }\\n    HashSet<List<int>> res = HashSet();\\n    res.addAll(lower);\\n    res.addAll(upper);\\n    return res.toList();\\n  }\\n}\\n```\n```dart\\nclass Solution {\\n  // TLE\\n  int crossProduct(List<int> p, List<int> q, List<int> r) {\\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\\n  }\\n\\n  bool distance(List<int> p, List<int> i, List<int> q) {\\n    bool a = i[0] >= p[0] && i[0] <= q[0] || i[0] <= p[0] && i[0] >= q[0];\\n    bool b = i[1] >= p[1] && i[1] <= q[1] || i[1] <= p[1] && i[1] >= q[1];\\n    return a && b;\\n  }\\n\\n  List<List<int>> outerTrees(List<List<int>> trees) {\\n    //use hashSet because this algorithm might try to insert duplicate point.\\n    HashSet<List<int>> hashSet = HashSet();\\n    if (trees.length < 4) {\\n      for (List<int> p in trees) hashSet.add(p);\\n      return hashSet.toList();\\n    }\\n    int leftMost = 0;\\n    for (int i = 0; i < trees.length; i++)\\n      if (trees[i][0] < trees[leftMost][0]) leftMost = i;\\n\\n    //first find leftmost point to start the march.\\n    int p = leftMost;\\n    do {\\n      int q = (p + 1) % trees.length;\\n\\n      for (int i = 0; i < trees.length; i++) {\\n        //if crossProduct < 0 it means trees[i] is on right of current point -> nextPoint. Make him the next point.\\n        if (crossProduct(trees[p], trees[i], trees[q]) < 0) {\\n          q = i;\\n        }\\n      }\\n\\n      for (int i = 0; i < trees.length; i++) {\\n        if (i != p &&\\n            i != q &&\\n            crossProduct(trees[p], trees[i], trees[q]) == 0 &&\\n            distance(trees[p], trees[i], trees[q])) {\\n          // if more than one trees are on the rightmost, then insert all the collinear trees in the hashSet\\n          hashSet.add(trees[i]);\\n        }\\n      }\\n\\n      hashSet.add(trees[q]);\\n      p = q;\\n    } while (p != leftMost);\\n    return hashSet.toList();\\n  }\\n}\\n```\n```dart\\nclass Solution {\\n  int crossProduct(List<int> A, List<int> B, List<int> C) {\\n    int BA_x = A[0] - B[0];\\n    int BC_x = C[0] - B[0];\\n    int BA_y = A[1] - B[1];\\n    int BC_y = C[1] - B[1];\\n    return BA_x * BC_y - BA_y * BC_x;\\n  }\\n\\n  int distance(List<int> A, List<int> B) {\\n    return (A[0] - B[0]) * (A[0] - B[0]) + (A[1] - B[1]) * (A[1] - B[1]);\\n  }\\n\\n  bool isNotInPointList(List<List<int>> pointList, List<int> point) {\\n    for (var point_ in pointList) {\\n      if (point_[0] == point[0] && point_[1] == point[1]) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  List<List<int>> outerTrees(List<List<int>> trees) {\\n    List<List<int>> result = [].map((e) => <int>[]).toList();\\n    int size = trees.length;\\n    // find the left most point and its index\\n    List<int> firstPoint = List.filled(2, 101);\\n    int firstIndex = 0;\\n    for (int i = 0; i < size; ++i) {\\n      if (trees[i][0] < firstPoint[0]) {\\n        firstPoint = trees[i];\\n        firstIndex = i;\\n      }\\n    }\\n    result.add(firstPoint);\\n\\n    List<int> currentPoint = firstPoint;\\n    int currentIndex = firstIndex;\\n    while (true) {\\n      // find the most outer point\\n      List<int> nextPoint = trees[0];\\n      int nextIndex = 0;\\n      for (int index = 0; index < size; ++index) {\\n        if (index == currentIndex) continue;\\n        int crossPRODUCT = crossProduct(currentPoint, trees[index], nextPoint);\\n        if (nextIndex == currentIndex ||\\n            crossPRODUCT > 0 ||\\n            (crossPRODUCT == 0 &&\\n                distance(trees[index], currentPoint) >\\n                    distance(nextPoint, currentPoint))) {\\n          nextPoint = trees[index];\\n          nextIndex = index;\\n        }\\n      }\\n      // sanity check\\n      for (int index = 0; index < size; ++index) {\\n        if (index == currentIndex) continue;\\n        int crossPRODUCT = crossProduct(currentPoint, trees[index], nextPoint);\\n        if (crossPRODUCT == 0 && isNotInPointList(result, trees[index]))\\n          result.add(trees[index]);\\n      }\\n      currentPoint = nextPoint;\\n      currentIndex = nextIndex;\\n      if (currentIndex == firstIndex) break;\\n    }\\n    return result;\\n  }\\n}\\n```\n```dart\\nclass Solution {\\n  int Orientation(List<int> p, List<int> q, List<int> r) =>\\n      (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\\n  List<List<int>> outerTrees(List<List<int>> trees) {\\n    //  Array.Sort(trees, (p,q) => q[0] - p[0] == 0 ? q[1] - p[1] : q[0] - p[0]);\\n    trees.sort((p, q) => q[0] - p[0] == 0 ? q[1] - p[1] : q[0] - p[0]);\\n\\n    List<List<int>> hull = [];\\n    for (int i = 0; i < trees.length; i++) {\\n      while (hull.length >= 2 &&\\n          Orientation(hull.elementAt(1), hull.first, trees[i]) > 0)\\n        hull.removeLast();\\n      hull.add(trees[i]);\\n    }\\n\\n    hull.removeLast();\\n\\n    for (int i = trees.length - 1; i >= 0; i--) {\\n      while (hull.length >= 2 &&\\n          Orientation(hull.elementAt(1), hull.first, trees[i]) > 0)\\n        hull.removeLast();\\n      hull.add(trees[i]);\\n    }\\n\\n    HashSet<List<int>> hashSet = HashSet();\\n    hashSet.addAll(hull);\\n    return hashSet.toList();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828900,
                "title": "c-simple-solution",
                "content": "```\\n static bool cmp(vector<int>&a, vector<int>&b){\\n        return a[0]<b[0] || (a[0]==b[0] && a[1]<b[1]);\\n    }\\n    \\n    int orientation(vector<int>&a, vector<int>&b, vector<int>&c){\\n        return (b[0]-a[0])*(c[1]-b[1])-(b[1]-a[1])*(c[0]-b[0]);\\n    }\\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& points) {\\n        int n=points.size();\\n        vector<vector<int>>ans;\\n        sort(points.begin(), points.end(), cmp);\\n        \\n        for(int i=0; i<n; i++){\\n            while(ans.size()>1 && orientation(ans[ans.size()-2], ans.back(), points[i])<0)\\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        \\n        if(ans.size()==n) return ans;\\n        \\n        for(int i=n-2; i>=0; i--){\\n            while(ans.size()>1 && orientation(ans[ans.size()-2], ans.back(), points[i])<0)\\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n static bool cmp(vector<int>&a, vector<int>&b){\\n        return a[0]<b[0] || (a[0]==b[0] && a[1]<b[1]);\\n    }\\n    \\n    int orientation(vector<int>&a, vector<int>&b, vector<int>&c){\\n        return (b[0]-a[0])*(c[1]-b[1])-(b[1]-a[1])*(c[0]-b[0]);\\n    }\\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& points) {\\n        int n=points.size();\\n        vector<vector<int>>ans;\\n        sort(points.begin(), points.end(), cmp);\\n        \\n        for(int i=0; i<n; i++){\\n            while(ans.size()>1 && orientation(ans[ans.size()-2], ans.back(), points[i])<0)\\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        \\n        if(ans.size()==n) return ans;\\n        \\n        for(int i=n-2; i>=0; i--){\\n            while(ans.size()>1 && orientation(ans[ans.size()-2], ans.back(), points[i])<0)\\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1444418,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    class Point\\n    {\\n        public:\\n        int x;\\n        int y;\\n\\n        bool operator < (Point(&P))\\n        {\\n            if (P.x == x)\\n                return y < P.y;\\n            else\\n                return x < P.x;\\n        }\\n        bool operator == (Point(&P))\\n        {\\n            return (x == P.x and y == P.y);\\n        }\\n};\\n    bool cw(Point a, Point b, Point c)\\n    {\\n        return (((b.y - a.y) * (c.x - b.x)) - ((c.y - b.y) * (b.x - a.x))) > 0;\\n    }\\n    bool acw(Point a, Point b, Point c)\\n    {\\n        return (((b.y - a.y) * (c.x - b.x)) - ((c.y - b.y) * (b.x - a.x))) < 0;\\n    }\\n    bool col(Point a, Point b, Point c)\\n    {\\n        return (((b.y - a.y) * (c.x - b.x)) - ((c.y - b.y) * (b.x - a.x))) == 0;\\n    }\\n    void convex_hull(vector<Point> &p)\\n    {\\n        if (p.size() <= 2) return;\\n        int n = p.size();\\n        sort(p.begin(), p.end());\\n        Point p1 = p[0], p2 = p[n - 1];\\n        vector <Point> up, down;\\n        up.push_back(p1);\\n        down.push_back(p1);\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (i == n - 1 or (!acw(p1, p[i], p2)))\\n            {\\n                while (up.size() >= 2 and (acw(up[up.size() - 2], up[up.size() - 1], p[i])))\\n                {\\n                    up.pop_back();\\n                }\\n                up.push_back(p[i]);\\n            }\\n            if (i == n - 1 or (!cw(p1, p[i], p2)))\\n            {\\n                while (down.size() >= 2 and (cw(down[down.size() - 2], down[down.size() - 1], p[i])))\\n                {\\n                    down.pop_back();\\n                }\\n                down.push_back(p[i]);\\n            }\\n        }\\n        p.clear();\\n        for (int i = 0; i < up.size(); i++)\\n            p.push_back(up[i]);\\n        for (int i = 0; i < down.size(); i++)\\n            p.push_back(down[i]);\\n        sort(p.begin(), p.end());\\n        p.resize(unique(p.begin(), p.end()) - p.begin());\\n    }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) \\n    {\\n        vector<Point> p;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            Point temp;      \\n            temp.x = trees[i][0];\\n            temp.y = trees[i][1];\\n            p.push_back(temp);\\n        }\\n        convex_hull(p);\\n        vector<vector<int> > ans;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            ans.push_back({p[i].x, p[i].y});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    class Point\\n    {\\n        public:\\n        int x;\\n        int y;\\n\\n        bool operator < (Point(&P))\\n        {\\n            if (P.x == x)\\n                return y < P.y;\\n            else\\n                return x < P.x;\\n        }\\n        bool operator == (Point(&P))\\n        {\\n            return (x == P.x and y == P.y);\\n        }\\n};\\n    bool cw(Point a, Point b, Point c)\\n    {\\n        return (((b.y - a.y) * (c.x - b.x)) - ((c.y - b.y) * (b.x - a.x))) > 0;\\n    }\\n    bool acw(Point a, Point b, Point c)\\n    {\\n        return (((b.y - a.y) * (c.x - b.x)) - ((c.y - b.y) * (b.x - a.x))) < 0;\\n    }\\n    bool col(Point a, Point b, Point c)\\n    {\\n        return (((b.y - a.y) * (c.x - b.x)) - ((c.y - b.y) * (b.x - a.x))) == 0;\\n    }\\n    void convex_hull(vector<Point> &p)\\n    {\\n        if (p.size() <= 2) return;\\n        int n = p.size();\\n        sort(p.begin(), p.end());\\n        Point p1 = p[0], p2 = p[n - 1];\\n        vector <Point> up, down;\\n        up.push_back(p1);\\n        down.push_back(p1);\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (i == n - 1 or (!acw(p1, p[i], p2)))\\n            {\\n                while (up.size() >= 2 and (acw(up[up.size() - 2], up[up.size() - 1], p[i])))\\n                {\\n                    up.pop_back();\\n                }\\n                up.push_back(p[i]);\\n            }\\n            if (i == n - 1 or (!cw(p1, p[i], p2)))\\n            {\\n                while (down.size() >= 2 and (cw(down[down.size() - 2], down[down.size() - 1], p[i])))\\n                {\\n                    down.pop_back();\\n                }\\n                down.push_back(p[i]);\\n            }\\n        }\\n        p.clear();\\n        for (int i = 0; i < up.size(); i++)\\n            p.push_back(up[i]);\\n        for (int i = 0; i < down.size(); i++)\\n            p.push_back(down[i]);\\n        sort(p.begin(), p.end());\\n        p.resize(unique(p.begin(), p.end()) - p.begin());\\n    }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) \\n    {\\n        vector<Point> p;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            Point temp;      \\n            temp.x = trees[i][0];\\n            temp.y = trees[i][1];\\n            p.push_back(temp);\\n        }\\n        convex_hull(p);\\n        vector<vector<int> > ans;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            ans.push_back({p[i].x, p[i].y});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443449,
                "title": "python-15-lines-easy-convex-hull-with-one-pass",
                "content": "### Convex Hull\\nIn order to reduce the minimum cost on rope, we need construct the fence along with the convex shape of the trees which transforms it to be the standard convex hull problem.\\nYou might be able to get the idea of picking up the convex points, but don\\'t know to implement it. \\nConvex Hull problem is basically an application for sorting, after which we evaluate each point in counterclockwise to get the convex shape. You can\\'t get it out if you haven\\'t seen it before, like you won\\'t be able to know binary search if you don\\'t learn it.\\nTo implement the solution, there are 2 critical parts to know, one of which is how to sort points, the other is how to determine counterclockwise.\\n\\n#### Sorting\\nThe goal of points iteration in counterclockwise after sorting is to popup the points that are concave, which gives the idea for sorting, counterclockwise.\\nWe have 2 options for sorting condition, both of which need to find out the bottom left point as origin.\\n* `atan2`, which returns radius for `(diff_y, diff_x)` for two points.\\n* slope, which requires to deal with the case of `x` being identical.\\n\\nWhen we have equal value for two points, we put point that is closer on the orientaton prior to the further one. \\n\\n```\\nsorting key = (atan2(y - origin_y, x - origin_x), -y, x) for x, y in trees\\n```\\nwhy do we have `(-y, x)` as tie breaker? \\n\\n#### Orientation\\nAfter sorting the points, we need to iterate each point to remove concave points by checking if the latest seen 3 points are in counterclock using stack.\\nWe use orientation to decide the status from colinear, clockwise, counterclockwise.\\n\\n```\\nfor p1, p2, p3:\\ndelta = (y3 - y2) * (x2 - x1) - (y2 - y1) * (x3 - x2) \\ndelta == 0 => colinear\\n          > 0 => counterclockwise\\n          < 0 => clockwise\\n```\\n\\nThen put all this together.\\nNote, we need ignore the origin when using `atan2` since it\\'s possible to have negative values and origin is taken as center.\\n\\n```python\\ndef outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n\\torigin = [float(\\'inf\\'), float(\\'inf\\')]\\n    for x, y in trees:\\n\\t\\tif x < origin[0] or y < origin[1]:\\n\\t\\t\\torigin = [x, y]\\n \\n\\tdef clockwise(a, b, c):\\n\\t\\treturn (c[1] - b[1]) * (b[0] - a[0]) < (c[0] - b[0]) * (b[1] - a[1]) \\n\\n\\ttrees.sort(key=lambda p: (atan2(p[1] - origin[1], p[0] - origin[0]), -p[1], p[0]))\\n    stack = [origin]\\n    for x, y in trees:\\n\\t\\tif [x, y] != origin:\\n\\t\\t\\twhile len(stack) > 1 and clockwise(stack[-2], stack[-1], [x, y]):\\n\\t\\t\\t\\tstack.pop()\\n\\t\\t\\tstack.append((x, y))     \\n\\treturn stack     \\n```\\n\\n*Time Complexity*= **O(NlgN)**\\n*Space Complexity*= **O(N)**\\n",
                "solutionTags": [],
                "code": "```\\nsorting key = (atan2(y - origin_y, x - origin_x), -y, x) for x, y in trees\\n```\n```\\nfor p1, p2, p3:\\ndelta = (y3 - y2) * (x2 - x1) - (y2 - y1) * (x3 - x2) \\ndelta == 0 => colinear\\n          > 0 => counterclockwise\\n          < 0 => clockwise\\n```\n```python\\ndef outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n\\torigin = [float(\\'inf\\'), float(\\'inf\\')]\\n    for x, y in trees:\\n\\t\\tif x < origin[0] or y < origin[1]:\\n\\t\\t\\torigin = [x, y]\\n \\n\\tdef clockwise(a, b, c):\\n\\t\\treturn (c[1] - b[1]) * (b[0] - a[0]) < (c[0] - b[0]) * (b[1] - a[1]) \\n\\n\\ttrees.sort(key=lambda p: (atan2(p[1] - origin[1], p[0] - origin[0]), -p[1], p[0]))\\n    stack = [origin]\\n    for x, y in trees:\\n\\t\\tif [x, y] != origin:\\n\\t\\t\\twhile len(stack) > 1 and clockwise(stack[-2], stack[-1], [x, y]):\\n\\t\\t\\t\\tstack.pop()\\n\\t\\t\\tstack.append((x, y))     \\n\\treturn stack     \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1443325,
                "title": "please-help-me-why-this-is-not-working-how-to-solve",
                "content": "```\\nclass Solution(object):\\n    def outerTrees(self, trees):\\n        ans = []\\n        d_xmax = {}\\n        d_ymax = {}\\n        for i in trees :\\n            if i[1] in d_xmax : \\n                if d_xmax[i[1]] < i[0] : \\n                    d_xmax[i[1]] = i[0]\\n            else : \\n                d_xmax[i[1]] = i[0]\\n        \\n        for i in d_xmax : \\n            ans.append([d_xmax[i],i])\\n        for i in trees : \\n            if i[0] in d_ymax: \\n                if d_ymax[i[0]] < i[1] :\\n                    d_ymax[i[0]] = i[1]\\n            else : \\n                d_ymax[i[0]] = i[1]    \\n        for i in d_ymax : \\n            key = [i,d_ymax[i]]\\n            if key not in ans : \\n                ans.append(key)\\n                \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def outerTrees(self, trees):\\n        ans = []\\n        d_xmax = {}\\n        d_ymax = {}\\n        for i in trees :\\n            if i[1] in d_xmax : \\n                if d_xmax[i[1]] < i[0] : \\n                    d_xmax[i[1]] = i[0]\\n            else : \\n                d_xmax[i[1]] = i[0]\\n        \\n        for i in d_xmax : \\n            ans.append([d_xmax[i],i])\\n        for i in trees : \\n            if i[0] in d_ymax: \\n                if d_ymax[i[0]] < i[1] :\\n                    d_ymax[i[0]] = i[1]\\n            else : \\n                d_ymax[i[0]] = i[1]    \\n        for i in d_ymax : \\n            key = [i,d_ymax[i]]\\n            if key not in ans : \\n                ans.append(key)\\n                \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442911,
                "title": "erect-the-fence-python3",
                "content": "```\\nclass Solution:\\n    \\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        ret = set()\\n        \\n        if (len(trees) <= 3):\\n            return trees\\n        \\n        # find the leftmost point\\n        leftmost = 0\\n        for i, tree in enumerate(trees):\\n            if(tree[0] < trees[leftmost][0]):\\n                leftmost = i\\n        \\n        i = leftmost\\n        while True:\\n            # j as next point\\n            j = (i + 1) % len(trees)\\n            \\n            # find the corresponding rightmost point\\n            for k, tree in enumerate(trees):\\n                if (self.crossProduct(trees[i], trees[k], trees[j]) > 0):\\n                    j = k\\n            \\n            ret.add((trees[j][0], trees[j][1]))\\n            #print(\" ADD \", j)\\n            \\n            # get points on the same straight line\\n            for k, tree in enumerate(trees):\\n                \\n                if (k != i) and (k != j) and (self.crossProduct(trees[i], trees[k], trees[j]) == 0):\\n                    \\n                    ret.add((trees[k][0], trees[k][1]))\\n                    #print(\" ADD \", k)\\n                    \\n                    # go to the farthest point \\n                    if (dist(trees[i], trees[k]) > dist(trees[i], trees[j])):\\n                        #print(\" MOVE \", j , \" to \", k)\\n                        j = k\\n                        \\n            i = j\\n            \\n            if(i == leftmost):\\n                break\\n\\n        return [list(item) for item in ret]\\n        \\n    def crossProduct(self, A: List[int], B: List[int], C: List[int]) -> int:\\n        # AB X BC = (Xb-Xa) * (Yc-Yb) - (Xc-Xb) * (Yb- Ya)\\n        return (B[0] - A[0]) * (C[1] - B[1]) - (C[0] - B[0]) * (B[1] - A[1]) \\n    \\n    def dist(self, A: List[int], B: List[int]) -> int:\\n        # distance square\\n        return ( (B[1] - A[1]) * (B[0] - B[1]) )**2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        ret = set()\\n        \\n        if (len(trees) <= 3):\\n            return trees\\n        \\n        # find the leftmost point\\n        leftmost = 0\\n        for i, tree in enumerate(trees):\\n            if(tree[0] < trees[leftmost][0]):\\n                leftmost = i\\n        \\n        i = leftmost\\n        while True:\\n            # j as next point\\n            j = (i + 1) % len(trees)\\n            \\n            # find the corresponding rightmost point\\n            for k, tree in enumerate(trees):\\n                if (self.crossProduct(trees[i], trees[k], trees[j]) > 0):\\n                    j = k\\n            \\n            ret.add((trees[j][0], trees[j][1]))\\n            #print(\" ADD \", j)\\n            \\n            # get points on the same straight line\\n            for k, tree in enumerate(trees):\\n                \\n                if (k != i) and (k != j) and (self.crossProduct(trees[i], trees[k], trees[j]) == 0):\\n                    \\n                    ret.add((trees[k][0], trees[k][1]))\\n                    #print(\" ADD \", k)\\n                    \\n                    # go to the farthest point \\n                    if (dist(trees[i], trees[k]) > dist(trees[i], trees[j])):\\n                        #print(\" MOVE \", j , \" to \", k)\\n                        j = k\\n                        \\n            i = j\\n            \\n            if(i == leftmost):\\n                break\\n\\n        return [list(item) for item in ret]\\n        \\n    def crossProduct(self, A: List[int], B: List[int], C: List[int]) -> int:\\n        # AB X BC = (Xb-Xa) * (Yc-Yb) - (Xc-Xb) * (Yb- Ya)\\n        return (B[0] - A[0]) * (C[1] - B[1]) - (C[0] - B[0]) * (B[1] - A[1]) \\n    \\n    def dist(self, A: List[int], B: List[int]) -> int:\\n        # distance square\\n        return ( (B[1] - A[1]) * (B[0] - B[1]) )**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442799,
                "title": "python3-convex-hull-via-graham-scan",
                "content": "\\n```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        # convex hull via Graham scan \\n        xx, yy = min(trees, key=lambda x: (x[1], x[0])) # reference point\\n        \\n        mp = {}\\n        for x, y in trees: mp.setdefault(atan2(y-yy, x-xx), []).append([x, y])\\n        \\n        trees = []\\n        m = max(mp)\\n        for k in sorted(mp): \\n            mp[k].sort(key=lambda p: abs(p[0]-xx)+abs(p[1]-yy))\\n            if k == m and trees: mp[k].reverse()\\n            trees.extend(mp[k])\\n                \\n        stack = []\\n        for x, y in trees: \\n            while len(stack) >= 2: \\n                x0, y0 = stack[-1]\\n                x1, y1 = stack[-2]\\n                if (x0-x1)*(y-y0) - (x-x0)*(y0-y1) >= 0: break\\n                else: stack.pop()\\n            stack.append([x, y])\\n        return stack\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        # convex hull via Graham scan \\n        xx, yy = min(trees, key=lambda x: (x[1], x[0])) # reference point\\n        \\n        mp = {}\\n        for x, y in trees: mp.setdefault(atan2(y-yy, x-xx), []).append([x, y])\\n        \\n        trees = []\\n        m = max(mp)\\n        for k in sorted(mp): \\n            mp[k].sort(key=lambda p: abs(p[0]-xx)+abs(p[1]-yy))\\n            if k == m and trees: mp[k].reverse()\\n            trees.extend(mp[k])\\n                \\n        stack = []\\n        for x, y in trees: \\n            while len(stack) >= 2: \\n                x0, y0 = stack[-1]\\n                x1, y1 = stack[-2]\\n                if (x0-x1)*(y-y0) - (x-x0)*(y0-y1) >= 0: break\\n                else: stack.pop()\\n            stack.append([x, y])\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442756,
                "title": "graham-scan-python",
                "content": "```\\nclass Point:\\n    def __init__(self, point: List[int]):\\n        self.x = point[0]\\n        self.y = point[1]\\n        \\n    def __eq__(self, other: \\'Point\\'):\\n        return self.x == other.x and self.y == other.y\\n\\n    def __hash__(self):\\n        return hash((self.x, self.y))\\n\\n    def __repr__(self) -> str:\\n        return f\\'({self.x}, {self.y})\\'\\n\\n\\nclass Solution:    \\n    def orientation(self, p1: Point, p2: Point, p: Point):\\n        return (p2.y - p1.y) * (p.x - p2.x) - (p2.x - p1.x) * (p.y - p2.y)  # cross product\\n \\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        n = len(trees)\\n        if n < 2:\\n            return trees\\n\\n        trees.sort(key=lambda x: (x[0], x[1]))\\n\\n        lower_hull = []\\n        for tree in trees:\\n            point = Point(tree)\\n            while len(lower_hull) > 1 and self.orientation(lower_hull[-2], lower_hull[-1], point) > 0:\\n                lower_hull.pop()\\n\\n            lower_hull.append(point)\\n\\n        upper_hull = []\\n        for tree in reversed(trees):\\n            point = Point(tree)\\n            while len(upper_hull) > 1 and self.orientation(upper_hull[-2], upper_hull[-1], point) > 0:\\n                upper_hull.pop()\\n\\n            upper_hull.append(point)\\n\\n        return [[p.x, p.y] for p in set(lower_hull[:-1] + upper_hull[:-1])]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Point:\\n    def __init__(self, point: List[int]):\\n        self.x = point[0]\\n        self.y = point[1]\\n        \\n    def __eq__(self, other: \\'Point\\'):\\n        return self.x == other.x and self.y == other.y\\n\\n    def __hash__(self):\\n        return hash((self.x, self.y))\\n\\n    def __repr__(self) -> str:\\n        return f\\'({self.x}, {self.y})\\'\\n\\n\\nclass Solution:    \\n    def orientation(self, p1: Point, p2: Point, p: Point):\\n        return (p2.y - p1.y) * (p.x - p2.x) - (p2.x - p1.x) * (p.y - p2.y)  # cross product\\n \\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        n = len(trees)\\n        if n < 2:\\n            return trees\\n\\n        trees.sort(key=lambda x: (x[0], x[1]))\\n\\n        lower_hull = []\\n        for tree in trees:\\n            point = Point(tree)\\n            while len(lower_hull) > 1 and self.orientation(lower_hull[-2], lower_hull[-1], point) > 0:\\n                lower_hull.pop()\\n\\n            lower_hull.append(point)\\n\\n        upper_hull = []\\n        for tree in reversed(trees):\\n            point = Point(tree)\\n            while len(upper_hull) > 1 and self.orientation(upper_hull[-2], upper_hull[-1], point) > 0:\\n                upper_hull.pop()\\n\\n            upper_hull.append(point)\\n\\n        return [[p.x, p.y] for p in set(lower_hull[:-1] + upper_hull[:-1])]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442092,
                "title": "c-solution-monotone-chain-o-nlogn",
                "content": "```\\npublic class Solution {\\n    \\n    public int Orientation(int[] p, int[] q, int[] r)\\n        => (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\\n    \\n    public int[][] OuterTrees(int[][] trees) {\\n        Array.Sort(trees, (p,q) => q[0] - p[0] == 0 ? q[1] - p[1] : q[0] - p[0]);\\n        \\n        var hull = new Stack<int[]>();\\n        for(int i = 0; i < trees.Length; i++)\\n        {\\n            while(hull.Count >= 2 && Orientation(hull.ElementAt(1), hull.Peek(), trees[i]) > 0)\\n                hull.Pop();\\n            hull.Push(trees[i]);\\n        }\\n        \\n        hull.Pop();\\n        \\n        for(int i = trees.Length - 1; i >= 0; i--)\\n        {\\n            while(hull.Count >= 2 && Orientation(hull.ElementAt(1), hull.Peek(), trees[i]) > 0)\\n                hull.Pop();\\n            hull.Push(trees[i]);\\n        }\\n        \\n        var hashSet = new HashSet<int[]>(hull);\\n        return hashSet.ToArray();\\n    }\\n    // T: O(nlogn), where n is the number of trees.\\n\\t// S: O(n), stack\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public int Orientation(int[] p, int[] q, int[] r)\\n        => (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\\n    \\n    public int[][] OuterTrees(int[][] trees) {\\n        Array.Sort(trees, (p,q) => q[0] - p[0] == 0 ? q[1] - p[1] : q[0] - p[0]);\\n        \\n        var hull = new Stack<int[]>();\\n        for(int i = 0; i < trees.Length; i++)\\n        {\\n            while(hull.Count >= 2 && Orientation(hull.ElementAt(1), hull.Peek(), trees[i]) > 0)\\n                hull.Pop();\\n            hull.Push(trees[i]);\\n        }\\n        \\n        hull.Pop();\\n        \\n        for(int i = trees.Length - 1; i >= 0; i--)\\n        {\\n            while(hull.Count >= 2 && Orientation(hull.ElementAt(1), hull.Peek(), trees[i]) > 0)\\n                hull.Pop();\\n            hull.Push(trees[i]);\\n        }\\n        \\n        var hashSet = new HashSet<int[]>(hull);\\n        return hashSet.ToArray();\\n    }\\n    // T: O(nlogn), where n is the number of trees.\\n\\t// S: O(n), stack\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317103,
                "title": "java-convex-hull-graham-scan-o-nlogn-solution",
                "content": "```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n        int n=trees.length;\\n        if(n<=1) return trees;\\n        sort(trees,bottomLeft(trees));\\n        Stack<int[]> stack = new Stack<>(); \\n        stack.push(trees[0]);                      \\n        stack.push(trees[1]);                              \\n        for (int i = 2; i < n; i++) {\\n            int[] top = stack.pop();                                \\n            while (compAngle(stack.peek(), top, trees[i]) < 0)\\n                top = stack.pop();\\n            stack.push(top);\\n            stack.push(trees[i]);\\n        }\\n        \\n       int [][]res=new int[stack.size()][2];\\n        int c=0;\\n        \\n        for(int[] i: stack)\\n            res[c++]=i;\\n        \\n        return res;\\n    }\\n    \\n    // get bottom left point\\n    int[] bottomLeft(int[][] trees) {\\n        int []bottomLeft=trees[0];\\n        \\n        for(int []tree:trees) {\\n           if(bottomLeft[1] > tree[1] || (bottomLeft[1]==tree[1] && bottomLeft[0]>tree[1]))\\n              bottomLeft=tree;\\n        }\\n        return bottomLeft;\\n    }\\n    \\n    \\n    // anticlockwise +ve, clockwise -ve, 0 collinear\\n    public int compAngle(int p1[], int[] p2, int[] p3){\\n        int[] firstVector = new int[]{p2[0]-p1[0], p2[1]-p1[1]};\\n        int[] secondVector = new int[]{p3[0]-p2[0], p3[1]-p2[1]};\\n        return firstVector[0]*secondVector[1] - firstVector[1]*secondVector[0];\\n    }\\n    \\n    int compDist(int []p1,int []p2) {\\n        return (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1]);\\n    }\\n    \\n    // sort points according to angle with the reference to the bottom left point\\n    void sort(int [][]trees,int[]ref) {\\n        Arrays.sort(trees,(a,b)->{\\n            int compAngle=compAngle(a,ref,b);\\n            int res= compAngle==0 ? compDist(a,ref)-compDist(b,ref) : compAngle;\\n            return res;\\n        });\\n        \\n        // find collinear points from the end\\n        int[] q=trees[trees.length-1];\\n        int i=trees.length-2;\\n        while(i>=0 && compAngle(trees[i],ref,q)==0)\\n            i--;\\n        \\n        // reverse sort collinear points\\n        int low=i+1,high=trees.length-1;\\n        \\n        while(low<high) {\\n            swap(trees,low,high);\\n            low++; high--;\\n        }\\n    }\\n    \\n    void swap(int [][]trees,int l,int r) {\\n        int []temp=trees[l];\\n        trees[l]=trees[r];\\n        trees[r]=temp;\\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n        int n=trees.length;\\n        if(n<=1) return trees;\\n        sort(trees,bottomLeft(trees));\\n        Stack<int[]> stack = new Stack<>(); \\n        stack.push(trees[0]);                      \\n        stack.push(trees[1]);                              \\n        for (int i = 2; i < n; i++) {\\n            int[] top = stack.pop();                                \\n            while (compAngle(stack.peek(), top, trees[i]) < 0)\\n                top = stack.pop();\\n            stack.push(top);\\n            stack.push(trees[i]);\\n        }\\n        \\n       int [][]res=new int[stack.size()][2];\\n        int c=0;\\n        \\n        for(int[] i: stack)\\n            res[c++]=i;\\n        \\n        return res;\\n    }\\n    \\n    // get bottom left point\\n    int[] bottomLeft(int[][] trees) {\\n        int []bottomLeft=trees[0];\\n        \\n        for(int []tree:trees) {\\n           if(bottomLeft[1] > tree[1] || (bottomLeft[1]==tree[1] && bottomLeft[0]>tree[1]))\\n              bottomLeft=tree;\\n        }\\n        return bottomLeft;\\n    }\\n    \\n    \\n    // anticlockwise +ve, clockwise -ve, 0 collinear\\n    public int compAngle(int p1[], int[] p2, int[] p3){\\n        int[] firstVector = new int[]{p2[0]-p1[0], p2[1]-p1[1]};\\n        int[] secondVector = new int[]{p3[0]-p2[0], p3[1]-p2[1]};\\n        return firstVector[0]*secondVector[1] - firstVector[1]*secondVector[0];\\n    }\\n    \\n    int compDist(int []p1,int []p2) {\\n        return (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1]);\\n    }\\n    \\n    // sort points according to angle with the reference to the bottom left point\\n    void sort(int [][]trees,int[]ref) {\\n        Arrays.sort(trees,(a,b)->{\\n            int compAngle=compAngle(a,ref,b);\\n            int res= compAngle==0 ? compDist(a,ref)-compDist(b,ref) : compAngle;\\n            return res;\\n        });\\n        \\n        // find collinear points from the end\\n        int[] q=trees[trees.length-1];\\n        int i=trees.length-2;\\n        while(i>=0 && compAngle(trees[i],ref,q)==0)\\n            i--;\\n        \\n        // reverse sort collinear points\\n        int low=i+1,high=trees.length-1;\\n        \\n        while(low<high) {\\n            swap(trees,low,high);\\n            low++; high--;\\n        }\\n    }\\n    \\n    void swap(int [][]trees,int l,int r) {\\n        int []temp=trees[l];\\n        trees[l]=trees[r];\\n        trees[r]=temp;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303047,
                "title": "java-jarvis-march-99-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[][] outerTrees(int[][] trees) {\\n\\t\\t\\tint n=trees.length;\\n\\t\\t\\tint[] start=null;\\n\\t\\t\\tfor(int []t:trees){\\n\\t\\t\\t\\tif(start==null || start[0]>t[0])\\tstart=t;\\n\\t\\t\\t}\\n\\t\\t\\tint curr[]=start;\\n\\t\\t\\tSet<int []> res=new HashSet<>();\\n\\t\\t\\tres.add(curr);\\n\\t\\t\\twhile(true){\\n\\t\\t\\t\\tList<int []> colinear=new ArrayList<>();\\n\\t\\t\\t\\tint next[]=trees[0];\\n\\t\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\t\\tif(curr!=trees[i]){\\n\\t\\t\\t\\t\\t\\tint val=crossProduct(curr,next,trees[i]);\\n\\t\\t\\t\\t\\t\\tif(val>0){\\n\\t\\t\\t\\t\\t\\t\\tnext=trees[i];\\n\\t\\t\\t\\t\\t\\t\\tcolinear.clear();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if(val==0){\\n\\t\\t\\t\\t\\t\\t\\tif(distance(curr,next,trees[i])<0){\\n\\t\\t\\t\\t\\t\\t\\t\\tcolinear.add(next);\\n\\t\\t\\t\\t\\t\\t\\t\\tnext=trees[i];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse colinear.add(trees[i]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i[]:colinear)\\tres.add(i);\\n\\t\\t\\t\\tif(next==start)\\tbreak;\\n\\t\\t\\t\\tres.add(next);\\n\\t\\t\\t\\tcurr=next;\\n\\t\\t\\t}\\n\\t\\t\\tint fencePoints[][]=new int[res.size()][2],k=0;\\n\\t\\t\\tfor(int i[]:res)    fencePoints[k++]=i;\\n\\t\\t\\treturn fencePoints;\\n\\t\\t}\\n\\t\\tprivate static int crossProduct(int curr[],int []next,int []point){\\n\\t\\t\\tint x1=curr[0]-next[0];\\n\\t\\t\\tint x2=curr[0]-point[0];\\n\\t\\t\\tint y1=curr[1]-next[1];\\n\\t\\t\\tint y2=curr[1]-point[1];\\n\\t\\t\\treturn y2*x1-y1*x2;\\n\\t\\t}\\n\\t\\tprivate static int distance(int curr[],int []next,int []point){\\n\\t\\t\\tint x1=curr[0]-next[0];\\n\\t\\t\\tint x2=curr[0]-point[0];\\n\\t\\t\\tint y1=curr[1]-next[1];\\n\\t\\t\\tint y2=curr[1]-point[1];\\n\\t\\t\\treturn y1*y1+x1*x1-y2*y2-x2*x2;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] outerTrees(int[][] trees) {\\n\\t\\t\\tint n=trees.length;\\n\\t\\t\\tint[] start=null;\\n\\t\\t\\tfor(int []t:trees){\\n\\t\\t\\t\\tif(start==null || start[0]>t[0])\\tstart=t;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1039563,
                "title": "javascript-with-jarvis-march",
                "content": "```\\n/**\\n * @param {number[][]} points\\n * @return {number[][]}\\n */\\nvar outerTrees = function(points) {\\n    // If points are less than or equal to 3, we don\\'t have to find the boundary.\\n    if (points.length <= 3) {\\n        return points;\\n    }\\n\\n    // Finding left, lowest point for starting point\\n    points.sort((a,b) => a[0] !== b[0] ? a[0] - b[0] : a[1] - b[1]);\\n\\n    // Get the counter clockwise value, if v is positive number, point c is in the counter clockwise position of line between a and b\\n    // If v is 0, point c is in the same clockwise position with line between a and b\\n    const crossProduct = (a, b, c) => {\\n        let v = (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\\n        return v;\\n    };\\n\\n    // Get a distance between the two points\\n    const dist = (a, b) => {\\n        let [dx, dy] = [a[0] - b[0], a[1] - b[1]];\\n        return dx * dx + dy * dy\\n    };\\n\\n    let endPoint = [...points[0]];\\n    let previousPoint = [...endPoint];\\n    let out = [];\\n    let used = new Set();\\n    let start = true;\\n    while (start || previousPoint && !(previousPoint[0] === endPoint[0] && previousPoint[1] === endPoint[1])) {\\n        start = false;\\n        let curPoint = null;\\n        let colliner = [];\\n        for (let [x, y] of points) {\\n            if (used.has(x + \\',\\' + y) || previousPoint[0] === x && previousPoint[1] == y) {\\n                continue;\\n            }\\n            if (!curPoint || crossProduct(previousPoint, curPoint, [x, y]) > 0) {\\n                 curPoint = [x, y];\\n                 colliner = [[x, y]];\\n            } else if (crossProduct(previousPoint, curPoint, [x, y]) === 0) {\\n                if (dist(previousPoint, [x, y]) > dist(previousPoint, curPoint)) {\\n                    curPoint = [x, y];\\n                }\\n                colliner.push([x,y]);\\n            }\\n        }\\n        if (colliner.length) {\\n            for (let [a, b] of colliner) {\\n                used.add(a + \\',\\' + b);\\n            }\\n            out = [...out, ...colliner];\\n        }\\n        previousPoint = curPoint;\\n    }\\n\\n    return out;\\n};",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number[][]}\\n */\\nvar outerTrees = function(points) {\\n    // If points are less than or equal to 3, we don\\'t have to find the boundary.\\n    if (points.length <= 3) {\\n        return points;\\n    }\\n\\n    // Finding left, lowest point for starting point\\n    points.sort((a,b) => a[0] !== b[0] ? a[0] - b[0] : a[1] - b[1]);\\n\\n    // Get the counter clockwise value, if v is positive number, point c is in the counter clockwise position of line between a and b\\n    // If v is 0, point c is in the same clockwise position with line between a and b\\n    const crossProduct = (a, b, c) => {\\n        let v = (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\\n        return v;\\n    };\\n\\n    // Get a distance between the two points\\n    const dist = (a, b) => {\\n        let [dx, dy] = [a[0] - b[0], a[1] - b[1]];\\n        return dx * dx + dy * dy\\n    };\\n\\n    let endPoint = [...points[0]];\\n    let previousPoint = [...endPoint];\\n    let out = [];\\n    let used = new Set();\\n    let start = true;\\n    while (start || previousPoint && !(previousPoint[0] === endPoint[0] && previousPoint[1] === endPoint[1])) {\\n        start = false;\\n        let curPoint = null;\\n        let colliner = [];\\n        for (let [x, y] of points) {\\n            if (used.has(x + \\',\\' + y) || previousPoint[0] === x && previousPoint[1] == y) {\\n                continue;\\n            }\\n            if (!curPoint || crossProduct(previousPoint, curPoint, [x, y]) > 0) {\\n                 curPoint = [x, y];\\n                 colliner = [[x, y]];\\n            } else if (crossProduct(previousPoint, curPoint, [x, y]) === 0) {\\n                if (dist(previousPoint, [x, y]) > dist(previousPoint, curPoint)) {\\n                    curPoint = [x, y];\\n                }\\n                colliner.push([x,y]);\\n            }\\n        }\\n        if (colliner.length) {\\n            for (let [a, b] of colliner) {\\n                used.add(a + \\',\\' + b);\\n            }\\n            out = [...out, ...colliner];\\n        }\\n        previousPoint = curPoint;\\n    }\\n\\n    return out;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1008059,
                "title": "java-graham",
                "content": "```\\nclass Solution {\\n//      let p1=(x1,y1)\\uFF0C   p2=(x2,y2)\\uFF0C   p3=(x3,y3)  \\n//      to get vector: \\n//      p12=(x2-x1,y2-y1)    \\n//      p23=(x3-x2,y3-y2)    \\n//      when cross product p12 and p23    \\n//      cross product = p12   x   p23   =   (x2-x1)*(y3-y2)-(y2-y1)*(x3-x2)     \\n//      cross product>0\\uFF0C p1->p2->p3   is anticlockwise\\uFF0C  \\n//      cross product<0\\uFF0C p1->p2->p3   is clockwise\\uFF0C  \\n//      cross product==0\\uFF0Cp1->p2->p3   on the same line.\\n    public int[][] outerTrees(int[][] points) {\\n        int len = points.length;\\n        if(len <= 1) return points;\\n        int[] bl = points[0];\\n        for(int[] p : points){\\n            if(p[1]<bl[1] || p[1]==bl[1] && p[0]<bl[0])\\n                bl = p;\\n        }\\n        sort(points, bl);\\n        Stack<int[]> st = new Stack();\\n        st.push(points[0]);\\n        st.push(points[1]);\\n        for(int i=2; i<len; i++){\\n            int[] cur = points[i];\\n            int[] last = st.pop();\\n            while(crossProduct(st.peek(), last, cur)<0)\\n                last = st.pop();\\n            st.push(last);\\n            st.push(cur);\\n        }\\n        int[][] res = new int[st.size()][2];\\n        int idx = 0;\\n        while(!st.isEmpty())\\n            res[idx++] = st.pop();\\n        return res;\\n    }\\n    public void sort(int[][] points, int[] p){\\n        Arrays.sort(points, (a,b)->{\\n            int cp = crossProduct(a, p, b);\\n            if(cp == 0) return dist(a, p)-dist(b, p);\\n            return cp;\\n        });\\n        int[] q = points[points.length-1];\\n        int i=points.length-2;\\n        for(; i>=0; i--){\\n            if(crossProduct(points[i], p, q)!=0)\\n                break;\\n        }\\n\\t\\t// we need to reverse the last collinear points to avoid losing anyone of them\\n        int l = ++i;\\n        int h = points.length-1;\\n        while(l<h){\\n            int[] temp = points[l];\\n            points[l++] = points[h];\\n            points[h--] = temp;\\n        }\\n    }\\n    public int dist(int[] a, int[] b){\\n        return (a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1]);\\n    }\\n    public int crossProduct(int p1[], int[] p2, int[] p3){\\n        int[] firstVector = new int[]{p2[0]-p1[0], p2[1]-p1[1]};\\n        int[] secondVector = new int[]{p3[0]-p2[0], p3[1]-p2[1]};\\n        return firstVector[0]*secondVector[1] - firstVector[1]*secondVector[0];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n//      let p1=(x1,y1)\\uFF0C   p2=(x2,y2)\\uFF0C   p3=(x3,y3)  \\n//      to get vector: \\n//      p12=(x2-x1,y2-y1)    \\n//      p23=(x3-x2,y3-y2)    \\n//      when cross product p12 and p23    \\n//      cross product = p12   x   p23   =   (x2-x1)*(y3-y2)-(y2-y1)*(x3-x2)     \\n//      cross product>0\\uFF0C p1->p2->p3   is anticlockwise\\uFF0C  \\n//      cross product<0\\uFF0C p1->p2->p3   is clockwise\\uFF0C  \\n//      cross product==0\\uFF0Cp1->p2->p3   on the same line.\\n    public int[][] outerTrees(int[][] points) {\\n        int len = points.length;\\n        if(len <= 1) return points;\\n        int[] bl = points[0];\\n        for(int[] p : points){\\n            if(p[1]<bl[1] || p[1]==bl[1] && p[0]<bl[0])\\n                bl = p;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 886892,
                "title": "go",
                "content": "I copy this shit directly from the approach 2, in case someone wanted to see the go version.\\n```\\nfunc outerTrees(points [][]int) [][]int {\\n    if len(points) <= 1 {\\n        return points\\n    }\\n    \\n    bm := bottomLeft(points)\\n    sort.Slice(points, func (i int, j int) bool {\\n        diff := orientation(bm, points[i], points[j])\\n        if diff == 0 {\\n            return distance(bm, points[i]) < distance(bm, points[j])\\n        } else {\\n            return diff < 0\\n        }\\n    })\\n\\n    i := len(points) - 1\\n    for i >= 0 && orientation(bm, points[len(points) - 1], points[i]) == 0 {\\n        i--\\n    }\\n\\n    j, k := i + 1, len(points) - 1\\n    for j < k {\\n        points[j], points[k] = points[k], points[j]\\n        j++\\n        k--\\n    }\\n\\n    stack := [][]int{points[0], points[1]}\\n    \\n    for p := 2; p < len(points); p++ {\\n        top := stack[len(stack) - 1]\\n        stack = stack[:len(stack) - 1]\\n        for orientation(stack[len(stack) - 1], top, points[p]) > 0 {\\n            top = stack[len(stack) - 1]\\n            stack = stack[:len(stack) - 1]\\n        }\\n        stack = append(stack, top)\\n        stack = append(stack, points[p])\\n    }\\n    return stack\\n}\\n\\nfunc bottomLeft(points [][]int) []int {\\n    res := points[0]\\n    for _, v := range points {\\n        if v[1] < res[1] {\\n            res = v\\n        }\\n    }\\n    return res\\n}\\n\\nfunc orientation(p []int, q []int, r []int) int {\\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\\n}\\n\\nfunc distance(p []int, q []int) int {\\n    return (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc outerTrees(points [][]int) [][]int {\\n    if len(points) <= 1 {\\n        return points\\n    }\\n    \\n    bm := bottomLeft(points)\\n    sort.Slice(points, func (i int, j int) bool {\\n        diff := orientation(bm, points[i], points[j])\\n        if diff == 0 {\\n            return distance(bm, points[i]) < distance(bm, points[j])\\n        } else {\\n            return diff < 0\\n        }\\n    })\\n\\n    i := len(points) - 1\\n    for i >= 0 && orientation(bm, points[len(points) - 1], points[i]) == 0 {\\n        i--\\n    }\\n\\n    j, k := i + 1, len(points) - 1\\n    for j < k {\\n        points[j], points[k] = points[k], points[j]\\n        j++\\n        k--\\n    }\\n\\n    stack := [][]int{points[0], points[1]}\\n    \\n    for p := 2; p < len(points); p++ {\\n        top := stack[len(stack) - 1]\\n        stack = stack[:len(stack) - 1]\\n        for orientation(stack[len(stack) - 1], top, points[p]) > 0 {\\n            top = stack[len(stack) - 1]\\n            stack = stack[:len(stack) - 1]\\n        }\\n        stack = append(stack, top)\\n        stack = append(stack, points[p])\\n    }\\n    return stack\\n}\\n\\nfunc bottomLeft(points [][]int) []int {\\n    res := points[0]\\n    for _, v := range points {\\n        if v[1] < res[1] {\\n            res = v\\n        }\\n    }\\n    return res\\n}\\n\\nfunc orientation(p []int, q []int, r []int) int {\\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\\n}\\n\\nfunc distance(p []int, q []int) int {\\n    return (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 792325,
                "title": "rust-translated-8ms-2-2m-100",
                "content": "```\\npub fn outer_trees(points: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n    use std::collections::HashSet;\\n\\n    fn orientation(p: &[i32], q: &[i32], r: &[i32]) -> i32 {\\n        (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\\n    }\\n\\n    let mut points = points;\\n    if points.len() <= 1 {\\n        return points;\\n    }\\n    points.sort_by(|p, q| p[0].cmp(&q[0]).then(p[1].cmp(&q[1])));\\n\\n    let mut hull = Vec::<Vec<i32>>::new();\\n    let n = points.len();\\n    for i in 0..n {\\n        while hull.len() >= 2\\n            && orientation(\\n                hull.get(hull.len() - 2).unwrap(),\\n                hull.get(hull.len() - 1).unwrap(),\\n                &points[i],\\n            ) > 0\\n        {\\n            hull.pop();\\n        }\\n        hull.push(points[i].clone());\\n    }\\n    for i in (0..n).rev() {\\n        while hull.len() >= 2\\n            && orientation(\\n                hull.get(hull.len() - 2).unwrap(),\\n                hull.get(hull.len() - 1).unwrap(),\\n                &points[i],\\n            ) > 0\\n        {\\n            hull.pop();\\n        }\\n        hull.push(points[i].clone());\\n    }\\n    let mut set = HashSet::<Vec<i32>>::new();\\n    for v in hull {\\n        set.insert(v);\\n    }\\n    let mut ans = vec![];\\n    for v in set {\\n        ans.push(v);\\n    }\\n    ans\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npub fn outer_trees(points: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n    use std::collections::HashSet;\\n\\n    fn orientation(p: &[i32], q: &[i32], r: &[i32]) -> i32 {\\n        (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\\n    }\\n\\n    let mut points = points;\\n    if points.len() <= 1 {\\n        return points;\\n    }\\n    points.sort_by(|p, q| p[0].cmp(&q[0]).then(p[1].cmp(&q[1])));\\n\\n    let mut hull = Vec::<Vec<i32>>::new();\\n    let n = points.len();\\n    for i in 0..n {\\n        while hull.len() >= 2\\n            && orientation(\\n                hull.get(hull.len() - 2).unwrap(),\\n                hull.get(hull.len() - 1).unwrap(),\\n                &points[i],\\n            ) > 0\\n        {\\n            hull.pop();\\n        }\\n        hull.push(points[i].clone());\\n    }\\n    for i in (0..n).rev() {\\n        while hull.len() >= 2\\n            && orientation(\\n                hull.get(hull.len() - 2).unwrap(),\\n                hull.get(hull.len() - 1).unwrap(),\\n                &points[i],\\n            ) > 0\\n        {\\n            hull.pop();\\n        }\\n        hull.push(points[i].clone());\\n    }\\n    let mut set = HashSet::<Vec<i32>>::new();\\n    for v in hull {\\n        set.insert(v);\\n    }\\n    let mut ans = vec![];\\n    for v in set {\\n        ans.push(v);\\n    }\\n    ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181735,
                "title": "two-scan-graham-java-solution",
                "content": "```\\nclass Solution {\\n    public List<Point> outerTrees(Point[] points) {\\n        if (points.length == 1) {\\n            List<Point> res = new ArrayList<>();\\n            res.add(points[0]);\\n            return res;\\n        }\\n        int n = points.length;\\n        Arrays.sort(points,(a,b) -> a.y == b.y ? a.x-b.x:a.y-b.y);\\n        HashSet<ArrayList<Integer>> dup = new HashSet();\\n        List<Point> res = new ArrayList<>();\\n        Stack<Point> hull = new Stack<>();\\n        hull.push(points[0]);\\n        hull.push(points[1]);\\n        // Graham scan; \\n        for (int i = 2; i < n; i++) {\\n            Point top = hull.pop();\\n            while (!hull.isEmpty() && ccw(hull.peek(), top, points[i]) < 0) {\\n                top = hull.pop();\\n            }\\n            hull.push(top);\\n            hull.push(points[i]);\\n        }\\n        for(int i = n-2;i>=0;i--) {\\n            Point top = hull.pop();\\n            while (!hull.isEmpty() && ccw(hull.peek(), top, points[i]) < 0) {\\n                top = hull.pop();\\n            }\\n            hull.push(top);\\n            hull.push(points[i]);\\n        }\\n        for(Point x: hull) {\\n            ArrayList<Integer> tmp = new ArrayList<>();\\n            tmp.add(x.x);tmp.add(x.y);\\n            if(dup.contains(tmp)) continue;\\n            dup.add(tmp);\\n            res.add(x);\\n        }\\n        return res;\\n    }\\n    public int ccw(Point a, Point b, Point c) {\\n        double area2 = (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);\\n        if      (area2 < 0) return -1;\\n        else if (area2 > 0) return +1;\\n        else                return  0;\\n    }\\n}\\n```\\nreferenced links.\\nhttps://blog.csdn.net/jiang199235jiangjj/article/details/7954512\\nhttps://www.bilibili.com/video/av9005901/?p=12\\nhttps://blog.csdn.net/u013532224/article/details/38587137",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Point> outerTrees(Point[] points) {\\n        if (points.length == 1) {\\n            List<Point> res = new ArrayList<>();\\n            res.add(points[0]);\\n            return res;\\n        }\\n        int n = points.length;\\n        Arrays.sort(points,(a,b) -> a.y == b.y ? a.x-b.x:a.y-b.y);\\n        HashSet<ArrayList<Integer>> dup = new HashSet();\\n        List<Point> res = new ArrayList<>();\\n        Stack<Point> hull = new Stack<>();\\n        hull.push(points[0]);\\n        hull.push(points[1]);\\n        // Graham scan; \\n        for (int i = 2; i < n; i++) {\\n            Point top = hull.pop();\\n            while (!hull.isEmpty() && ccw(hull.peek(), top, points[i]) < 0) {\\n                top = hull.pop();\\n            }\\n            hull.push(top);\\n            hull.push(points[i]);\\n        }\\n        for(int i = n-2;i>=0;i--) {\\n            Point top = hull.pop();\\n            while (!hull.isEmpty() && ccw(hull.peek(), top, points[i]) < 0) {\\n                top = hull.pop();\\n            }\\n            hull.push(top);\\n            hull.push(points[i]);\\n        }\\n        for(Point x: hull) {\\n            ArrayList<Integer> tmp = new ArrayList<>();\\n            tmp.add(x.x);tmp.add(x.y);\\n            if(dup.contains(tmp)) continue;\\n            dup.add(tmp);\\n            res.add(x);\\n        }\\n        return res;\\n    }\\n    public int ccw(Point a, Point b, Point c) {\\n        double area2 = (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);\\n        if      (area2 < 0) return -1;\\n        else if (area2 > 0) return +1;\\n        else                return  0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103324,
                "title": "quickhull-c-solution-29ms",
                "content": "Pseudo code (from Wikipedia):\\n   Input = a set S of n points \\n   Assume that there are at least 2 points in the input set S of points\\n   QuickHull (S) \\n   { \\n       // Find convex hull from the set S of n points\\n       Convex Hull := {} \\n       Find left and right most points, say A & B, and add A & B to convex hull \\n       Segment AB divides the remaining (n-2) points into 2 groups S1 and S2 \\n           where S1 are points in S that are on the right side of the oriented line from A to B, \\n           and S2 are points in S that are on the right side of the oriented line from B to A \\n       FindHull (S1, A, B) \\n       FindHull (S2, B, A) \\n   }\\n   FindHull (Sk, P, Q) \\n   { \\n       // Find points on convex hull from the set Sk of points \\n       // that are on the right side of the oriented line from P to Q\\n       If Sk has no point, then return. \\n       From the given set of points in Sk, find farthest point, say C, from segment PQ \\n       Add point C to convex hull at the location between P and Q \\n       Three points P, Q, and C partition the remaining points of Sk into 3 subsets: S0, S1, and S2 \\n           where S0 are points inside triangle PCQ, S1 are points on the right side of the oriented \\n           line from  P to C, and S2 are points on the right side of the oriented line from C to Q. \\n       FindHull(S1, P, C) \\n       FindHull(S2, C, Q) \\n   }\\n   Output = convex hull\\n\\n\\n````\\nclass Solution {\\npublic:\\n    static bool mycmp(Point &a, Point &b) {\\n        return a.x < b.x;\\n    }\\n    \\n    int testSide(Point &a, Point &b, Point &c) {\\n        // cross product of (AB and AC vectors)\\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\\n    }\\n    \\n    double distPointLine(Point &A, Point &B, Point &C) {\\n        // dist(line: ax+by+c=0, and point(x0, y0)): (a*x0 + b*y0 + c)/sqrt(a^2+b^2)\\n        // line: (y2-y1)*x - (x2-x1)*y + x2*y1 - y2*x1 = 0\\n        int a = B.y - A.y, b = B.x - A.x;\\n        return abs((a*C.x - b*C.y + B.x*A.y - B.y*A.x)/sqrt(a*a + b*b));\\n    }\\n    \\n    void FindHull(vector<Point> &points, Point &A, Point &B) {\\n        if (points.empty())\\n            return;\\n        \\n        int idx = 0;\\n        double dist = distPointLine(A, B, points[0]);\\n        for (int i=1; i<points.size(); i++) {\\n            if (distPointLine(A, B, points[i]) > dist) {\\n                dist = distPointLine(A, B, points[i]);\\n                idx = i;\\n            }\\n        }\\n        ret.push_back(points[idx]);\\n        \\n        vector<Point> R, T;\\n        for (int i=0; i<points.size(); i++) {\\n            if (i != idx) {\\n                int tmp = testSide(A, points[idx], points[i]);\\n                if (tmp >= 0)\\n                    R.push_back(points[i]);\\n                else {\\n                    tmp = testSide(points[idx], B, points[i]);\\n                    if (tmp >= 0)\\n                        T.push_back(points[i]);\\n                }\\n            }\\n        }\\n        FindHull(R, A, points[idx]);\\n        FindHull(T, points[idx], B);\\n        \\n        return;\\n    }\\n    \\n    vector<Point> ret;\\n    \\n    vector<Point> outerTrees(vector<Point>& points) {\\n        // find the convex hull; use QuickHull algorithm\\n        if (points.size() <= 1)\\n            return points;\\n        \\n        // find the left most and right most two points\\n        sort(points.begin(), points.end(), mycmp);\\n        ret.push_back(points[0]);\\n        ret.push_back(points.back());\\n        \\n        // test whether a point on the left side right side or on the line\\n        vector<Point> Left, Right, Online;\\n        for (int i=1; i<points.size()-1; i++) {\\n            int tmp = testSide(points[0], points.back(), points[i]);\\n            if (tmp < 0)\\n                Right.push_back(points[i]);\\n            else if (tmp > 0)\\n                Left.push_back(points[i]);\\n            else\\n                Online.push_back(points[i]);\\n        }\\n        // if Upper or Down is empty, Online should be pushed into ret\\n        if (Left.empty() || Right.empty())\\n            for (int i=0; i<Online.size(); i++)\\n                ret.push_back(Online[i]);\\n\\n        FindHull(Left, points[0], points.back());\\n        FindHull(Right, points.back(), points[0]);\\n        \\n        return ret;\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\npublic:\\n    static bool mycmp(Point &a, Point &b) {\\n        return a.x < b.x;\\n    }\\n    \\n    int testSide(Point &a, Point &b, Point &c) {\\n        // cross product of (AB and AC vectors)\\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\\n    }\\n    \\n    double distPointLine(Point &A, Point &B, Point &C) {\\n        // dist(line: ax+by+c=0, and point(x0, y0)): (a*x0 + b*y0 + c)/sqrt(a^2+b^2)\\n        // line: (y2-y1)*x - (x2-x1)*y + x2*y1 - y2*x1 = 0\\n        int a = B.y - A.y, b = B.x - A.x;\\n        return abs((a*C.x - b*C.y + B.x*A.y - B.y*A.x)/sqrt(a*a + b*b));\\n    }\\n    \\n    void FindHull(vector<Point> &points, Point &A, Point &B) {\\n        if (points.empty())\\n            return;\\n        \\n        int idx = 0;\\n        double dist = distPointLine(A, B, points[0]);\\n        for (int i=1; i<points.size(); i++) {\\n            if (distPointLine(A, B, points[i]) > dist) {\\n                dist = distPointLine(A, B, points[i]);\\n                idx = i;\\n            }\\n        }\\n        ret.push_back(points[idx]);\\n        \\n        vector<Point> R, T;\\n        for (int i=0; i<points.size(); i++) {\\n            if (i != idx) {\\n                int tmp = testSide(A, points[idx], points[i]);\\n                if (tmp >= 0)\\n                    R.push_back(points[i]);\\n                else {\\n                    tmp = testSide(points[idx], B, points[i]);\\n                    if (tmp >= 0)\\n                        T.push_back(points[i]);\\n                }\\n            }\\n        }\\n        FindHull(R, A, points[idx]);\\n        FindHull(T, points[idx], B);\\n        \\n        return;\\n    }\\n    \\n    vector<Point> ret;\\n    \\n    vector<Point> outerTrees(vector<Point>& points) {\\n        // find the convex hull; use QuickHull algorithm\\n        if (points.size() <= 1)\\n            return points;\\n        \\n        // find the left most and right most two points\\n        sort(points.begin(), points.end(), mycmp);\\n        ret.push_back(points[0]);\\n        ret.push_back(points.back());\\n        \\n        // test whether a point on the left side right side or on the line\\n        vector<Point> Left, Right, Online;\\n        for (int i=1; i<points.size()-1; i++) {\\n            int tmp = testSide(points[0], points.back(), points[i]);\\n            if (tmp < 0)\\n                Right.push_back(points[i]);\\n            else if (tmp > 0)\\n                Left.push_back(points[i]);\\n            else\\n                Online.push_back(points[i]);\\n        }\\n        // if Upper or Down is empty, Online should be pushed into ret\\n        if (Left.empty() || Right.empty())\\n            for (int i=0; i<Online.size(); i++)\\n                ret.push_back(Online[i]);\\n\\n        FindHull(Left, points[0], points.back());\\n        FindHull(Right, points.back(), points[0]);\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409213,
                "title": "solution",
                "content": "```C++ []\\nstruct pt {\\n    int x, y;\\n    pt(int x, int y): x(x), y(y){}\\n};\\nint orientation(pt a, pt b, pt c) {\\n    int v = a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y);\\n    if (v < 0) return -1;\\n    if (v > 0) return +1;\\n    return 0;\\n}\\nbool cw(pt a, pt b, pt c, bool include_collinear) {\\n    int o = orientation(a, b, c);\\n    return o < 0 || (include_collinear && o == 0);\\n}\\nbool ccw(pt a, pt b, pt c, bool include_collinear) {\\n    int o = orientation(a, b, c);\\n    return o > 0 || (include_collinear && o == 0);\\n}\\nvoid convex_hull(vector<pt>& a, bool include_collinear = false) {\\n    if (a.size() == 1)\\n        return;\\n\\n    sort(a.begin(), a.end(), [](pt a, pt b) {\\n        return make_pair(a.x, a.y) < make_pair(b.x, b.y);\\n    });\\n    pt p1 = a[0], p2 = a.back();\\n    vector<pt> up, down;\\n    up.push_back(p1);\\n    down.push_back(p1);\\n    for (int i = 1; i < (int)a.size(); i++) {\\n        if (i == a.size() - 1 || cw(p1, a[i], p2, include_collinear)) {\\n            while (up.size() >= 2 && !cw(up[up.size()-2], up[up.size()-1], a[i], include_collinear))\\n                up.pop_back();\\n            up.push_back(a[i]);\\n        }\\n        if (i == a.size() - 1 || ccw(p1, a[i], p2, include_collinear)) {\\n            while (down.size() >= 2 && !ccw(down[down.size()-2], down[down.size()-1], a[i], include_collinear))\\n                down.pop_back();\\n            down.push_back(a[i]);\\n        }\\n    }\\n    if (include_collinear && up.size() == a.size()) {\\n        reverse(a.begin(), a.end());\\n        return;\\n    }\\n    a.clear();\\n    for (int i = 0; i < (int)up.size(); i++)\\n        a.push_back(up[i]);\\n    for (int i = down.size() - 2; i > 0; i--)\\n        a.push_back(down[i]);\\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        int n = trees.size();\\n        vector<pt> res;\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < n; ++i) {\\n            res.push_back(pt(trees[i][0], trees[i][1]));\\n        }\\n        convex_hull(res, true);\\n        for(auto p: res) {\\n            ans.push_back({p.x, p.y});\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        yToX = {}\\n        for x,y in trees:\\n            if y not in yToX:\\n                yToX[y] = [x]\\n            else:\\n                yToX[y].append(x)\\n        for y in yToX:\\n            yToX[y].sort()\\n        lowerYToHigherY = sorted(yToX.keys())\\n        \\n        leftresults = []\\n        for y in lowerYToHigherY:\\n            curx = yToX[y][0]\\n            if len(leftresults) < 2:\\n                leftresults.append((curx, y))\\n            else:\\n                lastx, lasty = leftresults[-1]\\n                lastlastx, lastlasty = leftresults[-2]\\n                lastdx, lastdy = lastx-lastlastx, lasty-lastlasty\\n                curdx, curdy = curx-lastlastx, y-lastlasty\\n                while curdx/curdy < lastdx/lastdy:\\n                    leftresults.pop()\\n                    if len(leftresults) >= 2:\\n                        lastx, lasty = leftresults[-1]\\n                        lastlastx, lastlasty = leftresults[-2]\\n                        lastdx, lastdy = lastx-lastlastx, lasty-lastlasty\\n                        curdx, curdy = curx-lastlastx, y-lastlasty\\n                    else:\\n                        break\\n                leftresults.append((curx, y))\\n        rightresults = []\\n        for y in lowerYToHigherY:\\n            curx = yToX[y][-1]\\n            if len(rightresults) < 2:\\n                rightresults.append((curx, y))\\n            else:\\n                lastx, lasty = rightresults[-1]\\n                lastlastx, lastlasty = rightresults[-2]\\n                lastdx, lastdy = lastx-lastlastx, lasty-lastlasty\\n                curdx, curdy = curx-lastlastx, y-lastlasty\\n                while curdx/curdy > lastdx/lastdy:\\n                    rightresults.pop()\\n                    if len(rightresults) >= 2:\\n                        lastx, lasty = rightresults[-1]\\n                        lastlastx, lastlasty = rightresults[-2]\\n                        lastdx, lastdy = lastx-lastlastx, lasty-lastlasty\\n                        curdx, curdy = curx-lastlastx, y-lastlasty\\n                    else:\\n                        break\\n                rightresults.append((curx, y))\\n        res = leftresults[1:-1] + rightresults[1:-1]\\n        lowest = [(x,lowerYToHigherY[0]) for x in yToX[lowerYToHigherY[0]]]\\n        highest = [(x,lowerYToHigherY[-1]) for x in yToX[lowerYToHigherY[-1]]]\\n        res += lowest + highest\\n        res = set(res)\\n        return [list(x) for x in res]\\n```\\n\\n```Java []\\nclass Solution { \\n    public int[][] outerTrees(int[][] trees) {\\n        Arrays.sort(trees, (o1, o2) -> o1[0] != o2[0] ? o1[0] - o2[0] : o1[1] - o2[1]);\\n        int n = trees.length;\\n        boolean[] used = new boolean[n];\\n        int[] hull = new int[n + 2];\\n        int top = 0;\\n        for (int i = 0; i < n; i++) {\\n            while (top >= 2 && area(trees[hull[top - 1]], trees[hull[top]], trees[i]) > 0) {\\n                used[hull[top--]] = false;\\n            }\\n            hull[++top] = i;\\n            used[i] = true;\\n        }\\n        used[0] = false;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (used[i]) continue;\\n            while (top >= 2 && area(trees[hull[top - 1]], trees[hull[top]], trees[i]) > 0) {\\n                top--;\\n            }\\n            hull[++top] = i;\\n        }\\n        top--;\\n        int[][] res = new int[top][2];\\n        for (int i = 1; i <= top; i++) res[i - 1] = trees[hull[i]];\\n        return res;\\n    }\\n    private int area(int[] a, int[] b, int[] c) {\\n        return cross(b[0] - a[0], b[1] - a[1], c[0] - a[0], c[1] - a[1]);\\n    }\\n    private int cross(int x1, int y1, int x2, int y2) {\\n        return x1 * y2 - x2 * y1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nstruct pt {\\n    int x, y;\\n    pt(int x, int y): x(x), y(y){}\\n};\\nint orientation(pt a, pt b, pt c) {\\n    int v = a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y);\\n    if (v < 0) return -1;\\n    if (v > 0) return +1;\\n    return 0;\\n}\\nbool cw(pt a, pt b, pt c, bool include_collinear) {\\n    int o = orientation(a, b, c);\\n    return o < 0 || (include_collinear && o == 0);\\n}\\nbool ccw(pt a, pt b, pt c, bool include_collinear) {\\n    int o = orientation(a, b, c);\\n    return o > 0 || (include_collinear && o == 0);\\n}\\nvoid convex_hull(vector<pt>& a, bool include_collinear = false) {\\n    if (a.size() == 1)\\n        return;\\n\\n    sort(a.begin(), a.end(), [](pt a, pt b) {\\n        return make_pair(a.x, a.y) < make_pair(b.x, b.y);\\n    });\\n    pt p1 = a[0], p2 = a.back();\\n    vector<pt> up, down;\\n    up.push_back(p1);\\n    down.push_back(p1);\\n    for (int i = 1; i < (int)a.size(); i++) {\\n        if (i == a.size() - 1 || cw(p1, a[i], p2, include_collinear)) {\\n            while (up.size() >= 2 && !cw(up[up.size()-2], up[up.size()-1], a[i], include_collinear))\\n                up.pop_back();\\n            up.push_back(a[i]);\\n        }\\n        if (i == a.size() - 1 || ccw(p1, a[i], p2, include_collinear)) {\\n            while (down.size() >= 2 && !ccw(down[down.size()-2], down[down.size()-1], a[i], include_collinear))\\n                down.pop_back();\\n            down.push_back(a[i]);\\n        }\\n    }\\n    if (include_collinear && up.size() == a.size()) {\\n        reverse(a.begin(), a.end());\\n        return;\\n    }\\n    a.clear();\\n    for (int i = 0; i < (int)up.size(); i++)\\n        a.push_back(up[i]);\\n    for (int i = down.size() - 2; i > 0; i--)\\n        a.push_back(down[i]);\\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        int n = trees.size();\\n        vector<pt> res;\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < n; ++i) {\\n            res.push_back(pt(trees[i][0], trees[i][1]));\\n        }\\n        convex_hull(res, true);\\n        for(auto p: res) {\\n            ans.push_back({p.x, p.y});\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        yToX = {}\\n        for x,y in trees:\\n            if y not in yToX:\\n                yToX[y] = [x]\\n            else:\\n                yToX[y].append(x)\\n        for y in yToX:\\n            yToX[y].sort()\\n        lowerYToHigherY = sorted(yToX.keys())\\n        \\n        leftresults = []\\n        for y in lowerYToHigherY:\\n            curx = yToX[y][0]\\n            if len(leftresults) < 2:\\n                leftresults.append((curx, y))\\n            else:\\n                lastx, lasty = leftresults[-1]\\n                lastlastx, lastlasty = leftresults[-2]\\n                lastdx, lastdy = lastx-lastlastx, lasty-lastlasty\\n                curdx, curdy = curx-lastlastx, y-lastlasty\\n                while curdx/curdy < lastdx/lastdy:\\n                    leftresults.pop()\\n                    if len(leftresults) >= 2:\\n                        lastx, lasty = leftresults[-1]\\n                        lastlastx, lastlasty = leftresults[-2]\\n                        lastdx, lastdy = lastx-lastlastx, lasty-lastlasty\\n                        curdx, curdy = curx-lastlastx, y-lastlasty\\n                    else:\\n                        break\\n                leftresults.append((curx, y))\\n        rightresults = []\\n        for y in lowerYToHigherY:\\n            curx = yToX[y][-1]\\n            if len(rightresults) < 2:\\n                rightresults.append((curx, y))\\n            else:\\n                lastx, lasty = rightresults[-1]\\n                lastlastx, lastlasty = rightresults[-2]\\n                lastdx, lastdy = lastx-lastlastx, lasty-lastlasty\\n                curdx, curdy = curx-lastlastx, y-lastlasty\\n                while curdx/curdy > lastdx/lastdy:\\n                    rightresults.pop()\\n                    if len(rightresults) >= 2:\\n                        lastx, lasty = rightresults[-1]\\n                        lastlastx, lastlasty = rightresults[-2]\\n                        lastdx, lastdy = lastx-lastlastx, lasty-lastlasty\\n                        curdx, curdy = curx-lastlastx, y-lastlasty\\n                    else:\\n                        break\\n                rightresults.append((curx, y))\\n        res = leftresults[1:-1] + rightresults[1:-1]\\n        lowest = [(x,lowerYToHigherY[0]) for x in yToX[lowerYToHigherY[0]]]\\n        highest = [(x,lowerYToHigherY[-1]) for x in yToX[lowerYToHigherY[-1]]]\\n        res += lowest + highest\\n        res = set(res)\\n        return [list(x) for x in res]\\n```\n```Java []\\nclass Solution { \\n    public int[][] outerTrees(int[][] trees) {\\n        Arrays.sort(trees, (o1, o2) -> o1[0] != o2[0] ? o1[0] - o2[0] : o1[1] - o2[1]);\\n        int n = trees.length;\\n        boolean[] used = new boolean[n];\\n        int[] hull = new int[n + 2];\\n        int top = 0;\\n        for (int i = 0; i < n; i++) {\\n            while (top >= 2 && area(trees[hull[top - 1]], trees[hull[top]], trees[i]) > 0) {\\n                used[hull[top--]] = false;\\n            }\\n            hull[++top] = i;\\n            used[i] = true;\\n        }\\n        used[0] = false;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (used[i]) continue;\\n            while (top >= 2 && area(trees[hull[top - 1]], trees[hull[top]], trees[i]) > 0) {\\n                top--;\\n            }\\n            hull[++top] = i;\\n        }\\n        top--;\\n        int[][] res = new int[top][2];\\n        for (int i = 1; i <= top; i++) res[i - 1] = trees[hull[i]];\\n        return res;\\n    }\\n    private int area(int[] a, int[] b, int[] c) {\\n        return cross(b[0] - a[0], b[1] - a[1], c[0] - a[0], c[1] - a[1]);\\n    }\\n    private int cross(int x1, int y1, int x2, int y2) {\\n        return x1 * y2 - x2 * y1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834463,
                "title": "optimal-solution-fast-as-hell-cpp-easy-tree",
                "content": "# Fast as Hell | CPP |Easy\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    \\n    using tree = vector<int>;\\n    //Thanks to Bhalerao-2002\\n    vector<tree> outerTrees(vector<tree>& trees) \\n    {\\n        auto cross = [](tree& B, tree& A, tree& T) -> int\\n        {\\n            return (T[1]-B[1])*(B[0]-A[0]) - (B[1]-A[1])*(T[0]-B[0]);\\n        };\\n        \\n        sort(trees.begin(), trees.end());\\n        //Sorting whole tree\\n        deque<tree> F;\\n        \\n        for (tree T : trees)\\n        {\\n            while (F.size() >= 2 and cross(F[F.size()-1],F[F.size()-2],T) < 0)\\n                F.pop_back();\\n            F.push_back(T);\\n\\n            while (F.size() >= 2 and cross(F[0],F[1],T) > 0)\\n                F.pop_front();\\n            F.push_front(T);\\n        }\\n        \\n        set<tree> unique(F.begin(), F.end());\\n        return vector<tree>(unique.begin(), unique.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    \\n    using tree = vector<int>;\\n    //Thanks to Bhalerao-2002\\n    vector<tree> outerTrees(vector<tree>& trees) \\n    {\\n        auto cross = [](tree& B, tree& A, tree& T) -> int\\n        {\\n            return (T[1]-B[1])*(B[0]-A[0]) - (B[1]-A[1])*(T[0]-B[0]);\\n        };\\n        \\n        sort(trees.begin(), trees.end());\\n        //Sorting whole tree\\n        deque<tree> F;\\n        \\n        for (tree T : trees)\\n        {\\n            while (F.size() >= 2 and cross(F[F.size()-1],F[F.size()-2],T) < 0)\\n                F.pop_back();\\n            F.push_back(T);\\n\\n            while (F.size() >= 2 and cross(F[0],F[1],T) > 0)\\n                F.pop_front();\\n            F.push_front(T);\\n        }\\n        \\n        set<tree> unique(F.begin(), F.end());\\n        return vector<tree>(unique.begin(), unique.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832924,
                "title": "c-using-convex-hull-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConvex Hull Algorithm:\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getRotationAngle(vector<int> a, vector<int> b, vector<int> c){\\n        //(x2-x1)(y3-y1) - (y2-y1)(x3 - x1) cross product of ab and ac vector\\n        return ((b[0] - a[0]) * (c[1] - a[1])) - ((b[1] - a[1]) * (c[0] - a[0]));\\n    }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        //by using convex Hull algorithm\\n        if(trees.size() <= 3) return trees; // if less than equal to 3 then all need to include\\n        sort(trees.begin(), trees.end()); // sort them in lexo manner(according to order of x coordinates);\\n        vector<vector<int>> upperHull; //creating upper hull\\n        //pushing two points in upper hUll as \\'a\\' and \\'b\\';\\n        upperHull.push_back(trees[0]);\\n        upperHull.push_back(trees[1]);\\n        for(int i=2;i<trees.size();i++){ // considering it as \\'c\\' start traversing from index 2\\n            int Uhs =upperHull.size();\\n            //slop / cross product should be greater than 0 counter clock wise angle remove b and add c\\n            while(upperHull.size() >= 2 && getRotationAngle(upperHull[Uhs - 2], upperHull[Uhs - 1], trees[i]) > 0){\\n                upperHull.pop_back();\\n                Uhs--;\\n            }\\n            upperHull.push_back(trees[i]);\\n        }\\n        vector<vector<int>> lowerHull; //creating lower hull\\n        //same steps for lower hull as upper hull but reversed array of trees\\n        lowerHull.push_back(trees[trees.size() - 1]);\\n        lowerHull.push_back(trees[trees.size() - 2]);\\n        for(int i=trees.size() - 3;i>=0;i--){\\n            int lhs = lowerHull.size();\\n            while(lowerHull.size() >= 2 && getRotationAngle(lowerHull[lhs - 2], lowerHull[lhs - 1], trees[i]) > 0){\\n                lowerHull.pop_back();\\n                lhs--;\\n            }\\n            lowerHull.push_back(trees[i]);\\n        }\\n        //now merge upperhull and lowerHUll using STL\\n        upperHull.insert(upperHull.end(), lowerHull.begin(), lowerHull.end());\\n        //now remove the duplicates from the merged upper hull\\n        sort(upperHull.begin(), upperHull.end());\\n        upperHull.erase(unique(upperHull.begin(), upperHull.end()), upperHull.end());\\n        return upperHull;\\n    }\\n};\\n\\nPlease Upvote..\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getRotationAngle(vector<int> a, vector<int> b, vector<int> c){\\n        //(x2-x1)(y3-y1) - (y2-y1)(x3 - x1) cross product of ab and ac vector\\n        return ((b[0] - a[0]) * (c[1] - a[1])) - ((b[1] - a[1]) * (c[0] - a[0]));\\n    }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        //by using convex Hull algorithm\\n        if(trees.size() <= 3) return trees; // if less than equal to 3 then all need to include\\n        sort(trees.begin(), trees.end()); // sort them in lexo manner(according to order of x coordinates);\\n        vector<vector<int>> upperHull; //creating upper hull\\n        //pushing two points in upper hUll as \\'a\\' and \\'b\\';\\n        upperHull.push_back(trees[0]);\\n        upperHull.push_back(trees[1]);\\n        for(int i=2;i<trees.size();i++){ // considering it as \\'c\\' start traversing from index 2\\n            int Uhs =upperHull.size();\\n            //slop / cross product should be greater than 0 counter clock wise angle remove b and add c\\n            while(upperHull.size() >= 2 && getRotationAngle(upperHull[Uhs - 2], upperHull[Uhs - 1], trees[i]) > 0){\\n                upperHull.pop_back();\\n                Uhs--;\\n            }\\n            upperHull.push_back(trees[i]);\\n        }\\n        vector<vector<int>> lowerHull; //creating lower hull\\n        //same steps for lower hull as upper hull but reversed array of trees\\n        lowerHull.push_back(trees[trees.size() - 1]);\\n        lowerHull.push_back(trees[trees.size() - 2]);\\n        for(int i=trees.size() - 3;i>=0;i--){\\n            int lhs = lowerHull.size();\\n            while(lowerHull.size() >= 2 && getRotationAngle(lowerHull[lhs - 2], lowerHull[lhs - 1], trees[i]) > 0){\\n                lowerHull.pop_back();\\n                lhs--;\\n            }\\n            lowerHull.push_back(trees[i]);\\n        }\\n        //now merge upperhull and lowerHUll using STL\\n        upperHull.insert(upperHull.end(), lowerHull.begin(), lowerHull.end());\\n        //now remove the duplicates from the merged upper hull\\n        sort(upperHull.begin(), upperHull.end());\\n        upperHull.erase(unique(upperHull.begin(), upperHull.end()), upperHull.end());\\n        return upperHull;\\n    }\\n};\\n\\nPlease Upvote..\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832647,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) \\n    {\\n      int n = trees.size();\\n      if (n <= 3) return trees;\\n      sort(trees.begin(), trees.end(), [](const vector<int>& a, const vector<int>& b) {\\n        return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\\n      });\\n      vector<vector<int>> hull;\\n      for (int i = 0; i < n; ++i) {\\n        while (hull.size() >= 2 && cross(hull[hull.size() - 2], hull.back(), trees[i]) < 0) {\\n          hull.pop_back();\\n        }\\n        hull.push_back(trees[i]);\\n      }\\n      hull.pop_back();\\n      for (int i = n - 1; i >= 0; --i) {\\n        while (hull.size() >= 2 && cross(hull[hull.size() - 2], hull.back(), trees[i]) < 0) {\\n          hull.pop_back();\\n        }\\n        hull.push_back(trees[i]);\\n      }\\n      hull.pop_back();\\n      sort(hull.begin(), hull.end());\\n      hull.erase(unique(hull.begin(), hull.end()), hull.end());\\n      return hull;\\n    }\\nprivate:\\n    int cross(const vector<int>& a, const vector<int>& b, const vector<int>& c) {\\n      return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) \\n    {\\n      int n = trees.size();\\n      if (n <= 3) return trees;\\n      sort(trees.begin(), trees.end(), [](const vector<int>& a, const vector<int>& b) {\\n        return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\\n      });\\n      vector<vector<int>> hull;\\n      for (int i = 0; i < n; ++i) {\\n        while (hull.size() >= 2 && cross(hull[hull.size() - 2], hull.back(), trees[i]) < 0) {\\n          hull.pop_back();\\n        }\\n        hull.push_back(trees[i]);\\n      }\\n      hull.pop_back();\\n      for (int i = n - 1; i >= 0; --i) {\\n        while (hull.size() >= 2 && cross(hull[hull.size() - 2], hull.back(), trees[i]) < 0) {\\n          hull.pop_back();\\n        }\\n        hull.push_back(trees[i]);\\n      }\\n      hull.pop_back();\\n      sort(hull.begin(), hull.end());\\n      hull.erase(unique(hull.begin(), hull.end()), hull.end());\\n      return hull;\\n    }\\nprivate:\\n    int cross(const vector<int>& a, const vector<int>& b, const vector<int>& c) {\\n      return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831393,
                "title": "python-full-explanation",
                "content": "Python3 Solve\\nUsing convex hull algorithm with helper function.\\n\\nSummary:\\n\\nFind upper hull of polygon.\\nFind lower hull of polygon.\\nCombine both upper and lower hulls to form full polygon.\\n\\n---\\n\\nExplanation:\\n\\nHelper Function = comparing slopes:\\n- Create Helper function to compare slopes of 2 different lines created from 3 sorted points.\\n- Compare the slopes of the lines, find the difference between the slopes. \\n- ---1-Slope of the new line (made from connecting the new point to the last point) .\\n- ---vs \\n- ---2-Slope of previous line (created by connecting the last point with the point before that). \\n- This comparison decides whether the rotation of the lines is clockwise or counter clockwise.\\n- ---If the answer is negative = new line is clockwise. (add to Upper hull)\\n- ---If the answer is positive = new line is counter clockwise. (add to Lower hull)\\n\\nMain Function:\\n- Data must be sorted before starting loop.\\n- Start looping through the trees.\\n- At each tree check if the line formed from this tree to the previous is clockwise or counter clockwise to the line formed from the previous 2 points.\\n- ---check for lower and upper separately using while loops.\\n- ---if checking for upper hull and value is counter-clockwise = remove by popping from upper.\\n- ---if checking for lower hull and value is clockwise = remove by popping from lower.\\n- Add for loop\\'s current value to each hull so it can be checked on next while loops cycle.\\n- After sorting and adding to upper and lower hulls, combine hulls together.\\n- Use Set to prevent duplicate trees from entering final result.\\n- Return as a list.\\n\\n\\n---\\n\\n```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        def compare_slopes(point1, point2, point3):\\n            x_point1, y_point1 = point1\\n            x_point2, y_point2 = point2\\n            x_point3, y_point3 = point3\\n            return ((y_point3 - y_point2)*(x_point2 - x_point1)) - ((y_point2 - y_point1)*(x_point3 - x_point2))\\n\\n        trees.sort()\\n        upper, lower = [], []\\n        for point in trees:\\n            while len(upper) > 1 and compare_slopes(upper[-2], upper[-1], point) > 0:\\n                upper.pop()\\n            while len(lower) > 1 and compare_slopes(lower[-2], lower[-1], point) < 0:\\n                lower.pop()\\n            upper.append(tuple(point))\\n            lower.append(tuple(point))\\n        return list(set(upper + lower))\\n```\\n-fatalbanana",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        def compare_slopes(point1, point2, point3):\\n            x_point1, y_point1 = point1\\n            x_point2, y_point2 = point2\\n            x_point3, y_point3 = point3\\n            return ((y_point3 - y_point2)*(x_point2 - x_point1)) - ((y_point2 - y_point1)*(x_point3 - x_point2))\\n\\n        trees.sort()\\n        upper, lower = [], []\\n        for point in trees:\\n            while len(upper) > 1 and compare_slopes(upper[-2], upper[-1], point) > 0:\\n                upper.pop()\\n            while len(lower) > 1 and compare_slopes(lower[-2], lower[-1], point) < 0:\\n                lower.pop()\\n            upper.append(tuple(point))\\n            lower.append(tuple(point))\\n        return list(set(upper + lower))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831134,
                "title": "complicated-o-n-2-solution-c",
                "content": "# Intuition\\nThink of points as pivots and imagine rotating a long thread around the pivots\\n\\n# Approach\\nFind all points with least x, and all points with largest x, add them to solution. Now we do two things - \\n1) Start from largest y coordinate (among least x), and keep decreasing slope from infinity, finding the next point(s) having largest slope less than previous slope. Do this till we reach the point having max x.\\n2) Start from least y coordinate (among least x), and keep increasing slope from -infinity, finding the next point(s) having least slope greater than previous slope. Do this till we reach the point having max x.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int n,x,y,ix,d,dm,p,xm;\\n    float m,im,pm;\\n    int MIN = -1000, MAX = 1000;\\n    unordered_map<int,bool> M;\\n\\n    void fill(bool clock, vector<vector<int>>& trees){\\n\\n        x = ix;\\n\\n        if(clock){\\n\\n            y = MIN;\\n            pm = (float) MAX;\\n\\n            for(int i=0;i<n;i++){\\n                if(trees[i][0]==x){\\n                    if(trees[i][1]>y) y = trees[i][1];\\n                } \\n                if(trees[i][0]==xm) M[i]=true;\\n            }\\n\\n        }\\n        else{\\n\\n            y = MAX;\\n            pm = (float) MIN;\\n\\n            for(int i=0;i<n;i++){\\n                if(trees[i][0]==x){\\n                    M[i] = true;\\n                    if(trees[i][1]<y) y = trees[i][1];\\n                } \\n            }\\n\\n        }\\n\\n        bool brk = false;\\n\\n        while(true){\\n            if(clock) im = (float) MIN;\\n            else im = (float) MAX;\\n            for(int i=0;i<n;i++){\\n                if(x==trees[i][0]) continue;\\n                m = ((float) (trees[i][1]-y))/((float) (trees[i][0]-x));\\n                if(clock && m<pm && m>im) im = m;\\n                if(!clock && m>pm && m<im) im = m;\\n            }\\n            if(im==MAX || im==MIN) break;\\n            dm = 0;\\n            pm = im;\\n            for(int i=0;i<n;i++){\\n                if(x==trees[i][0]) continue;\\n                m = ((float) (trees[i][1]-y))/((float) (trees[i][0]-x));\\n                if(m==pm){\\n                    if(ix==trees[i][0] || xm==trees[i][0]){\\n                        brk = true;\\n                        continue;\\n                    }\\n                    M[i] = true;\\n                    d = (trees[i][0]-x)*(trees[i][0]-x) + (trees[i][1]-y)*(trees[i][1]-y);\\n                    if(d>dm){\\n                        dm = d;\\n                        p = i;\\n                    } \\n                } \\n            }\\n            if(brk) break;\\n            x = trees[p][0];\\n            y = trees[p][1];\\n        }\\n    }\\n\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n\\n        ix = MAX;\\n        xm = MIN;\\n        n = trees.size(); \\n        for(int i=0;i<n;i++){\\n            if(trees[i][0]<ix) ix = trees[i][0];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(trees[i][0]>xm) xm = trees[i][0];\\n        }\\n\\n        fill(true, trees);\\n        if(ix!=xm) fill(false, trees);\\n\\n        vector<vector<int>> ans;\\n        for(auto i : M){\\n            if(i.second) ans.push_back(trees[i.first]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int n,x,y,ix,d,dm,p,xm;\\n    float m,im,pm;\\n    int MIN = -1000, MAX = 1000;\\n    unordered_map<int,bool> M;\\n\\n    void fill(bool clock, vector<vector<int>>& trees){\\n\\n        x = ix;\\n\\n        if(clock){\\n\\n            y = MIN;\\n            pm = (float) MAX;\\n\\n            for(int i=0;i<n;i++){\\n                if(trees[i][0]==x){\\n                    if(trees[i][1]>y) y = trees[i][1];\\n                } \\n                if(trees[i][0]==xm) M[i]=true;\\n            }\\n\\n        }\\n        else{\\n\\n            y = MAX;\\n            pm = (float) MIN;\\n\\n            for(int i=0;i<n;i++){\\n                if(trees[i][0]==x){\\n                    M[i] = true;\\n                    if(trees[i][1]<y) y = trees[i][1];\\n                } \\n            }\\n\\n        }\\n\\n        bool brk = false;\\n\\n        while(true){\\n            if(clock) im = (float) MIN;\\n            else im = (float) MAX;\\n            for(int i=0;i<n;i++){\\n                if(x==trees[i][0]) continue;\\n                m = ((float) (trees[i][1]-y))/((float) (trees[i][0]-x));\\n                if(clock && m<pm && m>im) im = m;\\n                if(!clock && m>pm && m<im) im = m;\\n            }\\n            if(im==MAX || im==MIN) break;\\n            dm = 0;\\n            pm = im;\\n            for(int i=0;i<n;i++){\\n                if(x==trees[i][0]) continue;\\n                m = ((float) (trees[i][1]-y))/((float) (trees[i][0]-x));\\n                if(m==pm){\\n                    if(ix==trees[i][0] || xm==trees[i][0]){\\n                        brk = true;\\n                        continue;\\n                    }\\n                    M[i] = true;\\n                    d = (trees[i][0]-x)*(trees[i][0]-x) + (trees[i][1]-y)*(trees[i][1]-y);\\n                    if(d>dm){\\n                        dm = d;\\n                        p = i;\\n                    } \\n                } \\n            }\\n            if(brk) break;\\n            x = trees[p][0];\\n            y = trees[p][1];\\n        }\\n    }\\n\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n\\n        ix = MAX;\\n        xm = MIN;\\n        n = trees.size(); \\n        for(int i=0;i<n;i++){\\n            if(trees[i][0]<ix) ix = trees[i][0];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(trees[i][0]>xm) xm = trees[i][0];\\n        }\\n\\n        fill(true, trees);\\n        if(ix!=xm) fill(false, trees);\\n\\n        vector<vector<int>> ans;\\n        for(auto i : M){\\n            if(i.second) ans.push_back(trees[i.first]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830902,
                "title": "bug-in-jarvis-algorithm-implementation-in-solution-panel",
                "content": "**Solution 01 [Jarvis Algorithm] Implementation has a bug.**\\n\\n**Test Case**: [[0,5],[10,0],[10,10],[0,10],[0,0]]\\n\\nThe implementation didn\\'t handle the case when left_most is collinear. it causes **infinite iteration**.\\n\\nUse the below code to get the starting point:\\n\\n```\\n//finds the bottom-most, left-most point\\n        int left_most = 0;\\n        for (int i = 0; i < points.length; i++) {\\n            if (points[i][1] <= points[left_most][1]) {\\n                if (points[i][1] < points[left_most][1]) {\\n                    left_most = i;\\n                } else if (points[i][0] < points[left_most][0]) {\\n                    left_most = i;\\n                }\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n//finds the bottom-most, left-most point\\n        int left_most = 0;\\n        for (int i = 0; i < points.length; i++) {\\n            if (points[i][1] <= points[left_most][1]) {\\n                if (points[i][1] < points[left_most][1]) {\\n                    left_most = i;\\n                } else if (points[i][0] < points[left_most][0]) {\\n                    left_most = i;\\n                }\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2830891,
                "title": "easy-python3-erect-the-fence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing convex hull algorithm also known as Gift wraping algorithm\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing distance formula inbetween the points (y3-y2)/(y2-y1)=(x3-x2)/(x2-x1)\\nif value is >0 then it is counter-clockwise \\nif it is equal to =0 the it is linear \\nelse if value is <0 then it is clockwise , and we have to see only counter clockwise\\nif value is <0 then we have to pop() that index, if =0 or >0 then append(), in lst we will have values both in upper and lower so we will be eliminate comman values using set function and returns the value with is sum of both upper hull and lower hull\\n#formore you can watch convex hull algorithm\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n T(n) = nh + n = o(nh)\\nwhere n = total no. of points  \\nand h = total no of hull\\\\\\nworst time complexity is o(n^2) when all are in hull\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(h)\\n\\n# Code\\n```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        def clockwise(p1,p2,p3):\\n            x1,y1=p1\\n            x2,y2=p2\\n            x3,y3=p3\\n            \\n            return ((y3-y2)*(x2-x1)-(y2-y1)*(x3-x2))\\n        trees.sort()\\n        upper=[]\\n        lower=[]\\n        for t in trees:\\n            while len(upper)>1 and clockwise(upper[-2],upper[-1],t)>0:\\n                upper.pop()\\n            while len(lower)>1 and clockwise(lower[-2],lower[-1],t)<0:\\n                lower.pop()\\n            upper.append(tuple(t))\\n            lower.append(tuple(t))\\n            \\n        return list(set(upper+lower))      \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        def clockwise(p1,p2,p3):\\n            x1,y1=p1\\n            x2,y2=p2\\n            x3,y3=p3\\n            \\n            return ((y3-y2)*(x2-x1)-(y2-y1)*(x3-x2))\\n        trees.sort()\\n        upper=[]\\n        lower=[]\\n        for t in trees:\\n            while len(upper)>1 and clockwise(upper[-2],upper[-1],t)>0:\\n                upper.pop()\\n            while len(lower)>1 and clockwise(lower[-2],lower[-1],t)<0:\\n                lower.pop()\\n            upper.append(tuple(t))\\n            lower.append(tuple(t))\\n            \\n        return list(set(upper+lower))      \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830884,
                "title": "php-top-bottom-solution",
                "content": "# Code\\n```\\nclass Solution \\n{   \\n\\n        /**\\n        * Get Angle \\n        *\\n        * @param array $x\\n        * @param array $y\\n        * @param array $z\\n        * @return integer|null\\n        */\\n        protected function getAngle(array $x, array $y, array $z):?int {\\n            return ($y[0] - $x[0]) * ($z[1] - $x[1]) - ($y[1] - $x[1]) * ($z[0] - $x[0]);\\n        }\\n\\n        /**\\n        * @param Integer[][] $trees\\n        * @return Integer[][]\\n        */\\n        function outerTrees($trees) \\n        {\\n            // If we have 3 or less trees, then all the x,y points will be results\\n            $len = count($trees);\\n            if($len <= 3) return $trees;\\n\\n            // Sort by the lowest tree points to the highest\\n            sort($trees);\\n            \\n            // Go From The Top To The Bottom\\n            $top = [];\\n            for($i = 0; $i < $len; $i++) {\\n                $topLen = count($top);\\n                // Valid Triangle\\n                while($topLen >= 2 && $this->getAngle($top[$topLen - 2], $top[$topLen - 1], $trees[$i]) > 0) {\\n                    array_pop($top);\\n                    $topLen--;\\n                }\\n                $top[] = $trees[$i];\\n            }\\n\\n            // Go From Bottom To The Top\\n            $bottom = [];\\n            for($i = $len - 1; $i >= 0; $i--) {\\n                $bottomLen = count($bottom);\\n                // Valid Triangle\\n                while($bottomLen >= 2 && $this->getAngle($bottom[$bottomLen - 2], $bottom[$bottomLen - 1], $trees[$i]) > 0) {\\n                    array_pop($bottom);\\n                    $bottomLen--;\\n                }\\n                $bottom[] = $trees[$i];\\n            }\\n\\n\\n            // Merge & Remove Duplicates\\n            return array_unique(array_merge($top, $bottom), SORT_REGULAR);\\n\\n        }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution \\n{   \\n\\n        /**\\n        * Get Angle \\n        *\\n        * @param array $x\\n        * @param array $y\\n        * @param array $z\\n        * @return integer|null\\n        */\\n        protected function getAngle(array $x, array $y, array $z):?int {\\n            return ($y[0] - $x[0]) * ($z[1] - $x[1]) - ($y[1] - $x[1]) * ($z[0] - $x[0]);\\n        }\\n\\n        /**\\n        * @param Integer[][] $trees\\n        * @return Integer[][]\\n        */\\n        function outerTrees($trees) \\n        {\\n            // If we have 3 or less trees, then all the x,y points will be results\\n            $len = count($trees);\\n            if($len <= 3) return $trees;\\n\\n            // Sort by the lowest tree points to the highest\\n            sort($trees);\\n            \\n            // Go From The Top To The Bottom\\n            $top = [];\\n            for($i = 0; $i < $len; $i++) {\\n                $topLen = count($top);\\n                // Valid Triangle\\n                while($topLen >= 2 && $this->getAngle($top[$topLen - 2], $top[$topLen - 1], $trees[$i]) > 0) {\\n                    array_pop($top);\\n                    $topLen--;\\n                }\\n                $top[] = $trees[$i];\\n            }\\n\\n            // Go From Bottom To The Top\\n            $bottom = [];\\n            for($i = $len - 1; $i >= 0; $i--) {\\n                $bottomLen = count($bottom);\\n                // Valid Triangle\\n                while($bottomLen >= 2 && $this->getAngle($bottom[$bottomLen - 2], $bottom[$bottomLen - 1], $trees[$i]) > 0) {\\n                    array_pop($bottom);\\n                    $bottomLen--;\\n                }\\n                $bottom[] = $trees[$i];\\n            }\\n\\n\\n            // Merge & Remove Duplicates\\n            return array_unique(array_merge($top, $bottom), SORT_REGULAR);\\n\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830854,
                "title": "efficient-python-solution-beats-100",
                "content": "This method constructs the upper and lower hulls faster than the approach detailed in the provided solution. We store the current sequence of points under consideration as a stack, and remove them when they become invalidated. The complex if statement determines whether on not the most recently inserted point has become invalid via gradient checks.\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        \\n        result = set()\\n        \\n        trees.sort()\\n        x_min = trees[0][0]\\n        x_max = trees[-1][0]\\n        for tree in trees:\\n            if tree[0] in {x_min,x_max}:\\n                result.add(tuple(tree))\\n        stack = deque([trees[0]])\\n        for tree in trees[1:]:\\n            if tree[0]!=stack[-1][0]:\\n                while len(stack)>1:\\n                    if (tree[0]-stack[-2][0])*(stack[-1][1]-stack[-2][1])>(stack[-1][0]-stack[-2][0])*(tree[1]-stack[-2][1]):\\n                        stack.pop()\\n                    else:\\n                        break\\n                stack.append(tree)\\n        result = result.union(set(tuple(tree) for tree in stack))\\n        stack = deque([trees[-1]])\\n        for tree in trees[:-1][::-1]:\\n            if tree[0]!=stack[-1][0]:\\n                while len(stack)>1:\\n                    if (tree[0]-stack[-2][0])*(stack[-1][1]-stack[-2][1])>(stack[-1][0]-stack[-2][0])*(tree[1]-stack[-2][1]):\\n                        stack.pop()\\n                    else:\\n                        break\\n                stack.append(tree)\\n        result = result.union(set(tuple(tree) for tree in stack))\\n        return result\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        \\n        result = set()\\n        \\n        trees.sort()\\n        x_min = trees[0][0]\\n        x_max = trees[-1][0]\\n        for tree in trees:\\n            if tree[0] in {x_min,x_max}:\\n                result.add(tuple(tree))\\n        stack = deque([trees[0]])\\n        for tree in trees[1:]:\\n            if tree[0]!=stack[-1][0]:\\n                while len(stack)>1:\\n                    if (tree[0]-stack[-2][0])*(stack[-1][1]-stack[-2][1])>(stack[-1][0]-stack[-2][0])*(tree[1]-stack[-2][1]):\\n                        stack.pop()\\n                    else:\\n                        break\\n                stack.append(tree)\\n        result = result.union(set(tuple(tree) for tree in stack))\\n        stack = deque([trees[-1]])\\n        for tree in trees[:-1][::-1]:\\n            if tree[0]!=stack[-1][0]:\\n                while len(stack)>1:\\n                    if (tree[0]-stack[-2][0])*(stack[-1][1]-stack[-2][1])>(stack[-1][0]-stack[-2][0])*(tree[1]-stack[-2][1]):\\n                        stack.pop()\\n                    else:\\n                        break\\n                stack.append(tree)\\n        result = result.union(set(tuple(tree) for tree in stack))\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830723,
                "title": "java-solution-monotone-chain-algorithm-faster-than-96-55-of-java-submissions",
                "content": "```\\nclass Solution {\\n    private int cross(int[] o, int[] a, int[] b){\\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\\n    }\\n    \\n    private int[][] convexHull(int[][] trees){\\n        java.util.Arrays.sort(trees, new java.util.Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] == b[0])\\n                    return a[1] - b[1];\\n                \\n                return a[0] - b[0];\\n            }\\n        });\\n        \\n        int[][] lowerAndUpper = new int[2 * trees.length][2];\\n        int k = 0;\\n        for (int i = 0; i < trees.length; i++){\\n            while (k >= 2 && this.cross(lowerAndUpper[k - 2], lowerAndUpper[k - 1], trees[i]) > 0)\\n                k--;\\n            lowerAndUpper[k++] = trees[i]; \\n        }\\n        for (int i = trees.length - 2, t = k + 1; i >= 0; i--){\\n            while (k >= t && this.cross(lowerAndUpper[k - 2], lowerAndUpper[k - 1], trees[i]) > 0)\\n                k--;\\n            lowerAndUpper[k++] = trees[i]; \\n        }\\n        \\n        if (k > 1) {\\n\\t\\t\\tlowerAndUpper = Arrays.copyOfRange(lowerAndUpper, 0, k - 1);\\n\\t\\t}\\n\\n        return lowerAndUpper;\\n    }\\n    \\n    public int[][] outerTrees(int[][] trees) {\\n        if (trees.length == 1)\\n            return trees;\\n        \\n        int[][] convexArray = this.convexHull(trees);\\n        java.util.Arrays.sort(convexArray, new java.util.Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] == b[0])\\n                    return a[1] - b[1];\\n                \\n                return a[0] - b[0];\\n            }\\n        });\\n        \\n        int[][] resultNoDuplicate = new int[convexArray.length][2];\\n        int lengthResult = 0;\\n        for (int i = 0; i < convexArray.length - 1; i++){\\n            if (convexArray[i][0] == convexArray[i+1][0] && convexArray[i][1] == convexArray[i+1][1])\\n                continue;\\n            resultNoDuplicate[lengthResult++] = convexArray[i];\\n        }\\n        resultNoDuplicate[lengthResult++] = convexArray[convexArray.length - 1];\\n        \\n        return Arrays.copyOfRange(resultNoDuplicate, 0, lengthResult);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int cross(int[] o, int[] a, int[] b){\\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\\n    }\\n    \\n    private int[][] convexHull(int[][] trees){\\n        java.util.Arrays.sort(trees, new java.util.Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] == b[0])\\n                    return a[1] - b[1];\\n                \\n                return a[0] - b[0];\\n            }\\n        });\\n        \\n        int[][] lowerAndUpper = new int[2 * trees.length][2];\\n        int k = 0;\\n        for (int i = 0; i < trees.length; i++){\\n            while (k >= 2 && this.cross(lowerAndUpper[k - 2], lowerAndUpper[k - 1], trees[i]) > 0)\\n                k--;\\n            lowerAndUpper[k++] = trees[i]; \\n        }\\n        for (int i = trees.length - 2, t = k + 1; i >= 0; i--){\\n            while (k >= t && this.cross(lowerAndUpper[k - 2], lowerAndUpper[k - 1], trees[i]) > 0)\\n                k--;\\n            lowerAndUpper[k++] = trees[i]; \\n        }\\n        \\n        if (k > 1) {\\n\\t\\t\\tlowerAndUpper = Arrays.copyOfRange(lowerAndUpper, 0, k - 1);\\n\\t\\t}\\n\\n        return lowerAndUpper;\\n    }\\n    \\n    public int[][] outerTrees(int[][] trees) {\\n        if (trees.length == 1)\\n            return trees;\\n        \\n        int[][] convexArray = this.convexHull(trees);\\n        java.util.Arrays.sort(convexArray, new java.util.Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] == b[0])\\n                    return a[1] - b[1];\\n                \\n                return a[0] - b[0];\\n            }\\n        });\\n        \\n        int[][] resultNoDuplicate = new int[convexArray.length][2];\\n        int lengthResult = 0;\\n        for (int i = 0; i < convexArray.length - 1; i++){\\n            if (convexArray[i][0] == convexArray[i+1][0] && convexArray[i][1] == convexArray[i+1][1])\\n                continue;\\n            resultNoDuplicate[lengthResult++] = convexArray[i];\\n        }\\n        resultNoDuplicate[lengthResult++] = convexArray[convexArray.length - 1];\\n        \\n        return Arrays.copyOfRange(resultNoDuplicate, 0, lengthResult);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830410,
                "title": "easy-c-solution-using-convex-hull",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cross(vector<int> A , vector<int> B , vector<int> C){\\n        // (x2-x1)(y3-y1) - (y2-y1)(x3-x1) -> 3D Cross-product of AB and AC vectors\\n        return ((B[0]-A[0])*(C[1]-A[1])) - ((C[0]-A[0])*(B[1]-A[1]));\\n    }\\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        if(trees.size() <= 3) return trees;\\n        sort(trees.begin() , trees.end());\\n\\n        vector<vector<int>> upperHull;\\n        upperHull.push_back(trees[0]);\\n        upperHull.push_back(trees[1]);\\n\\n        for(int i = 2 ; i<trees.size() ; i++){\\n            int Us = upperHull.size();\\n            while(upperHull.size()>=2 && cross(upperHull[Us-2] , upperHull[Us-1] , trees[i]) > 0){\\n                upperHull.pop_back();\\n                Us--; \\n            }\\n            upperHull.push_back(trees[i]);\\n        }\\n\\n        vector<vector<int>> lowerHull;\\n        lowerHull.push_back(trees[trees.size()-1]);\\n        lowerHull.push_back(trees[trees.size()-2]);\\n\\n        for(int i = trees.size()-3 ; i>=0 ; i--){\\n            int Ls = lowerHull.size();\\n            while(lowerHull.size()>=2 && cross(lowerHull[Ls-2] , lowerHull[Ls-1] , trees[i]) > 0){\\n                lowerHull.pop_back(); \\n                Ls--;\\n            }\\n            lowerHull.push_back(trees[i]);\\n        }\\n\\n        upperHull.insert(upperHull.end() , lowerHull.begin() , lowerHull.end());\\n        sort(upperHull.begin() , upperHull.end());\\n\\n        upperHull.erase(unique(upperHull.begin() , upperHull.end()) , upperHull.end());\\n        return upperHull;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cross(vector<int> A , vector<int> B , vector<int> C){\\n        // (x2-x1)(y3-y1) - (y2-y1)(x3-x1) -> 3D Cross-product of AB and AC vectors\\n        return ((B[0]-A[0])*(C[1]-A[1])) - ((C[0]-A[0])*(B[1]-A[1]));\\n    }\\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        if(trees.size() <= 3) return trees;\\n        sort(trees.begin() , trees.end());\\n\\n        vector<vector<int>> upperHull;\\n        upperHull.push_back(trees[0]);\\n        upperHull.push_back(trees[1]);\\n\\n        for(int i = 2 ; i<trees.size() ; i++){\\n            int Us = upperHull.size();\\n            while(upperHull.size()>=2 && cross(upperHull[Us-2] , upperHull[Us-1] , trees[i]) > 0){\\n                upperHull.pop_back();\\n                Us--; \\n            }\\n            upperHull.push_back(trees[i]);\\n        }\\n\\n        vector<vector<int>> lowerHull;\\n        lowerHull.push_back(trees[trees.size()-1]);\\n        lowerHull.push_back(trees[trees.size()-2]);\\n\\n        for(int i = trees.size()-3 ; i>=0 ; i--){\\n            int Ls = lowerHull.size();\\n            while(lowerHull.size()>=2 && cross(lowerHull[Ls-2] , lowerHull[Ls-1] , trees[i]) > 0){\\n                lowerHull.pop_back(); \\n                Ls--;\\n            }\\n            lowerHull.push_back(trees[i]);\\n        }\\n\\n        upperHull.insert(upperHull.end() , lowerHull.begin() , lowerHull.end());\\n        sort(upperHull.begin() , upperHull.end());\\n\\n        upperHull.erase(unique(upperHull.begin() , upperHull.end()) , upperHull.end());\\n        return upperHull;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830381,
                "title": "swift-jarvis-s-convex-hull",
                "content": "```\\nclass Solution {\\n    enum Orientation {\\n        case clockwise, counterclockwise, collinear\\n    }\\n    \\n    func outerTrees(_ trees: [[Int]]) -> [[Int]] {\\n        guard trees.count > 3 else {\\n            return trees\\n        }\\n        var result = Set<[Int]>()\\n        var l = 0\\n        \\n        // Find the leftmost point (if several exist, pick the one at the bottom)\\n        for i in 0..<trees.count {\\n            if trees[i][0] < trees[l][0] {\\n                l = i\\n            } else if trees[i][0] == trees[l][0], trees[i][1] < trees[l][1] {\\n                l = i\\n            }\\n        }\\n\\n        // Start from leftmost point, keep moving counterclockwise\\n        // until we reach the start point again.  This loop runs O(n)\\n        // times where n is number of trees in result\\n\\t\\t\\n\\t\\tvar p = l\\n\\n        repeat {\\n            var q = (p + 1) % trees.count\\n            // Search for a point \\'q\\' such that orientation(p, q, x) is counterclockwise for all points \\'x\\'.\\n            // The idea is to keep track of last visited most counterclockwise point in q. \\n\\t\\t\\t// If any point \\'i\\' is more counterclockwise than q, then update q.\\n            for i in 0..<trees.count {\\n                if orientation(p: trees[p], q: trees[i], r: trees[q]) == .counterclockwise {\\n                    // If i is more counterclockwise than current q, then update q\\n                    q = i\\n                }\\n            }\\n            \\n            // Check for points that are on the line between p and q\\n            // and located between those points\\n            for i in 0..<trees.count {\\n                if i != p && i != q \\n                && orientation(p: trees[p], q: trees[i], r: trees[q]) == .collinear\\n                && inbetween(p: trees[p], i: trees[i], q: trees[q]) {\\n                    result.insert(trees[i])\\n                }\\n            }\\n            \\n            // Now q is the most counterclockwise with respect to p\\n            // Set p as q for next iteration, so that q is added to result\\n            result.insert(trees[q])\\n            p = q\\n        } while (p != l) // Stop when we have returned to the first point\\n        \\n        return Array(result)\\n    }\\n    \\n    func orientation(p: [Int], q: [Int], r: [Int]) -> Orientation {\\n        let val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\\n        \\n        if val == 0 {\\n            return .collinear\\n        } else if val > 0 {\\n            return .clockwise\\n        } else {\\n            return .counterclockwise\\n        }\\n    }\\n    \\n    func inbetween(p: [Int], i: [Int], q: [Int]) -> Bool {\\n        let a = i[0] >= p[0] && i[0] <= q[0] || i[0] <= p[0] && i[0] >= q[0]\\n        let b = i[1] >= p[1] && i[1] <= q[1] || i[1] <= p[1] && i[1] >= q[1]\\n        return a && b\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    enum Orientation {\\n        case clockwise, counterclockwise, collinear\\n    }\\n    \\n    func outerTrees(_ trees: [[Int]]) -> [[Int]] {\\n        guard trees.count > 3 else {\\n            return trees\\n        }\\n        var result = Set<[Int]>()\\n        var l = 0\\n        \\n        // Find the leftmost point (if several exist, pick the one at the bottom)\\n        for i in 0..<trees.count {\\n            if trees[i][0] < trees[l][0] {\\n                l = i\\n            } else if trees[i][0] == trees[l][0], trees[i][1] < trees[l][1] {\\n                l = i\\n            }\\n        }\\n\\n        // Start from leftmost point, keep moving counterclockwise\\n        // until we reach the start point again.  This loop runs O(n)\\n        // times where n is number of trees in result\\n\\t\\t\\n\\t\\tvar p = l\\n\\n        repeat {\\n            var q = (p + 1) % trees.count\\n            // Search for a point \\'q\\' such that orientation(p, q, x) is counterclockwise for all points \\'x\\'.\\n            // The idea is to keep track of last visited most counterclockwise point in q. \\n\\t\\t\\t// If any point \\'i\\' is more counterclockwise than q, then update q.\\n            for i in 0..<trees.count {\\n                if orientation(p: trees[p], q: trees[i], r: trees[q]) == .counterclockwise {\\n                    // If i is more counterclockwise than current q, then update q\\n                    q = i\\n                }\\n            }\\n            \\n            // Check for points that are on the line between p and q\\n            // and located between those points\\n            for i in 0..<trees.count {\\n                if i != p && i != q \\n                && orientation(p: trees[p], q: trees[i], r: trees[q]) == .collinear\\n                && inbetween(p: trees[p], i: trees[i], q: trees[q]) {\\n                    result.insert(trees[i])\\n                }\\n            }\\n            \\n            // Now q is the most counterclockwise with respect to p\\n            // Set p as q for next iteration, so that q is added to result\\n            result.insert(trees[q])\\n            p = q\\n        } while (p != l) // Stop when we have returned to the first point\\n        \\n        return Array(result)\\n    }\\n    \\n    func orientation(p: [Int], q: [Int], r: [Int]) -> Orientation {\\n        let val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\\n        \\n        if val == 0 {\\n            return .collinear\\n        } else if val > 0 {\\n            return .clockwise\\n        } else {\\n            return .counterclockwise\\n        }\\n    }\\n    \\n    func inbetween(p: [Int], i: [Int], q: [Int]) -> Bool {\\n        let a = i[0] >= p[0] && i[0] <= q[0] || i[0] <= p[0] && i[0] >= q[0]\\n        let b = i[1] >= p[1] && i[1] <= q[1] || i[1] <= p[1] && i[1] >= q[1]\\n        return a && b\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830268,
                "title": "java-solution-sorting-and-then-separating-into-lower-and-upper-hull",
                "content": "\\nTime complexity should be O(nlogn) , space O(n)\\n```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n        if(trees.length <= 3)\\n            return trees;\\n        \\n        Arrays.sort(trees, (a,b)->{\\n            if(a[0]==b[0])\\n                return a[1] - b[1];\\n            else\\n                return a[0] - b[0];\\n        });\\n        \\n        List<int[]> lower = new ArrayList<>();\\n        List<int[]> upper = new ArrayList<>();\\n        \\n        for(int[] tree : trees){\\n            while(lower.size() >=2 && compare(lower.get(lower.size() - 2), lower.get(lower.size() - 1), tree) > 0){\\n                // int[] p1 = lower.get(lower.size()-2);\\n                // int[] p2 = lower.get(lower.size()-1);\\n                // int[] p3 = tree;\\n                //if antiClockwise then remove _/  i.e\\n                //if(compare(p1, p2, p3) > 0) then\\n                \\n                    lower.remove(lower.size()-1);\\n            }\\n            while(upper.size()>=2 && compare(upper.get(upper.size() - 2), upper.get(upper.size() - 1), tree) < 0){\\n                // int[] p1 = upper.get(lower.size()-2);\\n                // int[] p2 = upper.get(lower.size()-1);\\n                // int[] p3 = tree;\\n                //if clockwise then remove -\\\\ i.e\\n                //if(compare(p1, p2, p3) < 0) then\\n                    upper.remove(upper.size()-1);\\n                \\n            }\\n            \\n            lower.add(tree);\\n            upper.add(tree);\\n        }\\n        \\n        Set<int[]> set = new HashSet<>();\\n        for(int[] l : lower)\\n            set.add(l);\\n        \\n        for(int[] u : upper)\\n            set.add(u);\\n        \\n        int[][] result = new int[set.size()][2];\\n        \\n        int i = 0;\\n        for(int[] s: set)\\n            result[i++] = s;\\n        \\n        return result;\\n    }\\n    \\n    public int compare(int[] p1, int[] p2, int[] p3){\\n        int x1 = p1[0];\\n        int y1 = p1[1];\\n        int x2 = p2[0];\\n        int y2 = p2[1];\\n        int x3 = p3[0];\\n        int y3 = p3[1];\\n        \\n        /*\\n            p1    p2    p3\\n            .-->--.-->--.\\n        \\n        < 0: clockwise\\n        > 0: antiClockwise\\n        == 0: collinear   \\n        */\\n        \\n        return (y3 - y2) * (x2 - x1) - (y2 - y1) * (x3 - x2);\\n    }\\n}\\n```\\nREFERENCES\\nhttps://commons.wikimedia.org/wiki/File:Animation_depicting_the_Monotone_algorithm.gif\\nhttps://algorithmist.com/wiki/Monotone_chain_convex_hull\\nhttps://cp-algorithms.com/geometry/grahams-scan-convex-hull.html\\n\\nCreadits: [@chaudhary1337](https://leetcode.com/problems/erect-the-fence/discuss/1442266/A-Detailed-Explanation-with-Diagrams-(Graham-Scan))",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n        if(trees.length <= 3)\\n            return trees;\\n        \\n        Arrays.sort(trees, (a,b)->{\\n            if(a[0]==b[0])\\n                return a[1] - b[1];\\n            else\\n                return a[0] - b[0];\\n        });\\n        \\n        List<int[]> lower = new ArrayList<>();\\n        List<int[]> upper = new ArrayList<>();\\n        \\n        for(int[] tree : trees){\\n            while(lower.size() >=2 && compare(lower.get(lower.size() - 2), lower.get(lower.size() - 1), tree) > 0){\\n                // int[] p1 = lower.get(lower.size()-2);\\n                // int[] p2 = lower.get(lower.size()-1);\\n                // int[] p3 = tree;\\n                //if antiClockwise then remove _/  i.e\\n                //if(compare(p1, p2, p3) > 0) then\\n                \\n                    lower.remove(lower.size()-1);\\n            }\\n            while(upper.size()>=2 && compare(upper.get(upper.size() - 2), upper.get(upper.size() - 1), tree) < 0){\\n                // int[] p1 = upper.get(lower.size()-2);\\n                // int[] p2 = upper.get(lower.size()-1);\\n                // int[] p3 = tree;\\n                //if clockwise then remove -\\\\ i.e\\n                //if(compare(p1, p2, p3) < 0) then\\n                    upper.remove(upper.size()-1);\\n                \\n            }\\n            \\n            lower.add(tree);\\n            upper.add(tree);\\n        }\\n        \\n        Set<int[]> set = new HashSet<>();\\n        for(int[] l : lower)\\n            set.add(l);\\n        \\n        for(int[] u : upper)\\n            set.add(u);\\n        \\n        int[][] result = new int[set.size()][2];\\n        \\n        int i = 0;\\n        for(int[] s: set)\\n            result[i++] = s;\\n        \\n        return result;\\n    }\\n    \\n    public int compare(int[] p1, int[] p2, int[] p3){\\n        int x1 = p1[0];\\n        int y1 = p1[1];\\n        int x2 = p2[0];\\n        int y2 = p2[1];\\n        int x3 = p3[0];\\n        int y3 = p3[1];\\n        \\n        /*\\n            p1    p2    p3\\n            .-->--.-->--.\\n        \\n        < 0: clockwise\\n        > 0: antiClockwise\\n        == 0: collinear   \\n        */\\n        \\n        return (y3 - y2) * (x2 - x1) - (y2 - y1) * (x3 - x2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829850,
                "title": "java-jarvis-march-convex-hull-algorithm-easy-to-read",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/hard/geometry/ErectFence.java",
                "solutionTags": [
                    "Java",
                    "Geometry"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2829828,
                "title": "please-upvote",
                "content": "class Solution {\\n    private int orientation(int[] p,int[] q,int[] r){\\n        return (r[1]-q[1]) * (q[0]-p[0]) - ( (q[1]-p[1]) * (r[0]-q[0])); \\n    }\\n    public int[][] outerTrees(int[][] trees) {\\n        Stack<int[]> upper= new Stack<>();\\n        Stack<int[]> lower= new Stack<>();\\n        Arrays.sort(trees,(p,q) ->\\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0] );\\n        for(int i=0;i<trees.length;i++){\\n            while(lower.size()>= 2 && orientation(lower.get(lower.size()-2),lower.get(lower.size()-1),trees[i]) >0){\\n                lower.pop();\\n            }\\n            while(upper.size()>= 2 && orientation(upper.get(upper.size()-2),upper.get(upper.size()-1),trees[i])<0){\\n                upper.pop();\\n            }\\n            lower.push(trees[i]);\\n            upper.push(trees[i]);\\n            \\n        }\\n        Set<int[]> res= new HashSet<>(lower);\\n        res.addAll(upper);\\n        return res.toArray(new int[res.size()][]);\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private int orientation(int[] p,int[] q,int[] r){\\n        return (r[1]-q[1]) * (q[0]-p[0]) - ( (q[1]-p[1]) * (r[0]-q[0])); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2829462,
                "title": "c-jarvis-algorithm",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int isBMoreClockWiseThanCAndAIsCentre(const vector<int> &a, const vector<int> &b, const vector<int> &c) {\\n        return (b[1] - a[1]) * (c[0] - b[0]) - (b[0] - a[0]) * (c[1] - b[1]);\\n    }\\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        set<vector<int>> set;\\n        int leftMostIndex = 0;\\n        int n = trees.size();\\n        if (n < 4) return trees;\\n        for (int i = 0; i < n; ++i) {\\n            if (trees[i][0] < trees[leftMostIndex][0]) leftMostIndex = i;\\n        }\\n        //we start from the leftMostIndex\\n        //and then try to pick the next\\n        //point from the available points\\n        //which is more clockwise from the current point\\n        //and we stop when we come to the same point\\n        int cur_point = leftMostIndex;\\n        while (1) {\\n            int candidate = (cur_point + 1) % n;\\n            //try to pick the next point which is more clockwise\\n            //to the current point\\n            for (int i = 0; i < n; ++i) {\\n                if (isBMoreClockWiseThanCAndAIsCentre(trees[cur_point], trees[candidate], trees[i]) > 0) candidate = i;\\n            }\\n            //pick all the points from the space\\n            //which are co-linear with the candidate\\n            for (int i = 0; i < n; ++i) {\\n                if (isBMoreClockWiseThanCAndAIsCentre(trees[cur_point], trees[candidate], trees[i]) == 0) {\\n                    set.insert(trees[i]);\\n                }\\n            }\\n            cur_point = candidate;\\n            if (cur_point == leftMostIndex || set.size() == n) break;\\n        }\\n        \\n        vector<vector<int>> result;\\n        for (const auto &node: set) {\\n            result.emplace_back(node);\\n        }\\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int isBMoreClockWiseThanCAndAIsCentre(const vector<int> &a, const vector<int> &b, const vector<int> &c) {\\n        return (b[1] - a[1]) * (c[0] - b[0]) - (b[0] - a[0]) * (c[1] - b[1]);\\n    }\\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        set<vector<int>> set;\\n        int leftMostIndex = 0;\\n        int n = trees.size();\\n        if (n < 4) return trees;\\n        for (int i = 0; i < n; ++i) {\\n            if (trees[i][0] < trees[leftMostIndex][0]) leftMostIndex = i;\\n        }\\n        //we start from the leftMostIndex\\n        //and then try to pick the next\\n        //point from the available points\\n        //which is more clockwise from the current point\\n        //and we stop when we come to the same point\\n        int cur_point = leftMostIndex;\\n        while (1) {\\n            int candidate = (cur_point + 1) % n;\\n            //try to pick the next point which is more clockwise\\n            //to the current point\\n            for (int i = 0; i < n; ++i) {\\n                if (isBMoreClockWiseThanCAndAIsCentre(trees[cur_point], trees[candidate], trees[i]) > 0) candidate = i;\\n            }\\n            //pick all the points from the space\\n            //which are co-linear with the candidate\\n            for (int i = 0; i < n; ++i) {\\n                if (isBMoreClockWiseThanCAndAIsCentre(trees[cur_point], trees[candidate], trees[i]) == 0) {\\n                    set.insert(trees[i]);\\n                }\\n            }\\n            cur_point = candidate;\\n            if (cur_point == leftMostIndex || set.size() == n) break;\\n        }\\n        \\n        vector<vector<int>> result;\\n        for (const auto &node: set) {\\n            result.emplace_back(node);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829374,
                "title": "java-this-question-sucks",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    private class Point{\\n        int x;\\n        int y;\\n        \\n        Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n\\n    public int[][] outerTrees(int[][] trees) {\\n        List<Point> points = new ArrayList<>();\\n\\n        for (int[] point : trees) {\\n            points.add(new Point(point[0], point[1]));\\n        }\\n\\n        List<Point> res = new ArrayList<>();\\n        if (points.size() == 1) return trees;\\n\\n        int n = points.size();\\n\\n        Collections.sort(points,(a,b) -> a.y == b.y ? a.x - b.x : a.y - b.y);\\n\\n        Set<List<Integer>> dup = new HashSet<>();\\n        Stack<Point> hull = new Stack<>();\\n\\n        hull.push(points.get(0));\\n        hull.push(points.get(1));\\n\\n        // Lower hull\\n        for (int i = 2; i < n; i++) {\\n            Point top = hull.pop();\\n\\n            while (!hull.isEmpty() && ccw(hull.peek(), top, points.get(i)) < 0) {\\n                top = hull.pop();\\n            }\\n\\n            hull.push(top);\\n            hull.push(points.get(i));\\n        }\\n\\n        // Upper  hull\\n        for (int i = n - 2; i >= 0; i--) {\\n            Point top = hull.pop();\\n\\n            while (!hull.isEmpty() && ccw(hull.peek(), top, points.get(i)) < 0) {\\n                top = hull.pop();\\n            }\\n\\n            hull.push(top);\\n            hull.push(points.get(i));\\n        }\\n\\n        for (Point p : hull) {\\n            List<Integer> tmp = new ArrayList<>();\\n            tmp.add(p.x);\\n            tmp.add(p.y);\\n\\n            if(dup.contains(tmp)) continue;\\n\\n            dup.add(tmp);\\n            res.add(p);\\n        }\\n\\n        int[][] ans = new int[res.size()][2];\\n        int i = 0;\\n\\n        for (Point p: res) {\\n            ans[i][0] = p.x;\\n            ans[i][1] = p.y;\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int ccw(Point a, Point b, Point c) {\\n        double crossProduct = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\\n        if (crossProduct < 0) return -1;\\n        if (crossProduct > 0) return +1;\\n        return 0;     // linear in natural\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private class Point{\\n        int x;\\n        int y;\\n        \\n        Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n\\n    public int[][] outerTrees(int[][] trees) {\\n        List<Point> points = new ArrayList<>();\\n\\n        for (int[] point : trees) {\\n            points.add(new Point(point[0], point[1]));\\n        }\\n\\n        List<Point> res = new ArrayList<>();\\n        if (points.size() == 1) return trees;\\n\\n        int n = points.size();\\n\\n        Collections.sort(points,(a,b) -> a.y == b.y ? a.x - b.x : a.y - b.y);\\n\\n        Set<List<Integer>> dup = new HashSet<>();\\n        Stack<Point> hull = new Stack<>();\\n\\n        hull.push(points.get(0));\\n        hull.push(points.get(1));\\n\\n        // Lower hull\\n        for (int i = 2; i < n; i++) {\\n            Point top = hull.pop();\\n\\n            while (!hull.isEmpty() && ccw(hull.peek(), top, points.get(i)) < 0) {\\n                top = hull.pop();\\n            }\\n\\n            hull.push(top);\\n            hull.push(points.get(i));\\n        }\\n\\n        // Upper  hull\\n        for (int i = n - 2; i >= 0; i--) {\\n            Point top = hull.pop();\\n\\n            while (!hull.isEmpty() && ccw(hull.peek(), top, points.get(i)) < 0) {\\n                top = hull.pop();\\n            }\\n\\n            hull.push(top);\\n            hull.push(points.get(i));\\n        }\\n\\n        for (Point p : hull) {\\n            List<Integer> tmp = new ArrayList<>();\\n            tmp.add(p.x);\\n            tmp.add(p.y);\\n\\n            if(dup.contains(tmp)) continue;\\n\\n            dup.add(tmp);\\n            res.add(p);\\n        }\\n\\n        int[][] ans = new int[res.size()][2];\\n        int i = 0;\\n\\n        for (Point p: res) {\\n            ans[i][0] = p.x;\\n            ans[i][1] = p.y;\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int ccw(Point a, Point b, Point c) {\\n        double crossProduct = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\\n        if (crossProduct < 0) return -1;\\n        if (crossProduct > 0) return +1;\\n        return 0;     // linear in natural\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829174,
                "title": "c-faster-than-100-00",
                "content": "> Runtime: 221 ms, faster than 100.00% of C# online submissions for Erect the Fence.\\nMemory Usage: 52.8 MB, less than 50.00% of C# online submissions for Erect the Fence.\\n```\\npublic class Solution {\\n    public int[][] OuterTrees(int[][] trees) {\\n        Array.Sort(trees, (p, q) => q[0] - p[0] == 0 ? q[1] - p[1] : q[0] - p[0]);\\n        \\n        int n = trees.Length;\\n        Stack<int[]> hull = new();\\n        for(int i = 0; i < n; i++)\\n        {\\n            while(hull.Count >= 2 && Orientation(hull.ElementAt(1), hull.Peek(), trees[i]) > 0)\\n                hull.Pop();\\n            hull.Push(trees[i]);\\n        }\\n        hull.Pop();\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            while(hull.Count >= 2 && Orientation(hull.ElementAt(1), hull.Peek(), trees[i]) > 0)\\n                hull.Pop();\\n            hull.Push(trees[i]);\\n        }\\n        \\n        HashSet<int[]> set = new(hull);\\n        return set.ToArray();\\n        \\n    }\\n    \\n    private int Orientation(int[] p, int[] q, int[] r)\\n        => (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] OuterTrees(int[][] trees) {\\n        Array.Sort(trees, (p, q) => q[0] - p[0] == 0 ? q[1] - p[1] : q[0] - p[0]);\\n        \\n        int n = trees.Length;\\n        Stack<int[]> hull = new();\\n        for(int i = 0; i < n; i++)\\n        {\\n            while(hull.Count >= 2 && Orientation(hull.ElementAt(1), hull.Peek(), trees[i]) > 0)\\n                hull.Pop();\\n            hull.Push(trees[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2828886,
                "title": "convex-hull-fundamental-approach-gramscan-algorithm",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int clockwise(vector<int>& p1, vector<int>& p2, vector<int>& p3) {\\n        int x1, y1, x2, y2, x3, y3;\\n        x1 = p1[0];\\n        y1 = p1[1];\\n        x2 = p2[0];\\n        y2 = p2[1];\\n        x3 = p3[0];\\n        y3 = p3[1];\\n        return ((y3-y2)*(x2-x1) - (y2-y1)*(x3-x2));\\n    }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        sort(trees.begin(), trees.end());\\n        vector<vector<int>> upper;\\n        vector<vector<int>> lower;\\n        for(auto tree:trees) {\\n            while(upper.size() > 1 and clockwise(upper[upper.size()-1], upper[upper.size()-2], tree) > 0) {\\n                upper.pop_back();\\n            }\\n            while(lower.size() > 1 and clockwise(lower[lower.size()-1], lower[lower.size()-2], tree) < 0) {\\n                lower.pop_back();\\n            }\\n            upper.push_back(tree);\\n            lower.push_back(tree);\\n        }\\n        vector<vector<int>> output;\\n        merge(upper.begin(), upper.end(), lower.begin(), lower.end(), back_inserter(output));\\n        auto pts = unique(output.begin(), output.end());\\n        output.erase(pts, output.end());\\n        return output;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int clockwise(vector<int>& p1, vector<int>& p2, vector<int>& p3) {\\n        int x1, y1, x2, y2, x3, y3;\\n        x1 = p1[0];\\n        y1 = p1[1];\\n        x2 = p2[0];\\n        y2 = p2[1];\\n        x3 = p3[0];\\n        y3 = p3[1];\\n        return ((y3-y2)*(x2-x1) - (y2-y1)*(x3-x2));\\n    }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        sort(trees.begin(), trees.end());\\n        vector<vector<int>> upper;\\n        vector<vector<int>> lower;\\n        for(auto tree:trees) {\\n            while(upper.size() > 1 and clockwise(upper[upper.size()-1], upper[upper.size()-2], tree) > 0) {\\n                upper.pop_back();\\n            }\\n            while(lower.size() > 1 and clockwise(lower[lower.size()-1], lower[lower.size()-2], tree) < 0) {\\n                lower.pop_back();\\n            }\\n            upper.push_back(tree);\\n            lower.push_back(tree);\\n        }\\n        vector<vector<int>> output;\\n        merge(upper.begin(), upper.end(), lower.begin(), lower.end(), back_inserter(output));\\n        auto pts = unique(output.begin(), output.end());\\n        output.erase(pts, output.end());\\n        return output;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828836,
                "title": "golang-jarvis-algorithm-o-n-2",
                "content": "```\\ntype Tree struct {\\n    r, c int\\n}\\n\\nfunc outerTrees(trees [][]int) [][]int {\\n    hull := make(map[Tree]struct{})\\n    n := len(trees)\\n    \\n    if n < 4 {\\n        return trees\\n    }\\n    \\n    leftMost := 0\\n    for i, tree := range trees {\\n        if tree[0] < trees[leftMost][0] {\\n            leftMost = i\\n        }\\n    }\\n    \\n    p := leftMost\\n    for {\\n        q := (p + 1) % n\\n        for i, _ := range trees {\\n            if orientation(trees[p], trees[i], trees[q]) < 0 {\\n                q = i\\n            }\\n        }\\n        \\n        for i, _ := range trees {\\n            if (i != q && i != p && orientation(trees[p], trees[i], trees[q]) == 0 && inBetween(trees[p], trees[i], trees[q])) {\\n                hull[Tree{trees[i][0], trees[i][1]}] = struct{}{}\\n            }\\n        }\\n        \\n        hull[Tree{trees[q][0], trees[q][1]}] = struct{}{}\\n        p = q\\n        \\n        if _, ok := hull[Tree{trees[leftMost][0], trees[leftMost][1]}]; ok{\\n            break    \\n        }\\n    }\\n    \\n    output := make([][]int, 0)\\n    for k, _ := range hull {\\n        output = append(output, []int{k.r, k.c})\\n    }\\n    return output\\n}\\n\\nfunc orientation(p []int, q []int, r []int) int {\\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\\n}\\n\\nfunc inBetween(p []int, i []int, q []int) bool {\\n    a := (i[0] >= p[0] && i[0] <= q[0]) || (i[0] <= p[0] && i[0] >= q[0])\\n    b := (i[1] >= p[1] && i[1] <= q[1]) || (i[1] <= p[1] && i[1] >= q[1])\\n    return a && b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Tree struct {\\n    r, c int\\n}\\n\\nfunc outerTrees(trees [][]int) [][]int {\\n    hull := make(map[Tree]struct{})\\n    n := len(trees)\\n    \\n    if n < 4 {\\n        return trees\\n    }\\n    \\n    leftMost := 0\\n    for i, tree := range trees {\\n        if tree[0] < trees[leftMost][0] {\\n            leftMost = i\\n        }\\n    }\\n    \\n    p := leftMost\\n    for {\\n        q := (p + 1) % n\\n        for i, _ := range trees {\\n            if orientation(trees[p], trees[i], trees[q]) < 0 {\\n                q = i\\n            }\\n        }\\n        \\n        for i, _ := range trees {\\n            if (i != q && i != p && orientation(trees[p], trees[i], trees[q]) == 0 && inBetween(trees[p], trees[i], trees[q])) {\\n                hull[Tree{trees[i][0], trees[i][1]}] = struct{}{}\\n            }\\n        }\\n        \\n        hull[Tree{trees[q][0], trees[q][1]}] = struct{}{}\\n        p = q\\n        \\n        if _, ok := hull[Tree{trees[leftMost][0], trees[leftMost][1]}]; ok{\\n            break    \\n        }\\n    }\\n    \\n    output := make([][]int, 0)\\n    for k, _ := range hull {\\n        output = append(output, []int{k.r, k.c})\\n    }\\n    return output\\n}\\n\\nfunc orientation(p []int, q []int, r []int) int {\\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\\n}\\n\\nfunc inBetween(p []int, i []int, q []int) bool {\\n    a := (i[0] >= p[0] && i[0] <= q[0]) || (i[0] <= p[0] && i[0] >= q[0])\\n    b := (i[1] >= p[1] && i[1] <= q[1]) || (i[1] <= p[1] && i[1] >= q[1])\\n    return a && b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2828749,
                "title": "python3-easy-solution-convex-hull-graham-s-scan-algorithm",
                "content": "\\n```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        def clockwise(p1,p2,p3):\\n            x1,y1=p1\\n            x2,y2=p2\\n            x3,y3=p3\\n            \\n            return ((y3-y2)*(x2-x1)-(y2-y1)*(x3-x2))\\n        trees.sort()\\n        upper=[]\\n        lower=[]\\n        for t in trees:\\n            while len(upper)>1 and clockwise(upper[-2],upper[-1],t)>0:\\n                upper.pop()\\n            while len(lower)>1 and clockwise(lower[-2],lower[-1],t)<0:\\n                lower.pop()\\n            upper.append(tuple(t))\\n            lower.append(tuple(t))\\n            \\n        return list(set(upper+lower))      \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        def clockwise(p1,p2,p3):\\n            x1,y1=p1\\n            x2,y2=p2\\n            x3,y3=p3\\n            \\n            return ((y3-y2)*(x2-x1)-(y2-y1)*(x3-x2))\\n        trees.sort()\\n        upper=[]\\n        lower=[]\\n        for t in trees:\\n            while len(upper)>1 and clockwise(upper[-2],upper[-1],t)>0:\\n                upper.pop()\\n            while len(lower)>1 and clockwise(lower[-2],lower[-1],t)<0:\\n                lower.pop()\\n            upper.append(tuple(t))\\n            lower.append(tuple(t))\\n            \\n        return list(set(upper+lower))      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753154,
                "title": "python-solution",
                "content": "\\n\\tclass Solution:\\n\\t\\tdef outerTrees(self, points):\\n\\t\\t\\tdef cross(p1, p2, p3):\\n\\t\\t\\t\\treturn (p2[0]-p1[0])*(p3[1]-p1[1])-(p2[1]-p1[1])*(p3[0]-p1[0])\\n\\n\\t\\t\\tstart = min(points)\\n\\t\\t\\tpoints.pop(points.index(start))\\n\\t\\t\\tpoints.sort(key=lambda p: (atan2(p[1]-start[1], p[0]-start[0]), -p[1], p[0]))\\n\\n\\t\\t\\tlast = len(points) - 1\\n\\t\\t\\twhile last > 0 and cross(start, points[-1], points[last - 1]) == 0:\\n\\t\\t\\t\\tlast -= 1\\n\\n\\t\\t\\tpoints[last:] = sorted(points[last:], key = lambda p: (-p[0]))\\n\\n\\t\\t\\tans = [start]\\n\\t\\t\\tfor p in points:\\n\\t\\t\\t\\tans.append(p)\\n\\t\\t\\t\\twhile len(ans) > 2 and cross(*ans[-3:]) < 0:\\n\\t\\t\\t\\t\\tans.pop(-2)\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "\\n\\tclass Solution:\\n\\t\\tdef outerTrees(self, points):\\n\\t\\t\\tdef cross(p1, p2, p3):\\n\\t\\t\\t\\treturn (p2[0]-p1[0])*(p3[1]-p1[1])-(p2[1]-p1[1])*(p3[0]-p1[0])\\n\\n\\t\\t\\tstart = min(points)\\n\\t\\t\\tpoints.pop(points.index(start))\\n\\t\\t\\tpoints.sort(key=lambda p: (atan2(p[1]-start[1], p[0]-start[0]), -p[1], p[0]))\\n\\n\\t\\t\\tlast = len(points) - 1\\n\\t\\t\\twhile last > 0 and cross(start, points[-1], points[last - 1]) == 0:\\n\\t\\t\\t\\tlast -= 1\\n\\n\\t\\t\\tpoints[last:] = sorted(points[last:], key = lambda p: (-p[0]))\\n\\n\\t\\t\\tans = [start]\\n\\t\\t\\tfor p in points:\\n\\t\\t\\t\\tans.append(p)\\n\\t\\t\\t\\twhile len(ans) > 2 and cross(*ans[-3:]) < 0:\\n\\t\\t\\t\\t\\tans.pop(-2)\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 2643210,
                "title": "rust",
                "content": "331 ms & 2.3M\\n\\n```rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn minus(a: &Vec<i32>, b: &Vec<i32>) -> Vec<i32> { vec![a[0] - b[0], a[1] - b[1]] }\\n    pub fn dot(a: &Vec<i32>, b: &Vec<i32>) -> i32 { a[0] * b[0] + a[1] * b[1] }\\n    pub fn distance(a: &Vec<i32>) -> f64 { (Solution::dot(a, a) as f64).sqrt() }\\n    pub fn angle(a: &Vec<i32>, pivot: &Vec<i32>, b: &Vec<i32>) -> f64 {\\n        let bo = Solution::minus(&b, &pivot);\\n        let ao = Solution::minus(&a, &pivot);\\n        Solution::dot(&bo, &ao) as f64 / Solution::distance(&ao) / Solution::distance(&bo)\\n    }\\n    pub fn outer_trees(trees: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut trees = trees.clone();\\n        if trees.len() <= 3 { return trees }\\n        let mut ret = Vec::new();\\n        let (mut left_idx, mut left_value, mut y_value ) = (0, 101, 101);\\n        for (i, tree) in trees.iter().enumerate() {\\n            if tree[0] < left_value || (tree[0] == left_value && tree[1] < y_value) {\\n                left_idx = i; left_value = tree[0]; y_value = tree[1];\\n            }\\n        }\\n\\n        let mut pivot = &trees[left_idx].clone();\\n        let mut pivot_idx = left_idx;\\n        ret.push(pivot.clone());\\n\\n        let mut reference = &vec![pivot[0], pivot[1]+101];\\n        let mut ref_idx: usize = 99999;\\n\\n        let mut seen = HashSet::new();\\n        // seen.insert(left_idx);\\n\\n        loop {\\n            let (mut next_idx, mut m_angle, mut m_dis) = (0 as usize, 10.0f64, 1000f64);\\n            for (i, tree) in trees.iter().enumerate() {\\n                if i == pivot_idx || i == ref_idx || seen.contains(&i) { continue; }\\n                let cur_angle = Solution::angle(reference, pivot, tree);\\n                let cur_dis = Solution::distance(&Solution::minus(tree, pivot));\\n                // println!(\"{tree:?} -- {cur_angle} {cur_dis}\");\\n                if cur_angle+0.00001 < m_angle || (cur_angle < m_angle+0.00001 && cur_dis < m_dis) {\\n                    // println!(\"Select {i}\");\\n                    m_angle = cur_angle;\\n                    m_dis = cur_dis;\\n                    next_idx = i;\\n                }\\n            }\\n            if next_idx == left_idx { break; }\\n            seen.insert(next_idx);\\n            reference = pivot;\\n            ref_idx = pivot_idx;\\n            pivot = &trees[next_idx];\\n            pivot_idx = next_idx;\\n            // println!(\"Do {:?}\", trees[next_idx]);\\n            ret.push(trees[next_idx].clone());\\n        }\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn minus(a: &Vec<i32>, b: &Vec<i32>) -> Vec<i32> { vec![a[0] - b[0], a[1] - b[1]] }\\n    pub fn dot(a: &Vec<i32>, b: &Vec<i32>) -> i32 { a[0] * b[0] + a[1] * b[1] }\\n    pub fn distance(a: &Vec<i32>) -> f64 { (Solution::dot(a, a) as f64).sqrt() }\\n    pub fn angle(a: &Vec<i32>, pivot: &Vec<i32>, b: &Vec<i32>) -> f64 {\\n        let bo = Solution::minus(&b, &pivot);\\n        let ao = Solution::minus(&a, &pivot);\\n        Solution::dot(&bo, &ao) as f64 / Solution::distance(&ao) / Solution::distance(&bo)\\n    }\\n    pub fn outer_trees(trees: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut trees = trees.clone();\\n        if trees.len() <= 3 { return trees }\\n        let mut ret = Vec::new();\\n        let (mut left_idx, mut left_value, mut y_value ) = (0, 101, 101);\\n        for (i, tree) in trees.iter().enumerate() {\\n            if tree[0] < left_value || (tree[0] == left_value && tree[1] < y_value) {\\n                left_idx = i; left_value = tree[0]; y_value = tree[1];\\n            }\\n        }\\n\\n        let mut pivot = &trees[left_idx].clone();\\n        let mut pivot_idx = left_idx;\\n        ret.push(pivot.clone());\\n\\n        let mut reference = &vec![pivot[0], pivot[1]+101];\\n        let mut ref_idx: usize = 99999;\\n\\n        let mut seen = HashSet::new();\\n        // seen.insert(left_idx);\\n\\n        loop {\\n            let (mut next_idx, mut m_angle, mut m_dis) = (0 as usize, 10.0f64, 1000f64);\\n            for (i, tree) in trees.iter().enumerate() {\\n                if i == pivot_idx || i == ref_idx || seen.contains(&i) { continue; }\\n                let cur_angle = Solution::angle(reference, pivot, tree);\\n                let cur_dis = Solution::distance(&Solution::minus(tree, pivot));\\n                // println!(\"{tree:?} -- {cur_angle} {cur_dis}\");\\n                if cur_angle+0.00001 < m_angle || (cur_angle < m_angle+0.00001 && cur_dis < m_dis) {\\n                    // println!(\"Select {i}\");\\n                    m_angle = cur_angle;\\n                    m_dis = cur_dis;\\n                    next_idx = i;\\n                }\\n            }\\n            if next_idx == left_idx { break; }\\n            seen.insert(next_idx);\\n            reference = pivot;\\n            ref_idx = pivot_idx;\\n            pivot = &trees[next_idx];\\n            pivot_idx = next_idx;\\n            // println!(\"Do {:?}\", trees[next_idx]);\\n            ret.push(trees[next_idx].clone());\\n        }\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555357,
                "title": "kotlin-100",
                "content": "```\\n// distance between trees\\nfun dist(p1: Pair<Int, Int>, p2: Pair<Int, Int>): Double {\\n    return Math.sqrt(Math.pow((p2.second-p1.second).toDouble(),2.0)+ Math.pow((p2.first-p1.first).toDouble(), 2.0))\\n}\\n\\n// angle to tree from tree (horizontally right = 0.0)\\nfun angle(p1: Pair<Int, Int>, p2: Pair<Int, Int>): Double {\\n    return Math.atan2((p2.second-p1.second).toDouble(), (p2.first-p1.first).toDouble()).let {\\n        if(it < 0) return (2.0 * Math.PI + it) else it\\n    }\\n}\\n\\nfun outerTrees(trees: Array<IntArray>): Array<IntArray> {\\n    if(trees.size < 3) return trees\\n\\n    val left = trees.asSequence().map { it[0] to it[1] }.toMutableList()\\n\\n    // finding bottom (and if several - bottom left) tree\\n    left.sortWith(compareBy<Pair<Int, Int>> { it.second }.thenBy { it.first })\\n    val firstPoint = left[0]\\n    var nowPoint = firstPoint\\n    val pointList = mutableListOf(nowPoint)\\n    var prevAngle = 0.0\\n    \\n    while(true) {\\n        \\n        var nowList = mutableListOf<Pair<Pair<Int,Int>, Double>>()\\n        var nowMinAngleDiff = 7.0 // first after PI * 2 = 6.28....\\n        var nowMinAngle = 7.0\\n\\n        // finding point (or list if there\\'s several on line at the MIN angle)\\n        left.forEach {\\n            if(it != nowPoint) {\\n                val angle = angle(nowPoint, it)\\n\\n                if(Math.abs(angle - nowMinAngle) < 0.0000001) { // prevent == on double\\n                    nowList.add(it to dist(it, nowPoint))\\n                } else {\\n                    val diff = if(angle >= prevAngle) (angle - prevAngle) else 2.0 * Math.PI - (angle - prevAngle)\\n                    if ((diff) < nowMinAngleDiff) {\\n                        nowMinAngle = angle\\n                        nowMinAngleDiff = (diff)\\n\\n                        // found angle smaller to find next \\'ANCHOR\\' point , clearing list and fill with it\\n                        nowList.clear()\\n                        nowList.add(it to dist(it, nowPoint))\\n                    }\\n                }\\n            }\\n        }\\n        prevAngle = nowMinAngle\\n        \\n        // sorting by distance from current point\\n        nowList.sortBy { it.second }\\n        val nowListOnlyPoints = nowList.map { it.first }.toMutableList()\\n\\n        if(nowListOnlyPoints.last() == firstPoint) {\\n            nowListOnlyPoints.removeAt(nowListOnlyPoints.size - 1)\\n            left.removeAll(nowListOnlyPoints)\\n            pointList.addAll(nowListOnlyPoints)\\n\\n            // next point = first => job is done\\n            break\\n        } else {\\n            nowPoint = nowListOnlyPoints.last()\\n\\n            left.removeAll(nowListOnlyPoints)\\n            pointList.addAll(nowListOnlyPoints)\\n        }\\n    }\\n    return pointList.asSequence().map { intArrayOf(it.first, it.second) }.toList().toTypedArray()\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n// distance between trees\\nfun dist(p1: Pair<Int, Int>, p2: Pair<Int, Int>): Double {\\n    return Math.sqrt(Math.pow((p2.second-p1.second).toDouble(),2.0)+ Math.pow((p2.first-p1.first).toDouble(), 2.0))\\n}\\n\\n// angle to tree from tree (horizontally right = 0.0)\\nfun angle(p1: Pair<Int, Int>, p2: Pair<Int, Int>): Double {\\n    return Math.atan2((p2.second-p1.second).toDouble(), (p2.first-p1.first).toDouble()).let {\\n        if(it < 0) return (2.0 * Math.PI + it) else it\\n    }\\n}\\n\\nfun outerTrees(trees: Array<IntArray>): Array<IntArray> {\\n    if(trees.size < 3) return trees\\n\\n    val left = trees.asSequence().map { it[0] to it[1] }.toMutableList()\\n\\n    // finding bottom (and if several - bottom left) tree\\n    left.sortWith(compareBy<Pair<Int, Int>> { it.second }.thenBy { it.first })\\n    val firstPoint = left[0]\\n    var nowPoint = firstPoint\\n    val pointList = mutableListOf(nowPoint)\\n    var prevAngle = 0.0\\n    \\n    while(true) {\\n        \\n        var nowList = mutableListOf<Pair<Pair<Int,Int>, Double>>()\\n        var nowMinAngleDiff = 7.0 // first after PI * 2 = 6.28....\\n        var nowMinAngle = 7.0\\n\\n        // finding point (or list if there\\'s several on line at the MIN angle)\\n        left.forEach {\\n            if(it != nowPoint) {\\n                val angle = angle(nowPoint, it)\\n\\n                if(Math.abs(angle - nowMinAngle) < 0.0000001) { // prevent == on double\\n                    nowList.add(it to dist(it, nowPoint))\\n                } else {\\n                    val diff = if(angle >= prevAngle) (angle - prevAngle) else 2.0 * Math.PI - (angle - prevAngle)\\n                    if ((diff) < nowMinAngleDiff) {\\n                        nowMinAngle = angle\\n                        nowMinAngleDiff = (diff)\\n\\n                        // found angle smaller to find next \\'ANCHOR\\' point , clearing list and fill with it\\n                        nowList.clear()\\n                        nowList.add(it to dist(it, nowPoint))\\n                    }\\n                }\\n            }\\n        }\\n        prevAngle = nowMinAngle\\n        \\n        // sorting by distance from current point\\n        nowList.sortBy { it.second }\\n        val nowListOnlyPoints = nowList.map { it.first }.toMutableList()\\n\\n        if(nowListOnlyPoints.last() == firstPoint) {\\n            nowListOnlyPoints.removeAt(nowListOnlyPoints.size - 1)\\n            left.removeAll(nowListOnlyPoints)\\n            pointList.addAll(nowListOnlyPoints)\\n\\n            // next point = first => job is done\\n            break\\n        } else {\\n            nowPoint = nowListOnlyPoints.last()\\n\\n            left.removeAll(nowListOnlyPoints)\\n            pointList.addAll(nowListOnlyPoints)\\n        }\\n    }\\n    return pointList.asSequence().map { intArrayOf(it.first, it.second) }.toList().toTypedArray()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2164009,
                "title": "python3-graham-scan-complex-plane-o-nlg-n-time-o-n-space",
                "content": "Tie break the sort relative to the centroid (start not included) so that points colinear to the start are ordered for correctly. \\n```\\nfrom cmath import phase\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> Tuple[Tuple[int]]:\\n        start = complex( *min( trees, key=lambda xy: ( xy[1], xy[0] ) ) )\\n        trees = [ c for c in itertools.starmap( complex, trees ) if c != start ]\\n        centroid = sum( trees )/max( len( trees ), 1 )\\n        trees.sort( key=lambda c: ( phase( c-start ),phase( ( c-centroid )/( centroid-start ) ) ) )\\n        \\n        stack = [start]\\n        for tree in trees:\\n            while len(stack) > 1 and crossProd( stack[-2], stack[-1], tree ) < 0:\\n                stack.pop()\\n            stack.append( tree )\\n        return tuple( map( lambda c: ( int(c.real), int(c.imag) ),stack ) )\\n    \\ndef crossProd( a: complex, b: complex, c: complex ) -> int:\\n    d, e = a-b, a-c\\n    return e.imag * d.real - d.imag * e.real\\n```",
                "solutionTags": [],
                "code": "```\\nfrom cmath import phase\\nclass Solution:\\n    def outerTrees(self, trees: List[List[int]]) -> Tuple[Tuple[int]]:\\n        start = complex( *min( trees, key=lambda xy: ( xy[1], xy[0] ) ) )\\n        trees = [ c for c in itertools.starmap( complex, trees ) if c != start ]\\n        centroid = sum( trees )/max( len( trees ), 1 )\\n        trees.sort( key=lambda c: ( phase( c-start ),phase( ( c-centroid )/( centroid-start ) ) ) )\\n        \\n        stack = [start]\\n        for tree in trees:\\n            while len(stack) > 1 and crossProd( stack[-2], stack[-1], tree ) < 0:\\n                stack.pop()\\n            stack.append( tree )\\n        return tuple( map( lambda c: ( int(c.real), int(c.imag) ),stack ) )\\n    \\ndef crossProd( a: complex, b: complex, c: complex ) -> int:\\n    d, e = a-b, a-c\\n    return e.imag * d.real - d.imag * e.real\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976631,
                "title": "graham-scan-different-implementation-c",
                "content": "```c++\\nclass Solution {\\n public:\\n  vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n    if (trees.size() <= 1) return trees;\\n\\n    int origin = 0;\\n    for (int i = 0; i < trees.size(); ++i) {\\n      if (trees[origin][1] > trees[i][1] || trees[origin][1] == trees[i][1] && trees[origin][0] > trees[i][0]) {\\n        origin = i;\\n      }\\n    }\\n    swap(trees[0], trees[origin]);\\n    sort(trees.begin() + 1, trees.end(), [&](const vector<int>& lhs, const vector<int>& rhs) -> bool {\\n      int result = cross(trees[0], lhs, rhs);\\n      if (result != 0) return result > 0;\\n      return norm(trees[0], lhs) < norm(trees[0], rhs);\\n    });\\n\\n    // deal with cases that the last k points are on one line\\n    int pos = trees.size() - 2;\\n    while (pos > 0 && cross(trees[0], trees.back(), trees[pos]) == 0) {\\n      --pos;\\n    }\\n    reverse(trees.begin() + pos + 1, trees.end());\\n\\n    vector<vector<int>> ans = {trees[0], trees[1]};\\n    for (int i = 2; i < trees.size(); ++i) {\\n      int cross_result = cross(ans[ans.size() - 2], ans[ans.size() - 1], trees[i]);\\n      while (cross_result < 0) {\\n        ans.pop_back();\\n        cross_result = cross(ans[ans.size() - 2], ans[ans.size() - 1], trees[i]);\\n      }\\n      ans.push_back(trees[i]);\\n    }\\n    return ans;\\n  }\\n\\n private:\\n  inline double norm(const vector<int>& o, const vector<int>& x) {\\n    int xx = x[0] - o[0];\\n    int yy = x[1] - o[1];\\n    return sqrt(xx * xx + yy * yy);\\n  }\\n\\n  inline int cross(const vector<int>& x, const vector<int>& y, const vector<int>& z) {\\n    return (y[0] - x[0]) * (z[1] - y[1]) - (y[1] - x[1]) * (z[0] - y[0]);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\n public:\\n  vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n    if (trees.size() <= 1) return trees;\\n\\n    int origin = 0;\\n    for (int i = 0; i < trees.size(); ++i) {\\n      if (trees[origin][1] > trees[i][1] || trees[origin][1] == trees[i][1] && trees[origin][0] > trees[i][0]) {\\n        origin = i;\\n      }\\n    }\\n    swap(trees[0], trees[origin]);\\n    sort(trees.begin() + 1, trees.end(), [&](const vector<int>& lhs, const vector<int>& rhs) -> bool {\\n      int result = cross(trees[0], lhs, rhs);\\n      if (result != 0) return result > 0;\\n      return norm(trees[0], lhs) < norm(trees[0], rhs);\\n    });\\n\\n    // deal with cases that the last k points are on one line\\n    int pos = trees.size() - 2;\\n    while (pos > 0 && cross(trees[0], trees.back(), trees[pos]) == 0) {\\n      --pos;\\n    }\\n    reverse(trees.begin() + pos + 1, trees.end());\\n\\n    vector<vector<int>> ans = {trees[0], trees[1]};\\n    for (int i = 2; i < trees.size(); ++i) {\\n      int cross_result = cross(ans[ans.size() - 2], ans[ans.size() - 1], trees[i]);\\n      while (cross_result < 0) {\\n        ans.pop_back();\\n        cross_result = cross(ans[ans.size() - 2], ans[ans.size() - 1], trees[i]);\\n      }\\n      ans.push_back(trees[i]);\\n    }\\n    return ans;\\n  }\\n\\n private:\\n  inline double norm(const vector<int>& o, const vector<int>& x) {\\n    int xx = x[0] - o[0];\\n    int yy = x[1] - o[1];\\n    return sqrt(xx * xx + yy * yy);\\n  }\\n\\n  inline int cross(const vector<int>& x, const vector<int>& y, const vector<int>& z) {\\n    return (y[0] - x[0]) * (z[1] - y[1]) - (y[1] - x[1]) * (z[0] - y[0]);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443525,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int[][] OuterTrees(int[][] trees) {\\n        \\n        Array.Sort(trees, (a, b) => a[0] == b[0]? b[1] - a[1] : a[0] - b[0]);\\n        \\n        Stack<int[]> stack = new Stack<int[]>();\\n        \\n        // low convex hull\\n        for(int i = 0; i < trees.Length; i++)\\n        {\\n            // check if stack.Peek() is part of the hull\\n            // stack.ElementAt(1): 2nd top element in the stack.\\n            while(stack.Count >= 2 && orientation(stack.Peek(), trees[i], stack.ElementAt(1)) > 0)\\n            {\\n                // stack.Peek() is in trees[i]\\'s counterclockwise direction, so stack.Peek() can\\'t be the hull\\n                stack.Pop();\\n            }\\n            stack.Push(trees[i]);\\n        }\\n        \\n        // up convex hull\\n        for(int j = trees.Length - 1; j >=0; j--)\\n        {\\n            while(stack.Count >= 2 && orientation(stack.Peek(), trees[j], stack.ElementAt(1)) > 0)\\n                stack.Pop();\\n            stack.Push(trees[j]);\\n        }\\n        \\n        HashSet<int[]> set = new HashSet<int[]>(stack);\\n        return set.ToArray();\\n    }\\n    \\n    private int orientation(int[] p, int[] q, int[] r)\\n    {\\n        /*\\n            Check if tree P is in tree Q\\'s counterclockwise direction\\n            \\n            direction = slopPR - slopQR = (p[1] - r[1]) / (p[0] - r[0]) - (q[1] - r[1]) / (q[0] - r[0]) \\n            \\n            if direction > 0, P is in Q\\'s counterclockwise direction\\n            else, P is in Q\\'s clockwise direction\\n\\n        */\\n        \\n        int direction = (p[1] - r[1]) * (q[0] - r[0]) - (p[0] - r[0]) * (q[1] - r[1]);  \\n        return direction;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] OuterTrees(int[][] trees) {\\n        \\n        Array.Sort(trees, (a, b) => a[0] == b[0]? b[1] - a[1] : a[0] - b[0]);\\n        \\n        Stack<int[]> stack = new Stack<int[]>();\\n        \\n        // low convex hull\\n        for(int i = 0; i < trees.Length; i++)\\n        {\\n            // check if stack.Peek() is part of the hull\\n            // stack.ElementAt(1): 2nd top element in the stack.\\n            while(stack.Count >= 2 && orientation(stack.Peek(), trees[i], stack.ElementAt(1)) > 0)\\n            {\\n                // stack.Peek() is in trees[i]\\'s counterclockwise direction, so stack.Peek() can\\'t be the hull\\n                stack.Pop();\\n            }\\n            stack.Push(trees[i]);\\n        }\\n        \\n        // up convex hull\\n        for(int j = trees.Length - 1; j >=0; j--)\\n        {\\n            while(stack.Count >= 2 && orientation(stack.Peek(), trees[j], stack.ElementAt(1)) > 0)\\n                stack.Pop();\\n            stack.Push(trees[j]);\\n        }\\n        \\n        HashSet<int[]> set = new HashSet<int[]>(stack);\\n        return set.ToArray();\\n    }\\n    \\n    private int orientation(int[] p, int[] q, int[] r)\\n    {\\n        /*\\n            Check if tree P is in tree Q\\'s counterclockwise direction\\n            \\n            direction = slopPR - slopQR = (p[1] - r[1]) / (p[0] - r[0]) - (q[1] - r[1]) / (q[0] - r[0]) \\n            \\n            if direction > 0, P is in Q\\'s counterclockwise direction\\n            else, P is in Q\\'s clockwise direction\\n\\n        */\\n        \\n        int direction = (p[1] - r[1]) * (q[0] - r[0]) - (p[0] - r[0]) * (q[1] - r[1]);  \\n        return direction;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443383,
                "title": "typescript-convex-hull-algorithm-with-a-little-modification",
                "content": "```\\nfunction outerTrees(trees: number[][]): number[][] {\\n  // Boring case: no points or a single point, possibly repeated multiple times.\\n  if (trees.length === 1) return trees;\\n\\n  // Sort the points lexicographically (tuples are compared lexicographically).\\n  // Remove duplicates to detect the case we have just one unique point.\\n  trees.sort((a, b) => {\\n    if (a[0] === b[0]) {\\n      return a[1] - b[1];\\n    } else {\\n      return a[0] - b[0];\\n    }\\n  });\\n\\n  // 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross product.\\n  // Returns a positive value, if OAB makes a counter-clockwise turn,\\n  // negative for clockwise turn, and zero if the points are collinear.\\n  const cross = (\\n    o: Array<number>,\\n    a: Array<number>,\\n    b: Array<number>,\\n  ): number => {\\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\\n  };\\n\\n  // Build lower hull\\n  const lower: number[][] = new Array();\\n  trees.forEach((p) => {\\n    while (\\n      lower.length >= 2 &&\\n      cross(lower[lower.length - 2], lower[lower.length - 1], p) < 0\\n    ) {\\n      lower.pop();\\n    }\\n    lower.push(p);\\n  });\\n\\n  // Build upper hull\\n  const upper: number[][] = new Array();\\n  trees\\n    .slice()\\n    .reverse()\\n    .forEach((p) => {\\n      while (\\n        upper.length >= 2 &&\\n        cross(upper[upper.length - 2], upper[upper.length - 1], p) < 0\\n      ) {\\n        upper.pop();\\n      }\\n      upper.push(p);\\n    });\\n\\n  // Concatenation of the lower and upper hulls gives the convex hull.\\n  // Last point of each list is omitted because it is repeated at the beginning of the other list.\\n  upper.pop();\\n  lower.pop();\\n\\n  // Remove duplicate point\\n  const prevs = new Set();\\n  return [...upper, ...lower].filter((value) => {\\n    if (prevs.has(value.toString())) {\\n      return false;\\n    }\\n    prevs.add(value.toString());\\n    return true;\\n  });\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction outerTrees(trees: number[][]): number[][] {\\n  // Boring case: no points or a single point, possibly repeated multiple times.\\n  if (trees.length === 1) return trees;\\n\\n  // Sort the points lexicographically (tuples are compared lexicographically).\\n  // Remove duplicates to detect the case we have just one unique point.\\n  trees.sort((a, b) => {\\n    if (a[0] === b[0]) {\\n      return a[1] - b[1];\\n    } else {\\n      return a[0] - b[0];\\n    }\\n  });\\n\\n  // 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross product.\\n  // Returns a positive value, if OAB makes a counter-clockwise turn,\\n  // negative for clockwise turn, and zero if the points are collinear.\\n  const cross = (\\n    o: Array<number>,\\n    a: Array<number>,\\n    b: Array<number>,\\n  ): number => {\\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\\n  };\\n\\n  // Build lower hull\\n  const lower: number[][] = new Array();\\n  trees.forEach((p) => {\\n    while (\\n      lower.length >= 2 &&\\n      cross(lower[lower.length - 2], lower[lower.length - 1], p) < 0\\n    ) {\\n      lower.pop();\\n    }\\n    lower.push(p);\\n  });\\n\\n  // Build upper hull\\n  const upper: number[][] = new Array();\\n  trees\\n    .slice()\\n    .reverse()\\n    .forEach((p) => {\\n      while (\\n        upper.length >= 2 &&\\n        cross(upper[upper.length - 2], upper[upper.length - 1], p) < 0\\n      ) {\\n        upper.pop();\\n      }\\n      upper.push(p);\\n    });\\n\\n  // Concatenation of the lower and upper hulls gives the convex hull.\\n  // Last point of each list is omitted because it is repeated at the beginning of the other list.\\n  upper.pop();\\n  lower.pop();\\n\\n  // Remove duplicate point\\n  const prevs = new Set();\\n  return [...upper, ...lower].filter((value) => {\\n    if (prevs.has(value.toString())) {\\n      return false;\\n    }\\n    prevs.add(value.toString());\\n    return true;\\n  });\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1443302,
                "title": "rust-intuition-from-scratch-ascii-art-slope-compare",
                "content": "**Intro**\\nIt seems all of the optimal solutions involves doing a Graham Scan. I hadn\\'t heard of this algorithm beforehand but ended up coming up with what seems to be a solution that runs in optimal time through intuition. The code I wrote up is a bit long but I\\'ll try to break down the logic corresponding to each part.\\n\\n**Intuition**\\nBasically, we should first realize that the answer consists of points on the \"outer boundary\" of the figure. My first thought was that the leftmost, rightmost, topmost, and bottommost points should all be included, but when drawing lines between these points, it\\'s possible that we\\'d need to expand our boundary.\\n\\nFor example, consider the below diagram:\\n```\\n0 --------2\\n  \\\\       |\\n    \\\\     |\\n      \\\\   |\\n\\t\\t\\\\ |\\n\\t      1\\n```\\n\\nNow if we add a third point `3` that is to the right of `0` and left of `1` and below `2` there are there are a two possibilities:\\n\\n*Case 1*\\n```\\n0 --------2\\n  \\\\       |\\n    \\\\ 3   |\\n      \\\\   |\\n\\t\\t\\\\ |\\n\\t      1\\n```\\n*Case 2*\\n```\\n0 --------2\\n  \\\\       |\\n  3 \\\\     |\\n      \\\\   |\\n\\t\\t\\\\ |\\n\\t      1\\n```\\n\\nNotice in Case 1 we don\\'t need to add 3 into the bottom boundary; we\\'d handle it later by either \\n* Putting it in the top boundary later\\n* Ignoring it, since it\\'s above the bottom boundary or below the top boundary (in this case it\\'s below the top boundary `0` to `2`.\\n\\nHowever, for Case 2, we visually see that we must add it into the bottom boundary. Mathematically, this is due to the fact that the slope between `0` and `3` is **less than** the slope between `0` and `1`. So, the revised case 2 diagram would be below:\\n```\\n0 --------2\\n \\\\        |\\n  3       |\\n    \\\\     |\\n\\t  \\\\   |\\n\\t      1\\n```\\n**Strategy**\\nWithout worrying about algorithm implementation, here\\'s a very high level description of the solution.\\n1. Push the left boundary into result. Note the bottom left and upper left coordinates.\\n2. Push the right boundary into result. Note the bottom right and upper right coordinates.\\n3. Grab points that could be on the bottom boundary (for each x-value in between left and right, note the lowest y coordinate).\\n4. Grab points that could be on the top boundary\\n5. Iterate over possible boundary and get the optimal perimeter\\n6. Iterate over possible top boundary and get the optimal perimeter \\n\\nNote steps 1-4 are a bit tedious but are straight-forward. Furthermore, we should sort the input by x coordinates in order to optimize the below steps.\\n**Code for 1-4**\\n```\\npub fn outer_trees(trees: Vec<Vec<i32>>) -> Vec<Vec<i32>> { // main\\n\\tlet mut vertices: Vec<(i32, i32)> = Vec::new();\\n\\tfor tree in trees {\\n\\t\\tvertices.push((tree[0], tree[1]));\\n\\t}\\n\\n\\tvertices.sort();\\n\\treturn Solution::enclose_boundary(&vertices);\\n}\\n\\nfn enclose_boundary(vertices: &Vec<(i32, i32)>) -> Vec<Vec<i32>> {\\n        let mut res: Vec<Vec<i32>> = Vec::new();\\n        if vertices.is_empty() {\\n            return res;\\n        }\\n        \\n        let N: usize = vertices.len();\\n        // determine left, right parts\\n        let (left, right): (i32, i32) = (vertices[0].0, vertices[N - 1].0);\\n        \\n        // insert left part\\n        let highest_left_idx: usize = Solution::push_boundary(\\n            &vertices,\\n            &mut res,\\n            0,\\n            N,\\n            vertices[0].0,\\n            false\\n        );\\n    \\n        if vertices[0].0 == vertices[N - 1].0 { // vertical line, so we\\'re done\\n            return res;\\n        }\\n        \\n        let lowest_right_idx: usize = Solution::push_boundary(\\n            &vertices,\\n            &mut res,\\n            highest_left_idx + 1,\\n            N,\\n            vertices[N - 1].0,\\n            true\\n        );\\n        \\n        // now insert lower and upper boundaries\\n        let mut bottom_cands: Vec<(i32, i32)> = Vec::with_capacity(N);\\n        let mut top_cands: Vec<(i32, i32)> = Vec::with_capacity(N);\\n        for idx in (highest_left_idx + 1)..lowest_right_idx {\\n            if vertices[idx].0 != vertices[idx - 1].0 { // new lowest entry due to sorting\\n                bottom_cands.push((vertices[idx].0, vertices[idx].1));\\n                top_cands.push((vertices[idx].0, vertices[idx].1)); // keep track of upper\\n            } else { // repeat element - modify current back of upper candidate\\n                top_cands.last_mut().unwrap().1 = vertices[idx].1;\\n            }\\n        }\\n\\t\\t// steps 5-6\\n\\t\\t...\\n\\t\\t\\n\\t\\treturn res;\\n}\\n```\\n\\n**Steps 5-6 Optimization**\\nLet\\'s focus on the bottom boundary first. From the above intuition, it will consist of a monotonic increasing sequence of slopes between coordinates on the perimeter. \\n\\nThis sequence of points can be calculated in O(N^2) time naively, O(Nlog(N)) time with a priority queue, or O(N) time with a monotonic stack.If the points are in left - right order, we can calculate this bottom most boundary in O(N) time through a monotonic stack.\\n\\n**Mono Stack**\\n```\\n    /***\\n     * Employ a monostack algorithm to get the desired points on the boundary;\\n     * basically, if the points fall above/below some given line between points,\\n     * they should be considered\\n     ***/\\n    fn get_slopes(\\n        cands: &Vec<(i32, i32)>,        // candidates to be used\\n        left_elm: &(i32, i32),          // default left\\n        right_elm: &(i32, i32),         // default right\\n        cmp: fn(&Slope, &Slope) -> bool // connect prev to curr if satisfied \\n    ) -> VecDeque<(Slope, usize)> {\\n        let mut slopes: VecDeque<(Slope, usize)> = VecDeque::new();\\n        for (idx, coord) in cands.iter().enumerate() {\\n            let mut curr_slope = Solution::discard_and_get(&mut slopes, cands, coord, cmp);   \\n            if slopes.is_empty() {\\n                curr_slope.set(coord.1 - left_elm.1, coord.0 - left_elm.0);\\n            }\\n            \\n            slopes.push_back((curr_slope, idx));\\n        }\\n        \\n        Solution::discard_and_get(&mut slopes, cands, right_elm, cmp);        \\n        return slopes;\\n    }\\n    \\n    /***\\n     * Monotonic stack routine. Return the last computed entry, which\\n     * is the slope between the rightmost valid coordinate in the stack\\n     * and the current point.\\n     ***/\\n    fn discard_and_get(\\n        mono: &mut VecDeque<(Slope, usize)>,\\n        cands: &Vec<(i32, i32)>,\\n        curr: &(i32, i32),\\n        cmp: fn(&Slope, &Slope) -> bool\\n    ) -> Slope {\\n        let mut last: Slope = Slope::new(0, 0);\\n        while let Some(slope_and_idx) = mono.back() {\\n            let prev: (i32, i32) = cands[slope_and_idx.1];\\n            last.set(curr.1 - prev.1, curr.0 - prev.0);\\n            if cmp(&last, &slope_and_idx.0) {\\n                mono.pop_back();\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return last;\\n    }\\n```\\nHere is how we\\'d call it for the bottom boundary:\\n```\\nfn enclose_boundary(vertices: &Vec<(i32, i32)>) -> Vec<Vec<i32>> {\\n    // Steps 1-4\\n   ...\\n    // Step 5\\n\\tlet mut elements_below: VecDeque<(Slope, usize)> = Solution::get_slopes(\\n\\t\\t&bottom_cands,\\n\\t\\t&vertices[0],\\n\\t\\t&vertices[lowest_right_idx],\\n\\t\\tSlope::lt\\n\\t);\\n\\n\\t\\t\\t// add all remaining points\\n\\twhile let Some(slope_pair) = elements_below.back() {\\n\\t\\tlet idx = slope_pair.1;\\n\\t\\tres.push(vec![bottom_cands[idx].0, bottom_cands[idx].1]);\\n\\t\\tseen_cands[idx] = true;\\n\\t\\telements_below.pop_back();\\n\\t}\\n\\t// step 6\\n\\tlet mut elements_above: VecDeque<(Slope, usize)> = Solution::get_slopes(\\n\\t\\t&top_cands,\\n\\t\\t&vertices[highest_left_idx],\\n\\t\\t&vertices[N - 1],\\n\\t\\tSlope::gt\\n\\t);\\n\\n\\t// copy over\\n\\twhile let Some(slope_pair) = elements_above.back() {\\n\\t\\tlet idx = slope_pair.1;\\n\\t\\tif bottom_cands[idx].1 != top_cands[idx].1 || !seen_cands[idx] { // not a duplicate, so add it\\n\\t\\t\\tres.push(vec![top_cands[idx].0, top_cands[idx].1]);\\n\\t\\t}\\n\\n\\t\\telements_above.pop_back();\\n\\t}\\n\\n\\treturn res;\\t\\n```\\nAnd we\\'re done!\\n\\n**Slopes**\\nThe only remaining question about the provided code is the `Slope` class. Recall that the slope between two coordinates `c1 = (x1, y1)` and `c2 = (x2, y2)` is given by `slope(c1, c2) = (y2 - y1)/(x2 - x1)`.\\n\\nAn unfavorable aspect of this is that we\\'re given integer coordinates and that the slope between them is a float. However, if we\\'d like to *compare* slopes, we can keep everything as integers.\\n```\\nslope(c1, c2) = (y2 - y1)/(x2 - x1)\\nslope(c3, c4) = (y4 - y3)/(x3 - x3)\\n\\nslope(c1, c2) > slope(c3, c4) <=> (y2 - y1)/(x2 - x1) > (y4 - y3)/(x4 - x3)\\n                              <=> (y2 - y1)*(x4 - x3) > (y4 - y3)*(x2 - x1)\\n```\\n*Note*: If exactly one of the denominators that are multiplied is negative, we\\'d have to flip the sign.\\n\\n**Slope Code**\\n```\\n/***\\n * Main purpose of slope class is to provide easy less than/greater than \\n * comparisons.\\n ***/\\nstruct Slope {\\n    m_y: i32,\\n    m_x: i32,\\n}\\n\\nimpl Slope {\\n    pub fn new(coord_x: i32, coord_y:i32) -> Self {\\n        return Slope {\\n            m_x: coord_x,\\n            m_y: coord_y,\\n        };\\n    }\\n    \\n    pub fn set(&mut self, x: i32, y: i32) -> () {\\n        self.m_x = x;\\n        self.m_y = y;\\n    }\\n    \\n    /***\\n     * Is Slope left < Slope right\\n     * left: yL/xL, right: yR/xR\\n     * yL/xL < yR/xR iff\\n     * yL*xR < yR*xL\\n     ***/\\n    pub fn lt(lhs: &Self, rhs: &Self) -> bool {\\n        if (rhs.m_x < 0) ^ (lhs.m_x < 0) {\\n            return lhs.m_y * rhs.m_x > rhs.m_y * lhs.m_x;\\n        }\\n        \\n        return lhs.m_y * rhs.m_x > rhs.m_y * lhs.m_x\\n    }\\n    \\n    pub fn gt(lhs: &Self, rhs: &Self) -> bool {\\n        if (rhs.m_x < 0) ^ (lhs.m_x < 0) {\\n            return lhs.m_y * rhs.m_x < rhs.m_y * lhs.m_x;\\n        }\\n        \\n        return lhs.m_y * rhs.m_x < rhs.m_y * lhs.m_x;\\n    }\\n}\\n\\nimpl Clone for Slope {\\n    fn clone(&self) -> Self {\\n        return Self {\\n            m_x: self.m_x,\\n            m_y: self.m_y\\n        };\\n    }\\n}\\n```\\n\\n**Some Edge Cases**\\n- Handle a single vertical line of points case. This is handled in the Steps 1-4 code.\\n- Avoid inserting shared points between bottom and top boundaries. This is handled by the `seen_cands` vector, which works because the top and bottom boundaries are exactly the same size (since they iterate over x coordinates in between the left and right).\\n\\n**Overall Code**\\nBelow is the complete solution.\\n```\\nuse std::collections::VecDeque;\\n\\n/***\\n * Main purpose of slope class is to provide easy less than/greater than \\n * comparisons.\\n ***/\\nstruct Slope {\\n    m_y: i32,\\n    m_x: i32,\\n}\\n\\nimpl Slope {\\n    pub fn new(coord_x: i32, coord_y:i32) -> Self {\\n        return Slope {\\n            m_x: coord_x,\\n            m_y: coord_y,\\n        };\\n    }\\n    \\n    pub fn set(&mut self, x: i32, y: i32) -> () {\\n        self.m_x = x;\\n        self.m_y = y;\\n    }\\n    \\n    /***\\n     * Is Slope left < Slope right\\n     * left: yL/xL, right: yR/xR\\n     * yL/xL < yR/xR iff\\n     * yL*xR < yR*xL\\n     ***/\\n    pub fn lt(lhs: &Self, rhs: &Self) -> bool {\\n        if (rhs.m_x < 0) ^ (lhs.m_x < 0) {\\n            return lhs.m_y * rhs.m_x > rhs.m_y * lhs.m_x;\\n        }\\n        \\n        return lhs.m_y * rhs.m_x > rhs.m_y * lhs.m_x\\n    }\\n    \\n    pub fn gt(lhs: &Self, rhs: &Self) -> bool {\\n        if (rhs.m_x < 0) ^ (lhs.m_x < 0) {\\n            return lhs.m_y * rhs.m_x < rhs.m_y * lhs.m_x;\\n        }\\n        \\n        return lhs.m_y * rhs.m_x < rhs.m_y * lhs.m_x;\\n    }\\n}\\n\\nimpl Clone for Slope {\\n    fn clone(&self) -> Self {\\n        return Self {\\n            m_x: self.m_x,\\n            m_y: self.m_y\\n        };\\n    }\\n}\\n\\n\\nimpl Solution {\\n    /***\\n     * Determine the trees that are on the minimum perimeter enclosing all trees.\\n     * Consists of points that we consider to be on the outermost boundary\\n     * Sort the points by x-coordinate first for easy computation, then\\n     * determine the boundary\\n     ***/\\n    pub fn outer_trees(trees: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut vertices: Vec<(i32, i32)> = Vec::new();\\n        for tree in trees {\\n            vertices.push((tree[0], tree[1]));\\n        }\\n        \\n        vertices.sort();\\n        return Solution::enclose_boundary(&vertices);\\n    }\\n    \\n    /***\\n     * 6 Steps to Solution\\n     * 1. Identify bottom and upper leftmost points and push left boundary\\n     * 2. Identify bottom and upper rightmost points and push right boundary\\n     * 3. Filter candidate bottom points\\n     * 4. Filter candidate top points\\n     * 5. Calculate optimal lower boundary\\n     * 6. Calculate optimal upper boundary\\n     ***/\\n    fn enclose_boundary(vertices: &Vec<(i32, i32)>) -> Vec<Vec<i32>> {\\n        let mut res: Vec<Vec<i32>> = Vec::new();\\n        if vertices.is_empty() {\\n            return res;\\n        }\\n        \\n        let N: usize = vertices.len();\\n        // Step 1: insert left part\\n        let highest_left_idx: usize = Solution::push_boundary(\\n            &vertices,\\n            &mut res,\\n            0,\\n            N,\\n            vertices[0].0,\\n            false\\n        );\\n    \\n        if vertices[0].0 == vertices[N - 1].0 { // vertical line, so we\\'re done\\n            return res;\\n        }\\n        \\n        // Step 2: insert right part\\n        let lowest_right_idx: usize = Solution::push_boundary(\\n            &vertices,\\n            &mut res,\\n            highest_left_idx + 1,\\n            N,\\n            vertices[N - 1].0,\\n            true\\n        );\\n        \\n        // Step 3 and 4: insert lower and upper boundaries\\n        let mut bottom_cands: Vec<(i32, i32)> = Vec::with_capacity(N);\\n        let mut top_cands: Vec<(i32, i32)> = Vec::with_capacity(N);\\n        for idx in (highest_left_idx + 1)..lowest_right_idx {\\n            if vertices[idx].0 != vertices[idx - 1].0 { // new lowest entry due to sorting\\n                bottom_cands.push((vertices[idx].0, vertices[idx].1));\\n                top_cands.push((vertices[idx].0, vertices[idx].1)); // keep track of upper\\n            } else { // repeat element - modify current back of upper candidate\\n                top_cands.last_mut().unwrap().1 = vertices[idx].1;\\n            }\\n        }\\n        \\n        // Step 5: Add bottom boundary\\n        let mut elements_below: VecDeque<(Slope, usize)> = Solution::get_slopes(\\n            &bottom_cands,\\n            &vertices[0],\\n            &vertices[lowest_right_idx],\\n            Slope::lt\\n        );\\n        \\n        // add all remaining points\\n        let mut seen_cands: Vec<bool> = vec![false; bottom_cands.len()]; // avoid re-adding points in top boundary that were added in the bottom for the future\\n        while let Some(slope_pair) = elements_below.back() {\\n            let idx = slope_pair.1;\\n            res.push(vec![bottom_cands[idx].0, bottom_cands[idx].1]);\\n            seen_cands[idx] = true;\\n            elements_below.pop_back();\\n        }\\n        \\n        // Step 6: same for above\\n        let mut elements_above: VecDeque<(Slope, usize)> = Solution::get_slopes(\\n            &top_cands,\\n            &vertices[highest_left_idx],\\n            &vertices[N - 1],\\n            Slope::gt\\n        );\\n\\n        // copy over\\n        while let Some(slope_pair) = elements_above.back() {\\n            let idx = slope_pair.1;\\n            if bottom_cands[idx].1 != top_cands[idx].1 || !seen_cands[idx] { // not a duplicate, so add it\\n                res.push(vec![top_cands[idx].0, top_cands[idx].1]);\\n            }\\n            \\n            elements_above.pop_back();\\n        }\\n        \\n        return res;\\n    }\\n    \\n    /***\\n     * Employ a monostack algorithm to get the desired points on the boundary;\\n     * basically, if the points fall above/below some given line between points,\\n     * they should be considered\\n     ***/\\n    fn get_slopes(\\n        cands: &Vec<(i32, i32)>,        // candidates to be used\\n        left_elm: &(i32, i32),          // default left\\n        right_elm: &(i32, i32),         // default right\\n        cmp: fn(&Slope, &Slope) -> bool // connect prev to curr if satisfied \\n    ) -> VecDeque<(Slope, usize)> {\\n        let mut slopes: VecDeque<(Slope, usize)> = VecDeque::new();\\n        for (idx, coord) in cands.iter().enumerate() {\\n            let mut curr_slope = Solution::discard_and_get(&mut slopes, cands, coord, cmp);   \\n            if slopes.is_empty() {\\n                curr_slope.set(coord.1 - left_elm.1, coord.0 - left_elm.0);\\n            }\\n            \\n            slopes.push_back((curr_slope, idx));\\n        }\\n        \\n        Solution::discard_and_get(&mut slopes, cands, right_elm, cmp);        \\n        return slopes;\\n    }\\n    \\n    /***\\n     * Monotonic stack routine. Return the last computed entry, which\\n     * is the slope between the rightmost valid coordinate in the stack\\n     * and the current point.\\n     ***/\\n    fn discard_and_get(\\n        mono: &mut VecDeque<(Slope, usize)>,\\n        cands: &Vec<(i32, i32)>,\\n        curr: &(i32, i32),\\n        cmp: fn(&Slope, &Slope) -> bool\\n    ) -> Slope {\\n        let mut last: Slope = Slope::new(0, 0);\\n        while let Some(slope_and_idx) = mono.back() {\\n            let prev: (i32, i32) = cands[slope_and_idx.1];\\n            last.set(curr.1 - prev.1, curr.0 - prev.0);\\n            if cmp(&last, &slope_and_idx.0) {\\n                mono.pop_back();\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return last;\\n    }\\n    \\n    /***\\n     * Return the index of the last element in the boundary and\\n     * populate the result vector with the boundary\\n     ***/\\n    fn push_boundary(\\n        vertices: &Vec<(i32, i32)>,\\n        res: &mut Vec<Vec<i32>>,\\n        left: usize,  // inclusive left\\n        right: usize, // exclusive right\\n        bound: i32,\\n        should_rev: bool\\n    ) -> usize {\\n        let mut r_last: usize = left; // relative index... needs adjustment\\n        if should_rev {\\n            for (r_idx, coord) in vertices[left..right].iter().rev().enumerate() {\\n                if !Solution::update_bound(coord, r_idx, res, bound, &mut r_last) {\\n                    break;\\n                }\\n            }   \\n            \\n            return right - r_last - 1; // adjust for absolute indexing\\n        }\\n        \\n        for (r_idx, coord) in vertices[left..right].iter().enumerate() {\\n            if !Solution::update_bound(coord, r_idx, res, bound, &mut r_last) {\\n                break;\\n            }\\n        }\\n            \\n        return left + r_last;\\n    }\\n    \\n    fn update_bound(\\n        coord: &(i32, i32), \\n        idx: usize, \\n        res: &mut Vec<Vec<i32>>, \\n        bound: i32, \\n        last: &mut usize\\n    ) -> bool {\\n        if coord.0 != bound {\\n            return false;\\n        }\\n        \\n        res.push(vec![coord.0, coord.1]);\\n        *last = idx;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n0 --------2\\n  \\\\       |\\n    \\\\     |\\n      \\\\   |\\n\\t\\t\\\\ |\\n\\t      1\\n```\n```\\n0 --------2\\n  \\\\       |\\n    \\\\ 3   |\\n      \\\\   |\\n\\t\\t\\\\ |\\n\\t      1\\n```\n```\\n0 --------2\\n  \\\\       |\\n  3 \\\\     |\\n      \\\\   |\\n\\t\\t\\\\ |\\n\\t      1\\n```\n```\\n0 --------2\\n \\\\        |\\n  3       |\\n    \\\\     |\\n\\t  \\\\   |\\n\\t      1\\n```\n```\\npub fn outer_trees(trees: Vec<Vec<i32>>) -> Vec<Vec<i32>> { // main\\n\\tlet mut vertices: Vec<(i32, i32)> = Vec::new();\\n\\tfor tree in trees {\\n\\t\\tvertices.push((tree[0], tree[1]));\\n\\t}\\n\\n\\tvertices.sort();\\n\\treturn Solution::enclose_boundary(&vertices);\\n}\\n\\nfn enclose_boundary(vertices: &Vec<(i32, i32)>) -> Vec<Vec<i32>> {\\n        let mut res: Vec<Vec<i32>> = Vec::new();\\n        if vertices.is_empty() {\\n            return res;\\n        }\\n        \\n        let N: usize = vertices.len();\\n        // determine left, right parts\\n        let (left, right): (i32, i32) = (vertices[0].0, vertices[N - 1].0);\\n        \\n        // insert left part\\n        let highest_left_idx: usize = Solution::push_boundary(\\n            &vertices,\\n            &mut res,\\n            0,\\n            N,\\n            vertices[0].0,\\n            false\\n        );\\n    \\n        if vertices[0].0 == vertices[N - 1].0 { // vertical line, so we\\'re done\\n            return res;\\n        }\\n        \\n        let lowest_right_idx: usize = Solution::push_boundary(\\n            &vertices,\\n            &mut res,\\n            highest_left_idx + 1,\\n            N,\\n            vertices[N - 1].0,\\n            true\\n        );\\n        \\n        // now insert lower and upper boundaries\\n        let mut bottom_cands: Vec<(i32, i32)> = Vec::with_capacity(N);\\n        let mut top_cands: Vec<(i32, i32)> = Vec::with_capacity(N);\\n        for idx in (highest_left_idx + 1)..lowest_right_idx {\\n            if vertices[idx].0 != vertices[idx - 1].0 { // new lowest entry due to sorting\\n                bottom_cands.push((vertices[idx].0, vertices[idx].1));\\n                top_cands.push((vertices[idx].0, vertices[idx].1)); // keep track of upper\\n            } else { // repeat element - modify current back of upper candidate\\n                top_cands.last_mut().unwrap().1 = vertices[idx].1;\\n            }\\n        }\\n\\t\\t// steps 5-6\\n\\t\\t...\\n\\t\\t\\n\\t\\treturn res;\\n}\\n```\n```\\n    /***\\n     * Employ a monostack algorithm to get the desired points on the boundary;\\n     * basically, if the points fall above/below some given line between points,\\n     * they should be considered\\n     ***/\\n    fn get_slopes(\\n        cands: &Vec<(i32, i32)>,        // candidates to be used\\n        left_elm: &(i32, i32),          // default left\\n        right_elm: &(i32, i32),         // default right\\n        cmp: fn(&Slope, &Slope) -> bool // connect prev to curr if satisfied \\n    ) -> VecDeque<(Slope, usize)> {\\n        let mut slopes: VecDeque<(Slope, usize)> = VecDeque::new();\\n        for (idx, coord) in cands.iter().enumerate() {\\n            let mut curr_slope = Solution::discard_and_get(&mut slopes, cands, coord, cmp);   \\n            if slopes.is_empty() {\\n                curr_slope.set(coord.1 - left_elm.1, coord.0 - left_elm.0);\\n            }\\n            \\n            slopes.push_back((curr_slope, idx));\\n        }\\n        \\n        Solution::discard_and_get(&mut slopes, cands, right_elm, cmp);        \\n        return slopes;\\n    }\\n    \\n    /***\\n     * Monotonic stack routine. Return the last computed entry, which\\n     * is the slope between the rightmost valid coordinate in the stack\\n     * and the current point.\\n     ***/\\n    fn discard_and_get(\\n        mono: &mut VecDeque<(Slope, usize)>,\\n        cands: &Vec<(i32, i32)>,\\n        curr: &(i32, i32),\\n        cmp: fn(&Slope, &Slope) -> bool\\n    ) -> Slope {\\n        let mut last: Slope = Slope::new(0, 0);\\n        while let Some(slope_and_idx) = mono.back() {\\n            let prev: (i32, i32) = cands[slope_and_idx.1];\\n            last.set(curr.1 - prev.1, curr.0 - prev.0);\\n            if cmp(&last, &slope_and_idx.0) {\\n                mono.pop_back();\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return last;\\n    }\\n```\n```\\nfn enclose_boundary(vertices: &Vec<(i32, i32)>) -> Vec<Vec<i32>> {\\n    // Steps 1-4\\n   ...\\n    // Step 5\\n\\tlet mut elements_below: VecDeque<(Slope, usize)> = Solution::get_slopes(\\n\\t\\t&bottom_cands,\\n\\t\\t&vertices[0],\\n\\t\\t&vertices[lowest_right_idx],\\n\\t\\tSlope::lt\\n\\t);\\n\\n\\t\\t\\t// add all remaining points\\n\\twhile let Some(slope_pair) = elements_below.back() {\\n\\t\\tlet idx = slope_pair.1;\\n\\t\\tres.push(vec![bottom_cands[idx].0, bottom_cands[idx].1]);\\n\\t\\tseen_cands[idx] = true;\\n\\t\\telements_below.pop_back();\\n\\t}\\n\\t// step 6\\n\\tlet mut elements_above: VecDeque<(Slope, usize)> = Solution::get_slopes(\\n\\t\\t&top_cands,\\n\\t\\t&vertices[highest_left_idx],\\n\\t\\t&vertices[N - 1],\\n\\t\\tSlope::gt\\n\\t);\\n\\n\\t// copy over\\n\\twhile let Some(slope_pair) = elements_above.back() {\\n\\t\\tlet idx = slope_pair.1;\\n\\t\\tif bottom_cands[idx].1 != top_cands[idx].1 || !seen_cands[idx] { // not a duplicate, so add it\\n\\t\\t\\tres.push(vec![top_cands[idx].0, top_cands[idx].1]);\\n\\t\\t}\\n\\n\\t\\telements_above.pop_back();\\n\\t}\\n\\n\\treturn res;\\t\\n```\n```\\nslope(c1, c2) = (y2 - y1)/(x2 - x1)\\nslope(c3, c4) = (y4 - y3)/(x3 - x3)\\n\\nslope(c1, c2) > slope(c3, c4) <=> (y2 - y1)/(x2 - x1) > (y4 - y3)/(x4 - x3)\\n                              <=> (y2 - y1)*(x4 - x3) > (y4 - y3)*(x2 - x1)\\n```\n```\\n/***\\n * Main purpose of slope class is to provide easy less than/greater than \\n * comparisons.\\n ***/\\nstruct Slope {\\n    m_y: i32,\\n    m_x: i32,\\n}\\n\\nimpl Slope {\\n    pub fn new(coord_x: i32, coord_y:i32) -> Self {\\n        return Slope {\\n            m_x: coord_x,\\n            m_y: coord_y,\\n        };\\n    }\\n    \\n    pub fn set(&mut self, x: i32, y: i32) -> () {\\n        self.m_x = x;\\n        self.m_y = y;\\n    }\\n    \\n    /***\\n     * Is Slope left < Slope right\\n     * left: yL/xL, right: yR/xR\\n     * yL/xL < yR/xR iff\\n     * yL*xR < yR*xL\\n     ***/\\n    pub fn lt(lhs: &Self, rhs: &Self) -> bool {\\n        if (rhs.m_x < 0) ^ (lhs.m_x < 0) {\\n            return lhs.m_y * rhs.m_x > rhs.m_y * lhs.m_x;\\n        }\\n        \\n        return lhs.m_y * rhs.m_x > rhs.m_y * lhs.m_x\\n    }\\n    \\n    pub fn gt(lhs: &Self, rhs: &Self) -> bool {\\n        if (rhs.m_x < 0) ^ (lhs.m_x < 0) {\\n            return lhs.m_y * rhs.m_x < rhs.m_y * lhs.m_x;\\n        }\\n        \\n        return lhs.m_y * rhs.m_x < rhs.m_y * lhs.m_x;\\n    }\\n}\\n\\nimpl Clone for Slope {\\n    fn clone(&self) -> Self {\\n        return Self {\\n            m_x: self.m_x,\\n            m_y: self.m_y\\n        };\\n    }\\n}\\n```\n```\\nuse std::collections::VecDeque;\\n\\n/***\\n * Main purpose of slope class is to provide easy less than/greater than \\n * comparisons.\\n ***/\\nstruct Slope {\\n    m_y: i32,\\n    m_x: i32,\\n}\\n\\nimpl Slope {\\n    pub fn new(coord_x: i32, coord_y:i32) -> Self {\\n        return Slope {\\n            m_x: coord_x,\\n            m_y: coord_y,\\n        };\\n    }\\n    \\n    pub fn set(&mut self, x: i32, y: i32) -> () {\\n        self.m_x = x;\\n        self.m_y = y;\\n    }\\n    \\n    /***\\n     * Is Slope left < Slope right\\n     * left: yL/xL, right: yR/xR\\n     * yL/xL < yR/xR iff\\n     * yL*xR < yR*xL\\n     ***/\\n    pub fn lt(lhs: &Self, rhs: &Self) -> bool {\\n        if (rhs.m_x < 0) ^ (lhs.m_x < 0) {\\n            return lhs.m_y * rhs.m_x > rhs.m_y * lhs.m_x;\\n        }\\n        \\n        return lhs.m_y * rhs.m_x > rhs.m_y * lhs.m_x\\n    }\\n    \\n    pub fn gt(lhs: &Self, rhs: &Self) -> bool {\\n        if (rhs.m_x < 0) ^ (lhs.m_x < 0) {\\n            return lhs.m_y * rhs.m_x < rhs.m_y * lhs.m_x;\\n        }\\n        \\n        return lhs.m_y * rhs.m_x < rhs.m_y * lhs.m_x;\\n    }\\n}\\n\\nimpl Clone for Slope {\\n    fn clone(&self) -> Self {\\n        return Self {\\n            m_x: self.m_x,\\n            m_y: self.m_y\\n        };\\n    }\\n}\\n\\n\\nimpl Solution {\\n    /***\\n     * Determine the trees that are on the minimum perimeter enclosing all trees.\\n     * Consists of points that we consider to be on the outermost boundary\\n     * Sort the points by x-coordinate first for easy computation, then\\n     * determine the boundary\\n     ***/\\n    pub fn outer_trees(trees: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut vertices: Vec<(i32, i32)> = Vec::new();\\n        for tree in trees {\\n            vertices.push((tree[0], tree[1]));\\n        }\\n        \\n        vertices.sort();\\n        return Solution::enclose_boundary(&vertices);\\n    }\\n    \\n    /***\\n     * 6 Steps to Solution\\n     * 1. Identify bottom and upper leftmost points and push left boundary\\n     * 2. Identify bottom and upper rightmost points and push right boundary\\n     * 3. Filter candidate bottom points\\n     * 4. Filter candidate top points\\n     * 5. Calculate optimal lower boundary\\n     * 6. Calculate optimal upper boundary\\n     ***/\\n    fn enclose_boundary(vertices: &Vec<(i32, i32)>) -> Vec<Vec<i32>> {\\n        let mut res: Vec<Vec<i32>> = Vec::new();\\n        if vertices.is_empty() {\\n            return res;\\n        }\\n        \\n        let N: usize = vertices.len();\\n        // Step 1: insert left part\\n        let highest_left_idx: usize = Solution::push_boundary(\\n            &vertices,\\n            &mut res,\\n            0,\\n            N,\\n            vertices[0].0,\\n            false\\n        );\\n    \\n        if vertices[0].0 == vertices[N - 1].0 { // vertical line, so we\\'re done\\n            return res;\\n        }\\n        \\n        // Step 2: insert right part\\n        let lowest_right_idx: usize = Solution::push_boundary(\\n            &vertices,\\n            &mut res,\\n            highest_left_idx + 1,\\n            N,\\n            vertices[N - 1].0,\\n            true\\n        );\\n        \\n        // Step 3 and 4: insert lower and upper boundaries\\n        let mut bottom_cands: Vec<(i32, i32)> = Vec::with_capacity(N);\\n        let mut top_cands: Vec<(i32, i32)> = Vec::with_capacity(N);\\n        for idx in (highest_left_idx + 1)..lowest_right_idx {\\n            if vertices[idx].0 != vertices[idx - 1].0 { // new lowest entry due to sorting\\n                bottom_cands.push((vertices[idx].0, vertices[idx].1));\\n                top_cands.push((vertices[idx].0, vertices[idx].1)); // keep track of upper\\n            } else { // repeat element - modify current back of upper candidate\\n                top_cands.last_mut().unwrap().1 = vertices[idx].1;\\n            }\\n        }\\n        \\n        // Step 5: Add bottom boundary\\n        let mut elements_below: VecDeque<(Slope, usize)> = Solution::get_slopes(\\n            &bottom_cands,\\n            &vertices[0],\\n            &vertices[lowest_right_idx],\\n            Slope::lt\\n        );\\n        \\n        // add all remaining points\\n        let mut seen_cands: Vec<bool> = vec![false; bottom_cands.len()]; // avoid re-adding points in top boundary that were added in the bottom for the future\\n        while let Some(slope_pair) = elements_below.back() {\\n            let idx = slope_pair.1;\\n            res.push(vec![bottom_cands[idx].0, bottom_cands[idx].1]);\\n            seen_cands[idx] = true;\\n            elements_below.pop_back();\\n        }\\n        \\n        // Step 6: same for above\\n        let mut elements_above: VecDeque<(Slope, usize)> = Solution::get_slopes(\\n            &top_cands,\\n            &vertices[highest_left_idx],\\n            &vertices[N - 1],\\n            Slope::gt\\n        );\\n\\n        // copy over\\n        while let Some(slope_pair) = elements_above.back() {\\n            let idx = slope_pair.1;\\n            if bottom_cands[idx].1 != top_cands[idx].1 || !seen_cands[idx] { // not a duplicate, so add it\\n                res.push(vec![top_cands[idx].0, top_cands[idx].1]);\\n            }\\n            \\n            elements_above.pop_back();\\n        }\\n        \\n        return res;\\n    }\\n    \\n    /***\\n     * Employ a monostack algorithm to get the desired points on the boundary;\\n     * basically, if the points fall above/below some given line between points,\\n     * they should be considered\\n     ***/\\n    fn get_slopes(\\n        cands: &Vec<(i32, i32)>,        // candidates to be used\\n        left_elm: &(i32, i32),          // default left\\n        right_elm: &(i32, i32),         // default right\\n        cmp: fn(&Slope, &Slope) -> bool // connect prev to curr if satisfied \\n    ) -> VecDeque<(Slope, usize)> {\\n        let mut slopes: VecDeque<(Slope, usize)> = VecDeque::new();\\n        for (idx, coord) in cands.iter().enumerate() {\\n            let mut curr_slope = Solution::discard_and_get(&mut slopes, cands, coord, cmp);   \\n            if slopes.is_empty() {\\n                curr_slope.set(coord.1 - left_elm.1, coord.0 - left_elm.0);\\n            }\\n            \\n            slopes.push_back((curr_slope, idx));\\n        }\\n        \\n        Solution::discard_and_get(&mut slopes, cands, right_elm, cmp);        \\n        return slopes;\\n    }\\n    \\n    /***\\n     * Monotonic stack routine. Return the last computed entry, which\\n     * is the slope between the rightmost valid coordinate in the stack\\n     * and the current point.\\n     ***/\\n    fn discard_and_get(\\n        mono: &mut VecDeque<(Slope, usize)>,\\n        cands: &Vec<(i32, i32)>,\\n        curr: &(i32, i32),\\n        cmp: fn(&Slope, &Slope) -> bool\\n    ) -> Slope {\\n        let mut last: Slope = Slope::new(0, 0);\\n        while let Some(slope_and_idx) = mono.back() {\\n            let prev: (i32, i32) = cands[slope_and_idx.1];\\n            last.set(curr.1 - prev.1, curr.0 - prev.0);\\n            if cmp(&last, &slope_and_idx.0) {\\n                mono.pop_back();\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return last;\\n    }\\n    \\n    /***\\n     * Return the index of the last element in the boundary and\\n     * populate the result vector with the boundary\\n     ***/\\n    fn push_boundary(\\n        vertices: &Vec<(i32, i32)>,\\n        res: &mut Vec<Vec<i32>>,\\n        left: usize,  // inclusive left\\n        right: usize, // exclusive right\\n        bound: i32,\\n        should_rev: bool\\n    ) -> usize {\\n        let mut r_last: usize = left; // relative index... needs adjustment\\n        if should_rev {\\n            for (r_idx, coord) in vertices[left..right].iter().rev().enumerate() {\\n                if !Solution::update_bound(coord, r_idx, res, bound, &mut r_last) {\\n                    break;\\n                }\\n            }   \\n            \\n            return right - r_last - 1; // adjust for absolute indexing\\n        }\\n        \\n        for (r_idx, coord) in vertices[left..right].iter().enumerate() {\\n            if !Solution::update_bound(coord, r_idx, res, bound, &mut r_last) {\\n                break;\\n            }\\n        }\\n            \\n        return left + r_last;\\n    }\\n    \\n    fn update_bound(\\n        coord: &(i32, i32), \\n        idx: usize, \\n        res: &mut Vec<Vec<i32>>, \\n        bound: i32, \\n        last: &mut usize\\n    ) -> bool {\\n        if coord.0 != bound {\\n            return false;\\n        }\\n        \\n        res.push(vec![coord.0, coord.1]);\\n        *last = idx;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442561,
                "title": "kotlin-clean-and-simple-o-nlogn-solution",
                "content": "Solution 1:\\n```\\nclass Solution {\\n    \\n    class Trees(val type: Type) {\\n        enum class Type(val value: Int) {\\n            CONVEX(1), CONCAVE(-1)\\n        }\\n\\n        private val _trees = mutableListOf<IntArray>()\\n        val trees: List<IntArray> = _trees\\n\\n        fun add(tree: IntArray) {\\n            val needRemoveLast: () -> Boolean = {\\n                trees.size > 1 && run {\\n                    val prev = trees[trees.lastIndex]\\n                    val prevPrev = trees[trees.lastIndex - 1]\\n                    return@run ((tree[1] - prev[1]) * (prev[0] - prevPrev[0]) -\\n                            (prev[1] - prevPrev[1]) * (tree[0] - prev[0])) * type.value > 0\\n                }\\n            }\\n            while (needRemoveLast()) {\\n                _trees.removeAt(trees.lastIndex)\\n            }\\n            _trees.add(tree)\\n        }\\n    }\\n\\n    fun outerTrees(trees: Array<IntArray>): Array<IntArray> {\\n        trees.sortWith(compareBy({ it[0] }, { it[1] }))\\n        val structuredTrees = trees.groupByTo(TreeMap<Int, MutableList<IntArray>>(), { it[0] }).values\\n\\n        val upperTrees = Trees(Trees.Type.CONVEX)\\n        val lowerTrees = Trees(Trees.Type.CONCAVE)\\n\\n        structuredTrees.forEach {\\n            upperTrees.add(it.last())\\n            lowerTrees.add(it.first())\\n        }\\n\\n        return mutableSetOf<IntArray>().apply {\\n            addAll(structuredTrees.first())\\n            addAll(structuredTrees.last())\\n            addAll(upperTrees.trees)\\n            addAll(lowerTrees.trees)\\n        }.toTypedArray()\\n    }\\n}\\n```\\n\\nSolution 2:\\n```\\nclass Solution {\\n    \\n    class ConvexTrees {\\n        private val _trees = mutableListOf<IntArray>()\\n        val trees: List<IntArray> = _trees\\n\\n        fun add(tree: IntArray) {\\n            val needRemoveLast: () -> Boolean = {\\n                trees.size > 1 && run {\\n                    val prev = trees[trees.lastIndex]\\n                    val prevPrev = trees[trees.lastIndex - 1]\\n                    return@run (tree[1] - prev[1]) * (prev[0] - prevPrev[0]) -\\n                            (prev[1] - prevPrev[1]) * (tree[0] - prev[0]) > 0\\n                }\\n            }\\n            while (needRemoveLast()) {\\n                _trees.removeAt(trees.lastIndex)\\n            }\\n            _trees.add(tree)\\n        }\\n    }\\n\\n    fun outerTrees(trees: Array<IntArray>): Array<IntArray> {\\n        trees.sortWith(compareBy({ it[0] }, { it[1] }))\\n        val structuredTrees = trees.groupBy { it[0] }.values.toTypedArray()\\n\\n        val upper = ConvexTrees()\\n        val lower = ConvexTrees()\\n\\n        for (i in structuredTrees.indices) {\\n            upper.add(structuredTrees[i].last())\\n        }\\n        for (i in structuredTrees.indices.reversed()) {\\n            lower.add(structuredTrees[i].first())\\n        }\\n\\n        return mutableSetOf<IntArray>().apply {\\n            addAll(structuredTrees.first())\\n            addAll(structuredTrees.last())\\n            addAll(upper.trees)\\n            addAll(lower.trees)\\n        }.toTypedArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Trees(val type: Type) {\\n        enum class Type(val value: Int) {\\n            CONVEX(1), CONCAVE(-1)\\n        }\\n\\n        private val _trees = mutableListOf<IntArray>()\\n        val trees: List<IntArray> = _trees\\n\\n        fun add(tree: IntArray) {\\n            val needRemoveLast: () -> Boolean = {\\n                trees.size > 1 && run {\\n                    val prev = trees[trees.lastIndex]\\n                    val prevPrev = trees[trees.lastIndex - 1]\\n                    return@run ((tree[1] - prev[1]) * (prev[0] - prevPrev[0]) -\\n                            (prev[1] - prevPrev[1]) * (tree[0] - prev[0])) * type.value > 0\\n                }\\n            }\\n            while (needRemoveLast()) {\\n                _trees.removeAt(trees.lastIndex)\\n            }\\n            _trees.add(tree)\\n        }\\n    }\\n\\n    fun outerTrees(trees: Array<IntArray>): Array<IntArray> {\\n        trees.sortWith(compareBy({ it[0] }, { it[1] }))\\n        val structuredTrees = trees.groupByTo(TreeMap<Int, MutableList<IntArray>>(), { it[0] }).values\\n\\n        val upperTrees = Trees(Trees.Type.CONVEX)\\n        val lowerTrees = Trees(Trees.Type.CONCAVE)\\n\\n        structuredTrees.forEach {\\n            upperTrees.add(it.last())\\n            lowerTrees.add(it.first())\\n        }\\n\\n        return mutableSetOf<IntArray>().apply {\\n            addAll(structuredTrees.first())\\n            addAll(structuredTrees.last())\\n            addAll(upperTrees.trees)\\n            addAll(lowerTrees.trees)\\n        }.toTypedArray()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    class ConvexTrees {\\n        private val _trees = mutableListOf<IntArray>()\\n        val trees: List<IntArray> = _trees\\n\\n        fun add(tree: IntArray) {\\n            val needRemoveLast: () -> Boolean = {\\n                trees.size > 1 && run {\\n                    val prev = trees[trees.lastIndex]\\n                    val prevPrev = trees[trees.lastIndex - 1]\\n                    return@run (tree[1] - prev[1]) * (prev[0] - prevPrev[0]) -\\n                            (prev[1] - prevPrev[1]) * (tree[0] - prev[0]) > 0\\n                }\\n            }\\n            while (needRemoveLast()) {\\n                _trees.removeAt(trees.lastIndex)\\n            }\\n            _trees.add(tree)\\n        }\\n    }\\n\\n    fun outerTrees(trees: Array<IntArray>): Array<IntArray> {\\n        trees.sortWith(compareBy({ it[0] }, { it[1] }))\\n        val structuredTrees = trees.groupBy { it[0] }.values.toTypedArray()\\n\\n        val upper = ConvexTrees()\\n        val lower = ConvexTrees()\\n\\n        for (i in structuredTrees.indices) {\\n            upper.add(structuredTrees[i].last())\\n        }\\n        for (i in structuredTrees.indices.reversed()) {\\n            lower.add(structuredTrees[i].first())\\n        }\\n\\n        return mutableSetOf<IntArray>().apply {\\n            addAll(structuredTrees.first())\\n            addAll(structuredTrees.last())\\n            addAll(upper.trees)\\n            addAll(lower.trees)\\n        }.toTypedArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442496,
                "title": "c-gift-wrapping",
                "content": "Reference: https://www.cnblogs.com/grandyang/p/7745697.html\\n\\nI learned the solution from the above blog. \\nThe idea is that we start from a corner point, and we use a rope (fixed length, long enough),  and we go as far as we can, since the length is fixed and we start from a corner point, we will go back to the origin point finally.\\n\\n1. The first step is how to find such a corner point, this can be done by choosing the left most point, it must be a corner point.\\n2. The second step is find the next corner point, we will explain this later in detail.\\n3. The third step is checking if we have returned to the original point.\\n\\nNow, we focus on the problem of **finding the next corner point fron one conner point**.\\n![image](https://assets.leetcode.com/users/images/3995a59f-1f1f-4f99-bcc1-8b9421fb6e8a_1630681460.271405.png)\\nNow, suppose we are now in the corner point `A`, we want to find the next corner point `D`, how do we do it: The idea is we start from a random point, say `B`, and select a random point, say `C`, and we compare `B` and `C`, find the **outer** one, where **outer** means `C` will be on the convex hull more likely than `B` in the anti-clockwise direction. If `C` is indeed outer than `B`, then we update `B<-C`, and find a new one, until all points has been visited.\\nNow our problem becomes: How to describe **outer** formally, or codable? The answer is outer product, I will not use mathematical definition here, but the property of outer product is that: if the `crossproduct(AB, AC)>0`, it means the vector `B` is in clockwise direction of `C` respect to `A`(as shown in figure above), otherwise  `B` is in anti-clockwise direction of `C` respect to `A` (for example, `D` and `C` or `C` and `B`).\\nFinally, we need to check the case when three points are colinear, since we need to chose the farthest one.\\n\\n```\\nint crossProduct(const vector<int>& A, \\n                 const vector<int>& B, \\n                 const vector<int>& C){\\n    int BA_x = A[0] - B[0];\\n    int BC_x = C[0] - B[0];\\n    int BA_y = A[1] - B[1];\\n    int BC_y = C[1] - B[1];\\n    return BA_x * BC_y - BA_y * BC_x;\\n}\\n\\nint distance(const vector<int>& A, \\n             const vector<int>& B){\\n    return (A[0] - B[0]) * (A[0] - B[0]) + (A[1] - B[1]) * (A[1] - B[1]);\\n}\\n\\nbool isNotInPointList(const vector<vector<int>>& pointList, \\n                  const vector<int>& point){\\n    for (const auto& point_ : pointList){\\n        if (point_[0] == point[0] && point_[1] == point[1]){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n\\nvector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n    vector<vector<int>> result;\\n    int size = trees.size();\\n    // find the left most point and its index\\n    vector<int> firstPoint(2, 101);\\n    int firstIndex = 0;\\n    for (int i = 0; i < size; ++i){\\n        if (trees[i][0] < firstPoint[0]){\\n            firstPoint = trees[i];\\n            firstIndex = i;\\n        }\\n    }\\n    result.push_back(firstPoint);\\n   \\n    vector<int> currentPoint = firstPoint;\\n    int currentIndex = firstIndex;\\n    while (true){\\n        // find the most outer point \\n        vector<int> nextPoint = trees[0];\\n        int nextIndex = 0;\\n        for (int index = 0; index < size; ++index){\\n            if (index == currentIndex)  continue;\\n            int crossproduct = crossProduct(currentPoint, trees[index], nextPoint);\\n            if (nextIndex == currentIndex || \\n                crossproduct > 0 ||\\n               (crossproduct == 0 && \\n                distance(trees[index], currentPoint) > distance(nextPoint, currentPoint))){\\n                nextPoint = trees[index];\\n                nextIndex = index;\\n            }\\n        }\\n        // sanity check\\n        for (int index = 0; index < size; ++index){\\n            if (index == currentIndex)  continue;\\n            int crossproduct = crossProduct(currentPoint, trees[index], nextPoint);\\n            if (crossproduct == 0 && isNotInPointList(result, trees[index]))\\n                result.push_back(trees[index]);\\n        }\\n        currentPoint = nextPoint;\\n        currentIndex = nextIndex;\\n        if (currentIndex == firstIndex)\\n            break;\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint crossProduct(const vector<int>& A, \\n                 const vector<int>& B, \\n                 const vector<int>& C){\\n    int BA_x = A[0] - B[0];\\n    int BC_x = C[0] - B[0];\\n    int BA_y = A[1] - B[1];\\n    int BC_y = C[1] - B[1];\\n    return BA_x * BC_y - BA_y * BC_x;\\n}\\n\\nint distance(const vector<int>& A, \\n             const vector<int>& B){\\n    return (A[0] - B[0]) * (A[0] - B[0]) + (A[1] - B[1]) * (A[1] - B[1]);\\n}\\n\\nbool isNotInPointList(const vector<vector<int>>& pointList, \\n                  const vector<int>& point){\\n    for (const auto& point_ : pointList){\\n        if (point_[0] == point[0] && point_[1] == point[1]){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n\\nvector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n    vector<vector<int>> result;\\n    int size = trees.size();\\n    // find the left most point and its index\\n    vector<int> firstPoint(2, 101);\\n    int firstIndex = 0;\\n    for (int i = 0; i < size; ++i){\\n        if (trees[i][0] < firstPoint[0]){\\n            firstPoint = trees[i];\\n            firstIndex = i;\\n        }\\n    }\\n    result.push_back(firstPoint);\\n   \\n    vector<int> currentPoint = firstPoint;\\n    int currentIndex = firstIndex;\\n    while (true){\\n        // find the most outer point \\n        vector<int> nextPoint = trees[0];\\n        int nextIndex = 0;\\n        for (int index = 0; index < size; ++index){\\n            if (index == currentIndex)  continue;\\n            int crossproduct = crossProduct(currentPoint, trees[index], nextPoint);\\n            if (nextIndex == currentIndex || \\n                crossproduct > 0 ||\\n               (crossproduct == 0 && \\n                distance(trees[index], currentPoint) > distance(nextPoint, currentPoint))){\\n                nextPoint = trees[index];\\n                nextIndex = index;\\n            }\\n        }\\n        // sanity check\\n        for (int index = 0; index < size; ++index){\\n            if (index == currentIndex)  continue;\\n            int crossproduct = crossProduct(currentPoint, trees[index], nextPoint);\\n            if (crossproduct == 0 && isNotInPointList(result, trees[index]))\\n                result.push_back(trees[index]);\\n        }\\n        currentPoint = nextPoint;\\n        currentIndex = nextIndex;\\n        if (currentIndex == firstIndex)\\n            break;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354222,
                "title": "c-solution-graham-scan-90-beat",
                "content": "```\\nint start_x_new=0;\\nint start_y_new=0;\\nvoid calling(int a,int b)\\n{\\n    start_x_new=a;\\n    start_y_new=b;\\n}\\nclass Solution {\\n    int check_determinant(pair<int,int>p , pair<int,int>v , pair<int,int>c)\\n    {\\n        int x1=v.first-p.first;\\n        int y1= v.second - p.second;\\n        int x2 = c.first-v.first;\\n        int y2 = c.second - v.second;\\n        return y2*x1 - y1*x2 ; \\n    }\\n    static bool again(const vector<int>&a , const vector<int>&b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    static bool compare(const vector<int>&a ,const vector<int>&b)\\n    {\\n        double y1 = (a[1]-start_y_new);\\n        double x1 = (a[0]-start_x_new);\\n        double angle1 = atan(y1/x1) * (180.00/M_PI);\\n        if(angle1<0.00)\\n        {\\n            angle1=90.000 + abs(angle1);\\n        }\\n        double y2 = (b[1]-start_y_new);\\n        double x2 = (b[0]-start_x_new);\\n        double angle2 = atan(y2/x2) * (180.00/M_PI);\\n        if(angle2<0.00)\\n        {\\n            angle2=90.000 + abs(angle2);\\n        }\\n        if(angle1==angle2)\\n        {\\n            if(a[0]!=b[0])\\n            {\\n                return a[0]<b[0];\\n            }\\n            else\\n            {\\n                return a[1]>b[1];\\n            }\\n        }\\n        if(angle1>90.000 && angle2>90.000)\\n        {\\n            return angle1 > angle2;\\n        }\\n        return angle1 < angle2;\\n    }\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        if(trees.size()==1)\\n        {\\n            return trees;\\n        }\\n        //find the lowest point which has lowest y\\n        int start_x=0 , start_y=0;\\n        int mini_y = INT_MAX;\\n        int index=0;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            if(trees[i][1]<mini_y)\\n            {\\n                start_x=trees[i][0];\\n                start_y=trees[i][1];\\n                mini_y=trees[i][1];\\n                index=i;\\n            }\\n        }\\n        calling(start_x,start_y);\\n        trees.erase(trees.begin()+index);\\n        //sort the points by angle\\n        sort(trees.begin(),trees.end(),compare);\\n        int u=0;\\n        while(u<trees.size() && trees[u][0]==start_x_new)\\n        {\\n            u++;\\n        }\\n        sort(trees.begin(),trees.begin()+u,again);\\n        stack<pair<int,int>>st;\\n        st.push({start_x_new,start_y_new});\\n        pair<int,int>p = st.top();\\n        st.push({trees[0][0],trees[0][1]});\\n        pair<int,int>v=st.top();\\n        int i=1;\\n        while(i<trees.size() && !st.empty())\\n        {\\n            pair<int,int>c={trees[i][0],trees[i][1]};\\n            if(check_determinant(p,v,c)>=0)\\n            {\\n                st.push(c);\\n                p=v;\\n                v=c;\\n                i++;\\n            }\\n            else\\n            {\\n                st.pop();\\n                v=st.top();\\n                st.pop();\\n                p=st.top();\\n                st.push(v);\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        while(!st.empty())\\n        {\\n            vector<int>y;\\n            y.push_back(st.top().first);\\n            y.push_back(st.top().second);\\n            st.pop();\\n            ans.push_back(y);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint start_x_new=0;\\nint start_y_new=0;\\nvoid calling(int a,int b)\\n{\\n    start_x_new=a;\\n    start_y_new=b;\\n}\\nclass Solution {\\n    int check_determinant(pair<int,int>p , pair<int,int>v , pair<int,int>c)\\n    {\\n        int x1=v.first-p.first;\\n        int y1= v.second - p.second;\\n        int x2 = c.first-v.first;\\n        int y2 = c.second - v.second;\\n        return y2*x1 - y1*x2 ; \\n    }\\n    static bool again(const vector<int>&a , const vector<int>&b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    static bool compare(const vector<int>&a ,const vector<int>&b)\\n    {\\n        double y1 = (a[1]-start_y_new);\\n        double x1 = (a[0]-start_x_new);\\n        double angle1 = atan(y1/x1) * (180.00/M_PI);\\n        if(angle1<0.00)\\n        {\\n            angle1=90.000 + abs(angle1);\\n        }\\n        double y2 = (b[1]-start_y_new);\\n        double x2 = (b[0]-start_x_new);\\n        double angle2 = atan(y2/x2) * (180.00/M_PI);\\n        if(angle2<0.00)\\n        {\\n            angle2=90.000 + abs(angle2);\\n        }\\n        if(angle1==angle2)\\n        {\\n            if(a[0]!=b[0])\\n            {\\n                return a[0]<b[0];\\n            }\\n            else\\n            {\\n                return a[1]>b[1];\\n            }\\n        }\\n        if(angle1>90.000 && angle2>90.000)\\n        {\\n            return angle1 > angle2;\\n        }\\n        return angle1 < angle2;\\n    }\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        if(trees.size()==1)\\n        {\\n            return trees;\\n        }\\n        //find the lowest point which has lowest y\\n        int start_x=0 , start_y=0;\\n        int mini_y = INT_MAX;\\n        int index=0;\\n        for(int i=0;i<trees.size();i++)\\n        {\\n            if(trees[i][1]<mini_y)\\n            {\\n                start_x=trees[i][0];\\n                start_y=trees[i][1];\\n                mini_y=trees[i][1];\\n                index=i;\\n            }\\n        }\\n        calling(start_x,start_y);\\n        trees.erase(trees.begin()+index);\\n        //sort the points by angle\\n        sort(trees.begin(),trees.end(),compare);\\n        int u=0;\\n        while(u<trees.size() && trees[u][0]==start_x_new)\\n        {\\n            u++;\\n        }\\n        sort(trees.begin(),trees.begin()+u,again);\\n        stack<pair<int,int>>st;\\n        st.push({start_x_new,start_y_new});\\n        pair<int,int>p = st.top();\\n        st.push({trees[0][0],trees[0][1]});\\n        pair<int,int>v=st.top();\\n        int i=1;\\n        while(i<trees.size() && !st.empty())\\n        {\\n            pair<int,int>c={trees[i][0],trees[i][1]};\\n            if(check_determinant(p,v,c)>=0)\\n            {\\n                st.push(c);\\n                p=v;\\n                v=c;\\n                i++;\\n            }\\n            else\\n            {\\n                st.pop();\\n                v=st.top();\\n                st.pop();\\n                p=st.top();\\n                st.push(v);\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        while(!st.empty())\\n        {\\n            vector<int>y;\\n            y.push_back(st.top().first);\\n            y.push_back(st.top().second);\\n            st.pop();\\n            ans.push_back(y);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301199,
                "title": "gift-wrapping-algo-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef complex<int>C;\\n    struct point{\\n        int x;\\n        int y;\\n    };\\n    set<pair<int,int>>s,coll;\\n    \\n    int cross(point a,point b,point c){\\n        int x1=a.x-b.x;\\n        int y1=a.y-b.y;\\n        int x2=a.x-c.x;\\n        int y2=a.y-c.y;\\n        int val=x1*y2-x2*y1;\\n        return val;\\n    }\\n    \\n    bool dis(point a,point b,point c){\\n        C x1={a.x,a.y};\\n        C x2={b.x,b.y};\\n        C x3={c.x,c.y};\\n        return (abs(x2-x1)>abs(x3-x1));\\n    }\\n    \\n    void compute(point p[],int n){\\n        point start=p[0];\\n        for(int i=0;i<n;i++){\\n            if(p[i].x<start.x)start=p[i];\\n        }\\n        s.insert({start.x,start.y});\\n        point curr=start;\\n        while(true){\\n            point next=p[0];\\n            for(int i=1;i<n;i++){\\n                if(curr.x==p[i].x and curr.y==p[i].y)continue;\\n                int val=cross(curr,next,p[i]);\\n                if(val>0){\\n                    next=p[i];\\n                    coll.clear();\\n                }\\n                else if(val==0){\\n                    if(dis(curr,next,p[i])){\\n                        coll.insert({p[i].x,p[i].y});\\n                    }\\n                    else{\\n                        coll.insert({next.x,next.y});\\n                        next=p[i];\\n                    }\\n                }\\n            }\\n            for(auto it:coll) s.insert(it);\\n            if(next.x==start.x and next.y==start.y) break;\\n            s.insert({next.x,next.y});\\n            curr=next;\\n        }\\n    }\\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n     int n=trees.size();\\n     point p[n];\\n     for(int i=0;i<n;i++)   {\\n         int m=trees[i][0];\\n         int k=trees[i][1];\\n         p[i]={m,k};\\n     }\\n        compute(p,n);\\n        vector<vector<int>>res;\\n        for(auto it:s){\\n            vector<int>temp={it.first,it.second};\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef complex<int>C;\\n    struct point{\\n        int x;\\n        int y;\\n    };\\n    set<pair<int,int>>s,coll;\\n    \\n    int cross(point a,point b,point c){\\n        int x1=a.x-b.x;\\n        int y1=a.y-b.y;\\n        int x2=a.x-c.x;\\n        int y2=a.y-c.y;\\n        int val=x1*y2-x2*y1;\\n        return val;\\n    }\\n    \\n    bool dis(point a,point b,point c){\\n        C x1={a.x,a.y};\\n        C x2={b.x,b.y};\\n        C x3={c.x,c.y};\\n        return (abs(x2-x1)>abs(x3-x1));\\n    }\\n    \\n    void compute(point p[],int n){\\n        point start=p[0];\\n        for(int i=0;i<n;i++){\\n            if(p[i].x<start.x)start=p[i];\\n        }\\n        s.insert({start.x,start.y});\\n        point curr=start;\\n        while(true){\\n            point next=p[0];\\n            for(int i=1;i<n;i++){\\n                if(curr.x==p[i].x and curr.y==p[i].y)continue;\\n                int val=cross(curr,next,p[i]);\\n                if(val>0){\\n                    next=p[i];\\n                    coll.clear();\\n                }\\n                else if(val==0){\\n                    if(dis(curr,next,p[i])){\\n                        coll.insert({p[i].x,p[i].y});\\n                    }\\n                    else{\\n                        coll.insert({next.x,next.y});\\n                        next=p[i];\\n                    }\\n                }\\n            }\\n            for(auto it:coll) s.insert(it);\\n            if(next.x==start.x and next.y==start.y) break;\\n            s.insert({next.x,next.y});\\n            curr=next;\\n        }\\n    }\\n    \\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n     int n=trees.size();\\n     point p[n];\\n     for(int i=0;i<n;i++)   {\\n         int m=trees[i][0];\\n         int k=trees[i][1];\\n         p[i]={m,k};\\n     }\\n        compute(p,n);\\n        vector<vector<int>>res;\\n        for(auto it:s){\\n            vector<int>temp={it.first,it.second};\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278884,
                "title": "c-solution-using-convex-hull-faster-than-99",
                "content": "```\\nclass Solution {\\npublic:\\n\\n\\n\\nclass Point\\n{\\npublic:\\n        int x;\\n        int y;\\n\\n        bool operator < (Point(&P))\\n        {\\n                if (P.x == x)\\n                        return y < P.y;\\n                else\\n                        return x < P.x;\\n        }\\n\\n        bool operator == (Point(&P))\\n        {\\n                return (x == P.x and y == P.y);\\n        }\\n\\n};\\n\\nbool cw(Point a, Point b, Point c)\\n{\\n        return (((b.y - a.y) * (c.x - b.x)) - ((c.y - b.y) * (b.x - a.x))) > 0;\\n}\\nbool acw(Point a, Point b, Point c)\\n{\\n        return (((b.y - a.y) * (c.x - b.x)) - ((c.y - b.y) * (b.x - a.x))) < 0;\\n}\\nbool col(Point a, Point b, Point c)\\n{\\n        return (((b.y - a.y) * (c.x - b.x)) - ((c.y - b.y) * (b.x - a.x))) == 0;\\n}\\n\\n\\n\\nvoid convex_hull(vector<Point> &p)\\n{\\n        if (p.size() <= 2) return;\\n\\n        int n = p.size();\\n\\n        sort(p.begin(), p.end());\\n\\n        Point p1 = p[0], p2 = p[n - 1];\\n\\n        vector <Point> up, down;\\n        up.push_back(p1);\\n        down.push_back(p1);\\n\\n        for (int i = 1; i < n; i++)\\n        {\\n                /// upper half\\n                if (i == n - 1 or (!acw(p1, p[i], p2)))\\n                {\\n                        while (up.size() >= 2 and (acw(up[up.size() - 2], up[up.size() - 1], p[i])))\\n                        {\\n                                up.pop_back();\\n                        }\\n                        up.push_back(p[i]);\\n                }\\n\\n                /// lower half\\n                if (i == n - 1 or (!cw(p1, p[i], p2)))\\n                {\\n                        while (down.size() >= 2 and (cw(down[down.size() - 2], down[down.size() - 1], p[i])))\\n                        {\\n                                down.pop_back();\\n                        }\\n                        down.push_back(p[i]);\\n                }\\n        }\\n\\n        p.clear();\\n        for (int i = 0; i < up.size(); i++)\\n                p.push_back(up[i]);\\n        for (int i = 0; i < down.size(); i++)\\n                p.push_back(down[i]);\\n\\n        //  deb(p.size())\\n        // deb2(up.size(),down.size())\\n        sort(p.begin(), p.end());\\n\\n        p.resize(unique(p.begin(), p.end()) - p.begin());\\n\\n}\\n\\n\\n\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n       \\n     vector<Point> p;\\n     for(int i=0;i<trees.size();i++)\\n     {\\n        Point temp;\\n        temp.x = trees[i][0];\\n        temp.y = trees[i][1];\\n        p.push_back(temp);\\n     }\\n\\n     convex_hull(p);\\n\\n     vector<vector<int> > ans;\\n     for(int i=0;i<p.size();i++)\\n     {\\n        ans.push_back({p[i].x, p[i].y});\\n     }\\n\\n     return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n\\nclass Point\\n{\\npublic:\\n        int x;\\n        int y;\\n\\n        bool operator < (Point(&P))\\n        {\\n                if (P.x == x)\\n                        return y < P.y;\\n                else\\n                        return x < P.x;\\n        }\\n\\n        bool operator == (Point(&P))\\n        {\\n                return (x == P.x and y == P.y);\\n        }\\n\\n};\\n\\nbool cw(Point a, Point b, Point c)\\n{\\n        return (((b.y - a.y) * (c.x - b.x)) - ((c.y - b.y) * (b.x - a.x))) > 0;\\n}\\nbool acw(Point a, Point b, Point c)\\n{\\n        return (((b.y - a.y) * (c.x - b.x)) - ((c.y - b.y) * (b.x - a.x))) < 0;\\n}\\nbool col(Point a, Point b, Point c)\\n{\\n        return (((b.y - a.y) * (c.x - b.x)) - ((c.y - b.y) * (b.x - a.x))) == 0;\\n}\\n\\n\\n\\nvoid convex_hull(vector<Point> &p)\\n{\\n        if (p.size() <= 2) return;\\n\\n        int n = p.size();\\n\\n        sort(p.begin(), p.end());\\n\\n        Point p1 = p[0], p2 = p[n - 1];\\n\\n        vector <Point> up, down;\\n        up.push_back(p1);\\n        down.push_back(p1);\\n\\n        for (int i = 1; i < n; i++)\\n        {\\n                /// upper half\\n                if (i == n - 1 or (!acw(p1, p[i], p2)))\\n                {\\n                        while (up.size() >= 2 and (acw(up[up.size() - 2], up[up.size() - 1], p[i])))\\n                        {\\n                                up.pop_back();\\n                        }\\n                        up.push_back(p[i]);\\n                }\\n\\n                /// lower half\\n                if (i == n - 1 or (!cw(p1, p[i], p2)))\\n                {\\n                        while (down.size() >= 2 and (cw(down[down.size() - 2], down[down.size() - 1], p[i])))\\n                        {\\n                                down.pop_back();\\n                        }\\n                        down.push_back(p[i]);\\n                }\\n        }\\n\\n        p.clear();\\n        for (int i = 0; i < up.size(); i++)\\n                p.push_back(up[i]);\\n        for (int i = 0; i < down.size(); i++)\\n                p.push_back(down[i]);\\n\\n        //  deb(p.size())\\n        // deb2(up.size(),down.size())\\n        sort(p.begin(), p.end());\\n\\n        p.resize(unique(p.begin(), p.end()) - p.begin());\\n\\n}\\n\\n\\n\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n       \\n     vector<Point> p;\\n     for(int i=0;i<trees.size();i++)\\n     {\\n        Point temp;\\n        temp.x = trees[i][0];\\n        temp.y = trees[i][1];\\n        p.push_back(temp);\\n     }\\n\\n     convex_hull(p);\\n\\n     vector<vector<int> > ans;\\n     for(int i=0;i<p.size();i++)\\n     {\\n        ans.push_back({p[i].x, p[i].y});\\n     }\\n\\n     return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825790,
                "title": "jarvis-step-by-step-modular",
                "content": "Credits : [Tushar roy\\'s jarvis march video](https://bit.ly/3jCGFCj)\\n\\nJarvis march is a rotational sweep convex-hull algorithm. \\nIt starts with leftmost point and keeps on selecting the outermost points.\\nSpecial handling is needed for collinear points.\\n\\n**Left most point**\\n```\\n    private fun leftMost(points: Array<IntArray>): IntArray {\\n        var left = points[0]\\n        points.forEach { point ->\\n            if (point[0] < left[0]) left = point\\n        }\\n        return left\\n    }\\n```\\n**Cross product**\\nIf positive, c is on the left of line segment ab otherwise on the right\\n```\\n    private fun crossProduct(a: IntArray, b: IntArray, c: IntArray): Int {\\n        val (x1, y1) = a[0] - b[0] to a[1] - b[1]\\n        val (x2, y2) = a[0] - c[0] to a[1] - c[1]\\n        return x1 * y2 - x2 * y1\\n    }\\n```\\n\\n**Is on Left**\\nInput param is the cross product\\n```\\n    private fun isOnLeft(product: Int): Boolean {\\n        return product > 0\\n    }\\n```\\n\\n**Is collinear**\\nInput param is the cross product\\n```\\n    private fun isCollinear(product: Int): Boolean {\\n\\t\\treturn product == 0\\n\\t}\\n```\\n\\n**Distance of collinear points**\\nIf this returns negative value, c is farthest\\n```\\n    private fun distance(a: IntArray, b: IntArray, c: IntArray): Int {\\n        val (x1, y1) = a[0] - b[0] to a[1] - b[1]\\n        val (x2, y2) = a[0] - c[0] to a[1] - c[1]\\n        val p = x1 * x1\\n        val q = y1 * y1\\n        val r = x2 * x2\\n        val s = y2 * y2\\n        return (p + q).compareTo(r + s)\\n    }\\n```\\n\\n<details><summary>CLICK ME for full code</summary>\\n<p>\\n\\n```kotlin\\nfun outerTrees(points: Array<IntArray>): Array<IntArray> {\\n        val start = leftMost(points)\\n        val result = mutableSetOf<IntArray>()\\n        val collinear = mutableListOf<IntArray>()\\n        result.add(start)\\n        var current = start\\n        while (true) {\\n            var nextTarget = points[0]\\n            for (i in 1..points.lastIndex) {\\n                val third = points[i]\\n                if (third == current) continue\\n                val product = crossProduct(current, nextTarget, third)\\n                if (isOnLeft(product)) {\\n                    nextTarget = third   \\n                    collinear.clear()\\n                } else if (isCollinear(product)) {\\n                    if (distance(current, nextTarget, third) < 0) {\\n                        collinear.add(nextTarget)\\n                        nextTarget = third\\n                    } else {\\n                        collinear.add(third)\\n                    }\\n                }\\n            }\\n            result.addAll(collinear)\\n            if (nextTarget == start) break\\n            result.add(nextTarget)\\n            current = nextTarget\\n        }\\n        return result.toTypedArray()\\n    }\\n    \\n    private fun distance(a: IntArray, b: IntArray, c: IntArray): Int {\\n        val (x1, y1) = a[0] - b[0] to a[1] - b[1]\\n        val (x2, y2) = a[0] - c[0] to a[1] - c[1]\\n        val p = x1 * x1\\n        val q = y1 * y1\\n        val r = x2 * x2\\n        val s = y2 * y2\\n        return (p + q).compareTo(r + s)\\n    }\\n    \\n    private fun leftMost(points: Array<IntArray>): IntArray {\\n        var left = points[0]\\n        points.forEach { point ->\\n            if (point[0] < left[0]) left = point\\n        }\\n        return left\\n    }\\n    \\n    private fun crossProduct(a: IntArray, b: IntArray, c: IntArray): Int {\\n        val (x1, y1) = a[0] - b[0] to a[1] - b[1]\\n        val (x2, y2) = a[0] - c[0] to a[1] - c[1]\\n        return x1 * y2 - x2 * y1\\n    }\\n    \\n    private fun isOnLeft(product: Int): Boolean {\\n        return product > 0\\n    }\\n    \\n    private fun isCollinear(product: Int): Boolean {\\n        return product == 0\\n    }\\n```\\n\\n</p>\\n</details>\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    private fun leftMost(points: Array<IntArray>): IntArray {\\n        var left = points[0]\\n        points.forEach { point ->\\n            if (point[0] < left[0]) left = point\\n        }\\n        return left\\n    }\\n```\n```\\n    private fun crossProduct(a: IntArray, b: IntArray, c: IntArray): Int {\\n        val (x1, y1) = a[0] - b[0] to a[1] - b[1]\\n        val (x2, y2) = a[0] - c[0] to a[1] - c[1]\\n        return x1 * y2 - x2 * y1\\n    }\\n```\n```\\n    private fun isOnLeft(product: Int): Boolean {\\n        return product > 0\\n    }\\n```\n```\\n    private fun isCollinear(product: Int): Boolean {\\n\\t\\treturn product == 0\\n\\t}\\n```\n```\\n    private fun distance(a: IntArray, b: IntArray, c: IntArray): Int {\\n        val (x1, y1) = a[0] - b[0] to a[1] - b[1]\\n        val (x2, y2) = a[0] - c[0] to a[1] - c[1]\\n        val p = x1 * x1\\n        val q = y1 * y1\\n        val r = x2 * x2\\n        val s = y2 * y2\\n        return (p + q).compareTo(r + s)\\n    }\\n```\n```kotlin\\nfun outerTrees(points: Array<IntArray>): Array<IntArray> {\\n        val start = leftMost(points)\\n        val result = mutableSetOf<IntArray>()\\n        val collinear = mutableListOf<IntArray>()\\n        result.add(start)\\n        var current = start\\n        while (true) {\\n            var nextTarget = points[0]\\n            for (i in 1..points.lastIndex) {\\n                val third = points[i]\\n                if (third == current) continue\\n                val product = crossProduct(current, nextTarget, third)\\n                if (isOnLeft(product)) {\\n                    nextTarget = third   \\n                    collinear.clear()\\n                } else if (isCollinear(product)) {\\n                    if (distance(current, nextTarget, third) < 0) {\\n                        collinear.add(nextTarget)\\n                        nextTarget = third\\n                    } else {\\n                        collinear.add(third)\\n                    }\\n                }\\n            }\\n            result.addAll(collinear)\\n            if (nextTarget == start) break\\n            result.add(nextTarget)\\n            current = nextTarget\\n        }\\n        return result.toTypedArray()\\n    }\\n    \\n    private fun distance(a: IntArray, b: IntArray, c: IntArray): Int {\\n        val (x1, y1) = a[0] - b[0] to a[1] - b[1]\\n        val (x2, y2) = a[0] - c[0] to a[1] - c[1]\\n        val p = x1 * x1\\n        val q = y1 * y1\\n        val r = x2 * x2\\n        val s = y2 * y2\\n        return (p + q).compareTo(r + s)\\n    }\\n    \\n    private fun leftMost(points: Array<IntArray>): IntArray {\\n        var left = points[0]\\n        points.forEach { point ->\\n            if (point[0] < left[0]) left = point\\n        }\\n        return left\\n    }\\n    \\n    private fun crossProduct(a: IntArray, b: IntArray, c: IntArray): Int {\\n        val (x1, y1) = a[0] - b[0] to a[1] - b[1]\\n        val (x2, y2) = a[0] - c[0] to a[1] - c[1]\\n        return x1 * y2 - x2 * y1\\n    }\\n    \\n    private fun isOnLeft(product: Int): Boolean {\\n        return product > 0\\n    }\\n    \\n    private fun isCollinear(product: Int): Boolean {\\n        return product == 0\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 641691,
                "title": "convex-hull-implementation-with-some-explanation",
                "content": "Solution is divided into two parts upper hull and lower hull about the line joining bottom left and upper right point\\n```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    struct point {\\n        int x, y;\\n        bool operator < (point &O) {\\n            if (O.x == x) return y < O.y;\\n            else return x < O.x;\\n        }\\n        bool operator == (point &O) {\\n            return (x == O.x && y == O.y);\\n        }\\n    };\\n\\n    bool cw(point a, point b, point c) {\\n        return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) > 0;\\n    }\\n\\n    bool ccw(point a, point b, point c) {\\n        return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) < 0;\\n    }\\n\\n    bool collinear(point a, point b, point c) {\\n        return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) == 0;\\n    }\\n\\n    void convex_hull(vector<point> &p) {\\n        if (p.size() <= 2) return;\\n\\n        sort(p.begin(), p.end());\\n        // now p[0] is p1, p[n-1] is p2\\n        int i, n = p.size();\\n        point p1 = p[0], p2 = p[n - 1];\\n        // actually p1 is bottom left point and p2 is top right point\\n        vector<point> up, down;\\n        up.pb(p1);\\n        down.pb(p1);\\n\\n        for (i = 1; i < n; i++) {\\n            // now i have to check whether my current point is in lower half\\n            // or upper half\\n            if (i == n - 1 || !ccw(p1, p[i], p2)) {\\n                // p[i] is in the upper half\\n                while (up.size() >= 2 && ccw(up[up.size() - 2], up[up.size() - 1], p[i])) {\\n                    up.pop_back();\\n                }\\n                up.pb(p[i]);\\n            }\\n            if (i == n - 1 || !cw(p1, p[i], p2)) {\\n                // p[i] is in the lower half\\n                while (down.size() >= 2 && cw(down[down.size() - 2], down[down.size() - 1],                         p[i])) {\\n                    down.pop_back();\\n                }\\n                down.pb(p[i]);\\n            }\\n        }\\n        // up and down vector contains all points including the points p1 and p2 repeatedly\\n        p.clear();\\n        for (i = 0; i < up.size(); i++) {\\n            p.pb(up[i]);\\n        }\\n        for (i = 0; i < down.size(); i++) {\\n            p.pb(down[i]);\\n        }\\n        // p vector contais all the pints from up as well as down\\n        sort(p.begin(), p.end());\\n        p.resize(unique(p.begin(), p.end()) - p.begin());\\n    }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& points) {\\n        vector<point> p;\\n        for(int i=0;i<points.size();i++){\\n            point temp ;\\n            temp.x = points[i][0];\\n            temp.y = points[i][1];\\n            p.pb(temp);\\n        }\\n        convex_hull(p);\\n        vector<vector<int> > ans;\\n        for(auto val : p){\\n            ans.pb({val.x,val.y});\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    struct point {\\n        int x, y;\\n        bool operator < (point &O) {\\n            if (O.x == x) return y < O.y;\\n            else return x < O.x;\\n        }\\n        bool operator == (point &O) {\\n            return (x == O.x && y == O.y);\\n        }\\n    };\\n\\n    bool cw(point a, point b, point c) {\\n        return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) > 0;\\n    }\\n\\n    bool ccw(point a, point b, point c) {\\n        return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) < 0;\\n    }\\n\\n    bool collinear(point a, point b, point c) {\\n        return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) == 0;\\n    }\\n\\n    void convex_hull(vector<point> &p) {\\n        if (p.size() <= 2) return;\\n\\n        sort(p.begin(), p.end());\\n        // now p[0] is p1, p[n-1] is p2\\n        int i, n = p.size();\\n        point p1 = p[0], p2 = p[n - 1];\\n        // actually p1 is bottom left point and p2 is top right point\\n        vector<point> up, down;\\n        up.pb(p1);\\n        down.pb(p1);\\n\\n        for (i = 1; i < n; i++) {\\n            // now i have to check whether my current point is in lower half\\n            // or upper half\\n            if (i == n - 1 || !ccw(p1, p[i], p2)) {\\n                // p[i] is in the upper half\\n                while (up.size() >= 2 && ccw(up[up.size() - 2], up[up.size() - 1], p[i])) {\\n                    up.pop_back();\\n                }\\n                up.pb(p[i]);\\n            }\\n            if (i == n - 1 || !cw(p1, p[i], p2)) {\\n                // p[i] is in the lower half\\n                while (down.size() >= 2 && cw(down[down.size() - 2], down[down.size() - 1],                         p[i])) {\\n                    down.pop_back();\\n                }\\n                down.pb(p[i]);\\n            }\\n        }\\n        // up and down vector contains all points including the points p1 and p2 repeatedly\\n        p.clear();\\n        for (i = 0; i < up.size(); i++) {\\n            p.pb(up[i]);\\n        }\\n        for (i = 0; i < down.size(); i++) {\\n            p.pb(down[i]);\\n        }\\n        // p vector contais all the pints from up as well as down\\n        sort(p.begin(), p.end());\\n        p.resize(unique(p.begin(), p.end()) - p.begin());\\n    }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& points) {\\n        vector<point> p;\\n        for(int i=0;i<points.size();i++){\\n            point temp ;\\n            temp.x = points[i][0];\\n            temp.y = points[i][1];\\n            p.pb(temp);\\n        }\\n        convex_hull(p);\\n        vector<vector<int> > ans;\\n        for(auto val : p){\\n            ans.pb({val.x,val.y});\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626520,
                "title": "c-convex-hull-implementation",
                "content": "```\\nbool cmp(vector<int> &a, vector<int> &b) {\\n    if (a[0] == b[0])\\n        return a[1] < b[1];\\n    return a[0] < b[0];\\n}\\n\\n// lt stands for Left turn and rt stands for a Right turn\\n// Used vectors of size 2 to store the points (x,y)\\n// left turn means the middle point of three sorted points is below the line joining 1st and 3rd point(draw urself to get better picture) \\n// Viceversa goes for right turn\\n\\nstruct Hull {\\n    bool lt(vector<int> &a, vector<int> &b, vector<int> &c) {\\n        return (a[0] * (b[1] - c[1])) + (b[0] * (c[1] - a[1])) + (c[0] * (a[1] - b[1])) > 0;\\n    }\\n\\n    bool rt(vector<int> &a, vector<int> &b, vector<int> &c) {\\n        return (a[0] * (b[1] - c[1])) + (b[0] * (c[1] - a[1])) + (c[0] * (a[1] - b[1])) < 0;\\n    }\\n\\n    void convexHull(vector<vector<int>> &points) {\\n        deque<vector<int>> up, down;\\n        vector<int> &st = points[0], &en = points.back();\\n        up.push_back(st), down.push_back(st);\\n\\n        for (int i = 1; i < points.size(); i++) {\\n            vector<int> &p = points[i];\\n            if (!lt(st, p, en)) {\\n                while (up.size() > 1 and lt(up[up.size() - 2], up.back(), p))\\n                    up.pop_back();\\n                up.push_back(p);\\n            }\\n            if (!rt(st, p, en)) {\\n                while (down.size() > 1 and rt(down[down.size() - 2], down.back(), p))\\n                    down.pop_back();\\n                down.push_back(p);\\n            }\\n        }\\n\\n        points.clear();\\n        for (vector<int> &p : up)\\n            points.push_back(p);\\n        for (vector<int> &p : down)\\n            points.push_back(p);\\n\\n        sort(points.begin(), points.end(), cmp);\\n        points.resize(unique(points.begin(), points.end()) - points.begin());\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>> &points) {\\n        sort(points.begin(), points.end(), cmp);\\n        Hull h;\\n        h.convexHull(points);\\n        return points;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>> &points) {\\n        sort(points.begin(), points.end(), cmp);\\n        Hull h;\\n        h.convexHull(points);\\n        return points;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 503122,
                "title": "jarvis-plus-taking-care-of-colinear",
                "content": "given a partial computed convex hull, (assumed as valid)\\nwhat is the next point?\\n1. let a be the last point selected\\n2. there is one argmax b to the angle a,b (imagine positionning a as the origin of the trigonometric circle and putting b on the circle)\\n3. compute all colinear points to the vector ab sorted by distance \\n\\npain in the bu***** maximized for sure!\\n\\n```\\nclass Solution(object):\\n    def outerTrees(self, points):\\n        if len(points) <= 3: return points\\n        stack = [min(points)]\\n        while(len(stack) == 1 or stack[-1] != stack[0]):\\n            a = stack[-1]\\n            # this point is garantted 100 % as belonging to the convex hull precomputed up till now\\n            # a plausible candidate is cand thats NULL for now\\n            cand = None \\n            for b in points:\\n                if b!= a and (cand is None or self.left(a,cand,b)): \\n                    # choose it iff \\n                    # (o,cand), (o,b) is a left turn\\n                    cand = b\\n            \\n            # grab the points that are colinear to the vector (o,cand)\\n            # sorted from the closest to a \\n            # to the furthest\\n            for v in sorted([(self.distance(a,bb),bb) for bb in points if self.f(a,cand,bb) == 0 and bb!= a]): \\n                stack.append(v[1])\\n                \\n        stack.pop()\\n        return stack        \\n        \\n    # distance between 2 points (raised to the square to avoid dealing with sq root, as I m using these to exclusively)\\n    def distance(self,a,b): return ((b[1] - a[1]) ** 2 + (b[0] - a[0]) ** 2) \\n    \\n    # vectorial product\\n    def f(self,o,a,b): return (b[1] - o[1]) * (a[0] - o[0]) - (a[1] - o[1]) * (b[0] - o[0]) \\n    \\n    # returns True iff the angle formed by this pair of vector (oa,ob) is a left turn\\n    def left(self,o,a,b):  return self.f(o,a,b) > 0\\n    \\n    def right(self,o,a,b):  return self.f(o,a,b) < 0\\n    \\n    def colinear(self, o,a,b): return self.f(o,a,b) == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def outerTrees(self, points):\\n        if len(points) <= 3: return points\\n        stack = [min(points)]\\n        while(len(stack) == 1 or stack[-1] != stack[0]):\\n            a = stack[-1]\\n            # this point is garantted 100 % as belonging to the convex hull precomputed up till now\\n            # a plausible candidate is cand thats NULL for now\\n            cand = None \\n            for b in points:\\n                if b!= a and (cand is None or self.left(a,cand,b)): \\n                    # choose it iff \\n                    # (o,cand), (o,b) is a left turn\\n                    cand = b\\n            \\n            # grab the points that are colinear to the vector (o,cand)\\n            # sorted from the closest to a \\n            # to the furthest\\n            for v in sorted([(self.distance(a,bb),bb) for bb in points if self.f(a,cand,bb) == 0 and bb!= a]): \\n                stack.append(v[1])\\n                \\n        stack.pop()\\n        return stack        \\n        \\n    # distance between 2 points (raised to the square to avoid dealing with sq root, as I m using these to exclusively)\\n    def distance(self,a,b): return ((b[1] - a[1]) ** 2 + (b[0] - a[0]) ** 2) \\n    \\n    # vectorial product\\n    def f(self,o,a,b): return (b[1] - o[1]) * (a[0] - o[0]) - (a[1] - o[1]) * (b[0] - o[0]) \\n    \\n    # returns True iff the angle formed by this pair of vector (oa,ob) is a left turn\\n    def left(self,o,a,b):  return self.f(o,a,b) > 0\\n    \\n    def right(self,o,a,b):  return self.f(o,a,b) < 0\\n    \\n    def colinear(self, o,a,b): return self.f(o,a,b) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433943,
                "title": "java-updated-jarvis-march-algorithm-gift-wrapping-algo",
                "content": "We find the leftmost point in the grid. Since it is the leftmost point, we conclude that it should be a correct point (correct, because we know it is part of the answer -> Because it is the leftmost point, it is in the outermost area of the boundary). We then look for the leftmost point (or rightmost. you just need to pick an orientation and stick with it.) with respect to the point we originally picked. We pick the leftmost point, because that leftmost point should be part of the boundary too. It will be the most \"outside\" point. We repeat this until all the leftmost points have been picked.   \\n\\nhttps://www.youtube.com/watch?v=Vu84lmMzP2o&t=719s\\nHere is the video I used for learning and visualization.\\n```\\npublic class Solution {\\n\\t/* compares the slop of pq to the slope of qr. If the slope of pq is larger than the slope of qr, we know it\\'s increasing at a faster rate (imagine the slopes on a 2D grid). \\n\\tThis means that q must be more left or counter clockwise with respect to p. If it is negative, qr is more left/CCW with respect to p*/\\n    public int orientation(int[] p, int[] q, int[] r) {\\n        return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\\n    }\\n    public int distance(int[] p, int[] q) {\\n        return (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\\n    }\\n    public int[][] outerTrees(int[][] points) {\\n        int n = points.length;\\n        if (n < 4) {\\n            return points;\\n        }\\n        HashSet<int[]> hull = new HashSet();\\n        int left_most = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (points[i][0] < points[left_most][0]) {\\n                left_most = i;\\n            }\\n        }\\n        int p = left_most;\\n        ArrayList<int[]> list = new ArrayList();\\n        do {\\n            int q = (p + 1) % n;\\n            for (int i = 0; i < points.length; i++) {\\n                int orientationRes = orientation(points[p], points[q], points[i]);\\n\\t\\t\\t\\t/* Look at explanation above, if orientationRes is negative, it means we found a more left/CCW point. */\\n                if (orientationRes < 0) {\\n                    q = i;\\n                    list = new ArrayList();\\n                } else if(orientationRes == 0) {\\n\\t\\t\\t\\t\\t/* if the slopes of pq and qr are the same, we know that they lie on the same line. \\n\\t\\t\\t\\t\\tThis means that we need to choose between q and i. We want the one that is further away, \\n\\t\\t\\t\\t\\tsince the one closer to p will eventually pick the current i as the furthest left/CCW point. \\n\\t\\t\\t\\t\\tWe can optimize by picking the one that is further away and just adding the closer one (closer one with respect to p) to the list. */\\n                    if(distance(points[p], points[q]) >= distance(points[p], points[i])) {\\n                        list.add(points[i]);\\n                    } else {\\n                        list.add(points[q]);\\n                        q = i;\\n                    }\\n                }\\n            }\\n            list.add(points[q]);\\n            hull.addAll(list);\\n            p = q;\\n        } while (p != left_most);\\n        \\n        int[][] res = new int[hull.size()][2];\\n        int i = 0;\\n        for(int[] h: hull) {\\n            res[i++] = h;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\t/* compares the slop of pq to the slope of qr. If the slope of pq is larger than the slope of qr, we know it\\'s increasing at a faster rate (imagine the slopes on a 2D grid). \\n\\tThis means that q must be more left or counter clockwise with respect to p. If it is negative, qr is more left/CCW with respect to p*/\\n    public int orientation(int[] p, int[] q, int[] r) {\\n        return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\\n    }\\n    public int distance(int[] p, int[] q) {\\n        return (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\\n    }\\n    public int[][] outerTrees(int[][] points) {\\n        int n = points.length;\\n        if (n < 4) {\\n            return points;\\n        }\\n        HashSet<int[]> hull = new HashSet();\\n        int left_most = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (points[i][0] < points[left_most][0]) {\\n                left_most = i;\\n            }\\n        }\\n        int p = left_most;\\n        ArrayList<int[]> list = new ArrayList();\\n        do {\\n            int q = (p + 1) % n;\\n            for (int i = 0; i < points.length; i++) {\\n                int orientationRes = orientation(points[p], points[q], points[i]);\\n\\t\\t\\t\\t/* Look at explanation above, if orientationRes is negative, it means we found a more left/CCW point. */\\n                if (orientationRes < 0) {\\n                    q = i;\\n                    list = new ArrayList();\\n                } else if(orientationRes == 0) {\\n\\t\\t\\t\\t\\t/* if the slopes of pq and qr are the same, we know that they lie on the same line. \\n\\t\\t\\t\\t\\tThis means that we need to choose between q and i. We want the one that is further away, \\n\\t\\t\\t\\t\\tsince the one closer to p will eventually pick the current i as the furthest left/CCW point. \\n\\t\\t\\t\\t\\tWe can optimize by picking the one that is further away and just adding the closer one (closer one with respect to p) to the list. */\\n                    if(distance(points[p], points[q]) >= distance(points[p], points[i])) {\\n                        list.add(points[i]);\\n                    } else {\\n                        list.add(points[q]);\\n                        q = i;\\n                    }\\n                }\\n            }\\n            list.add(points[q]);\\n            hull.addAll(list);\\n            p = q;\\n        } while (p != left_most);\\n        \\n        int[][] res = new int[hull.size()][2];\\n        int i = 0;\\n        for(int[] h: hull) {\\n            res[i++] = h;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313869,
                "title": "java-59-ms-faster-than-11-11-47-9-mb-less-than-74-44",
                "content": "```\\nclass Solution {\\n    public int[][] outerTrees(int[][] pois) {\\n        if (pois.length == 1) {\\n            return new int[][]{pois[0]};\\n        }\\n        Point[] points = new Point[pois.length];\\n        for (int i = 0; i < pois.length; ++i) {\\n            points[i] = new Point(pois[i][0], pois[i][1]);\\n        }\\n        Arrays.sort(points, (a, b) -> a.x == b.x ? a.y - b.y : a.x - b.x);\\n        int n = points.length;\\n        Stack<Point> boarder = new Stack<>();\\n        Set<Point> res = new HashSet<>();\\n        boarder.push(points[0]);\\n        boarder.push(points[1]);\\n        for (int i = 2; i < n; ++i) {\\n            Point top = boarder.pop();\\n            while (!boarder.isEmpty() && !isClock(boarder.peek(), top, points[i])) {\\n                top = boarder.pop();\\n            }\\n            boarder.push(top);\\n            boarder.push(points[i]);\\n        }\\n        for (int i = n - 2; i >= 0; --i) {\\n            Point top = boarder.pop();\\n            while (!boarder.isEmpty() && !isClock(boarder.peek(), top, points[i])) {\\n                top = boarder.pop();\\n            }\\n            boarder.push(top);\\n            boarder.push(points[i]);\\n        }\\n        for (Point p : boarder) {\\n            res.add(p);\\n        }\\n        int[][] ans = new int[res.size()][2];\\n        int i = 0;\\n        for (Point p : res) {\\n            ans[i][0] = p.x;\\n            ans[i++][1] = p.y;\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isClock(Point ori, Point p1, Point p2) {\\n        return (p1.x - ori.x) * (p2.y - ori.y) <= (p2.x - ori.x) * (p1.y - ori.y);\\n    }\\n    \\n    private class Point{\\n        int x;\\n        int y;\\n        \\n        Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] outerTrees(int[][] pois) {\\n        if (pois.length == 1) {\\n            return new int[][]{pois[0]};\\n        }\\n        Point[] points = new Point[pois.length];\\n        for (int i = 0; i < pois.length; ++i) {\\n            points[i] = new Point(pois[i][0], pois[i][1]);\\n        }\\n        Arrays.sort(points, (a, b) -> a.x == b.x ? a.y - b.y : a.x - b.x);\\n        int n = points.length;\\n        Stack<Point> boarder = new Stack<>();\\n        Set<Point> res = new HashSet<>();\\n        boarder.push(points[0]);\\n        boarder.push(points[1]);\\n        for (int i = 2; i < n; ++i) {\\n            Point top = boarder.pop();\\n            while (!boarder.isEmpty() && !isClock(boarder.peek(), top, points[i])) {\\n                top = boarder.pop();\\n            }\\n            boarder.push(top);\\n            boarder.push(points[i]);\\n        }\\n        for (int i = n - 2; i >= 0; --i) {\\n            Point top = boarder.pop();\\n            while (!boarder.isEmpty() && !isClock(boarder.peek(), top, points[i])) {\\n                top = boarder.pop();\\n            }\\n            boarder.push(top);\\n            boarder.push(points[i]);\\n        }\\n        for (Point p : boarder) {\\n            res.add(p);\\n        }\\n        int[][] ans = new int[res.size()][2];\\n        int i = 0;\\n        for (Point p : res) {\\n            ans[i][0] = p.x;\\n            ans[i++][1] = p.y;\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isClock(Point ori, Point p1, Point p2) {\\n        return (p1.x - ori.x) * (p2.y - ori.y) <= (p2.x - ori.x) * (p1.y - ori.y);\\n    }\\n    \\n    private class Point{\\n        int x;\\n        int y;\\n        \\n        Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278208,
                "title": "o-nlogn-monotone-chain-algorithm",
                "content": "Idea is to construct the lower and upper hulls separately. Sort points by x. If xs are equal, we need to sort by y in descending order so we can capture collinear points in the solution.\\n\\n```\\nclass Solution {\\n    int ccw(vector<int>& o, vector<int>& a, vector<int>& b) {\\n        return (a[0] - o[0]) * (b[1] - o[1]) - (b[0] - o[0]) * (a[1] - o[1]);\\n    }\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if (n <= 3) return points;\\n        \\n        // Sort points by x coordinate\\n        sort(points.begin(), points.end(), [](auto& a, auto& b) {\\n            return a[0] < b[0] || a[0] == b[0] && a[1] > b[1];\\n        });\\n        \\n        // Hull\\n        vector<vector<int>> hull(2 * n, vector<int>(2));\\n        \\n        // Lower hull\\n        int k = 0;\\n        for (int i = 0; i < n; ++i) {\\n            while (k >= 2 && ccw(hull[k-2], hull[k-1], points[i]) < 0) --k;\\n            hull[k++] = points[i];\\n        }\\n\\n        // Upper hull;\\n        for (int i = n - 2, t = k + 1; i >= 0; --i) {\\n            while (k >= t && ccw(hull[k-2], hull[k-1], points[i]) < 0) --k;\\n            hull[k++] = points[i];\\n        }\\n        \\n        hull.resize(k-1);\\n        return hull;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ccw(vector<int>& o, vector<int>& a, vector<int>& b) {\\n        return (a[0] - o[0]) * (b[1] - o[1]) - (b[0] - o[0]) * (a[1] - o[1]);\\n    }\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if (n <= 3) return points;\\n        \\n        // Sort points by x coordinate\\n        sort(points.begin(), points.end(), [](auto& a, auto& b) {\\n            return a[0] < b[0] || a[0] == b[0] && a[1] > b[1];\\n        });\\n        \\n        // Hull\\n        vector<vector<int>> hull(2 * n, vector<int>(2));\\n        \\n        // Lower hull\\n        int k = 0;\\n        for (int i = 0; i < n; ++i) {\\n            while (k >= 2 && ccw(hull[k-2], hull[k-1], points[i]) < 0) --k;\\n            hull[k++] = points[i];\\n        }\\n\\n        // Upper hull;\\n        for (int i = n - 2, t = k + 1; i >= 0; --i) {\\n            while (k >= t && ccw(hull[k-2], hull[k-1], points[i]) < 0) --k;\\n            hull[k++] = points[i];\\n        }\\n        \\n        hull.resize(k-1);\\n        return hull;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 236590,
                "title": "how-to-approach-this-problem-without-knowing-convex-hull-algorithms",
                "content": "I have no idea what Convex Hull is before this problem. Wondering if anyone in the same shoe but solved this problem can share some insights on the though process.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 166258,
                "title": "27-lines-c-solution",
                "content": "```\\nclass Solution {\\n    int cross2d(Point origin, Point a, Point b){\\n        return (a.x - origin.x) * (b.y - origin.y) - (b.x - origin.x) * (a.y - origin.y);\\n    }\\npublic:\\n    vector<Point> outerTrees(vector<Point>& points) {\\n        int n = points.size();\\n        if(n <= 3) return points;\\n        sort(points.begin(), points.end(), [](auto& a, auto& b){return tie(a.x, a.y) < tie(b.x, b.y);});\\n        \\n        vector<Point> fence;\\n        for(int i = 0; points[i].x != points.back().x; i ++){\\n            while(fence.size() >= 2 && cross2d(*next(fence.rbegin()), *fence.rbegin(), points[i]) > 0){\\n                fence.pop_back();\\n            }\\n            fence.emplace_back(points[i]);\\n        }\\n        for(int i = n - 1;; i --){\\n            while(fence.size() >= 2 && cross2d(*next(fence.rbegin()), *fence.rbegin(), points[i]) > 0){\\n                fence.pop_back();\\n            }\\n            if(i != 0){ fence.emplace_back(points[i]); }\\n            else{ break; }\\n        }\\n        return fence;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int cross2d(Point origin, Point a, Point b){\\n        return (a.x - origin.x) * (b.y - origin.y) - (b.x - origin.x) * (a.y - origin.y);\\n    }\\npublic:\\n    vector<Point> outerTrees(vector<Point>& points) {\\n        int n = points.size();\\n        if(n <= 3) return points;\\n        sort(points.begin(), points.end(), [](auto& a, auto& b){return tie(a.x, a.y) < tie(b.x, b.y);});\\n        \\n        vector<Point> fence;\\n        for(int i = 0; points[i].x != points.back().x; i ++){\\n            while(fence.size() >= 2 && cross2d(*next(fence.rbegin()), *fence.rbegin(), points[i]) > 0){\\n                fence.pop_back();\\n            }\\n            fence.emplace_back(points[i]);\\n        }\\n        for(int i = n - 1;; i --){\\n            while(fence.size() >= 2 && cross2d(*next(fence.rbegin()), *fence.rbegin(), points[i]) > 0){\\n                fence.pop_back();\\n            }\\n            if(i != 0){ fence.emplace_back(points[i]); }\\n            else{ break; }\\n        }\\n        return fence;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 118552,
                "title": "python3-beats-100-with-easy-detailed-explanation",
                "content": "\\nFirst, sort points according to `x` value.\\nGet left most point(s) with `x0`\\nGet left most point with highest `y0`, use get `(x0, y0)` as the start point, while there are points at the right of then, from remaining points pick the one with the highest `sin-value=(x-x0)/(y-y0)` (If more than one points have hightest value, add them all, update to rightmost one), this is to try to go higher. Repeat until no points has larger `x`.\\n\\nThe next step is start with left most point with lowest `y0`, keep choosing points with smallest `sin-value=(x-x0)/(y-y0)` until no points at right.\\n\\nAll points visited are on the fence, then add all leftmost points and all rightmost points.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/luckypants/image_1520688031.png)\\n\\n\\n\\nSo easy to understand.\\n\\n\\n```\\n# Definition for a point.\\n# class Point(object):\\n#     def __init__(self, a=0, b=0):\\n#         self.x = a\\n#         self.y = b\\n\\nclass Solution:\\n    def outerTrees(self, points):\\n        \"\"\"\\n        :type points: List[Point]\\n        :rtype: List[Point]\\n        \"\"\"\\n        ret = set()\\n        \\n        dic = collections.defaultdict(list)\\n        for p in points:\\n            dic[p.x].append(p.y)\\n\\n        xs = sorted(set([_.x for _ in points]))\\n        ret.update([(xs[0], y) for y in dic[xs[0]]])\\n        ret.update([(xs[-1], y) for y in dic[xs[-1]]])\\n        \\n        x = xs.pop(0)\\n        ys = dic[x]\\n        y = max(ys)        \\n        while xs:\\n            remain = [(a, b) for a in xs for b in dic[a]]\\n            ma_sin = [(b-y)/(a-x) for (a, b) in remain]\\n            tmp = -sys.maxsize\\n            cands = set()\\n            for i in range(len(ma_sin)):\\n                if ma_sin[i]>tmp:\\n                    tmp = ma_sin[i]\\n                    cands = set([remain[i]])\\n                elif ma_sin[i]==tmp:\\n                    cands.add(remain[i])\\n            x, y = -1, -1\\n            ret.update(cands)\\n            for c in cands:\\n                if c[0]>x:\\n                    x, y = c\\n            while xs and xs[0]<=x:\\n                xs.pop(0)\\n        \\n        xs = sorted(set([_.x for _ in points]))\\n        x = xs.pop(0)\\n        ys = dic[x]\\n        y = min(ys)        \\n        while xs:\\n            print\\n            remain = [(a, b) for a in xs for b in dic[a]]\\n            mi_sin = [(b-y)/(a-x) for (a, b) in remain]\\n            tmp = sys.maxsize\\n            cands = set()\\n            for i in range(len(mi_sin)):\\n                if mi_sin[i]<tmp:\\n                    tmp = mi_sin[i]\\n                    cands = set([remain[i]])\\n                elif mi_sin[i]==tmp:\\n                    cands.add(remain[i])\\n            x, y = -1, -1\\n            ret.update(cands)\\n            for c in cands:\\n                if c[0]>x:\\n                    x, y = c\\n            while xs and xs[0]<=x:\\n                xs.pop(0)\\n            \\n        # print(ret)\\n        return list(ret)",
                "solutionTags": [],
                "code": "\\nFirst, sort points according to `x` value.\\nGet left most point(s) with `x0`\\nGet left most point with highest `y0`, use get `(x0, y0)` as the start point, while there are points at the right of then, from remaining points pick the one with the highest `sin-value=(x-x0)/(y-y0)` (If more than one points have hightest value, add them all, update to rightmost one), this is to try to go higher. Repeat until no points has larger `x`.\\n\\nThe next step is start with left most point with lowest `y0`, keep choosing points with smallest `sin-value=(x-x0)/(y-y0)` until no points at right.\\n\\nAll points visited are on the fence, then add all leftmost points and all rightmost points.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/luckypants/image_1520688031.png)\\n\\n\\n\\nSo easy to understand.\\n\\n\\n```\\n# Definition for a point.\\n# class Point(object):\\n#     def __init__(self, a=0, b=0):\\n#         self.x = a\\n#         self.y = b\\n\\nclass Solution:\\n    def outerTrees(self, points):\\n        \"\"\"\\n        :type points: List[Point]\\n        :rtype: List[Point]\\n        \"\"\"\\n        ret = set()\\n        \\n        dic = collections.defaultdict(list)\\n        for p in points:\\n            dic[p.x].append(p.y)\\n\\n        xs = sorted(set([_.x for _ in points]))\\n        ret.update([(xs[0], y) for y in dic[xs[0]]])\\n        ret.update([(xs[-1], y) for y in dic[xs[-1]]])\\n        \\n        x = xs.pop(0)\\n        ys = dic[x]\\n        y = max(ys)        \\n        while xs:\\n            remain = [(a, b) for a in xs for b in dic[a]]\\n            ma_sin = [(b-y)/(a-x) for (a, b) in remain]\\n            tmp = -sys.maxsize\\n            cands = set()\\n            for i in range(len(ma_sin)):\\n                if ma_sin[i]>tmp:\\n                    tmp = ma_sin[i]\\n                    cands = set([remain[i]])\\n                elif ma_sin[i]==tmp:\\n                    cands.add(remain[i])\\n            x, y = -1, -1\\n            ret.update(cands)\\n            for c in cands:\\n                if c[0]>x:\\n                    x, y = c\\n            while xs and xs[0]<=x:\\n                xs.pop(0)\\n        \\n        xs = sorted(set([_.x for _ in points]))\\n        x = xs.pop(0)\\n        ys = dic[x]\\n        y = min(ys)        \\n        while xs:\\n            print\\n            remain = [(a, b) for a in xs for b in dic[a]]\\n            mi_sin = [(b-y)/(a-x) for (a, b) in remain]\\n            tmp = sys.maxsize\\n            cands = set()\\n            for i in range(len(mi_sin)):\\n                if mi_sin[i]<tmp:\\n                    tmp = mi_sin[i]\\n                    cands = set([remain[i]])\\n                elif mi_sin[i]==tmp:\\n                    cands.add(remain[i])\\n            x, y = -1, -1\\n            ret.update(cands)\\n            for c in cands:\\n                if c[0]>x:\\n                    x, y = c\\n            while xs and xs[0]<=x:\\n                xs.pop(0)\\n            \\n        # print(ret)\\n        return list(ret)",
                "codeTag": "Java"
            },
            {
                "id": 103310,
                "title": "c-monotone-chain-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int orientation(Point &p, Point &q, Point &r) {\\n        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\\n    }\\n    \\n    vector<Point> outerTrees(vector<Point>& points) {\\n        if (points.size() < 4)\\n            return points;\\n        \\n        sort(points.begin(), points.end(), [](Point &p, Point &q) {\\n            return p.x < q.x || (p.x == q.x && p.y < q.y);\\n        });\\n        \\n        vector<Point> ans;\\n        for (int i = 0; i < points.size(); ++i) {\\n            while (ans.size() >= 2 && orientation(ans[ans.size() - 2], ans[ans.size() - 1], points[i]) < 0)\\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        ans.pop_back();\\n        for (int i = points.size() - 1; i >= 0; --i) {\\n            while (ans.size() >= 2 && orientation(ans[ans.size() - 2], ans[ans.size() - 1], points[i]) < 0)\\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int orientation(Point &p, Point &q, Point &r) {\\n        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\\n    }\\n    \\n    vector<Point> outerTrees(vector<Point>& points) {\\n        if (points.size() < 4)\\n            return points;\\n        \\n        sort(points.begin(), points.end(), [](Point &p, Point &q) {\\n            return p.x < q.x || (p.x == q.x && p.y < q.y);\\n        });\\n        \\n        vector<Point> ans;\\n        for (int i = 0; i < points.size(); ++i) {\\n            while (ans.size() >= 2 && orientation(ans[ans.size() - 2], ans[ans.size() - 1], points[i]) < 0)\\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        ans.pop_back();\\n        for (int i = points.size() - 1; i >= 0; --i) {\\n            while (ans.size() >= 2 && orientation(ans[ans.size() - 2], ans[ans.size() - 1], points[i]) < 0)\\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103314,
                "title": "python-graham-scan-simple-and-short",
                "content": "```\\n    def outerTrees(self, A):\\n        \"\"\"\\n        :type points: A[Point]\\n        :rtype: List[Point]\\n        \"\"\"\\n        def comparator(p1,p2):\\n            if p1.x==p2.x: return p1.y-p2.y\\n            else: \\n                return p1.x-p2.x\\n                \\n        def onleftside(p0,p1,p2):\\n            x1,x2=p1.x-p0.x,p2.x-p1.x\\n            y1,y2=p1.y-p0.y,p2.y-p1.y\\n            cross=x1*y2-x2*y1\\n            return cross>0\\n            \\n        def findHull(s,p):\\n            while len(s)>=2 and onleftside(s[-2],s[-1],p):\\n                s.pop()\\n            s.append(p)\\n        \\n        n= len(A)\\n        if n<4: return A\\n        A.sort(cmp=comparator)\\n        \\n        upHull,bottemHull=[A[0]],[A[-1]]\\n        for i in xrange(1,n):\\n            findHull(upHull,A[i])\\n        for i in xrange(n-2,-1,-1):\\n            findHull(bottemHull,A[i])\\n\\n        for p in bottemHull:\\n            if p not in upHull:\\n                upHull.append(p)\\n        return upHull\\n```",
                "solutionTags": [],
                "code": "```\\n    def outerTrees(self, A):\\n        \"\"\"\\n        :type points: A[Point]\\n        :rtype: List[Point]\\n        \"\"\"\\n        def comparator(p1,p2):\\n            if p1.x==p2.x: return p1.y-p2.y\\n            else: \\n                return p1.x-p2.x\\n                \\n        def onleftside(p0,p1,p2):\\n            x1,x2=p1.x-p0.x,p2.x-p1.x\\n            y1,y2=p1.y-p0.y,p2.y-p1.y\\n            cross=x1*y2-x2*y1\\n            return cross>0\\n            \\n        def findHull(s,p):\\n            while len(s)>=2 and onleftside(s[-2],s[-1],p):\\n                s.pop()\\n            s.append(p)\\n        \\n        n= len(A)\\n        if n<4: return A\\n        A.sort(cmp=comparator)\\n        \\n        upHull,bottemHull=[A[0]],[A[-1]]\\n        for i in xrange(1,n):\\n            findHull(upHull,A[i])\\n        for i in xrange(n-2,-1,-1):\\n            findHull(bottemHull,A[i])\\n\\n        for p in bottemHull:\\n            if p not in upHull:\\n                upHull.append(p)\\n        return upHull\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 103316,
                "title": "c-o-nlogn-solution",
                "content": "```\\n    vector<Point> outerTrees(vector<Point>& points) {\\n        if(points.size() < 3) return points;\\n        auto cmp = [](Point& a, Point& b) -> bool {\\n            return a.x < b.x || (a.x == b.x && a.y < b.y);\\n        };\\n        sort(points.begin(), points.end(), cmp);\\n        vector<Point> stack;\\n        stack.push_back(points[0]);\\n        stack.push_back(points[1]);\\n        //left to right;\\n        for(int i = 2; i < points.size(); ++i) {\\n            while(stack.size() > 1) {\\n                auto &t1 = stack.back();\\n                auto &t2 = stack[stack.size() - 2];\\n                if(isRightTurn(t2, t1, points[i])) break;\\n                else stack.pop_back();\\n            }\\n            stack.push_back(points[i]);\\n        }\\n        int n = stack.size();\\n        if(n == points.size()) return stack; //check if linear\\n        stack.push_back(points[points.size() - 2]);\\n        //right to left;\\n        for(int i = points.size() - 3; i >= 0; --i) {\\n            while(stack.size() > n) {\\n                auto &t1 = stack.back();\\n                auto &t2 = stack[stack.size() - 2];\\n                if(isRightTurn(t2, t1, points[i])) break;\\n                else stack.pop_back();\\n            }\\n            stack.push_back(points[i]);\\n        }\\n        stack.pop_back();\\n        return stack;\\n    }\\n    \\n    bool isRightTurn(Point &a, Point &b, Point &c) {\\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x) <= 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<Point> outerTrees(vector<Point>& points) {\\n        if(points.size() < 3) return points;\\n        auto cmp = [](Point& a, Point& b) -> bool {\\n            return a.x < b.x || (a.x == b.x && a.y < b.y);\\n        };\\n        sort(points.begin(), points.end(), cmp);\\n        vector<Point> stack;\\n        stack.push_back(points[0]);\\n        stack.push_back(points[1]);\\n        //left to right;\\n        for(int i = 2; i < points.size(); ++i) {\\n            while(stack.size() > 1) {\\n                auto &t1 = stack.back();\\n                auto &t2 = stack[stack.size() - 2];\\n                if(isRightTurn(t2, t1, points[i])) break;\\n                else stack.pop_back();\\n            }\\n            stack.push_back(points[i]);\\n        }\\n        int n = stack.size();\\n        if(n == points.size()) return stack; //check if linear\\n        stack.push_back(points[points.size() - 2]);\\n        //right to left;\\n        for(int i = points.size() - 3; i >= 0; --i) {\\n            while(stack.size() > n) {\\n                auto &t1 = stack.back();\\n                auto &t2 = stack[stack.size() - 2];\\n                if(isRightTurn(t2, t1, points[i])) break;\\n                else stack.pop_back();\\n            }\\n            stack.push_back(points[i]);\\n        }\\n        stack.pop_back();\\n        return stack;\\n    }\\n    \\n    bool isRightTurn(Point &a, Point &b, Point &c) {\\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x) <= 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103321,
                "title": "using-divide-and-conquer",
                "content": "![0_1494819762573_upload-9d9db74c-5aab-460d-899e-bcf4dddf98b7](/uploads/files/1494819744153-upload-9d9db74c-5aab-460d-899e-bcf4dddf98b7.png) \\n\\n```java\\npublic List<Point> outerTrees(Point[] points) {\\n\\t\\tList<Point> pp = new ArrayList<>();\\n\\t\\tfor (Point p : points){\\n\\t\\t\\tpp.add(p);\\n\\t\\t}\\n\\t\\thelper(pp,true);\\n\\t\\thelper(pp, false);\\n\\t\\treturn new ArrayList<>(ans);\\n\\t}\\n\\t\\n\\tSet<Point> ans = new HashSet<>();\\n\\tprivate void helper(List<Point> points, boolean calcuConvex){\\n\\t\\tif (points.size() == 0) return;\\n\\t\\tCollections.sort(points, new Comparator<Point>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(Point o1, Point o2) {\\n\\t\\t\\t\\treturn o1.x != o2.x ? o1.x - o2.x : o1.y - o2.y;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tint fir = 0;\\n\\t\\tint lst = points.size() - 1;\\n\\n\\t\\tans.add(points.get(fir));\\n\\t\\tans.add(points.get(lst));\\n\\n\\t\\tif (points.size() == 2)\\n\\t\\t\\treturn;\\n\\n\\t\\t// oneLine\\n\\t\\tboolean isLine = true;\\n\\t\\tfor (int i = 0; i < points.size(); i++) {\\n\\t\\t\\tif (i == fir || i == lst)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (calcuTriangle(points.get(fir), points.get(lst), points.get(i)) != 0) {\\n\\t\\t\\t\\tisLine = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (isLine) {\\n\\t\\t\\tans.addAll(points);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tint maxIndex = -1;\\n\\t\\tint max = 0;\\n\\t\\tfor (int i = 0; i < points.size(); i++) {\\n\\t\\t\\tif (i == fir || i == lst)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (calcuConvex && calcuTriangle(points.get(fir), points.get(lst), points.get(i)) > max) {\\n\\t\\t\\t\\tmaxIndex = i;\\n\\t\\t\\t\\tmax = calcuTriangle(points.get(fir), points.get(lst), points.get(i));\\n\\t\\t\\t}\\n\\t\\t\\tif (!calcuConvex && -calcuTriangle(points.get(fir), points.get(lst), points.get(i)) > max) {\\n\\t\\t\\t\\tmaxIndex = i;\\n\\t\\t\\t\\tmax = -calcuTriangle(points.get(fir), points.get(lst), points.get(i));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (maxIndex == -1) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tList<Point> c1 = new ArrayList<>();\\n\\t\\tsplit(fir, maxIndex, points, c1, calcuConvex);\\n\\t\\thelper(c1,calcuConvex);\\n\\n\\t\\tList<Point> c2 = new ArrayList<>();\\n\\t\\tsplit(lst, maxIndex, points, c2, !calcuConvex);\\n\\t\\thelper(c2,calcuConvex);\\n\\t}\\n\\t\\n\\tprivate void split(int a1, int a2, List<Point> points, List<Point> part1, boolean isConvex) {\\n\\t\\tfor (int i = 0; i < points.size(); i++) {\\n\\t\\t\\tif (i == a1 || i == a2) {\\n\\t\\t\\t\\tpart1.add(points.get(i));\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (isConvex && calcuTriangle(points.get(a1), points.get(a2), points.get(i)) >= 0) {\\n\\t\\t\\t\\tpart1.add(points.get(i));\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!isConvex && calcuTriangle(points.get(a1), points.get(a2), points.get(i)) <= 0) {\\n\\t\\t\\t\\tpart1.add(points.get(i));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\tprivate int calcuTriangle(Point a1, Point a2, Point a3) {\\n\\t\\treturn a1.x * a2.y + a3.x * a1.y + a2.x * a3.y \\n\\t\\t\\t\\t- a3.x * a2.y - a2.x * a1.y - a1.x * a3.y;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic List<Point> outerTrees(Point[] points) {\\n\\t\\tList<Point> pp = new ArrayList<>();\\n\\t\\tfor (Point p : points){\\n\\t\\t\\tpp.add(p);\\n\\t\\t}\\n\\t\\thelper(pp,true);\\n\\t\\thelper(pp, false);\\n\\t\\treturn new ArrayList<>(ans);\\n\\t}\\n\\t\\n\\tSet<Point> ans = new HashSet<>();\\n\\tprivate void helper(List<Point> points, boolean calcuConvex){\\n\\t\\tif (points.size() == 0) return;\\n\\t\\tCollections.sort(points, new Comparator<Point>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(Point o1, Point o2) {\\n\\t\\t\\t\\treturn o1.x != o2.x ? o1.x - o2.x : o1.y - o2.y;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tint fir = 0;\\n\\t\\tint lst = points.size() - 1;\\n\\n\\t\\tans.add(points.get(fir));\\n\\t\\tans.add(points.get(lst));\\n\\n\\t\\tif (points.size() == 2)\\n\\t\\t\\treturn;\\n\\n\\t\\t// oneLine\\n\\t\\tboolean isLine = true;\\n\\t\\tfor (int i = 0; i < points.size(); i++) {\\n\\t\\t\\tif (i == fir || i == lst)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (calcuTriangle(points.get(fir), points.get(lst), points.get(i)) != 0) {\\n\\t\\t\\t\\tisLine = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (isLine) {\\n\\t\\t\\tans.addAll(points);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tint maxIndex = -1;\\n\\t\\tint max = 0;\\n\\t\\tfor (int i = 0; i < points.size(); i++) {\\n\\t\\t\\tif (i == fir || i == lst)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (calcuConvex && calcuTriangle(points.get(fir), points.get(lst), points.get(i)) > max) {\\n\\t\\t\\t\\tmaxIndex = i;\\n\\t\\t\\t\\tmax = calcuTriangle(points.get(fir), points.get(lst), points.get(i));\\n\\t\\t\\t}\\n\\t\\t\\tif (!calcuConvex && -calcuTriangle(points.get(fir), points.get(lst), points.get(i)) > max) {\\n\\t\\t\\t\\tmaxIndex = i;\\n\\t\\t\\t\\tmax = -calcuTriangle(points.get(fir), points.get(lst), points.get(i));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (maxIndex == -1) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tList<Point> c1 = new ArrayList<>();\\n\\t\\tsplit(fir, maxIndex, points, c1, calcuConvex);\\n\\t\\thelper(c1,calcuConvex);\\n\\n\\t\\tList<Point> c2 = new ArrayList<>();\\n\\t\\tsplit(lst, maxIndex, points, c2, !calcuConvex);\\n\\t\\thelper(c2,calcuConvex);\\n\\t}\\n\\t\\n\\tprivate void split(int a1, int a2, List<Point> points, List<Point> part1, boolean isConvex) {\\n\\t\\tfor (int i = 0; i < points.size(); i++) {\\n\\t\\t\\tif (i == a1 || i == a2) {\\n\\t\\t\\t\\tpart1.add(points.get(i));\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (isConvex && calcuTriangle(points.get(a1), points.get(a2), points.get(i)) >= 0) {\\n\\t\\t\\t\\tpart1.add(points.get(i));\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!isConvex && calcuTriangle(points.get(a1), points.get(a2), points.get(i)) <= 0) {\\n\\t\\t\\t\\tpart1.add(points.get(i));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\tprivate int calcuTriangle(Point a1, Point a2, Point a3) {\\n\\t\\treturn a1.x * a2.y + a3.x * a1.y + a2.x * a3.y \\n\\t\\t\\t\\t- a3.x * a2.y - a2.x * a1.y - a1.x * a3.y;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041872,
                "title": "python-very-simple-14-lines-lots-of-comments-o-n-log-n",
                "content": "```python\\nclass Solution:\\n  def outerTrees(self, points: List[List[int]]) -> List[List[int]]:\\n    # The orientation function determines the relative orientation of the triplet (p, q, r).\\n    # If the result is 0, they\\'re collinear.\\n    # If the result is positive, the triplet is in counterclockwise order.\\n    # If the result is negative, the triplet is in clockwise order.\\n    def orientation(p, q, r):\\n      return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0])\\n    \\n    # Sort the points based on their x-coordinate, and if they have the same x-coordinate,\\n    # sort based on their y-coordinate.\\n    points.sort(key=lambda p: (p[0], p[1]))\\n    \\n    # Initialize an empty list to store the points of the convex hull.\\n    hull = []\\n    \\n    # The first loop constructs the lower part of the convex hull.\\n    for point in points:\\n      # If the current point doesn\\'t make a counterclockwise turn from the last two points in the hull,\\n      # remove the last point from the hull.\\n      while len(hull) >= 2 and orientation(hull[-2], hull[-1], point) < 0:\\n        hull.pop()\\n      # Append the current point to the hull.\\n      # Have to cast to tuple becauses lists are not hashable since they are mutable unlike immutable tuples\\n      hull.append(tuple(point))\\n    \\n    # The second loop constructs the upper part of the convex hull.\\n    # We skip the last point in the sorted list as it\\'s already included.\\n    for point in reversed(points[:-1]):\\n      # Similar to the first loop, if the current point doesn\\'t make a counterclockwise turn from the last two points in the hull,\\n      # points in the hull, remove the last point from the hull.\\n      while len(hull) >= 2 and orientation(hull[-2], hull[-1], point) < 0:\\n        hull.pop()\\n      # Append the current point to the hull.\\n      # Have to cast to tuple becauses lists are not hashable since they are mutable unlike immutable tuples\\n      hull.append(tuple(point))\\n    \\n    # Some points might be included in the hull twice (once from the lower part and once from the upper part).\\n    # Convert the hull to a set and then back to a list to remove any redundant points.\\n    return list(set(hull))\\n```\\n\\nThe runtime complexity and space complexity of this code can be analyzed in the following way:\\n\\n**1. Sorting the Points:** \\nThe line `points.sort(key=lambda p: (p[0], p[1]))` sorts the list of points. The worst-case time complexity of sorting a list of $$n$$ elements is $$O(n \\\\log n)$$.\\n\\n**2. Constructing the Lower Hull:** \\nIn the first for loop, we iterate over each of the $$n$$ points once. In the worst case, the while loop can run $$n$$ times (though not for each iteration of the for loop). So, the time complexity of constructing the lower hull is $$O(n)$$.\\n\\n**3. Constructing the Upper Hull:** \\nSimilar to the lower hull, the second loop also has a time complexity of $$O(n)$$ for constructing the upper hull.\\n\\n**4. Removing Redundant Points:** \\nConverting the list to a set and then back to a list has a linear time complexity, $$O(n)$$.\\n\\nCombining all the steps together, the overall time complexity is:\\n\\n$$O(n \\\\log n) + O(n) + O(n) + O(n) = O(n \\\\log n)$$\\n\\n**Space Complexity:** \\nThe space complexity is primarily dominated by the space used to store the sorted points and the convex hull. In the worst case, all points might end up in the hull. Thus, the space complexity is $$O(n)$$.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n  def outerTrees(self, points: List[List[int]]) -> List[List[int]]:\\n    # The orientation function determines the relative orientation of the triplet (p, q, r).\\n    # If the result is 0, they\\'re collinear.\\n    # If the result is positive, the triplet is in counterclockwise order.\\n    # If the result is negative, the triplet is in clockwise order.\\n    def orientation(p, q, r):\\n      return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0])\\n    \\n    # Sort the points based on their x-coordinate, and if they have the same x-coordinate,\\n    # sort based on their y-coordinate.\\n    points.sort(key=lambda p: (p[0], p[1]))\\n    \\n    # Initialize an empty list to store the points of the convex hull.\\n    hull = []\\n    \\n    # The first loop constructs the lower part of the convex hull.\\n    for point in points:\\n      # If the current point doesn\\'t make a counterclockwise turn from the last two points in the hull,\\n      # remove the last point from the hull.\\n      while len(hull) >= 2 and orientation(hull[-2], hull[-1], point) < 0:\\n        hull.pop()\\n      # Append the current point to the hull.\\n      # Have to cast to tuple becauses lists are not hashable since they are mutable unlike immutable tuples\\n      hull.append(tuple(point))\\n    \\n    # The second loop constructs the upper part of the convex hull.\\n    # We skip the last point in the sorted list as it\\'s already included.\\n    for point in reversed(points[:-1]):\\n      # Similar to the first loop, if the current point doesn\\'t make a counterclockwise turn from the last two points in the hull,\\n      # points in the hull, remove the last point from the hull.\\n      while len(hull) >= 2 and orientation(hull[-2], hull[-1], point) < 0:\\n        hull.pop()\\n      # Append the current point to the hull.\\n      # Have to cast to tuple becauses lists are not hashable since they are mutable unlike immutable tuples\\n      hull.append(tuple(point))\\n    \\n    # Some points might be included in the hull twice (once from the lower part and once from the upper part).\\n    # Convert the hull to a set and then back to a list to remove any redundant points.\\n    return list(set(hull))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951818,
                "title": "clear-concise-c",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int calculate(vector<int> &p1, vector<int> &p2, vector<int> &p3){\\n        int x1 = p1[0], x2 = p2[0], x3 = p3[0];\\n        int y1 = p1[1], y2 = p2[1], y3 = p3[1];\\n\\n        // m23 - m12\\n        // (y3-y2)/(x3-x2) - (y2-y1)/(x2-x1)\\n        return (y3 - y2)*(x2 - x1) - (y2 - y1)*(x3 - x2);\\n    }\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        sort(trees.begin(), trees.end());\\n        vector<vector<int>> upper, lower;\\n        for(auto i : trees){\\n            int l = lower.size();\\n            int u = upper.size();\\n            vector<int> point = {i[0], i[1]};\\n            // calculate(p1, p2, p3) should be > 0 for valid case for upper part\\n            //     p2\\n            //     .\\n            // .         .\\n            // p1        p3\\n            while(u >= 2 && calculate(upper[u-2], upper[u-1], point) < 0){\\n                u--;\\n                upper.pop_back();\\n            }\\n            // calculate(p1, p2, p3) should be < 0 for valid case for lower part\\n            //        p1           p3\\n            //         .           .\\n            //              .\\n            //             p2\\n            while(l >= 2 && calculate(lower[l-2], lower[l-1], point) > 0){\\n                l--;\\n                lower.pop_back();\\n            }\\n            upper.push_back(point);\\n            lower.push_back(point);\\n        }\\n        set<vector<int>> st;\\n        for(auto i : upper){\\n            st.insert(i);\\n        }\\n        for(auto i : lower){\\n            st.insert(i);\\n        }\\n        vector<vector<int>> res(st.begin(), st.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int calculate(vector<int> &p1, vector<int> &p2, vector<int> &p3){\\n        int x1 = p1[0], x2 = p2[0], x3 = p3[0];\\n        int y1 = p1[1], y2 = p2[1], y3 = p3[1];\\n\\n        // m23 - m12\\n        // (y3-y2)/(x3-x2) - (y2-y1)/(x2-x1)\\n        return (y3 - y2)*(x2 - x1) - (y2 - y1)*(x3 - x2);\\n    }\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        sort(trees.begin(), trees.end());\\n        vector<vector<int>> upper, lower;\\n        for(auto i : trees){\\n            int l = lower.size();\\n            int u = upper.size();\\n            vector<int> point = {i[0], i[1]};\\n            // calculate(p1, p2, p3) should be > 0 for valid case for upper part\\n            //     p2\\n            //     .\\n            // .         .\\n            // p1        p3\\n            while(u >= 2 && calculate(upper[u-2], upper[u-1], point) < 0){\\n                u--;\\n                upper.pop_back();\\n            }\\n            // calculate(p1, p2, p3) should be < 0 for valid case for lower part\\n            //        p1           p3\\n            //         .           .\\n            //              .\\n            //             p2\\n            while(l >= 2 && calculate(lower[l-2], lower[l-1], point) > 0){\\n                l--;\\n                lower.pop_back();\\n            }\\n            upper.push_back(point);\\n            lower.push_back(point);\\n        }\\n        set<vector<int>> st;\\n        for(auto i : upper){\\n            st.insert(i);\\n        }\\n        for(auto i : lower){\\n            st.insert(i);\\n        }\\n        vector<vector<int>> res(st.begin(), st.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886658,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```java  []\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n\\n        // Sort by x asc and then by y desc\\n        Arrays.sort(trees, (p1, p2) -> {\\n            if (p1[0] == p2[0]) {\\n                return p2[1] - p1[1];\\n                // return p1[1] - p2[1];\\n            }\\n            return p1[0] - p2[0];\\n        });\\n\\n        Set<Point> res = new HashSet<>();\\n        res.add(new Point(trees[0]));\\n\\n        int n = trees.length;\\n        int i = 0;\\n        while (i != n - 1) {\\n            // find the next best slope\\n            double bestSlope = Integer.MIN_VALUE;\\n            int[] nextPoint = trees[i + 1];\\n            int jCandidate = i + 1;\\n\\n            for (int j = i + 1; j < n; j++) {\\n                double slope = calculateSlope(trees[i], trees[j]);\\n                if (slope > bestSlope) {\\n                    bestSlope = slope;\\n                    nextPoint = trees[j];\\n                    jCandidate = j;\\n                }\\n            }\\n\\n            i = jCandidate;\\n            res.add(new Point(nextPoint));\\n        }\\n\\n        // Reverse it\\n        i = n - 1;\\n        while (i != 0) {\\n            // find the next best slope\\n            double bestSlope = Integer.MIN_VALUE;\\n             int[] nextPoint = trees[i - 1];\\n            int jCandidate = i - 1;\\n\\n            for (int j = i - 1; j >= 0; j--) {\\n                double slope = calculateSlope(trees[j], trees[i]);\\n                if (slope > bestSlope) {\\n                    bestSlope = slope;\\n                    nextPoint = trees[j];\\n                    jCandidate = j;\\n                }\\n            }\\n\\n            i = jCandidate;\\n            res.add(new Point(nextPoint));\\n        }\\n\\n        return res.stream().map(p -> new int[]{p.x, p.y}).toArray(int[][]::new);\\n    }\\n\\n    private double calculateSlope(int[] p1, int[] p2) {\\n        if (p1[0] == p2[0]) { // 0 division\\n            return Integer.MIN_VALUE;\\n        }\\n        return (double) (p2[1] - p1[1]) / (double) (p2[0] - p1[0]);\\n    }\\n\\n    private static class Point {\\n        public int x;\\n        public int y;\\n\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        public Point(int[] p) {\\n            this.x = p[0];\\n            this.y = p[1];\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Point{\" +\\n                    \"x=\" + x +\\n                    \", y=\" + y +\\n                    \\'}\\';\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Point point = (Point) o;\\n            return x == point.x && y == point.y;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(x, y);\\n        }\\n    }\\n}\\n```\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java  []\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n\\n        // Sort by x asc and then by y desc\\n        Arrays.sort(trees, (p1, p2) -> {\\n            if (p1[0] == p2[0]) {\\n                return p2[1] - p1[1];\\n                // return p1[1] - p2[1];\\n            }\\n            return p1[0] - p2[0];\\n        });\\n\\n        Set<Point> res = new HashSet<>();\\n        res.add(new Point(trees[0]));\\n\\n        int n = trees.length;\\n        int i = 0;\\n        while (i != n - 1) {\\n            // find the next best slope\\n            double bestSlope = Integer.MIN_VALUE;\\n            int[] nextPoint = trees[i + 1];\\n            int jCandidate = i + 1;\\n\\n            for (int j = i + 1; j < n; j++) {\\n                double slope = calculateSlope(trees[i], trees[j]);\\n                if (slope > bestSlope) {\\n                    bestSlope = slope;\\n                    nextPoint = trees[j];\\n                    jCandidate = j;\\n                }\\n            }\\n\\n            i = jCandidate;\\n            res.add(new Point(nextPoint));\\n        }\\n\\n        // Reverse it\\n        i = n - 1;\\n        while (i != 0) {\\n            // find the next best slope\\n            double bestSlope = Integer.MIN_VALUE;\\n             int[] nextPoint = trees[i - 1];\\n            int jCandidate = i - 1;\\n\\n            for (int j = i - 1; j >= 0; j--) {\\n                double slope = calculateSlope(trees[j], trees[i]);\\n                if (slope > bestSlope) {\\n                    bestSlope = slope;\\n                    nextPoint = trees[j];\\n                    jCandidate = j;\\n                }\\n            }\\n\\n            i = jCandidate;\\n            res.add(new Point(nextPoint));\\n        }\\n\\n        return res.stream().map(p -> new int[]{p.x, p.y}).toArray(int[][]::new);\\n    }\\n\\n    private double calculateSlope(int[] p1, int[] p2) {\\n        if (p1[0] == p2[0]) { // 0 division\\n            return Integer.MIN_VALUE;\\n        }\\n        return (double) (p2[1] - p1[1]) / (double) (p2[0] - p1[0]);\\n    }\\n\\n    private static class Point {\\n        public int x;\\n        public int y;\\n\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        public Point(int[] p) {\\n            this.x = p[0];\\n            this.y = p[1];\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Point{\" +\\n                    \"x=\" + x +\\n                    \", y=\" + y +\\n                    \\'}\\';\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Point point = (Point) o;\\n            return x == point.x && y == point.y;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(x, y);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853564,
                "title": "erect-the-fence-convex-hull-algorithm-c-detailed-explanation",
                "content": "\\n# **Description:**\\n\\n\\uD83C\\uDF33 Check out my C++ solution for the \"Erect the Fence\" problem on LeetCode!\\n\\uD83D\\uDD0D The challenge is to find the convex hull of a set of points representing trees.\\n\\uD83D\\uDCD0 I\\'ve implemented the Convex Hull algorithm to solve this problem efficiently.\\n# **Approach:**\\n\\n\\uD83D\\uDD04 Sort the given points in ascending order based on their x-coordinate.\\n\\uD83D\\uDD04 In case of a tie in x-coordinates, sort them based on their y-coordinate.\\n\\u23E9 This ensures a counter-clockwise order of points, vital for finding the convex hull.\\n\\uD83E\\uDDED Use the check() function to determine if a given point is inside the convex hull.\\n\\uD83E\\uDDED check() calculates the cross product of three points and checks if it\\'s negative.\\n\\uD83D\\uDD04 If negative, the third point is outside the convex hull, so pop the last point from the answer list.\\n\\uD83D\\uDCDD The outerTrees() function finds the convex hull using a stack-like approach.\\n\\uD83D\\uDCDD It scans from left to right to find the upper part of the convex hull.\\n\\uD83D\\uDD04 Then, it reverses the list and scans from right to left to find the lower part.\\n\\uD83C\\uDFAF This ensures that we have the complete convex hull.\\n## **Time Complexity:**\\n\\n\\u23F0 O(n log n) due to the sorting step.\\n\\u23F0 The stack-like traversal to find the convex hull takes linear time.\\n# **Conclusion:**\\n\\n\\uD83C\\uDF89 I hope you find this solution helpful for solving the \"Erect the Fence\" problem!\\n\\uD83D\\uDCAC Feel free to comment if you have any questions or suggestions for improvement.\\n\\uD83D\\uDE80 Happy coding and have fun solving LeetCode challenges! \\uD83D\\uDE0A\\nBest regards,\\n# **VIVEK JAIN**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   static bool cmp(vector<int> &a,vector<int> &b){\\n       return a[0]<b[0] || ( a[0]==b[0]&&a[1]<b[1]);\\n   }\\n   bool check(vector<int> &a,vector<int> &b,vector<int> &c){\\n       return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])<0;\\n   }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        sort(trees.begin(),trees.end(),cmp); // SORTING USING COMPARATOR\\n        vector<vector<int>> ans; int n=trees.size();\\n        for(int i=0;i<n;i++){\\n            while(ans.size()>1 && check(ans[ans.size()-2],ans[ans.size()-1],trees[i])){\\n                ans.pop_back();\\n            }\\n            ans.push_back(trees[i]);\\n        }\\n        if(ans.size()==n) return ans;\\n        for(int i=n-2;i>=0;i--){\\n            while(ans.size()>1 && check(ans[ans.size()-2],ans[ans.size()-1],trees[i])){\\n                ans.pop_back();\\n            }\\n            ans.push_back(trees[i]);\\n        }\\n        ans.pop_back(); // TO AVOID REPETITION OF THE FIRST COORDINATE \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   static bool cmp(vector<int> &a,vector<int> &b){\\n       return a[0]<b[0] || ( a[0]==b[0]&&a[1]<b[1]);\\n   }\\n   bool check(vector<int> &a,vector<int> &b,vector<int> &c){\\n       return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])<0;\\n   }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        sort(trees.begin(),trees.end(),cmp); // SORTING USING COMPARATOR\\n        vector<vector<int>> ans; int n=trees.size();\\n        for(int i=0;i<n;i++){\\n            while(ans.size()>1 && check(ans[ans.size()-2],ans[ans.size()-1],trees[i])){\\n                ans.pop_back();\\n            }\\n            ans.push_back(trees[i]);\\n        }\\n        if(ans.size()==n) return ans;\\n        for(int i=n-2;i>=0;i--){\\n            while(ans.size()>1 && check(ans[ans.size()-2],ans[ans.size()-1],trees[i])){\\n                ans.pop_back();\\n            }\\n            ans.push_back(trees[i]);\\n        }\\n        ans.pop_back(); // TO AVOID REPETITION OF THE FIRST COORDINATE \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812976,
                "title": "the-most-shitty-solution-200-lines-only-passing-the-cases",
                "content": "# Intuition\\nI start by finding the vertices of the trees (up_l, up_r, dw_l, dw_r, lft_u, lft_d, rt_u, rt_d), then compare ways of connecting them by their slope. Once a corner is solved, those points used are added to the output.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nNo specific approach.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def outerTrees(self, trees: list[list[int]]) -> list[list[int]]:\\n        output = []\\n        up, down, left, right = trees[0], trees[0], trees[0], trees[0]\\n        up_cord, down_cord, right_cord, left_cord = None, None, None, None\\n        for t in trees:\\n            if t[1] >= up[1]:\\n                up_cord = t[1]\\n                up = t\\n            if t[1] <= down[1]:\\n                down_cord = t[1]\\n                down = t\\n            if t[0] >= right[0]:\\n                right_cord = t[0]\\n                right = t\\n            if t[0] <= left[0]:\\n                left_cord = t[0]\\n                left = t\\n\\n        up_l, up_r, dw_l, dw_r, lft_u, lft_d, rt_u, rt_d = None, None, None, None, None, None, None, None\\n        for t in trees:\\n            if t[1] == up_cord:\\n                if t not in output:\\n                    output.append(t)\\n                if not up_l:\\n                    if t[0] <= up[0]:\\n                        up_l = t\\n                elif t[0] <= up_l[0]:\\n                    up_l = t\\n                if not up_r:\\n                    if t[0] >= up[0]:\\n                        up_r = t\\n                elif t[0] >= up_r[0]:\\n                    up_r = t\\n\\n        for t in trees:\\n            if t[1] == down_cord:\\n                if t not in output:\\n                    output.append(t)\\n                if not dw_l:\\n                    if t[0] <= down[0]:\\n                        dw_l = t\\n                elif t[0] <= dw_l[0]:\\n                    dw_l = t\\n                if not dw_r:\\n                    if t[0] >= down[0]:\\n                        dw_r = t\\n                elif t[0] >= dw_r[0]:\\n                    dw_r = t\\n        for t in trees:\\n            if t[0] == left_cord:\\n                if t not in output:\\n                    output.append(t)\\n                if not lft_u:\\n                    if t[1] >= left[1]:\\n                        lft_u = t\\n                elif t[1] >= lft_u[1]:\\n                    lft_u = t\\n                if not lft_d: #ignoring the bug caused by [0,0] == false, while as setting [0,0] must be a vertex\\n                    if t[1] <= left[1]:\\n                        lft_d = t\\n                elif t[1] <= lft_d[1]:\\n                    lft_d = t\\n        for t in trees:\\n            if t[0] == right_cord:\\n                if t not in output:\\n                    output.append(t)\\n                if not rt_u:\\n                    if t[1] >= right[1]:\\n                        rt_u = t\\n                elif t[1] >= rt_u[1]:\\n                    rt_u = t\\n                if not rt_d:\\n                    if t[1] <= right[1]:\\n                        rt_d = t\\n                elif t[1] <= rt_d[1]:\\n                    rt_d = t\\n\\n        # print(up_l, up_r, dw_l, dw_r, lft_u, lft_d, rt_u, rt_d)\\n\\n        top_left, top_right, down_left, down_right = [], [], [], []\\n        for i in trees:\\n            if i not in output:\\n                if lft_u[0] <= i[0] <= up_l[0] and lft_u[1] <= i[1] <= up_l[1]:\\n                    top_left.append(i)\\n                if up_r[0] <= i[0] <= rt_u[0] and rt_u[1] <= i[1] <= up_r[1]:\\n                    top_right.append(i)\\n                if lft_d[0] <= i[0] <= dw_l[0] and lft_d[1] >= i[1] >= dw_l[1]:\\n                    down_left.append(i)\\n                if dw_r[0] <= i[0] <= rt_d[0] and dw_r[1] <= i[1] <= rt_d[1]:\\n                    down_right.append(i)\\n\\n        down_right.sort()\\n        down_left.sort()\\n        top_left.sort()\\n        top_right.sort()\\n\\n        # treat top left corner\\n        start, end = up_l, lft_u\\n        end_get = []\\n        if start is not end and (start[1] - end[1]) != 0:\\n            tan = (start[0] - end[0]) / (start[1] - end[1])\\n            while True:\\n                for j in top_left:\\n                    if j not in output and (start[1] - j[1]) != 0:\\n                        new_tan = (start[0] - j[0]) / (start[1] - j[1])\\n                        if start[0] - j[0] >= 0 and new_tan > tan:\\n                            tan = new_tan\\n                            end = j\\n                            end_get = [end]\\n                        elif start[0] - j[0] >= 0 and new_tan == tan:\\n                            if not end_get:\\n                                end = j\\n                            end_get.append(j)\\n                if end != lft_u or len(end_get) > 1:\\n                    output.extend(end_get)\\n                    end_get = []\\n                    start, end = end, lft_u\\n                    if (start[1] - end[1]) != 0: tan = (start[0] - end[0]) / (start[1] - end[1])\\n                else:\\n                    break\\n\\n        # treat top right corner\\n        start, end = up_r, rt_u\\n        end_get = []\\n        if start is not end and (start[1] - end[1]) != 0:\\n            tan = (end[0] - start[0]) / (start[1] - end[1])\\n            while True:\\n                for j in top_right:\\n                    if j not in output and (start[1] - j[1]) != 0:\\n                        new_tan = (j[0] - start[0]) / (start[1] - j[1])\\n                        if j[0] - start[0] >= 0 and new_tan > tan:\\n                            tan = new_tan\\n                            end = j\\n                            end_get = [end]\\n                        if j[0] - start[0] >= 0 and new_tan == tan:\\n                            if not end_get:\\n                                end = j\\n                            end_get.append(j)\\n                if end != rt_u or len(end_get) > 1:\\n                    output.extend(end_get)\\n                    end_get = []\\n                    start, end = end, rt_u\\n                    if (start[1] - end[1]) != 0: tan = (end[0] - start[0]) / (start[1] - end[1])\\n                else:\\n                    break\\n\\n        # treat down left corner\\n        start, end = lft_d, dw_l\\n        end_get = []\\n        if start is not end and (end[0] - start[0]) != 0:\\n            tan = (start[1] - end[1]) / (end[0] - start[0])\\n            while True:\\n                for j in down_left:\\n                    if j not in output and (j[0] - start[0]) != 0:\\n                        new_tan = (start[1] - j[1]) / (j[0] - start[0])\\n                        if start[1] - j[1] >= 0 and new_tan > tan:\\n                            tan = new_tan\\n                            end = j\\n                            end_get = [end]\\n                        elif start[1] - j[1] >= 0 and new_tan == tan:\\n                            if not end_get:\\n                                end = j\\n                            end_get.append(j)\\n                if end != dw_l or len(end_get) > 1:\\n                    output.extend(end_get)\\n                    end_get = []\\n                    start, end = end, dw_l\\n                    if (end[0] - start[0]) != 0: tan = (start[1] - end[1]) / (end[0] - start[0])\\n                else:\\n                    break\\n        # treat down right corner\\n        start, end = rt_d, dw_r\\n        end_get = []\\n        if start is not end and (start[0] - end[0]) != 0:\\n            tan = (start[1] - end[1]) / (start[0] - end[0])\\n            while True:\\n                for j in down_right:\\n                    if j not in output and (start[0] - j[0]) != 0:\\n                        new_tan = (start[1] - j[1]) / (start[0] - j[0])\\n                        if start[1] - j[1] >= 0 and new_tan > tan:\\n                            tan = new_tan\\n                            end = j\\n                            end_get = [end]\\n                        elif start[1] - j[1] >= 0 and new_tan == tan:\\n                            if not end_get:\\n                                end = j\\n                            end_get.append(j)\\n                if end != dw_r or len(end_get) > 1:\\n                    output.extend(end_get)\\n                    end_get = []\\n                    start, end = end, dw_r\\n                    if (start[0] - end[0]) != 0: tan = (start[1] - end[1]) / (start[0] - end[0])\\n                else:\\n                    break\\n        output_f = []\\n        for i in output:\\n            if i not in output_f:\\n                output_f.append(i)\\n        return output_f\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def outerTrees(self, trees: list[list[int]]) -> list[list[int]]:\\n        output = []\\n        up, down, left, right = trees[0], trees[0], trees[0], trees[0]\\n        up_cord, down_cord, right_cord, left_cord = None, None, None, None\\n        for t in trees:\\n            if t[1] >= up[1]:\\n                up_cord = t[1]\\n                up = t\\n            if t[1] <= down[1]:\\n                down_cord = t[1]\\n                down = t\\n            if t[0] >= right[0]:\\n                right_cord = t[0]\\n                right = t\\n            if t[0] <= left[0]:\\n                left_cord = t[0]\\n                left = t\\n\\n        up_l, up_r, dw_l, dw_r, lft_u, lft_d, rt_u, rt_d = None, None, None, None, None, None, None, None\\n        for t in trees:\\n            if t[1] == up_cord:\\n                if t not in output:\\n                    output.append(t)\\n                if not up_l:\\n                    if t[0] <= up[0]:\\n                        up_l = t\\n                elif t[0] <= up_l[0]:\\n                    up_l = t\\n                if not up_r:\\n                    if t[0] >= up[0]:\\n                        up_r = t\\n                elif t[0] >= up_r[0]:\\n                    up_r = t\\n\\n        for t in trees:\\n            if t[1] == down_cord:\\n                if t not in output:\\n                    output.append(t)\\n                if not dw_l:\\n                    if t[0] <= down[0]:\\n                        dw_l = t\\n                elif t[0] <= dw_l[0]:\\n                    dw_l = t\\n                if not dw_r:\\n                    if t[0] >= down[0]:\\n                        dw_r = t\\n                elif t[0] >= dw_r[0]:\\n                    dw_r = t\\n        for t in trees:\\n            if t[0] == left_cord:\\n                if t not in output:\\n                    output.append(t)\\n                if not lft_u:\\n                    if t[1] >= left[1]:\\n                        lft_u = t\\n                elif t[1] >= lft_u[1]:\\n                    lft_u = t\\n                if not lft_d: #ignoring the bug caused by [0,0] == false, while as setting [0,0] must be a vertex\\n                    if t[1] <= left[1]:\\n                        lft_d = t\\n                elif t[1] <= lft_d[1]:\\n                    lft_d = t\\n        for t in trees:\\n            if t[0] == right_cord:\\n                if t not in output:\\n                    output.append(t)\\n                if not rt_u:\\n                    if t[1] >= right[1]:\\n                        rt_u = t\\n                elif t[1] >= rt_u[1]:\\n                    rt_u = t\\n                if not rt_d:\\n                    if t[1] <= right[1]:\\n                        rt_d = t\\n                elif t[1] <= rt_d[1]:\\n                    rt_d = t\\n\\n        # print(up_l, up_r, dw_l, dw_r, lft_u, lft_d, rt_u, rt_d)\\n\\n        top_left, top_right, down_left, down_right = [], [], [], []\\n        for i in trees:\\n            if i not in output:\\n                if lft_u[0] <= i[0] <= up_l[0] and lft_u[1] <= i[1] <= up_l[1]:\\n                    top_left.append(i)\\n                if up_r[0] <= i[0] <= rt_u[0] and rt_u[1] <= i[1] <= up_r[1]:\\n                    top_right.append(i)\\n                if lft_d[0] <= i[0] <= dw_l[0] and lft_d[1] >= i[1] >= dw_l[1]:\\n                    down_left.append(i)\\n                if dw_r[0] <= i[0] <= rt_d[0] and dw_r[1] <= i[1] <= rt_d[1]:\\n                    down_right.append(i)\\n\\n        down_right.sort()\\n        down_left.sort()\\n        top_left.sort()\\n        top_right.sort()\\n\\n        # treat top left corner\\n        start, end = up_l, lft_u\\n        end_get = []\\n        if start is not end and (start[1] - end[1]) != 0:\\n            tan = (start[0] - end[0]) / (start[1] - end[1])\\n            while True:\\n                for j in top_left:\\n                    if j not in output and (start[1] - j[1]) != 0:\\n                        new_tan = (start[0] - j[0]) / (start[1] - j[1])\\n                        if start[0] - j[0] >= 0 and new_tan > tan:\\n                            tan = new_tan\\n                            end = j\\n                            end_get = [end]\\n                        elif start[0] - j[0] >= 0 and new_tan == tan:\\n                            if not end_get:\\n                                end = j\\n                            end_get.append(j)\\n                if end != lft_u or len(end_get) > 1:\\n                    output.extend(end_get)\\n                    end_get = []\\n                    start, end = end, lft_u\\n                    if (start[1] - end[1]) != 0: tan = (start[0] - end[0]) / (start[1] - end[1])\\n                else:\\n                    break\\n\\n        # treat top right corner\\n        start, end = up_r, rt_u\\n        end_get = []\\n        if start is not end and (start[1] - end[1]) != 0:\\n            tan = (end[0] - start[0]) / (start[1] - end[1])\\n            while True:\\n                for j in top_right:\\n                    if j not in output and (start[1] - j[1]) != 0:\\n                        new_tan = (j[0] - start[0]) / (start[1] - j[1])\\n                        if j[0] - start[0] >= 0 and new_tan > tan:\\n                            tan = new_tan\\n                            end = j\\n                            end_get = [end]\\n                        if j[0] - start[0] >= 0 and new_tan == tan:\\n                            if not end_get:\\n                                end = j\\n                            end_get.append(j)\\n                if end != rt_u or len(end_get) > 1:\\n                    output.extend(end_get)\\n                    end_get = []\\n                    start, end = end, rt_u\\n                    if (start[1] - end[1]) != 0: tan = (end[0] - start[0]) / (start[1] - end[1])\\n                else:\\n                    break\\n\\n        # treat down left corner\\n        start, end = lft_d, dw_l\\n        end_get = []\\n        if start is not end and (end[0] - start[0]) != 0:\\n            tan = (start[1] - end[1]) / (end[0] - start[0])\\n            while True:\\n                for j in down_left:\\n                    if j not in output and (j[0] - start[0]) != 0:\\n                        new_tan = (start[1] - j[1]) / (j[0] - start[0])\\n                        if start[1] - j[1] >= 0 and new_tan > tan:\\n                            tan = new_tan\\n                            end = j\\n                            end_get = [end]\\n                        elif start[1] - j[1] >= 0 and new_tan == tan:\\n                            if not end_get:\\n                                end = j\\n                            end_get.append(j)\\n                if end != dw_l or len(end_get) > 1:\\n                    output.extend(end_get)\\n                    end_get = []\\n                    start, end = end, dw_l\\n                    if (end[0] - start[0]) != 0: tan = (start[1] - end[1]) / (end[0] - start[0])\\n                else:\\n                    break\\n        # treat down right corner\\n        start, end = rt_d, dw_r\\n        end_get = []\\n        if start is not end and (start[0] - end[0]) != 0:\\n            tan = (start[1] - end[1]) / (start[0] - end[0])\\n            while True:\\n                for j in down_right:\\n                    if j not in output and (start[0] - j[0]) != 0:\\n                        new_tan = (start[1] - j[1]) / (start[0] - j[0])\\n                        if start[1] - j[1] >= 0 and new_tan > tan:\\n                            tan = new_tan\\n                            end = j\\n                            end_get = [end]\\n                        elif start[1] - j[1] >= 0 and new_tan == tan:\\n                            if not end_get:\\n                                end = j\\n                            end_get.append(j)\\n                if end != dw_r or len(end_get) > 1:\\n                    output.extend(end_get)\\n                    end_get = []\\n                    start, end = end, dw_r\\n                    if (start[0] - end[0]) != 0: tan = (start[1] - end[1]) / (start[0] - end[0])\\n                else:\\n                    break\\n        output_f = []\\n        for i in output:\\n            if i not in output_f:\\n                output_f.append(i)\\n        return output_f\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506058,
                "title": "using-slope-difference-and-stack",
                "content": "3 hours of my life GONE! Hope you enjoy my solution \\uD83D\\uDC80\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n        Arrays.sort(trees, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        \\n        LinkedList<Integer> stack = new LinkedList<>();\\n        for (int i = 0; i < trees.length; i++) {\\n            while (stack.size() > 1) {\\n                double m = slope(trees, stack.peekLast(), i);\\n                int curr = stack.removeLast();\\n                int prev = stack.peekLast();\\n                double pm = slope(trees, prev, curr);\\n\\n                if (m >= pm) {\\n                    stack.addLast(curr);\\n                    break;\\n                }\\n            }\\n            stack.addLast(i);\\n        }\\n\\n        LinkedList<Integer> stack2 = new LinkedList<>();\\n        for (int i = trees.length - 1; i >= 0; i--) {\\n            while (stack2.size() > 1) {\\n                double m = slope(trees, stack2.peekLast(), i);\\n                int curr = stack2.removeLast();\\n                int prev = stack2.peekLast();\\n                double pm = slope(trees, prev, curr);\\n\\n                if (m >= pm) {\\n                    stack2.addLast(curr);\\n                    break;\\n                }\\n            }\\n            stack2.addLast(i);\\n        }\\n\\n        boolean[] set = new boolean[trees.length];\\n        int count = 0;\\n        for (Integer i : stack) {\\n            count++;\\n            set[i] = true;\\n        }\\n        for (Integer i : stack2)\\n            if (!set[i]) {\\n                set[i] = true;\\n                count++;\\n            }\\n        \\n        int[][] ans = new int[count][2];\\n        for (int i = 0, j = 0; i < trees.length; i++)\\n            if (set[i])\\n                ans[j++] = trees[i];\\n\\n        return ans;\\n    }\\n\\n    private double slope(int[][] trees, int i, int j) {\\n        double m = (trees[i][1] - trees[j][1]) / ((double) (trees[i][0] - trees[j][0]));\\n        if (m == Double.NEGATIVE_INFINITY) return Double.POSITIVE_INFINITY;\\n        if (m == -0.0) return 0.0;\\n        else return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] outerTrees(int[][] trees) {\\n        Arrays.sort(trees, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        \\n        LinkedList<Integer> stack = new LinkedList<>();\\n        for (int i = 0; i < trees.length; i++) {\\n            while (stack.size() > 1) {\\n                double m = slope(trees, stack.peekLast(), i);\\n                int curr = stack.removeLast();\\n                int prev = stack.peekLast();\\n                double pm = slope(trees, prev, curr);\\n\\n                if (m >= pm) {\\n                    stack.addLast(curr);\\n                    break;\\n                }\\n            }\\n            stack.addLast(i);\\n        }\\n\\n        LinkedList<Integer> stack2 = new LinkedList<>();\\n        for (int i = trees.length - 1; i >= 0; i--) {\\n            while (stack2.size() > 1) {\\n                double m = slope(trees, stack2.peekLast(), i);\\n                int curr = stack2.removeLast();\\n                int prev = stack2.peekLast();\\n                double pm = slope(trees, prev, curr);\\n\\n                if (m >= pm) {\\n                    stack2.addLast(curr);\\n                    break;\\n                }\\n            }\\n            stack2.addLast(i);\\n        }\\n\\n        boolean[] set = new boolean[trees.length];\\n        int count = 0;\\n        for (Integer i : stack) {\\n            count++;\\n            set[i] = true;\\n        }\\n        for (Integer i : stack2)\\n            if (!set[i]) {\\n                set[i] = true;\\n                count++;\\n            }\\n        \\n        int[][] ans = new int[count][2];\\n        for (int i = 0, j = 0; i < trees.length; i++)\\n            if (set[i])\\n                ans[j++] = trees[i];\\n\\n        return ans;\\n    }\\n\\n    private double slope(int[][] trees, int i, int j) {\\n        double m = (trees[i][1] - trees[j][1]) / ((double) (trees[i][0] - trees[j][0]));\\n        if (m == Double.NEGATIVE_INFINITY) return Double.POSITIVE_INFINITY;\\n        if (m == -0.0) return 0.0;\\n        else return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458781,
                "title": "convex-hull-graham-scan-algo",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    struct pt{\\n        double x,y;\\n    };\\n\\n    static int orient(pt a, pt b, pt c){\\n        double v=a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y);\\n        if(v<0) return -1;\\n        if(v>0) return 1;\\n        return 0;\\n    }\\n\\n    static bool cw(pt a, pt b, pt c, bool in_collinear){\\n        int o=orient(a,b,c);\\n        return o<0 || (in_collinear && o==0);\\n    }\\n\\n    static bool collinear(pt a, pt b, pt c) { return orient(a,b,c)==0; }\\n\\n    vector<pt> convex_hull(vector<pt>& a, bool in_collinear=true){\\n        pt p0=*min_element(a.begin(),a.end(),[](pt a, pt b){\\n            return make_pair(a.y,a.x) < make_pair(b.y,b.x);\\n        });\\n        sort(a.begin(),a.end(), [&p0](const pt& a, const pt& b){\\n            int o=orient(p0,a,b);\\n            if(o==0)\\n                return (p0.x-a.x)*(p0.x-a.x)+(p0.y-a.y)*(p0.y-a.y) < (p0.x-b.x)*(p0.x-b.x)+(p0.y-b.y)*(p0.y-b.y);\\n            \\n            return o<0;\\n        });\\n        if(in_collinear){\\n            int i=(int)a.size()-1;\\n            while(i>=0 && collinear(p0,a[i],a.back()))\\n                i--;\\n            reverse(a.begin()+i+1,a.end());\\n        }\\n        vector<pt> st;\\n        for(int i=0; i<(int)a.size(); i++){\\n            while(st.size()>1 && !cw(st[st.size()-2],st.back(),a[i], true))\\n                st.pop_back();\\n            st.push_back(a[i]);\\n        }\\n        a=st;\\n        return st;\\n    }\\n\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        vector<pt> a;\\n        for(auto& v : trees){\\n            pt point {};\\n            point.x=v[0];\\n            point.y=v[1];\\n            a.push_back(point);\\n        }\\n        vector<pt> ans = convex_hull(a,true);\\n        vector<vector<int>> res;\\n        for(auto& x : ans){\\n            vector<int> t;\\n            t.push_back(x.x);\\n            t.push_back(x.y);\\n            res.push_back(t);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct pt{\\n        double x,y;\\n    };\\n\\n    static int orient(pt a, pt b, pt c){\\n        double v=a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y);\\n        if(v<0) return -1;\\n        if(v>0) return 1;\\n        return 0;\\n    }\\n\\n    static bool cw(pt a, pt b, pt c, bool in_collinear){\\n        int o=orient(a,b,c);\\n        return o<0 || (in_collinear && o==0);\\n    }\\n\\n    static bool collinear(pt a, pt b, pt c) { return orient(a,b,c)==0; }\\n\\n    vector<pt> convex_hull(vector<pt>& a, bool in_collinear=true){\\n        pt p0=*min_element(a.begin(),a.end(),[](pt a, pt b){\\n            return make_pair(a.y,a.x) < make_pair(b.y,b.x);\\n        });\\n        sort(a.begin(),a.end(), [&p0](const pt& a, const pt& b){\\n            int o=orient(p0,a,b);\\n            if(o==0)\\n                return (p0.x-a.x)*(p0.x-a.x)+(p0.y-a.y)*(p0.y-a.y) < (p0.x-b.x)*(p0.x-b.x)+(p0.y-b.y)*(p0.y-b.y);\\n            \\n            return o<0;\\n        });\\n        if(in_collinear){\\n            int i=(int)a.size()-1;\\n            while(i>=0 && collinear(p0,a[i],a.back()))\\n                i--;\\n            reverse(a.begin()+i+1,a.end());\\n        }\\n        vector<pt> st;\\n        for(int i=0; i<(int)a.size(); i++){\\n            while(st.size()>1 && !cw(st[st.size()-2],st.back(),a[i], true))\\n                st.pop_back();\\n            st.push_back(a[i]);\\n        }\\n        a=st;\\n        return st;\\n    }\\n\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        vector<pt> a;\\n        for(auto& v : trees){\\n            pt point {};\\n            point.x=v[0];\\n            point.y=v[1];\\n            a.push_back(point);\\n        }\\n        vector<pt> ans = convex_hull(a,true);\\n        vector<vector<int>> res;\\n        for(auto& x : ans){\\n            vector<int> t;\\n            t.push_back(x.x);\\n            t.push_back(x.y);\\n            res.push_back(t);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399186,
                "title": "587-erect-the-fence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n    hull = []\\n\\n    trees.sort(key=lambda x: (x[0], x[1]))\\n\\n    def cross(p: List[int], q: List[int], r: List[int]) -> int:\\n      return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\\n\\n    # Build lower hull: left-to-right scan\\n    for tree in trees:\\n      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:\\n        hull.pop()\\n      hull.append(tuple(tree))\\n    hull.pop()\\n\\n    # Build upper hull: right-to-left scan\\n    for tree in reversed(trees):\\n      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:\\n        hull.pop()\\n      hull.append(tuple(tree))\\n\\n    # Remove redundant elements from the stack\\n    return list(set(hull))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n    hull = []\\n\\n    trees.sort(key=lambda x: (x[0], x[1]))\\n\\n    def cross(p: List[int], q: List[int], r: List[int]) -> int:\\n      return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\\n\\n    # Build lower hull: left-to-right scan\\n    for tree in trees:\\n      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:\\n        hull.pop()\\n      hull.append(tuple(tree))\\n    hull.pop()\\n\\n    # Build upper hull: right-to-left scan\\n    for tree in reversed(trees):\\n      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:\\n        hull.pop()\\n      hull.append(tuple(tree))\\n\\n    # Remove redundant elements from the stack\\n    return list(set(hull))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348868,
                "title": "c-convex-hull-graham-scan-algorithm",
                "content": "# Intuition\\n\\n# Approach\\nGraham Scan Algorithm\\n\\n# Complexity\\nGraham Scan Algorithm time complexity: O(n log n) where, n is the number of input points.in the best and average case,and O(n^2) in the worst case.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if (n <= 1) return points;\\n        // Andrew\\'s monotone chain method || Graham Scan Algorithm\\n        sort(begin(points), end(points), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\\n        });\\n        vector<vector<int>> hull;\\n        for (int i = 0; i < n; ++i) {\\n            while (hull.size() > 1 && cross_product(hull[hull.size()-2], hull.back(), points[i]) < 0) {\\n                hull.pop_back();\\n            }\\n            hull.push_back(points[i]);\\n        }\\n \\n        if(hull.size() == n) return hull;\\n        for (int i = n-2; i >= 0; --i) {\\n            while (hull.size() > 1 && cross_product(hull[hull.size()-2], hull[hull.size()-1], points[i]) < 0) {\\n                hull.pop_back();\\n            }\\n            hull.push_back(points[i]);\\n        }\\n        hull.pop_back();\\n        return hull;\\n    }\\n    private:\\n    int64_t cross_product(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        int64_t x1 = b[0] - a[0];\\n        int64_t y1 = b[1] - a[1];\\n        int64_t x2 = c[0] - a[0];\\n        int64_t y2 = c[1] - a[1];\\n        return x1 * y2 - x2 * y1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if (n <= 1) return points;\\n        // Andrew\\'s monotone chain method || Graham Scan Algorithm\\n        sort(begin(points), end(points), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\\n        });\\n        vector<vector<int>> hull;\\n        for (int i = 0; i < n; ++i) {\\n            while (hull.size() > 1 && cross_product(hull[hull.size()-2], hull.back(), points[i]) < 0) {\\n                hull.pop_back();\\n            }\\n            hull.push_back(points[i]);\\n        }\\n \\n        if(hull.size() == n) return hull;\\n        for (int i = n-2; i >= 0; --i) {\\n            while (hull.size() > 1 && cross_product(hull[hull.size()-2], hull[hull.size()-1], points[i]) < 0) {\\n                hull.pop_back();\\n            }\\n            hull.push_back(points[i]);\\n        }\\n        hull.pop_back();\\n        return hull;\\n    }\\n    private:\\n    int64_t cross_product(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        int64_t x1 = b[0] - a[0];\\n        int64_t y1 = b[1] - a[1];\\n        int64_t x2 = c[0] - a[0];\\n        int64_t y2 = c[1] - a[1];\\n        return x1 * y2 - x2 * y1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259038,
                "title": "convex-hull-in-typescript",
                "content": "# Intuition\\nSee: https://leetcode.com/problems/erect-the-fence/solutions/1442266/a-detailed-explanation-with-diagrams-graham-scan/\\n\\n# Approach\\nConvex hull algorithm\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\ntype Point = [number, number]\\n\\n// function outerTrees(trees: number[][]): number[][] {\\nfunction outerTrees(trees: Point[]): number[][] {\\n  if (trees.length < 3) {\\n    return trees\\n  }\\n  \\n  const sortedTrees = trees.concat().sort(sortTrees)\\n  // console.debug({ sortedTrees })\\n  \\n  const lower: Point[] = []\\n  const upper: Point[] = []\\n\\n  for (const tree of sortedTrees) {\\n    while (\\n      lower.length >= 2 && \\n      cmpTrees(lower[lower.length-2], lower[lower.length-1], tree) > 0\\n    ) {\\n      // console.debug(\\'Lower pop\\')\\n      lower.pop()\\n    }\\n\\n    while (\\n      upper.length >= 2 && \\n      cmpTrees(upper[upper.length-2], upper[upper.length-1], tree) < 0\\n    ) {\\n      // console.debug(\\'Upper pop\\')\\n      upper.pop()\\n    }\\n\\n    lower.push(tree)\\n    upper.push(tree)\\n    // console.debug({ lower, upper })\\n  }\\n\\n  const solution = new Set([...lower, ...upper])\\n  // console.log({ solution })\\n  return Array.from(solution)\\n};\\n\\nfunction cmpTrees(p1: Point, p2: Point, p3: Point): number {\\n  const [x1, y1] = p1\\n  const [x2, y2] = p2\\n  const [x3, y3] = p3\\n  return ((y3 - y2) * (x2 - x1)) - ((y2 - y1) * (x3 - x2))\\n}\\n\\nfunction sortTrees(p1: Point, p2: Point): number {\\n  const [x1, y1] = p1\\n  const [x2, y2] = p2\\n  return x1 !== x2 ? x1 - x2 : y1 - y2\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Point = [number, number]\\n\\n// function outerTrees(trees: number[][]): number[][] {\\nfunction outerTrees(trees: Point[]): number[][] {\\n  if (trees.length < 3) {\\n    return trees\\n  }\\n  \\n  const sortedTrees = trees.concat().sort(sortTrees)\\n  // console.debug({ sortedTrees })\\n  \\n  const lower: Point[] = []\\n  const upper: Point[] = []\\n\\n  for (const tree of sortedTrees) {\\n    while (\\n      lower.length >= 2 && \\n      cmpTrees(lower[lower.length-2], lower[lower.length-1], tree) > 0\\n    ) {\\n      // console.debug(\\'Lower pop\\')\\n      lower.pop()\\n    }\\n\\n    while (\\n      upper.length >= 2 && \\n      cmpTrees(upper[upper.length-2], upper[upper.length-1], tree) < 0\\n    ) {\\n      // console.debug(\\'Upper pop\\')\\n      upper.pop()\\n    }\\n\\n    lower.push(tree)\\n    upper.push(tree)\\n    // console.debug({ lower, upper })\\n  }\\n\\n  const solution = new Set([...lower, ...upper])\\n  // console.log({ solution })\\n  return Array.from(solution)\\n};\\n\\nfunction cmpTrees(p1: Point, p2: Point, p3: Point): number {\\n  const [x1, y1] = p1\\n  const [x2, y2] = p2\\n  const [x3, y3] = p3\\n  return ((y3 - y2) * (x2 - x1)) - ((y2 - y1) * (x3 - x2))\\n}\\n\\nfunction sortTrees(p1: Point, p2: Point): number {\\n  const [x1, y1] = p1\\n  const [x2, y2] = p2\\n  return x1 !== x2 ? x1 - x2 : y1 - y2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3125880,
                "title": "i-didn-t-know-the-algorithms-so-i-made-a-new-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe leftmost and rightmost point(s) are guarunteed to be in the answer.\\n\\nBetween two guarunteed points, the only point that\\'s guarunteed to also be in the solution set is the one farthest away from the imaginary line between the two guarunteed points (farthest above the line if it\\'s the top of the fence, farthest below the line if it\\'s below the fence).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the points by their x-coordinates and add the leftmost and rightmost point (or points there\\'s a tie). Then search between those guarunteed points for the point farthest above the imaginary line.\\n\\nUsing basic algebra, we can find a formula for the distance a point is from the line by finding the intercepting line, then the point of intersection between the lines, and lastly the distance between the intersection and the point.\\n\\nThe imaginary line between the inital two points $$(x_{left},y_{left})$$ and $$(x_{right},y_{right})$$ is \\n$$y=m(x-x_{left})+y_{left}$$, where $$m=\\\\dfrac{y_{right}-y_{left}}{x_{right}-x_{left}}$$.\\nThe inverse line that passes through the point being tested $$(x_{test},y_{test})$$ is\\n$$y=\\\\frac{1}{m}(x-x_{test})+y_{test}$$.\\nThe x-intercept between these lines can be found by finding where the y\\'s match:\\n$$m(x-x_{left})+y_{left}=\\\\frac{1}{m}(x-x_{test})+y_{test}$$\\nthen solving for x we get\\n$$x=\\\\dfrac{-x_{test}+m\\\\cdot y_{test}+m^{2}x_{left}-m\\\\cdot y_{left}}{m^{2}-1}$$.\\nWe can get the corresponding y coordinate by simply plugging the x-intercept into either line formula:\\n$$y=m\\\\left(\\\\left(\\\\dfrac{-x_{test}+my_{test}+m^{2}x_{left}-m\\\\cdot y_{left}}{m^{2}-1}\\\\right)-x_{left}\\\\right)+y_{left}$$\\nwhich can be simplified to\\n$$y=\\\\dfrac{m^{2}y_{test}+mx_{left}-mx_{test}-y_{left}}{m^{2}-1}$$.\\nThe difference formula is just the hypotenuse of the differences-between-each-axis sides. Here, that looks like this:\\n$$d=\\\\sqrt{\\\\left(x_{test}-\\\\dfrac{m^{2}\\\\cdot x_{left}-m\\\\cdot y_{left}+m\\\\cdot y_{test}+x_{test}}{m^{2}+1}\\\\right)^{2}+\\\\left(y_{test}-\\\\dfrac{-m\\\\cdot x_{left}+m^{2}\\\\cdot y_{test}+m\\\\cdot x_{test}+y_{left}}{m^{2}+1}\\\\right)^{2}}$$\\nbut luckily that mess can be simplified down to\\n$$d=\\\\sqrt{\\\\dfrac{\\\\left(m\\\\left(x_{left}-x_{test}\\\\right)-y_{left}+y_{test}\\\\right)^{2}}{m^{2}+1}}$$.\\nWe can tweak to this formula by bringing out the numerator\\n$$d=\\\\left(m\\\\left(x_{left}-x_{test}\\\\right)-y_{left}+y_{test}\\\\right)\\\\cdot\\\\sqrt{\\\\dfrac{1}{m^{2}+1}}$$\\nwhich will make the formula compute the same thing, except the output will be negative if the test point is below the imaginary line, which in our case is very useful.\\nThe main downsize to this formula is having the compute the inverse square root at the end, but luckily since m is always the same when testing against the imaginary line, $\\\\sqrt{\\\\dfrac{1}{m^{2}+1}}$ is just a constant (positive) multiplier and we can simply take it out without our ability to find the point that\\'s farthest away.\\nAfter all that, our final formula is\\n$$d=m\\\\left(x_{left}-x_{test}\\\\right)-y_{left}+y_{test}$$.\\n\\nUsing this formula, we can test to see which point between the left and right points is farthest above the line. If there is one, add it to the answer and then do the checking again for the points between the left point and the newly added point, and the newly added point and the right point. \\n\\nAfter all possible points are added this way, do the same thing but for finding the points on the bottom (aka points farthest below the imaginary lines). After that we\\'re done!\\n\\n(The only edge cases we have to account for are cases where there are ties for the leftmost and rightmost points at the very start. In these cases, just add all the points to the answer and start searching for points between the top left and top right points, and the bottom left and bottom right points for the bottom of the fence.)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n^2)$, though usually much better.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$ for storing the sorted list and the output (although you can use the original list to store the output after it\\'s been sorted).\\n# Code\\n```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nvoid recurse(int** trees,short left,short right,int** output, int* returnSize, bool mode){\\n    if (left+1==right || trees[left][0]==trees[right][0]) return;//if no points to add, or all on a vertical line\\n    float slope=(float)(trees[right][1]-trees[left][1])/(float)(trees[right][0]-trees[left][0]);\\n    float far=(mode?-1:1);\\n    int farInd;\\n    for (short i=left+1;trees[i][0]<trees[right][0];i++){//finds tree furthest from line between tree[left] and tree[right]\\n        if (trees[i][0]==trees[left][0]) continue;//guarunteed not to add\\n        float temp=slope*(trees[left][0]-trees[i][0])-trees[left][1]+trees[i][1];//modified distance-to-line formula\\n        if ((temp>far && mode) || (temp<far && !mode)){\\n            far=temp;\\n            farInd=i;\\n        }\\n    }\\n    if ((far>=0 && mode) || (far<=0 && !mode)){//mode 1: top of rope, mode 2: bottom\\n        output[(*returnSize)++]=trees[farInd];\\n        recurse(trees,left,farInd,output,returnSize,mode);//check left of new anchor point for more anchor points\\n        recurse(trees,farInd,right,output,returnSize,mode);//check right of new anchor point\\n    }\\n}\\nint** outerTrees(int** trees, int treesSize, int* treesColSize, int* returnSize, int** returnColumnSizes){\\n    if (treesSize<3){\\n        *returnSize = treesSize;\\n        goto exitJump;//add returnColumnSizes and return\\n    }\\n    //sort array by x:\\n    int** sortedTrees=malloc(sizeof(int*) * treesSize);\\n    short countX[101]={};\\n    for (short i=0;i<treesSize;i++){\\n        countX[trees[i][0]]++;\\n    }\\n    short runningSum=0;\\n    for (short i=0;i<101;i++){\\n        if (countX[i]){\\n            countX[i]+=runningSum;\\n            runningSum=countX[i];\\n        }\\n    }\\n    for (short i=0;i<treesSize;i++){\\n        sortedTrees[--countX[trees[i][0]]]=trees[i];\\n    }\\n    //set up and call recurse\\n    if (sortedTrees[0][0]==sortedTrees[treesSize-1][0]){//if vertical line\\n        *returnSize=treesSize;\\n        goto exitJump;//add returnColumnSizes and return\\n    }\\n    trees[0]=sortedTrees[0];//the original \"trees\" list is now our output >:)\\n    trees[1]=sortedTrees[treesSize-1];\\n    *returnSize=2;\\n    short topLeft=0;//if left edge is vertical, start top of rope at top left, bottom of rope at bottom left\\n    short bottomLeft=0;\\n    short topRight=(short)treesSize-1;\\n    short bottomRight=(short)treesSize-1;\\n    for (short i=1;sortedTrees[i][0]==sortedTrees[0][0];i++){\\n        trees[(*returnSize)++]=sortedTrees[i];//add left edge (recurse() ignores b/c double counting issues)\\n        topLeft=(sortedTrees[i][1]>sortedTrees[topLeft][1]?i:topLeft);\\n        bottomLeft=(sortedTrees[i][1]<sortedTrees[bottomLeft][1]?i:bottomLeft);\\n    }\\n    for (short i=treesSize-2;sortedTrees[i][0]==sortedTrees[treesSize-1][0];i--){\\n        trees[(*returnSize)++]=sortedTrees[i];//add right edge (recurse() ignores b/c double counting issues)\\n        topRight=(sortedTrees[i][1]>sortedTrees[topRight][1]?i:topRight);\\n        bottomRight=(sortedTrees[i][1]<sortedTrees[bottomRight][1]?i:bottomRight);\\n    }\\n    recurse(sortedTrees,topLeft,topRight,trees,returnSize,1);\\n    if (*returnSize<treesSize) recurse(sortedTrees,bottomLeft,bottomRight,trees,returnSize,0);\\n    exitJump:\\n    *returnColumnSizes=malloc(*returnSize*4);\\n    wmemset(*returnColumnSizes,2,*returnSize);\\n    return trees;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nvoid recurse(int** trees,short left,short right,int** output, int* returnSize, bool mode){\\n    if (left+1==right || trees[left][0]==trees[right][0]) return;//if no points to add, or all on a vertical line\\n    float slope=(float)(trees[right][1]-trees[left][1])/(float)(trees[right][0]-trees[left][0]);\\n    float far=(mode?-1:1);\\n    int farInd;\\n    for (short i=left+1;trees[i][0]<trees[right][0];i++){//finds tree furthest from line between tree[left] and tree[right]\\n        if (trees[i][0]==trees[left][0]) continue;//guarunteed not to add\\n        float temp=slope*(trees[left][0]-trees[i][0])-trees[left][1]+trees[i][1];//modified distance-to-line formula\\n        if ((temp>far && mode) || (temp<far && !mode)){\\n            far=temp;\\n            farInd=i;\\n        }\\n    }\\n    if ((far>=0 && mode) || (far<=0 && !mode)){//mode 1: top of rope, mode 2: bottom\\n        output[(*returnSize)++]=trees[farInd];\\n        recurse(trees,left,farInd,output,returnSize,mode);//check left of new anchor point for more anchor points\\n        recurse(trees,farInd,right,output,returnSize,mode);//check right of new anchor point\\n    }\\n}\\nint** outerTrees(int** trees, int treesSize, int* treesColSize, int* returnSize, int** returnColumnSizes){\\n    if (treesSize<3){\\n        *returnSize = treesSize;\\n        goto exitJump;//add returnColumnSizes and return\\n    }\\n    //sort array by x:\\n    int** sortedTrees=malloc(sizeof(int*) * treesSize);\\n    short countX[101]={};\\n    for (short i=0;i<treesSize;i++){\\n        countX[trees[i][0]]++;\\n    }\\n    short runningSum=0;\\n    for (short i=0;i<101;i++){\\n        if (countX[i]){\\n            countX[i]+=runningSum;\\n            runningSum=countX[i];\\n        }\\n    }\\n    for (short i=0;i<treesSize;i++){\\n        sortedTrees[--countX[trees[i][0]]]=trees[i];\\n    }\\n    //set up and call recurse\\n    if (sortedTrees[0][0]==sortedTrees[treesSize-1][0]){//if vertical line\\n        *returnSize=treesSize;\\n        goto exitJump;//add returnColumnSizes and return\\n    }\\n    trees[0]=sortedTrees[0];//the original \"trees\" list is now our output >:)\\n    trees[1]=sortedTrees[treesSize-1];\\n    *returnSize=2;\\n    short topLeft=0;//if left edge is vertical, start top of rope at top left, bottom of rope at bottom left\\n    short bottomLeft=0;\\n    short topRight=(short)treesSize-1;\\n    short bottomRight=(short)treesSize-1;\\n    for (short i=1;sortedTrees[i][0]==sortedTrees[0][0];i++){\\n        trees[(*returnSize)++]=sortedTrees[i];//add left edge (recurse() ignores b/c double counting issues)\\n        topLeft=(sortedTrees[i][1]>sortedTrees[topLeft][1]?i:topLeft);\\n        bottomLeft=(sortedTrees[i][1]<sortedTrees[bottomLeft][1]?i:bottomLeft);\\n    }\\n    for (short i=treesSize-2;sortedTrees[i][0]==sortedTrees[treesSize-1][0];i--){\\n        trees[(*returnSize)++]=sortedTrees[i];//add right edge (recurse() ignores b/c double counting issues)\\n        topRight=(sortedTrees[i][1]>sortedTrees[topRight][1]?i:topRight);\\n        bottomRight=(sortedTrees[i][1]<sortedTrees[bottomRight][1]?i:bottomRight);\\n    }\\n    recurse(sortedTrees,topLeft,topRight,trees,returnSize,1);\\n    if (*returnSize<treesSize) recurse(sortedTrees,bottomLeft,bottomRight,trees,returnSize,0);\\n    exitJump:\\n    *returnColumnSizes=malloc(*returnSize*4);\\n    wmemset(*returnColumnSizes,2,*returnSize);\\n    return trees;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3012722,
                "title": "python-jarvis-scan",
                "content": "```\\nclass Solution:\\n    def outerTrees(self, points: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\\n        def angle(a, b, c):\\n            angle = (atan2(a[0]-b[0],a[1]-b[1]) - atan2(c[0]-b[0],c[1]-b[1])) * 180/pi\\n            return angle if angle < 180 else (angle - 360)\\n\\n        if len(points) < 3: return points\\n        two = first = min(points, key = lambda point: (point[0], point[1])) # get leftmost\\n        one = (two[0], two[1]+1) # doesn\\'t matter what we set it to, as long as it\\'s not equal to `two`\\n        hull = [two]\\n\\n        while True:\\n            ang = float(\\'inf\\')\\n            smallest = []\\n\\n            for three in points:\\n                if three in [one, two]:\\n                    continue\\n                \\n                a = angle(one, two, three)\\n                if a < ang:\\n                    ang = a\\n                    smallest = [three]\\n                elif a == ang:\\n                    smallest.append(three)\\n\\n            hull += smallest\\n            if smallest[0] == first: break\\n            one, two = two, smallest[0]\\n\\n        return set(tuple(h) for h in hull)\\n```\\n\\n```\\nclass Solution:\\n    def outerTrees(self, points: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\\n        def cross_prod(x, y, z):\\n            a, b, c, d, e, f = x[0], x[1], y[0], y[1], z[0], z[1]\\n            return (f-b)*(c-a) - (d-b)*(e-a)\\n\\n        if len(points) < 3: return points\\n        two = first = min(points, key = lambda point: (point[0], point[1])) # get leftmost\\n        hull = [two]\\n\\n        while True:\\n            most_counter = []\\n            i = 0\\n\\n            for three in points:\\n                if three == two:\\n                    continue\\n                if not most_counter: \\n                    most_counter = [three]\\n                    continue\\n\\n                c = cross_prod(two, three, most_counter[-1])\\n                \\n                if c > 0:\\n                    i = 0\\n                    most_counter = [three]\\n                elif c == 0:\\n                    if dist(two, most_counter[i]) < dist(two, three):\\n                        i = len(most_counter)\\n\\n                    most_counter.append(three)\\n\\n            hull += most_counter\\n            if most_counter[i] == first: break\\n            two = most_counter[i]\\n\\n        return set(tuple(h) for h in hull)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def outerTrees(self, points: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\\n        def angle(a, b, c):\\n            angle = (atan2(a[0]-b[0],a[1]-b[1]) - atan2(c[0]-b[0],c[1]-b[1])) * 180/pi\\n            return angle if angle < 180 else (angle - 360)\\n\\n        if len(points) < 3: return points\\n        two = first = min(points, key = lambda point: (point[0], point[1])) # get leftmost\\n        one = (two[0], two[1]+1) # doesn\\'t matter what we set it to, as long as it\\'s not equal to `two`\\n        hull = [two]\\n\\n        while True:\\n            ang = float(\\'inf\\')\\n            smallest = []\\n\\n            for three in points:\\n                if three in [one, two]:\\n                    continue\\n                \\n                a = angle(one, two, three)\\n                if a < ang:\\n                    ang = a\\n                    smallest = [three]\\n                elif a == ang:\\n                    smallest.append(three)\\n\\n            hull += smallest\\n            if smallest[0] == first: break\\n            one, two = two, smallest[0]\\n\\n        return set(tuple(h) for h in hull)\\n```\n```\\nclass Solution:\\n    def outerTrees(self, points: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\\n        def cross_prod(x, y, z):\\n            a, b, c, d, e, f = x[0], x[1], y[0], y[1], z[0], z[1]\\n            return (f-b)*(c-a) - (d-b)*(e-a)\\n\\n        if len(points) < 3: return points\\n        two = first = min(points, key = lambda point: (point[0], point[1])) # get leftmost\\n        hull = [two]\\n\\n        while True:\\n            most_counter = []\\n            i = 0\\n\\n            for three in points:\\n                if three == two:\\n                    continue\\n                if not most_counter: \\n                    most_counter = [three]\\n                    continue\\n\\n                c = cross_prod(two, three, most_counter[-1])\\n                \\n                if c > 0:\\n                    i = 0\\n                    most_counter = [three]\\n                elif c == 0:\\n                    if dist(two, most_counter[i]) < dist(two, three):\\n                        i = len(most_counter)\\n\\n                    most_counter.append(three)\\n\\n            hull += most_counter\\n            if most_counter[i] == first: break\\n            two = most_counter[i]\\n\\n        return set(tuple(h) for h in hull)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966285,
                "title": "covex-hull-technique-gram-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-- convex  hull is the method to fiinding the polygon around the points\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool clockwise(pair<int,int>&p1,pair<int,int>&p2,pair<int,int>&p3)\\n{\\nreturn p1.first*(p2.second-p3.second)+p2.first*(p3.second-p1.second)+p3.first*(p1.second-p2.second)>0;\\n}\\nbool anticlockwise(pair<int,int>&p1,pair<int,int>&p2,pair<int,int>&p3)\\n{\\nreturn p1.first*(p2.second-p3.second)+p2.first*(p3.second-p1.second)+p3.first*(p1.second-p2.second)<0;\\n}\\nbool collinear(pair<int,int>&p1,pair<int,int>&p2,pair<int,int>&p3)\\n{\\nreturn p1.first*(p2.second-p3.second)+p2.first*(p3.second-p1.second)+p3.first*(p1.second-p2.second)==0;\\n}\\n  // ercec tthe fence  --convex hull\\nbool cmp(pair<int,int>&p1,pair<int,int>&p2){\\n    if(p1.first==p2.first){\\n        return p1.second<p2.second; \\n    }\\n    return p1.first<p2.first;\\n}\\nvector<vector<int>>ans;\\n void convex_hull(vector<pair<int,int>>p){\\n     if(p.size()<=2)return ;\\n     sort(p.begin(),p.end());\\n     int n=p.size();\\n     auto p1=p[0];\\n     auto p2=p[n-1];\\nvector<pair<int,int>>up;\\nvector<pair<int,int>>down;\\nfor(int i=0; i<n; i++){\\n    if(i==n-1 || !anticlockwise(p1,p[i],p2) ){\\n        while(up.size()>=2 && anticlockwise(up[up.size()-2],up[up.size()-1],p[i])){\\n            up.pop_back();\\n        }\\n        up.push_back(p[i]);\\n    }\\n     if(i==n-1 || !clockwise(p1,p[i],p2) ){\\n        while(down.size()>=2 && clockwise(down[down.size()-2],down[down.size()-1],p[i])){\\n            down.pop_back();\\n        }\\n        down.push_back(p[i]);\\n    }\\n}\\nset<pair<int,int>>st;\\nfor(auto i:up){\\n    st.insert(i);\\n}\\nfor(auto i:down){\\n    st.insert(i);\\n\\n}\\n\\nfor(auto j:st){\\n    ans.push_back({j.first,j.second});\\n}\\n\\n }\\n\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        if(trees.size()<=2){\\n            return trees;\\n        }\\n        vector<pair<int,int>>p(trees.size());\\n        int j=0;\\n        for(auto i:trees){\\n            p[j++]={i[0],i[1]};\\n        }\\nconvex_hull(p);\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool clockwise(pair<int,int>&p1,pair<int,int>&p2,pair<int,int>&p3)\\n{\\nreturn p1.first*(p2.second-p3.second)+p2.first*(p3.second-p1.second)+p3.first*(p1.second-p2.second)>0;\\n}\\nbool anticlockwise(pair<int,int>&p1,pair<int,int>&p2,pair<int,int>&p3)\\n{\\nreturn p1.first*(p2.second-p3.second)+p2.first*(p3.second-p1.second)+p3.first*(p1.second-p2.second)<0;\\n}\\nbool collinear(pair<int,int>&p1,pair<int,int>&p2,pair<int,int>&p3)\\n{\\nreturn p1.first*(p2.second-p3.second)+p2.first*(p3.second-p1.second)+p3.first*(p1.second-p2.second)==0;\\n}\\n  // ercec tthe fence  --convex hull\\nbool cmp(pair<int,int>&p1,pair<int,int>&p2){\\n    if(p1.first==p2.first){\\n        return p1.second<p2.second; \\n    }\\n    return p1.first<p2.first;\\n}\\nvector<vector<int>>ans;\\n void convex_hull(vector<pair<int,int>>p){\\n     if(p.size()<=2)return ;\\n     sort(p.begin(),p.end());\\n     int n=p.size();\\n     auto p1=p[0];\\n     auto p2=p[n-1];\\nvector<pair<int,int>>up;\\nvector<pair<int,int>>down;\\nfor(int i=0; i<n; i++){\\n    if(i==n-1 || !anticlockwise(p1,p[i],p2) ){\\n        while(up.size()>=2 && anticlockwise(up[up.size()-2],up[up.size()-1],p[i])){\\n            up.pop_back();\\n        }\\n        up.push_back(p[i]);\\n    }\\n     if(i==n-1 || !clockwise(p1,p[i],p2) ){\\n        while(down.size()>=2 && clockwise(down[down.size()-2],down[down.size()-1],p[i])){\\n            down.pop_back();\\n        }\\n        down.push_back(p[i]);\\n    }\\n}\\nset<pair<int,int>>st;\\nfor(auto i:up){\\n    st.insert(i);\\n}\\nfor(auto i:down){\\n    st.insert(i);\\n\\n}\\n\\nfor(auto j:st){\\n    ans.push_back({j.first,j.second});\\n}\\n\\n }\\n\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        if(trees.size()<=2){\\n            return trees;\\n        }\\n        vector<pair<int,int>>p(trees.size());\\n        int j=0;\\n        for(auto i:trees){\\n            p[j++]={i[0],i[1]};\\n        }\\nconvex_hull(p);\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965629,
                "title": "c-divide-and-conquer-method-o-n-on-average",
                "content": "Runtime: 40 ms, faster than 99.80% of C++ online submissions for Erect the Fence.\\nMemory Usage: 22 MB, less than 84.55% of C++ online submissions for Erect the Fence.\\nhttps://leetcode.com/submissions/detail/867296904/\\nThe time complexity is O(N) because it is equal to (1 + 2/3 + (2/3)^2 +....)*N = 3N.\\n\\nIdea:\\n1. for two boundary points and the points set locating on the one side of the line that consists of that two boundary points, we can find one new boundary point from that points set by picking the fartherest distance from that line.\\n2. for the new boundary point and old two boundary points, we can get a triangle and divide the plane into 3 valid parts (actually it is 5 parts but the rest 2 areas, one is empty and the other is considered). For the inner part inside of that triangle, they are not boundary points so filter those points. For the rest two parts, recursively sovle these two areas.\\n3. The time complexity on average is O(N) = (1 + 2/3 + (2/3)^2 +....)*N = 3N\\n4. This is the first linear solution I\\'ve ever seen. So it beats 99.8%\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        if (trees.size() <= 3) return trees;\\n        int min_i = 0, min_v = trees[0][0], max_i = 0, max_v = trees[0][0];\\n        for (int i = 1; i < trees.size(); ++i) {\\n            if (trees[i][0] > max_v) {\\n                max_i = i;\\n                max_v = trees[i][0];\\n            }\\n            if (trees[i][0] < min_v) {\\n                min_i = i;\\n                min_v = trees[i][0];\\n            }\\n        }\\n        vector<int> record = {min_i, max_i};\\n        \\n        auto crossprodByIndex = [&](int a, int b, int c) {\\n            // ca x cb\\n            int x1 = trees[a][0] - trees[c][0], y1 = trees[a][1] - trees[c][1];\\n            int x2 = trees[b][0] - trees[c][0], y2 = trees[b][1] - trees[c][1];\\n            return x1*y2 - y1 * x2;\\n        };\\n\\n        auto inSide = [&](int a, int b, int c, int t) {\\n            int flag0 = crossprodByIndex(a, b, t);\\n            int flag1 = crossprodByIndex(b, c, t);\\n            int flag2 = crossprodByIndex(c, a, t);\\n            if (flag0 * flag1 > 0 && flag2 * flag1 > 0) return 1;\\n            if (flag0 == 0 || flag1 == 0 || flag2 == 0) return 0;\\n            return -1;\\n        };\\n        function<void(int, int, int, vector<int>&)> triangle = [&](int a, int b, int c, vector<int>& collections) {\\n            if (collections.empty()) return;\\n            // a---c, b---c\\n            vector<int> ac0, bc0, ac, bc;\\n            for (auto& e : collections) {\\n                int val =  inSide(a, b, c, e);\\n                if ( val <= 0) {\\n                    if (val == 0) {\\n                        if (crossprodByIndex(a, c, e) == 0) {\\n                            ac0.push_back(e);\\n                        } else {\\n                            bc0.push_back(e);\\n                        }\\n                    } else {\\n                        if (crossprodByIndex(a, c, e) * crossprodByIndex(a, c, b) < 0) {\\n                            ac.push_back(e);\\n                        } else {\\n                            bc.push_back(e);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            \\n            auto helper = [&](vector<int>& ac0, vector<int>& ac, int a, int c) {\\n                if (ac.empty()) {\\n                    for (auto& e: ac0) record.push_back(e);\\n                } else {\\n                    int val = abs(crossprodByIndex(a, c, ac[0])), max_i = ac[0];\\n                    for (int i = 1; i < ac.size(); ++i) {\\n                        if (val < abs(crossprodByIndex(a, c, ac[i]))) {\\n                            max_i = ac[i]; val = abs(crossprodByIndex(a, c, ac[i]));\\n                        }\\n                    }\\n                    record.push_back(max_i);\\n                    ac.erase(remove(ac.begin(), ac.end(), max_i), ac.end());\\n                    triangle(a, c, max_i, ac);\\n                }\\n            };\\n            helper(ac0, ac, a, c);\\n            helper(bc0, bc, b, c);\\n        };\\n        \\n        function<void(int, int, vector<int>&)> partition = [&] (int i, int j, vector<int>& collections) {\\n            if (collections.empty()) return;\\n            vector<int> pos, neg, zero;// index, area\\n            int max_pos_area = 0, max_neg_area = 0;// val \\n            int max_pos_area_i = 0, max_neg_area_i = 0;// index\\n            auto seperate = [](vector<int>& pos, int& mpa, int& mpai, int val, int e) {\\n                pos.push_back(e);\\n                if (mpa < val) {\\n                    mpa = val;\\n                    mpai = e;\\n                }\\n            };\\n            for (auto& e : collections) {\\n                int val = crossprodByIndex(i, j, e);\\n                if (val > 0) {\\n                    seperate(pos, max_pos_area, max_pos_area_i, val, e);\\n                } else if (val < 0) {\\n                    seperate(neg, max_neg_area, max_neg_area_i, -val, e);\\n                } else zero.push_back(e);\\n            }\\n            auto helper = [&](vector<int>& neg, int maxArea) {\\n                if (neg.empty()) return;\\n                record.push_back(maxArea);\\n                neg.erase(remove(neg.begin(), neg.end(), maxArea), neg.end());\\n                triangle(i, j, maxArea, neg);\\n            };\\n            if (pos.empty()) {\\n                for (auto& e : zero) record.push_back(e);\\n                helper(neg, max_neg_area_i);\\n            } else if (neg.empty()) {\\n                for (auto& e : zero) record.push_back(e);\\n                helper(pos, max_pos_area_i);\\n            } else {\\n                helper(pos, max_pos_area_i);\\n                helper(neg, max_neg_area_i);\\n            }\\n        };\\n        vector<int> collections;\\n        for (int i = 0; i < trees.size(); ++i) {\\n            if (i == min_i || i == max_i) continue;\\n            collections.push_back(i);\\n        }\\n        partition(min_i, max_i, collections);\\n        vector<vector<int>> ret;\\n        for (auto& i : record) {\\n            ret.push_back(trees[i]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        if (trees.size() <= 3) return trees;\\n        int min_i = 0, min_v = trees[0][0], max_i = 0, max_v = trees[0][0];\\n        for (int i = 1; i < trees.size(); ++i) {\\n            if (trees[i][0] > max_v) {\\n                max_i = i;\\n                max_v = trees[i][0];\\n            }\\n            if (trees[i][0] < min_v) {\\n                min_i = i;\\n                min_v = trees[i][0];\\n            }\\n        }\\n        vector<int> record = {min_i, max_i};\\n        \\n        auto crossprodByIndex = [&](int a, int b, int c) {\\n            // ca x cb\\n            int x1 = trees[a][0] - trees[c][0], y1 = trees[a][1] - trees[c][1];\\n            int x2 = trees[b][0] - trees[c][0], y2 = trees[b][1] - trees[c][1];\\n            return x1*y2 - y1 * x2;\\n        };\\n\\n        auto inSide = [&](int a, int b, int c, int t) {\\n            int flag0 = crossprodByIndex(a, b, t);\\n            int flag1 = crossprodByIndex(b, c, t);\\n            int flag2 = crossprodByIndex(c, a, t);\\n            if (flag0 * flag1 > 0 && flag2 * flag1 > 0) return 1;\\n            if (flag0 == 0 || flag1 == 0 || flag2 == 0) return 0;\\n            return -1;\\n        };\\n        function<void(int, int, int, vector<int>&)> triangle = [&](int a, int b, int c, vector<int>& collections) {\\n            if (collections.empty()) return;\\n            // a---c, b---c\\n            vector<int> ac0, bc0, ac, bc;\\n            for (auto& e : collections) {\\n                int val =  inSide(a, b, c, e);\\n                if ( val <= 0) {\\n                    if (val == 0) {\\n                        if (crossprodByIndex(a, c, e) == 0) {\\n                            ac0.push_back(e);\\n                        } else {\\n                            bc0.push_back(e);\\n                        }\\n                    } else {\\n                        if (crossprodByIndex(a, c, e) * crossprodByIndex(a, c, b) < 0) {\\n                            ac.push_back(e);\\n                        } else {\\n                            bc.push_back(e);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            \\n            auto helper = [&](vector<int>& ac0, vector<int>& ac, int a, int c) {\\n                if (ac.empty()) {\\n                    for (auto& e: ac0) record.push_back(e);\\n                } else {\\n                    int val = abs(crossprodByIndex(a, c, ac[0])), max_i = ac[0];\\n                    for (int i = 1; i < ac.size(); ++i) {\\n                        if (val < abs(crossprodByIndex(a, c, ac[i]))) {\\n                            max_i = ac[i]; val = abs(crossprodByIndex(a, c, ac[i]));\\n                        }\\n                    }\\n                    record.push_back(max_i);\\n                    ac.erase(remove(ac.begin(), ac.end(), max_i), ac.end());\\n                    triangle(a, c, max_i, ac);\\n                }\\n            };\\n            helper(ac0, ac, a, c);\\n            helper(bc0, bc, b, c);\\n        };\\n        \\n        function<void(int, int, vector<int>&)> partition = [&] (int i, int j, vector<int>& collections) {\\n            if (collections.empty()) return;\\n            vector<int> pos, neg, zero;// index, area\\n            int max_pos_area = 0, max_neg_area = 0;// val \\n            int max_pos_area_i = 0, max_neg_area_i = 0;// index\\n            auto seperate = [](vector<int>& pos, int& mpa, int& mpai, int val, int e) {\\n                pos.push_back(e);\\n                if (mpa < val) {\\n                    mpa = val;\\n                    mpai = e;\\n                }\\n            };\\n            for (auto& e : collections) {\\n                int val = crossprodByIndex(i, j, e);\\n                if (val > 0) {\\n                    seperate(pos, max_pos_area, max_pos_area_i, val, e);\\n                } else if (val < 0) {\\n                    seperate(neg, max_neg_area, max_neg_area_i, -val, e);\\n                } else zero.push_back(e);\\n            }\\n            auto helper = [&](vector<int>& neg, int maxArea) {\\n                if (neg.empty()) return;\\n                record.push_back(maxArea);\\n                neg.erase(remove(neg.begin(), neg.end(), maxArea), neg.end());\\n                triangle(i, j, maxArea, neg);\\n            };\\n            if (pos.empty()) {\\n                for (auto& e : zero) record.push_back(e);\\n                helper(neg, max_neg_area_i);\\n            } else if (neg.empty()) {\\n                for (auto& e : zero) record.push_back(e);\\n                helper(pos, max_pos_area_i);\\n            } else {\\n                helper(pos, max_pos_area_i);\\n                helper(neg, max_neg_area_i);\\n            }\\n        };\\n        vector<int> collections;\\n        for (int i = 0; i < trees.size(); ++i) {\\n            if (i == min_i || i == max_i) continue;\\n            collections.push_back(i);\\n        }\\n        partition(min_i, max_i, collections);\\n        vector<vector<int>> ret;\\n        for (auto& i : record) {\\n            ret.push_back(trees[i]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928228,
                "title": "some-dawg-shit-code",
                "content": "```\\n#include <vector>\\n#include <iostream>\\n#include <assert.h>\\n#include <algorithm>\\n#include <math.h>\\n#include <unordered_set>\\n\\n// Compile and run with\\n// rm -rf && clang++ convex_hull.cc -std=c++11 -stdlib=libc++ && ./a.out\\n//\\n// add `-Weverything` as in `clang++ convex_hull.cc -std=c++11 -stdlib=libc++ -Weverything`\\n// to make this give you helpful warnings (though a lot of them are not helpful)\\nusing namespace std;\\n\\n// Slow (and in theory also fast, but haven\\'t finished yet) convex hull\\n\\n// For numerical issues and testing\\nstruct Float {\\n    double v;\\n    Float(double u) { v = u; }\\n    Float(const Float& u) { v = u.v; }\\n\\n    #define EPS 0.000000000001\\n    bool operator ==(const Float& u) const { return abs(v - u.v) < EPS; }\\n    bool operator !=(const Float& u) const { return !(*this == u); }\\n    Float operator +(const Float& u) const{ return Float(v + u.v); }\\n    Float operator -(const Float& u) const{ return Float(v - u.v); }\\n    Float operator *(const Float& u) const{ return Float(v * u.v); }\\n    Float operator /(const Float& u) const{ return Float(v / u.v); }\\n    bool operator >(const Float& u) const { return v > u.v; }\\n    bool operator >=(const Float& u) const { return v >= u.v; }\\n    bool operator <(const Float& u) const { return v < u.v; }\\n    bool operator <=(const Float& u) const { return v <= u.v; }\\n    bool operator =(const Float& u) { return v = u.v; }\\n    \\n};\\n\\nstruct Point_t {\\n    Float x;\\n    Float y;\\n    const bool operator ==(const struct Point_t& p) const { return x == p.x && y == p.y; }\\n};\\n\\nstruct Vec_t {\\n    Float x;\\n    Float y;\\n    const bool operator ==(const struct Vec_t& v) const { return x == v.x && y == v.y; }\\n};\\n\\ntypedef struct Point_t Point;\\n// Debugging helper\\nvoid print_point_vector(vector<Point>& hull) {\\n    for (auto& p : hull) cout << \"(\" << p.x.v << \", \" << p.y.v << \") \";\\n    cout << \"\\\\n\";\\n}\\n\\nnamespace std {\\n    template<>\\n    struct hash<Point> {\\n        size_t operator()(const Point &p) const {\\n            return hash<double>()(p.x.v) ^ hash<double>()(p.y.v);\\n        }\\n    };\\n}\\n\\n\\ntypedef struct Vec_t Vec;\\n\\ntypedef int Quadrant;\\n#define I 1\\n#define II 2\\n#define III 3\\n#define IV 4\\n\\n\\n// Identifier for quadrants. Importantly, everything on a vertical or horizontal slope\\n// gets assigned to the quadrant that it ENDS because that way we just want the slope\\n// to always get more positive.\\n// RETURN\\n//  - A quadrant that is numerated in a mod-4 fashion such that\\n//  - until you loop there is an ordering of the quadrants where\\n//  - if you go to the lower quadrant above you, you are rotating less\\nstatic inline Quadrant quadrant(Vec v) {\\n    if (v.x >= 0 && v.y > 0) return I;\\n    if (v.x < 0 && v.y >= 0) return II;\\n    if (v.x <= 0 && v.y < 0) return III;\\n    return IV;\\n}\\n\\n// Get an ordering of the changes in quadrants from less costly to more costly\\n// RETURN\\n//  - The difference in quadrants (counting in a circle) in number of steps\\nstatic inline int quadrant_diff(Quadrant q1, Quadrant q2) {\\n    int d = q2 - q1;\\n    if (d < 0) d += 4;\\n    return d;\\n}\\n\\n// RETURN\\n//  - Vector from diff of two points\\nstatic inline Vec point_diff(Point p1, Point p2) {\\n    return Vec{p1.x - p2.x, p1.y - p2.y};\\n}\\n\\n// RETURN\\n//  - The dot product of two vectors\\nstatic inline Float dot(Vec v, Vec u) {\\n    return v.x * u.x + v.y * u.y;\\n}\\n// RETURN\\n//  - The squared norm (euclidean) of a vector\\nstatic inline Float norm2(Vec v) {\\n    return v.x * v.x + v.y * v.y;\\n}\\n\\n// RETURN\\n//  - Whether two vectors have the same heading\\n// (assuming they are in the same quadrant)\\nstatic inline bool same_direction(Vec v, Vec u) {\\n    Float d = dot(v, u);\\n    // In the case of d = 0 they can only be in the same direction if it is\\n    // the zero vector. This is an edge case which won\\'t occur, but it will pass.\\n    return d * d == norm2(v) * norm2(u) && d >= 0;\\n}\\n\\n\\n// RETURN\\n//  - Whether the beater_traj has more negative slope or not than loser_traj\\n// NOTE: that is not vector, it is SLOPE (so it is assumed that you are in the same quadrant)\\nstatic inline bool beats_more_neg_slope(Vec beater_traj, Vec loser_traj){\\n    if (same_direction(beater_traj, loser_traj)) {\\n        // Return the one that is closer (the convention they seem to want)\\n        return norm2(beater_traj) <= norm2(loser_traj);\\n    }\\n    return beater_traj.y * loser_traj.x <= beater_traj.x * loser_traj.y;\\n}\\n\\n// Assuming that two vectors are in the same quadrant, decide\\n// which one has the least change in the right hand rule direction\\n// RETURN\\n//  - The trajectory that wins and true if it was beater\\nstatic inline bool beats_in_quad(\\n    Quadrant quad, \\n    Vec beater_traj,\\n    Vec loser_traj) {\\n\\n    // dx / dy > dx\\' / dy\\' => dy\\'*dx > dy * dx\\'\\n    // if each is negative then it should still work...\\n    assert(beater_traj.x != 0 || beater_traj.y != 0);\\n    assert(loser_traj.x != 0 || loser_traj.y != 0);\\n    \\n    assert(quadrant(beater_traj) == quad);\\n    assert(quadrant(loser_traj) == quad);\\n    // Turns out, you always want the more negative slope, because on teh right hand of y you get\\n    // more positive and you want to slow that, while on the left hand of y you also get more positive\\n    // (and also want to slow that), it\\'s just that at y you jump from +infty to -infty\\n    if (beats_more_neg_slope(beater_traj, loser_traj)) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\n// Get which next point beats the other (i.e. we should take to keep\\n// the hull convex)\\n// RETURN\\n//  - The heading that we should take to stay convex\\n//  - Whether the beater won (if so, increment beater, else increment loser)\\nstatic inline pair<Quadrant, bool> beats(\\n    // Current heading quadrant\\n    Quadrant curr_quad,\\n    // Current point (could be in another quadrant)\\n    Point curr_pnt,\\n    // Next options\\n    Point cand_beater,\\n    Point cand_loser) {\\n    Vec beater_traj = {\\n        cand_beater.x - curr_pnt.x,\\n        cand_beater.y - curr_pnt.y\\n    };\\n    Vec loser_traj = {\\n        cand_loser.x - curr_pnt.x,\\n        cand_loser.y - curr_pnt.y\\n    };\\n\\n    // Quadrant pointing of that vector\\n    Quadrant beater_quad = quadrant(beater_traj);\\n    Quadrant loser_quad = quadrant(loser_traj);\\n\\n    int beater_quad_diff = quadrant_diff(curr_quad, beater_quad);\\n    int loser_quad_diff = quadrant_diff(curr_quad, loser_quad);\\n    // If there is a change in quadrants that is larger for one vector than the other\\n    // just return the smaller change\\n    if (beater_quad_diff < loser_quad_diff) {\\n        return pair<Quadrant, bool>(beater_quad, true);\\n    } else if (beater_quad_diff > loser_quad_diff) {\\n        return pair<Quadrant, bool>(loser_quad, false);\\n    }\\n    // If the changes are both in the same quadrant, return the one that leads to the less\\n    // difference\\n    assert(beater_quad == loser_quad);\\n    return pair<Quadrant, bool>(beater_quad, beats_in_quad(beater_quad, beater_traj, loser_traj));\\n}\\n\\nstatic inline pair<Quadrant, Point> beating_point(\\n    // Current heading quadrant\\n    Quadrant curr_quad, \\n    // Current point\\n    Point curr_pnt, \\n    vector<Point>& pnts) {\\n    Point beater = pnts[0];\\n    if (beater == curr_pnt) {\\n        assert(pnts.size() > 1);\\n        beater = pnts[1];\\n    }\\n    Quadrant beater_quad = quadrant(point_diff(beater, curr_pnt));\\n    for (int i = 1; i < pnts.size(); i++) {\\n        if (pnts[i] == curr_pnt) continue;\\n\\n        pair<Quadrant, bool> beater_beats = beats(curr_quad, curr_pnt, beater, pnts[i]);\\n        if (!beater_beats.second) {\\n            beater = pnts[i];\\n            beater_quad = beater_beats.first;\\n        }\\n    }\\n    return pair<Quadrant, Point>(beater_quad, beater);\\n}\\n\\nstatic inline vector<Point> convex_hull_slow(vector<Point>& points) {\\n    assert(points.size() > 0);\\n\\n    // Get the lowest point (must be in the convex hull)\\n    int m = 0;\\n    for (int i = 1; i < points.size(); i++) {\\n        if (points[i].x < points[m].x || points[i].x == points[m].x && points[i].y < points[m].y) m = i;\\n    }\\n    \\n    unordered_set<Point> visited;\\n    visited.insert(points[m]);\\n    vector<Point> hull(1, points[m]);\\n    if (points.size() == 1) return hull;\\n\\n    // Current quadrant tells us where our heading\\'s quadrant is\\n    // We start at II because we choose the minimum x point to be the\\n    // starting point, meaning that anyone pointing to us must be pointing\\n    // towards II or III. The only case in which they point to III is when\\n    // there are multiple on the same X, in which case we pick the lowest one,\\n    // but in that case it doesn\\'t matter since the up vector <1, 0> is in\\n    // quadrant I and so those will be ignored anyways.\\n    Quadrant curr_quad = II;\\n\\n    while (true) {\\n        pair<Quadrant, Point> beater = beating_point(curr_quad, hull[hull.size() - 1], points);\\n        if (visited.find(beater.second) == visited.end()) {\\n            curr_quad = beater.first;\\n            hull.push_back(beater.second);\\n            visited.insert(beater.second);\\n        } else {\\n            break;\\n        }\\n        if (hull.size() > points.size()) {\\n            print_point_vector(hull);\\n            cout << \"Ran Forever :( i.e. hull too big\";\\n            throw new runtime_error(\"Hull too big\");\\n        }\\n    }\\n    return hull;\\n}\\n\\n// Functions to transform for Leetcode\\'s format to/from my own\\nstatic inline vector<int> point2vec(Point& p) {\\n    assert(p.x.v == (int)p.x.v && p.y.v == (int)p.y.v);\\n    return vector<int>{(int)p.x.v, (int)p.y.v};\\n}\\nstatic inline Point vec2point(vector<int>& p) { return Point{p[0], p[1]}; }\\nstatic inline vector<Point> vecs2points(vector<vector<int>>& vs) {\\n    vector<Point> ps;\\n    for (auto& v : vs) ps.push_back(vec2point(v));\\n    return ps;\\n}\\nstatic inline vector<vector<int>> points2vecs(vector<Point>& ps) {\\n    vector<vector<int>> vs;\\n    for (auto& p : ps) vs.push_back(point2vec(p));\\n    return vs;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        vector<Point> points = vecs2points(trees);\\n        vector<Point> hull = convex_hull_slow(points);\\n        return points2vecs(hull);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <iostream>\\n#include <assert.h>\\n#include <algorithm>\\n#include <math.h>\\n#include <unordered_set>\\n\\n// Compile and run with\\n// rm -rf && clang++ convex_hull.cc -std=c++11 -stdlib=libc++ && ./a.out\\n//\\n// add `-Weverything` as in `clang++ convex_hull.cc -std=c++11 -stdlib=libc++ -Weverything`\\n// to make this give you helpful warnings (though a lot of them are not helpful)\\nusing namespace std;\\n\\n// Slow (and in theory also fast, but haven\\'t finished yet) convex hull\\n\\n// For numerical issues and testing\\nstruct Float {\\n    double v;\\n    Float(double u) { v = u; }\\n    Float(const Float& u) { v = u.v; }\\n\\n    #define EPS 0.000000000001\\n    bool operator ==(const Float& u) const { return abs(v - u.v) < EPS; }\\n    bool operator !=(const Float& u) const { return !(*this == u); }\\n    Float operator +(const Float& u) const{ return Float(v + u.v); }\\n    Float operator -(const Float& u) const{ return Float(v - u.v); }\\n    Float operator *(const Float& u) const{ return Float(v * u.v); }\\n    Float operator /(const Float& u) const{ return Float(v / u.v); }\\n    bool operator >(const Float& u) const { return v > u.v; }\\n    bool operator >=(const Float& u) const { return v >= u.v; }\\n    bool operator <(const Float& u) const { return v < u.v; }\\n    bool operator <=(const Float& u) const { return v <= u.v; }\\n    bool operator =(const Float& u) { return v = u.v; }\\n    \\n};\\n\\nstruct Point_t {\\n    Float x;\\n    Float y;\\n    const bool operator ==(const struct Point_t& p) const { return x == p.x && y == p.y; }\\n};\\n\\nstruct Vec_t {\\n    Float x;\\n    Float y;\\n    const bool operator ==(const struct Vec_t& v) const { return x == v.x && y == v.y; }\\n};\\n\\ntypedef struct Point_t Point;\\n// Debugging helper\\nvoid print_point_vector(vector<Point>& hull) {\\n    for (auto& p : hull) cout << \"(\" << p.x.v << \", \" << p.y.v << \") \";\\n    cout << \"\\\\n\";\\n}\\n\\nnamespace std {\\n    template<>\\n    struct hash<Point> {\\n        size_t operator()(const Point &p) const {\\n            return hash<double>()(p.x.v) ^ hash<double>()(p.y.v);\\n        }\\n    };\\n}\\n\\n\\ntypedef struct Vec_t Vec;\\n\\ntypedef int Quadrant;\\n#define I 1\\n#define II 2\\n#define III 3\\n#define IV 4\\n\\n\\n// Identifier for quadrants. Importantly, everything on a vertical or horizontal slope\\n// gets assigned to the quadrant that it ENDS because that way we just want the slope\\n// to always get more positive.\\n// RETURN\\n//  - A quadrant that is numerated in a mod-4 fashion such that\\n//  - until you loop there is an ordering of the quadrants where\\n//  - if you go to the lower quadrant above you, you are rotating less\\nstatic inline Quadrant quadrant(Vec v) {\\n    if (v.x >= 0 && v.y > 0) return I;\\n    if (v.x < 0 && v.y >= 0) return II;\\n    if (v.x <= 0 && v.y < 0) return III;\\n    return IV;\\n}\\n\\n// Get an ordering of the changes in quadrants from less costly to more costly\\n// RETURN\\n//  - The difference in quadrants (counting in a circle) in number of steps\\nstatic inline int quadrant_diff(Quadrant q1, Quadrant q2) {\\n    int d = q2 - q1;\\n    if (d < 0) d += 4;\\n    return d;\\n}\\n\\n// RETURN\\n//  - Vector from diff of two points\\nstatic inline Vec point_diff(Point p1, Point p2) {\\n    return Vec{p1.x - p2.x, p1.y - p2.y};\\n}\\n\\n// RETURN\\n//  - The dot product of two vectors\\nstatic inline Float dot(Vec v, Vec u) {\\n    return v.x * u.x + v.y * u.y;\\n}\\n// RETURN\\n//  - The squared norm (euclidean) of a vector\\nstatic inline Float norm2(Vec v) {\\n    return v.x * v.x + v.y * v.y;\\n}\\n\\n// RETURN\\n//  - Whether two vectors have the same heading\\n// (assuming they are in the same quadrant)\\nstatic inline bool same_direction(Vec v, Vec u) {\\n    Float d = dot(v, u);\\n    // In the case of d = 0 they can only be in the same direction if it is\\n    // the zero vector. This is an edge case which won\\'t occur, but it will pass.\\n    return d * d == norm2(v) * norm2(u) && d >= 0;\\n}\\n\\n\\n// RETURN\\n//  - Whether the beater_traj has more negative slope or not than loser_traj\\n// NOTE: that is not vector, it is SLOPE (so it is assumed that you are in the same quadrant)\\nstatic inline bool beats_more_neg_slope(Vec beater_traj, Vec loser_traj){\\n    if (same_direction(beater_traj, loser_traj)) {\\n        // Return the one that is closer (the convention they seem to want)\\n        return norm2(beater_traj) <= norm2(loser_traj);\\n    }\\n    return beater_traj.y * loser_traj.x <= beater_traj.x * loser_traj.y;\\n}\\n\\n// Assuming that two vectors are in the same quadrant, decide\\n// which one has the least change in the right hand rule direction\\n// RETURN\\n//  - The trajectory that wins and true if it was beater\\nstatic inline bool beats_in_quad(\\n    Quadrant quad, \\n    Vec beater_traj,\\n    Vec loser_traj) {\\n\\n    // dx / dy > dx\\' / dy\\' => dy\\'*dx > dy * dx\\'\\n    // if each is negative then it should still work...\\n    assert(beater_traj.x != 0 || beater_traj.y != 0);\\n    assert(loser_traj.x != 0 || loser_traj.y != 0);\\n    \\n    assert(quadrant(beater_traj) == quad);\\n    assert(quadrant(loser_traj) == quad);\\n    // Turns out, you always want the more negative slope, because on teh right hand of y you get\\n    // more positive and you want to slow that, while on the left hand of y you also get more positive\\n    // (and also want to slow that), it\\'s just that at y you jump from +infty to -infty\\n    if (beats_more_neg_slope(beater_traj, loser_traj)) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\n// Get which next point beats the other (i.e. we should take to keep\\n// the hull convex)\\n// RETURN\\n//  - The heading that we should take to stay convex\\n//  - Whether the beater won (if so, increment beater, else increment loser)\\nstatic inline pair<Quadrant, bool> beats(\\n    // Current heading quadrant\\n    Quadrant curr_quad,\\n    // Current point (could be in another quadrant)\\n    Point curr_pnt,\\n    // Next options\\n    Point cand_beater,\\n    Point cand_loser) {\\n    Vec beater_traj = {\\n        cand_beater.x - curr_pnt.x,\\n        cand_beater.y - curr_pnt.y\\n    };\\n    Vec loser_traj = {\\n        cand_loser.x - curr_pnt.x,\\n        cand_loser.y - curr_pnt.y\\n    };\\n\\n    // Quadrant pointing of that vector\\n    Quadrant beater_quad = quadrant(beater_traj);\\n    Quadrant loser_quad = quadrant(loser_traj);\\n\\n    int beater_quad_diff = quadrant_diff(curr_quad, beater_quad);\\n    int loser_quad_diff = quadrant_diff(curr_quad, loser_quad);\\n    // If there is a change in quadrants that is larger for one vector than the other\\n    // just return the smaller change\\n    if (beater_quad_diff < loser_quad_diff) {\\n        return pair<Quadrant, bool>(beater_quad, true);\\n    } else if (beater_quad_diff > loser_quad_diff) {\\n        return pair<Quadrant, bool>(loser_quad, false);\\n    }\\n    // If the changes are both in the same quadrant, return the one that leads to the less\\n    // difference\\n    assert(beater_quad == loser_quad);\\n    return pair<Quadrant, bool>(beater_quad, beats_in_quad(beater_quad, beater_traj, loser_traj));\\n}\\n\\nstatic inline pair<Quadrant, Point> beating_point(\\n    // Current heading quadrant\\n    Quadrant curr_quad, \\n    // Current point\\n    Point curr_pnt, \\n    vector<Point>& pnts) {\\n    Point beater = pnts[0];\\n    if (beater == curr_pnt) {\\n        assert(pnts.size() > 1);\\n        beater = pnts[1];\\n    }\\n    Quadrant beater_quad = quadrant(point_diff(beater, curr_pnt));\\n    for (int i = 1; i < pnts.size(); i++) {\\n        if (pnts[i] == curr_pnt) continue;\\n\\n        pair<Quadrant, bool> beater_beats = beats(curr_quad, curr_pnt, beater, pnts[i]);\\n        if (!beater_beats.second) {\\n            beater = pnts[i];\\n            beater_quad = beater_beats.first;\\n        }\\n    }\\n    return pair<Quadrant, Point>(beater_quad, beater);\\n}\\n\\nstatic inline vector<Point> convex_hull_slow(vector<Point>& points) {\\n    assert(points.size() > 0);\\n\\n    // Get the lowest point (must be in the convex hull)\\n    int m = 0;\\n    for (int i = 1; i < points.size(); i++) {\\n        if (points[i].x < points[m].x || points[i].x == points[m].x && points[i].y < points[m].y) m = i;\\n    }\\n    \\n    unordered_set<Point> visited;\\n    visited.insert(points[m]);\\n    vector<Point> hull(1, points[m]);\\n    if (points.size() == 1) return hull;\\n\\n    // Current quadrant tells us where our heading\\'s quadrant is\\n    // We start at II because we choose the minimum x point to be the\\n    // starting point, meaning that anyone pointing to us must be pointing\\n    // towards II or III. The only case in which they point to III is when\\n    // there are multiple on the same X, in which case we pick the lowest one,\\n    // but in that case it doesn\\'t matter since the up vector <1, 0> is in\\n    // quadrant I and so those will be ignored anyways.\\n    Quadrant curr_quad = II;\\n\\n    while (true) {\\n        pair<Quadrant, Point> beater = beating_point(curr_quad, hull[hull.size() - 1], points);\\n        if (visited.find(beater.second) == visited.end()) {\\n            curr_quad = beater.first;\\n            hull.push_back(beater.second);\\n            visited.insert(beater.second);\\n        } else {\\n            break;\\n        }\\n        if (hull.size() > points.size()) {\\n            print_point_vector(hull);\\n            cout << \"Ran Forever :( i.e. hull too big\";\\n            throw new runtime_error(\"Hull too big\");\\n        }\\n    }\\n    return hull;\\n}\\n\\n// Functions to transform for Leetcode\\'s format to/from my own\\nstatic inline vector<int> point2vec(Point& p) {\\n    assert(p.x.v == (int)p.x.v && p.y.v == (int)p.y.v);\\n    return vector<int>{(int)p.x.v, (int)p.y.v};\\n}\\nstatic inline Point vec2point(vector<int>& p) { return Point{p[0], p[1]}; }\\nstatic inline vector<Point> vecs2points(vector<vector<int>>& vs) {\\n    vector<Point> ps;\\n    for (auto& v : vs) ps.push_back(vec2point(v));\\n    return ps;\\n}\\nstatic inline vector<vector<int>> points2vecs(vector<Point>& ps) {\\n    vector<vector<int>> vs;\\n    for (auto& p : ps) vs.push_back(point2vec(p));\\n    return vs;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        vector<Point> points = vecs2points(trees);\\n        vector<Point> hull = convex_hull_slow(points);\\n        return points2vecs(hull);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2913801,
                "title": "c-simple-solution-sort-set-find-widest-angle-vectex-from-origin-runtime-beat-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Sort all vertices order by X, Y\\n- Find widest angle vertex from base vertices.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- sort array (nlogn)\\n- insert all vertices which x == 0 and x == max(X)\\n- i = 0\\n- run below while loop for biggest Y vertex, smallest Y vertex\\n- while i<n-1 \\n    for j=i+1~n : \\n        find wide angle vertice\\n        set i to j\\n- return vertices from set\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<pair<int,int>>> tree_v;\\n    set<pair<int,int>> ret_set;\\n    vector<vector<int>> ret_v;\\n\\n    void insert_all_trees(int idx){\\n        vector<pair<int,int>>& n = tree_v[idx];\\n        for(int i=0;i<n.size();i++) ret_set.insert(n[i]);\\n    }\\n\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        \\n        tree_v.clear();\\n        ret_set.clear();\\n        ret_v.clear();\\n        \\n        sort(trees.begin(), trees.end());\\n\\n        int prev_x = -1;\\n        for(int i=0;i<trees.size();i++){\\n            if(prev_x != trees[i][0]) tree_v.push_back({});\\n            tree_v[tree_v.size()-1].push_back({trees[i][0], trees[i][1]});\\n            prev_x = trees[i][0];\\n        }\\n        sort(tree_v.begin(), tree_v.end()); // sort array\\n\\n        insert_all_trees(0); // insert all vertexies first x-axis\\n        for(int a=0;a<2;a++){\\n            int i=0;\\n            int treev_size = tree_v.size();\\n            while(i<treev_size-1){\\n                pair<int,int>& big = a==0?tree_v[i][tree_v[i].size()-1]:tree_v[i][0];\\n                double ang = -INT_MAX;\\n                int f_idx = i;\\n\\n                for(int j=i+1;j<treev_size;j++){\\n                    pair<int,int>& cmp = a==0?tree_v[j][tree_v[j].size()-1]:tree_v[j][0];\\n                    double tmp_ang = a==0?(double)(cmp.second - big.second)/(double)(cmp.first - big.first):(double)(cmp.second - big.second)/(double)(big.first - cmp.first);\\n                    if(ang < tmp_ang) {\\n                        ang = tmp_ang;\\n                        f_idx = j;\\n                    }\\n                }\\n                if(a==0) ret_set.insert(tree_v[f_idx][tree_v[f_idx].size()-1]);\\n                else ret_set.insert(tree_v[f_idx][0]);\\n\\n                i = f_idx;\\n            }\\n        }\\n        insert_all_trees(tree_v.size()-1); // insert all vertexies last x-axis\\n        \\n        for(auto it = ret_set.begin();it!=ret_set.end();++it) ret_v.push_back({it->first, it->second});\\n        \\n        return ret_v;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<pair<int,int>>> tree_v;\\n    set<pair<int,int>> ret_set;\\n    vector<vector<int>> ret_v;\\n\\n    void insert_all_trees(int idx){\\n        vector<pair<int,int>>& n = tree_v[idx];\\n        for(int i=0;i<n.size();i++) ret_set.insert(n[i]);\\n    }\\n\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        \\n        tree_v.clear();\\n        ret_set.clear();\\n        ret_v.clear();\\n        \\n        sort(trees.begin(), trees.end());\\n\\n        int prev_x = -1;\\n        for(int i=0;i<trees.size();i++){\\n            if(prev_x != trees[i][0]) tree_v.push_back({});\\n            tree_v[tree_v.size()-1].push_back({trees[i][0], trees[i][1]});\\n            prev_x = trees[i][0];\\n        }\\n        sort(tree_v.begin(), tree_v.end()); // sort array\\n\\n        insert_all_trees(0); // insert all vertexies first x-axis\\n        for(int a=0;a<2;a++){\\n            int i=0;\\n            int treev_size = tree_v.size();\\n            while(i<treev_size-1){\\n                pair<int,int>& big = a==0?tree_v[i][tree_v[i].size()-1]:tree_v[i][0];\\n                double ang = -INT_MAX;\\n                int f_idx = i;\\n\\n                for(int j=i+1;j<treev_size;j++){\\n                    pair<int,int>& cmp = a==0?tree_v[j][tree_v[j].size()-1]:tree_v[j][0];\\n                    double tmp_ang = a==0?(double)(cmp.second - big.second)/(double)(cmp.first - big.first):(double)(cmp.second - big.second)/(double)(big.first - cmp.first);\\n                    if(ang < tmp_ang) {\\n                        ang = tmp_ang;\\n                        f_idx = j;\\n                    }\\n                }\\n                if(a==0) ret_set.insert(tree_v[f_idx][tree_v[f_idx].size()-1]);\\n                else ret_set.insert(tree_v[f_idx][0]);\\n\\n                i = f_idx;\\n            }\\n        }\\n        insert_all_trees(tree_v.size()-1); // insert all vertexies last x-axis\\n        \\n        for(auto it = ret_set.begin();it!=ret_set.end();++it) ret_v.push_back({it->first, it->second});\\n        \\n        return ret_v;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881767,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    //If the number is positive then ab is further than ac\\n    public int distance(int[] a, int[] b, int[] c){\\n        int ab_x = b[0] - a[0];\\n        int ab_y = b[1] - a[1];\\n        int ac_x = c[0] - a[0];\\n        int ac_y = c[1] - a[1];\\n\\n        return (ab_x * ab_x + ab_y * ab_y) - (ac_x * ac_x + ac_y * ac_y);\\n    }\\n\\n    //Check the cross product to see if ac is left to ab\\n    //if point is toward the left the return value of the crossproduct is positive\\n    public int crossProduct(int[] a, int[] b, int[] c){\\n        int ab_x = b[0] - a[0];\\n        int ab_y = b[1] - a[1];\\n        int ac_x = c[0] - a[0];\\n        int ac_y = c[1] - a[1];\\n\\n        //[ab_x, ab_y], [ac_x, ac_y]\\n        return (ab_x * ac_y) - (ab_y * ac_x);\\n    }\\n\\n    public int[][] outerTrees(int[][] trees) {\\n        Set<int[]> ans = new HashSet<>();\\n\\n        int[] start = trees[0];\\n        //find the leftmost point\\n\\n        for(int i = 0; i < trees.length; i++){\\n            if(trees[i][0] < start[0]){\\n                start = trees[i];\\n            }else if(trees[i][0] == start[0]){\\n                if(trees[i][1] < start[1]){\\n                    start = trees[i];\\n                }\\n            }\\n        }\\n\\n        ans.add(start);\\n        int[] curr = start;\\n        //Now we will do a convex hull sweep to check for next coord\\n        while(true){\\n            int[] currbest = trees[0];\\n            ArrayList<int[]> collinear = new ArrayList<>();\\n\\n            for(int i = 1; i < trees.length; i++){\\n                int[] contestant = trees[i];\\n                if(curr == contestant){\\n                    continue;\\n                }\\n\\n                if(crossProduct(curr, currbest, contestant) > 0){\\n                    currbest = contestant;\\n                    collinear = new ArrayList<>();\\n                }else if(crossProduct(curr, currbest, contestant) == 0){\\n                    if(distance(curr, currbest, contestant) > 0){\\n                        collinear.add(contestant);\\n                    }else{\\n                        collinear.add(currbest);\\n                        currbest = contestant;\\n                    }\\n                }\\n            }\\n\\n            //Now we will add the collinear points\\n            for(int[] col: collinear){\\n                ans.add(col);\\n            }\\n\\n            //then we will check whether we reached the starting point\\n            if(currbest == start){\\n                break;\\n            }\\n\\n            ans.add(currbest);\\n            curr = currbest;\\n        }\\n\\n        int len = ans.size();\\n        int[][] toret = new int[len][];\\n        int idx = 0;\\n        for(int[] entry:ans){\\n            toret[idx++] = entry;\\n        }\\n        return toret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //If the number is positive then ab is further than ac\\n    public int distance(int[] a, int[] b, int[] c){\\n        int ab_x = b[0] - a[0];\\n        int ab_y = b[1] - a[1];\\n        int ac_x = c[0] - a[0];\\n        int ac_y = c[1] - a[1];\\n\\n        return (ab_x * ab_x + ab_y * ab_y) - (ac_x * ac_x + ac_y * ac_y);\\n    }\\n\\n    //Check the cross product to see if ac is left to ab\\n    //if point is toward the left the return value of the crossproduct is positive\\n    public int crossProduct(int[] a, int[] b, int[] c){\\n        int ab_x = b[0] - a[0];\\n        int ab_y = b[1] - a[1];\\n        int ac_x = c[0] - a[0];\\n        int ac_y = c[1] - a[1];\\n\\n        //[ab_x, ab_y], [ac_x, ac_y]\\n        return (ab_x * ac_y) - (ab_y * ac_x);\\n    }\\n\\n    public int[][] outerTrees(int[][] trees) {\\n        Set<int[]> ans = new HashSet<>();\\n\\n        int[] start = trees[0];\\n        //find the leftmost point\\n\\n        for(int i = 0; i < trees.length; i++){\\n            if(trees[i][0] < start[0]){\\n                start = trees[i];\\n            }else if(trees[i][0] == start[0]){\\n                if(trees[i][1] < start[1]){\\n                    start = trees[i];\\n                }\\n            }\\n        }\\n\\n        ans.add(start);\\n        int[] curr = start;\\n        //Now we will do a convex hull sweep to check for next coord\\n        while(true){\\n            int[] currbest = trees[0];\\n            ArrayList<int[]> collinear = new ArrayList<>();\\n\\n            for(int i = 1; i < trees.length; i++){\\n                int[] contestant = trees[i];\\n                if(curr == contestant){\\n                    continue;\\n                }\\n\\n                if(crossProduct(curr, currbest, contestant) > 0){\\n                    currbest = contestant;\\n                    collinear = new ArrayList<>();\\n                }else if(crossProduct(curr, currbest, contestant) == 0){\\n                    if(distance(curr, currbest, contestant) > 0){\\n                        collinear.add(contestant);\\n                    }else{\\n                        collinear.add(currbest);\\n                        currbest = contestant;\\n                    }\\n                }\\n            }\\n\\n            //Now we will add the collinear points\\n            for(int[] col: collinear){\\n                ans.add(col);\\n            }\\n\\n            //then we will check whether we reached the starting point\\n            if(currbest == start){\\n                break;\\n            }\\n\\n            ans.add(currbest);\\n            curr = currbest;\\n        }\\n\\n        int len = ans.size();\\n        int[][] toret = new int[len][];\\n        int idx = 0;\\n        for(int[] entry:ans){\\n            toret[idx++] = entry;\\n        }\\n        return toret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849463,
                "title": "graham-scan",
                "content": "We need to build a convex hull here, and we will use the Graham Scan algorithm. \\n\\nFrom the leftmost point `a`, we sort other points based on their slope with respect to the leftmost point.\\n\\nThen, we go in the sorted order and push points into a stack. A points on a hull should appear in a counter clock-wise direction from the previos point. If it appears in a clockwise direction, we pop a previous point from the stack.\\n\\nThe trickies part is the sorting. If two points have the same point, the closest point shold appear first.\\n\\nThis is true for all slopes except the last, where furthest point should appear first. So, we just reverse points in the last slope.\\n\\n**C++**\\n```cpp\\nint ccw(const vector<int> &a, const vector<int> &b, const vector<int> &c) {\\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\\n}   \\nvector<vector<int>> outerTrees(vector<vector<int>>& ts) {\\n    const auto a = *min_element(begin(ts), end(ts));\\n    sort(begin(ts), end(ts), [&](const auto& b, const auto& c){\\n        int res = ccw(a, b, c);\\n        return res == 0 ? b < c : res > 0;\\n    });\\n    int p = (int)ts.size() - 2; // last slope.\\n    while (p >= 0 && ccw(a, ts[p], ts.back()) == 0) \\n        p--;\\n    reverse(begin(ts) + p + 1, end(ts));\\n    vector<vector<int>> res;\\n    for (const auto &c : ts) {\\n        while (res.size() > 1 && ccw(res[res.size() - 2], res.back(), c) < 0)\\n            res.pop_back();\\n        res.push_back(c);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint ccw(const vector<int> &a, const vector<int> &b, const vector<int> &c) {\\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\\n}   \\nvector<vector<int>> outerTrees(vector<vector<int>>& ts) {\\n    const auto a = *min_element(begin(ts), end(ts));\\n    sort(begin(ts), end(ts), [&](const auto& b, const auto& c){\\n        int res = ccw(a, b, c);\\n        return res == 0 ? b < c : res > 0;\\n    });\\n    int p = (int)ts.size() - 2; // last slope.\\n    while (p >= 0 && ccw(a, ts[p], ts.back()) == 0) \\n        p--;\\n    reverse(begin(ts) + p + 1, end(ts));\\n    vector<vector<int>> res;\\n    for (const auto &c : ts) {\\n        while (res.size() > 1 && ccw(res[res.size() - 2], res.back(), c) < 0)\\n            res.pop_back();\\n        res.push_back(c);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2848672,
                "title": "python3-pyhton-graham-s-scan",
                "content": "Calculate if the direction is clockwise or not.\\n- upper_edges -> non clock wise part of fence\\n- lower_edges -> clock wise part of fence\\n```\\nclass Solution(object):\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        def cal_direct(a, b, c):\\n            return (c[1] - b[1]) * (b[0] - a[0]) - (b[1] - a[1]) * (c[0] - b[0])\\n        \\n        def updateEdges(tree):\\n            while len(upper_edges) >= 2 and cal_direct(upper_edges[-2], upper_edges[-1], tree) < 0:\\n                upper_edges.pop()\\n            while len(lower_edges) >= 2 and cal_direct(lower_edges[-2], lower_edges[-1], tree) > 0:\\n                lower_edges.pop()\\n                \\n        trees.sort()\\n        upper_edges = []\\n        lower_edges = []\\n        \\n        for tree in trees:\\n            updateEdges(tree)\\n            upper_edges.append(tuple(tree))\\n            lower_edges.append(tuple(tree))\\n        \\n        return set(upper_edges + lower_edges)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\\n        def cal_direct(a, b, c):\\n            return (c[1] - b[1]) * (b[0] - a[0]) - (b[1] - a[1]) * (c[0] - b[0])\\n        \\n        def updateEdges(tree):\\n            while len(upper_edges) >= 2 and cal_direct(upper_edges[-2], upper_edges[-1], tree) < 0:\\n                upper_edges.pop()\\n            while len(lower_edges) >= 2 and cal_direct(lower_edges[-2], lower_edges[-1], tree) > 0:\\n                lower_edges.pop()\\n                \\n        trees.sort()\\n        upper_edges = []\\n        lower_edges = []\\n        \\n        for tree in trees:\\n            updateEdges(tree)\\n            upper_edges.append(tuple(tree))\\n            lower_edges.append(tuple(tree))\\n        \\n        return set(upper_edges + lower_edges)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845407,
                "title": "unoptimized-jarvis-convex-hull-n-2",
                "content": "You can optimize  more by using indices instead of vectors\\n# Complexity\\n- Time complexity:\\nN^2\\n\\n- Space complexity:\\nN\\n\\n# Code\\n```\\nclass Solution {\\n    int convexhull(vector<int> &a,vector<int> &b, vector<int> &c){\\n        int res=(b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0]);\\n        if(res==0)\\n            return 0;\\n        if(res>0)\\n            return 1;\\n        return -1;\\n    }\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        if(trees.size()<4)\\n            return trees;\\n        vector<vector<int>> res;\\n        auto left=*min_element(trees.begin(),trees.end());\\n        res.push_back(left);\\n        unordered_map<int,bool> visited;\\n        visited[min_element(trees.begin(),trees.end())-trees.begin()]=true;\\n        while(res.size()<trees.size()){\\n            vector<int> cur;\\n            int cx;\\n            for(int x=0;x<trees.size();x++){\\n                if(!visited[x]){\\n                    cur=trees[x];\\n                    cx=x;\\n                    break;\\n                }\\n            }\\n            if(cur==res.back())\\n                cur=trees[1];\\n            for(int x=0;x<trees.size();x++){\\n                if(visited[x])\\n                    continue;\\n                int r=convexhull(res.back(),cur,trees[x]);\\n                if(r==-1 or (r==0 and \\n                (\\n                    abs(res.back()[0]-trees[x][0])<abs(res.back()[0]-cur[0])\\n                    or\\n                    abs(res.back()[1]-trees[x][1])<abs(res.back()[1]-cur[1])\\n                ))){\\n                    cx=x;\\n                    cur=trees[x];\\n                }\\n            }\\n            if(convexhull(res.back(),cur,left)==-1)\\n                return res;\\n            res.push_back(cur);\\n            visited[cx]=true;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int convexhull(vector<int> &a,vector<int> &b, vector<int> &c){\\n        int res=(b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0]);\\n        if(res==0)\\n            return 0;\\n        if(res>0)\\n            return 1;\\n        return -1;\\n    }\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        if(trees.size()<4)\\n            return trees;\\n        vector<vector<int>> res;\\n        auto left=*min_element(trees.begin(),trees.end());\\n        res.push_back(left);\\n        unordered_map<int,bool> visited;\\n        visited[min_element(trees.begin(),trees.end())-trees.begin()]=true;\\n        while(res.size()<trees.size()){\\n            vector<int> cur;\\n            int cx;\\n            for(int x=0;x<trees.size();x++){\\n                if(!visited[x]){\\n                    cur=trees[x];\\n                    cx=x;\\n                    break;\\n                }\\n            }\\n            if(cur==res.back())\\n                cur=trees[1];\\n            for(int x=0;x<trees.size();x++){\\n                if(visited[x])\\n                    continue;\\n                int r=convexhull(res.back(),cur,trees[x]);\\n                if(r==-1 or (r==0 and \\n                (\\n                    abs(res.back()[0]-trees[x][0])<abs(res.back()[0]-cur[0])\\n                    or\\n                    abs(res.back()[1]-trees[x][1])<abs(res.back()[1]-cur[1])\\n                ))){\\n                    cx=x;\\n                    cur=trees[x];\\n                }\\n            }\\n            if(convexhull(res.back(),cur,left)==-1)\\n                return res;\\n            res.push_back(cur);\\n            visited[cx]=true;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839914,
                "title": "geometry-jarvis-algorithm-java",
                "content": "# Complexity\\n- Time complexity: O(n^2) + O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // Jarvis Algorithm, geometry\\n    // Worst case Time Complexity: O(n^2).\\n    // Worst case Space Complexity: O(n).\\n\\n    //  Slope of two points p1 and p2 = (y2 - y1)/(x2 - x1), where p1 = (x1, y1) & p2 = (x2, y2).\\n    //  We have first sorted the trees based on the X coordinate (non-decreasing).\\n    //  If X coordinate is same, we use the Y coordinate(non-increasing).\\n\\n    //  If we start from the left most tree and try to find the first tree\\n    //  which would come up if we moved counter clockwise \\n    //   relative to that tree. Thats the next tree.\\n\\n    //  Algorithm\\n    //  Assuming trees as points on the coordinate axis.\\n\\n    //  Sort the points\\n    //  Starting from the first point, we find the slope of it \\n    //  with all the points succeeding it. \\n    //  The one with the smallest slope is chosen as the next point\\n    //  that would be on the perimeter.\\n\\n    //  Starting from the last point, we find the slope of it \\n    //  with all the points preceding it.\\n    //  The one with the smallest slope is chosen as the next point \\n    //  that would be on the perimeter.\\n\\n    //  As we transverse these points, we mark them as visited.\\n    //  After completing the transversal, we create an array of all the visited points and return.\\n\\n    class sortByXthenY implements Comparator<int[]>{\\n        public int compare(int[] ob1, int[] ob2){\\n            if(ob1[0] == ob2[0]){\\n                return ob2[1] - ob1[1];\\n            }\\n            return ob1[0] - ob2[0];\\n        }\\n    }\\n\\n    public int[][] outerTrees(int[][] trees) {\\n        Arrays.sort(trees, new sortByXthenY());\\n        boolean[] visited = new boolean[trees.length];\\n\\n        for(int i = 0; i < trees.length;){\\n            visited[i] = true;\\n            int idx = trees.length;\\n            double slope = Integer.MAX_VALUE;\\n            for(int j = i +1; j< trees.length; j++){\\n                double s = slopeIs(trees[i], trees[j]);\\n                if(s < slope){\\n                    slope = s;\\n                    idx = j;\\n                }\\n            }\\n            i = idx;\\n        }\\n\\n        for(int i = trees.length -1; i>= 0;){\\n            visited[i] = true;\\n            int idx = -1;\\n            double slope = Integer.MAX_VALUE;\\n            for(int j = i-1; j>= 0; j--){\\n                double s = slopeIs(trees[i], trees[j]);\\n                if(s < slope){\\n                    slope = s;\\n                    idx = j;\\n                }\\n            }\\n            i = idx;\\n        }\\n\\n        int counter = 0;\\n        for(boolean i: visited){\\n            if(i){\\n                counter++;\\n            }\\n        }\\n        int[][] ans = new int[counter][2];\\n        int j = 0;\\n        for(int i = 0; i < trees.length; i++){\\n            if(visited[i]){\\n                ans[j++] = trees[i];\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public double slopeIs(int[] p1, int[] p2){\\n        if(p1[0] == p2[0]){\\n            //  Edge case when the slope of two points is not defined\\n            //  i.e. there line lies parallel to the y axis.\\n            //  TC = [[1,4],[1,1],[2,5],[3,4],[3,1]]\\n            return Integer.MIN_VALUE;\\n        }\\n        return (double)(p2[1] - p1[1])/(p2[0] - p1[0]);\\n    }\\n\\n//  Functions for debugging\\n    private void print2(int[][] arr){\\n        for(int i = 0; i < arr.length; i++){\\n            System.out.print(arr[i][1] + \" \");\\n        }\\n        System.out.println();\\n    }\\n    private void print(int[][] arr){\\n        for(int i = 0; i < arr[0].length; i++){\\n            System.out.print(arr[0][i] + \" \");\\n        }\\n        System.out.println();\\n        for(int i = 0; i < arr[0].length; i++){\\n            System.out.print(arr[1][i] + \" \");\\n        }\\n        System.out.println();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Jarvis Algorithm, geometry\\n    // Worst case Time Complexity: O(n^2).\\n    // Worst case Space Complexity: O(n).\\n\\n    //  Slope of two points p1 and p2 = (y2 - y1)/(x2 - x1), where p1 = (x1, y1) & p2 = (x2, y2).\\n    //  We have first sorted the trees based on the X coordinate (non-decreasing).\\n    //  If X coordinate is same, we use the Y coordinate(non-increasing).\\n\\n    //  If we start from the left most tree and try to find the first tree\\n    //  which would come up if we moved counter clockwise \\n    //   relative to that tree. Thats the next tree.\\n\\n    //  Algorithm\\n    //  Assuming trees as points on the coordinate axis.\\n\\n    //  Sort the points\\n    //  Starting from the first point, we find the slope of it \\n    //  with all the points succeeding it. \\n    //  The one with the smallest slope is chosen as the next point\\n    //  that would be on the perimeter.\\n\\n    //  Starting from the last point, we find the slope of it \\n    //  with all the points preceding it.\\n    //  The one with the smallest slope is chosen as the next point \\n    //  that would be on the perimeter.\\n\\n    //  As we transverse these points, we mark them as visited.\\n    //  After completing the transversal, we create an array of all the visited points and return.\\n\\n    class sortByXthenY implements Comparator<int[]>{\\n        public int compare(int[] ob1, int[] ob2){\\n            if(ob1[0] == ob2[0]){\\n                return ob2[1] - ob1[1];\\n            }\\n            return ob1[0] - ob2[0];\\n        }\\n    }\\n\\n    public int[][] outerTrees(int[][] trees) {\\n        Arrays.sort(trees, new sortByXthenY());\\n        boolean[] visited = new boolean[trees.length];\\n\\n        for(int i = 0; i < trees.length;){\\n            visited[i] = true;\\n            int idx = trees.length;\\n            double slope = Integer.MAX_VALUE;\\n            for(int j = i +1; j< trees.length; j++){\\n                double s = slopeIs(trees[i], trees[j]);\\n                if(s < slope){\\n                    slope = s;\\n                    idx = j;\\n                }\\n            }\\n            i = idx;\\n        }\\n\\n        for(int i = trees.length -1; i>= 0;){\\n            visited[i] = true;\\n            int idx = -1;\\n            double slope = Integer.MAX_VALUE;\\n            for(int j = i-1; j>= 0; j--){\\n                double s = slopeIs(trees[i], trees[j]);\\n                if(s < slope){\\n                    slope = s;\\n                    idx = j;\\n                }\\n            }\\n            i = idx;\\n        }\\n\\n        int counter = 0;\\n        for(boolean i: visited){\\n            if(i){\\n                counter++;\\n            }\\n        }\\n        int[][] ans = new int[counter][2];\\n        int j = 0;\\n        for(int i = 0; i < trees.length; i++){\\n            if(visited[i]){\\n                ans[j++] = trees[i];\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public double slopeIs(int[] p1, int[] p2){\\n        if(p1[0] == p2[0]){\\n            //  Edge case when the slope of two points is not defined\\n            //  i.e. there line lies parallel to the y axis.\\n            //  TC = [[1,4],[1,1],[2,5],[3,4],[3,1]]\\n            return Integer.MIN_VALUE;\\n        }\\n        return (double)(p2[1] - p1[1])/(p2[0] - p1[0]);\\n    }\\n\\n//  Functions for debugging\\n    private void print2(int[][] arr){\\n        for(int i = 0; i < arr.length; i++){\\n            System.out.print(arr[i][1] + \" \");\\n        }\\n        System.out.println();\\n    }\\n    private void print(int[][] arr){\\n        for(int i = 0; i < arr[0].length; i++){\\n            System.out.print(arr[0][i] + \" \");\\n        }\\n        System.out.println();\\n        for(int i = 0; i < arr[0].length; i++){\\n            System.out.print(arr[1][i] + \" \");\\n        }\\n        System.out.println();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839639,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI tried to think of it as drawing lines touching all the trees on the \"outer edge\". Then, for each tree, see if \"straightening\" the rope for two neighbors makes this tree \"not be on the edge\". If that was true, I would remove that tree, and rerun the logic.\\n\\nIt certainly took me a lot of tries, as I tried doing this without recursion, but some test cases would always fail. \\n\\nI am pretty sure this is overly complex, but it works, and it was easier to visualize how this would work in terms of a rope.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIdentify all the columns, and their highest/lowest points.\\nAdd all the trees on the leftmost column and rightmost column to the answer.\\n\\nConnect all the trees from the highest point in each column. Start looping backwards, and see if any tree is unneeded if we draw a straight line from the neighbors. If that is true, remove that tree, and rerun the logic.\\n\\nRepeat for the lowest points in each column (lower edge of the rope).\\n\\nUse a hashset to make sure the tree is listed only once.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLet n be the number of trees.\\nWe need O(n) to catalogue all the trees.\\nWe need upto O(n) to create the initial lists of lines.\\nLet\\'s say the top edge and bottom edge are both concave (left/right tops are the tallest). That will mean, we will start by adding all the lines, and then slowly eliminating one by one. So, O(n) again.\\nSince, constants don\\'t matter, the time complexity is O(n).\\n\\nMy confidence in this analysis: low :-)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) to store all the points, O(n) for lines, and O(n) for recursion.\\n\\nO(n) overall.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] OuterTrees(int[][] trees) {\\n        List<Column> columns = new List<Column>();\\n\\n        for (int i = 0; i < trees.Length; i++) {\\n            int thisX = trees[i][0];\\n            int thisY = trees[i][1];\\n\\n            if (thisX >= columns.Count) {\\n                for (int j = columns.Count; j <= thisX; j++) {\\n                    columns.Add(new Column(j));\\n                }\\n            }\\n\\n            columns[thisX].AddPoint(thisY);\\n        }\\n\\n        for (int i = columns.Count - 1; i >=0; i--) {\\n            if (columns[i].Points.Count < 1) {\\n                columns.RemoveAt(i);\\n            }\\n        }\\n\\n        HashSet<int> hash = new HashSet<int>();\\n        \\n        //left edge\\n        for (int i = 0; i < columns[0].Points.Count; i++) {\\n            hash.Add(columns[0].X * 1000 + columns[0].Points[i]);\\n        }\\n\\n        if (columns.Count > 1) {\\n            //right edge\\n            for (int i = 0; i < columns[columns.Count - 1].Points.Count; i++) {\\n                hash.Add(columns[columns.Count - 1].X * 1000 + columns[columns.Count - 1].Points[i]);\\n            }\\n\\n            Lines topLines = new Lines(columns[0].X, columns[0].Highest, columns[1].X, columns[1].Highest);\\n            for (int i = 1; i < columns.Count - 1; i++) {\\n                topLines.lines.Add(new Line(columns[i].X, columns[i].Highest, columns[i+1].X, columns[i+1].Highest));\\n            }\\n\\n            topLines.InflateLines(true);\\n            for (int i = 1; i < topLines.lines.Count; i++) {\\n                Point pt =  topLines.lines[i].A;\\n                hash.Add(pt.X * 1000 + pt.Y);\\n            }\\n        \\n            Lines bottomLines = new Lines(columns[0].X, columns[0].Lowest, columns[1].X, columns[1].Lowest);\\n            for (int i = 1; i < columns.Count - 1; i++) {\\n                bottomLines.lines.Add(new Line(columns[i].X, columns[i].Lowest, columns[i+1].X, columns[i+1].Lowest));\\n            }\\n\\n            bottomLines.InflateLines(false);\\n            for (int i = 1; i < bottomLines.lines.Count; i++) {\\n                Point pt =  bottomLines.lines[i].A;\\n                hash.Add(pt.X * 1000 + pt.Y);\\n            }\\n        }\\n\\n        int[][] result = new int[hash.Count][];\\n        int index = 0;\\n\\n        foreach (int thisKey in hash) {\\n            result[index++] = new int[] { thisKey / 1000, thisKey % 1000 };\\n        }\\n\\n        return result;\\n    }\\n}\\n\\npublic class Column {\\n    public int X { get; set; }\\n    public int Highest { get; set; }\\n    public int Lowest { get; set; }   \\n    public List<int> Points { get; set; }\\n\\n    public Column(int x) {\\n        X = x;\\n        Highest = 0;\\n        Lowest = 101;\\n        Points = new List<int>();\\n    }\\n\\n    public void AddPoint(int y) {\\n        Points.Add(y);\\n        Highest = Math.Max(Highest, y);\\n        Lowest = Math.Min(Lowest, y);\\n    }\\n}\\n\\npublic class Lines {\\n    public List<Line> lines { get; set; }\\n\\n    public Lines(int x1, int y1, int x2, int y2) {\\n        lines = new List<Line>() {\\n            new Line(x1, y1, x2, y2)\\n        };\\n    }\\n\\n    public void InflateLines(bool upwards) {\\n        for (int i = lines.Count - 1; i > 0; i--) {\\n            Point thisPoint = lines[i].A;\\n            Point leftPoint = lines[i-1].A;\\n            Point rightPoint = lines[i].B;\\n\\n            Line possibleLine = new Line(leftPoint.X, leftPoint.Y, rightPoint.X, rightPoint.Y);\\n            if (!possibleLine.PointAffectsLine(upwards, thisPoint.X, thisPoint.Y)) {\\n                //remove this point\\n                lines[i-1].B = new Point(rightPoint.X, rightPoint.Y);\\n                lines.RemoveAt(i);\\n\\n                InflateLines(upwards);\\n                break;\\n            }\\n        }\\n    }\\n\\n}\\n\\npublic class Line {\\n    public Point A { get; set; }\\n    public Point B { get; set; }\\n\\n    public Line (int x1, int y1, int x2, int y2) {\\n        A = new Point(x1, y1);\\n        B = new Point(x2, y2);\\n    }\\n\\n    public bool PointAffectsLine(bool directionUp, int x, int y) {\\n        int xDiff = B.X - A.X;\\n        int yDiff = B.Y - A.Y;\\n\\n        double increment = (double)yDiff / (double)xDiff;\\n        double lineYAtPoint = A.Y + (increment * (x - A.X));\\n        double doubleY = (double)y;\\n\\n        return directionUp ? doubleY >= lineYAtPoint : doubleY <= lineYAtPoint;\\n    }\\n}\\n\\npublic class Point {\\n    public int X { get; set; }\\n    public int Y { get; set; }\\n\\n    public Point(int x, int y) {\\n        X = x;\\n        Y = y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] OuterTrees(int[][] trees) {\\n        List<Column> columns = new List<Column>();\\n\\n        for (int i = 0; i < trees.Length; i++) {\\n            int thisX = trees[i][0];\\n            int thisY = trees[i][1];\\n\\n            if (thisX >= columns.Count) {\\n                for (int j = columns.Count; j <= thisX; j++) {\\n                    columns.Add(new Column(j));\\n                }\\n            }\\n\\n            columns[thisX].AddPoint(thisY);\\n        }\\n\\n        for (int i = columns.Count - 1; i >=0; i--) {\\n            if (columns[i].Points.Count < 1) {\\n                columns.RemoveAt(i);\\n            }\\n        }\\n\\n        HashSet<int> hash = new HashSet<int>();\\n        \\n        //left edge\\n        for (int i = 0; i < columns[0].Points.Count; i++) {\\n            hash.Add(columns[0].X * 1000 + columns[0].Points[i]);\\n        }\\n\\n        if (columns.Count > 1) {\\n            //right edge\\n            for (int i = 0; i < columns[columns.Count - 1].Points.Count; i++) {\\n                hash.Add(columns[columns.Count - 1].X * 1000 + columns[columns.Count - 1].Points[i]);\\n            }\\n\\n            Lines topLines = new Lines(columns[0].X, columns[0].Highest, columns[1].X, columns[1].Highest);\\n            for (int i = 1; i < columns.Count - 1; i++) {\\n                topLines.lines.Add(new Line(columns[i].X, columns[i].Highest, columns[i+1].X, columns[i+1].Highest));\\n            }\\n\\n            topLines.InflateLines(true);\\n            for (int i = 1; i < topLines.lines.Count; i++) {\\n                Point pt =  topLines.lines[i].A;\\n                hash.Add(pt.X * 1000 + pt.Y);\\n            }\\n        \\n            Lines bottomLines = new Lines(columns[0].X, columns[0].Lowest, columns[1].X, columns[1].Lowest);\\n            for (int i = 1; i < columns.Count - 1; i++) {\\n                bottomLines.lines.Add(new Line(columns[i].X, columns[i].Lowest, columns[i+1].X, columns[i+1].Lowest));\\n            }\\n\\n            bottomLines.InflateLines(false);\\n            for (int i = 1; i < bottomLines.lines.Count; i++) {\\n                Point pt =  bottomLines.lines[i].A;\\n                hash.Add(pt.X * 1000 + pt.Y);\\n            }\\n        }\\n\\n        int[][] result = new int[hash.Count][];\\n        int index = 0;\\n\\n        foreach (int thisKey in hash) {\\n            result[index++] = new int[] { thisKey / 1000, thisKey % 1000 };\\n        }\\n\\n        return result;\\n    }\\n}\\n\\npublic class Column {\\n    public int X { get; set; }\\n    public int Highest { get; set; }\\n    public int Lowest { get; set; }   \\n    public List<int> Points { get; set; }\\n\\n    public Column(int x) {\\n        X = x;\\n        Highest = 0;\\n        Lowest = 101;\\n        Points = new List<int>();\\n    }\\n\\n    public void AddPoint(int y) {\\n        Points.Add(y);\\n        Highest = Math.Max(Highest, y);\\n        Lowest = Math.Min(Lowest, y);\\n    }\\n}\\n\\npublic class Lines {\\n    public List<Line> lines { get; set; }\\n\\n    public Lines(int x1, int y1, int x2, int y2) {\\n        lines = new List<Line>() {\\n            new Line(x1, y1, x2, y2)\\n        };\\n    }\\n\\n    public void InflateLines(bool upwards) {\\n        for (int i = lines.Count - 1; i > 0; i--) {\\n            Point thisPoint = lines[i].A;\\n            Point leftPoint = lines[i-1].A;\\n            Point rightPoint = lines[i].B;\\n\\n            Line possibleLine = new Line(leftPoint.X, leftPoint.Y, rightPoint.X, rightPoint.Y);\\n            if (!possibleLine.PointAffectsLine(upwards, thisPoint.X, thisPoint.Y)) {\\n                //remove this point\\n                lines[i-1].B = new Point(rightPoint.X, rightPoint.Y);\\n                lines.RemoveAt(i);\\n\\n                InflateLines(upwards);\\n                break;\\n            }\\n        }\\n    }\\n\\n}\\n\\npublic class Line {\\n    public Point A { get; set; }\\n    public Point B { get; set; }\\n\\n    public Line (int x1, int y1, int x2, int y2) {\\n        A = new Point(x1, y1);\\n        B = new Point(x2, y2);\\n    }\\n\\n    public bool PointAffectsLine(bool directionUp, int x, int y) {\\n        int xDiff = B.X - A.X;\\n        int yDiff = B.Y - A.Y;\\n\\n        double increment = (double)yDiff / (double)xDiff;\\n        double lineYAtPoint = A.Y + (increment * (x - A.X));\\n        double doubleY = (double)y;\\n\\n        return directionUp ? doubleY >= lineYAtPoint : doubleY <= lineYAtPoint;\\n    }\\n}\\n\\npublic class Point {\\n    public int X { get; set; }\\n    public int Y { get; set; }\\n\\n    public Point(int x, int y) {\\n        X = x;\\n        Y = y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838310,
                "title": "c-o-1-extra-space",
                "content": "There is O(N) modifed space, but still O(1) extra space. See if you find it insightful! \\n\\n```\\nclass Solution {\\npublic:\\n    int cross(vector <int> &a, vector <int> &b, vector <int> &c) {\\n        return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);\\n    }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& a) {\\n        // get lowest, leftmost atan2\\n        // get leftmost, lowest instead? atan!\\n        int i = 0, n = a.size();\\n        for (int j = 1; j < n; j++) \\n            if (a[i][0] > a[j][0] || (a[i][0] == a[j][0] && a[i][1] > a[j][1]))\\n                swap(a[i], a[j]);\\n        \\n        auto z = a[0]; // remember the point\\n        for (auto &x : a) { \\n            x[0] -= z[0]; // center everything into 0,0\\n            x[1] -= z[1]; // for the sorting\\n        }\\n        // sort by angle and distance, the O(NlogN)\\n        // 1/0.0 = inf ... atan(inf) = pi/2\\n        sort(a.begin() + 1, a.end(), [](const auto &x, const auto &y) {\\n            // fixed point pseudo angles instead of doubles and atan\\n            int xx = x[0] == 0 ? INT_MAX : (x[1] * 1000000) / x[0];\\n            int yy = y[0] == 0 ? INT_MAX : (y[1] * 1000000) / y[0];\\n            // would manhattan work? it does!\\n            int dx = abs(x[1]) + abs(x[0]); // don\\'t need to calculate \\n            int dy = abs(y[1]) + abs(y[0]); // actual magnitude ||x||\\n            return xx < yy || (xx == yy && dx > dy);\\n        });\\n        \\n        // sorting by distance isn\\'t optimal everywhere\\n        // here we reverse the first ones **\\n        int k = 1;\\n        while (k + 1 < n && cross(a[i], a[k], a[k + 1]) == 0)\\n            k++;\\n        reverse(a.begin() + 1, a.begin() + k + 1);\\n        \\n        // just pick the circle, stack\\n        // push good points and pop bad points\\n        for (int j = 1; j < n; j++) {\\n            swap(a[++i], a[j]); // push all into a stack\\n            while (cross(a[i - 1], a[i], a[(j + 1) % n]) < 0)\\n                i--; // pop bad from stack\\n        }\\n        a.resize(i + 1); // remove extras\\n        for (auto &x : a) { \\n            x[0] += z[0]; // recover original points\\n            x[1] += z[1]; \\n        }\\n        return a;\\n    }\\n};\\n```\\nIf you have any questions don\\'t hesistate to ask!",
                "solutionTags": [
                    "C",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cross(vector <int> &a, vector <int> &b, vector <int> &c) {\\n        return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);\\n    }\\n    vector<vector<int>> outerTrees(vector<vector<int>>& a) {\\n        // get lowest, leftmost atan2\\n        // get leftmost, lowest instead? atan!\\n        int i = 0, n = a.size();\\n        for (int j = 1; j < n; j++) \\n            if (a[i][0] > a[j][0] || (a[i][0] == a[j][0] && a[i][1] > a[j][1]))\\n                swap(a[i], a[j]);\\n        \\n        auto z = a[0]; // remember the point\\n        for (auto &x : a) { \\n            x[0] -= z[0]; // center everything into 0,0\\n            x[1] -= z[1]; // for the sorting\\n        }\\n        // sort by angle and distance, the O(NlogN)\\n        // 1/0.0 = inf ... atan(inf) = pi/2\\n        sort(a.begin() + 1, a.end(), [](const auto &x, const auto &y) {\\n            // fixed point pseudo angles instead of doubles and atan\\n            int xx = x[0] == 0 ? INT_MAX : (x[1] * 1000000) / x[0];\\n            int yy = y[0] == 0 ? INT_MAX : (y[1] * 1000000) / y[0];\\n            // would manhattan work? it does!\\n            int dx = abs(x[1]) + abs(x[0]); // don\\'t need to calculate \\n            int dy = abs(y[1]) + abs(y[0]); // actual magnitude ||x||\\n            return xx < yy || (xx == yy && dx > dy);\\n        });\\n        \\n        // sorting by distance isn\\'t optimal everywhere\\n        // here we reverse the first ones **\\n        int k = 1;\\n        while (k + 1 < n && cross(a[i], a[k], a[k + 1]) == 0)\\n            k++;\\n        reverse(a.begin() + 1, a.begin() + k + 1);\\n        \\n        // just pick the circle, stack\\n        // push good points and pop bad points\\n        for (int j = 1; j < n; j++) {\\n            swap(a[++i], a[j]); // push all into a stack\\n            while (cross(a[i - 1], a[i], a[(j + 1) % n]) < 0)\\n                i--; // pop bad from stack\\n        }\\n        a.resize(i + 1); // remove extras\\n        for (auto &x : a) { \\n            x[0] += z[0]; // recover original points\\n            x[1] += z[1]; \\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834731,
                "title": "leetcode-errors",
                "content": "In the descrption you see:![image](https://assets.leetcode.com/users/images/a1e5cb89-2b7c-4fbc-a7ba-00df62628016_1668996717.7745702.jpeg)\\n\\nIn the solution you see:![image](https://assets.leetcode.com/users/images/2e0123a7-4966-44f9-bbed-2b80ec1ff406_1669169349.284745.jpeg)\\n\\n\\nIn my computer I get:![image](https://assets.leetcode.com/users/images/7f93b3f9-261a-4190-a514-2f74c45b20b9_1668996844.3289769.jpeg)\\n\\nWhy do we get two diferent answers from leetcode?\\n\\nBy the way, should the answer be clockwise or counterclockwise?\\nFrom which point onwards?\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "In the descrption you see:![image](https://assets.leetcode.com/users/images/a1e5cb89-2b7c-4fbc-a7ba-00df62628016_1668996717.7745702.jpeg)\\n\\nIn the solution you see:![image](https://assets.leetcode.com/users/images/2e0123a7-4966-44f9-bbed-2b80ec1ff406_1669169349.284745.jpeg)\\n\\n\\nIn my computer I get:![image](https://assets.leetcode.com/users/images/7f93b3f9-261a-4190-a514-2f74c45b20b9_1668996844.3289769.jpeg)\\n\\nWhy do we get two diferent answers from leetcode?\\n\\nBy the way, should the answer be clockwise or counterclockwise?\\nFrom which point onwards?\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2834497,
                "title": "i-was-late-for-the-submit-swift",
                "content": "# Intuition\\nthis is literally my first \"project\" over #100 lines of code\\n# Approach\\nnothing fancy it\\'s all in the book, convex hull algorithm with Graham scan, but there are details needs to be considered\\n\\n# Complexity\\n- Time complexity:\\nmy approach is definitely more complicated than using cosine, just trying to do something different\\n\\n- Space complexity:\\nfor sure this is the best, I beat 100% \\n\\n# Code\\n```\\nclass Solution {\\n    var fence = [[Int]]()\\n    var result = [[Int]]()\\n\\n    //this is to calculate the slope of two dots, HAVE to use Double\\n    func slope(_ spot1: [Int], _ spot2: [Int]) -> Double{\\n        return (Double(spot2[1]) - Double(spot1[1])) / (Double(spot2[0]) - Double(spot1[0]))\\n    }\\n  \\n    //Calculating the manhattanDistance(also known as the taxi distance) of two dots\\n    func manhattanDistance(_ spot1: [Int], _ spot2: [Int]) -> Int{\\n        return abs(spot1[0] - spot2[0]) + abs(spot1[1] - spot2[1])\\n    }\\n    \\n    //The core function of Graham scan\\n    func onTheFence(_ spot1: [Int], _ spot2: [Int], _ spot3: [Int]) -> Int{\\n        return (spot2[0] - spot1[0]) * (spot3[1] - spot1[1]) - (spot2[1] - spot1[1]) * (spot3[0] - spot1[0])\\n    }\\n\\n    //Main function\\n    func outerTrees(_ trees: [[Int]]) -> [[Int]] {\\n        var fence = [[Int]]()\\n\\n        if trees.count < 4{\\n            return trees\\n        }else{\\n            //Graham scan https://en.wikipedia.org/wiki/Graham_scan            \\n            //find the first tree\\n            var firstTree = [Int]()\\n            \\n            for tree in trees{\\n                if firstTree.isEmpty || tree[1] < firstTree[1]{\\n                    firstTree = tree\\n                }else if tree[1] == firstTree[1]{\\n                    if tree[0] < firstTree[0]{\\n                        firstTree = tree\\n                    }else{\\n                        continue\\n                    }\\n                }\\n            }\\n\\n            //sort all the trees by slope, but there\\'re things to consider:\\n            //I\\'m trying to not use cosine but cosine is easier\\n            //  Rule 1. if N.y == firstTree.y, the slope not exist, but those trees are in the middle of the line\\n            //  Rule 2. the slope of trees on the left(with the firstTree) are negative but for the trees on the right the slope is positive\\n            //  Rule 3. most important: first couple of trees with the same slope needs to be sorted by manhattan distance ASCENDING \\n            //          while the last couple of trees with the same slope need to be DESCENDING\\n            //\\n            //when you can\\'t come with elegant code, write something works\\n            var middleTrees = [[Int]]()\\n            var westTrees = [[Int]]()\\n            var eastTrees = [[Int]]()\\n            for tree in trees{\\n                //skip the first tree\\n                if tree == firstTree{\\n                    continue\\n                //get the trees in the middle line\\n                }else if tree[0] == firstTree[0]{\\n                    if middleTrees.isEmpty{\\n                        middleTrees.append(tree)\\n                    }else{\\n                        for spot in middleTrees{\\n                            if spot[1] < tree[1]{\\n                                if spot == middleTrees.last{\\n                                    middleTrees.append(tree)\\n                                    break\\n                                }\\n                                continue\\n                            }else{\\n                                middleTrees.insert(tree, at: middleTrees.firstIndex(of: spot)!)\\n                                break\\n                            }\\n                        }\\n                    }\\n                //get the trees on the right side of the middle line\\n                }else if tree[0] > firstTree[0]{\\n                    if eastTrees.isEmpty{\\n                        eastTrees.append(tree)\\n                    }else{\\n                        for spot in eastTrees{\\n                            if slope(spot, firstTree) < slope(tree, firstTree){\\n                                if spot == eastTrees.last{\\n                                    eastTrees.append(tree)\\n                                    break\\n                                }else{\\n                                    continue\\n                                }\\n                            }else if slope(spot, firstTree) == slope(tree, firstTree){\\n                                if spot[0] < tree[0]{\\n                                    if spot == eastTrees.last{\\n                                        eastTrees.append(tree)\\n                                        break\\n                                    }else{\\n                                        continue\\n                                    }\\n                                }else{\\n                                    eastTrees.insert(tree, at: eastTrees.firstIndex(of: spot)!)\\n                                    break\\n                                }\\n                            }else{\\n                                eastTrees.insert(tree, at: eastTrees.firstIndex(of: spot)!)\\n                                break\\n                            }\\n                        }\\n                    }\\n                //the rest of the trees are on the left side of the middle line\\n                }else{\\n                    if westTrees.isEmpty{\\n                        westTrees.append(tree)\\n                    }else{\\n                        for spot in westTrees{\\n                            if slope(spot, firstTree) < slope(tree, firstTree){\\n                                if spot == westTrees.last{\\n                                    westTrees.append(tree)\\n                                    break\\n                                }\\n                                continue\\n                            }else if slope(spot, firstTree) == slope(tree, firstTree){\\n                                if spot[0] < tree[0]{\\n                                    if spot == westTrees.last{\\n                                        westTrees.append(tree)\\n                                        break\\n                                    }\\n                                    continue\\n                                }else{\\n                                    westTrees.insert(tree, at: westTrees.firstIndex(of: spot)!)\\n                                    break\\n                                }\\n                            }else{\\n                                westTrees.insert(tree, at: westTrees.firstIndex(of: spot)!)\\n                                break\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            //combining all trees in order also making the line meets the 3rd rule\\n            if eastTrees.isEmpty && westTrees.isEmpty{\\n                middleTrees.append(firstTree)\\n                return middleTrees\\n            }else if westTrees.isEmpty{\\n                fence = eastTrees + middleTrees\\n                fence.reverse()\\n                var lastSlope = slope(firstTree, fence[0])\\n                var tail = [[Int]]()\\n                for tree in fence{\\n                  if slope(firstTree, tree) == lastSlope{\\n                    tail.append(tree)\\n                    fence.removeFirst(1)\\n                  }\\n                }\\n                fence.reverse()\\n                fence = fence + tail\\n            }else{\\n                fence = eastTrees + middleTrees + westTrees\\n            }\\n\\n            //one more thing to consider:\\n            //if there are more than 2 trees in the same line in the middle of the process, it is naccessary to sort them by manhattan distance\\n            for tree in fence{\\n                if result.isEmpty{\\n                    result.append(firstTree)\\n                    result.append(tree)\\n                    continue\\n                }else{\\n                    while onTheFence(result[result.count - 2], result[result.count - 1], tree) < 0{\\n                      result.removeLast()\\n                    }\\n                    \\n                    if onTheFence(result[result.count - 2], result[result.count - 1], tree) == 0{\\n                      if manhattanDistance(tree, result[result.count - 2]) > manhattanDistance(result[result.count - 1], result[result.count - 2]){\\n                        result.append(tree)\\n                      }else{\\n                        result.insert(tree, at: result.count - 1)\\n                      }\\n                    }else{\\n                        result.append(tree)\\n                    }\\n                }\\n            }\\n\\n            return result\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    var fence = [[Int]]()\\n    var result = [[Int]]()\\n\\n    //this is to calculate the slope of two dots, HAVE to use Double\\n    func slope(_ spot1: [Int], _ spot2: [Int]) -> Double{\\n        return (Double(spot2[1]) - Double(spot1[1])) / (Double(spot2[0]) - Double(spot1[0]))\\n    }\\n  \\n    //Calculating the manhattanDistance(also known as the taxi distance) of two dots\\n    func manhattanDistance(_ spot1: [Int], _ spot2: [Int]) -> Int{\\n        return abs(spot1[0] - spot2[0]) + abs(spot1[1] - spot2[1])\\n    }\\n    \\n    //The core function of Graham scan\\n    func onTheFence(_ spot1: [Int], _ spot2: [Int], _ spot3: [Int]) -> Int{\\n        return (spot2[0] - spot1[0]) * (spot3[1] - spot1[1]) - (spot2[1] - spot1[1]) * (spot3[0] - spot1[0])\\n    }\\n\\n    //Main function\\n    func outerTrees(_ trees: [[Int]]) -> [[Int]] {\\n        var fence = [[Int]]()\\n\\n        if trees.count < 4{\\n            return trees\\n        }else{\\n            //Graham scan https://en.wikipedia.org/wiki/Graham_scan            \\n            //find the first tree\\n            var firstTree = [Int]()\\n            \\n            for tree in trees{\\n                if firstTree.isEmpty || tree[1] < firstTree[1]{\\n                    firstTree = tree\\n                }else if tree[1] == firstTree[1]{\\n                    if tree[0] < firstTree[0]{\\n                        firstTree = tree\\n                    }else{\\n                        continue\\n                    }\\n                }\\n            }\\n\\n            //sort all the trees by slope, but there\\'re things to consider:\\n            //I\\'m trying to not use cosine but cosine is easier\\n            //  Rule 1. if N.y == firstTree.y, the slope not exist, but those trees are in the middle of the line\\n            //  Rule 2. the slope of trees on the left(with the firstTree) are negative but for the trees on the right the slope is positive\\n            //  Rule 3. most important: first couple of trees with the same slope needs to be sorted by manhattan distance ASCENDING \\n            //          while the last couple of trees with the same slope need to be DESCENDING\\n            //\\n            //when you can\\'t come with elegant code, write something works\\n            var middleTrees = [[Int]]()\\n            var westTrees = [[Int]]()\\n            var eastTrees = [[Int]]()\\n            for tree in trees{\\n                //skip the first tree\\n                if tree == firstTree{\\n                    continue\\n                //get the trees in the middle line\\n                }else if tree[0] == firstTree[0]{\\n                    if middleTrees.isEmpty{\\n                        middleTrees.append(tree)\\n                    }else{\\n                        for spot in middleTrees{\\n                            if spot[1] < tree[1]{\\n                                if spot == middleTrees.last{\\n                                    middleTrees.append(tree)\\n                                    break\\n                                }\\n                                continue\\n                            }else{\\n                                middleTrees.insert(tree, at: middleTrees.firstIndex(of: spot)!)\\n                                break\\n                            }\\n                        }\\n                    }\\n                //get the trees on the right side of the middle line\\n                }else if tree[0] > firstTree[0]{\\n                    if eastTrees.isEmpty{\\n                        eastTrees.append(tree)\\n                    }else{\\n                        for spot in eastTrees{\\n                            if slope(spot, firstTree) < slope(tree, firstTree){\\n                                if spot == eastTrees.last{\\n                                    eastTrees.append(tree)\\n                                    break\\n                                }else{\\n                                    continue\\n                                }\\n                            }else if slope(spot, firstTree) == slope(tree, firstTree){\\n                                if spot[0] < tree[0]{\\n                                    if spot == eastTrees.last{\\n                                        eastTrees.append(tree)\\n                                        break\\n                                    }else{\\n                                        continue\\n                                    }\\n                                }else{\\n                                    eastTrees.insert(tree, at: eastTrees.firstIndex(of: spot)!)\\n                                    break\\n                                }\\n                            }else{\\n                                eastTrees.insert(tree, at: eastTrees.firstIndex(of: spot)!)\\n                                break\\n                            }\\n                        }\\n                    }\\n                //the rest of the trees are on the left side of the middle line\\n                }else{\\n                    if westTrees.isEmpty{\\n                        westTrees.append(tree)\\n                    }else{\\n                        for spot in westTrees{\\n                            if slope(spot, firstTree) < slope(tree, firstTree){\\n                                if spot == westTrees.last{\\n                                    westTrees.append(tree)\\n                                    break\\n                                }\\n                                continue\\n                            }else if slope(spot, firstTree) == slope(tree, firstTree){\\n                                if spot[0] < tree[0]{\\n                                    if spot == westTrees.last{\\n                                        westTrees.append(tree)\\n                                        break\\n                                    }\\n                                    continue\\n                                }else{\\n                                    westTrees.insert(tree, at: westTrees.firstIndex(of: spot)!)\\n                                    break\\n                                }\\n                            }else{\\n                                westTrees.insert(tree, at: westTrees.firstIndex(of: spot)!)\\n                                break\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            //combining all trees in order also making the line meets the 3rd rule\\n            if eastTrees.isEmpty && westTrees.isEmpty{\\n                middleTrees.append(firstTree)\\n                return middleTrees\\n            }else if westTrees.isEmpty{\\n                fence = eastTrees + middleTrees\\n                fence.reverse()\\n                var lastSlope = slope(firstTree, fence[0])\\n                var tail = [[Int]]()\\n                for tree in fence{\\n                  if slope(firstTree, tree) == lastSlope{\\n                    tail.append(tree)\\n                    fence.removeFirst(1)\\n                  }\\n                }\\n                fence.reverse()\\n                fence = fence + tail\\n            }else{\\n                fence = eastTrees + middleTrees + westTrees\\n            }\\n\\n            //one more thing to consider:\\n            //if there are more than 2 trees in the same line in the middle of the process, it is naccessary to sort them by manhattan distance\\n            for tree in fence{\\n                if result.isEmpty{\\n                    result.append(firstTree)\\n                    result.append(tree)\\n                    continue\\n                }else{\\n                    while onTheFence(result[result.count - 2], result[result.count - 1], tree) < 0{\\n                      result.removeLast()\\n                    }\\n                    \\n                    if onTheFence(result[result.count - 2], result[result.count - 1], tree) == 0{\\n                      if manhattanDistance(tree, result[result.count - 2]) > manhattanDistance(result[result.count - 1], result[result.count - 2]){\\n                        result.append(tree)\\n                      }else{\\n                        result.insert(tree, at: result.count - 1)\\n                      }\\n                    }else{\\n                        result.append(tree)\\n                    }\\n                }\\n            }\\n\\n            return result\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834384,
                "title": "erect-the-fence-c-simple-solution",
                "content": "*** **Monotone chain algorithm** constructs the convex hull in O(n * log(n)) time. We have to sort the points first and then calculate the upper and lower hulls in O(n) time. The points will be sorted with respect to x-coordinates (with respect to y-coordinates in case of a tie in x-coordinates), we will then find the left most point and then try to rotate in clockwise direction and find the next point and then repeat the step until we reach the rightmost point and then again rotate in the clockwise direction and find the lower hull.***\\n\\n\\nComplexity Analsysis\\n\\nTime Complexity: O(n log n), because we need to sort the trees.\\nSpace Complexity: O(n).\\n\\n\\nclass Solution {\\npublic:\\n    static vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        \\n        // Andrew\\'s monotone chain method.\\n        sort(trees.begin() , trees.end() , []( const vector<int>& a, const vector<int>& b){\\n            return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\\n        });\\n        // left and right \\n        const int n = trees.size();\\n        vector<vector<int>>res;\\n        res.reserve(n);\\n        \\n        for(int i=0 ; i<n ; ++i){\\n            while(res.size() > 1 && orientation (res[res.size() - 2], res.back(),trees[i]) < 0)\\n                  res.pop_back();\\n            res.push_back(trees[i]);\\n                  \\n        }\\n        //If all points are along a line, size(ans) is n after left to right procedure.        \\n        if (size(res) == n) return res;\\n\\n        // right to left\\n        for (int i = n - 2; i >= 0; --i) {\\n            while (size(res) > 1 && orientation(res[size(res) - 2], res.back(), trees[i]) < 0) \\n                res.pop_back();\\n            res.push_back(trees[i]);\\n        }\\n        res.pop_back();\\n        return res;\\n    }\\n\\n    static int orientation(const vector<int>& a, const vector<int>& b, const vector<int>& c) {\\n             return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0]);\\n        }\\n                      \\n};",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n    static vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        \\n        // Andrew\\'s monotone chain method.\\n        sort(trees.begin() , trees.end() , []( const vector<int>& a, const vector<int>& b){\\n            return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2833456,
                "title": "erect-the-fence-scala-o-nk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically, this is a [convex hull](https://en.wikipedia.org/wiki/Convex_hull) problem. The solution is based on the observation that, for any two adjacent points, $$a$$ and $$b$$, on the hull (forming an edge on the hull), such that $$a$$ is before $$b$$ in a clockwise order, the next adjacent point on the hull, $$c$$, after $$b$$, forms the max angle $$\\\\widehat{abc}$$ of all angles $$\\\\widehat{abx}$$ where $$x$$ is any point inside or on the hull except $$a$$ and $$b$$.\\n\\n \\n![convex-hull.png](https://assets.leetcode.com/users/images/487342f2-6cb9-45ee-947c-2bbd90cc9321_1668951831.1689382.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will determine an initail point on the hull, then iteratively we will find the next adjacent point until the hull is closed (i.e. we finally meet the initial point). At each step we will keep two points, the head of the hull and its previous adjacent point (i.e. the previous head). Using these two points, we will iterate through all other remaining points (that are not on the hull yet), compute the angle $$\\\\widehat{\\\\text{previous head}, \\\\text{head}, \\\\text{point}}$$, and pick $$point$$ with the maximum angle as the next point on the hull.\\n\\nInitial point on the hull can be one of the following 4 cases:\\n1. Points with min y value.\\n2. Points with max y value.\\n3. Points with min x value.\\n4. Points with max x value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nk)$$ where $$k$$ is number of points on the hull\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nobject Solution {\\n    type Point = Array[Int]\\n    type Vec = Array[Int]\\n\\n    @inline def dot(v1: Vec, v2: Vec) = v1(0) * v2(0) + v1(1) * v2(1)\\n\\n    @inline def magnitude(v: Vec) = math.sqrt(dot(v, v))\\n\\n    @inline def vector(p1: Point, p2: Point) = Array(p1(0) - p2(0), p1(1) - p2(1))\\n\\n    @inline def pEq(p1: Point, p2: Point) = p1(0) == p2(0) && p1(1) == p2(1)\\n\\n    @inline def angle(pivot: Point, point1: Point, point2: Point) = {\\n        if (pEq(point1, point2)) 2 * math.Pi\\n        else if (pEq(pivot, point1) || pEq(pivot, point2)) 2 * math.Pi\\n        else {\\n            val v1 = vector(pivot, point1)\\n            val v2 = vector(pivot, point2)\\n            val cos = dot(v1, v2) / (magnitude(v1) * magnitude(v2))\\n            if (cos + 1 <= 0.0000001) math.Pi else math.acos(cos)\\n        }\\n    }\\n\\n    @inline def p2s(p: Point) = p.mkString(s\"[\", \",\", \"]\")\\n\\n    def showTrees(trees: Array[Point], scaleX: Int = 2): Unit = {\\n        val xMax = trees.map(_.head).max\\n        val yMax = trees.map(_.last).max\\n\\n        val xMargin = yMax.toString.length\\n        val yMargin = xMax.toString.length\\n\\n        val cols = scaleX * (xMax + 1) + xMargin\\n        val rows = (yMax + 1) + yMargin\\n\\n        // init grid space\\n        val grid = Array.fill[String](rows, cols)(\" \")\\n\\n        // draw x-axis\\n        grid.update(rows - 1 - yMargin, Array.fill[String](cols)(\"_\"))\\n        for {\\n            i    <- 0 to xMax\\n            label = i.toString\\n            xTick = scaleX * i + xMargin\\n            k    <- label.indices\\n            j     = rows - yMargin + k\\n            row   = grid(j)\\n        } {\\n            row.update(xTick, label(k).toString)\\n            grid.update(j, row)\\n        }\\n\\n        // draw y-axis\\n        for {\\n            i    <- 0 to yMax\\n            label = \" \" * (xMargin - i.toString.length) + i.toString + \"|\"\\n            yTick = rows - yMargin - i - 1\\n            row   = grid(yTick)\\n            k    <- label.indices\\n        } {\\n            row.update(k, label(k).toString)\\n            grid.update(yTick, row)\\n        }\\n\\n        // place points\\n        trees.foreach { p =>\\n            val row = grid(rows - yMargin - p.last - 1)\\n            row.update(scaleX * p.head + xMargin, \"+\")\\n            grid.update(rows - yMargin - p.last - 1, row)\\n        }\\n\\n        // show grid\\n        println(grid.map(_.mkString(\"\")).mkString(\"\\\\n\"))\\n    }\\n\\n    def outerTrees(trees: Array[Point]): Array[Point] = {\\n        // showTrees(trees)\\n        if (trees.length <= 1) trees\\n        else {\\n            val remaining = collection.mutable.HashSet[Point]()\\n            val convexHull = collection.mutable.HashSet[Point]()\\n\\n            // first corner point of the hull\\n            // val p0 = trees.sortBy(p => p(1)).head\\n            // val remaining = trees.remove(p0)\\n            val p0 = trees.tail.foldLeft(trees.head) { case (pOfMinY, currentP) =>\\n                if (currentP.last < pOfMinY.last) {\\n                    remaining += pOfMinY\\n                    currentP\\n                } else {\\n                    remaining += currentP\\n                    pOfMinY\\n                }\\n            }\\n            convexHull += p0\\n\\n            // returns the next point on the hull given the current head and the previous one\\n            def nextPoint(head: Point, pre: Point) = {\\n                // finds the point, p, in remaining list which produces the largest angle\\n                // between vectors: (head, pre) and (head, p)\\n                def a(rem: List[Point], p: Option[Point], pAngle: Option[Double]): Point = rem match {\\n                    case Nil =>\\n                        // base case: nothing to compare to, return p\\n                        p.get\\n                    case h :: t if pAngle.isEmpty =>\\n                        // initial case, pick h as p\\n                        a(t, Some(h), Some(angle(head, pre, h)))\\n                    case h :: t if pEq(h, head) || pEq(h, pre) =>\\n                        // edge case: h is already a hull point, just continue with p\\n                        // println(s\"\\\\tPreferring p=${p2s(p.get)} over h=${p2s(h)} as \" +\\n                        //         s\"h is either head=${p2s(head)} or pre=${p2s(pre)}\")\\n                        a(t, p, pAngle)\\n                    case h :: t if (pEq(p.get, head) || pEq(p.get, pre)) && !convexHull.contains(p.get) =>\\n                        // edge case: covering for arbitrary point picked initially as pre (which is not\\n                        // actually yet on hull)\\n                        // println(s\"\\\\tPreferring h=${p2s(h)} over p=${p2s(p.get)} as \" +\\n                        //         s\"p is either head=${p2s(head)} or pre=${p2s(pre)} and not on hull\")\\n                        a(t, Some(h), Some(angle(head, pre, h)))\\n                    case h :: t =>\\n                        val hAngle = angle(head, pre, h)\\n                        if (\\n                            // if hAngle is significantly bigger than pAngle\\n                            (math.abs(hAngle - pAngle.get) > 0.000001 && hAngle > pAngle.get) ||\\n                            // or (hAngle is approximatley equal to pAngle and\\n                            //     h is closer to head than p)\\n                            (math.abs(hAngle - pAngle.get) <= 0.000001 &&\\n                            magnitude(vector(head, h)) < magnitude(vector(head, p.get))\\n                            )\\n                        ) {\\n                            // pick h\\n                            // println(s\"\\\\tPreferring h=${p2s(h)} over p=${p2s(p.get)} as \" +\\n                            //     s\"hAngle=$hAngle > pAngle=${pAngle.get} (${hAngle > pAngle.get}) \" +\\n                            //     s\"||h||=${magnitude(vector(head, h))} < ||p||=${magnitude(vector(head, p.get))} \" +\\n                            //     s\"(${magnitude(vector(head, h)) < magnitude(vector(head, p.get))})\")\\n                            a(t, Some(h), Some(hAngle))\\n                         } else {\\n                            // o.w. keep p\\n                            //  println(s\"\\\\tPreferring p=${p2s(p.get)} over h=${p2s(h)} as \" +\\n                            //     s\"hAngle=$hAngle > pAngle=${pAngle.get} (${hAngle > pAngle.get}) \" +\\n                            //     s\"||h||=${magnitude(vector(head, h))} < ||p||=${magnitude(vector(head, p.get))} \" +\\n                            //     s\"(${magnitude(vector(head, h)) < magnitude(vector(head, p.get))})\")\\n                            a(t, p, pAngle)\\n                         }\\n                }\\n                // always add initial hull point, p0, to be able to detect when the hull is finally closed\\n                a(remaining.toList :+ p0, None, None)\\n            }\\n\\n            // pick an arbitrary point as pre of current hull head\\n            var preHead = remaining.head //Array(0, 0)\\n            var head = p0\\n            var isClosed = false\\n            // println(s\"First: ${p2s(head)}, Pre: ${p2s(preHead)}, remaining: ${remaining.map(p2s)}\")\\n\\n            while (remaining.nonEmpty && !isClosed) {\\n                val next = nextPoint(head, preHead)\\n                isClosed = next == p0\\n                if (!isClosed) {\\n                    remaining -= next\\n                    convexHull += next\\n                    preHead = head\\n                    head = next\\n                    // println(s\"Next: ${p2s(next)}, Pre: ${p2s(preHead)}, isClosed: $isClosed, remaining: ${remaining.map(p2s)}\")\\n                }\\n                // else println(\"Closed\")\\n            }\\n\\n            convexHull.toArray\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    type Point = Array[Int]\\n    type Vec = Array[Int]\\n\\n    @inline def dot(v1: Vec, v2: Vec) = v1(0) * v2(0) + v1(1) * v2(1)\\n\\n    @inline def magnitude(v: Vec) = math.sqrt(dot(v, v))\\n\\n    @inline def vector(p1: Point, p2: Point) = Array(p1(0) - p2(0), p1(1) - p2(1))\\n\\n    @inline def pEq(p1: Point, p2: Point) = p1(0) == p2(0) && p1(1) == p2(1)\\n\\n    @inline def angle(pivot: Point, point1: Point, point2: Point) = {\\n        if (pEq(point1, point2)) 2 * math.Pi\\n        else if (pEq(pivot, point1) || pEq(pivot, point2)) 2 * math.Pi\\n        else {\\n            val v1 = vector(pivot, point1)\\n            val v2 = vector(pivot, point2)\\n            val cos = dot(v1, v2) / (magnitude(v1) * magnitude(v2))\\n            if (cos + 1 <= 0.0000001) math.Pi else math.acos(cos)\\n        }\\n    }\\n\\n    @inline def p2s(p: Point) = p.mkString(s\"[\", \",\", \"]\")\\n\\n    def showTrees(trees: Array[Point], scaleX: Int = 2): Unit = {\\n        val xMax = trees.map(_.head).max\\n        val yMax = trees.map(_.last).max\\n\\n        val xMargin = yMax.toString.length\\n        val yMargin = xMax.toString.length\\n\\n        val cols = scaleX * (xMax + 1) + xMargin\\n        val rows = (yMax + 1) + yMargin\\n\\n        // init grid space\\n        val grid = Array.fill[String](rows, cols)(\" \")\\n\\n        // draw x-axis\\n        grid.update(rows - 1 - yMargin, Array.fill[String](cols)(\"_\"))\\n        for {\\n            i    <- 0 to xMax\\n            label = i.toString\\n            xTick = scaleX * i + xMargin\\n            k    <- label.indices\\n            j     = rows - yMargin + k\\n            row   = grid(j)\\n        } {\\n            row.update(xTick, label(k).toString)\\n            grid.update(j, row)\\n        }\\n\\n        // draw y-axis\\n        for {\\n            i    <- 0 to yMax\\n            label = \" \" * (xMargin - i.toString.length) + i.toString + \"|\"\\n            yTick = rows - yMargin - i - 1\\n            row   = grid(yTick)\\n            k    <- label.indices\\n        } {\\n            row.update(k, label(k).toString)\\n            grid.update(yTick, row)\\n        }\\n\\n        // place points\\n        trees.foreach { p =>\\n            val row = grid(rows - yMargin - p.last - 1)\\n            row.update(scaleX * p.head + xMargin, \"+\")\\n            grid.update(rows - yMargin - p.last - 1, row)\\n        }\\n\\n        // show grid\\n        println(grid.map(_.mkString(\"\")).mkString(\"\\\\n\"))\\n    }\\n\\n    def outerTrees(trees: Array[Point]): Array[Point] = {\\n        // showTrees(trees)\\n        if (trees.length <= 1) trees\\n        else {\\n            val remaining = collection.mutable.HashSet[Point]()\\n            val convexHull = collection.mutable.HashSet[Point]()\\n\\n            // first corner point of the hull\\n            // val p0 = trees.sortBy(p => p(1)).head\\n            // val remaining = trees.remove(p0)\\n            val p0 = trees.tail.foldLeft(trees.head) { case (pOfMinY, currentP) =>\\n                if (currentP.last < pOfMinY.last) {\\n                    remaining += pOfMinY\\n                    currentP\\n                } else {\\n                    remaining += currentP\\n                    pOfMinY\\n                }\\n            }\\n            convexHull += p0\\n\\n            // returns the next point on the hull given the current head and the previous one\\n            def nextPoint(head: Point, pre: Point) = {\\n                // finds the point, p, in remaining list which produces the largest angle\\n                // between vectors: (head, pre) and (head, p)\\n                def a(rem: List[Point], p: Option[Point], pAngle: Option[Double]): Point = rem match {\\n                    case Nil =>\\n                        // base case: nothing to compare to, return p\\n                        p.get\\n                    case h :: t if pAngle.isEmpty =>\\n                        // initial case, pick h as p\\n                        a(t, Some(h), Some(angle(head, pre, h)))\\n                    case h :: t if pEq(h, head) || pEq(h, pre) =>\\n                        // edge case: h is already a hull point, just continue with p\\n                        // println(s\"\\\\tPreferring p=${p2s(p.get)} over h=${p2s(h)} as \" +\\n                        //         s\"h is either head=${p2s(head)} or pre=${p2s(pre)}\")\\n                        a(t, p, pAngle)\\n                    case h :: t if (pEq(p.get, head) || pEq(p.get, pre)) && !convexHull.contains(p.get) =>\\n                        // edge case: covering for arbitrary point picked initially as pre (which is not\\n                        // actually yet on hull)\\n                        // println(s\"\\\\tPreferring h=${p2s(h)} over p=${p2s(p.get)} as \" +\\n                        //         s\"p is either head=${p2s(head)} or pre=${p2s(pre)} and not on hull\")\\n                        a(t, Some(h), Some(angle(head, pre, h)))\\n                    case h :: t =>\\n                        val hAngle = angle(head, pre, h)\\n                        if (\\n                            // if hAngle is significantly bigger than pAngle\\n                            (math.abs(hAngle - pAngle.get) > 0.000001 && hAngle > pAngle.get) ||\\n                            // or (hAngle is approximatley equal to pAngle and\\n                            //     h is closer to head than p)\\n                            (math.abs(hAngle - pAngle.get) <= 0.000001 &&\\n                            magnitude(vector(head, h)) < magnitude(vector(head, p.get))\\n                            )\\n                        ) {\\n                            // pick h\\n                            // println(s\"\\\\tPreferring h=${p2s(h)} over p=${p2s(p.get)} as \" +\\n                            //     s\"hAngle=$hAngle > pAngle=${pAngle.get} (${hAngle > pAngle.get}) \" +\\n                            //     s\"||h||=${magnitude(vector(head, h))} < ||p||=${magnitude(vector(head, p.get))} \" +\\n                            //     s\"(${magnitude(vector(head, h)) < magnitude(vector(head, p.get))})\")\\n                            a(t, Some(h), Some(hAngle))\\n                         } else {\\n                            // o.w. keep p\\n                            //  println(s\"\\\\tPreferring p=${p2s(p.get)} over h=${p2s(h)} as \" +\\n                            //     s\"hAngle=$hAngle > pAngle=${pAngle.get} (${hAngle > pAngle.get}) \" +\\n                            //     s\"||h||=${magnitude(vector(head, h))} < ||p||=${magnitude(vector(head, p.get))} \" +\\n                            //     s\"(${magnitude(vector(head, h)) < magnitude(vector(head, p.get))})\")\\n                            a(t, p, pAngle)\\n                         }\\n                }\\n                // always add initial hull point, p0, to be able to detect when the hull is finally closed\\n                a(remaining.toList :+ p0, None, None)\\n            }\\n\\n            // pick an arbitrary point as pre of current hull head\\n            var preHead = remaining.head //Array(0, 0)\\n            var head = p0\\n            var isClosed = false\\n            // println(s\"First: ${p2s(head)}, Pre: ${p2s(preHead)}, remaining: ${remaining.map(p2s)}\")\\n\\n            while (remaining.nonEmpty && !isClosed) {\\n                val next = nextPoint(head, preHead)\\n                isClosed = next == p0\\n                if (!isClosed) {\\n                    remaining -= next\\n                    convexHull += next\\n                    preHead = head\\n                    head = next\\n                    // println(s\"Next: ${p2s(next)}, Pre: ${p2s(preHead)}, isClosed: $isClosed, remaining: ${remaining.map(p2s)}\")\\n                }\\n                // else println(\"Closed\")\\n            }\\n\\n            convexHull.toArray\\n        }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2833342,
                "title": "swift-monotone-chain-solution",
                "content": "# Approach\\nBased on [Monotone chain (or convex hull) algorithm implementation proposed by Wikibooks](https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n log (n))$$\\n\\n# Code\\n```\\nclass Solution {\\n    func orientation(_ secondPreviousPoint: [Int], _ firstPreviousPoint: [Int], _ currentPoint: [Int]) -> Int {\\n      let lhs = (firstPreviousPoint[1] - secondPreviousPoint[1]) * (currentPoint[0] - firstPreviousPoint[0])\\n      let rhs = (firstPreviousPoint[0] - secondPreviousPoint[0]) * (currentPoint[1] - firstPreviousPoint[1])\\n      return lhs - rhs\\n    }\\n\\n    func outerTrees(_ points: [[Int]]) -> [[Int]] {\\n      let points = points.sorted { pt1, pt2 in\\n        pt1[0] < pt2[0] || pt1[0] == pt2[0] && pt1[1] < pt2[1]\\n      }\\n\\n      var hull: [[Int]] = []\\n\\n      for point in points {\\n        while hull.count >= 2 && orientation(hull[hull.count - 2], hull[hull.count - 1], point) > 0 {\\n          hull.removeLast()\\n        }\\n        hull.append(point)\\n      }\\n\\n      for point in points.lazy.reversed() {\\n        while hull.count >= 2 && orientation(hull[hull.count - 2], hull[hull.count - 1], point) > 0 {\\n          hull.removeLast()\\n        }\\n        hull.append(point)\\n      }\\n\\n      return Array(Set(hull))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func orientation(_ secondPreviousPoint: [Int], _ firstPreviousPoint: [Int], _ currentPoint: [Int]) -> Int {\\n      let lhs = (firstPreviousPoint[1] - secondPreviousPoint[1]) * (currentPoint[0] - firstPreviousPoint[0])\\n      let rhs = (firstPreviousPoint[0] - secondPreviousPoint[0]) * (currentPoint[1] - firstPreviousPoint[1])\\n      return lhs - rhs\\n    }\\n\\n    func outerTrees(_ points: [[Int]]) -> [[Int]] {\\n      let points = points.sorted { pt1, pt2 in\\n        pt1[0] < pt2[0] || pt1[0] == pt2[0] && pt1[1] < pt2[1]\\n      }\\n\\n      var hull: [[Int]] = []\\n\\n      for point in points {\\n        while hull.count >= 2 && orientation(hull[hull.count - 2], hull[hull.count - 1], point) > 0 {\\n          hull.removeLast()\\n        }\\n        hull.append(point)\\n      }\\n\\n      for point in points.lazy.reversed() {\\n        while hull.count >= 2 && orientation(hull[hull.count - 2], hull[hull.count - 1], point) > 0 {\\n          hull.removeLast()\\n        }\\n        hull.append(point)\\n      }\\n\\n      return Array(Set(hull))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833003,
                "title": "simple-javascript-understandable-solution-by-finding-cross-products",
                "content": "# Intuition\\n<!-- This is a standard problem of finding the convex hulls of the  given plotting points. -->\\n\\n# Approach\\n<!-- Andrew\\u2019s monotone convex hull Algorithm -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} trees\\n * @return {number[][]}\\n */\\n \\n //function to  find cross product the result will tell which way the two vectors turn\\nvar calculate = function(A,B,C)\\n{\\n    \\n    Ax = A[0] - B[0]\\n    Ay = A[1] - B[1]\\n    Bx = C[0] - B[0]\\n    By = C[1] - B[1]\\n\\n    return Ax*By - Ay*Bx    \\n}\\n\\n//if cross product less than zero that means we turn left else right\\nvar findLeft = function(convexHull,C)\\n{\\n\\n    while(convexHull.length >=2 && calculate(convexHull[convexHull.length-2],convexHull[convexHull.length-1],C) < 0)\\n    {   \\n        convexHull.pop()\\n    }\\n    convexHull.push(C)\\n    return convexHull\\n}\\n\\n\\nvar outerTrees = function(trees) {\\n\\n    trees.sort(function(a,b){                 //start by sorting the trees\\n    if( a[0] == b[0]) return a[1]-b[1];\\n        return a[0]-b[0];\\n        })\\n\\n    convexHullLower = []                       //we do two passes one upper and one lower and store it in seperate array\\n    convexHullUpper = []\\n \\n\\n    for(let i =0;i<trees.length;i++) {\\n\\n        if(convexHullLower.length<2)\\n        {\\n            convexHullLower.push(trees[i])\\n        }            \\n        else\\n        {\\n                convexHullLower = findLeft(convexHullLower,trees[i])\\n        }\\n\\n    }\\n    for(let i = trees.length-1;i>-1;i--)\\n    {\\n        \\n        if(convexHullUpper.length<2)\\n        {\\n            convexHullUpper.push(trees[i])\\n        }        \\n        else\\n        {\\n                convexHullUpper = findLeft(convexHullUpper,trees[i])\\n        }\\n    }\\n\\n    let convexHull = []\\n    convexHull.push(...convexHullLower)\\n    for(x in  convexHullUpper)                          //removig duplicates\\n    {\\n        if(!convexHull.includes(convexHullUpper[x]))\\n            convexHull.push(convexHullUpper[x])\\n    }\\n \\n    return convexHull\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} trees\\n * @return {number[][]}\\n */\\n \\n //function to  find cross product the result will tell which way the two vectors turn\\nvar calculate = function(A,B,C)\\n{\\n    \\n    Ax = A[0] - B[0]\\n    Ay = A[1] - B[1]\\n    Bx = C[0] - B[0]\\n    By = C[1] - B[1]\\n\\n    return Ax*By - Ay*Bx    \\n}\\n\\n//if cross product less than zero that means we turn left else right\\nvar findLeft = function(convexHull,C)\\n{\\n\\n    while(convexHull.length >=2 && calculate(convexHull[convexHull.length-2],convexHull[convexHull.length-1],C) < 0)\\n    {   \\n        convexHull.pop()\\n    }\\n    convexHull.push(C)\\n    return convexHull\\n}\\n\\n\\nvar outerTrees = function(trees) {\\n\\n    trees.sort(function(a,b){                 //start by sorting the trees\\n    if( a[0] == b[0]) return a[1]-b[1];\\n        return a[0]-b[0];\\n        })\\n\\n    convexHullLower = []                       //we do two passes one upper and one lower and store it in seperate array\\n    convexHullUpper = []\\n \\n\\n    for(let i =0;i<trees.length;i++) {\\n\\n        if(convexHullLower.length<2)\\n        {\\n            convexHullLower.push(trees[i])\\n        }            \\n        else\\n        {\\n                convexHullLower = findLeft(convexHullLower,trees[i])\\n        }\\n\\n    }\\n    for(let i = trees.length-1;i>-1;i--)\\n    {\\n        \\n        if(convexHullUpper.length<2)\\n        {\\n            convexHullUpper.push(trees[i])\\n        }        \\n        else\\n        {\\n                convexHullUpper = findLeft(convexHullUpper,trees[i])\\n        }\\n    }\\n\\n    let convexHull = []\\n    convexHull.push(...convexHullLower)\\n    for(x in  convexHullUpper)                          //removig duplicates\\n    {\\n        if(!convexHull.includes(convexHullUpper[x]))\\n            convexHull.push(convexHullUpper[x])\\n    }\\n \\n    return convexHull\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2832742,
                "title": "convex-hull-c-solution",
                "content": "//point o , a ,b me se a ko exclude krte hai clockwise hone pr\\n![IMG_20221120_142726.jpg](https://assets.leetcode.com/users/images/6d3f4ba0-b062-4fd4-85e9-eef058d9af35_1668934863.0723398.jpeg)\\n```\\nclass Solution {\\n    int cross(vector<int>&o,vector<int>&a,vector<int>&b){\\n        return (b[1]-o[1])*(a[0]-o[0])-(a[1]-o[1])*(b[0]-o[0]);\\n    }\\n    \\n    static bool equal(vector<int>&a,vector<int>&b){\\n        return a[0]==b[0] && a[1]==b[1];\\n    }\\n\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        int n = trees.size();\\n\\n        auto cmp = [&](const vector<int>& a,const vector<int> &b){\\n            return a[0]<b[0] || (a[0]==b[0]) && a[1]<b[1];\\n        };\\n        sort(trees.begin(),trees.end(),cmp);\\n        //pehle sare points ko sort krlo\\n        // iske bad ek lower hull aur upper hull bna lo\\n        //aur ek final ans or hull bna lo jisme sab result store hoga\\n        vector<vector<int>>L(n),U(n),H;\\n        // set<vector<int>>s;\\n        int p = 0;\\n         \\n        // fir lower hull nikal l0\\n        // jab bhi 3 points ajay tab condition strt kro lgana while vali\\n        //while ki condition me ye horha ki tumhare pas teen points hai o,a,b\\n        //tum unka cross nikal lo(oa,ab) ka agr vo:-\\n        //1. negative ay matlab clockwise direction me move kr rhe tab us point ko nahi lena hai i.e a  vale ko\\n        //2.agar +ve ay matlab anticlockwise direction aur usko fir respective hull me add krdo\\n        for(int i=0;i<n;i++){\\n            while(p>=2 && cross(L[p-2],L[p-1],trees[i])<0) p--;\\n            L[p++]=trees[i];\\n        }\\n        L.resize(p);//jitne points ho us hisab se resize krdo\\n        p=0;\\n        \\n        //same process upper hull ke lye rhegi last point se chalu krenge\\n        for(int i=n-1;i>=0;i--){\\n            while(p>=2 && cross(U[p-2],U[p-1],trees[i])<0) p--;\\n            U[p++]=trees[i];\\n        }\\n        U.resize(p);\\n        \\n        //ab dono hull me sirf unique values ko hi lenge aur final hull me push kra dnge\\n        for(auto it:L)H.push_back(it);\\n        for(auto it:U)H.push_back(it);\\n        \\n        sort(H.begin(),H.end(),cmp);\\n        H.erase(unique(H.begin(),H.end(),equal),H.end());\\n        return H;\\n    }\\n};\\nCREDITS:ANJALI RANI\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int cross(vector<int>&o,vector<int>&a,vector<int>&b){\\n        return (b[1]-o[1])*(a[0]-o[0])-(a[1]-o[1])*(b[0]-o[0]);\\n    }\\n    \\n    static bool equal(vector<int>&a,vector<int>&b){\\n        return a[0]==b[0] && a[1]==b[1];\\n    }\\n\\npublic:\\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\\n        int n = trees.size();\\n\\n        auto cmp = [&](const vector<int>& a,const vector<int> &b){\\n            return a[0]<b[0] || (a[0]==b[0]) && a[1]<b[1];\\n        };\\n        sort(trees.begin(),trees.end(),cmp);\\n        //pehle sare points ko sort krlo\\n        // iske bad ek lower hull aur upper hull bna lo\\n        //aur ek final ans or hull bna lo jisme sab result store hoga\\n        vector<vector<int>>L(n),U(n),H;\\n        // set<vector<int>>s;\\n        int p = 0;\\n         \\n        // fir lower hull nikal l0\\n        // jab bhi 3 points ajay tab condition strt kro lgana while vali\\n        //while ki condition me ye horha ki tumhare pas teen points hai o,a,b\\n        //tum unka cross nikal lo(oa,ab) ka agr vo:-\\n        //1. negative ay matlab clockwise direction me move kr rhe tab us point ko nahi lena hai i.e a  vale ko\\n        //2.agar +ve ay matlab anticlockwise direction aur usko fir respective hull me add krdo\\n        for(int i=0;i<n;i++){\\n            while(p>=2 && cross(L[p-2],L[p-1],trees[i])<0) p--;\\n            L[p++]=trees[i];\\n        }\\n        L.resize(p);//jitne points ho us hisab se resize krdo\\n        p=0;\\n        \\n        //same process upper hull ke lye rhegi last point se chalu krenge\\n        for(int i=n-1;i>=0;i--){\\n            while(p>=2 && cross(U[p-2],U[p-1],trees[i])<0) p--;\\n            U[p++]=trees[i];\\n        }\\n        U.resize(p);\\n        \\n        //ab dono hull me sirf unique values ko hi lenge aur final hull me push kra dnge\\n        for(auto it:L)H.push_back(it);\\n        for(auto it:U)H.push_back(it);\\n        \\n        sort(H.begin(),H.end(),cmp);\\n        H.erase(unique(H.begin(),H.end(),equal),H.end());\\n        return H;\\n    }\\n};\\nCREDITS:ANJALI RANI\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567657,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1688856,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1565263,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1688968,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1689236,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1689191,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1575714,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1689418,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1689658,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1689295,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1567657,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1688856,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1565263,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1688968,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1689236,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1689191,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1575714,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1689418,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1689658,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            },
            {
                "id": 1689295,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "The visualization should be self-evident. If you find it un-intuitive, please let me know, that means something I can improve. :D\\n\\nIt shows the basic steps of a particular algorithm that has been explained in many other posts listed here.\\n\\nThis visualizes the CXX solution I submitted, which took 94ms to run. It is about the average, so not the super-duper fastest.\\n\\n![image](https://assets.leetcode.com/users/images/868b5af3-f687-4833-94a3-3d350964fe6d_1630872933.6195335.gif)\\n\\n\\np5.js version:\\nhttps://editor.p5js.org/nitroglycerine/present/9TdE-ZFuD\\nUsage: punch `Toggle Autorun` to start viewing the animation \\uD83D\\uDE00\\n\\nWhat\\'s different in this one:\\nI have been making a few visualizations like this but every one of the previous ones were made by porting my CXX solution to JS by hand. So each time when I make a visualization I have to port the algo & write the viz code.\\nIn this one, I compiled the CXX solution to a JS file using EmScripten and inserted some code to generate the trace of the algo and feed that into the viz code. This saves the trouble of having to port the algo from CXX to JS. No duplicated work! \\uD83D\\uDC4C\\nThere is still something that can be improved, for example I would want to be able to \"break\" the CXX algo during its execution, and visualize its live status in the JavaScript code. That may be for some time later.\\n\\nThanks for viewing :D"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Amazing visualization. Just the answer I needed. Thank you!!!"
                    },
                    {
                        "username": "belkasn43",
                        "content": "Lovely visualization, thanks :)"
                    },
                    {
                        "username": "Omarito",
                        "content": "This helped me a lot!! Thanks a bunch!! You are doing god\\'s work here!"
                    },
                    {
                        "username": "denz1994",
                        "content": "This is so good. Thank you for the visualization."
                    },
                    {
                        "username": "mangoDD",
                        "content": "Thanks a lot for this visualization, It\\'s very easy to understand and it also leaves some room to think the solution from scratch."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Thanks it made solution really intuitive."
                    },
                    {
                        "username": "PrajapatiShefali",
                        "content": "Liked your efforts by making it so easy to visualize. "
                    },
                    {
                        "username": "72engineers",
                        "content": "This problem is definitely gonna break my streak for this November challenge."
                    },
                    {
                        "username": "ahmz",
                        "content": "[@jahid_shakil](/jahid_shakil) This video was really helpful.."
                    },
                    {
                        "username": "denz1994",
                        "content": "[@jahid_shakil](/jahid_shakil) This way of thinking is so helpful for working through hard problems. \\n\\nSteve Jobs had a similar approach to early mac development from his biography. https://www.folklore.org/StoryView.py?story=Saving_Lives.txt#:~:text=One%20of%20the%20things%20that,system%2C%20and%20load%20the%20Finder"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I have spent my whole great thoughtful day with LeetCode. 😂"
                    },
                    {
                        "username": "sdakshya23",
                        "content": "as a beginner how would i know that this question belongs to convex hull the topic tag also has  maths only in it "
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Haha been there . I have been ignoring these type of problems :)"
                    },
                    {
                        "username": "Shatvik",
                        "content": "cheaters out there !... \\uD83D\\uDE01"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "[@parikshitgupta2001](/parikshitgupta2001) It does not make sense. You have whole 24 Hours in a day. And it is near to unbelievable that you are not going to learn the technique and then code it.\n\nYou can check this video: https://www.youtube.com/watch?v=Vu84lmMzP2o"
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "For the hard ones, I just look at the solution then copy and paste"
                    },
                    {
                        "username": "_sowwn",
                        "content": "me too broh :\\')"
                    },
                    {
                        "username": "mingrui",
                        "content": "I think convex hull is too specific a topic to be an interview question."
                    },
                    {
                        "username": "shantanu_joshi21",
                        "content": "[YouTube Second Thread Convex Hull](https://youtu.be/G51AjY8tIcA) Watch first 10 minutes of this video, and you will get the concept."
                    },
                    {
                        "username": "namanvijay814",
                        "content": "Thanks for the video mate."
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "Thanks for the video, really helped in understanding the Algorithm."
                    },
                    {
                        "username": "bstodin",
                        "content": "I found a test on which the testing system gives the wrong solution.\\n\\nInput:\\n`trees = [[10,10],[10,8],[10,12],[12,12],[12,8],[11,11]]`\\n\\nLeetCode expected output:\\n`[[11,11],[12,12],[12,8],[10,8],[10,12],[10,10]]`\\n\\nCorrect output:\\n`[[10,10],[10,8],[10,12],[12,12],[12,8]]`\\n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "Indeed, and very weird. Perhaps they forgot to sort the points somewhere, since once the input above is sorted, the expected output is correct."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Getting a question like this in an interview is a nightmare for me \\uD83D\\uDE36"
                    },
                    {
                        "username": "safibadi",
                        "content": "Just sort the given array,\\nYou can imagin shoted array like this.\\n\\n![image](https://assets.leetcode.com/users/images/e52d2276-7364-4b8c-bd4a-872231715b70_1630692688.140091.jpeg)\\n\\n\\nstart with the first element of sorted array as first tree,\\ntraverse each element of array and as you notice that x cordinate of the previous and current element are different add previouse element in fence list. \\nWhile adding element to fence remove the elements that are already covered by new element. For checking if previous tree is now covered by the line formed by current tree use two point line eqaution.\\n\\nReferance:\\nTwo point line equation: https://www.cuemath.com/geometry/two-point-form/\\n\\nPoint is covered or not: https://www.emathzone.com/tutorials/geometry/position-of-point-with-respect-to-line.html#:~:text=If%20y%20is%20the%20ordinate,equation%20of%20the%20line%2C%20i.e.&text=Next%20we%20consider%20the%20difference%20y1%E2%80%93y%2C%20i.e.&text=(a)%20If%20the%20point%20A,y1%E2%80%93y%3E0\\n\\nx = fence[-2][0]\\ny = fence[-2][1]\\n\\nx1 = fence[-3][0]\\ny1 = fence[-3][1]\\n\\nx2 = fence[-1][0]\\ny2 = fence[-1][1]\\n\\na = y1 - y2\\nb = x2 - x1\\nc = x1*y2 - y1*x2\\n\\nif ( a*x + b*y + c < 0 and b>0 ) or ( a*x + b*y + c > 0 and b<0 ):\\n\\tdel fence[-2]"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=tAhT2qDgEyI\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This question should have Convex Hull in topics tag."
                    },
                    {
                        "username": "morningstar1",
                        "content": "Sometimes I felt like I was \"cheating\" when I look at the topics tag to figure out what algo to use, but sometimes that\\'s very helpful to my overall practice productivity. I can just skip the hour where I wrack my brain trying to remember an algorithm I might not even know about (lol), go learn a new algo, then try to apply it to the problem."
                    },
                    {
                        "username": "Ayesha-Imr",
                        "content": "1. Find the points with minimum and maximum x and y coordinates.\n2. Add them all to the fence vector.\n3. Find equation of all lines connecting the point with the minimum x-coordinate to the points with the max and min y-coordinates, and the point with the maximum x-coordinate to the points with the max and min y-coordinates  (in the form of y = mx + c).\n4. Check every other point to see that if any point satisfies any equation (by substituting values of x and y into the equation with m and c known), then add that point to the fence vector too.\n\nThis is a solution I came up with though I haven't tried coding it yet. Even if it does end up working, the time complexity will be too high. \nThis problem is next-level..."
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "I thought of the same approach. Does not work. Imagine if there were 5 outermost trees in the shape of an irregular pentagon. This approach won\\'t work for cases like that"
                    }
                ]
            }
        ]
    }
]