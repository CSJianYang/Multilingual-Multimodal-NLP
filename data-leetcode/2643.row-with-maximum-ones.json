[
    {
        "title": "Row With Maximum Ones",
        "question_content": "Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row.\nIn case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected.\nReturn an array containing the index of the row, and the number of ones in it.\n&nbsp;\nExample 1:\n\nInput: mat = [[0,1],[1,0]]\nOutput: [0,1]\nExplanation: Both rows have the same number of 1's. So we return the index of the smaller row, 0, and the maximum count of ones (1). So, the answer is [0,1]. \n\nExample 2:\n\nInput: mat = [[0,0,0],[0,1,1]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So we return its index, 1, and the count. So, the answer is [1,2].\n\nExample 3:\n\nInput: mat = [[0,0],[1,1],[0,0]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So the answer is [1,2].\n\n&nbsp;\nConstraints:\n\n\tm == mat.length&nbsp;\n\tn == mat[i].length&nbsp;\n\t1 <= m, n <= 100&nbsp;\n\tmat[i][j] is either 0 or 1.",
        "solutions": [
            {
                "id": 3421712,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0,index=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int val=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    val++;\\n                }\\n            }\\n            if(val>max)\\n            {\\n                index=i;\\n                max=val;\\n            }\\n        }\\n        return new int[]{index,max};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0,index=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int val=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    val++;\\n                }\\n            }\\n            if(val>max)\\n            {\\n                index=i;\\n                max=val;\\n            }\\n        }\\n        return new int[]{index,max};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421887,
                "title": "easy-solution-with-explaination",
                "content": "# Intuition\\nThe basic idea is to iterate over all rows of the matrix, and count the number of ones in each row. We keep track of the row with the maximum count of ones seen so far, and update it whenever we find a row with a larger count.\\n\\n# Approach\\nTo count the number of ones in a row, we simply iterate over all elements of the row and add up the ones.\\n\\nFinally, we return the index of the row with the maximum count of ones, along with the count itself, as a vector of two integers. If there are multiple rows with the maximum count, we return the one with the smallest row number, which is the first one encountered in the loop.\\n\\n# Complexity\\n- Time complexity:\\nThe solution has a time complexity of O(mn), which is the size of the matrix, since we need to iterate over all its elements. This is optimal, since we need to examine all rows and elements to determine the maximum count of ones.\\n\\n- Space complexity:\\nSpace complexity is O(1), since we aren\\'t using any extra space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int maxCount = 0;\\n        int maxRow = 0;\\n        for (int i = 0; i < m; i++) {\\n            int count = 0;\\n            for (int j = 0; j < n; j++) {\\n                count += mat[i][j];\\n            }\\n            if (count > maxCount) {\\n                maxCount = count;\\n                maxRow = i;\\n            }\\n        }\\n        return {maxRow, maxCount};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int maxCount = 0;\\n        int maxRow = 0;\\n        for (int i = 0; i < m; i++) {\\n            int count = 0;\\n            for (int j = 0; j < n; j++) {\\n                count += mat[i][j];\\n            }\\n            if (count > maxCount) {\\n                maxCount = count;\\n                maxRow = i;\\n            }\\n        }\\n        return {maxRow, maxCount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421854,
                "title": "easiest-solution-python3",
                "content": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:    \\n        ones = 0 \\n        index = 0\\n        for it, row in enumerate(mat):\\n            c = row.count(1)\\n            if ones < c:\\n                ones = c\\n                index = it\\n        \\n        return [index,ones]\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:    \\n        ones = 0 \\n        index = 0\\n        for it, row in enumerate(mat):\\n            c = row.count(1)\\n            if ones < c:\\n                ones = c\\n                index = it\\n        \\n        return [index,ones]\\n",
                "codeTag": "Java"
            },
            {
                "id": 3421700,
                "title": "c-bruteforce",
                "content": "**Count Ones in each row and update the answer**\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        //         {index,frequency}\\n        vector<int> res{-1, -1};\\n        for(int i = 0; i < mat.size(); ++i){\\n            int one = count(mat[i].begin(), mat[i].end(), 1);\\n            if(one > res[1])\\n                res = {i, one};\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        //         {index,frequency}\\n        vector<int> res{-1, -1};\\n        for(int i = 0; i < mat.size(); ++i){\\n            int one = count(mat[i].begin(), mat[i].end(), 1);\\n            if(one > res[1])\\n                res = {i, one};\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422458,
                "title": "c-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans(2);\\n        int ones = 0;\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                if(mat[i][j] == 1) ones++;\\n            }\\n            if(ones > ans[1]) {\\n                ans[0] = i;\\n                ans[1] = ones;\\n            }\\n            ones = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans(2);\\n        int ones = 0;\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                if(mat[i][j] == 1) ones++;\\n            }\\n            if(ones > ans[1]) {\\n                ans[0] = i;\\n                ans[1] = ones;\\n            }\\n            ones = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421881,
                "title": "simple-java-easy-explanation",
                "content": "# Intuition\\n\\nA straightforward method is to iterate through each row of the array and count the number of ones in each row. We can then keep track of the maximum number of ones seen so far and the index of the row with the maximum number of ones. At the end, we can return the index of the row with the maximum number of ones.\\n\\nTo implement this, we use two nested loops and one variable:\\n\\n\\u2022 \\'rowCount\\' to track the count of 1\\'s in each row.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force\\n\\n# Complexity\\n- Time complexity:  O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i=0; i<mat.length; i++){\\n            int rowCount = 0;\\n            for(int j=0; j<mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    rowCount++;\\n                }\\n            }\\n            if(rowCount > arr[1]){\\n                arr[1] = rowCount;\\n                arr[0] = i;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i=0; i<mat.length; i++){\\n            int rowCount = 0;\\n            for(int j=0; j<mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    rowCount++;\\n                }\\n            }\\n            if(rowCount > arr[1]){\\n                arr[1] = rowCount;\\n                arr[0] = i;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421837,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxVal=0,ind=-1,c=0;\\n        \\n        for(int i=0;i<mat.size();i++){\\n            c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]){\\n                    c++;\\n                }\\n            }\\n            if(c > maxVal){\\n                maxVal = c;\\n                ind=i;\\n            }\\n        }\\n        if(ind==-1){\\n            return vector<int> {0,0};\\n        }\\n        return vector<int> {ind,maxVal};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxVal=0,ind=-1,c=0;\\n        \\n        for(int i=0;i<mat.size();i++){\\n            c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]){\\n                    c++;\\n                }\\n            }\\n            if(c > maxVal){\\n                maxVal = c;\\n                ind=i;\\n            }\\n        }\\n        if(ind==-1){\\n            return vector<int> {0,0};\\n        }\\n        return vector<int> {ind,maxVal};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421675,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int ans[]=new int[2];\\n        int max=0;\\n        int ind=0;\\n        for(int i=0;i<mat.length;i++){\\n            int count=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n            if(count>max){\\n                max=count;\\n                ind=i;\\n            }\\n        }\\n        ans[0]=ind;\\n        ans[1]=max;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int ans[]=new int[2];\\n        int max=0;\\n        int ind=0;\\n        for(int i=0;i<mat.length;i++){\\n            int count=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n            if(count>max){\\n                max=count;\\n                ind=i;\\n            }\\n        }\\n        ans[0]=ind;\\n        ans[1]=max;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510886,
                "title": "python-go-easy-solution",
                "content": "# Python\\u2705\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        output = [0,0]\\n        for index, item in enumerate(mat):\\n            one_count = item.count(1)\\n            if one_count > output[1]:\\n                output[0] = index\\n                output[1] = one_count\\n        return output\\n\\n```\\n# Go\\u2705\\n```\\nfunc rowAndMaximumOnes(mat [][]int) []int {\\n    output := []int{0,0}\\n    for index, item := range mat {\\n        oneCount := 0\\n        for _, v := range item {\\n            if v == 1{\\n                oneCount++\\n            }\\n        }\\n        if oneCount > output[1] {\\n            output[0] = index\\n            output[1] = oneCount\\n        }\\n    }\\n    return output\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        output = [0,0]\\n        for index, item in enumerate(mat):\\n            one_count = item.count(1)\\n            if one_count > output[1]:\\n                output[0] = index\\n                output[1] = one_count\\n        return output\\n\\n```\n```\\nfunc rowAndMaximumOnes(mat [][]int) []int {\\n    output := []int{0,0}\\n    for index, item := range mat {\\n        oneCount := 0\\n        for _, v := range item {\\n            if v == 1{\\n                oneCount++\\n            }\\n        }\\n        if oneCount > output[1] {\\n            output[0] = index\\n            output[1] = oneCount\\n        }\\n    }\\n    return output\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503602,
                "title": "simple-sort-solution",
                "content": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        list1=[]\\n        for ind,row in enumerate(mat):\\n            list1.append([ind,row.count(1)])\\n        list1.sort(key=lambda x:[-x[1],x[0]])\\n        return list1[0]\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        list1=[]\\n        for ind,row in enumerate(mat):\\n            list1.append([ind,row.count(1)])\\n        list1.sort(key=lambda x:[-x[1],x[0]])\\n        return list1[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459775,
                "title": "java-easy-soln-o-row-col",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat){\\n        int ans[]=new int [2];\\n        int maxSum=0;\\n        int row=0;\\n        for(int i=0;i<mat.length;i++){\\n            int sum=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j]!=0) sum+=1;\\n                }\\n                if(sum>maxSum){\\n                maxSum=sum;\\n                row=i;\\n            }\\n            }\\n        ans[0]=row;\\n        ans[1]=maxSum;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat){\\n        int ans[]=new int [2];\\n        int maxSum=0;\\n        int row=0;\\n        for(int i=0;i<mat.length;i++){\\n            int sum=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j]!=0) sum+=1;\\n                }\\n                if(sum>maxSum){\\n                maxSum=sum;\\n                row=i;\\n            }\\n            }\\n        ans[0]=row;\\n        ans[1]=maxSum;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423453,
                "title": "java-6ms-beats-85-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n    int index=0;\\n        int maxOne=0;\\n        \\n        for(int i=0; i<mat.length; i++){\\n            int rowOnes=0;\\n//to count the number of ones in each row\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1) rowOnes++;\\n            }\\n            if(rowOnes>maxOne){\\n//checking whether the number of ones if maximum till now and updatng its value\\n                index=i;\\n                maxOne=rowOnes;\\n            }\\n        }\\n        \\n//creating a new array and returning it with the row number and number of ones in it\\n        return new int[]{index,maxOne};\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n    int index=0;\\n        int maxOne=0;\\n        \\n        for(int i=0; i<mat.length; i++){\\n            int rowOnes=0;\\n//to count the number of ones in each row\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1) rowOnes++;\\n            }\\n            if(rowOnes>maxOne){\\n//checking whether the number of ones if maximum till now and updatng its value\\n                index=i;\\n                maxOne=rowOnes;\\n            }\\n        }\\n        \\n//creating a new array and returning it with the row number and number of ones in it\\n        return new int[]{index,maxOne};\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421932,
                "title": "easy-solution-go-c",
                "content": "Initialize variables c and m to 0. c represents the index of the row with the maximum count of ones, and m represents the number of ones in that row.\\n\\nIterate over each row i in the matrix using a for loop. For each row i, initialize a temporary variable temp to 0, which will count the number of ones in the row.\\n\\nIterate over each column j in the current row i using another for loop. For each cell in the row, if the value is 1, increment the value of temp by 1.\\n\\nCompare the value of temp with the current maximum count of ones m. If temp is greater than m, update the values of c and m to the current row i and the number of ones in the row temp, respectively.\\n\\nOnce all rows have been iterated, return an array containing the index of the row with the maximum count of ones c and the number of ones in that row m.\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nGo\\n```\\nfunc rowAndMaximumOnes(mat [][]int) []int {\\n    var c, m int\\n\\n    for i := 0; i < len(mat); i++ {\\n        temp := 0\\n        for j := 0; j < len(mat[i]); j++ {\\n            if mat[i][j] == 1 {\\n                temp++\\n            }\\n        }\\n\\n        if temp > m {\\n            m = temp\\n            c = i\\n        }\\n    }\\n\\n    return []int{c, m}\\n}\\n\\n```\\nC#\\n```\\npublic class Solution {\\n    public int[] RowAndMaximumOnes(int[][] mat) {\\n        var c = 0;\\n        var m = 0;\\n\\n        for (var i = 0; i < mat.Length; i++)\\n        {\\n            var temp = 0;\\n            for (var j = 0; j < mat[i].Length; j++)\\n            {\\n                if (mat[i][j] == 1)\\n                {\\n                    temp++;\\n                }\\n            }\\n\\n            if (temp > m)\\n            {\\n                m = temp;\\n                c = i;\\n            }\\n        }\\n\\n        return new[] {c, m};\\n    }\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go"
                ],
                "code": "```\\nfunc rowAndMaximumOnes(mat [][]int) []int {\\n    var c, m int\\n\\n    for i := 0; i < len(mat); i++ {\\n        temp := 0\\n        for j := 0; j < len(mat[i]); j++ {\\n            if mat[i][j] == 1 {\\n                temp++\\n            }\\n        }\\n\\n        if temp > m {\\n            m = temp\\n            c = i\\n        }\\n    }\\n\\n    return []int{c, m}\\n}\\n\\n```\n```\\npublic class Solution {\\n    public int[] RowAndMaximumOnes(int[][] mat) {\\n        var c = 0;\\n        var m = 0;\\n\\n        for (var i = 0; i < mat.Length; i++)\\n        {\\n            var temp = 0;\\n            for (var j = 0; j < mat[i].Length; j++)\\n            {\\n                if (mat[i][j] == 1)\\n                {\\n                    temp++;\\n                }\\n            }\\n\\n            if (temp > m)\\n            {\\n                m = temp;\\n                c = i;\\n            }\\n        }\\n\\n        return new[] {c, m};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421897,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans = {0,0};\\n        int i,j,m=mat.size(),n=mat[0].size(),x;\\n        for(i = 0; i < m; i++){\\n            x = 0;\\n            for(j = 0; j < n; j++){\\n                x += mat[i][j];\\n            }\\n            if(x>ans[1]){\\n                ans = {i,x};\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans = {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 3421891,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcount=0;\\n        int index=0;\\n        for(int i=0;i<mat.size();i++){\\n            int countone=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1){\\n                    countone++;\\n                }\\n        }\\n             if(countone>maxcount){\\n                 maxcount=countone;\\n                index=i;\\n             }\\n        }\\n        return{index,maxcount};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcount=0;\\n        int index=0;\\n        for(int i=0;i<mat.size();i++){\\n            int countone=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1){\\n                    countone++;\\n                }\\n        }\\n             if(countone>maxcount){\\n                 maxcount=countone;\\n                index=i;\\n             }\\n        }\\n        return{index,maxcount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421778,
                "title": "clean-easy-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int row=0, maxOnes=0;\\n        for(int i=0; i<mat.length; i++){\\n            int ones = 0;\\n            for(int j=0; j<mat[0].length; j++)\\n                if(mat[i][j] == 1) ones++;\\n            if(maxOnes < ones){\\n                row = i;\\n                maxOnes = ones;\\n            }\\n        }\\n        return new int[]{row,maxOnes};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int row=0, maxOnes=0;\\n        for(int i=0; i<mat.length; i++){\\n            int ones = 0;\\n            for(int j=0; j<mat[0].length; j++)\\n                if(mat[i][j] == 1) ones++;\\n            if(maxOnes < ones){\\n                row = i;\\n                maxOnes = ones;\\n            }\\n        }\\n        return new int[]{row,maxOnes};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044301,
                "title": "beats-100-beginner-friendly-approach-using-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     int count, ansY=0, ansX=0;\\n        for(int i=0; i<mat.size();i++){\\n            count = 0;\\n            for(int j=0; j<mat[0].size();j++){\\n              count+=mat[i][j];\\n            }\\n            if(count>ansY){\\n                ansY=count;\\n                ansX=i;\\n            }\\n        }\\n\\n        return {ansX,ansY};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     int count, ansY=0, ansX=0;\\n        for(int i=0; i<mat.size();i++){\\n            count = 0;\\n            for(int j=0; j<mat[0].size();j++){\\n              count+=mat[i][j];\\n            }\\n            if(count>ansY){\\n                ansY=count;\\n                ansX=i;\\n            }\\n        }\\n\\n        return {ansX,ansY};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596424,
                "title": "simple-brute-force-approach-tc-o-m-n-sc-o-1",
                "content": "\\n\\n# Approach\\nUse Nested loops & traverse on the complete matrix & just check the conditions & maitain the maxi variable\\n\\n# Complexity\\n- Time complexity: O( m*n )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& matrix) {\\n        int m = matrix.size(); // no. of rows\\n        int n = matrix[0].size(); //no. of column\\n        int maxi = 0 , cnt =0;\\n        int index = 0; // if no row found still retrun 0\\n        for(int i =0 ; i<m ;i++){\\n               cnt = 0;\\n            for(int j =0 ;j<n; j++){\\n                if(matrix[i][j] ==1){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt > maxi ){\\n                index = i;\\n            }\\n            maxi = max(maxi, cnt);\\n          \\n        }\\n    \\n    return {index , maxi};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& matrix) {\\n        int m = matrix.size(); // no. of rows\\n        int n = matrix[0].size(); //no. of column\\n        int maxi = 0 , cnt =0;\\n        int index = 0; // if no row found still retrun 0\\n        for(int i =0 ; i<m ;i++){\\n               cnt = 0;\\n            for(int j =0 ;j<n; j++){\\n                if(matrix[i][j] ==1){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt > maxi ){\\n                index = i;\\n            }\\n            maxi = max(maxi, cnt);\\n          \\n        }\\n    \\n    return {index , maxi};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478298,
                "title": "easy-beginner-friendly-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     int res = 0, mx = 0;\\n        for(int i = 0 ; i < mat.size() ; i++) {\\n            int one = 0;\\n            for(int j = 0 ; j < mat[0].size() ; j++) one += (mat[i][j] == 1);\\n            if(one > mx) {\\n                mx = one;\\n                res = i;\\n            }\\n        }\\n        return {res, mx};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     int res = 0, mx = 0;\\n        for(int i = 0 ; i < mat.size() ; i++) {\\n            int one = 0;\\n            for(int j = 0 ; j < mat[0].size() ; j++) one += (mat[i][j] == 1);\\n            if(one > mx) {\\n                mx = one;\\n                res = i;\\n            }\\n        }\\n        return {res, mx};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431777,
                "title": "dfs-solution-different-approach-full-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe dfs function is a helper function that performs a depth-first search (DFS) traversal on the input matrix mat starting from the cell at index (i, j). It uses recursion to explore neighboring cells in the matrix and counts the number of 1s encountered. It also marks the visited cells by setting their value to -1. This function updates the count parameter by reference, which keeps track of the number of 1s encountered during the traversal.\\n\\nThe rowAndMaximumOnes function is the main function that solves the problem. It takes a 2D vector mat as input, representing the matrix of 0s and 1s. The goal is to find the row in the matrix that contains the maximum number of 1s, and return that row index along with the count of 1s in that row.\\n\\nThe function iterates through the cells of the matrix using nested for-loops. For each cell that contains a 1, it calls the dfs function to count the number of 1s in the connected component of that 1. It keeps track of the maximum count of 1s encountered and the corresponding row index. It also uses some additional variables, such as prevCount and prevRow, to optimize the DFS traversal by reusing the count from the previous row if the current row is the same as the previous row. Finally, the function returns the row index and the maximum count of 1s as a vector of two integers.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& mat,int i,int j,int &count){\\n\\n        if(i>=mat.size() || i<0 || j>=mat[0].size() || j<0){\\n            return;\\n        }\\n        if(mat[i][j]==1){\\n\\n            mat[i][j]=-1;\\n            count++;\\n            dfs(mat,i,j+1,count);\\n            dfs(mat,i,j-1,count);\\n        }\\n    }\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxCountRow,maxCount=0;\\n        int prevCount=0;\\n        int prevRow=-1;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1){\\n                    int count=0;\\n                    if(i==prevRow){\\n                        count = prevCount;\\n                    }\\n                    \\n                    dfs(mat,i,j,count);\\n                    if(count>maxCount){ maxCount=count; maxCountRow=i;}\\n                    prevCount=count;\\n                    prevRow = i;\\n                }\\n            }\\n        }\\n\\n        return {maxCountRow,maxCount};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& mat,int i,int j,int &count){\\n\\n        if(i>=mat.size() || i<0 || j>=mat[0].size() || j<0){\\n            return;\\n        }\\n        if(mat[i][j]==1){\\n\\n            mat[i][j]=-1;\\n            count++;\\n            dfs(mat,i,j+1,count);\\n            dfs(mat,i,j-1,count);\\n        }\\n    }\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxCountRow,maxCount=0;\\n        int prevCount=0;\\n        int prevRow=-1;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1){\\n                    int count=0;\\n                    if(i==prevRow){\\n                        count = prevCount;\\n                    }\\n                    \\n                    dfs(mat,i,j,count);\\n                    if(count>maxCount){ maxCount=count; maxCountRow=i;}\\n                    prevCount=count;\\n                    prevRow = i;\\n                }\\n            }\\n        }\\n\\n        return {maxCountRow,maxCount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427083,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        row=0\\n        value=0\\n        for i,j in enumerate(mat):\\n            one=j.count(1)\\n            if one>value:\\n                value=one\\n                row=i\\n        return [row, value]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        row=0\\n        value=0\\n        for i,j in enumerate(mat):\\n            one=j.count(1)\\n            if one>value:\\n                value=one\\n                row=i\\n        return [row, value]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423064,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut res = vec![-1, -1];\\n        for (i, row) in mat.into_iter().enumerate() {\\n            let ones = row.iter().filter(|&&x| x == 1).count() as i32;\\n            if ones > res[1] {\\n                res[0] = i as i32;\\n                res[1] = ones;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut res = vec![-1, -1];\\n        for (i, row) in mat.into_iter().enumerate() {\\n            let ones = row.iter().filter(|&&x| x == 1).count() as i32;\\n            if ones > res[1] {\\n                res[0] = i as i32;\\n                res[1] = ones;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422647,
                "title": "python3-solutions-with-explanation-enumeration-numpy",
                "content": "\\u0421ount ones within rows and update index if number of ones exceeds current maximum\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        row_idx, max_ones = 0, 0\\n    \\n        for idx, row in enumerate(mat):\\n            cur_ones = sum(row)\\n\\n            if cur_ones > max_ones:\\n                row_idx, max_ones = idx, cur_ones\\n\\n        return [row_idx, max_ones]\\n```\\nI would say it is a slower version, but at least something different:\\n1) Find indices of elements within rows that contain ones\\n2) Count occurrences of these elements along the rows\\n3) If there are ones, we output the index of the row containing the maximum number of ones, otherwise we return zeros as index and maximum count ones\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        ones = np.where(np.array(mat) == 1)[0]\\n        counts = np.bincount(ones)\\n        \\n        return [np.argmax(counts), counts[np.argmax(counts)]] if sum(counts) else [0, 0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        row_idx, max_ones = 0, 0\\n    \\n        for idx, row in enumerate(mat):\\n            cur_ones = sum(row)\\n\\n            if cur_ones > max_ones:\\n                row_idx, max_ones = idx, cur_ones\\n\\n        return [row_idx, max_ones]\\n```\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        ones = np.where(np.array(mat) == 1)[0]\\n        counts = np.bincount(ones)\\n        \\n        return [np.argmax(counts), counts[np.argmax(counts)]] if sum(counts) else [0, 0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421883,
                "title": "c-easy-peasy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int max_count = 0;\\n        int max_row_index = -1;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        for (int i = 0; i < m; i++) {\\n            int count = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            if (count > max_count) {\\n                max_count = count;\\n                max_row_index = i;\\n            }\\n        }\\n        \\n        if (max_row_index == -1) {\\n            return {0, 0};\\n        }\\n        \\n        vector<int> result = {max_row_index, max_count};\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int max_count = 0;\\n        int max_row_index = -1;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        for (int i = 0; i < m; i++) {\\n            int count = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            if (count > max_count) {\\n                max_count = count;\\n                max_row_index = i;\\n            }\\n        }\\n        \\n        if (max_row_index == -1) {\\n            return {0, 0};\\n        }\\n        \\n        vector<int> result = {max_row_index, max_count};\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421864,
                "title": "c-linear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n*m)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n        vector<int> ans(2,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n            if(mat[i][m-1]>ans[1]){\\n                ans[0]=i;\\n                ans[1]=mat[i][m-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n        vector<int> ans(2,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n            if(mat[i][m-1]>ans[1]){\\n                ans[0]=i;\\n                ans[1]=mat[i][m-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421800,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int maxCount = 0;\\n        int index = 0;\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            int countOne = 0;\\n            for(int j = 0; j < mat[0].length; j++) {\\n                if(mat[i][j] == 1) {\\n                    countOne++;\\n                }\\n            }\\n            \\n            if(countOne > maxCount) {\\n                maxCount = countOne;\\n                index = i;\\n            }\\n        }\\n        return new int[] {index, maxCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int maxCount = 0;\\n        int index = 0;\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            int countOne = 0;\\n            for(int j = 0; j < mat[0].length; j++) {\\n                if(mat[i][j] == 1) {\\n                    countOne++;\\n                }\\n            }\\n            \\n            if(countOne > maxCount) {\\n                maxCount = countOne;\\n                index = i;\\n            }\\n        }\\n        return new int[] {index, maxCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037301,
                "title": "easy-solution-in-c-2beats-86-31-of-users-with-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n//initilize a vector to store answer to return mac row with max ones\\n        vector<int>ans;\\n//it store row with max ones\\n        int maxrow=-1;\\n//it store max number of ones in a row\\n        int maxones=-1;\\n        int row=mat.size();\\n        for(int i=0;i<row;i++){\\n//count max ones in a row\\n            int countones=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    countones++;\\n                }\\n            }\\n//compare the maxones with countones and update \\n            if(maxones<countones){\\n                maxones=countones;\\n                maxrow=i;\\n            }\\n        }\\n//push in a vector to return answer\\n        ans.push_back(maxrow);\\n        ans.push_back(maxones);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n//initilize a vector to store answer to return mac row with max ones\\n        vector<int>ans;\\n//it store row with max ones\\n        int maxrow=-1;\\n//it store max number of ones in a row\\n        int maxones=-1;\\n        int row=mat.size();\\n        for(int i=0;i<row;i++){\\n//count max ones in a row\\n            int countones=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    countones++;\\n                }\\n            }\\n//compare the maxones with countones and update \\n            if(maxones<countones){\\n                maxones=countones;\\n                maxrow=i;\\n            }\\n        }\\n//push in a vector to return answer\\n        ans.push_back(maxrow);\\n        ans.push_back(maxones);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927224,
                "title": "easy-solution-for-begginer-fast-than-90-18-best-memory-than-99-14",
                "content": "![Screenshot_307.png](https://assets.leetcode.com/users/images/13fcd1a5-36fc-46f8-9070-42c6b3c3ae79_1692366483.620762.png)\\n\\n# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        maxValue = 0\\n        index = 0\\n        for m in range(len(mat)):\\n            sumN = 0\\n            sumN = sum(mat[m])\\n            if sumN > maxValue:\\n                index =  m\\n            maxValue=max(maxValue,sumN)\\n        return [index,maxValue]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        maxValue = 0\\n        index = 0\\n        for m in range(len(mat)):\\n            sumN = 0\\n            sumN = sum(mat[m])\\n            if sumN > maxValue:\\n                index =  m\\n            maxValue=max(maxValue,sumN)\\n        return [index,maxValue]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806426,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        Map<Integer,Integer>hash=new HashMap<>();\\n          int [] arr=new int[2];\\n\\n       for(int i=0;i<mat.length;i++){\\n           int max=0;\\n           for(int j=0;j<mat[i].length;j++){\\n                max+=mat[i][j];\\n           }\\n           hash.put(i,max);\\n       }\\n       int ind=0;\\n       int val=Integer.MIN_VALUE;;\\n        for(int i=0;i<hash.size();i++){\\n            if(val<hash.get(i)){\\n                val=hash.get(i);\\n                ind=i;\\n            }\\n        }\\narr[0]=ind;\\narr[1]=val;\\n               return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        Map<Integer,Integer>hash=new HashMap<>();\\n          int [] arr=new int[2];\\n\\n       for(int i=0;i<mat.length;i++){\\n           int max=0;\\n           for(int j=0;j<mat[i].length;j++){\\n                max+=mat[i][j];\\n           }\\n           hash.put(i,max);\\n       }\\n       int ind=0;\\n       int val=Integer.MIN_VALUE;;\\n        for(int i=0;i<hash.size();i++){\\n            if(val<hash.get(i)){\\n                val=hash.get(i);\\n                ind=i;\\n            }\\n        }\\narr[0]=ind;\\narr[1]=val;\\n               return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802330,
                "title": "binary-search-method",
                "content": "# Intuition\\n**Binary Search**\\n\\n# Approach\\n- traverse through matrix \\n- count the no. of 1s present in it using binary search\\n- for Binary search I have used function , which first sorts the row and the searches for the 1st One [ 0 0 0 **1** 1 1 1] \\n- when the while loop ends , our low will be pointing to the 1st One index\\n- total number of 1s present. = (n-1)-low+1 ( same as length of the sliding window j-i+1)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n O(N * NlogN) // here this could be optimised if we use linear search ,    because in that we don\\'t requie to sort the row, which could save our **nlogn** time\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint noOfOnes(vector<int>&row,int n){\\n    if(n==1)return row[0]==1;\\n    int low =0;\\n    int high = n-1;\\n    sort(row.begin(),row.end());\\n\\n    while(low<=high){\\n        int mid = low+(high-low)/2;\\n\\n        if(row[mid]==1){\\n            high = mid-1;\\n        }else{\\n            low=mid+1;\\n        }\\n    }\\n    return (n-1)-low+1;\\n}\\nvector<int> rowAndMaximumOnes(vector<vector<int>>& matrix) {\\n   int max1=0;\\n   int indexOfMaxRow=0;\\n   int n= matrix.size();\\n       int m = matrix[0].size();\\n   for(int i=0;i<n;i++){\\n       int OneINThisRow = noOfOnes(matrix[i],m);\\n       if(OneINThisRow>max1){\\n           max1=OneINThisRow;\\n           indexOfMaxRow = i;\\n       }\\n   }\\n   return {indexOfMaxRow,max1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint noOfOnes(vector<int>&row,int n){\\n    if(n==1)return row[0]==1;\\n    int low =0;\\n    int high = n-1;\\n    sort(row.begin(),row.end());\\n\\n    while(low<=high){\\n        int mid = low+(high-low)/2;\\n\\n        if(row[mid]==1){\\n            high = mid-1;\\n        }else{\\n            low=mid+1;\\n        }\\n    }\\n    return (n-1)-low+1;\\n}\\nvector<int> rowAndMaximumOnes(vector<vector<int>>& matrix) {\\n   int max1=0;\\n   int indexOfMaxRow=0;\\n   int n= matrix.size();\\n       int m = matrix[0].size();\\n   for(int i=0;i<n;i++){\\n       int OneINThisRow = noOfOnes(matrix[i],m);\\n       if(OneINThisRow>max1){\\n           max1=OneINThisRow;\\n           indexOfMaxRow = i;\\n       }\\n   }\\n   return {indexOfMaxRow,max1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700572,
                "title": "row-with-maximum-ones-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int sum = 0;\\n        int index = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<mat.length; i++){\\n            count = 0;\\n            for(int j=0; j<mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n            if(count > sum){\\n                sum = count;\\n                index = i;\\n            }\\n        }\\n        int[] arr ={index,sum};\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int sum = 0;\\n        int index = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<mat.length; i++){\\n            count = 0;\\n            for(int j=0; j<mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n            if(count > sum){\\n                sum = count;\\n                index = i;\\n            }\\n        }\\n        int[] arr ={index,sum};\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692917,
                "title": "very-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcount=0;\\n        int index=0;\\n        for(int i=0;i<mat.size();i++){\\n            int countone=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1)\\n                    countone++;\\n                }\\n             if(countone>maxcount){\\n                 maxcount=countone;\\n                index=i;\\n                }\\n        }\\n        return{index,maxcount};\\n    }\\n};\\n```\\n![leetcode upvote.jpg](https://assets.leetcode.com/users/images/4e3da845-1bff-4b18-b600-051d45d0cc61_1687953880.5652628.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcount=0;\\n        int index=0;\\n        for(int i=0;i<mat.size();i++){\\n            int countone=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1)\\n                    countone++;\\n                }\\n             if(countone>maxcount){\\n                 maxcount=countone;\\n                index=i;\\n                }\\n        }\\n        return{index,maxcount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541374,
                "title": "simple-java-solution-for-beginners-2ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int count;\\n        int maxCount = 0;\\n        int maxCountRow = 0;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[0].length; j++) {\\n                count += mat[i][j];\\n            }\\n            if(count > maxCount) {\\n                maxCount = count;\\n                maxCountRow = i;\\n            }\\n        }\\n        return new int[]{maxCountRow, maxCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int count;\\n        int maxCount = 0;\\n        int maxCountRow = 0;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[0].length; j++) {\\n                count += mat[i][j];\\n            }\\n            if(count > maxCount) {\\n                maxCount = count;\\n                maxCountRow = i;\\n            }\\n        }\\n        return new int[]{maxCountRow, maxCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541346,
                "title": "simple-java-solution-for-beginners-5ms-beats-84-48",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int arr[] = new int[2];\\n        int count;\\n        int maxCount = Integer.MIN_VALUE;\\n        int maxCountIndex = -1;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[i].length; j++) {\\n                if(mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            maxCountIndex = count > maxCount ? i : maxCountIndex;\\n            maxCount = Integer.max(count, maxCount);\\n        }\\n        arr[0] = maxCountIndex;\\n        arr[1] = maxCount;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int arr[] = new int[2];\\n        int count;\\n        int maxCount = Integer.MIN_VALUE;\\n        int maxCountIndex = -1;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[i].length; j++) {\\n                if(mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            maxCountIndex = count > maxCount ? i : maxCountIndex;\\n            maxCount = Integer.max(count, maxCount);\\n        }\\n        arr[0] = maxCountIndex;\\n        arr[1] = maxCount;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519424,
                "title": "beginners-friendly-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    keep track of count of 1 for every row and \\n    update the row and max when we encounter greater count of 1 than \\n    previous\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0;\\n        int row=0;\\n        \\n\\n        for(int i=0;i<mat.length;i++){\\n            int count=0;\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1) count++;\\n            }\\n            if(count>max){\\n                max= count;\\n                row=i;\\n            }\\n            \\n        }\\n\\n        return new int[] {row,max};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0;\\n        int row=0;\\n        \\n\\n        for(int i=0;i<mat.length;i++){\\n            int count=0;\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1) count++;\\n            }\\n            if(count>max){\\n                max= count;\\n                row=i;\\n            }\\n            \\n        }\\n\\n        return new int[] {row,max};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484456,
                "title": "python-one-liner",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        return sorted([(ind,val.count(1)) for ind,val in enumerate(mat)],key=lambda x:[-x[1],x[0]])[0]\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        return sorted([(ind,val.count(1)) for ind,val in enumerate(mat)],key=lambda x:[-x[1],x[0]])[0]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455090,
                "title": "easy-solution-with-javascript-just-checkout-how-much-it-s-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n**2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let ans=[-1,-1];\\n    let row=mat.length;\\n    let col=mat[0].length;\\n\\n    for(let i=0; i<row; i++){\\n        let zero=0;\\n        let ones=0;\\n        for(let j=0; j<col; j++){\\n            if(mat[i][j]==0){\\n                zero++;\\n            }else{\\n                ones++;\\n            }\\n        }\\n        let max=Math.max(ones, ans[1]);\\n        if(max>ans[1]){\\n            ans[0]=i;\\n            ans[1]=max;\\n        }\\n        \\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let ans=[-1,-1];\\n    let row=mat.length;\\n    let col=mat[0].length;\\n\\n    for(let i=0; i<row; i++){\\n        let zero=0;\\n        let ones=0;\\n        for(let j=0; j<col; j++){\\n            if(mat[i][j]==0){\\n                zero++;\\n            }else{\\n                ones++;\\n            }\\n        }\\n        let max=Math.max(ones, ans[1]);\\n        if(max>ans[1]){\\n            ans[0]=i;\\n            ans[1]=max;\\n        }\\n        \\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3434594,
                "title": "rust-sum-approach",
                "content": "Sum all the values to count number of 1s as it is just 1s and 0s. No need to filter.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut ans: Vec<i32> = vec![0,0];\\n        for (i, row) in mat.iter().enumerate(){\\n            let mut count: i32 = row.iter().sum();\\n            if count > ans[1]{\\n                ans[1] = count;\\n                ans[0] = i as i32;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut ans: Vec<i32> = vec![0,0];\\n        for (i, row) in mat.iter().enumerate(){\\n            let mut count: i32 = row.iter().sum();\\n            if count > ans[1]{\\n                ans[1] = count;\\n                ans[0] = i as i32;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3432302,
                "title": "easy-iteration-and-updation-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1.For the counting the numbers of ones we have iterate in the matrix of rach row \\n2.then we have find the maximum value so we check by the comparision  if count of the one greater than max value then update\\n3.if it is equal then we have to we have to choose the min index value\\n \\nThis three points we have take in the mind\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple by iterating in the matrix finding count of ones and calculate the maximum count and we have to fing min value if its index if the count is same.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(n^2)\\n\\n<b> Easy question of Leetcode give me self satisfaction\\uD83D\\uDE02\\uD83D\\uDE02\\n![Bom dia ,Boa tarde ,Boa noite.png](https://assets.leetcode.com/users/images/dad35698-7331-414e-8f1c-acd427e371a7_1681842257.8646004.png)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        count=0\\n        max1=0\\n        ind=0\\n        for i in range (len(mat)):\\n            for j in range (len(mat[0])):\\n                if mat[i][j]==1:\\n                    count+=1\\n            if count>max1:\\n                max1=count\\n                ind=i\\n            elif max1==count:\\n                ind=min(ind,i)\\n            count=0\\n                \\n        return [ind,max1]\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        count=0\\n        max1=0\\n        ind=0\\n        for i in range (len(mat)):\\n            for j in range (len(mat[0])):\\n                if mat[i][j]==1:\\n                    count+=1\\n            if count>max1:\\n                max1=count\\n                ind=i\\n            elif max1==count:\\n                ind=min(ind,i)\\n            count=0\\n                \\n        return [ind,max1]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425963,
                "title": "counting-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& v) \\n    {\\n        int onecount = 0;\\n        int rowidx = 0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<v[i].size();j++)\\n            {\\n                if(v[i][j] == 1) count++;\\n            }\\n            if(onecount < count)\\n            {\\n                onecount = count;\\n                rowidx = i;\\n            }\\n        }\\n        return {rowidx ,onecount};    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& v) \\n    {\\n        int onecount = 0;\\n        int rowidx = 0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<v[i].size();j++)\\n            {\\n                if(v[i][j] == 1) count++;\\n            }\\n            if(onecount < count)\\n            {\\n                onecount = count;\\n                rowidx = i;\\n            }\\n        }\\n        return {rowidx ,onecount};    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424763,
                "title": "c-easy-brute-force",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int cnt=0, pos=0;\\n        for (int i=0; i<mat.size(); i++){\\n            int curr=0;\\n            for (int j=0; j<mat[0].size(); j++){\\n                if (mat[i][j]==1)curr++;\\n            }\\n            if (curr>cnt){\\n                cnt= curr;\\n                pos= i;\\n            }\\n        }\\n        return {pos,cnt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int cnt=0, pos=0;\\n        for (int i=0; i<mat.size(); i++){\\n            int curr=0;\\n            for (int j=0; j<mat[0].size(); j++){\\n                if (mat[i][j]==1)curr++;\\n            }\\n            if (curr>cnt){\\n                cnt= curr;\\n                pos= i;\\n            }\\n        }\\n        return {pos,cnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424612,
                "title": "no-explanation-required",
                "content": "\\n# Solution:\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = 0, row = 0;\\n        for (int i = 0; i < mat.length; i++) {\\n            int ct = 0;\\n            for (int j = 0; j < mat[0].length; j++) {\\n                ct += mat[i][j];\\n            }\\n            if (ct > max) {\\n                max = ct;\\n                row = i;\\n            }\\n        }\\n        return new int[] {row, max};\\n    }\\n}\\n```\\n### Time complexity: $$O(nm)$$",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = 0, row = 0;\\n        for (int i = 0; i < mat.length; i++) {\\n            int ct = 0;\\n            for (int j = 0; j < mat[0].length; j++) {\\n                ct += mat[i][j];\\n            }\\n            if (ct > max) {\\n                max = ct;\\n                row = i;\\n            }\\n        }\\n        return new int[] {row, max};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424231,
                "title": "python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        indicies = []\\n        for r in range(len(mat)):\\n            indicies.append(r)\\n        counts = []\\n        for row in mat:\\n            counts.append(row.count(1))\\n        for i in indicies:\\n            if counts[i] == max(counts):\\n                return [i, counts[i]]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        indicies = []\\n        for r in range(len(mat)):\\n            indicies.append(r)\\n        counts = []\\n        for row in mat:\\n            counts.append(row.count(1))\\n        for i in indicies:\\n            if counts[i] == max(counts):\\n                return [i, counts[i]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422669,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        n=len(mat)\\n        m=len(mat[0])\\n        row,count_one=0,0\\n        for i in range(n):\\n            one=0\\n            for j in range(m):\\n                if mat[i][j]==1:\\n                    one+=1\\n\\n            if one>count_one:\\n                count_one=one\\n\\n                row=i\\n\\n        return [row,count_one]                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        n=len(mat)\\n        m=len(mat[0])\\n        row,count_one=0,0\\n        for i in range(n):\\n            one=0\\n            for j in range(m):\\n                if mat[i][j]==1:\\n                    one+=1\\n\\n            if one>count_one:\\n                count_one=one\\n\\n                row=i\\n\\n        return [row,count_one]                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422559,
                "title": "simple-and-easy-solution-easy-to-understand",
                "content": "# Intuition\\n**Just thought to update maxim whenever count exceedes maxim.**\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxim=INT_MIN;\\n        bool falg=true;\\n        int z;\\n        int count;\\n        vector<int>arr;\\n        vector<pair<int,int>>v_p;\\n        for(int i=0; i<n; i++)\\n        {\\n            count=0;\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    count++;\\n                }\\n                \\n            }\\n           \\n            if(count>maxim)\\n            {\\n                z=i;\\n               maxim=max(maxim,count);\\n            }\\n            \\n            \\n        }\\n      arr.push_back(z);\\n      arr.push_back(maxim);\\n        return arr;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxim=INT_MIN;\\n        bool falg=true;\\n        int z;\\n        int count;\\n        vector<int>arr;\\n        vector<pair<int,int>>v_p;\\n        for(int i=0; i<n; i++)\\n        {\\n            count=0;\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    count++;\\n                }\\n                \\n            }\\n           \\n            if(count>maxim)\\n            {\\n                z=i;\\n               maxim=max(maxim,count);\\n            }\\n            \\n            \\n        }\\n      arr.push_back(z);\\n      arr.push_back(maxim);\\n        return arr;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422292,
                "title": "very-easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n        int ans[]=new int[2];\\n        \\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            int countOnes=0;\\n            \\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1){\\n                    countOnes++;\\n                }\\n            }\\n            if(countOnes>max){\\n                max=countOnes;\\n                ans[0]=i;\\n                ans[1]=max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n        int ans[]=new int[2];\\n        \\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            int countOnes=0;\\n            \\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1){\\n                    countOnes++;\\n                }\\n            }\\n            if(countOnes>max){\\n                max=countOnes;\\n                ans[0]=i;\\n                ans[1]=max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422251,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut res = vec![-1, -1];\\n        for (i, row) in mat.iter().enumerate() {\\n            let one = row.iter().filter(|&&x| x == 1).count() as i32;\\n            if one > res[1] {\\n                res = vec![i as i32, one];\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut res = vec![-1, -1];\\n        for (i, row) in mat.iter().enumerate() {\\n            let one = row.iter().filter(|&&x| x == 1).count() as i32;\\n            if one > res[1] {\\n                res = vec![i as i32, one];\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422112,
                "title": "easyapproach-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We initialize maxCount and maxRowIndex to 0. Then we loop through all the rows of the matrix mat.\\n\\n 2. For each row, we count the number of ones in it by looping through all its elements. \\n\\n3. If this count is greater than the current maximum count, we update maxCount and maxRowIndex.\\n\\n 4. Finally, we return an array containing maxRowIndex and maxCount.\\n\\n5. To ensure that the row with the smallest row number is selected in case of multiple rows with the maximum count of ones, we can modify the code to check for the smallest row number while updating the maxRowIndex.\\n\\n6. In addition to checking if count > maxCount, we also check if count == maxCount and the current row index i is less than maxRowIndex.\\n\\n 7. If these conditions are true, we update maxRowIndex to the current row index i.\\n\\n - 8. This ensures that we always select the row with the smallest row number among the rows with the maximum count of ones.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nxn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n    int maxCount = 0;\\n    int maxRowIndex = 0;\\n\\n    for (int i = 0; i < mat.length; i++) {\\n        int count = 0;\\n        for (int j = 0; j < mat[i].length; j++) {\\n            if (mat[i][j] == 1) {\\n                count++;\\n            }\\n        }\\n\\n        if (count > maxCount || (count == maxCount && i < maxRowIndex)) {\\n            maxCount = count;\\n            maxRowIndex = i;\\n        }\\n    }\\n\\n    return new int[] { maxRowIndex, maxCount };\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n    int maxCount = 0;\\n    int maxRowIndex = 0;\\n\\n    for (int i = 0; i < mat.length; i++) {\\n        int count = 0;\\n        for (int j = 0; j < mat[i].length; j++) {\\n            if (mat[i][j] == 1) {\\n                count++;\\n            }\\n        }\\n\\n        if (count > maxCount || (count == maxCount && i < maxRowIndex)) {\\n            maxCount = count;\\n            maxRowIndex = i;\\n        }\\n    }\\n\\n    return new int[] { maxRowIndex, maxCount };\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422079,
                "title": "optimized-java-solution-easy-structured-with-comments-and-approach",
                "content": "# Approach\\nIn this problem, we will simply iterate through the 2D array and keep track of count of 1 in that row.\\n\\nwe will store the max count in index 1 of ans array and row with max count at index 0.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        // {index, maxCount}\\n        int ans[]=new int[2];\\n\\n        for(int i=0;i<mat.length;i++){\\n            // number of 1 in ith row\\n            int count=0;\\n\\n            // getting count of 1s\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n\\n            // checking for maximum count\\n            if(count>ans[1]){\\n                ans[1]=count;\\n                ans[0]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        // {index, maxCount}\\n        int ans[]=new int[2];\\n\\n        for(int i=0;i<mat.length;i++){\\n            // number of 1 in ith row\\n            int count=0;\\n\\n            // getting count of 1s\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n\\n            // checking for maximum count\\n            if(count>ans[1]){\\n                ans[1]=count;\\n                ans[0]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422002,
                "title": "best-c-well-explained-linear-time",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust traverse every row and count  the number of one. and compare it with the maximum oneCnt\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(row * column)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int r=0, maxi=0;\\n        for(int i=0; i<mat.size(); i++) {\\n            int cnt = 0;\\n            for(int j=0; j<mat[0].size(); j++)  if(mat[i][j] == 1)  cnt++;\\n            if(cnt > maxi)  {\\n                maxi = cnt;\\n                r = i;\\n            }\\n        }\\n        return {r, maxi};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int r=0, maxi=0;\\n        for(int i=0; i<mat.size(); i++) {\\n            int cnt = 0;\\n            for(int j=0; j<mat[0].size(); j++)  if(mat[i][j] == 1)  cnt++;\\n            if(cnt > maxi)  {\\n                maxi = cnt;\\n                r = i;\\n            }\\n        }\\n        return {r, maxi};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421908,
                "title": "javascript-simple-one-line-109ms",
                "content": "```\\nconst rowAndMaximumOnes = (g) => g.map((a, i) => [i, a.filter(x => x == 1).length]).sort((x, y) => y[1] - x[1] || x[0] - y[0])[0];\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sort",
                    "Matrix"
                ],
                "code": "```\\nconst rowAndMaximumOnes = (g) => g.map((a, i) => [i, a.filter(x => x == 1).length]).sort((x, y) => y[1] - x[1] || x[0] - y[0])[0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3421856,
                "title": "ez-brute-force",
                "content": "# Intuition\\nJust count the number of ones in each row and find out the maximum out of it.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat)\\n    {\\n        vector<int> res(2,0);\\n        int n = mat.size();\\n        int maxi = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int cnt = 0;\\n            for(auto x : mat[i])\\n            {\\n                cnt+=x;\\n            }\\n            if(cnt > maxi)\\n            {\\n                res[0]=i;\\n                res[1] = cnt;\\n                maxi = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] res = new int[2];\\n        int n = mat.length;\\n        int maxi = 0;\\n        for(int i=0; i<n; i++) {\\n            int cnt = 0;\\n            for(int x : mat[i]) {\\n                cnt += x;\\n            }\\n            if(cnt > maxi) {\\n                res[0] = i;\\n                res[1] = cnt;\\n                maxi = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, 0]\\n        n = len(mat)\\n        maxi = 0\\n        for i in range(n):\\n            cnt = sum(mat[i])\\n            if cnt > maxi:\\n                res[0] = i\\n                res[1] = cnt\\n                maxi = cnt\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat)\\n    {\\n        vector<int> res(2,0);\\n        int n = mat.size();\\n        int maxi = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int cnt = 0;\\n            for(auto x : mat[i])\\n            {\\n                cnt+=x;\\n            }\\n            if(cnt > maxi)\\n            {\\n                res[0]=i;\\n                res[1] = cnt;\\n                maxi = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] res = new int[2];\\n        int n = mat.length;\\n        int maxi = 0;\\n        for(int i=0; i<n; i++) {\\n            int cnt = 0;\\n            for(int x : mat[i]) {\\n                cnt += x;\\n            }\\n            if(cnt > maxi) {\\n                res[0] = i;\\n                res[1] = cnt;\\n                maxi = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, 0]\\n        n = len(mat)\\n        maxi = 0\\n        for i in range(n):\\n            cnt = sum(mat[i])\\n            if cnt > maxi:\\n                res[0] = i\\n                res[1] = cnt\\n                maxi = cnt\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421828,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n     int[] ans = new int[2];\\n    \\n        int max=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int len=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n               if(mat[i][j]==1)\\n               {\\n                   len++;\\n                   \\n               }\\n            }\\n           if(max<len)\\n           {\\n               max=len;\\n               ans[0]=i;\\n           }\\n        }\\n        ans[1]=max;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n     int[] ans = new int[2];\\n    \\n        int max=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int len=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n               if(mat[i][j]==1)\\n               {\\n                   len++;\\n                   \\n               }\\n            }\\n           if(max<len)\\n           {\\n               max=len;\\n               ans[0]=i;\\n           }\\n        }\\n        ans[1]=max;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421822,
                "title": "easy-java-self-explanatory-o-mn",
                "content": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int m = mat.length, n = mat[0].length, max = -1, curr = 0, ans[] = new int[2];\\n        for(int row=0;row<m;row++){\\n           curr = 0;\\n           for(int col=0;col<n;col++){\\n             if(mat[row][col] == 1) curr++;  \\n           }\\n            if(curr > max){\\n                ans[0] = row;\\n                ans[1] = curr;\\n                max = curr;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int m = mat.length, n = mat[0].length, max = -1, curr = 0, ans[] = new int[2];\\n        for(int row=0;row<m;row++){\\n           curr = 0;\\n           for(int col=0;col<n;col++){\\n             if(mat[row][col] == 1) curr++;  \\n           }\\n            if(curr > max){\\n                ans[0] = row;\\n                ans[1] = curr;\\n                max = curr;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421767,
                "title": "c-brute-force-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int max_idx = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < mat.size(); i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < mat[0].size(); j++)\\n            {\\n                if(mat[i][j] == 1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(maxi < count)\\n            {\\n                maxi = count;\\n                max_idx = i;\\n            }\\n        }\\n        return {max_idx,maxi};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int max_idx = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < mat.size(); i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < mat[0].size(); j++)\\n            {\\n                if(mat[i][j] == 1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(maxi < count)\\n            {\\n                maxi = count;\\n                max_idx = i;\\n            }\\n        }\\n        return {max_idx,maxi};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421733,
                "title": "c-count-one-in-each-row",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ind=0,cnt=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1) c+=1;\\n            }\\n            if(c>cnt){\\n                ind=i;\\n                cnt=c;\\n            }\\n        }\\n        \\n        return {ind,cnt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ind=0,cnt=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1) c+=1;\\n            }\\n            if(c>cnt){\\n                ind=i;\\n                cnt=c;\\n            }\\n        }\\n        \\n        return {ind,cnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421732,
                "title": "c-easy-to-understand-for-begineer",
                "content": "```\\nclass Solution {\\npublic:\\n    //Priyanshu\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     vector<int> ans;\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        // int one=0;\\n        vector<pair<int,int>>vec;\\n       for(int i=0;i<n;i++){\\n           int one=0;\\n           for(int j=0;j<m;j++){\\n               if(mat[i][j]==1)one++;\\n           }\\n           vec.push_back({one,i});\\n       }\\n        int x=vec.size();\\n        sort(vec.begin(),vec.end());\\n        int maxi=vec[x-1].first;\\n        for(auto it: vec){\\n            cout<<it.first<<\" \"<<it.second<<endl;\\n        }\\n        for(auto it: vec){\\n            if(it.first==maxi){\\n                ans.push_back(it.second);\\n                ans.push_back(it.first);\\n                break;\\n            }\\n        }\\n        return ans;}};\\n\\t\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Priyanshu\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     vector<int> ans;\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        // int one=0;\\n        vector<pair<int,int>>vec;\\n       for(int i=0;i<n;i++){\\n           int one=0;\\n           for(int j=0;j<m;j++){\\n               if(mat[i][j]==1)one++;\\n           }\\n           vec.push_back({one,i});\\n       }\\n        int x=vec.size();\\n        sort(vec.begin(),vec.end());\\n        int maxi=vec[x-1].first;\\n        for(auto it: vec){\\n            cout<<it.first<<\" \"<<it.second<<endl;\\n        }\\n        for(auto it: vec){\\n            if(it.first==maxi){\\n                ans.push_back(it.second);\\n                ans.push_back(it.first);\\n                break;\\n            }\\n        }\\n        return ans;}};\\n\\t\\t```",
                "codeTag": "C++"
            },
            {
                "id": 3421689,
                "title": "simplest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int> ans;\\n        int maxcount=0;\\n        int row=0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1)\\n                count++;\\n              }\\n                if(count>maxcount){\\n                    maxcount=count;\\n                    row=i;\\n            }\\n        }\\n        ans.push_back(row);\\n        ans.push_back(maxcount);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int> ans;\\n        int maxcount=0;\\n        int row=0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1)\\n                count++;\\n              }\\n                if(count>maxcount){\\n                    maxcount=count;\\n                    row=i;\\n            }\\n        }\\n        ans.push_back(row);\\n        ans.push_back(maxcount);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421677,
                "title": "simple-approach-brute-force-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i =0 ;i < mat.length;i++){\\n            int cnt =0;\\n            for(int j =0 ;j<mat[i].length;j++){\\n                if(mat[i][j] ==1){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt > arr[1]){\\n                arr[1] = cnt;\\n                arr[0] = i;\\n            }\\n            \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i =0 ;i < mat.length;i++){\\n            int cnt =0;\\n            for(int j =0 ;j<mat[i].length;j++){\\n                if(mat[i][j] ==1){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt > arr[1]){\\n                arr[1] = cnt;\\n                arr[0] = i;\\n            }\\n            \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101358,
                "title": "easy-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int res=0;\\n        int k=0;\\n        for(int i=0;i<m;i++){\\n             int count=0;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n         if(count>res){\\n             res=count;\\n             k=i;\\n         }\\n        }\\n        ans.push_back(k);\\n        ans.push_back(res);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int res=0;\\n        int k=0;\\n        for(int i=0;i<m;i++){\\n             int count=0;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n         if(count>res){\\n             res=count;\\n             k=i;\\n         }\\n        }\\n        ans.push_back(k);\\n        ans.push_back(res);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101082,
                "title": "simple-and-easy-to-understand-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = Integer.MIN_VALUE;\\n        int index = -1;\\n        int result[] = new int[2];\\n        for(int i=0; i<mat.length; i++) {\\n            int count = 0;\\n            for(int j=0; j<mat[0].length; j++) {\\n                if(mat[i][j]==1) {\\n                    count++;\\n                }\\n            }\\n            if(count > max) {\\n                max = count;\\n                index = i;\\n            }\\n        }\\n        result[0] = index;\\n        result[1] = max;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = Integer.MIN_VALUE;\\n        int index = -1;\\n        int result[] = new int[2];\\n        for(int i=0; i<mat.length; i++) {\\n            int count = 0;\\n            for(int j=0; j<mat[0].length; j++) {\\n                if(mat[i][j]==1) {\\n                    count++;\\n                }\\n            }\\n            if(count > max) {\\n                max = count;\\n                index = i;\\n            }\\n        }\\n        result[0] = index;\\n        result[1] = max;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101064,
                "title": "solved-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int count=0,max=0,i,j,row;\\n        for(i=0;i<mat.size();i++)\\n        {\\n            for(j=0;j<mat[i].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>max)\\n            {\\n                max = count;\\n                row = i;\\n\\n            }\\n            count=0;\\n        }\\n        ans.push_back(row);\\n        ans.push_back(max);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int count=0,max=0,i,j,row;\\n        for(i=0;i<mat.size();i++)\\n        {\\n            for(j=0;j<mat[i].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>max)\\n            {\\n                max = count;\\n                row = i;\\n\\n            }\\n            count=0;\\n        }\\n        ans.push_back(row);\\n        ans.push_back(max);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101032,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) \\n    {\\n        int ans[]=new int [2];\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(ans[1]<count)\\n            {\\n                ans[1]=count;\\n                ans[0]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) \\n    {\\n        int ans[]=new int [2];\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(ans[1]<count)\\n            {\\n                ans[1]=count;\\n                ans[0]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100296,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int onecount = INT_MIN;\\n        int row = -1;\\n\\n        for(int i=0; i<mat.size(); ++i){\\n            int cnt = 0;\\n            for(int j=0; j<mat[i].size(); ++j){\\n                if(mat[i][j] == 1) cnt++;\\n            }\\n\\n            if(cnt > onecount){\\n                onecount = cnt;\\n                row = i;\\n            }\\n\\n        }\\n\\n        ans.push_back(row);\\n        ans.push_back(onecount);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int onecount = INT_MIN;\\n        int row = -1;\\n\\n        for(int i=0; i<mat.size(); ++i){\\n            int cnt = 0;\\n            for(int j=0; j<mat[i].size(); ++j){\\n                if(mat[i][j] == 1) cnt++;\\n            }\\n\\n            if(cnt > onecount){\\n                onecount = cnt;\\n                row = i;\\n            }\\n\\n        }\\n\\n        ans.push_back(row);\\n        ans.push_back(onecount);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091988,
                "title": "bs-best-solution-o-n-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortrow(vector<int> &row){\\n        sort(row.begin(),row.end());\\n    }\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& a) {\\n         int count=0,index=0;\\n         int n=a.size(),m=a[0].size();\\n        for(int i=0;i<n;i++){\\n            sortrow(a[i]);\\n            int low=0,high=m-1;\\n            int ind=m;\\n            while(low<=high){\\n                int mid=(low+high)/2;\\n                if(a[i][mid]==1){\\n                    ind=mid;\\n                    high=mid-1;\\n                }\\n                else\\n                low=mid+1;\\n            }\\n            int count_ones=m-ind;\\n            if(count_ones>count){\\n                count=count_ones;\\n                index=i;\\n            }\\n        }\\n        return {index,count};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortrow(vector<int> &row){\\n        sort(row.begin(),row.end());\\n    }\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& a) {\\n         int count=0,index=0;\\n         int n=a.size(),m=a[0].size();\\n        for(int i=0;i<n;i++){\\n            sortrow(a[i]);\\n            int low=0,high=m-1;\\n            int ind=m;\\n            while(low<=high){\\n                int mid=(low+high)/2;\\n                if(a[i][mid]==1){\\n                    ind=mid;\\n                    high=mid-1;\\n                }\\n                else\\n                low=mid+1;\\n            }\\n            int count_ones=m-ind;\\n            if(count_ones>count){\\n                count=count_ones;\\n                index=i;\\n            }\\n        }\\n        return {index,count};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088570,
                "title": "easy-solution-in-python-specially-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        l = []\\n        m=0\\n        k=0\\n        x=0\\n        for i in mat:\\n            p = i.count(1)\\n            if m<p:\\n                m = p\\n                x = k\\n            k+=1\\n        l.append(x)\\n        l.append(m)\\n        return l\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        l = []\\n        m=0\\n        k=0\\n        x=0\\n        for i in mat:\\n            p = i.count(1)\\n            if m<p:\\n                m = p\\n                x = k\\n            k+=1\\n        l.append(x)\\n        l.append(m)\\n        return l\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085878,
                "title": "best-question-for-beginners-and-the-easiest-code-given-below",
                "content": "## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int count=0;\\n        int max=0;\\n        int index=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            count=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n               \\n            }\\n            if(count>max)\\n            {\\n                max=count;\\n                index=i;\\n            }\\n           \\n        }\\n         \\n        return new int[] {index,max};\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int count=0;\\n        int max=0;\\n        int index=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            count=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n               \\n            }\\n            if(count>max)\\n            {\\n                max=count;\\n                index=i;\\n            }\\n           \\n        }\\n         \\n        return new int[] {index,max};\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085187,
                "title": "95-beats-in-c-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int count = 0;\\n        int min_index = -1;\\n\\n        for(int i = 0; i < mat.size(); i++){\\n            int count2 = 0;\\n            for(int j = 0; j < mat[i].size(); j++){\\n                if(mat[i][j] == 1){\\n                    count2++;\\n                }\\n            }\\n            if(count2 > count){\\n                count = count2;\\n                min_index = i;\\n            }\\n        }\\n\\n        if(count == 0){\\n            return {0,0};\\n        }\\n        return {min_index,count};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int count = 0;\\n        int min_index = -1;\\n\\n        for(int i = 0; i < mat.size(); i++){\\n            int count2 = 0;\\n            for(int j = 0; j < mat[i].size(); j++){\\n                if(mat[i][j] == 1){\\n                    count2++;\\n                }\\n            }\\n            if(count2 > count){\\n                count = count2;\\n                min_index = i;\\n            }\\n        }\\n\\n        if(count == 0){\\n            return {0,0};\\n        }\\n        return {min_index,count};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081899,
                "title": "striver-approach-lower-bound-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint lowerBound(vector<int> &arr, int x){\\n    int n=arr.size();\\n    int low=0;\\n    int high = n-1;\\n    sort(arr.begin(),arr.end());\\n    int ans=n;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        if(arr[mid] >= x){\\n            ans=mid;\\n            high=mid-1;\\n        }else{\\n            low=mid+1;\\n        }\\n    }\\n    return ans;\\n}\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int maxCount=0;\\n        int index=0;\\n        vector<int> ans;\\n        for(int i=0; i<m; i++){\\n            int onesCount = n-lowerBound(mat[i], 1);\\n            if(onesCount > maxCount){\\n                maxCount = onesCount;\\n                index=i;\\n            }\\n        }\\n        return {index, maxCount};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint lowerBound(vector<int> &arr, int x){\\n    int n=arr.size();\\n    int low=0;\\n    int high = n-1;\\n    sort(arr.begin(),arr.end());\\n    int ans=n;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        if(arr[mid] >= x){\\n            ans=mid;\\n            high=mid-1;\\n        }else{\\n            low=mid+1;\\n        }\\n    }\\n    return ans;\\n}\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int maxCount=0;\\n        int index=0;\\n        vector<int> ans;\\n        for(int i=0; i<m; i++){\\n            int onesCount = n-lowerBound(mat[i], 1);\\n            if(onesCount > maxCount){\\n                maxCount = onesCount;\\n                index=i;\\n            }\\n        }\\n        return {index, maxCount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080350,
                "title": "beginner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        maxOne=-9999\\n        index =-1\\n        for i in range(len(mat)):\\n            if maxOne < mat[i].count(1):\\n                maxOne = mat[i].count(1)\\n                index= i\\n        return [index,maxOne]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        maxOne=-9999\\n        index =-1\\n        for i in range(len(mat)):\\n            if maxOne < mat[i].count(1):\\n                maxOne = mat[i].count(1)\\n                index= i\\n        return [index,maxOne]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079830,
                "title": "simple-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let index = 0;\\n    let maxCount = 0;\\n    for(let i=0; i< mat.length; i++){\\n        let count = 0\\n        for(let j=0; j< mat[i].length; j++){\\n            if(mat[i][j] === 1){\\n                count++\\n            }\\n        }\\n        if(count > maxCount){\\n         maxCount = count;\\n         index = i;\\n        }\\n    }  \\n    return [index,  maxCount]  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let index = 0;\\n    let maxCount = 0;\\n    for(let i=0; i< mat.length; i++){\\n        let count = 0\\n        for(let j=0; j< mat[i].length; j++){\\n            if(mat[i][j] === 1){\\n                count++\\n            }\\n        }\\n        if(count > maxCount){\\n         maxCount = count;\\n         index = i;\\n        }\\n    }  \\n    return [index,  maxCount]  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079790,
                "title": "row-with-maximum-ones",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n      vector<int>ans;\\n      int n=mat.size();\\n      int oneCount = INT_MIN;\\n      int rowNo;\\n\\n      for(int i=0;i<n;i++){\\n        int count=0;\\n        for(int j=0;j<mat[i].size();j++){\\n          if(mat[i][j]==1){\\n            count++;\\n          }\\n        }\\n        if(count>oneCount){\\n          oneCount=count;\\n          rowNo=i;\\n        }\\n      }\\n      ans.push_back(rowNo);\\n      ans.push_back(oneCount);\\n      return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n      vector<int>ans;\\n      int n=mat.size();\\n      int oneCount = INT_MIN;\\n      int rowNo;\\n\\n      for(int i=0;i<n;i++){\\n        int count=0;\\n        for(int j=0;j<mat[i].size();j++){\\n          if(mat[i][j]==1){\\n            count++;\\n          }\\n        }\\n        if(count>oneCount){\\n          oneCount=count;\\n          rowNo=i;\\n        }\\n      }\\n      ans.push_back(rowNo);\\n      ans.push_back(oneCount);\\n      return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074711,
                "title": "easy-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        arr=[]\\n        res=[]\\n        for i in mat:\\n            count=0\\n            for j in i:\\n                if j==1:\\n                    print(j)\\n                    count+=1\\n                if j==0:\\n                    continue\\n            arr.append(count)\\n        print(arr)\\n        if arr:\\n            for l in range(len(arr)):\\n                if arr[l]==max(arr):\\n                    res.append(l)\\n                    res.append(max(arr))\\n                    break\\n        else:\\n            res.append(0)\\n            res.append(0)\\n        return res\\n        \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        arr=[]\\n        res=[]\\n        for i in mat:\\n            count=0\\n            for j in i:\\n                if j==1:\\n                    print(j)\\n                    count+=1\\n                if j==0:\\n                    continue\\n            arr.append(count)\\n        print(arr)\\n        if arr:\\n            for l in range(len(arr)):\\n                if arr[l]==max(arr):\\n                    res.append(l)\\n                    res.append(max(arr))\\n                    break\\n        else:\\n            res.append(0)\\n            res.append(0)\\n        return res\\n        \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072903,
                "title": "o-m-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int a=0,c=0,b=0;\\n        for(int i=0;i<mat.length;i++){\\n            c=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j] == 1){\\n                    c++;\\n                }\\n                if(c>a){\\n                    b = i;\\n                }\\n                a = Math.max(a,c);\\n            }\\n        }\\n        int[] ans = {b,a};\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int a=0,c=0,b=0;\\n        for(int i=0;i<mat.length;i++){\\n            c=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j] == 1){\\n                    c++;\\n                }\\n                if(c>a){\\n                    b = i;\\n                }\\n                a = Math.max(a,c);\\n            }\\n        }\\n        int[] ans = {b,a};\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070947,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int n =mat.length;\\n        int m = mat[0].length;\\n\\n        int index =0;\\n        int max =0;\\n\\n        for(int i =0;i<n; i++){\\n          int sum =0;\\n          for(int j =0;j<m;j++){\\n            sum = sum + mat[i][j];\\n            \\n          }\\n         if(sum > max){\\n           index =i;\\n           max =sum;\\n         }\\n        \\n        }\\n        return new int[] {index,max};\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int n =mat.length;\\n        int m = mat[0].length;\\n\\n        int index =0;\\n        int max =0;\\n\\n        for(int i =0;i<n; i++){\\n          int sum =0;\\n          for(int j =0;j<m;j++){\\n            sum = sum + mat[i][j];\\n            \\n          }\\n         if(sum > max){\\n           index =i;\\n           max =sum;\\n         }\\n        \\n        }\\n        return new int[] {index,max};\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070818,
                "title": "use-c-stl",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(c)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans(2,0);\\n        for(int i=0; i<mat.size(); ++i)\\n        {\\n            int sum = accumulate(mat[i].begin(), mat[i].end(),0);\\n            if(sum > ans[1])\\n            {\\n                ans[1] = sum;\\n                ans[0] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans(2,0);\\n        for(int i=0; i<mat.size(); ++i)\\n        {\\n            int sum = accumulate(mat[i].begin(), mat[i].end(),0);\\n            if(sum > ans[1])\\n            {\\n                ans[1] = sum;\\n                ans[0] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068780,
                "title": "python-simple-with-explanation",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        #INITIALISE ANS WITH 0\\n        ans=0\\n        res=[]\\n        #COUNT THE MAX NUMBER OF 1\\'S IN EACH LIST\\n        for i in mat:\\n            ans=max(ans,i.count(1))\\n        #SEARCH FOR THAT LIST AND RETURN ITS INDEX\\n        for i in range(len(mat)):\\n            if mat[i].count(1)==ans:\\n                res.append(i)\\n                res.append(ans)\\n                return res\\n                break\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        #INITIALISE ANS WITH 0\\n        ans=0\\n        res=[]\\n        #COUNT THE MAX NUMBER OF 1\\'S IN EACH LIST\\n        for i in mat:\\n            ans=max(ans,i.count(1))\\n        #SEARCH FOR THAT LIST AND RETURN ITS INDEX\\n        for i in range(len(mat)):\\n            if mat[i].count(1)==ans:\\n                res.append(i)\\n                res.append(ans)\\n                return res\\n                break\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066516,
                "title": "python-solution-easy-to-understand-for-beginners",
                "content": "\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        temp=[]\\n        count1=0\\n        for i in range(len(mat)):\\n            new=mat[i].count(1)\\n            if new>count1:\\n                count1=new\\n                temp=[i,count1]\\n        if temp==[]:\\n            return [0,0]\\n        return temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        temp=[]\\n        count1=0\\n        for i in range(len(mat)):\\n            new=mat[i].count(1)\\n            if new>count1:\\n                count1=new\\n                temp=[i,count1]\\n        if temp==[]:\\n            return [0,0]\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064962,
                "title": "a-bit-lenthy-solution-but-easy-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[100];\\n        int count = 0;\\n        int k = 0;\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j] == 1){\\n                    count ++;\\n                }\\n                \\n            }\\n            arr[k++] = count;\\n                count = 0;\\n        }\\n        int max = arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            if(arr[i] > max){\\n                max = arr[i];\\n            }\\n        }\\n        int ans = position(arr,max);\\n        int[] nums = {ans,max};\\n        return nums;\\n    }\\n        public int position(int[] arr,int target){\\n            for(int i=0;i<arr.length;i++){\\n                if(arr[i] == target){\\n                    return i;\\n                    \\n                }\\n            }\\n            return -1;\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[100];\\n        int count = 0;\\n        int k = 0;\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j] == 1){\\n                    count ++;\\n                }\\n                \\n            }\\n            arr[k++] = count;\\n                count = 0;\\n        }\\n        int max = arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            if(arr[i] > max){\\n                max = arr[i];\\n            }\\n        }\\n        int ans = position(arr,max);\\n        int[] nums = {ans,max};\\n        return nums;\\n    }\\n        public int position(int[] arr,int target){\\n            for(int i=0;i<arr.length;i++){\\n                if(arr[i] == target){\\n                    return i;\\n                    \\n                }\\n            }\\n            return -1;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063673,
                "title": "easy-and-clean-code-c-solution-clean-code-easy-to-understand-o-n-2-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        vector<int>anss;\\n        int max=INT_MIN;\\n        for(int i=0;i<mat.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    cnt+=1;\\n                }\\n            }\\n           ans.push_back(i);\\n           anss.push_back(cnt);\\n            \\n        }\\n        int  index;\\n        for(int i=0;i<anss.size();i++){\\n            if(anss[i]>max){\\n                max=anss[i];\\n                index=i;\\n            }\\n        }\\n    \\n        return {index,max};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        vector<int>anss;\\n        int max=INT_MIN;\\n        for(int i=0;i<mat.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    cnt+=1;\\n                }\\n            }\\n           ans.push_back(i);\\n           anss.push_back(cnt);\\n            \\n        }\\n        int  index;\\n        for(int i=0;i<anss.size();i++){\\n            if(anss[i]>max){\\n                max=anss[i];\\n                index=i;\\n            }\\n        }\\n    \\n        return {index,max};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063205,
                "title": "h",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int row_size=mat.size();\\n        int oneCount=INT_MIN;\\n        int rowNo=0;\\n        for(int i=0;i<row_size;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>oneCount)\\n            {\\n                oneCount=count;\\n                rowNo=i;\\n            }\\n        }\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int row_size=mat.size();\\n        int oneCount=INT_MIN;\\n        int rowNo=0;\\n        for(int i=0;i<row_size;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>oneCount)\\n            {\\n                oneCount=count;\\n                rowNo=i;\\n            }\\n        }\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062082,
                "title": "simple-fast-and-100-accepted-c-c-bruteforce-approach-beats-maximum-users-check-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-> Assume ansr, Row number = 0\\n-> Assume ans, Maximum no. of 1\\'s =0\\n-> Count the no. of 1\\'s in each row.\\n-> Then, Store it in ansr, ans variable.\\n\\nReturn the ans, ansr.\\nans = maximum no. of 1s\\nansr = minimum row which contain maximum 1\\'s. \\n\\n# Approach\\nBruteForce Approach\\n\\n# Complexity\\n- Time complexity:\\nO(m x n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int ansr=0,ans=0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            int count = 0;\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n            if(count>ans)\\n            {\\n                ans = count;\\n                ansr = i; \\n            }\\n        }\\n        return {ansr,ans};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int ansr=0,ans=0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            int count = 0;\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n            if(count>ans)\\n            {\\n                ans = count;\\n                ansr = i; \\n            }\\n        }\\n        return {ansr,ans};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060971,
                "title": "easy-java-approach",
                "content": "## ****Bold****# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0,maxrow=0;\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        for(int i=0;i<m;i++)\\n        {\\n            int c=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(mat[i][j]==1)\\n                 c++;\\n            }\\n            if(c>max)\\n            {\\n            max=c;\\n            maxrow=i;\\n            }\\n        }\\n        int[] arr = new int[2];\\n        arr[1]=max;\\n        arr[0]=maxrow;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0,maxrow=0;\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        for(int i=0;i<m;i++)\\n        {\\n            int c=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(mat[i][j]==1)\\n                 c++;\\n            }\\n            if(c>max)\\n            {\\n            max=c;\\n            maxrow=i;\\n            }\\n        }\\n        int[] arr = new int[2];\\n        arr[1]=max;\\n        arr[0]=maxrow;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060192,
                "title": "simple-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int>ans;\\n        \\n        int index=0;\\n        int OnesCount=0;\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1){\\n                 count++;\\n                }\\n            }\\n\\n           if(count>OnesCount) {\\n            OnesCount=count;\\n             index=i;\\n             }\\n        }\\n\\n        ans.push_back(index);\\n        ans.push_back(OnesCount);\\n        return ans;\\n          \\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int>ans;\\n        \\n        int index=0;\\n        int OnesCount=0;\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1){\\n                 count++;\\n                }\\n            }\\n\\n           if(count>OnesCount) {\\n            OnesCount=count;\\n             index=i;\\n             }\\n        }\\n\\n        ans.push_back(index);\\n        ans.push_back(OnesCount);\\n        return ans;\\n          \\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058731,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n**O(m*n)**\\n\\nThe countOnes function iterates through a row of length \\'n\\' once and counts the number of ones. So, its time complexity is O(n).\\n\\nIn the rowAndMaximumOnes function, there is a loop that iterates through all \\'m\\' rows of the matrix. Inside the loop, it calls the countOnes function, which has a time complexity of O(n). Therefore, the time complexity of the loop is O(m * n).\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int countOnes(vector<int>& row) {\\n        int count = 0;\\n        for (int num : row) {\\n            if (num == 1) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxCount = 0;\\n        int rowIndex = -1;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        for (int i = 0; i < m; i++) {\\n            int onesCount = countOnes(mat[i]);\\n            if (onesCount > maxCount) {\\n                maxCount = onesCount;\\n                rowIndex = i;\\n            }\\n        }\\n        if (rowIndex == -1) {\\n            return {0, 0};  // No ones found in any row\\n        }\\n        vector<int> result = {rowIndex, maxCount};\\n        return result;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int countOnes(vector<int>& row) {\\n        int count = 0;\\n        for (int num : row) {\\n            if (num == 1) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxCount = 0;\\n        int rowIndex = -1;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        for (int i = 0; i < m; i++) {\\n            int onesCount = countOnes(mat[i]);\\n            if (onesCount > maxCount) {\\n                maxCount = onesCount;\\n                rowIndex = i;\\n            }\\n        }\\n        if (rowIndex == -1) {\\n            return {0, 0};  // No ones found in any row\\n        }\\n        vector<int> result = {rowIndex, maxCount};\\n        return result;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055258,
                "title": "fast-and-easy-code-by-using-python3",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-> first we are taking each row and finding number of 1\\'s in it by using count meathod ad appedning it into num_1 list\\n-> next we are finding index of the row by finding index of the max element in the num_1 list because its index match with the row index \\n-> finally we are taking index i and no. of times 1 repeated into a final list and returning it \\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        num_1 = []\\n        for i in mat:\\n            # finding nuo. of times 1 repeated in each row \\n            num_1.append(i.count(1))\\n        # finding index of max element in num_1\\n        i = num_1.index(max(num_1))\\n        final = [i,max(num_1)]\\n        return final\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        num_1 = []\\n        for i in mat:\\n            # finding nuo. of times 1 repeated in each row \\n            num_1.append(i.count(1))\\n        # finding index of max element in num_1\\n        i = num_1.index(max(num_1))\\n        final = [i,max(num_1)]\\n        return final\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054975,
                "title": "beat-90-in-memory-and-easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        l=[0,0]\\n        for i in range(len(mat)):\\n            if sum(mat[i])>l[1]:\\n                l[1]=sum(mat[i])\\n                l[0]=i\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        l=[0,0]\\n        for i in range(len(mat)):\\n            if sum(mat[i])>l[1]:\\n                l[1]=sum(mat[i])\\n                l[0]=i\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054524,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int row = 0;\\n        int count = 0;\\n        int maxCount = 0;\\n        for(int i = 0 ;  i< mat.length; i++){\\n            count = 0;\\n            for(int j = 0; j < mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n\\n            if(count > maxCount){\\n                maxCount = count;\\n                row = i;\\n            }\\n        }\\n        return new int[] {row, maxCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int row = 0;\\n        int count = 0;\\n        int maxCount = 0;\\n        for(int i = 0 ;  i< mat.length; i++){\\n            count = 0;\\n            for(int j = 0; j < mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n\\n            if(count > maxCount){\\n                maxCount = count;\\n                row = i;\\n            }\\n        }\\n        return new int[] {row, maxCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053693,
                "title": "using-count-p",
                "content": "# Intuition\\nOn a first thought, i used 2 for\\'s, but that\\'s not necessary\\n# Approach\\nbc python gives us \"count\" wich you call with the array and, as a parameter, you put the element.. Of course it probably cycles the list so it\\'s still a O(n^2) but the guy who made count is way better than me so my code si 50ms faster :P I just check if the counter of 1\\'s in a array is bigger than the actual, i just keep the big one and the index, which probally isn\\'t necesary as variable, but i\\'m not a py programmer D:\\n\\n# Complexity\\n- Time complexity:\\nO(n^2).. but i\\'m having doubts with that if, maybe hurts more than what it helps\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nnot really sure about space, i mean i use 2 variables and un array length==2 D:\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        counter = 0\\n        i = 0\\n        salida = [0,0]\\n        for array in mat:\\n            if(1 in array):\\n                counter = array.count(1)\\n                if(counter > salida[1]):\\n                    salida = [i, counter]\\n            i += 1\\n            counter = 0\\n        return salida\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        counter = 0\\n        i = 0\\n        salida = [0,0]\\n        for array in mat:\\n            if(1 in array):\\n                counter = array.count(1)\\n                if(counter > salida[1]):\\n                    salida = [i, counter]\\n            i += 1\\n            counter = 0\\n        return salida\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048826,
                "title": "cpp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) \\n    {\\n        vector<int> answer(2 , 0);\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int count = 0;\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                count += mat[i][j];\\n            }\\n            if(answer[1] < count)\\n            {\\n                answer[0] = i;\\n                answer[1] = count;\\n            }\\n        }    \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) \\n    {\\n        vector<int> answer(2 , 0);\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int count = 0;\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                count += mat[i][j];\\n            }\\n            if(answer[1] < count)\\n            {\\n                answer[0] = i;\\n                answer[1] = count;\\n            }\\n        }    \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047801,
                "title": "easy-c-solution-without-taking-extra-variable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> result(2);\\n       //  have created one vector with size 2 because we have to return a vector, IN the fist index  result[0] we will be storing index of the max row and second position  result[1] we will be storing max 1 count;\\n\\n        for(int i=0 ;i<mat.size() ; i++){  // for row\\n            int oneCount = 0;    // to count 1 each row\\n            for(int j=0 ; j<mat[0].size() ; j++){  // for column\\n                if(mat[i][j] == 1){\\n                    oneCount++;  // if 1 fount in the row then we will count\\n                }\\n            }\\n            if( oneCount > result[1]){    //if max row found with respect to the previous row then we will update vector\\n                result[0] = i;\\n                result[1] = oneCount;\\n\\n            }\\n        }\\n        return result; // return the vector\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> result(2);\\n       //  have created one vector with size 2 because we have to return a vector, IN the fist index  result[0] we will be storing index of the max row and second position  result[1] we will be storing max 1 count;\\n\\n        for(int i=0 ;i<mat.size() ; i++){  // for row\\n            int oneCount = 0;    // to count 1 each row\\n            for(int j=0 ; j<mat[0].size() ; j++){  // for column\\n                if(mat[i][j] == 1){\\n                    oneCount++;  // if 1 fount in the row then we will count\\n                }\\n            }\\n            if( oneCount > result[1]){    //if max row found with respect to the previous row then we will update vector\\n                result[0] = i;\\n                result[1] = oneCount;\\n\\n            }\\n        }\\n        return result; // return the vector\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047187,
                "title": "74ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let result = [];\\n    let tmpCount = -1;\\n    mat.forEach((item, i) => {\\n        let count = item.reduce((n, sum) => (n + sum), 0);\\n        if (count > tmpCount) {\\n            result[0] = i;\\n            result[1] = count\\n            tmpCount = count;\\n        }\\n        \\n    });\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let result = [];\\n    let tmpCount = -1;\\n    mat.forEach((item, i) => {\\n        let count = item.reduce((n, sum) => (n + sum), 0);\\n        if (count > tmpCount) {\\n            result[0] = i;\\n            result[1] = count\\n            tmpCount = count;\\n        }\\n        \\n    });\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045304,
                "title": "brute-force-and-simple-to-understand-100",
                "content": "# Intuition\\n![cat_image.jpeg](https://assets.leetcode.com/users/images/84b86bbb-442c-414d-9e18-6b1057407c45_1694716995.6876135.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcont=0;\\n        int cont=0;\\n        int ind;\\n\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            cont=0;\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                   cont++;\\n                }\\n            }\\n\\n            if(cont>maxcont)\\n            {\\n                maxcont=cont;\\n                ind=i;\\n            }\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(ind);\\n        ans.push_back(maxcont);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcont=0;\\n        int cont=0;\\n        int ind;\\n\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            cont=0;\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                   cont++;\\n                }\\n            }\\n\\n            if(cont>maxcont)\\n            {\\n                maxcont=cont;\\n                ind=i;\\n            }\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(ind);\\n        ans.push_back(maxcont);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045214,
                "title": "easy-and-simple-c-solution-row-with-maximum-ones",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row. ---->**Idea :-** We\\'ll count one\\'s value in each row by traversing the matrix , then store the ans and return the value of rowNo and max oneCount. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all , initialize a vector array of int type as \"ans\" `vector<int> ans;`to store the index of the row, and the number of ones in it. \\nInitializes two variables \\n-> `oneCount=INT_MIN` (that have the maximum count of ones)\\n->`rowNo = -1` (the row with the smallest row number having max no. of 1\\'s)\\n1) Using nested loop to check whether `mat[i][j]==1` or not, if mat[i][j]==1, then increment `count++`. \\n2) Check `if(count > onecount)` then  oneCount=count , rowNo= i\\n3) push_back rowNo and oneCount in \"ans\" vector array , then return ans `ans.push_back(rowNo);`\\n `ans.push_back(oneCount);`\\n `return ans;`\\n\\n# Complexity\\n- Time complexity: O( m*n ) `traversal of matrix`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n=mat.size();\\n        //oneCount-> will store max number of 1\\'s in a row\\n        int oneCount=INT_MIN;\\n        //rowNo-> will store index of max no. of 1\\'s wali row\\n        int rowNo=-1;\\n\\n        for(int i=0;i<n;i++){\\n            //har row start hone se phele intialize count with 0\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            //after row completion , compare count with oneCount\\n            if(count> oneCount){\\n                oneCount=count;\\n                rowNo= i;\\n            }\\n        }\\n       \\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n```\\n![canUpleaseUpvote.jpeg](https://assets.leetcode.com/users/images/8d39986a-7aae-4ac6-8605-00bda5df2579_1694715765.6027052.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n=mat.size();\\n        //oneCount-> will store max number of 1\\'s in a row\\n        int oneCount=INT_MIN;\\n        //rowNo-> will store index of max no. of 1\\'s wali row\\n        int rowNo=-1;\\n\\n        for(int i=0;i<n;i++){\\n            //har row start hone se phele intialize count with 0\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            //after row completion , compare count with oneCount\\n            if(count> oneCount){\\n                oneCount=count;\\n                rowNo= i;\\n            }\\n        }\\n       \\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043733,
                "title": "row-wise-counting",
                "content": "# Intuition\\nstep 1: Traversing row wise and count 1 and compare max and count if count > max then max = count. Then count -> 0\\nstep 2: storing row idx\\nstep 3: return row idx and maximum count of 1\\n\\n# Approach\\nRow-wise Counting\\n\\n# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector <int> ans;\\n        int Max = INT_MIN, row_Idx;\\n        for(int i = 0 ; i<mat.size(); i++){\\n            int count = 0;\\n        for(int j = 0 ; j<mat[0].size(); j++){\\n            if(mat[i][j] == 1){\\n                count++;\\n            }\\n        }\\n        if(Max < count){\\n            Max = count;\\n            row_Idx = i;\\n        }\\n        }\\n        ans.push_back(row_Idx);\\n        ans.push_back(Max);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector <int> ans;\\n        int Max = INT_MIN, row_Idx;\\n        for(int i = 0 ; i<mat.size(); i++){\\n            int count = 0;\\n        for(int j = 0 ; j<mat[0].size(); j++){\\n            if(mat[i][j] == 1){\\n                count++;\\n            }\\n        }\\n        if(Max < count){\\n            Max = count;\\n            row_Idx = i;\\n        }\\n        }\\n        ans.push_back(row_Idx);\\n        ans.push_back(Max);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042974,
                "title": "row-with-maximum-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int onecount =INT_MIN;\\n        int n=mat.size();\\n        vector<int>ans;\\n        int rowno = -1;\\n        for(int i=0 ;i<n ;i++){\\n            int count =0;\\n            for(int j=0 ; j<mat[i].size() ; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            if(count >  onecount){\\n                onecount =count;\\n                rowno =i;\\n            }\\n        }\\n        ans.push_back(rowno);\\n        ans.push_back(onecount);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int onecount =INT_MIN;\\n        int n=mat.size();\\n        vector<int>ans;\\n        int rowno = -1;\\n        for(int i=0 ;i<n ;i++){\\n            int count =0;\\n            for(int j=0 ; j<mat[i].size() ; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            if(count >  onecount){\\n                onecount =count;\\n                rowno =i;\\n            }\\n        }\\n        ans.push_back(rowno);\\n        ans.push_back(onecount);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041660,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        \\n        vector<int>ans;\\n        int row = mat.size();\\n        int col = mat[0].size();\\n        // for max count of one\\n        int oneCount = INT_MIN;\\n        // for which row has max one count\\n        int rowNo = 0;\\n\\n        for(int i=0 ; i<row ; i++){\\n            int count = 0;\\n            for(int j=0 ; j<col ; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n\\n            if(count > oneCount){\\n                oneCount = count;\\n                rowNo = i;\\n            }\\n        }\\n\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        \\n        vector<int>ans;\\n        int row = mat.size();\\n        int col = mat[0].size();\\n        // for max count of one\\n        int oneCount = INT_MIN;\\n        // for which row has max one count\\n        int rowNo = 0;\\n\\n        for(int i=0 ; i<row ; i++){\\n            int count = 0;\\n            for(int j=0 ; j<col ; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n\\n            if(count > oneCount){\\n                oneCount = count;\\n                rowNo = i;\\n            }\\n        }\\n\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041598,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int oneCount = 0;\\n        int rowNo ;\\n        vector<int> ans;\\n\\n        for(int i=0 ; i<n ;i++){\\n            int count=0;\\n            for(int j=0 ; j<mat[i].size() ; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n\\n                if(count>oneCount){\\n                    oneCount = count;\\n\\n                    rowNo = i;\\n                }\\n            }\\n        }\\n            ans.push_back(rowNo);\\n            ans.push_back(oneCount);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int oneCount = 0;\\n        int rowNo ;\\n        vector<int> ans;\\n\\n        for(int i=0 ; i<n ;i++){\\n            int count=0;\\n            for(int j=0 ; j<mat[i].size() ; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n\\n                if(count>oneCount){\\n                    oneCount = count;\\n\\n                    rowNo = i;\\n                }\\n            }\\n        }\\n            ans.push_back(rowNo);\\n            ans.push_back(oneCount);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040180,
                "title": "easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> v;\\n        int max1 = 0;\\n        int maxi = 0;\\n\\n        for (int i = 0; i < mat.size(); i++) {\\n            int count = 0;\\n\\n            for (int j = 0; j < mat[i].size(); j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n\\n            if (count > max1) {\\n                max1 = count;\\n                maxi = i;\\n            }\\n        }\\n\\n        v.push_back(maxi);\\n        v.push_back(max1);\\n\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> v;\\n        int max1 = 0;\\n        int maxi = 0;\\n\\n        for (int i = 0; i < mat.size(); i++) {\\n            int count = 0;\\n\\n            for (int j = 0; j < mat[i].size(); j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n\\n            if (count > max1) {\\n                max1 = count;\\n                maxi = i;\\n            }\\n        }\\n\\n        v.push_back(maxi);\\n        v.push_back(max1);\\n\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039370,
                "title": "beats-98-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n=mat.size();\\n        //oneCount ->will store max no of 1\\'s in a row\\n        int oneCount=INT_MIN;\\n        //rowno-->  will store index of max no of 1/s wali row\\n        int rowNo=-101;\\n\\n        for(int i=0;i<n;i++){\\n            //hr row start hone se phle initialize count with 0\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                //if one found then increment one\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            //after row comple compare with one count\\n            if(count>oneCount){\\n                oneCount=count;\\n                rowNo=i;\\n            }\\n        }\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n=mat.size();\\n        //oneCount ->will store max no of 1\\'s in a row\\n        int oneCount=INT_MIN;\\n        //rowno-->  will store index of max no of 1/s wali row\\n        int rowNo=-101;\\n\\n        for(int i=0;i<n;i++){\\n            //hr row start hone se phle initialize count with 0\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                //if one found then increment one\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            //after row comple compare with one count\\n            if(count>oneCount){\\n                oneCount=count;\\n                rowNo=i;\\n            }\\n        }\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037894,
                "title": "easy-c-solution-of-this-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int >ans;\\n        int n = mat.size();\\n        int onecount = INT_MIN;\\n        int rowno = -1;\\n\\n        for(int i = 0; i<n; i++ ){\\n            int count = 0; \\n            for(int  j = 0; j<mat[i].size(); j++ )\\n            {\\n                if(mat[i][j]  == 1){\\n                    count++;\\n                }\\n            }\\n            if(count > onecount )\\n            {\\n                onecount = count;\\n                rowno = i;\\n            }\\n        }\\n        ans.push_back(rowno); \\n        ans.push_back(onecount);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int >ans;\\n        int n = mat.size();\\n        int onecount = INT_MIN;\\n        int rowno = -1;\\n\\n        for(int i = 0; i<n; i++ ){\\n            int count = 0; \\n            for(int  j = 0; j<mat[i].size(); j++ )\\n            {\\n                if(mat[i][j]  == 1){\\n                    count++;\\n                }\\n            }\\n            if(count > onecount )\\n            {\\n                onecount = count;\\n                rowno = i;\\n            }\\n        }\\n        ans.push_back(rowno); \\n        ans.push_back(onecount);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036575,
                "title": "row-with-maximum-ones",
                "content": "# Intuition\\nWe are given a binary matrix where each row represents a set of elements with values 0 or 1. We need to find the row with the maximum number of 1s.\\n\\n# Approach\\n1. Initialize oneCount to a very small integer (e.g., INT_MIN) to keep track of the maximum number of 1s in a row.\\n2. Initialize rowNo to -1 to keep track of the row number with the maximum 1s.\\n3. Iterate through each row of the matrix.\\n->Initialize count to 0 for each row to count the number of 1s.\\n->Iterate through each element in the row.\\n->If an element is 1, increment count.\\n4. After counting the 1s in a row, compare count with oneCount.\\n->If count is greater than oneCount, update oneCount with count and rowNo with the current row number.\\n5. Finally, return a vector containing rowNo and oneCount, which represents the row with the maximum 1s and the count of maximum 1s in that row.\\n# Complexity\\n- Time complexity:\\nWe iterate through each row of the matrix once, and for each row, we iterate through all of its elements once. Therefore, the time complexity is O(n * m), where n is the number of rows and m is the number of columns in the matrix.\\n\\n- Space complexity:\\nWe use a constant amount of extra space for variables (oneCount, rowNo, and count) regardless of the input size. Therefore, the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n = mat.size();\\n        // Will store the max number of 1s in a row\\n        int oneCount = INT_MIN;\\n        // Will store max row number with max 1s\\n        int rowNo = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            // Initialize count with 0 for each row\\n            int count = 0;\\n            for (int j = 0; j < mat[i].size(); j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            // After row completion, compare count with oneCount\\n            if (count > oneCount) {\\n                oneCount = count;\\n                rowNo = i;\\n            }\\n        }\\n\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n = mat.size();\\n        // Will store the max number of 1s in a row\\n        int oneCount = INT_MIN;\\n        // Will store max row number with max 1s\\n        int rowNo = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            // Initialize count with 0 for each row\\n            int count = 0;\\n            for (int j = 0; j < mat[i].size(); j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            // After row completion, compare count with oneCount\\n            if (count > oneCount) {\\n                oneCount = count;\\n                rowNo = i;\\n            }\\n        }\\n\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035519,
                "title": "easy-java-sol-using-iterative-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=Integer.MIN_VALUE;\\n        int ans[]=new int[2];\\n\\n        for(int i=0;i<mat.length;i++){\\n            int ones=0;\\n\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1) ones++;\\n            }\\n            if(ones>max){\\n                max=ones;\\n                ans[0]=i;\\n                ans[1]=ones;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=Integer.MIN_VALUE;\\n        int ans[]=new int[2];\\n\\n        for(int i=0;i<mat.length;i++){\\n            int ones=0;\\n\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1) ones++;\\n            }\\n            if(ones>max){\\n                max=ones;\\n                ans[0]=i;\\n                ans[1]=ones;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028371,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n\\n        int count=0, index=0;\\n        int arr[] = new int[2];\\n\\n        for(int i=0; i<mat.length; i++){\\n            count=0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n          \\n            if(count>arr[1]){\\n                arr[1]=count;\\n                arr[0]=i;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n\\n        int count=0, index=0;\\n        int arr[] = new int[2];\\n\\n        for(int i=0; i<mat.length; i++){\\n            count=0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n          \\n            if(count>arr[1]){\\n                arr[1]=count;\\n                arr[0]=i;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022806,
                "title": "n-x-log2-m",
                "content": "# Intuition\\njust finding the no. of 1\\'s using lower bound and checking the condition that if maxcnt is larger than the instant cnt.\\n\\n# Approach\\nfirstly we know that the matrix is sorted at the column level .so, we cannot optimize row traversal the only thing we can optimize is that the way of computing no. of 1\\'s.\\nrun a for lopp for each row and find the no. of 1,s at each row by\\ncntones = m - lowerBound(matrix[i],m,1) .\\nand then check the condition.\\n\\n# Complexity\\n- Time complexity:O(N X log2(M))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int lowerBound(vector<int>& arr,int n,int x){\\n    \\n    int low = 0, high = n-1;\\n    \\n    while(low <= high){\\n        int mid = (low+high)/2;\\n        \\n        if(arr[mid] >= x){\\n            high=mid-1;\\n        }\\n        \\n        else{\\n            low=mid+1;\\n        }\\n    }\\n    return low;\\n}\\n\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        \\n        int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i=0;i<mat.size();i++){\\n            sort(mat[i].begin(),mat[i].end());\\n        }\\n            int index = -1;\\n    int max_cnt = -1;//don\\'t put max_cnt = -1; \\n    \\n    // n X log2 m\\n\\n    for(int i=0;i<n;i++){\\n        int cnt_ones = m-lowerBound(mat[i],m,1);\\n\\n        if(cnt_ones > max_cnt){\\n            max_cnt=cnt_ones;\\n            index=i;\\n        }\\n    }\\n    return {index,max_cnt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int lowerBound(vector<int>& arr,int n,int x){\\n    \\n    int low = 0, high = n-1;\\n    \\n    while(low <= high){\\n        int mid = (low+high)/2;\\n        \\n        if(arr[mid] >= x){\\n            high=mid-1;\\n        }\\n        \\n        else{\\n            low=mid+1;\\n        }\\n    }\\n    return low;\\n}\\n\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        \\n        int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i=0;i<mat.size();i++){\\n            sort(mat[i].begin(),mat[i].end());\\n        }\\n            int index = -1;\\n    int max_cnt = -1;//don\\'t put max_cnt = -1; \\n    \\n    // n X log2 m\\n\\n    for(int i=0;i<n;i++){\\n        int cnt_ones = m-lowerBound(mat[i],m,1);\\n\\n        if(cnt_ones > max_cnt){\\n            max_cnt=cnt_ones;\\n            index=i;\\n        }\\n    }\\n    return {index,max_cnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021509,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int[] rowAndMaximumOnes(int[][] mat) {\\n\\t\\tint maxCount = Integer.MIN_VALUE;\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tif(mat[i][j]==1) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(maxCount<count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tindex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n        return new int[] {index,maxCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] rowAndMaximumOnes(int[][] mat) {\\n\\t\\tint maxCount = Integer.MIN_VALUE;\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tif(mat[i][j]==1) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(maxCount<count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tindex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n        return new int[] {index,maxCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016559,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public static int[] rowAndMaximumOnes(int[][] mat) {\\n\\t\\tint maxCount = Integer.MIN_VALUE;\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tif(mat[i][j]==1) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(maxCount<count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tindex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n        return new int[] {index,maxCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] rowAndMaximumOnes(int[][] mat) {\\n\\t\\tint maxCount = Integer.MIN_VALUE;\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tif(mat[i][j]==1) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(maxCount<count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tindex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n        return new int[] {index,maxCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015231,
                "title": "short-and-simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse `sum` to find the number of ones in each row, then `max`.\\n\\n# Complexity\\n- Time complexity: $$ O(m*n) $$ - summing each row takes $$ O(n) $$ and we do this $$ m $$ times.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(1) $$ - no additional memory is allocated.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        # Use the negative index here since we want the \"smallest row number\"\\n        count, index = max((sum(row), -i) for i, row in enumerate(mat))\\n        # Turn index back to positive\\n        return [-index, count]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        # Use the negative index here since we want the \"smallest row number\"\\n        count, index = max((sum(row), -i) for i, row in enumerate(mat))\\n        # Turn index back to positive\\n        return [-index, count]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015006,
                "title": "javascript-max",
                "content": "# Code\\n```\\n// T: O(m*n) | S: O(1)\\nvar rowAndMaximumOnes = function(mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    let max = 0;\\n    let ind = 0;\\n    for (let i = 0; i < m; i++) {\\n        let val = 0;\\n        for (let j = 0; j < n; j++) {\\n            val += mat[i][j];\\n        }\\n        if (val > max) {\\n            max = val;\\n            ind = i;\\n        }\\n    }\\n    return [ind, max];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// T: O(m*n) | S: O(1)\\nvar rowAndMaximumOnes = function(mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    let max = 0;\\n    let ind = 0;\\n    for (let i = 0; i < m; i++) {\\n        let val = 0;\\n        for (let j = 0; j < n; j++) {\\n            val += mat[i][j];\\n        }\\n        if (val > max) {\\n            max = val;\\n            ind = i;\\n        }\\n    }\\n    return [ind, max];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012313,
                "title": "elixir-simple-solution",
                "content": "```\\ndefmodule Solution do\\n  @spec row_and_maximum_ones(mat :: [[integer]]) :: [integer]\\n  def row_and_maximum_ones(mat) do\\n    mat\\n    |> Enum.with_index()\\n    |> Enum.reduce([0, 0], fn {row, i}, [r, ct] ->\\n      ones = Enum.count(row, &(&1 == 1))\\n\\n      if ones > ct do\\n        [i, ones]\\n      else\\n        [r, ct]\\n      end\\n    end)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec row_and_maximum_ones(mat :: [[integer]]) :: [integer]\\n  def row_and_maximum_ones(mat) do\\n    mat\\n    |> Enum.with_index()\\n    |> Enum.reduce([0, 0], fn {row, i}, [r, ct] ->\\n      ones = Enum.count(row, &(&1 == 1))\\n\\n      if ones > ct do\\n        [i, ones]\\n      else\\n        [r, ct]\\n      end\\n    end)\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4002799,
                "title": "93-beats-java-o-n-m",
                "content": "# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] temp = new int[mat.length];\\n        int idx = -1,value = -1;\\n\\n        for(int i = 0; i<mat.length; i++){\\n            for(int j = 0; j<mat[0].length; j++){\\n                temp[i]+=mat[i][j];\\n            }\\n            if(value<temp[i]){\\n                    idx = i;\\n                    value = temp[i];\\n                }\\n        }\\n\\n        return new int[]{idx,value};\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] temp = new int[mat.length];\\n        int idx = -1,value = -1;\\n\\n        for(int i = 0; i<mat.length; i++){\\n            for(int j = 0; j<mat[0].length; j++){\\n                temp[i]+=mat[i][j];\\n            }\\n            if(value<temp[i]){\\n                    idx = i;\\n                    value = temp[i];\\n                }\\n        }\\n\\n        return new int[]{idx,value};\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990845,
                "title": "java-soltuion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int ans[] = new int[2];\\n        int count=0,index=0,sum=0;\\n        int n=mat.length;int m=mat[0].length;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            count =0;\\n            for(int j=0;j <mat[i].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>sum){\\n            sum=count;\\n            index=i;\\n            }\\n        }\\n        ans[0]=index;\\n        ans[1]=sum;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int ans[] = new int[2];\\n        int count=0,index=0,sum=0;\\n        int n=mat.length;int m=mat[0].length;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            count =0;\\n            for(int j=0;j <mat[i].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>sum){\\n            sum=count;\\n            index=i;\\n            }\\n        }\\n        ans[0]=index;\\n        ans[1]=sum;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982528,
                "title": "click-drama-drama-alert-idiot-here-at-your-service-wow-big-big",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary meaning only zeroes and ones. If all rows are of same length then the maximum of the sums of each row should be the answer. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse list comprehension and the sum() function. max() to find the highest and find the index of the highest and index() returns the first occurrence if there are multiple.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        sums = [sum(i) for i in mat]\\n        high = max(sums)\\n        ind = sums.index(high)\\n        return [ind, high]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        sums = [sum(i) for i in mat]\\n        high = max(sums)\\n        ind = sums.index(high)\\n        return [ind, high]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979126,
                "title": "sort-elixir",
                "content": "# Code\\n```\\ndefmodule Solution do\\n  @spec row_and_maximum_ones(mat :: [[integer]]) :: [integer]\\n  def row_and_maximum_ones(mat) do\\n    mat\\n    |> Enum.with_index()\\n    |> Enum.map(fn {row, index} -> [index, count_ones(row)] end)\\n    |> sort_by()\\n    |> hd()\\n  end\\n\\n  defp count_ones(row) do\\n    Enum.count(row, fn x -> x == 1 end)\\n  end\\n\\n  defp sort_by(arr) do\\n    Enum.sort(arr, fn [a_idx, a_cnt], [b_idx, b_cnt] ->\\n      case a_cnt == b_cnt do\\n        true -> a_idx < b_idx\\n        false -> a_cnt > b_cnt\\n      end\\n    end)\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec row_and_maximum_ones(mat :: [[integer]]) :: [integer]\\n  def row_and_maximum_ones(mat) do\\n    mat\\n    |> Enum.with_index()\\n    |> Enum.map(fn {row, index} -> [index, count_ones(row)] end)\\n    |> sort_by()\\n    |> hd()\\n  end\\n\\n  defp count_ones(row) do\\n    Enum.count(row, fn x -> x == 1 end)\\n  end\\n\\n  defp sort_by(arr) do\\n    Enum.sort(arr, fn [a_idx, a_cnt], [b_idx, b_cnt] ->\\n      case a_cnt == b_cnt do\\n        true -> a_idx < b_idx\\n        false -> a_cnt > b_cnt\\n      end\\n    end)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3978594,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) \\n    {\\n        \\n        int index = -1;\\n        int max_count = -1;\\n        for(int i=0; i<mat.size(); i++)\\n        {\\n            int row_count = 0;\\n            for(int j=0; j<mat[0].size(); j++)\\n            {\\n                row_count = row_count + mat[i][j];\\n            }\\n            if(row_count > max_count)\\n            {\\n                max_count = row_count;\\n                index = i;\\n            }\\n        }\\n        return {index, max_count};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) \\n    {\\n        \\n        int index = -1;\\n        int max_count = -1;\\n        for(int i=0; i<mat.size(); i++)\\n        {\\n            int row_count = 0;\\n            for(int j=0; j<mat[0].size(); j++)\\n            {\\n                row_count = row_count + mat[i][j];\\n            }\\n            if(row_count > max_count)\\n            {\\n                max_count = row_count;\\n                index = i;\\n            }\\n        }\\n        return {index, max_count};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3975885,
                "title": "python-94-efficient-solution-space-using-lambda-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        result = []\\n        #Traversing row\\n        for i in range(len(mat)):\\n            counter = 0\\n            #Traversing elements of the row\\n            for j in mat[i]:\\n                if j == 1:\\n                    #Count the number of 1\\'s in the row\\n                    counter += 1\\n            result.append([i,counter])\\n        result.sort(reverse=True)\\n        #Sort the result along with the number of 1 present in that row\\n        result.sort(key=lambda x:x[1])\\n        return result[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        result = []\\n        #Traversing row\\n        for i in range(len(mat)):\\n            counter = 0\\n            #Traversing elements of the row\\n            for j in mat[i]:\\n                if j == 1:\\n                    #Count the number of 1\\'s in the row\\n                    counter += 1\\n            result.append([i,counter])\\n        result.sort(reverse=True)\\n        #Sort the result along with the number of 1 present in that row\\n        result.sort(key=lambda x:x[1])\\n        return result[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966398,
                "title": "java-direct-to-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute force approach\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        \\n       int ans[] = new int[2];\\n\\n       int count = 0;\\n\\n       for(int i=0; i<mat.length; i++ ){\\n\\n           int temp = 0;\\n\\n           for( int j=0; j<mat[0].length; j++){\\n\\n               if( mat[i][j] == 1 ){\\n                   temp++;\\n               }\\n           }\\n\\n           if( temp > count ){\\n\\n               count = temp;\\n               \\n               ans[0] = i;\\n               ans[1] = count;\\n\\n           }\\n       }\\n\\n       return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        \\n       int ans[] = new int[2];\\n\\n       int count = 0;\\n\\n       for(int i=0; i<mat.length; i++ ){\\n\\n           int temp = 0;\\n\\n           for( int j=0; j<mat[0].length; j++){\\n\\n               if( mat[i][j] == 1 ){\\n                   temp++;\\n               }\\n           }\\n\\n           if( temp > count ){\\n\\n               count = temp;\\n               \\n               ans[0] = i;\\n               ans[1] = count;\\n\\n           }\\n       }\\n\\n       return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965735,
                "title": "oneline-fast",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        return sorted((mat[i].count(1), -i, i, mat[i].count(1)) for i in range(len(mat)))[-1][2:]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        return sorted((mat[i].count(1), -i, i, mat[i].count(1)) for i in range(len(mat)))[-1][2:]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963997,
                "title": "c-simple-solution-runtime-106-ms-beats-93-20-memory-60-5-mb-beats-59-69",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int row_size = mat.size(), col_size = mat[0].size();\\n        vector<int> ans(2);\\n        int mx_count = INT_MIN;\\n        for(int i = 0; i < row_size; ++i){\\n            int count = 0;\\n            for(int j = 0; j < col_size; ++j){\\n                if(mat[i][j] == 1) count++;\\n            }\\n            if(mx_count < count) {\\n                ans[0] = i;\\n                ans[1] = count;\\n                mx_count = count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int row_size = mat.size(), col_size = mat[0].size();\\n        vector<int> ans(2);\\n        int mx_count = INT_MIN;\\n        for(int i = 0; i < row_size; ++i){\\n            int count = 0;\\n            for(int j = 0; j < col_size; ++j){\\n                if(mat[i][j] == 1) count++;\\n            }\\n            if(mx_count < count) {\\n                ans[0] = i;\\n                ans[1] = count;\\n                mx_count = count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961693,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i = 0; i < mat.length; i++){\\n            int count = 0;\\n            for(int j = 0; j < mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n            if(arr[1] < count){\\n                arr[0] = i;\\n                arr[1] = count;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i = 0; i < mat.length; i++){\\n            int count = 0;\\n            for(int j = 0; j < mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n            if(arr[1] < count){\\n                arr[0] = i;\\n                arr[1] = count;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959143,
                "title": "easiest-solution-possible-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] ar = new int[2];\\n        int maxi = 0;\\n       \\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0; i<mat.length; i++){\\n            int count = 0;\\n            for(int j = 0; j<mat[0].length;j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n\\n            }\\n            if(!map.containsKey(count)){\\n                map.put(count,i);\\n            }\\n        }\\n       \\n        for(int i : map.keySet()){\\n            maxi = Math.max(maxi,i);\\n\\n\\n\\n        }\\n        ar[0] = map.get(maxi);\\n        ar[1] = maxi;\\n\\n    return ar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] ar = new int[2];\\n        int maxi = 0;\\n       \\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0; i<mat.length; i++){\\n            int count = 0;\\n            for(int j = 0; j<mat[0].length;j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n\\n            }\\n            if(!map.containsKey(count)){\\n                map.put(count,i);\\n            }\\n        }\\n       \\n        for(int i : map.keySet()){\\n            maxi = Math.max(maxi,i);\\n\\n\\n\\n        }\\n        ar[0] = map.get(maxi);\\n        ar[1] = maxi;\\n\\n    return ar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957817,
                "title": "optimal-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ind=0,cnt=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1) c+=1;\\n            }\\n            if(c>cnt){\\n                ind=i;\\n                cnt=c;\\n            }\\n        }\\n        \\n        return {ind,cnt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ind=0,cnt=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1) c+=1;\\n            }\\n            if(c>cnt){\\n                ind=i;\\n                cnt=c;\\n            }\\n        }\\n        \\n        return {ind,cnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955950,
                "title": "too-easy-easiest-java-solution-beats-100-o-m-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m * n) \\n    Where m is the number of rows and n is the number of columns in the input matrix mat.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] arr=new int [2];\\n        int min=Integer.MIN_VALUE;\\n        for (int i=0;i<mat.length;i++){\\n            int count=0;\\n            for (int j=0;j<mat[i].length;j++){\\n                if (mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            \\n            if (min<count){\\n                min=count;\\n                arr[0]=i;\\n            }\\n            \\n        }\\n        arr[1]=min;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] arr=new int [2];\\n        int min=Integer.MIN_VALUE;\\n        for (int i=0;i<mat.length;i++){\\n            int count=0;\\n            for (int j=0;j<mat[i].length;j++){\\n                if (mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            \\n            if (min<count){\\n                min=count;\\n                arr[0]=i;\\n            }\\n            \\n        }\\n        arr[1]=min;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954501,
                "title": "binary-search-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int rowWithone(int[] arr,int st,int end){\\n           Arrays.sort(arr);\\n            int firstOccurence=-1;\\n\\t\\t\\twhile(st<=end){\\n\\t\\t\\t\\tint mid=(st+end)/2;\\n\\t\\t\\t\\tif(arr[mid]==1){           \\n\\t\\t\\t\\t\\tfirstOccurence=mid;\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arr[mid]<1){\\n\\t\\t\\t\\t\\tst=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t    return firstOccurence;\\n    }\\n    public int[] rowAndMaximumOnes(int[][] arr) {\\n        int n=arr.length;\\n        int m=arr[0].length;\\n        int maxValue=0;     //varible store the max count of one\\'s;\\n\\t\\tint maxValueidx=-1;  //variable store the idx of max count of one\\'s;\\n\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\tint firstOccuridx=rowWithone(arr[i],0,m-1 );    //calling function which return the first occurence index of the 1 in that row;\\n\\t\\t\\tif(firstOccuridx!=-1 && m-firstOccuridx>maxValue ){   //if the firstOuccrenc is -1 which means no one is fount on that row \\n\\t\\t\\t\\tmaxValue=m-firstOccuridx;                         //else if it is not -1 then we have to count the no of one\\'s on that row \\n\\t\\t\\t\\tmaxValueidx=i;                                    // no of one\\'s on that row are the no of ele - first occure indx;\\n\\t\\t\\t\\t                                                  //if the max count of one is more then the previous count then update it and update the max value idx;else continue \\n\\t\\t\\t}\\n\\t\\t}\\t\\n        int[] res=new int[2];\\n        if(maxValueidx==-1) res[0]=0;\\n        else res[0]=maxValueidx;\\n        res[1]=maxValue;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int rowWithone(int[] arr,int st,int end){\\n           Arrays.sort(arr);\\n            int firstOccurence=-1;\\n\\t\\t\\twhile(st<=end){\\n\\t\\t\\t\\tint mid=(st+end)/2;\\n\\t\\t\\t\\tif(arr[mid]==1){           \\n\\t\\t\\t\\t\\tfirstOccurence=mid;\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arr[mid]<1){\\n\\t\\t\\t\\t\\tst=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t    return firstOccurence;\\n    }\\n    public int[] rowAndMaximumOnes(int[][] arr) {\\n        int n=arr.length;\\n        int m=arr[0].length;\\n        int maxValue=0;     //varible store the max count of one\\'s;\\n\\t\\tint maxValueidx=-1;  //variable store the idx of max count of one\\'s;\\n\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\tint firstOccuridx=rowWithone(arr[i],0,m-1 );    //calling function which return the first occurence index of the 1 in that row;\\n\\t\\t\\tif(firstOccuridx!=-1 && m-firstOccuridx>maxValue ){   //if the firstOuccrenc is -1 which means no one is fount on that row \\n\\t\\t\\t\\tmaxValue=m-firstOccuridx;                         //else if it is not -1 then we have to count the no of one\\'s on that row \\n\\t\\t\\t\\tmaxValueidx=i;                                    // no of one\\'s on that row are the no of ele - first occure indx;\\n\\t\\t\\t\\t                                                  //if the max count of one is more then the previous count then update it and update the max value idx;else continue \\n\\t\\t\\t}\\n\\t\\t}\\t\\n        int[] res=new int[2];\\n        if(maxValueidx==-1) res[0]=0;\\n        else res[0]=maxValueidx;\\n        res[1]=maxValue;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949019,
                "title": "beats-100-ruby-easy-to-understand-2643-row-with-maximum-ones",
                "content": "# Code\\n```\\n# @param {Integer[][]} mat\\n# @return {Integer[]}\\ndef row_and_maximum_ones(matrix)\\n    max = 0\\n    index = 0\\n    matrix.each_with_index do |mat, indx|\\n        tamp_max = 0\\n        mat.each do |mt|\\n            tamp_max += 1 if mt == 1\\n        end\\n        if tamp_max > max\\n            max = tamp_max\\n            index = indx\\n        end\\n    end\\n    return [index, max]\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n# @param {Integer[][]} mat\\n# @return {Integer[]}\\ndef row_and_maximum_ones(matrix)\\n    max = 0\\n    index = 0\\n    matrix.each_with_index do |mat, indx|\\n        tamp_max = 0\\n        mat.each do |mt|\\n            tamp_max += 1 if mt == 1\\n        end\\n        if tamp_max > max\\n            max = tamp_max\\n            index = indx\\n        end\\n    end\\n    return [index, max]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3945308,
                "title": "count-and-maximum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] arr = new int[mat.length];\\n        for(int i=0; i<mat.length; i++){\\n            int count=0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            arr[i]=count;\\n        }\\n\\n        int max=0;\\n        int ind=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                ind=i;\\n            }\\n        }\\n        return new int[]{ind,max};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] arr = new int[mat.length];\\n        for(int i=0; i<mat.length; i++){\\n            int count=0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            arr[i]=count;\\n        }\\n\\n        int max=0;\\n        int ind=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                ind=i;\\n            }\\n        }\\n        return new int[]{ind,max};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942937,
                "title": "short-and-simple-python3-beats-99-9-runtime",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, 0]\\n        for i, row in enumerate(mat):\\n            c = row.count(1)\\n            if c > res[1]:\\n                res[:] = i, c             \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, 0]\\n        for i, row in enumerate(mat):\\n            c = row.count(1)\\n            if c > res[1]:\\n                res[:] = i, c             \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938486,
                "title": "c-o-n-logm-solution",
                "content": "# Intuition\\nIf the row was sorted then I can easily find the count of ones using by finding first occurence of 1 using lower bound/first occurence\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort every row\\nFind the first occrrence of 1.\\nCount of 1s in the row is then just row.size() - firstOccurrence\\n\\n# Complexity\\n- Time complexity:\\nO(n* log m) when n is number of rows and m is number of columns\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        for(auto &row:mat){\\n            sort(row.begin(), row.end());\\n        }\\n\\n        int currentMax=-1, idx=-1;\\n\\n        for(int i=0; i<mat.size(); ++i){\\n            int firstOccurrence = lower_bound(mat[i].begin(), mat[i].end(), 1) - mat[i].begin();\\n            int currentCount = mat[i].size()-firstOccurrence;\\n            if(currentCount>currentMax){\\n                currentMax=currentCount;\\n                idx=i;\\n            }\\n        }\\n        return {idx, currentMax};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        for(auto &row:mat){\\n            sort(row.begin(), row.end());\\n        }\\n\\n        int currentMax=-1, idx=-1;\\n\\n        for(int i=0; i<mat.size(); ++i){\\n            int firstOccurrence = lower_bound(mat[i].begin(), mat[i].end(), 1) - mat[i].begin();\\n            int currentCount = mat[i].size()-firstOccurrence;\\n            if(currentCount>currentMax){\\n                currentMax=currentCount;\\n                idx=i;\\n            }\\n        }\\n        return {idx, currentMax};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930828,
                "title": "easy-c-solution-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWith one row at a time,you just need to iterate over the column elements of respective rows and update curr element.If max>curr just update your max and index.It is important to keep note that the curr variable should be updated to zero after each iteration in order to avoid any discrepancy.Its using just an additional space for storing result which makes it quite efficient.\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n\\n- Space complexity: 0(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        int firstrow = 0;\\n        int lastrow = m-1;\\n        int firstcol = 0;\\n        int lastcol = n-1;\\n\\n        vector<int>ans;\\n        int max_one = 0;\\n        int index = 0;\\n\\n        for(int row = firstrow;row<=lastrow;row++){\\n            int curr = 0;\\n            for(int col = firstcol;col<=lastcol;col++){\\n                if(mat[row][col] == 1){\\n                    curr++;\\n                }\\n                else{\\n                    continue;\\n                }\\n                if(curr>max_one){\\n                    max_one = curr;\\n                    index = row;\\n                }\\n            }\\n        }\\n        ans.push_back(index);\\n        ans.push_back(max_one);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        int firstrow = 0;\\n        int lastrow = m-1;\\n        int firstcol = 0;\\n        int lastcol = n-1;\\n\\n        vector<int>ans;\\n        int max_one = 0;\\n        int index = 0;\\n\\n        for(int row = firstrow;row<=lastrow;row++){\\n            int curr = 0;\\n            for(int col = firstcol;col<=lastcol;col++){\\n                if(mat[row][col] == 1){\\n                    curr++;\\n                }\\n                else{\\n                    continue;\\n                }\\n                if(curr>max_one){\\n                    max_one = curr;\\n                    index = row;\\n                }\\n            }\\n        }\\n        ans.push_back(index);\\n        ans.push_back(max_one);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929440,
                "title": "java-soluction",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int sum=0;\\n        int index=0;int count=0;\\n        for(int i=0;i<mat.length;i++){\\n            count=0;\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            if(count>sum){\\n                sum=count;\\n                index=i;\\n            }\\n        }\\n        int arr[]={index,sum};\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int sum=0;\\n        int index=0;int count=0;\\n        for(int i=0;i<mat.length;i++){\\n            count=0;\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            if(count>sum){\\n                sum=count;\\n                index=i;\\n            }\\n        }\\n        int arr[]={index,sum};\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926603,
                "title": "row-with-maximum-ones",
                "content": "# Complexity\\n- Time complexity:O(N*logM)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\nint lowerbound(vector<int>arr,int n){\\n        if(n==1) return arr[0]==1;\\n        int low=0,high=n-1;\\n        sort(arr.begin(),arr.end());\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(arr[mid]==1){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return (n-1)-low+1;\\n    }\\n    public:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxi=0;\\n        int index=0;\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        for(int i=0;i<n;i++){\\n            int cnt_ones=lowerbound(mat[i],m);\\n            if(cnt_ones>maxi){\\n                maxi=cnt_ones;\\n                index=i;\\n            }\\n        }\\n        return {index,maxi};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\nint lowerbound(vector<int>arr,int n){\\n        if(n==1) return arr[0]==1;\\n        int low=0,high=n-1;\\n        sort(arr.begin(),arr.end());\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(arr[mid]==1){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return (n-1)-low+1;\\n    }\\n    public:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxi=0;\\n        int index=0;\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        for(int i=0;i<n;i++){\\n            int cnt_ones=lowerbound(mat[i],m);\\n            if(cnt_ones>maxi){\\n                maxi=cnt_ones;\\n                index=i;\\n            }\\n        }\\n        return {index,maxi};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923778,
                "title": "python-beats-96-runtime-95-memory-coded-on-mobile",
                "content": "![image](https://assets.leetcode.com/users/images/4cbb30dd-9007-4e98-938e-aee6c806a6b8_1692295282.9749117.jpeg)\\n![image](https://assets.leetcode.com/users/images/c46adaeb-f468-4681-bf13-4e6e8c7bf59f_1692295283.356553.jpeg)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/4cbb30dd-9007-4e98-938e-aee6c806a6b8_1692295282.9749117.jpeg)\\n![image](https://assets.leetcode.com/users/images/c46adaeb-f468-4681-bf13-4e6e8c7bf59f_1692295283.356553.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3923316,
                "title": "iteration-and-reduce-ts-js",
                "content": "\\n# Approach\\ninitialize max variable with values = [-1,-1]\\niterate through each row \\nsum all 1s in the row using reduce\\nif sum is greater than the stored value in max, update max\\n\\n\\n# Code\\n```\\nfunction rowAndMaximumOnes(mat: number[][]): number[] {\\n  let max = [-1, -1]\\n  mat.forEach((val, i) => {\\n    const x = val.reduce((acc,val) => val ? (acc + val) : acc, 0)\\n    if (x > max[1]) { max = [i, x]}\\n  })\\n  return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction rowAndMaximumOnes(mat: number[][]): number[] {\\n  let max = [-1, -1]\\n  mat.forEach((val, i) => {\\n    const x = val.reduce((acc,val) => val ? (acc + val) : acc, 0)\\n    if (x > max[1]) { max = [i, x]}\\n  })\\n  return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3904858,
                "title": "simple-javascript-80-ms-beats-92",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let m = mat.length;\\n    let n = mat[0].length;\\n\\n    let row = 0, count = 0;\\n\\n    for(let i = 0; i < m; i++) {\\n        let rowCount = 0;\\n        for(let j = 0; j < n; j++) {\\n            if(mat[i][j] === 1) {\\n                rowCount++;\\n            }\\n\\n            if(rowCount > count) {\\n                count = rowCount;\\n                row = i;\\n            }\\n        }\\n    }\\n    return [row, count];\\n};\\n\\n// TC: O(m * n)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let m = mat.length;\\n    let n = mat[0].length;\\n\\n    let row = 0, count = 0;\\n\\n    for(let i = 0; i < m; i++) {\\n        let rowCount = 0;\\n        for(let j = 0; j < n; j++) {\\n            if(mat[i][j] === 1) {\\n                rowCount++;\\n            }\\n\\n            if(rowCount > count) {\\n                count = rowCount;\\n                row = i;\\n            }\\n        }\\n    }\\n    return [row, count];\\n};\\n\\n// TC: O(m * n)\\n// SC: O(1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3903945,
                "title": "python-simple-solution-nested-loops-beginner-friendly",
                "content": "# Intuition\\n\\n---\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        m = len(mat)\\n        n = len(mat[0])\\n        maxcount = 0\\n        index = 0\\n\\n        for i in range(m):\\n            count = 0\\n            for j in range(n):\\n                if mat[i][j] == 1:\\n                    count +=1\\n\\n                    if count > maxcount:\\n                        maxcount = count\\n                        index = i\\n        return [index,maxcount]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        m = len(mat)\\n        n = len(mat[0])\\n        maxcount = 0\\n        index = 0\\n\\n        for i in range(m):\\n            count = 0\\n            for j in range(n):\\n                if mat[i][j] == 1:\\n                    count +=1\\n\\n                    if count > maxcount:\\n                        maxcount = count\\n                        index = i\\n        return [index,maxcount]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894967,
                "title": "python3-solution-everything-explained-line-by-line-both-time-and-space-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        #Both time (828ms beats 94%) and memory (16.73mb beats 92.38%) effiecent\\n        max_ones = 0\\n        ans = []\\n        i = 0     # a variable to trace the index we are at.\\n        for lst in mat:\\n            lst_sum = sum(lst)\\n            if max_ones <= lst_sum:\\n                max_ones =  lst_sum\\n                ans.append([i,lst_sum])\\n            i+=1\\n        num_once  = []\\n        final_ans  = []\\n        #the following code block ensures the row with the smallest row number is selected. \\n        for i in range(len(ans)):\\n            if ans[i][-1] not in num_once:\\n                num_once.append(ans[i][-1])\\n                final_ans.append(ans[i])\\n           \\n        return final_ans[-1] # Since, the one which is lastly selected, for sure contains max_ones \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        #Both time (828ms beats 94%) and memory (16.73mb beats 92.38%) effiecent\\n        max_ones = 0\\n        ans = []\\n        i = 0     # a variable to trace the index we are at.\\n        for lst in mat:\\n            lst_sum = sum(lst)\\n            if max_ones <= lst_sum:\\n                max_ones =  lst_sum\\n                ans.append([i,lst_sum])\\n            i+=1\\n        num_once  = []\\n        final_ans  = []\\n        #the following code block ensures the row with the smallest row number is selected. \\n        for i in range(len(ans)):\\n            if ans[i][-1] not in num_once:\\n                num_once.append(ans[i][-1])\\n                final_ans.append(ans[i])\\n           \\n        return final_ans[-1] # Since, the one which is lastly selected, for sure contains max_ones \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885537,
                "title": "simple-and-easy-java-soulution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int max=0,ind=0;\\n        for(int i=0;i<m;i++){\\n            int c=0;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    c++;\\n                }\\n            }\\n            if(max<c){\\n                ind=i;\\n                max=c;\\n            }\\n        }\\n        return new int[]{ind,max};\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int max=0,ind=0;\\n        for(int i=0;i<m;i++){\\n            int c=0;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    c++;\\n                }\\n            }\\n            if(max<c){\\n                ind=i;\\n                max=c;\\n            }\\n        }\\n        return new int[]{ind,max};\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884509,
                "title": "rust-solution-easy-to-understand",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let (mut row_number, mut ones) = (0, 0);\\n        for (index, row) in mat.iter().enumerate() {\\n            let local_ones = row.iter().filter(|&&x| x == 1).count();\\n            if index == 0 {\\n                ones = local_ones;\\n                continue;\\n            }\\n            if local_ones > ones {\\n                row_number = index;\\n                ones = local_ones;\\n            }\\n        }\\n        vec![row_number as i32, ones as i32]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let (mut row_number, mut ones) = (0, 0);\\n        for (index, row) in mat.iter().enumerate() {\\n            let local_ones = row.iter().filter(|&&x| x == 1).count();\\n            if index == 0 {\\n                ones = local_ones;\\n                continue;\\n            }\\n            if local_ones > ones {\\n                row_number = index;\\n                ones = local_ones;\\n            }\\n        }\\n        vec![row_number as i32, ones as i32]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880237,
                "title": "swift-simple-solution-for-newbie",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func rowAndMaximumOnes(_ mat: [[Int]]) -> [Int] { \\n    var answer = [0,0]\\n\\n    for i in 0..<mat.count {\\n        let a = mat[i].reduce(0) {$0 + $1}\\n        if a > answer[1] {\\n            answer[1] = a\\n            answer[0] = i\\n        }\\n    }\\n\\n    return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func rowAndMaximumOnes(_ mat: [[Int]]) -> [Int] { \\n    var answer = [0,0]\\n\\n    for i in 0..<mat.count {\\n        let a = mat[i].reduce(0) {$0 + $1}\\n        if a > answer[1] {\\n            answer[1] = a\\n            answer[0] = i\\n        }\\n    }\\n\\n    return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877382,
                "title": "100-efficiant-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int count;\\n        int ans=0;\\n        int row=0;\\n        for(int i=0; i<mat.size(); i++)\\n        {\\n            count=0;\\n            for(int j=0; j<mat[0].size(); j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if (count>ans) \\n            {\\n                ans = count;\\n                row = i;\\n            }\\n        }\\n        return {row,ans};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int count;\\n        int ans=0;\\n        int row=0;\\n        for(int i=0; i<mat.size(); i++)\\n        {\\n            count=0;\\n            for(int j=0; j<mat[0].size(); j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if (count>ans) \\n            {\\n                ans = count;\\n                row = i;\\n            }\\n        }\\n        return {row,ans};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877021,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] ans = {0,0};\\n        int max  = 0, idx = 0;\\n        for(int i=0; i<mat.length; i++){\\n            int count = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n                if(count > max){\\n                    max  = count;\\n                    idx = i;\\n                }\\n            } \\n        }\\n        ans[0] = idx;\\n        ans[1] =  max;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] ans = {0,0};\\n        int max  = 0, idx = 0;\\n        for(int i=0; i<mat.length; i++){\\n            int count = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n                if(count > max){\\n                    max  = count;\\n                    idx = i;\\n                }\\n            } \\n        }\\n        ans[0] = idx;\\n        ans[1] =  max;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876131,
                "title": "java-clear-solution",
                "content": "\\n# Complexity\\n- Time complexity: *O(m * n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(1)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] result = new int[2];\\n        int n = mat.length, \\n            m = mat[0].length,\\n            max = 0,\\n            tem = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            tem = 0;\\n            for(int j = 0; j < m; j++)\\n               if(mat[i][j] == 1) tem ++;\\n            \\n            if(tem > max){\\n                max = tem;\\n                result[0] = i;\\n                result[1] = max;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] result = new int[2];\\n        int n = mat.length, \\n            m = mat[0].length,\\n            max = 0,\\n            tem = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            tem = 0;\\n            for(int j = 0; j < m; j++)\\n               if(mat[i][j] == 1) tem ++;\\n            \\n            if(tem > max){\\n                max = tem;\\n                result[0] = i;\\n                result[1] = max;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874937,
                "title": "easy-solution-in-c-beats-93",
                "content": "# Intuition\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ma=0;\\n        int mi=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    c++;\\n                }\\n            }\\n            if(ma<c && c!=0){\\n                ma=c;\\n                if(mi<i){\\n                    mi=i;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        ans.push_back(mi);\\n        ans.push_back(ma);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ma=0;\\n        int mi=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    c++;\\n                }\\n            }\\n            if(ma<c && c!=0){\\n                ma=c;\\n                if(mi<i){\\n                    mi=i;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        ans.push_back(mi);\\n        ans.push_back(ma);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873695,
                "title": "to-find-maximum-ones-in-2d-array-and-output-contains-index-of-maximum-ones-and-count-of-ones",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int counter[] = new int[mat.length];\\n\\n//the below code to find the ones in the 2D array\\n        for(int i =0; i<mat.length; i++){\\n            for(int j = 0; j< mat[0].length; j++){\\n                if(mat[i][j] == 1){\\n                    counter[i]++;\\n                }\\n            }\\n        }\\n\\n        int finalCount =Integer.MIN_VALUE; //to store minus infinity\\n       int m =0;\\n        for(int i = counter.length-1;i >= 0;i--){\\n            if(counter[i] >= finalCount){\\n                finalCount = counter[i];\\n                m = i;\\n            }\\n        }\\n     //  int max = finalCount;\\n       //int index = m;\\n        int con[] ={m,finalCount};\\n    return con;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int counter[] = new int[mat.length];\\n\\n//the below code to find the ones in the 2D array\\n        for(int i =0; i<mat.length; i++){\\n            for(int j = 0; j< mat[0].length; j++){\\n                if(mat[i][j] == 1){\\n                    counter[i]++;\\n                }\\n            }\\n        }\\n\\n        int finalCount =Integer.MIN_VALUE; //to store minus infinity\\n       int m =0;\\n        for(int i = counter.length-1;i >= 0;i--){\\n            if(counter[i] >= finalCount){\\n                finalCount = counter[i];\\n                m = i;\\n            }\\n        }\\n     //  int max = finalCount;\\n       //int index = m;\\n        int con[] ={m,finalCount};\\n    return con;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870704,
                "title": "solution-with-enu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, float(\"-inf\")]\\n        for i, v in enumerate(mat):\\n            if res[1] < (s:=sum(v)):\\n                res[1] = s\\n                res[0] = i\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, float(\"-inf\")]\\n        for i, v in enumerate(mat):\\n            if res[1] < (s:=sum(v)):\\n                res[1] = s\\n                res[0] = i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868524,
                "title": "simple-iterative-decision",
                "content": "## Code\\n![image.png](https://assets.leetcode.com/users/images/83391be2-74af-480c-bf4a-f1805a847370_1691256904.8159122.png)\\n\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        result = [0,0]\\n        for idx, row in enumerate(mat):\\n            s = sum(row)\\n            if s > result[1]:\\n                result = [idx, s]\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        result = [0,0]\\n        for idx, row in enumerate(mat):\\n            s = sum(row)\\n            if s > result[1]:\\n                result = [idx, s]\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864083,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n          int rows=mat.length;\\n          int cols=mat[0].length;\\n          \\n          int ans[]=new int[2];\\n          int idx=0;\\n          int count=Integer.MIN_VALUE;\\n\\n          for(int i=0; i<rows; i++)\\n          {\\n                 int cnt=0;\\n             for(int j=0; j<cols; j++)\\n             {\\n                 if(mat[i][j]==1)\\n                 {\\n                   cnt++;\\n                 }\\n             }\\n             if(cnt>count)\\n             {\\n                 count=cnt;\\n                 idx=i;\\n             }\\n          }\\n          ans[0]=idx;\\n          ans[1]=count;\\n\\n          return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n          int rows=mat.length;\\n          int cols=mat[0].length;\\n          \\n          int ans[]=new int[2];\\n          int idx=0;\\n          int count=Integer.MIN_VALUE;\\n\\n          for(int i=0; i<rows; i++)\\n          {\\n                 int cnt=0;\\n             for(int j=0; j<cols; j++)\\n             {\\n                 if(mat[i][j]==1)\\n                 {\\n                   cnt++;\\n                 }\\n             }\\n             if(cnt>count)\\n             {\\n                 count=cnt;\\n                 idx=i;\\n             }\\n          }\\n          ans[0]=idx;\\n          ans[1]=count;\\n\\n          return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857580,
                "title": "the-realworld-solution-for-java",
                "content": "# Intuition\\nThinking about the solution\\n\\n# Approach\\nWriting the solution\\n\\n# Complexity\\n- Time complexity:\\n\\u044F \\u0434\\u0443\\u043C\\u0430\\u044E \\u0448\\u043E \\u041E(n)\\n\\n- Space complexity:\\n\\u043D\\u0435 \\u041E(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = 0;\\n        int index = 0;\\n\\n        for(int i = 0; i < mat.length; i++) {\\n            int count = 0;\\n\\n            for(int j = 0; j < mat[i].length; j++) {\\n                if(mat[i][j] == 1) count++;\\n            }\\n\\n            if(count > max) index = i;\\n            max = Math.max(max, count);\\n        }\\n\\n        int[] RealWorld = new int[] {index, max};\\n\\n        return RealWorld;\\n    }\\n}\\n```\\n\\nUpvote if you want Andrew Tate to be free :)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Counting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = 0;\\n        int index = 0;\\n\\n        for(int i = 0; i < mat.length; i++) {\\n            int count = 0;\\n\\n            for(int j = 0; j < mat[i].length; j++) {\\n                if(mat[i][j] == 1) count++;\\n            }\\n\\n            if(count > max) index = i;\\n            max = Math.max(max, count);\\n        }\\n\\n        int[] RealWorld = new int[] {index, max};\\n\\n        return RealWorld;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854102,
                "title": "python-beginner-s-friendly-solution-think-easiest-way",
                "content": "I think the code is not like pythonic. But here is my simple solution.\\nPlease any advice me. It would be help.\\nThanks for reading. :)\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        max_cnt = 0\\n        answer = []\\n        for i in range(len(mat)):\\n            if mat[i].count(1) > max_cnt:\\n                answer = []\\n                max_cnt = mat[i].count(1)\\n                answer.append(i)\\n                answer.append(max_cnt)\\n        if max_cnt == 0:\\n            answer.append(0)\\n            answer.append(0)\\n        return answer\\n        \\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        max_cnt = 0\\n        answer = []\\n        for i in range(len(mat)):\\n            if mat[i].count(1) > max_cnt:\\n                answer = []\\n                max_cnt = mat[i].count(1)\\n                answer.append(i)\\n                answer.append(max_cnt)\\n        if max_cnt == 0:\\n            answer.append(0)\\n            answer.append(0)\\n        return answer\\n        \\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851496,
                "title": "easy-understandable",
                "content": "\\n# Complexity\\n- Time complexity: O (m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int sz = mat.size();\\n        int szin = mat[0].size();\\n\\n        int cntofone = 0;\\n        int idx = 0;\\n\\n        for(int i = 0; i < sz; i++){\\n            int cnt = 0;\\n            for(int j = 0; j <szin ; j++){\\n\\n                if(mat[i][j]==1)cnt++;\\n\\n            }\\n\\n            if(cntofone < cnt){\\n                cntofone = cnt;\\n                idx = i;\\n            }\\n        }\\n        vector<int>result = {idx, cntofone};\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int sz = mat.size();\\n        int szin = mat[0].size();\\n\\n        int cntofone = 0;\\n        int idx = 0;\\n\\n        for(int i = 0; i < sz; i++){\\n            int cnt = 0;\\n            for(int j = 0; j <szin ; j++){\\n\\n                if(mat[i][j]==1)cnt++;\\n\\n            }\\n\\n            if(cntofone < cnt){\\n                cntofone = cnt;\\n                idx = i;\\n            }\\n        }\\n        vector<int>result = {idx, cntofone};\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1865174,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Perfect way  to start your day with this easy beautiful problem"
                    },
                    {
                        "username": "shahil3303",
                        "content": "simple solution\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain one way to do it in great length, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/row-with-maximum-ones/solutions/3422198/how-about-a-python-one-liner-detailed-begginer-friendly-explanations/)"
                    }
                ]
            },
            {
                "id": 1869530,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Perfect way  to start your day with this easy beautiful problem"
                    },
                    {
                        "username": "shahil3303",
                        "content": "simple solution\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain one way to do it in great length, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/row-with-maximum-ones/solutions/3422198/how-about-a-python-one-liner-detailed-begginer-friendly-explanations/)"
                    }
                ]
            },
            {
                "id": 1865186,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Perfect way  to start your day with this easy beautiful problem"
                    },
                    {
                        "username": "shahil3303",
                        "content": "simple solution\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain one way to do it in great length, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/row-with-maximum-ones/solutions/3422198/how-about-a-python-one-liner-detailed-begginer-friendly-explanations/)"
                    }
                ]
            }
        ]
    }
]