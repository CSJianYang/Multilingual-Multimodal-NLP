[
    {
        "title": "Last Stone Weight",
        "question_content": "You are given an array of integers stones where stones[i] is the weight of the ith stone.\nWe are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\n\n\tIf x == y, both stones are destroyed, and\n\tIf x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\n\nAt the end of the game, there is at most one stone left.\nReturn the weight of the last remaining stone. If there are no stones left, return 0.\n&nbsp;\nExample 1:\n\nInput: stones = [2,7,4,1,8,1]\nOutput: 1\nExplanation: \nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\n\nExample 2:\n\nInput: stones = [1]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= stones.length <= 30\n\t1 <= stones[i] <= 1000",
        "solutions": [
            {
                "id": 294956,
                "title": "java-c-python-priority-queue",
                "content": "# **Explanation**\\nPut all elements into a priority queue.\\nPop out the two biggest, push back the difference,\\nuntil there are no more two elements left.\\n<br>\\n\\n# **Complexity**\\nTime `O(NlogN)`\\nSpace `O(N)`\\n<br>\\n\\n**Java, PriorityQueue**\\n```java\\n    public int lastStoneWeight(int[] A) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)-> b - a);\\n        for (int a : A)\\n            pq.offer(a);\\n        while (pq.size() > 1)\\n            pq.offer(pq.poll() - pq.poll());\\n        return pq.poll();\\n    }\\n```\\n\\n**C++, priority_queue**\\n```cpp\\n    int lastStoneWeight(vector<int>& A) {\\n        priority_queue<int> pq(begin(A), end(A));\\n        while (pq.size() > 1) {\\n            int x = pq.top(); pq.pop();\\n            int y = pq.top(); pq.pop();\\n            if (x > y) pq.push(x - y);\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n```\\n**Python, using heap, O(NlogN) time**\\n```py\\n    def lastStoneWeight(self, A):\\n        h = [-x for x in A]\\n        heapq.heapify(h)\\n        while len(h) > 1 and h[0] != 0:\\n            heapq.heappush(h, heapq.heappop(h) - heapq.heappop(h))\\n        return -h[0]\\n```\\n\\n**Python, using binary insort, O(N^2) time**\\n```py\\n    def lastStoneWeight(self, A):\\n        A.sort()\\n        while len(A) > 1:\\n            bisect.insort(A, A.pop() - A.pop())\\n        return A[0]\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int lastStoneWeight(int[] A) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)-> b - a);\\n        for (int a : A)\\n            pq.offer(a);\\n        while (pq.size() > 1)\\n            pq.offer(pq.poll() - pq.poll());\\n        return pq.poll();\\n    }\\n```\n```cpp\\n    int lastStoneWeight(vector<int>& A) {\\n        priority_queue<int> pq(begin(A), end(A));\\n        while (pq.size() > 1) {\\n            int x = pq.top(); pq.pop();\\n            int y = pq.top(); pq.pop();\\n            if (x > y) pq.push(x - y);\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n```\n```py\\n    def lastStoneWeight(self, A):\\n        h = [-x for x in A]\\n        heapq.heapify(h)\\n        while len(h) > 1 and h[0] != 0:\\n            heapq.heappush(h, heapq.heappop(h) - heapq.heappop(h))\\n        return -h[0]\\n```\n```py\\n    def lastStoneWeight(self, A):\\n        A.sort()\\n        while len(A) > 1:\\n            bisect.insort(A, A.pop() - A.pop())\\n        return A[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1921100,
                "title": "simple-easy-c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/fc5f29d9-7e2e-4f5b-a3d9-2c5654652b76_1649292145.9654834.png)\\n\\n```\\n int lastStoneWeight(vector<int>& stones) \\n    {\\n        priority_queue<int> pq(stones.begin(),stones.end());\\n        while(pq.size()>1)\\n        {\\n            int y=pq.top();\\n            pq.pop();\\n            int x=pq.top();\\n            pq.pop();\\n            if(x!=y) pq.push(y-x);\\n        }\\n        return pq.empty()? 0 : pq.top();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int lastStoneWeight(vector<int>& stones) \\n    {\\n        priority_queue<int> pq(stones.begin(),stones.end());\\n        while(pq.size()>1)\\n        {\\n            int y=pq.top();\\n            pq.pop();\\n            int x=pq.top();\\n            pq.pop();\\n            if(x!=y) pq.push(y-x);\\n        }\\n        return pq.empty()? 0 : pq.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921241,
                "title": "python-beginner-friendly-optimisation-process-with-explanation",
                "content": "### Introduction\\n\\nGiven an array of stones `stones`, we repeatedly \"smash\" (i.e., compare) the two heaviest stones together until there is at most one stone left. If the two heaviest stones are of the same weight, both stones are \"destroyed\" (i.e., both weights become 0), otherwise, a stone with the absolute weight difference of both stones will remain.\\n\\nNote that the order in which the stones are \"smashed\" needs to be followed strictly. Otherwise, we will not end up with the correct weight of the remaining stone, if any.\\n\\n```text\\narr = [2, 7, 4, 1, 8, 1]\\n\\nCORRECT METHOD\\n1) Smash 8 and 7 -> arr = [2, 4, 1, 1, 1]\\n2) Smash 4 and 2 -> arr = [2, 1, 1, 1]\\n3) Smash 2 and 1 -> arr = [1, 1, 1]\\n4) Smash 1 and 1 -> arr = [1]\\n\\nWRONG METHOD #1 (according to index ordering)\\n1) Smash 2 and 7 -> arr = [5, 4, 1, 8, 1]\\n2) Smash 5 and 4 -> arr = [1, 1, 8, 1]\\n3) Smash 1 and 1 -> arr = [8, 1]\\n4) Smash 8 and 1 -> arr = [7]\\n\\nWRONG METHOD #2 (in ascending order)\\n1) Smash 1 and 1 -> arr = [2, 7, 4, 8]\\n2) Smash 2 and 4 -> arr = [2, 7, 8]\\n3) Smash 2 and 7 -> arr = [5, 8]\\n4) Smash 5 and 8 -> arr = [3]\\n```\\n\\n---\\n\\n### Base Approach - Sort and Insert\\n\\nSince we are required to \"smash\" the two heaviest stones, we need to know which two stones are the heaviest, and for all iterations. As such, we will first have to sort the stones in order by weight in order to compare the two heaviest stones.\\n\\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # we need to insert the remaining stone (s1-s2) into the list\\n                pass\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\\n\\nAll that remains now is how we can insert the stone from the \"smashing\" of the two heaviest stones back into `stones`. The simplest method is to loop through `stones` and insert the stone in the correct index.\\n\\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # the remaining stone will be s1-s2\\n                # loop through stones to find the index to insert the stone\\n                for i in range(len(stones)+1):\\n                    if i == len(stones) or stones[i] >= s1-s2:\\n                        stones.insert(i, s1-s2)\\n                        break\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\\n\\n**TC: O(n<sup>2</sup>)**, where `n` is the length of `stones`, due to the nested inserts.\\n**SC: O(1)**, no additonal data structures are used.\\n\\n---\\n\\n### Slight Optimisation - Binary Search Insert\\n\\nAn \"optimisation\" from the above method to find the index to insert the remaining stone is to binary search for the index to insert to instead of looping through `stones` manually. This involves Python\\'s [bisect library](https://docs.python.org/3/library/bisect.html) which has a pre-written function to help us do just that.\\n\\nNote that we only need to change one portion of the code; the remaining code logic is the same.\\n\\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # the remaining stone will be s1-s2\\n                # binary-insert the remaining stone into stones\\n                insort_left(stones, s1-s2)\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\\n\\n**TC: O(n<sup>2</sup>)**. Even though binary searching for the index to insert to takes O(logn) time, the insert function alone takes O(n) time because it needs to shift all the elements after the index to the right by 1. As such, the overall time complexity for `insort_left()` is O(n).\\n**SC: O(1)**, as discussed above.\\n\\n---\\n\\n### Data Structure - Heap Implementation\\n\\nUnfortunately, due to the implementation of the list data structure, even the binary search optimisation cannot break free of the O(n) insert. If only there was a data structure that could help us sort and insert automatically without having to rely on a heavier insert function...\\n\\nPython has an in-built [heap library](https://docs.python.org/3/library/heapq.html) that is perfect for this task. Essentially, all we need to do is insert the elements, and the heap will settle the sorting order for us. Unfortunately, Python\\'s heap library implements a min-heap instead of a max-heap, whereby popping will give us the lightest stone instead of the heaviest stone.\\n\\nA standard (very common!) workaround is to **negate all the weight values of the stones**. This way, the heaviest stone has the most negative value, and hence becomes the smallest value in the heap. Then, all we have to do after obtaining the value from the heap is to un-negate the value to use it in our calculations.\\n\\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        # first, negate all weight values in-place\\n        for i, s in enumerate(stones):\\n            stones[i] = -s\\n        heapify(stones)  # pass all negated values into the min-heap\\n        while stones:\\n            s1 = -heappop(stones)  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = -heappop(stones)  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                heappush(stones, s2-s1)  # push the NEGATED value of s1-s2; i.e., s2-s1\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\\n\\n**TC: O(nlogn)**; `heappush()` and `heappop()` both have O(logn) time complexity, and are both nested in the while loop. Note: `heapify()` runs in O(n) time, hence the time complexity is not affected.\\n**SC: O(1)**; both the negation and the heapify are done in-place.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```text\\narr = [2, 7, 4, 1, 8, 1]\\n\\nCORRECT METHOD\\n1) Smash 8 and 7 -> arr = [2, 4, 1, 1, 1]\\n2) Smash 4 and 2 -> arr = [2, 1, 1, 1]\\n3) Smash 2 and 1 -> arr = [1, 1, 1]\\n4) Smash 1 and 1 -> arr = [1]\\n\\nWRONG METHOD #1 (according to index ordering)\\n1) Smash 2 and 7 -> arr = [5, 4, 1, 8, 1]\\n2) Smash 5 and 4 -> arr = [1, 1, 8, 1]\\n3) Smash 1 and 1 -> arr = [8, 1]\\n4) Smash 8 and 1 -> arr = [7]\\n\\nWRONG METHOD #2 (in ascending order)\\n1) Smash 1 and 1 -> arr = [2, 7, 4, 8]\\n2) Smash 2 and 4 -> arr = [2, 7, 8]\\n3) Smash 2 and 7 -> arr = [5, 8]\\n4) Smash 5 and 8 -> arr = [3]\\n```\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # we need to insert the remaining stone (s1-s2) into the list\\n                pass\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # the remaining stone will be s1-s2\\n                # loop through stones to find the index to insert the stone\\n                for i in range(len(stones)+1):\\n                    if i == len(stones) or stones[i] >= s1-s2:\\n                        stones.insert(i, s1-s2)\\n                        break\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # the remaining stone will be s1-s2\\n                # binary-insert the remaining stone into stones\\n                insort_left(stones, s1-s2)\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        # first, negate all weight values in-place\\n        for i, s in enumerate(stones):\\n            stones[i] = -s\\n        heapify(stones)  # pass all negated values into the min-heap\\n        while stones:\\n            s1 = -heappop(stones)  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = -heappop(stones)  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                heappush(stones, s2-s1)  # push the NEGATED value of s1-s2; i.e., s2-s1\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448875,
                "title": "c-explained-easy-solution-priority-queue",
                "content": "# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Intuition\\n- #### To solve this problem, we can use a priority queue to keep track of the heaviest stones. \\n- #### At each turn, we can pop the two heaviest stones from the heap, smash them together according to the given rules, and then push the resulting stone (if any) back onto the heap. \\n- #### We repeat this process until there is at most one stone left in the heap.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- #### In this code, we first create the priority queue by negating the values of the stones. \\n- #### We then loop until there is at most one stone left in the heap. Inside the loop, we pop the two heaviest stones from the queue and check whether they are equal or not.\\n    1. #### If they are not equal, we calculate the weight of the resulting stone and push it back onto the Queue (priority queue heapify itself after every push operation).\\n- #### Finally, we return the weight of the last remaining stone (or 0 if there are no stones left).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& a) {\\n        priority_queue<int>pq(a.begin(),a.end());\\n\\n        while(pq.size() > 1)\\n        {\\n            int a = pq.top();\\n            pq.pop();\\n            int b = pq.top();\\n            pq.pop();\\n\\n            if(a != b)\\n                pq.push(abs(a-b));\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/8044a3f7-5e30-4954-bb50-1485656ecab5_1682302010.1464121.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& a) {\\n        priority_queue<int>pq(a.begin(),a.end());\\n\\n        while(pq.size() > 1)\\n        {\\n            int a = pq.top();\\n            pq.pop();\\n            int b = pq.top();\\n            pq.pop();\\n\\n            if(a != b)\\n                pq.push(abs(a-b));\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575674,
                "title": "java-simple-to-complex-solutions-explained-0-ms-top-100-time-100-memory-2-lines-of-code-only",
                "content": "At every step of the algorithm, we need to know the top heaviest stone.\\nThe most efficient way to retrieve the max for large input sizes is to use a max heap, which in Java is a PriorityQueue (min heap) with a reverse comparator:\\n\\nO(n log (n)) time O(n) space \\n1 ms time 37.5 MB space\\n91% time 100% space\\n\\n```\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i : stones) {\\n            queue.add(i);\\n        }\\n        int x;\\n        int y;\\n        while(queue.size() > 1) {\\n            y = queue.poll();\\n            x = queue.poll();\\n            if(y > x) {\\n                queue.offer(y-x);   \\n            }\\n        }\\n        return queue.isEmpty() ? 0 : queue.poll();\\n    }\\n```\\n\\nBut we can do better, right? If you have done a few of these problems you might know to use BucketSort with has constant access and no typical \"sorting\", we can do O(n) time. \\n\\nHowever, it is more accurate to say the time would be O(n + maxStoneWeight) because we will build a bucket for every possible weight. And usually a O(n + 1000) would be a great solution, but the test cases here have a very short input size. the number of stones goes only from 0 to 30, so this solution actually performs worse than O(n) since n is at most 30! O(30) == O(1030) but 30 < 1030. Both have the same complexity, but the first runs faster, and you might have not noticed why unless you check the inputs given in the tests.\\n\\n```\\n    int[] buckets = new int[1001];\\n    for(int stone: stones)\\n      buckets[stone]++;\\n    int i = 1000;\\n    int j;\\n    while(i > 0) {\\n      if(buckets[i] == 0) {\\n        i--;\\n      } else {\\n        buckets[i] = buckets[i] % 2;\\n        if(buckets[i] != 0) {\\n          j = i-1;\\n          while(j > 0 && buckets[j] == 0)\\n            j--;\\n          if(j == 0)\\n            return i;\\n          buckets[i - j]++;\\n          buckets[j]--;\\n          i--;\\n        }\\n      }\\n    }\\n    return 0;\\n```\\n\\nRuns even slower! Remember to not always apply a solution that seems faster because you didn\\'t consider your context or use cases. here the number of stones is much smaller than the weight of the stones.\\n\\nSo if we know that the number of stones is quite small, can we do even better than the PriorityQueue? What is a very fast sorting algorithm for small sets, better than building a heap? Sort in place in the array! Don\\'t waste time building new objects or copies of the input.\\n\\nO( n^2 log(n) ) because for every stone n, we sort the array O(nlog(n))\\nO(1) space, no extra space, sort in place\\n**0 ms time 36.9 MB\\tspace\\nfaster than 100% and less space used than 100% of other solutions**\\n\\n```\\n  public static int lastStoneWeight(int[] stones) {\\n    Arrays.sort(stones);\\n    for(int i=stones.length-1; i>0; i--) {\\n      stones[i-1] = stones[i] - stones[i-1];\\n      Arrays.sort(stones);\\n    }\\n    return stones[0];\\n  }\\n```\\n\\nAnd just for fun, let\\'s mangle it into **2 lines**:\\n```\\n    for(int i=stones.length; i>0; stones[i-1] = i==stones.length? stones[i-1] : stones[i] - stones[i-1], Arrays.sort(stones), i--);\\n    return stones[0];\\n```\\n\\nEDIT: \\nTo be completely clear, if the input size was unrestricted and not less than 30 stones, BucketSort would be the best solution because it runs in O(maxStoneWeight). If the stones weight is not unrestricted, then BucketSort cannot work as you would need 2,147,483,647 buckets. In that case, PriorityQueue would be the best solution.\\n\\n**In an interview, you should only discuss either BucketSort or PriorityQueue (max head) solutions**. The only reason I mentioned the sorting solution, which is much worse than the two other solutions, is because the input size in the tests of this challenge are so small that this solution is faster.",
                "solutionTags": [],
                "code": "```\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i : stones) {\\n            queue.add(i);\\n        }\\n        int x;\\n        int y;\\n        while(queue.size() > 1) {\\n            y = queue.poll();\\n            x = queue.poll();\\n            if(y > x) {\\n                queue.offer(y-x);   \\n            }\\n        }\\n        return queue.isEmpty() ? 0 : queue.poll();\\n    }\\n```\n```\\n    int[] buckets = new int[1001];\\n    for(int stone: stones)\\n      buckets[stone]++;\\n    int i = 1000;\\n    int j;\\n    while(i > 0) {\\n      if(buckets[i] == 0) {\\n        i--;\\n      } else {\\n        buckets[i] = buckets[i] % 2;\\n        if(buckets[i] != 0) {\\n          j = i-1;\\n          while(j > 0 && buckets[j] == 0)\\n            j--;\\n          if(j == 0)\\n            return i;\\n          buckets[i - j]++;\\n          buckets[j]--;\\n          i--;\\n        }\\n      }\\n    }\\n    return 0;\\n```\n```\\n  public static int lastStoneWeight(int[] stones) {\\n    Arrays.sort(stones);\\n    for(int i=stones.length-1; i>0; i--) {\\n      stones[i-1] = stones[i] - stones[i-1];\\n      Arrays.sort(stones);\\n    }\\n    return stones[0];\\n  }\\n```\n```\\n    for(int i=stones.length; i>0; stones[i-1] = i==stones.length? stones[i-1] : stones[i] - stones[i-1], Arrays.sort(stones), i--);\\n    return stones[0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921254,
                "title": "a-solid-explanation",
                "content": "How\\'s going Ladies - n - Gentlemen, today we are going to solve another coolest problem i.e. **Last Stone Weight** \\n\\nOkay, so first of all let\\'s understand the problem\\n\\n**We have 2 stones x & y**\\n\\n![image](https://assets.leetcode.com/users/images/e062b588-f311-49ea-9aa0-c19e720eb38a_1649295151.330421.png)\\n\\nAnd There could be 2 Possiblities :\\n* If both the stones x & y have same weight, then **` x == y, both stones are destroyed`**\\n\\n\\n* If they are not equal, then stone y always be greater then stone x, therefore **`x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.`** \\n\\n```\\nAt the end of the game, there is at most one stone left.\\n\\nReturn the smallest possible weight of the left stone. If there are no stones left, return 0.\\n```\\n\\nI hope problem statement is absolute clear, now let\\'s talk about how we gonna solve this problem.\\n\\n**Let\\'s take an example,**\\n\\n**Input**: stones = [2,7,4,1,8,1]\\n**Output**: 1\\n\\nThe very Brute force Idea came in our mind is, why don;t we just sort that array, such that we will have bigger values in the end, and to maintain that highest value in the end, we always gonna sort them once both of the stones will collide. \\n\\nWhat I mean is, let\\'s take our input array:\\n```\\n[2,7,4,1,8,1]\\n\\nLet\\'s sort it:\\n\\n[1,1,2,4,7,8]\\n```\\n\\nNow what we gonna do is, collide the 2 stones and get their difference i.e. `y - x`\\n```\\n[1,1,2,4,7,8]  -->  y = 8      &      x = 7\\n\\nThus,\\ny - x    -->  8 - 7 = 1\\n```\\nNow we gonna put that one in our array & maintain the order by sorting it back again\\n```\\n[1,1,2,4]          add => 1   in our array\\n\\n[1,1,2,4,1]          now again sort it,\\n\\n[1,1,1,2,4]\\n```\\nSo, we gonna perform the same step for all. Well it\\'s not a great approach to go with, as our Time Complexity will be much higher.\\n\\nLet\\'s code it up, then we gonna analysis it\\'s space & time complexity:-\\n\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        \\n        for(int i = stones.length - 1; i > 0; i--){\\n            stones[i - 1] = stones[i] - stones[i - 1];\\n            Arrays.sort(stones);\\n        }\\n        return stones[0];\\n    }\\n}\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(NlogN) * BigO(N) => BigO(N^2logN)\\n\\n* **Space Complexity :-** BigO(1)\\n\\nWell, now you say. Dude, let;s optimise it. \\nYes, we just goona do that stuff now!!\\n```\\nFor Optimising it, we gonna use the help of Heap\\n```\\n\\nOkay, so we gonna take the same example & now you\\'ll ask which heap do we have to use??\\n**minHeap OR maxHeap??**\\n\\nAs, you can see we want highest value at the first & lowest value in the last. So, we gonna use **maxHeap**\\n\\nLet\\'s create our maxHeap and use the same example i.e. **`[2,7,4,1,8,1]`** to fill our heap.\\n\\nSo, our first job is, let\\'s fill our heap.\\n```\\n                Array           [2,7,4,1,8,1]\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|     |\\n|     |\\n--------\\nmaxHeap\\n```\\n\\nNow let\\'s fill our heap,\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                 ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|     |\\n|  2  |\\n--------\\nmaxHeap\\n```\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                   ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|  7  |\\n|  2  |\\n--------\\nmaxHeap\\n```\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                     ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|  7  |\\n|  4  |\\n|  2  |\\n--------\\nmaxHeap\\n```\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                       ^\\n|     |\\n|\\t  |\\t\\t\\n|  7  |  \\n|  4  |\\n|  2  |\\n|  1  |\\n--------\\nmaxHeap\\n```\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                         ^\\n|     |\\n|  8  |\\t\\t\\n|  7  |  \\n|  4  |\\n|  2  |\\n|  1  |\\n--------\\nmaxHeap\\n```\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           ^\\n|  8  |\\n|  7  |\\t\\t\\n|  4  |  \\n|  2  |\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\\n\\nNow it\\'s time to get the stone x & y using our heap & after calculating **`y - x`** put the new difference in our stack\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           \\n|     |         y = 8\\n|     |\\t\\t    x = 7\\n|  4  |      \\n|  2  |         and their result will be y - x => 8 - 7 = 1\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\\nNow put that **1** into our heap & again calculate the result of stone x & y\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           \\n|     |         y = 4\\n|     |\\t\\t    x = 2\\n|     |      \\n|  1  |         and their result will be y - x => 4 - 2 = 2\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\\nSo, we gonna perform the same step until & unless only 1 elemnent left in our stack.\\n\\nI hope so, ladies - n - gentlemen, approach is absolute clear, **then let\\'s code it up:**\\n\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int v : stones){\\n            maxHeap.offer(v);\\n        }\\n        int x;\\n        int y;\\n        while(maxHeap.size() > 1){\\n            y = maxHeap.poll();\\n            x = maxHeap.poll();\\n            if(y > x){\\n                maxHeap.offer(y - x);\\n            }\\n        }\\n        if(maxHeap.size() == 0) return 0;\\n        return maxHeap.poll();\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(NlogN)\\n\\n* **Space Complexity :-** BigO(N)\\n```\\nTime Complexity Explanation\\'s may be still if I\\'m wrong, correct me then, THANKS <^^>\\n```\\n\\n*Heap is a specialized tree-based data structure* that is essentially almost *complete binary tree.* There are so many operations possible with **max and min heaps like -**\\n\\n`insert(), delete(), update(), findMinElement(), findMaxElement(), etc`\\n\\nAnd time complexity depends on the operation you perform on the heap.\\n\\n**`Heap Sort has O(nlog n) time complexities for all the cases ( best case, average case, and worst case).`**\\n\\n**Let us understand the reason why.** The height of a complete binary tree containing n elements is **log n**\\n\\nIn the worst case scenario, we will need to move an element from the root to the leaf node making a multiple of **log(n)** comparisons and swaps.\\n\\nDuring the `build_max_heap` stage, we do that for **n/2** elements so the worst case complexity of the `build_heap` step is **n/2xlog n ~ nlog n**.\\n\\nDuring the sorting step, we exchange the root element with the last element and heapify the root element. For each element, this again takes **log n** worst time because we might have to bring the element all the way from the root to the leaf. Since we repeat this n times, the `heap_sort` step is also **nlog n.**\\n\\nAlso since the `build_max_heap` and `heap_sort` steps are executed one after another, the algorithmic complexity is not multiplied and it remains in the order of **nlog n**.",
                "solutionTags": [],
                "code": "```\\nAt the end of the game, there is at most one stone left.\\n\\nReturn the smallest possible weight of the left stone. If there are no stones left, return 0.\\n```\n```\\n[2,7,4,1,8,1]\\n\\nLet\\'s sort it:\\n\\n[1,1,2,4,7,8]\\n```\n```\\n[1,1,2,4,7,8]  -->  y = 8      &      x = 7\\n\\nThus,\\ny - x    -->  8 - 7 = 1\\n```\n```\\n[1,1,2,4]          add => 1   in our array\\n\\n[1,1,2,4,1]          now again sort it,\\n\\n[1,1,1,2,4]\\n```\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        \\n        for(int i = stones.length - 1; i > 0; i--){\\n            stones[i - 1] = stones[i] - stones[i - 1];\\n            Arrays.sort(stones);\\n        }\\n        return stones[0];\\n    }\\n}\\n```\n```\\nFor Optimising it, we gonna use the help of Heap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|     |\\n|     |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                 ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|     |\\n|  2  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                   ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|  7  |\\n|  2  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                     ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|  7  |\\n|  4  |\\n|  2  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                       ^\\n|     |\\n|\\t  |\\t\\t\\n|  7  |  \\n|  4  |\\n|  2  |\\n|  1  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                         ^\\n|     |\\n|  8  |\\t\\t\\n|  7  |  \\n|  4  |\\n|  2  |\\n|  1  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           ^\\n|  8  |\\n|  7  |\\t\\t\\n|  4  |  \\n|  2  |\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           \\n|     |         y = 8\\n|     |\\t\\t    x = 7\\n|  4  |      \\n|  2  |         and their result will be y - x => 8 - 7 = 1\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           \\n|     |         y = 4\\n|     |\\t\\t    x = 2\\n|     |      \\n|  1  |         and their result will be y - x => 4 - 2 = 2\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int v : stones){\\n            maxHeap.offer(v);\\n        }\\n        int x;\\n        int y;\\n        while(maxHeap.size() > 1){\\n            y = maxHeap.poll();\\n            x = maxHeap.poll();\\n            if(y > x){\\n                maxHeap.offer(y - x);\\n            }\\n        }\\n        if(maxHeap.size() == 0) return 0;\\n        return maxHeap.poll();\\n    }\\n}\\n```\n```\\nTime Complexity Explanation\\'s may be still if I\\'m wrong, correct me then, THANKS <^^>\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294993,
                "title": "java-python-3-easy-code-using-priorityqueue-heapq-w-brief-explanation-and-analysis",
                "content": "Sort stones descendingly in PriorityQueue, then pop out pair by pair, compute the difference between them and add back to PriorityQueue.\\n\\nNote: since we already know the first poped out is not smaller, it is not necessary to use Math.abs().\\n\\n```java\\n    public int lastStoneWeight(int[] stones) {\\n    //  PriorityQueue<Integer> pq = new PriorityQueue<>(stones.length, Comparator.reverseOrder());\\n        var q = new PriorityQueue<Integer>(stones.length, Comparator.reverseOrder());  // Credit to @YaoFrankie.\\n        for (int st : stones) { \\n            q.offer(st); \\n        }\\n        while (q.size() > 1) {\\n            q.offer(q.poll() - q.poll());\\n        }\\n        return q.peek();\\n    }\\n```\\n```\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        q = [-stone for stone in stones]\\n        heapq.heapify(q)\\n        while (len(q)) > 1:\\n            heapq.heappush(q, heapq.heappop(q) - heapq.heappop(q))\\n        return -q[0]\\n```\\n\\nIn case you want to optimize the time performance, refer to the following version, which does NOT put `0` into the PriorityQueue:\\n```java\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(stones.length, Comparator.reverseOrder());\\n        IntStream.of(stones).forEach(pq::offer);\\n        while (pq.size() > 1) {\\n            int diff = pq.poll() - pq.poll();\\n            if (diff > 0) {\\n                pq.offer(diff);\\n            }\\n        }\\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n```\\n```python\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heapify(hp := [-s for s in stones])\\n        while len(hp) > 1:\\n            if (diff := heappop(hp) - heappop(hp)) != 0:\\n                heappush(hp, diff)\\n        return -heappop(hp) if hp else 0\\n```\\n\\n**Analysis:**\\n\\nTime: O(nlogn), space: O(n), where n = stones.length.\\n\\n----\\n\\n**Q & A:**\\n\\nQ: If not adding zeroes in the queue when polling out two elements are equal, is the result same as the above code?\\n\\nA: Yes. 0s are always at the end of the PriorityQueue. No matter a positive deduct 0 or 0 deduct 0, the result is same as NOT adding 0s into the PriorityQueue.",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\n    public int lastStoneWeight(int[] stones) {\\n    //  PriorityQueue<Integer> pq = new PriorityQueue<>(stones.length, Comparator.reverseOrder());\\n        var q = new PriorityQueue<Integer>(stones.length, Comparator.reverseOrder());  // Credit to @YaoFrankie.\\n        for (int st : stones) { \\n            q.offer(st); \\n        }\\n        while (q.size() > 1) {\\n            q.offer(q.poll() - q.poll());\\n        }\\n        return q.peek();\\n    }\\n```\n```\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        q = [-stone for stone in stones]\\n        heapq.heapify(q)\\n        while (len(q)) > 1:\\n            heapq.heappush(q, heapq.heappop(q) - heapq.heappop(q))\\n        return -q[0]\\n```\n```java\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(stones.length, Comparator.reverseOrder());\\n        IntStream.of(stones).forEach(pq::offer);\\n        while (pq.size() > 1) {\\n            int diff = pq.poll() - pq.poll();\\n            if (diff > 0) {\\n                pq.offer(diff);\\n            }\\n        }\\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n```\n```python\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heapify(hp := [-s for s in stones])\\n        while len(hp) > 1:\\n            if (diff := heappop(hp) - heappop(hp)) != 0:\\n                heappush(hp, diff)\\n        return -heappop(hp) if hp else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 294925,
                "title": "c-multiset-and-priority-queue",
                "content": "#### Approach 1: Multiset\\n```\\nint lastStoneWeight(vector<int>& st) {\\n  multiset<int> s(begin(st), end(st));\\n  while (s.size() > 1) {\\n    auto w1 = *prev(s.end());\\n    s.erase(prev(s.end()));\\n    auto w2 = *prev(s.end());\\n    s.erase(prev(s.end()));\\n    if (w1 - w2 > 0) s.insert(w1 - w2);\\n  }\\n  return s.empty() ? 0 : *s.begin();\\n}\\n```\\n#### Approach 2: Priority Queue\\n```\\nint lastStoneWeight(vector<int>& st) {\\n  priority_queue<int> q(begin(st), end(st));\\n  while (q.size() > 1) {\\n    auto w1 = q.top(); q.pop();\\n    auto w2 = q.top(); q.pop();\\n    if (w1 - w2 > 0) q.push(w1 - w2);\\n  }\\n  return q.empty() ? 0 : q.top();\\n}\\n```\\n#### Complexity Analysys\\n- Time: O(n log n) to sort stones.\\n- Memory: O(n) for the multiset/queue.",
                "solutionTags": [],
                "code": "```\\nint lastStoneWeight(vector<int>& st) {\\n  multiset<int> s(begin(st), end(st));\\n  while (s.size() > 1) {\\n    auto w1 = *prev(s.end());\\n    s.erase(prev(s.end()));\\n    auto w2 = *prev(s.end());\\n    s.erase(prev(s.end()));\\n    if (w1 - w2 > 0) s.insert(w1 - w2);\\n  }\\n  return s.empty() ? 0 : *s.begin();\\n}\\n```\n```\\nint lastStoneWeight(vector<int>& st) {\\n  priority_queue<int> q(begin(st), end(st));\\n  while (q.size() > 1) {\\n    auto w1 = q.top(); q.pop();\\n    auto w2 = q.top(); q.pop();\\n    if (w1 - w2 > 0) q.push(w1 - w2);\\n  }\\n  return q.empty() ? 0 : q.top();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 360047,
                "title": "super-simple-o-n-java-solution-using-bucket-sort-and-two-pointers",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int[] buckets = new int[1001];\\n        for (int i = 0; i < stones.length; i++) {\\n            buckets[stones[i]]++;\\n        }\\n\\n        int slow = buckets.length - 1;   //start from the big to small\\n        while (slow > 0) {\\n\\t\\t// If the number of stones with the same size is even or zero, \\n\\t\\t// these stones can be totally destroyed pair by pair or there is no such size stone existing, \\n\\t\\t// we can just ignore this situation.\\n\\t\\t\\n        // When the number of stones with the same size is odd, \\n\\t\\t// there should leave one stone which is to smash with the smaller size one.\\n            if (buckets[slow]%2 != 0) {\\n                int fast = slow - 1;\\n                while (fast > 0 && buckets[fast] == 0) {\\n                    fast--;\\n                }\\n                if (fast == 0) break;\\n                buckets[fast]--;\\n                buckets[slow - fast]++;\\n            }\\n            slow--;\\n        }\\n        return slow;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int[] buckets = new int[1001];\\n        for (int i = 0; i < stones.length; i++) {\\n            buckets[stones[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1923171,
                "title": "javascript-faster-than-95-easy-to-understand-with-comments",
                "content": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while(stones.length>1){\\n        stones.sort((a,b)=>b-a); //sort the remaining stones in decending order;\\n        stones[1]=stones[0]-stones[1]; //smash the first and second stones ie the stones with largest weight ans assign the remaining stone weight to 1st index\\n        stones.shift();//shift the array to get rid of the 0 index\\n    }\\n    return stones[0] //return the 0 index value ie the resultl\\n};\\n```\\n\\nIts okay if you did not get the solution in the first try, don\\'t give up!\\nPlease do UPVOTE if you find it helpfull.... I know this is not the best solution to this problem but this is what I came up with.\\nHappy C0d1ng!! Cheers!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while(stones.length>1){\\n        stones.sort((a,b)=>b-a); //sort the remaining stones in decending order;\\n        stones[1]=stones[0]-stones[1]; //smash the first and second stones ie the stones with largest weight ans assign the remaining stone weight to 1st index\\n        stones.shift();//shift the array to get rid of the 0 index\\n    }\\n    return stones[0] //return the 0 index value ie the resultl\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1922652,
                "title": "c-java-python-6-line-approach-question-clarifications-heap-cheatsheet",
                "content": "If you are already familiar with priority_queue in C++ skip to the Approach section at the end\\n### C++ Heap Guide/Cheatsheet\\nIn C++ [priority_queue](https://www.cplusplus.com/reference/queue/priority_queue/) is the implementation for heaps. If you have never used priority_queue before, you can get started by reading this cheatsheet and solving this problem. However, you still should read about [heaps](https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-fall-2011/resources/lecture-4-heaps-and-heap-sort/) and how they work so that you know when and where to use them.\\n\\n1. **Introduction**\\n* Why heaps?\\nHeap as a container gives you fast insertion of any element as well as reads and deletion of either the minimum-most or maximum-most element. Also it does not provide random access to any other element in the heap\\n* Where to use?\\nBased on this advantage, some major use cases for heaps are BFS, Djikstra, Current median of stream of elements\\n\\n2. **Initialising**\\n\\t```cpp\\n\\t// 1. max heap -> for popping largest element\\n\\t\\tpriority_queue<int> pq;     // replace int with any other type or a struct based on need\\n\\t// 2. min heap -> for popping minimum element\\n\\t\\tpriority_queue<int, vector<int>, greater<int>> pq;\\n\\t// 3. custom heaps in case of custom ordering (here we are creating min heap based on second property)\\n\\t\\tstruct comp {\\n\\t\\t\\tbool operator()(pair<int, int> a, pair<int, int> b) {\\n\\t\\t\\t\\treturn a.second > b.second;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tpriority_queue<int, vector<int>, comp> pq;\\n\\t// 4. If you already have an array and want to initialise using it\\n\\t\\tpriority_queue<int, vector<int>, greater<int>> pq(a.begin(), a.end());\\n\\t```\\n\\tThis last operation takes O(n) time where n is size of array a.\\n\\n3. **Important operations**\\n\\t```cpp\\n\\tpq.push(10);           // adds element to heap\\n\\tint cur = pq.top();    // returns top element, does NOT pop though\\n\\tpq.pop()               // pops top element, does NOT return the value of top element though\\n\\tpq.size()              // return size of heap\\n\\tpq.empty()             // returns true if heap is empty else false\\n\\t```\\n - Always make sure that heap is not empty prior to top() and pop() methods\\n - *Time* - push() and pop() takes O(logn) time, the other three require O(1) time.\\n___\\n</br>\\n\\n### Question Clarifications\\nSome people have misinterpreted the question a bit, for example [here](https://leetcode.com/problems/last-stone-weight/discuss/1922217)\\nNote, the question states that you always have to pick the two largest stones and then find the minimum-most stone. Its however not necessary that if you had the freedom to pick any two stones, that picking the largest would give you smallest stone at the end. It actually wont, consider the following example -\\n> [25, 23, 16, 16, 16]\\n\\n* If you picked the largest two every time you would end up with 14.\\n* However with freedom to pick any stone you can end with 0. By picking following stones at each step -\\n\\t```text\\n\\t(25, 16) -> (23, 16) -> (16, 9)  -> (7, 7)\\n\\tleaves 9 -> leaves 7 -> leaves 7 -> leaves 0\\n\\t```\\n\\nAnother clarification, is the question states find the minimum most possible stone after only one stone remains. Since there can be only one pair of largest stones possible at each step and you do not have the element of choice, you can only have one way of smashing the stones and hence only one possibility of last stone remaining, which being the only candidate for being the minimum-most will also be the answer.\\n___\\n</br>\\n\\n### Approach\\nOnce we are aware of how to use the priority queue and the above facts the approach is straightforward as the question instructs us what to do. We need the two largest elements at each step for our operation, since heaps give the fastest access to the extremes its our go to here. The pseudo-code is as follows -\\n```text\\n\\tInitialise heap using the array (use 4th option above)\\n\\tKeep smashing as long as there is 2 or more stones (use size() method)\\n\\t\\tPick the two largest and remove them from heap (use top() and pop())\\n\\t\\tif their difference is positive add new stone to our heap (use push())\\n\\t\\n\\tIf there is a stone remaining in heap return it or else return 0 (use empty() and top())\\n```\\n\\nC++/Java/Python code based on above pseudo code\\n\\n<iframe src=\"https://leetcode.com/playground/kocCUYy5/shared\" frameBorder=\"0\" width=\"800\" height=\"370\"></iframe>\\n\\nComplexity - Time: O(nlogn), Space: O(n)\\n\\nWould also like to add the common heap operations and code for Java and Python along with complexity to this cheatsheet, please mention them if you are familiar with them.\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\n\\t// 1. max heap -> for popping largest element\\n\\t\\tpriority_queue<int> pq;     // replace int with any other type or a struct based on need\\n\\t// 2. min heap -> for popping minimum element\\n\\t\\tpriority_queue<int, vector<int>, greater<int>> pq;\\n\\t// 3. custom heaps in case of custom ordering (here we are creating min heap based on second property)\\n\\t\\tstruct comp {\\n\\t\\t\\tbool operator()(pair<int, int> a, pair<int, int> b) {\\n\\t\\t\\t\\treturn a.second > b.second;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tpriority_queue<int, vector<int>, comp> pq;\\n\\t// 4. If you already have an array and want to initialise using it\\n\\t\\tpriority_queue<int, vector<int>, greater<int>> pq(a.begin(), a.end());\\n\\t```\n```cpp\\n\\tpq.push(10);           // adds element to heap\\n\\tint cur = pq.top();    // returns top element, does NOT pop though\\n\\tpq.pop()               // pops top element, does NOT return the value of top element though\\n\\tpq.size()              // return size of heap\\n\\tpq.empty()             // returns true if heap is empty else false\\n\\t```\n```text\\n\\t(25, 16) -> (23, 16) -> (16, 9)  -> (7, 7)\\n\\tleaves 9 -> leaves 7 -> leaves 7 -> leaves 0\\n\\t```\n```text\\n\\tInitialise heap using the array (use 4th option above)\\n\\tKeep smashing as long as there is 2 or more stones (use size() method)\\n\\t\\tPick the two largest and remove them from heap (use top() and pop())\\n\\t\\tif their difference is positive add new stone to our heap (use push())\\n\\t\\n\\tIf there is a stone remaining in heap return it or else return 0 (use empty() and top())\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575360,
                "title": "python3-heapq-priority-queue",
                "content": "Since we want the two largest stones each time, and heapq.pop() gives us the smallest each time, we just need to make every value of stones negative at the beginning.\\n```\\nimport heapq\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-val for val in stones]\\n        heapq.heapify(stones)\\n        while len(stones) > 1:\\n            x1 = heapq.heappop(stones)\\n            x2 = heapq.heappop(stones)\\n            if x1 != x2:\\n                heapq.heappush(stones,x1-x2)\\n        if len(stones) == 0:\\n            return 0\\n        return -stones[0]\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-val for val in stones]\\n        heapq.heapify(stones)\\n        while len(stones) > 1:\\n            x1 = heapq.heappop(stones)\\n            x2 = heapq.heappop(stones)\\n            if x1 != x2:\\n                heapq.heappush(stones,x1-x2)\\n        if len(stones) == 0:\\n            return 0\\n        return -stones[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449430,
                "title": "java-easy-solution-explained-similar-questions-beginner-friendly",
                "content": "# Intuition\\nSince we need to choose heaviest two stones everytime, this is a clear hint to go for heap data structure. In java we implement heap via priority queue.\\n\\nSimilar questions for heap i faced in interviews.\\nLC 347[ Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)\\nLC 215[ Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)\\nLC 23 [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)\\n\\n\\n---\\n# Approach\\n1) Make a heap via priority queue, we need to make a max heap as we need heaviest stone collision first.\\n2) Add stones[] to heap\\n3) Now run a while loop till there are two elements remaining in the hea[] i.e ```while(heap.size()>1)``` Two elements because each collision needs two stones atleast. \\n- pick top 2 stones and calculate their difference\\n- if difference!=0 we need back to heap other both stones are destroyed.\\n4) Once outside the loop, check for size!=0 i.e once stone remains return that or return zero.\\n\\n---\\n# Complexity\\n- Time complexity:\\nO(nlogn) : Building of heap intially nlogn, Then since we poll and push again to the heap, it needs to rebuild which takes logn(heapify) everytime.\\n\\n- Space complexity:\\nO(n) at max we will have n elements in heap.\\n\\n---\\n\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging\\n\\n\\n---\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        //setting decreasing order of the heap or max heap\\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a,b) -> b-a);\\n        for(int each: stones)\\n            heap.add(each);\\n\\n        while(heap.size()>1){\\n            int top1 = heap.poll();\\n            int top2 = heap.poll();\\n            int diff = Math.abs(top1-top2);\\n\\n            if(diff!=0){\\n                heap.add(diff);\\n            }\\n        }\\n\\n        if(heap.size()!=0){\\n            return heap.poll();\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```while(heap.size()>1)```\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        //setting decreasing order of the heap or max heap\\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a,b) -> b-a);\\n        for(int each: stones)\\n            heap.add(each);\\n\\n        while(heap.size()>1){\\n            int top1 = heap.poll();\\n            int top2 = heap.poll();\\n            int diff = Math.abs(top1-top2);\\n\\n            if(diff!=0){\\n                heap.add(diff);\\n            }\\n        }\\n\\n        if(heap.size()!=0){\\n            return heap.poll();\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921223,
                "title": "c-simulation-100-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nTo solve this problem, we can conduct an actual simulation of the described process. Since we always need to use the heaviest stones, we can use a heap data structure for easy access to max elements.\\n\\nTime: **O(nlogn)** - for the heap\\nSpace: **O(1)** - nothing stored\\n\\nRuntime: 0 ms, faster than **100.00%** of C++ online submissions for Last Stone Weight.\\nMemory Usage: 7.6 MB, less than **34.27%** of C++ online submissions for Last Stone Weight.\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& s) {\\n         make_heap(s.begin(), s.end());\\n        \\n         while (s.size() > 1) {\\n            int x = s.front();\\n            pop_heap(s.begin(), s.end());\\n            s.pop_back();\\n            \\n            int y = s.front();\\n            pop_heap(s.begin(), s.end());\\n            s.pop_back();\\n            \\n            if (x == y) continue;\\n            \\n            s.push_back(x - y);\\n            push_heap(s.begin(), s.end());\\n        }\\n        \\n        return s.size() ? s.front() : 0;\\n    }\\n};\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& s) {\\n         make_heap(s.begin(), s.end());\\n        \\n         while (s.size() > 1) {\\n            int x = s.front();\\n            pop_heap(s.begin(), s.end());\\n            s.pop_back();\\n            \\n            int y = s.front();\\n            pop_heap(s.begin(), s.end());\\n            s.pop_back();\\n            \\n            if (x == y) continue;\\n            \\n            s.push_back(x - y);\\n            push_heap(s.begin(), s.end());\\n        }\\n        \\n        return s.size() ? s.front() : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921769,
                "title": "java-best-intuitive-solution-priority-queue-1ms-99-faster",
                "content": "**Code**\\n```java\\npublic int lastStoneWeight(int[] stones) {\\n\\tPriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\tfor(int st: stones)\\n\\t\\tpq.offer(st);\\n\\n\\twhile(pq.size() > 1) {\\n\\t\\tint f = pq.poll();\\n\\t\\tint s = pq.poll();\\n\\t\\tif(f != s) \\n\\t\\t\\tpq.offer(f-s);\\n\\t}\\n\\n\\treturn pq.isEmpty() ? 0 : pq.peek();\\n}\\n```\\n\\n**Explanation**\\nWe were required to do operations each time on largest elements, and for that we can use max heap which can use used by reverting the order of priority queue available in Collections framework in java.\\n- Push all elements in priority queue.\\n- Iterate while the size of priority queue becomes equal to or less than 1.\\n- Pop two largest element from top and perform following checks\\n\\t- if both are equal then we don\\'t need to do anything.\\n\\t- else we add the difference of `f` and `s` to the priority queue.\\n- Now return 0 if size of `pq` is 0 otherwise return top element.\\n\\nHere\\'s how it works:-\\n\\n![image](https://assets.leetcode.com/users/images/89bb3992-f3ba-410e-a071-62c44831876a_1649307957.4194489.png)\\n\\n\\nHope it helps,\\nIf it does do upvote\\nThanks",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\npublic int lastStoneWeight(int[] stones) {\\n\\tPriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\tfor(int st: stones)\\n\\t\\tpq.offer(st);\\n\\n\\twhile(pq.size() > 1) {\\n\\t\\tint f = pq.poll();\\n\\t\\tint s = pq.poll();\\n\\t\\tif(f != s) \\n\\t\\t\\tpq.offer(f-s);\\n\\t}\\n\\n\\treturn pq.isEmpty() ? 0 : pq.peek();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563863,
                "title": "easy-to-understand-heap-based-faster-simple-python-solution",
                "content": "```\\ndef lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-i for i in stones]\\n        heapq.heapify(stones)\\n        while len(stones)>1:\\n            first = abs(heapq.heappop(stones))\\n            second = abs(heapq.heappop(stones))\\n            if first != second:\\n                heapq.heappush(stones, -abs(first - second))\\n                \\n        # this compact return statement way is great ^_^\\n        return abs(stones[0]) if len(stones) else 0\\n                \\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-i for i in stones]\\n        heapq.heapify(stones)\\n        while len(stones)>1:\\n            first = abs(heapq.heappop(stones))\\n            second = abs(heapq.heappop(stones))\\n            if first != second:\\n                heapq.heappush(stones, -abs(first - second))\\n                \\n        # this compact return statement way is great ^_^\\n        return abs(stones[0]) if len(stones) else 0\\n                \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1470255,
                "title": "simple-javascript-soluton-recursion",
                "content": "```\\nvar lastStoneWeight = function(stones) {\\n    if(stones.length < 2) return stones;\\n    stones.sort((a,b) => a-b);\\n    let a = stones.pop();\\n    let b = stones.pop();\\n    stones.push(Math.abs(a-b));\\n    return lastStoneWeight(stones);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar lastStoneWeight = function(stones) {\\n    if(stones.length < 2) return stones;\\n    stones.sort((a,b) => a-b);\\n    let a = stones.pop();\\n    let b = stones.pop();\\n    stones.push(Math.abs(a-b));\\n    return lastStoneWeight(stones);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3222221,
                "title": "java-solution-let-s-learn-when-to-use-heap-priority-queue",
                "content": "# Intuition\\nAs soon as we understand that we need to repeatedly get a maximum/minimum value from an array, we can use Heap (Priority Queue).\\n\\nYou can use Minimum Heap like this:\\n***PriorityQueue<Integer> minHeap = new PriorityQueue<>();***\\n\\nOr you can use Maximum Heap this way:\\n***PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());***\\n\\nAs you can see, if you want to change your heap from min to max you can simply reverse it by adding ***Comparator.reverseOrder()***;\\n\\nGiven this knowledge we can start implementing our solution.\\n\\n# Approach\\n1. Initialize max heap, because we need the biggest stones.\\n2. Add all stones from our initial array to the heap.\\n3. While size of our heap is not equal to one we need to remove two stones and confirm if they are equal (then we will add 0 to our heap) or x != y (then we will add y - x to the heap (the biggest stone minus second one)).\\n4. The last element from the heap will be our answer.\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\text{ }log \\\\text{ } n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int stone : stones) {\\n            maxHeap.add(stone);\\n        }\\n        while (maxHeap.size() != 1) {\\n            int y = maxHeap.remove();\\n            int x = maxHeap.remove();\\n            if (x == y) maxHeap.add(0);\\n            if (x != y) maxHeap.add(y - x);\\n        }\\n        return maxHeap.peek();\\n    }\\n}\\n```\\n![4x5hdv.jpeg](https://assets.leetcode.com/users/images/d8917be9-a9ce-4b97-a3ee-8b99901cf5af_1677435627.74426.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int stone : stones) {\\n            maxHeap.add(stone);\\n        }\\n        while (maxHeap.size() != 1) {\\n            int y = maxHeap.remove();\\n            int x = maxHeap.remove();\\n            if (x == y) maxHeap.add(0);\\n            if (x != y) maxHeap.add(y - x);\\n        }\\n        return maxHeap.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448738,
                "title": "easy-solution-of-java-c-beginner-friendly-arraylist",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n   public int lastStoneWeight(int[] stones)\\n{\\n\\t\\tArrayList<Integer> listStones = new ArrayList<>();\\n\\t\\tfor (int a : stones)\\n\\t\\t\\tlistStones.add(a);\\n\\n\\t\\twhile (true)\\n\\t\\t{\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\t\\tint len = listStones.size();\\n\\n\\t\\t\\tif (len == 1 || len == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tCollections.sort(listStones);\\n\\t\\t\\tmin = listStones.get(len - 2);\\n\\t\\t\\tmax = listStones.get(len - 1);\\n\\n\\t\\t\\tif (min < max)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmax = max - min;\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.add(max);\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if (min == max)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        if(listStones.size()==1)\\n            return listStones.get(0);\\n        return 0;\\n\\t}\\n}\\n```\\nC++\\n```\\n    int lastStoneWeight(vector<int>& s) {\\n        int n = s.size();\\n        if(n == 1) return s[0];\\n        sort(s.begin(), s.end());\\n        int i = n-1;\\n        while(i >= 1){\\n            if(s[i-1] == s[i])\\n                i = i - 2;\\n            else{\\n                s[i-1] = s[i] - s[i-1];\\n                i = i -1;\\n                int j = i;\\n                while( j > 0 and s[j-1] > s[j] ){\\n                    swap( s[j-1] , s[j] );\\n                    j--;\\n                }\\n            }\\n        }\\n        if( i == 0 )\\n            return s[i];\\n        else \\n            return 0;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n   public int lastStoneWeight(int[] stones)\\n{\\n\\t\\tArrayList<Integer> listStones = new ArrayList<>();\\n\\t\\tfor (int a : stones)\\n\\t\\t\\tlistStones.add(a);\\n\\n\\t\\twhile (true)\\n\\t\\t{\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\t\\tint len = listStones.size();\\n\\n\\t\\t\\tif (len == 1 || len == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tCollections.sort(listStones);\\n\\t\\t\\tmin = listStones.get(len - 2);\\n\\t\\t\\tmax = listStones.get(len - 1);\\n\\n\\t\\t\\tif (min < max)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmax = max - min;\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.add(max);\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if (min == max)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        if(listStones.size()==1)\\n            return listStones.get(0);\\n        return 0;\\n\\t}\\n}\\n```\n```\\n    int lastStoneWeight(vector<int>& s) {\\n        int n = s.size();\\n        if(n == 1) return s[0];\\n        sort(s.begin(), s.end());\\n        int i = n-1;\\n        while(i >= 1){\\n            if(s[i-1] == s[i])\\n                i = i - 2;\\n            else{\\n                s[i-1] = s[i] - s[i-1];\\n                i = i -1;\\n                int j = i;\\n                while( j > 0 and s[j-1] > s[j] ){\\n                    swap( s[j-1] , s[j] );\\n                    j--;\\n                }\\n            }\\n        }\\n        if( i == 0 )\\n            return s[i];\\n        else \\n            return 0;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922257,
                "title": "2-approaches-sorting-max-heap-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- ***Brute force solution*** //not recommended.\\n- Here every iteration we\\u2019re sorting the array & changing the last 2 values.\\n- As the last 2 are the max elements, so ***x=stones[n-2]*** & ***y=stones[n-1].***\\n- We\\u2019ll replace x with 0 (as all elements will be greater than 0), and y with y-x.\\n- Return the last element after n iteration.\\n- **Time complexity:** O(n^2logn).\\n\\n### Solution 02\\n\\n- Using ***Max Heap.***\\n- Max heap keeps the maximum element on top.\\n- First, we\\u2019ll push all the elements of stones to our max heap.\\n- Now until the size of our heap won\\u2019t became 1 we\\u2019ll continue this operation:\\n    - Take the top element to y & pop that element. `y = q.top(); q.pop();`\\n    - Similarly, put the next element to x & pop it. `x = q.top(); q.pop();`\\n    - Now smallest element will destroy & we\\u2019ll push y-x to our heap again. In the case of same weight elements, it will automatically push 0. `q.push(y-x);`\\n    - When the size of the heap became 1 we\\u2019ll break the loop and return top element.\\n- **Time complexity:** O(nlogn).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n = stones.size(), ans, count = 0;\\n        \\n        if(n == 1) return stones[0];\\n        \\n        while(count != n-1){\\n            sort(stones.begin(), stones.end());\\n            stones[n-1] = stones[n-1] - stones[n-2];\\n            stones[n-2] = 0;\\n            count++;\\n        }\\n        return stones[n-1];\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int, vector<int>> q;\\n        int x, y;\\n        \\n        for(auto x:stones)\\n            q.push(x);\\n        \\n        while(q.size() != 1){\\n            y = q.top();\\n            q.pop();\\n            x = q.top();\\n            q.pop();\\n\\n            q.push(y-x);\\n        }\\n        \\n        return q.top();\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n = stones.size(), ans, count = 0;\\n        \\n        if(n == 1) return stones[0];\\n        \\n        while(count != n-1){\\n            sort(stones.begin(), stones.end());\\n            stones[n-1] = stones[n-1] - stones[n-2];\\n            stones[n-2] = 0;\\n            count++;\\n        }\\n        return stones[n-1];\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int, vector<int>> q;\\n        int x, y;\\n        \\n        for(auto x:stones)\\n            q.push(x);\\n        \\n        while(q.size() != 1){\\n            y = q.top();\\n            q.pop();\\n            x = q.top();\\n            q.pop();\\n\\n            q.push(y-x);\\n        }\\n        \\n        return q.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922285,
                "title": "shortest-solution-using-min-heap-priorityqueue",
                "content": "**Step 1:** Put the array into a min heap. To avoid creating a custom comparer, let\\'s just revert priorities (`-x`).\\n**Step 2:** Get the two \"heaviest\" stones from the heap and smash them together. If there is something left, put it back into the heap.\\n\\n```csharp\\npublic int LastStoneWeight(int[] stones)\\n{\\n    var q = new PriorityQueue<int, int>(stones.Select(x => (x, -x)));\\n    \\n    while (q.Count > 1)\\n    {\\n        int a = q.Dequeue() - q.Dequeue();\\n        if (a != 0) q.Enqueue(a, -a);\\n    }\\n        \\n    return (q.Count == 0) ? 0 : q.Peek();\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```csharp\\npublic int LastStoneWeight(int[] stones)\\n{\\n    var q = new PriorityQueue<int, int>(stones.Select(x => (x, -x)));\\n    \\n    while (q.Count > 1)\\n    {\\n        int a = q.Dequeue() - q.Dequeue();\\n        if (a != 0) q.Enqueue(a, -a);\\n    }\\n        \\n    return (q.Count == 0) ? 0 : q.Peek();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 494003,
                "title": "java-100-time-100-space",
                "content": "````\\npublic int lastStoneWeight(int[] stones) {\\n        if(stones.length==1)return stones[0];\\n        Arrays.sort(stones);\\n        int y = stones.length-1;\\n        int x = stones.length-2;\\n        while(x>=0){\\n            if(stones[x]==stones[y]){\\n                stones[x] = 0;\\n                stones[y] = 0;\\n            }else{\\n                stones[y] -= stones[x];\\n                stones[x] = 0;\\n            }\\n            Arrays.sort(stones);\\n            if(stones[x]==0)break;\\n        }\\n        return stones[y];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\npublic int lastStoneWeight(int[] stones) {\\n        if(stones.length==1)return stones[0];\\n        Arrays.sort(stones);\\n        int y = stones.length-1;\\n        int x = stones.length-2;\\n        while(x>=0){\\n            if(stones[x]==stones[y]){\\n                stones[x] = 0;\\n                stones[y] = 0;\\n            }else{\\n                stones[y] -= stones[x];\\n                stones[x] = 0;\\n            }\\n            Arrays.sort(stones);\\n            if(stones[x]==0)break;\\n        }\\n        return stones[y];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1921204,
                "title": "python-6-lines-sortedlist-clean",
                "content": "**Please UPVOTE if you LIKE!** \\uD83D\\uDE01\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        sl = SortedList(stones)\\n        while len(sl) >= 2:\\n            y = sl.pop()\\n            x = sl.pop()\\n            if y > x: sl.add(y - x)  # Note that sl is a SortedList\\n        return sl.pop() if len(sl) else 0\\n```\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        sl = SortedList(stones)\\n        while len(sl) >= 2:\\n            y = sl.pop()\\n            x = sl.pop()\\n            if y > x: sl.add(y - x)  # Note that sl is a SortedList\\n        return sl.pop() if len(sl) else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365807,
                "title": "c-priority-queue-100-time-short-easy-to-understand",
                "content": "```\\npriority_queue<int> pq(v.begin(),v.end());\\n        \\n        while(true)\\n        {\\n            if(pq.size() ==0)   return 0;\\n            if(pq.size() ==1)   return pq.top();\\n            int a = pq.top();\\n            pq.pop();\\n            int b = pq.top();\\n            pq.pop();\\n            if(a!=b)    pq.push(abs(a-b));\\n        }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npriority_queue<int> pq(v.begin(),v.end());\\n        \\n        while(true)\\n        {\\n            if(pq.size() ==0)   return 0;\\n            if(pq.size() ==1)   return pq.top();\\n            int a = pq.top();\\n            pq.pop();\\n            int b = pq.top();\\n            pq.pop();\\n            if(a!=b)    pq.push(abs(a-b));\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2854146,
                "title": "python-heap-explained-with-easy-code",
                "content": "# Naive Approach\\nThe naive approach to solve the question, would be:\\n\\n1. Sort the array in decreasing order\\n2. Pop the first two elements, subtract them.\\n3. If the difference is 0, then do nothing. Else, append the difference in the array\\n4. Repeat the step 1, 2 and 3 until there is only one item left in the array\\n5. The only item left in the array is the answer\\n\\nHowever, the time complexity would be high because sorting is performed (N-1) times. The time complexity would be O(N<sup>2</sup>).\\n\\n---\\n\\n\\n# Optimal Approach\\nThe optimal approach uses a very important Data Structure, Heap. Heap is a Complete Binary Tree.\\nFirst, let\\'s understand what is a <b>Complete Binary Tree</b>. \\n*[Skip if you know that already]*\\n\\n### Complete Binary Tree\\n1. <b>Definition 1</b>\\nA complete binary tree is a binary tree where all the levels, except the last level must be completely filled. The last level may or may not be filled completely. The last level MUST be filled from left to right.\\n2. <b>Definition 2</b>\\nA Complete Binary Tree is a Tree, where every level in the tree is required to be filled with maximum nodes, except the last level. The last level may not be completely filled but all the nodes in the last level must be towards the left of the tree.\\n\\n## Heap\\nHeap Data Strucutre, is a Complete Binary Tree, which satisfies the <b>Heap Property</b>. We are going to discuss the heap properties in a moment. There are two types of Heaps: <b>MaxHeap</b> and <b>MinHeap</b>.\\n\\n## MaxHeap\\nProperty for a MaxHeap is \"<b>The value of every node is less than or equal to its parent</b>\". Therefore, in a MaxHeap, the maximum value resides as the root node. Here is a valid MaxHeap:\\n<table width = \"100%\">\\n<tr>\\n<td><img src = \"https://assets.leetcode.com/users/images/22cb76cb-8d54-4e4a-8947-d500f0c7c0f3_1669561918.8131528.png\" style =\"text-align: center; margin: 0; width: 100%;\" /></td>\\n</tr>\\n<tr>\\n<td>This is a valid MaxHeap Tree because:\\n<ol>\\n<li>It is a complete binary tree. Every level is completely filled except the last level which is completely left aligned.</li>\\n<li>Every Node is less than or equal to its parent node.</li>\\n</ol>\\n</td>\\n</tr>\\n</table>\\n\\n## MinHeap\\nMinHeap is just opposite of MaxHeap. The Heap Property for a MinHeap is \"<b>The value of every node is greater than or equal to its parent</b>\". Therefore, in a MinHeap, the minimum value resides as the root node.\\n\\n---\\n\\n# Why Heap?\\n\\nAs you just saw, in a MaxHeap, the maximum element is guaranteed to be on the top of the tree, or in a MinHeap, the minimum element is guaranteed to be on the top of the tree. In an sorted array, each time, we inserted, removed or updated an element in the array, the whole array needs to be sorted again to keep the array in order. It was a very time costly operation. In heaps, we can remove, insert or update an element in the heap in `log N`.\\n\\n### How is it so fast?\\nThis high performace is achieved because a Heap Tree can be written in an array (list) in such a way that, the traversals are easy as compared to that in a normal array. \\nFor example, let\\'s write the above mentioned MaxHeap in the array.:\\n<table>\\n<tr>\\n<td>100</td>\\n<td>17</td>\\n<td>39</td>\\n<td>15</td>\\n<td>13</td>\\n<td>36</td>\\n<td>25</td>\\n<td>14</td>\\n<td>9</td>\\n</tr>\\n</table>\\n\\nLet the indices be 1, 2, 3, 4... and so on. If, I ask you to look at the array and tell me the parent of 36 in the Heap, how would you do it?\\nWell, there\\'s a simple trick. Get the index of 36, which is 6. Floored Division of the index by 2 would give the index of its parent. Hence, its parent is at index 3, i.e. 39. You can try that for other elements as well.... You can also do the opposite, i.e. multiply and index by 2 to get the index of left child, and add 1 to it to get the index of right child.\\nThis holds true, as long as the tree is a Complete Binary Tree.\\n\\nNow, how things work is... say you want to insert an element 19 in the array (or heap). The algorithm goes like:\\n1. Add 19 to the next available position in the heap, i.e. 19 would be added as the left child of 13 (Consider the tree diagram above). \\n**Important:** Note that, in the array notation of the heap, the element would be added to the last of the array. Actually, there is no data structure like Complete Binary Tree getting involved here, it\\'s just for visualisation. All the operations we do are on the array.\\n2. Find the parent of 19 and compare both the numbers. Here, the parent is 13 and 13 < 19. Since, it is a Max Heap, larger number remains on top. So, we swap 13 with 19.\\n3. Now, again we find the parent of 19, which would be 17 this time. Again, 17 < 19. So, 17 and 19 are swapped.\\n4. Again the parent of 19 is 100, but 100 > 19, so no more swapping is done, and we have our element inserted.\\n\\nSimilarily there are deletion operations, which can also be performed in `log N` time. But, we are not going deeper into this.\\n\\n---\\n\\n# Heap in Python\\nPython provides an inbuilt module for dealing with heap data structure, namely \\'heapq\\'. It has various functions which are going to help us throughout the program. Thus, we need to import it to use it. The library can be used to create MinHeap. But, we can use the properties of MaxHeap if we multiply every value in the MinHeap with -1. Then, the negative value of every node acts as a MaxHeap.\\nLet\\'s code:\\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        \\n\\t\\t#    First, import the heapq module. Specifically the functions heapify, heappop and heappush\\n        from heapq import heapify, heappop, heappush\\n        \\n\\t\\t#    Initialize an empty array, which we would use as heap\\n        heap = []\\n        for stone in stones:\\n\\t\\t\\n\\t\\t#    We would add the negative values of the given list in the Heap\\n            heap.append(-stone)\\n        \\n\\t\\t#    heapify function from the heapq module, takes an array as parameter, arranges the contents\\n\\t\\t#    of the array in such a way that the array becomes a minheap\\n        heapify(heap)\\n        \\n        while len(heap) > 1:\\n\\t\\t\\n\\t\\t#    heappop function from the heapq module, takes an array (heap) as parameter, and removes\\n\\t\\t#    the root of the minheap, returns the value, and then makes the necessary arrangement so\\n\\t\\t#    that the heap does not lose its properties.\\n            x = heappop(heap)\\n            y = heappop(heap)\\n            \\n\\t\\t#    if the two minimum values from the heap are not equal, then subtract the larger value (smaller\\n\\t\\t#    magnitude) from the smaller value (larger magnitude). Add the difference back to the heap\\n            if x != y:\\n\\t\\t\\t\\n\\t\\t#    heappush function, from the heapq module, takes an array (heap) as parameter, and adds\\n\\t\\t#    the second parameter to the array, maintaining the heap properties of the array.\\n                heappush(heap, x - y)\\n        \\n\\t\\t#    if heap is not empty then, return the first item in the heap multiplied by -1\\n        if heap:\\n            return -heap[0]\\n\\t\\t\\t\\n\\t\\t#    if heap was empty, then return 0\\n        return 0\\n```\\n\\nIt took sweats to create this post. Please upvote, if you found it helpful. Happy Leetcoding!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        \\n\\t\\t#    First, import the heapq module. Specifically the functions heapify, heappop and heappush\\n        from heapq import heapify, heappop, heappush\\n        \\n\\t\\t#    Initialize an empty array, which we would use as heap\\n        heap = []\\n        for stone in stones:\\n\\t\\t\\n\\t\\t#    We would add the negative values of the given list in the Heap\\n            heap.append(-stone)\\n        \\n\\t\\t#    heapify function from the heapq module, takes an array as parameter, arranges the contents\\n\\t\\t#    of the array in such a way that the array becomes a minheap\\n        heapify(heap)\\n        \\n        while len(heap) > 1:\\n\\t\\t\\n\\t\\t#    heappop function from the heapq module, takes an array (heap) as parameter, and removes\\n\\t\\t#    the root of the minheap, returns the value, and then makes the necessary arrangement so\\n\\t\\t#    that the heap does not lose its properties.\\n            x = heappop(heap)\\n            y = heappop(heap)\\n            \\n\\t\\t#    if the two minimum values from the heap are not equal, then subtract the larger value (smaller\\n\\t\\t#    magnitude) from the smaller value (larger magnitude). Add the difference back to the heap\\n            if x != y:\\n\\t\\t\\t\\n\\t\\t#    heappush function, from the heapq module, takes an array (heap) as parameter, and adds\\n\\t\\t#    the second parameter to the array, maintaining the heap properties of the array.\\n                heappush(heap, x - y)\\n        \\n\\t\\t#    if heap is not empty then, return the first item in the heap multiplied by -1\\n        if heap:\\n            return -heap[0]\\n\\t\\t\\t\\n\\t\\t#    if heap was empty, then return 0\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448720,
                "title": "priority-queue-max-heap-clean-code-easy-explaination",
                "content": "# Intuition\\nIf you reached here it\\'s for sure you not able to get to the solution in the first place dont worry I did the same mistake. \\n\\nJust read the question nicely, It says every time you have to pick the stones with largest weight, so for sure you might have sorted the Array and applied a greedy approach,but you\\'ll have to perform sort operation everytime you perform a operation. \\n\\nSo priority queue uses a Data structure called Max heap for the implemenation where the top node is always the maximum and we can get it in 0(1) time.\\n\\nYou can see the code we just pop two top stones with heigest weight and put a stone again in it.\\n\\n# Approach\\nSimple thinking, Heap Data structure greedy.\\n\\n# Complexity\\n- Time complexity:\\nCreation of priority-0(nlogn)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n = stones.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++) pq.push(stones[i]);\\n        while(pq.size()>=2)\\n        {\\n           int x = pq.top(); pq.pop();\\n           int y = pq.top(); pq.pop();\\n           if(x!=y) pq.push(abs(x-y));\\n\\n        }if(pq.size()==0) return 0;\\n        return pq.top();\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n = stones.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++) pq.push(stones[i]);\\n        while(pq.size()>=2)\\n        {\\n           int x = pq.top(); pq.pop();\\n           int y = pq.top(); pq.pop();\\n           if(x!=y) pq.push(abs(x-y));\\n\\n        }if(pq.size()==0) return 0;\\n        return pq.top();\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123710,
                "title": "javascript-simple-priority-queue",
                "content": "```\\nvar lastStoneWeight = function(stones) {\\n    const queue = new MaxPriorityQueue();\\n    \\n    for (stone of stones) queue.enqueue(stone)\\n    \\n    while (queue.size() > 1) {\\n        let first = queue.dequeue().element;\\n        let second = queue.dequeue().element;\\n        if (first !== second) queue.enqueue(first-second)\\n    }\\n    \\n    return queue.size() === 0 ? 0 : queue.front().element\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar lastStoneWeight = function(stones) {\\n    const queue = new MaxPriorityQueue();\\n    \\n    for (stone of stones) queue.enqueue(stone)\\n    \\n    while (queue.size() > 1) {\\n        let first = queue.dequeue().element;\\n        let second = queue.dequeue().element;\\n        if (first !== second) queue.enqueue(first-second)\\n    }\\n    \\n    return queue.size() === 0 ? 0 : queue.front().element\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575358,
                "title": "easy-c-solution-using-priority-queue",
                "content": "1. Create a Priority queue (pq)\\n2. as long as size of pq > 1:\\n* every time pop two elements \\n* subtract second from first\\n* if res of subtractions is non-zero push this result back into pq\\nCODE:\\n```\\nint lastStoneWeight(vector<int>& stones) {\\n     priority_queue<int> pq;\\n      for(auto i : stones)        pq.push(i);\\n      while(pq.size() > 1)\\n      {\\n          int a = pq.top(); pq.pop();\\n          int b = pq.top(); pq.pop();\\n          if(a  - b > 0)\\n              pq.push(a-b);\\n      }\\n      return pq.empty()?0:pq.top();  \\n    }\\n",
                "solutionTags": [],
                "code": "1. Create a Priority queue (pq)\\n2. as long as size of pq > 1:\\n* every time pop two elements \\n* subtract second from first\\n* if res of subtractions is non-zero push this result back into pq\\nCODE:\\n```\\nint lastStoneWeight(vector<int>& stones) {\\n     priority_queue<int> pq;\\n      for(auto i : stones)        pq.push(i);\\n      while(pq.size() > 1)\\n      {\\n          int a = pq.top(); pq.pop();\\n          int b = pq.top(); pq.pop();\\n          if(a  - b > 0)\\n              pq.push(a-b);\\n      }\\n      return pq.empty()?0:pq.top();  \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1921745,
                "title": "rust-heap-and-matching",
                "content": "Code is short thanks to Rust\\'s pattern matching:\\n```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        let mut heap = BinaryHeap::from(stones);\\n        loop {\\n            match (heap.pop(), heap.pop()) {\\n                (Some(a), Some(b)) => if a > b {\\n                    heap.push(a - b);\\n                }\\n                (Some(a), None) => return a,\\n                (None, _) => return 0,\\n            };\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        let mut heap = BinaryHeap::from(stones);\\n        loop {\\n            match (heap.pop(), heap.pop()) {\\n                (Some(a), Some(b)) => if a > b {\\n                    heap.push(a - b);\\n                }\\n                (Some(a), None) => return a,\\n                (None, _) => return 0,\\n            };\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 576384,
                "title": "python-solution-simplest-2-line",
                "content": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) > 1: stones.append(stones.pop(stones.index(max(stones))) - stones.pop(stones.index(max(stones))))\\n        return stones[0]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) > 1: stones.append(stones.pop(stones.index(max(stones))) - stones.pop(stones.index(max(stones))))\\n        return stones[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354141,
                "title": "java-4-liner-explained",
                "content": "**Idea:**\\n* Push all stones in a max-heap\\n* Poll two stones, and push their difference back into the heap\\n* Do this till there\\'s only 1 stone left\\n\\n>**T/S:** O(n lg n)/O(n), where n = size(stones)\\n```\\npublic int lastStoneWeight(int[] stones) {\\n\\tvar maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\\n\\t\\n\\tfor (var stone : stones)\\n\\t\\tmaxHeap.add(stone);\\n\\n\\twhile (maxHeap.size() > 1)\\n\\t\\tmaxHeap.offer(maxHeap.poll() - maxHeap.poll());\\n\\t\\t\\n\\treturn maxHeap.poll();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int lastStoneWeight(int[] stones) {\\n\\tvar maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\\n\\t\\n\\tfor (var stone : stones)\\n\\t\\tmaxHeap.add(stone);\\n\\n\\twhile (maxHeap.size() > 1)\\n\\t\\tmaxHeap.offer(maxHeap.poll() - maxHeap.poll());\\n\\t\\t\\n\\treturn maxHeap.poll();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3449074,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "We can see that after two stones break we need to replace them back in the array. Where depends on how much they broke down, and it isn\\'t always guaranteed to be the end. This points toward a data structure that allows us to restructure efficiently, and that would be a Max Heap.\\n\\nA max heap is a tree structure that keeps the largest value on top, and for each child the same holds true. When we pop from a heap, the heap will restructure itself to maintain the same dynamics. So 2 pops from a max heap will result in us receiving the 2 largest stones. Pushing back on the heap will place the stones in their correct spot.\\n\\nNote: A lot of built-in heaps are min heap implementations, to utilize them, we must push the negative weights of the stones on the heap to maintain a max heap structure.\\n\\nTime Complexity: $$O(nlogn)$$. Where $$n$$ is the size of the heap/stones array. It will take $$n*log(n)$$ time to create the initial heap, then up to $$log(n)$$ time to place the broken-down stones back into the heap.\\n\\nSpace Complexity: $$O(n)$$. Where $$n$$ is the size of the stones array, to maintain our heap data structure with up to $$n$$ stones inside.\\n\\n\\n```py\\n# written by ColeB2\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        # initialize an empty array to hold our heap, python uses\\n        # arrays, and the heapq module to handle min Heaps. We will\\n        # use negative values of the stones to convert to a max heap.\\n        heap = []\\n        # loop through each stone in our stones array\\n        for stone in stones:\\n            # push the negative value of the stone onto the heap.\\n            # heappush takes the heap array, and the value to push\\n            # onto the heap. -stone will allow the min heap to act\\n            # as a max heap instead.\\n            heapq.heappush(heap, -stone)\\n        # We need at least 2 stones to smash together, so we loop while\\n        # our heap has at least 2 stones inside.\\n        while len(heap) >= 2:\\n            # pop both stones off, the 1st is the largest stone.\\n            stone1 = heapq.heappop(heap)\\n            stone2 = heapq.heappop(heap)\\n            # if the second stone is bigger, since we are using negative\\n            # values, the second being bigger, means they are not\\n            # the same size, and the first is larger. This means\\n            # the stone won\\'t be completely destroyed, so we need\\n            # co calculate the difference to add onto the heap.\\n            if stone2 > stone1:\\n                # Add onto the heap the difference of stones 1 and 2.\\n                heapq.heappush(heap, stone1 - stone2)\\n        # remembering that we used negative values of the stones, we \\n        # must return the absolute value of the remaining stone if it\\n        # exists, else 0 as the question asks.\\n        return abs(heap[0]) if heap else 0\\n```\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        // initialize a priority_queue in c++\\n        priority_queue<int> pq;\\n        // push the positive value of the stone onto the priority_queue\\n        for (int x : stones) pq.push(x); \\n        // We need at least 2 stones to smash together, so we loop while\\n        // our heap has at least 2 stones inside.\\n        while (pq.size() >= 2) {\\n            // pop both stones off, the 1st is the largest stone.\\n            int y = pq.top(); pq.pop();\\n            int x = pq.top(); pq.pop();\\n            // if the stones are not same, then the stone of weight x is detroyed\\n            // and the stone of weight y has new weight y - x.\\n            if (x != y) pq.push(y - x);\\n        }\\n        // if there are no stones left, return 0\\n        if (pq.size() == 0) return 0;\\n        // return the weight of the last remaining stone\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```py\\n# written by ColeB2\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        # initialize an empty array to hold our heap, python uses\\n        # arrays, and the heapq module to handle min Heaps. We will\\n        # use negative values of the stones to convert to a max heap.\\n        heap = []\\n        # loop through each stone in our stones array\\n        for stone in stones:\\n            # push the negative value of the stone onto the heap.\\n            # heappush takes the heap array, and the value to push\\n            # onto the heap. -stone will allow the min heap to act\\n            # as a max heap instead.\\n            heapq.heappush(heap, -stone)\\n        # We need at least 2 stones to smash together, so we loop while\\n        # our heap has at least 2 stones inside.\\n        while len(heap) >= 2:\\n            # pop both stones off, the 1st is the largest stone.\\n            stone1 = heapq.heappop(heap)\\n            stone2 = heapq.heappop(heap)\\n            # if the second stone is bigger, since we are using negative\\n            # values, the second being bigger, means they are not\\n            # the same size, and the first is larger. This means\\n            # the stone won\\'t be completely destroyed, so we need\\n            # co calculate the difference to add onto the heap.\\n            if stone2 > stone1:\\n                # Add onto the heap the difference of stones 1 and 2.\\n                heapq.heappush(heap, stone1 - stone2)\\n        # remembering that we used negative values of the stones, we \\n        # must return the absolute value of the remaining stone if it\\n        # exists, else 0 as the question asks.\\n        return abs(heap[0]) if heap else 0\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        // initialize a priority_queue in c++\\n        priority_queue<int> pq;\\n        // push the positive value of the stone onto the priority_queue\\n        for (int x : stones) pq.push(x); \\n        // We need at least 2 stones to smash together, so we loop while\\n        // our heap has at least 2 stones inside.\\n        while (pq.size() >= 2) {\\n            // pop both stones off, the 1st is the largest stone.\\n            int y = pq.top(); pq.pop();\\n            int x = pq.top(); pq.pop();\\n            // if the stones are not same, then the stone of weight x is detroyed\\n            // and the stone of weight y has new weight y - x.\\n            if (x != y) pq.push(y - x);\\n        }\\n        // if there are no stones left, return 0\\n        if (pq.size() == 0) return 0;\\n        // return the weight of the last remaining stone\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575369,
                "title": "python-solution-4-lines",
                "content": "```\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        for i in range(len(stones) - 1):\\n            stones.sort()\\n            stones.append(stones.pop() - stones.pop()) \\n        return stones[0]\\n\\t\\t\\n\\t\\t\\n\\t\\tFollow me for more intresting programming questions :\\n\\t\\t\\t\\t\\t\\t\\thttps://www.github.com/shubhamthrills\\n\\t\\t\\t\\t\\t\\t\\thttps://www.instagaram.com/shubhamthrills\\n\\t\\t\\t\\t\\t\\t\\thttps://www.linkedin.com/in/shubhamsagar\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\n#Another Possible approch [If you don\\'t want to decrease the length of loop every time]\\n\\n```\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        #stones=[2,7,4,1,8,1]\\n        for i in range(len(stones) - 1):\\n            stones.sort()\\n            temp=stones[-1] - stones[-2]\\n            stones[-2]=-1\\n            stones[-1]=temp\\n        return (stones[-1])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        for i in range(len(stones) - 1):\\n            stones.sort()\\n            stones.append(stones.pop() - stones.pop()) \\n        return stones[0]\\n\\t\\t\\n\\t\\t\\n\\t\\tFollow me for more intresting programming questions :\\n\\t\\t\\t\\t\\t\\t\\thttps://www.github.com/shubhamthrills\\n\\t\\t\\t\\t\\t\\t\\thttps://www.instagaram.com/shubhamthrills\\n\\t\\t\\t\\t\\t\\t\\thttps://www.linkedin.com/in/shubhamsagar\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\n#Another Possible approch [If you don\\'t want to decrease the length of loop every time]\\n\\n```\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        #stones=[2,7,4,1,8,1]\\n        for i in range(len(stones) - 1):\\n            stones.sort()\\n            temp=stones[-1] - stones[-2]\\n            stones[-2]=-1\\n            stones[-1]=temp\\n        return (stones[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921692,
                "title": "simple-solution-using-arraylist-java-self-explanatory",
                "content": "class Solution {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        \\n        ArrayList<Integer> ar = new ArrayList<>();\\n        \\n        for(int i=0;i<stones.length;i++){\\n            ar.add(stones[i]);\\n        }\\n        \\n       \\n       \\n        while(ar.size()>1){\\n             \\n        Collections.sort(ar);\\n            \\n            int y = ar.get(ar.size()-1);\\n            ar.remove(new Integer(y));\\n            \\n            int x = ar.get(ar.size()-1);\\n            ar.remove(new Integer(x));\\n            \\n            if(x!=y){\\n                ar.add(y-x);\\n            }\\n           \\n            \\n        }\\n        \\n        if(ar.isEmpty()){\\n            return 0;\\n        }else{\\n            return ar.get(0);\\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        \\n        ArrayList<Integer> ar = new ArrayList<>();\\n        \\n        for(int i=0;i<stones.length;i++){\\n            ar.add(stones[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 714283,
                "title": "easy-js-solution",
                "content": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while (stones.length > 1) {\\n        let max1 = Math.max(...stones);\\n        stones.splice(stones.indexOf(max1),1);\\n        let max2 = Math.max(...stones);\\n        stones.splice(stones.indexOf(max2),1);\\n        if (max1 !== max2) stones.push(Math.abs(max1-max2));       \\n    }\\n    return stones[0] || 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while (stones.length > 1) {\\n        let max1 = Math.max(...stones);\\n        stones.splice(stones.indexOf(max1),1);\\n        let max2 = Math.max(...stones);\\n        stones.splice(stones.indexOf(max2),1);\\n        if (max1 !== max2) stones.push(Math.abs(max1-max2));       \\n    }\\n    return stones[0] || 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575519,
                "title": "c-countsort-bucketsort-solution",
                "content": "Since range of the elements is limited to integers between 1 and 1000, we can easily extend a bucket sort / count sort technique to this problem.\\n\\n1. Keep count of elements (in say array `arr`) against the indexes derived from their values. So, if we see a value `x`, we increment `arr[x]`. Thus each index is marking the bucket of the index value.\\n2. Start from the highest index 1000 and gradually come down to the lowest index 1, smashing rocks along the way. I use two pointers `lo` and `hi` to point to the two rocks that will be smashed in the current iteration. If there are multiple occurrences of a rock, `lo` and `hi` might point to the same index / bucket.\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int arr[1010] = {0};\\n        \\n        for(auto num: stones)\\n            arr[num]++;\\n        \\n        int hi = 1000, lo = hi;\\n        while(lo > 0 && hi > 0) {\\n            while(hi > 0 && arr[hi] < 1)\\n                hi--;\\n            \\n            if(hi < 1)\\n                break;\\n            \\n            lo = arr[hi] > 1 ? hi : hi-1;\\n            while(lo > 0 && arr[lo] < 1)\\n                    lo--;\\n            \\n            if(lo < 1)\\n                break;\\n            \\n            // smash!\\n            arr[hi-lo]++;\\n            arr[hi]--;\\n            arr[lo]--;\\n        }\\n        \\n        return hi * (arr[hi] > 0);\\n    }\\n};\\n```\\n\\n+ Uses extra linear space in the order of the range of elements.\\n+ Runs in linear time in the order of the number of elements.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int arr[1010] = {0};\\n        \\n        for(auto num: stones)\\n            arr[num]++;\\n        \\n        int hi = 1000, lo = hi;\\n        while(lo > 0 && hi > 0) {\\n            while(hi > 0 && arr[hi] < 1)\\n                hi--;\\n            \\n            if(hi < 1)\\n                break;\\n            \\n            lo = arr[hi] > 1 ? hi : hi-1;\\n            while(lo > 0 && arr[lo] < 1)\\n                    lo--;\\n            \\n            if(lo < 1)\\n                break;\\n            \\n            // smash!\\n            arr[hi-lo]++;\\n            arr[hi]--;\\n            arr[lo]--;\\n        }\\n        \\n        return hi * (arr[hi] > 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498199,
                "title": "1046-javascript-recursive-one-liner",
                "content": "> Runtime: **64 ms**, faster than *52.83%* of JavaScript online submissions\\n> Memory Usage: **35.2 MB**, less than *100.00%* of JavaScript online submissions\\n\\n```\\nconst lastStoneWeight = s =>\\n  1 === s.length\\n    ? s[0]\\n    : lastStoneWeight(s.sort((a, b) => a - b).concat(s.pop() - s.pop()));\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nconst lastStoneWeight = s =>\\n  1 === s.length\\n    ? s[0]\\n    : lastStoneWeight(s.sort((a, b) => a - b).concat(s.pop() - s.pop()));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3448997,
                "title": "python3-easy-solution-with-explanation-quibler7",
                "content": "# Code\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        #first sort the list\\n        stones.sort()\\n\\n        while stones:\\n            #most heaviest stone\\n            s1 = stones.pop()\\n\\n            #if list is empty after removing one stone i.e s1 then \\n            #return s1\\n            if not stones: return s1\\n\\n            #second heaviest stone s2 where s2 <= s1\\n            s2 = stones.pop()\\n\\n            #if s1 > s2 then element to be inserted is s1-s2 as given in the \\n            #problem statement\\n            if s1 > s2:\\n\\n                #using Insort_left Function Of Bisect Module\\n                #we will insert s1-s2 at correct position \\n                insort_left(stones, s1-s2)\\n\\n            #else s1 == s2 and as we are continously popping elements \\n            #both the stones are destroyed if they are same\\n\\n        #if no more stones remaining return 0 \\n        return 0 \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        #first sort the list\\n        stones.sort()\\n\\n        while stones:\\n            #most heaviest stone\\n            s1 = stones.pop()\\n\\n            #if list is empty after removing one stone i.e s1 then \\n            #return s1\\n            if not stones: return s1\\n\\n            #second heaviest stone s2 where s2 <= s1\\n            s2 = stones.pop()\\n\\n            #if s1 > s2 then element to be inserted is s1-s2 as given in the \\n            #problem statement\\n            if s1 > s2:\\n\\n                #using Insort_left Function Of Bisect Module\\n                #we will insert s1-s2 at correct position \\n                insort_left(stones, s1-s2)\\n\\n            #else s1 == s2 and as we are continously popping elements \\n            #both the stones are destroyed if they are same\\n\\n        #if no more stones remaining return 0 \\n        return 0 \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921076,
                "title": "java-easy-and-fast-solution",
                "content": "\\n\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        int count = stones.length-1;\\n        while(count!=0)\\n        {\\n            if(stones[stones.length-1]==stones[stones.length-2])\\n            {\\n                stones[stones.length-1]=0;\\n                stones[stones.length-2]=0;\\n            }\\n            if(stones[stones.length-1]!=stones[stones.length-2])\\n            {\\n                stones[stones.length-1]=stones[stones.length-1] - stones[stones.length-2];\\n                stones[stones.length-2]=0;\\n            }\\n            Arrays.sort(stones);\\n            count--;\\n        }\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n \\xA0 \\xA0return stones[stones.length-1]\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        int count = stones.length-1;\\n        while(count!=0)\\n        {\\n            if(stones[stones.length-1]==stones[stones.length-2])\\n            {\\n                stones[stones.length-1]=0;\\n                stones[stones.length-2]=0;\\n            }\\n            if(stones[stones.length-1]!=stones[stones.length-2])\\n            {\\n                stones[stones.length-1]=stones[stones.length-1] - stones[stones.length-2];\\n                stones[stones.length-2]=0;\\n            }\\n            Arrays.sort(stones);\\n            count--;\\n        }\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n \\xA0 \\xA0return stones[stones.length-1]\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772788,
                "title": "go-heap-solution",
                "content": "Cause all I do is dance.\\n```\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int {return len(h)}\\nfunc (h IntHeap) Less(i, j int) bool {return h[i] > h[j]}\\nfunc (h IntHeap) Swap(i, j int) {h[i], h[j] = h[j], h[i]}\\nfunc (h *IntHeap) Push(x interface{}) {*h = append(*h, x.(int))}\\nfunc (h *IntHeap) Pop() interface{} {\\n    n := len(*h)\\n    x := (*h)[n-1]\\n    *h = (*h)[0:n-1]\\n    return x\\n}\\n\\nfunc lastStoneWeight(stones []int) int {\\n    pq := IntHeap(stones)\\n    heap.Init(&pq)\\n    for pq.Len() > 1 {\\n        x, y := heap.Pop(&pq).(int), heap.Pop(&pq).(int)\\n        if x != y {\\n            heap.Push(&pq, x-y)\\n        }\\n    }\\n    \\n    if pq.Len() == 0 {\\n        return 0\\n    }\\n    \\n    return heap.Pop(&pq).(int)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int {return len(h)}\\nfunc (h IntHeap) Less(i, j int) bool {return h[i] > h[j]}\\nfunc (h IntHeap) Swap(i, j int) {h[i], h[j] = h[j], h[i]}\\nfunc (h *IntHeap) Push(x interface{}) {*h = append(*h, x.(int))}\\nfunc (h *IntHeap) Pop() interface{} {\\n    n := len(*h)\\n    x := (*h)[n-1]\\n    *h = (*h)[0:n-1]\\n    return x\\n}\\n\\nfunc lastStoneWeight(stones []int) int {\\n    pq := IntHeap(stones)\\n    heap.Init(&pq)\\n    for pq.Len() > 1 {\\n        x, y := heap.Pop(&pq).(int), heap.Pop(&pq).(int)\\n        if x != y {\\n            heap.Push(&pq, x-y)\\n        }\\n    }\\n    \\n    if pq.Len() == 0 {\\n        return 0\\n    }\\n    \\n    return heap.Pop(&pq).(int)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3450508,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while len(stones)>1:\\n            y=stones.pop(-1)\\n            x=stones.pop(-1)\\n            if x!=y:\\n                stones.append(y-x)\\n            stones.sort()\\n        return stones[0] if len(stones)>=1 else 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while len(stones)>1:\\n            y=stones.pop(-1)\\n            x=stones.pop(-1)\\n            if x!=y:\\n                stones.append(y-x)\\n            stones.sort()\\n        return stones[0] if len(stones)>=1 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449734,
                "title": "python-elegant-short-max-heap",
                "content": "# Complexity\\n- Time complexity: $$O(n * \\\\log_2 {n})$$\\n- Space complexity: $$O(n)$$\\n\\n# Maximum heap code\\n```\\nclass MaxHeap:\\n    def __init__(self, data: List[int]):\\n        self.data = [-num for num in data]\\n        heapq.heapify(self.data)\\n\\n    def push(self, item: int):\\n        heapq.heappush(self.data, -item)\\n\\n    def pop(self) -> int:\\n        return -heapq.heappop(self.data)\\n\\n    def __len__(self) -> int:\\n        return len(self.data)\\n\\n    def __bool__(self) -> bool:\\n        return len(self) != 0\\n```\\n\\n# Solution code\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heap = MaxHeap(stones)\\n\\n        while len(heap) > 1:\\n            first, second = heap.pop(), heap.pop()\\n            if first != second:\\n                heap.push(abs(first - second))\\n\\n        return heap.pop() if heap else 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MaxHeap:\\n    def __init__(self, data: List[int]):\\n        self.data = [-num for num in data]\\n        heapq.heapify(self.data)\\n\\n    def push(self, item: int):\\n        heapq.heappush(self.data, -item)\\n\\n    def pop(self) -> int:\\n        return -heapq.heappop(self.data)\\n\\n    def __len__(self) -> int:\\n        return len(self.data)\\n\\n    def __bool__(self) -> bool:\\n        return len(self) != 0\\n```\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heap = MaxHeap(stones)\\n\\n        while len(heap) > 1:\\n            first, second = heap.pop(), heap.pop()\\n            if first != second:\\n                heap.push(abs(first - second))\\n\\n        return heap.pop() if heap else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449269,
                "title": "easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while True:\\n            stones = sorted(stones,reverse = True)\\n            if len(stones) == 1:\\n                return stones[0]\\n            elif len(stones) == 0:\\n                return 0\\n            first = stones.pop(0)\\n            sec = stones.pop(0)\\n            if first == sec:\\n                continue\\n            else:\\n                stones.append(first-sec)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while True:\\n            stones = sorted(stones,reverse = True)\\n            if len(stones) == 1:\\n                return stones[0]\\n            elif len(stones) == 0:\\n                return 0\\n            first = stones.pop(0)\\n            sec = stones.pop(0)\\n            if first == sec:\\n                continue\\n            else:\\n                stones.append(first-sec)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593690,
                "title": "js-heap-easy-understanding",
                "content": "Solution 1 - O(n^2*logn)\\n\\n```\\nvar lastStoneWeight = function(stones) {\\n\\n    while(stones.length > 1) {\\n        stones.sort((a, b) => a - b);\\n        let x = stones.pop();\\n        let y = stones.pop();\\n        \\n        if(x === y) continue;\\n        else stones.push(Math.abs(x - y));\\n    }\\n    \\n    return stones;\\n}\\n```\\n\\nSolution 2 - O(n*logn)\\n\\n```\\nclass Heap {\\n    constructor(stones) {\\n        this.heap = stones;\\n        this.size = stones.length;\\n        this.heapify(0);\\n    }\\n    right(pos) {\\n        return 2 * pos + 2;\\n    }\\n    left(pos) {\\n        return 2 * pos + 1;\\n    }\\n    isleaf(pos) {\\n        if (2 * pos + 1 >= this.size) return true;\\n        return false;\\n    }\\n    swap(a, b) {\\n        let temp = this.heap[a];\\n        this.heap[a] = this.heap[b];\\n        this.heap[b] = temp;\\n    }\\n    fix(pos) {\\n        if (this.isleaf(pos)) return;\\n        let left = this.left(pos);\\n        let right = this.right(pos);\\n        let bigger = left;\\n        if (right < this.size)\\n            bigger = this.heap[left] > this.heap[right] ? left : right;\\n        if (this.heap[pos] < this.heap[bigger]) {\\n            this.swap(pos, bigger);\\n            this.fix(bigger);\\n        }\\n    }\\n    heapify(pos) {\\n        if (this.isleaf(pos)) return;\\n        this.heapify(this.left(pos));\\n        this.heapify(this.right(pos));\\n        this.fix(pos);\\n    }\\n    delete() {\\n        this.swap(0, --this.size);\\n        this.fix(0);\\n        return this.heap[0];\\n    }\\n    insert(val) {\\n        this.size++;\\n        this.heap[this.size - 1] = val;\\n        this.heapify(0);\\n    }\\n    peek() {\\n        return this.heap[0];\\n    }\\n}\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function (stones) {\\n    const heap = new Heap(stones);\\n    while (heap.size > 1) {\\n        let x = heap.peek();\\n        heap.delete();\\n        let y = heap.peek();\\n        heap.delete();\\n        const res = x - y;\\n        if (res > 0) heap.insert(res);\\n    }\\n    if (heap.size) return heap.peek();\\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar lastStoneWeight = function(stones) {\\n\\n    while(stones.length > 1) {\\n        stones.sort((a, b) => a - b);\\n        let x = stones.pop();\\n        let y = stones.pop();\\n        \\n        if(x === y) continue;\\n        else stones.push(Math.abs(x - y));\\n    }\\n    \\n    return stones;\\n}\\n```\n```\\nclass Heap {\\n    constructor(stones) {\\n        this.heap = stones;\\n        this.size = stones.length;\\n        this.heapify(0);\\n    }\\n    right(pos) {\\n        return 2 * pos + 2;\\n    }\\n    left(pos) {\\n        return 2 * pos + 1;\\n    }\\n    isleaf(pos) {\\n        if (2 * pos + 1 >= this.size) return true;\\n        return false;\\n    }\\n    swap(a, b) {\\n        let temp = this.heap[a];\\n        this.heap[a] = this.heap[b];\\n        this.heap[b] = temp;\\n    }\\n    fix(pos) {\\n        if (this.isleaf(pos)) return;\\n        let left = this.left(pos);\\n        let right = this.right(pos);\\n        let bigger = left;\\n        if (right < this.size)\\n            bigger = this.heap[left] > this.heap[right] ? left : right;\\n        if (this.heap[pos] < this.heap[bigger]) {\\n            this.swap(pos, bigger);\\n            this.fix(bigger);\\n        }\\n    }\\n    heapify(pos) {\\n        if (this.isleaf(pos)) return;\\n        this.heapify(this.left(pos));\\n        this.heapify(this.right(pos));\\n        this.fix(pos);\\n    }\\n    delete() {\\n        this.swap(0, --this.size);\\n        this.fix(0);\\n        return this.heap[0];\\n    }\\n    insert(val) {\\n        this.size++;\\n        this.heap[this.size - 1] = val;\\n        this.heapify(0);\\n    }\\n    peek() {\\n        return this.heap[0];\\n    }\\n}\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function (stones) {\\n    const heap = new Heap(stones);\\n    while (heap.size > 1) {\\n        let x = heap.peek();\\n        heap.delete();\\n        let y = heap.peek();\\n        heap.delete();\\n        const res = x - y;\\n        if (res > 0) heap.insert(res);\\n    }\\n    if (heap.size) return heap.peek();\\n    return 0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921399,
                "title": "c-100-shortest-and-easiest-without-using-any-data-structure",
                "content": "```\\n\\u2714without using priority_queue\\n\\u2714all you need to do is sorting the array each time you modify it.\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>&s) {\\n        sort(s.begin(),s.end());\\n        while(s.size()>1){\\n            int i=s.size()-1;\\n            int x=s[i],y=s[i-1];\\n            s.pop_back();\\n            s.pop_back();\\n            if(x!=y)s.push_back(x-y);\\n            sort(s.begin(),s.end());\\n        }\\n        if(s.size()==0)return 0;\\n        return s[0];\\n    }\\n};\\n```\\nUPVOTE IF YOU LIKE IT!!\\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n\\u2714without using priority_queue\\n\\u2714all you need to do is sorting the array each time you modify it.\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>&s) {\\n        sort(s.begin(),s.end());\\n        while(s.size()>1){\\n            int i=s.size()-1;\\n            int x=s[i],y=s[i-1];\\n            s.pop_back();\\n            s.pop_back();\\n            if(x!=y)s.push_back(x-y);\\n            sort(s.begin(),s.end());\\n        }\\n        if(s.size()==0)return 0;\\n        return s[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576377,
                "title": "python-solution-using-recursion",
                "content": "```\\nclass Solution:\\n    def lastStoneWeight(self, nums: List[int]) -> int:        \\n        if not nums:\\n            return 0\\n        \\n        elif len(nums) == 1:\\n            return nums[0]\\n        \\n        elif len(nums) == 2:\\n            return abs(nums[0] - nums[1])\\n        \\n        else:\\n            max1 = max(nums)\\n            nums.remove(max1)\\n            max2 = max(nums)\\n            nums.remove(max2)\\n        \\n            if max1 != max2:\\n                val = abs(max1-max2)\\n                nums.append(val)\\n\\n        val = self.lastStoneWeight(nums)\\n        return val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, nums: List[int]) -> int:        \\n        if not nums:\\n            return 0\\n        \\n        elif len(nums) == 1:\\n            return nums[0]\\n        \\n        elif len(nums) == 2:\\n            return abs(nums[0] - nums[1])\\n        \\n        else:\\n            max1 = max(nums)\\n            nums.remove(max1)\\n            max2 = max(nums)\\n            nums.remove(max2)\\n        \\n            if max1 != max2:\\n                val = abs(max1-max2)\\n                nums.append(val)\\n\\n        val = self.lastStoneWeight(nums)\\n        return val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360024,
                "title": "o-nlogn-and-o-n-algo",
                "content": "O(n*log(n)) Using Priority Queue\\nO(n) bucket sort\\n * Runtime: 1 ms, faster than 97.26% of Java online submissions for Last Stone Weight.\\n * Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.\\n\\n\\nPriorith Queue:\\n```\\n\\n/**\\n * O(n*log(n))\\n * Runtime: 1 ms, faster than 97.26% of Java online submissions for Last Stone Weight.\\n * Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.\\n */\\nclass LastStoneWeightPriorityQueue {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        if (null == stones || stones.length == 0)\\n            return 0;\\n\\n        System.out.println(Printer.toString(stones));\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for (int i = 0; i < stones.length; i++)\\n            pq.offer(stones[i]);\\n\\n        while (pq.size() >= 2) {\\n\\n            int s1 = pq.poll();\\n            int s2 = pq.poll();\\n\\n            if (s1 != s2)\\n                pq.offer(s1 - s2);\\n\\n        }\\n\\n        /*\\n        for (int i = 0; i < stones.length - 1; ++i)\\n            pq.offer(pq.poll() - pq.poll());\\n        return pq.poll();\\n         */\\n\\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n}\\n```\\n\\nBucket Sort: O(n)\\n\\n\\n```\\n\\n/**\\n * We can apply bucket sort to make it work in linear time.\\n * Since\\n * 1 <= stones.length <= 30\\n * 1 <= stones[i] <= 1000\\n * Algorithm:\\n * 1. Find the maximum value in the stones array.\\n * 2. Create that many buckets; bucket[max]\\n * 3. Count the frequency of each bucket\\n * 4. Run backward from bucket for each element from max to 0\\n * <p>\\n * a. if this bucket has even frequency; then they will destroy each other; move back\\n * b. If this bucket has odd frequency[i]; then we need to find another bucket[j] and then update the bucket whose value is [i-j]+1\\n * As well decrease the frequency of this buckets as we used both of the stones.\\n * <p>\\n * Keep doing this, at the end the bucket which has frequency > 0 and its odd is your value.\\n * <p>\\n *\\n * <p>\\n * Complexity:\\n * Space: O(max) ; since 1 <= stones[i] <= 1000 then O(1000) is constant => O(1)\\n * <p>\\n * Time: O(n) {bucket frequency} + the maximum value of stones= 1000 and the max length of stones is 30 [1 <= stones.length <= 30[.\\n * In wost scenario; all stones are duplicate Or unique or flatten like [1,1,1,1,1000]\\n * <p>\\n * at max the loop will run 1000 time. Hence constant\\n * <p>\\n * Space: O(1)\\n * Time: O(n+1000) => O(n)\\n * <p>\\n * * Runtime: 1 ms, faster than 97.26% of Java online submissions for Last Stone Weight.\\n * * Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.\\n */\\nclass LastStoneWeightBucketSort {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        if (null == stones || stones.length == 0)\\n            return 0;\\n\\n        /**\\n         * Find Max\\n         */\\n        int max = 0;\\n        for (int i = 0; i < stones.length; i++)\\n            max = Math.max(max, stones[i]);\\n\\n        /**\\n         * Create \\'max\\' number of buckets; max+1 since array has max as value\\n         */\\n        int buckets[] = new int[max + 1];\\n\\n        /**\\n         * Count frequency\\n         */\\n        for (int i = 0; i < stones.length; i++)\\n            buckets[stones[i]]++;\\n\\n\\n        int i = max;\\n        int lastJ = max;\\n\\n        /**\\n         * Run backward\\n         */\\n        while (i > 0) {\\n\\n            /**\\n             * If this weight store is present\\n             */\\n            if (buckets[i] > 0) {\\n\\n                /**\\n                 * if frequency = even, they will destroy each other\\n                 */\\n                if (buckets[i] % 2 == 0) {\\n                    buckets[i] = 0;\\n                    i--;\\n                    continue;\\n                } else {\\n                    /**\\n                     * Otherwise find a stone whose frequency is not 0\\n                     */\\n                    int j = i - 1 > lastJ ? lastJ : i - 1;\\n                    while (j > 0 && buckets[j] == 0) j--;\\n\\n                    /**\\n                     * If no bucket left, then [i] is last stone\\n                     */\\n                    if (j == 0) {\\n                        return i;\\n//                        break;\\n                    } else {\\n                        lastJ = j;\\n\\n                        /**\\n                         * Utilize both of the stones\\n                         */\\n                        buckets[j]--;\\n                        buckets[i]--;\\n\\n                        /**\\n                         * create a new stone of i-j difference\\n                         */\\n                        buckets[i - j]++;\\n\\n\\n                        if (i - j > j) {\\n                            i = i - j;\\n                        } else {\\n                            i = j;\\n                        }\\n\\n                    }\\n                }\\n            } else\\n                i--;\\n        }\\n\\n\\n//        for (int x = 0; x < buckets.length; x++)\\n//            if (buckets[x] > 0 && buckets[x] % 2 != 0)\\n//                return x;\\n\\n        return 0;\\n    }\\n}\\n```\\n\\nworst case like \\n[1,1,1,1,1,1000] in this case the while(i>0) will run 1000^2 times if we don\\'t cache lastJ otherwise 1000 times and if (j==0) then i will be surely that last element where >0 frequency is there \\n",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * O(n*log(n))\\n * Runtime: 1 ms, faster than 97.26% of Java online submissions for Last Stone Weight.\\n * Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.\\n */\\nclass LastStoneWeightPriorityQueue {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        if (null == stones || stones.length == 0)\\n            return 0;\\n\\n        System.out.println(Printer.toString(stones));\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for (int i = 0; i < stones.length; i++)\\n            pq.offer(stones[i]);\\n\\n        while (pq.size() >= 2) {\\n\\n            int s1 = pq.poll();\\n            int s2 = pq.poll();\\n\\n            if (s1 != s2)\\n                pq.offer(s1 - s2);\\n\\n        }\\n\\n        /*\\n        for (int i = 0; i < stones.length - 1; ++i)\\n            pq.offer(pq.poll() - pq.poll());\\n        return pq.poll();\\n         */\\n\\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n}\\n```\n```\\n\\n/**\\n * We can apply bucket sort to make it work in linear time.\\n * Since\\n * 1 <= stones.length <= 30\\n * 1 <= stones[i] <= 1000\\n * Algorithm:\\n * 1. Find the maximum value in the stones array.\\n * 2. Create that many buckets; bucket[max]\\n * 3. Count the frequency of each bucket\\n * 4. Run backward from bucket for each element from max to 0\\n * <p>\\n * a. if this bucket has even frequency; then they will destroy each other; move back\\n * b. If this bucket has odd frequency[i]; then we need to find another bucket[j] and then update the bucket whose value is [i-j]+1\\n * As well decrease the frequency of this buckets as we used both of the stones.\\n * <p>\\n * Keep doing this, at the end the bucket which has frequency > 0 and its odd is your value.\\n * <p>\\n *\\n * <p>\\n * Complexity:\\n * Space: O(max) ; since 1 <= stones[i] <= 1000 then O(1000) is constant => O(1)\\n * <p>\\n * Time: O(n) {bucket frequency} + the maximum value of stones= 1000 and the max length of stones is 30 [1 <= stones.length <= 30[.\\n * In wost scenario; all stones are duplicate Or unique or flatten like [1,1,1,1,1000]\\n * <p>\\n * at max the loop will run 1000 time. Hence constant\\n * <p>\\n * Space: O(1)\\n * Time: O(n+1000) => O(n)\\n * <p>\\n * * Runtime: 1 ms, faster than 97.26% of Java online submissions for Last Stone Weight.\\n * * Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.\\n */\\nclass LastStoneWeightBucketSort {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        if (null == stones || stones.length == 0)\\n            return 0;\\n\\n        /**\\n         * Find Max\\n         */\\n        int max = 0;\\n        for (int i = 0; i < stones.length; i++)\\n            max = Math.max(max, stones[i]);\\n\\n        /**\\n         * Create \\'max\\' number of buckets; max+1 since array has max as value\\n         */\\n        int buckets[] = new int[max + 1];\\n\\n        /**\\n         * Count frequency\\n         */\\n        for (int i = 0; i < stones.length; i++)\\n            buckets[stones[i]]++;\\n\\n\\n        int i = max;\\n        int lastJ = max;\\n\\n        /**\\n         * Run backward\\n         */\\n        while (i > 0) {\\n\\n            /**\\n             * If this weight store is present\\n             */\\n            if (buckets[i] > 0) {\\n\\n                /**\\n                 * if frequency = even, they will destroy each other\\n                 */\\n                if (buckets[i] % 2 == 0) {\\n                    buckets[i] = 0;\\n                    i--;\\n                    continue;\\n                } else {\\n                    /**\\n                     * Otherwise find a stone whose frequency is not 0\\n                     */\\n                    int j = i - 1 > lastJ ? lastJ : i - 1;\\n                    while (j > 0 && buckets[j] == 0) j--;\\n\\n                    /**\\n                     * If no bucket left, then [i] is last stone\\n                     */\\n                    if (j == 0) {\\n                        return i;\\n//                        break;\\n                    } else {\\n                        lastJ = j;\\n\\n                        /**\\n                         * Utilize both of the stones\\n                         */\\n                        buckets[j]--;\\n                        buckets[i]--;\\n\\n                        /**\\n                         * create a new stone of i-j difference\\n                         */\\n                        buckets[i - j]++;\\n\\n\\n                        if (i - j > j) {\\n                            i = i - j;\\n                        } else {\\n                            i = j;\\n                        }\\n\\n                    }\\n                }\\n            } else\\n                i--;\\n        }\\n\\n\\n//        for (int x = 0; x < buckets.length; x++)\\n//            if (buckets[x] > 0 && buckets[x] % 2 != 0)\\n//                return x;\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450031,
                "title": "two-appraoches-heapq-and-sorting",
                "content": "# Heap  Approach : TC : (NLogN)\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        list1=[-x for x in stones]\\n        while len(list1)>1:\\n            heapq.heapify(list1)\\n            a,b=heapq.heappop(list1),heapq.heappop(list1)\\n            heapq.heappush(list1,-(abs(a-b)))\\n        return abs(list1[0])\\n```\\n# Sorting Approach ,TC:---->N*(N*LogN)\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones)>1:\\n            stones.sort()\\n            a,b=stones.pop(),stones.pop()\\n            stones.append(abs(a-b))\\n        return stones[0]\\n````\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        list1=[-x for x in stones]\\n        while len(list1)>1:\\n            heapq.heapify(list1)\\n            a,b=heapq.heappop(list1),heapq.heappop(list1)\\n            heapq.heappush(list1,-(abs(a-b)))\\n        return abs(list1[0])\\n```\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones)>1:\\n            stones.sort()\\n            a,b=stones.pop(),stones.pop()\\n            stones.append(abs(a-b))\\n        return stones[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449192,
                "title": "100-beats-easy-c-solution-just-see-for-yourself",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsort in descending order and going through the first two elements and repeating the process.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is very simple. Follow the following steps to understand the approach.\\n\\n1)Sort the stones vector in descending order.\\n2)store the difference of first two numbers(stones[0] and stones[1]) in res.\\n3)If res is 0 then remove stones[0] and stones[1]. If res is not equal to zero which is a positve integer, then remove the front element in the vector and replace the res value with front element in the vector. (Since we need to remove 1st two elements and push the positve integer, instead of that am removing one element and replacing the other).\\n4)Repeat the steps until stones vector is having atleast 2 elements.\\n5)If there is an element in the stones vector, then that is our answer else return 0.\\n\\n# Complexity\\n- Time complexity: O(N*NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        sort(stones.begin(), stones.end(), greater<int>());\\n        int i = 0;\\n        while (i<stones.size() && (i+1)<stones.size()){\\n            int res = stones[i] - stones[i+1];\\n            if (res != 0){\\n                stones.erase(stones.begin());\\n                stones[0] = res;\\n                sort(stones.begin(), stones.end(), greater<int>());\\n            }\\n            else{\\n                stones.erase(stones.begin(), stones.begin()+2);\\n            }\\n        }\\n        if (stones.size()){\\n            return stones[0];\\n        }\\n        return 0;\\n    }\\n};\\n\\n//                         (sorted)         (updated vector)\\n//[2, 7, 4, 1, 8, 1] = [8, 7, 4, 2, 1, 1] -> [1, 4, 2, 1, 1] = [4, 2, 1, 1, 1] ->\\n// [2, 1, 1, 1] -> [1, 1, 1] -> \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        sort(stones.begin(), stones.end(), greater<int>());\\n        int i = 0;\\n        while (i<stones.size() && (i+1)<stones.size()){\\n            int res = stones[i] - stones[i+1];\\n            if (res != 0){\\n                stones.erase(stones.begin());\\n                stones[0] = res;\\n                sort(stones.begin(), stones.end(), greater<int>());\\n            }\\n            else{\\n                stones.erase(stones.begin(), stones.begin()+2);\\n            }\\n        }\\n        if (stones.size()){\\n            return stones[0];\\n        }\\n        return 0;\\n    }\\n};\\n\\n//                         (sorted)         (updated vector)\\n//[2, 7, 4, 1, 8, 1] = [8, 7, 4, 2, 1, 1] -> [1, 4, 2, 1, 1] = [4, 2, 1, 1, 1] ->\\n// [2, 1, 1, 1] -> [1, 1, 1] -> \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448759,
                "title": "easy-java-soluton-using-priorityqueue-with-explanation-intuition",
                "content": "# PLEASE UPVOTE\\n\\n![Screenshot 2023-04-24 at 06.29.54.png](https://assets.leetcode.com/users/images/877f6529-7103-45dc-a713-d2c71c40566d_1682298023.9539728.png)\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Priority Queue to sort at every operation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Inserting the whole array to Priorty Queue,\\n2. Popping the first two elements from the pq (MAX and second MAX),\\n3. adding the difference back to pq,\\n4. repeating 2 & 3.\\n5. return max when loop completes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n*sorting at every input and operation.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0;i<stones.length;i++){\\n            pq.add(stones[i]);\\n        }\\n        int p,q;\\n        while(pq.size()>1){\\n            p=pq.poll();\\n            q=pq.poll();\\n            // System.out.println(\\xF7p+\" \"+q);\\n            pq.add(p-q);\\n        }\\n        return pq.poll();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0;i<stones.length;i++){\\n            pq.add(stones[i]);\\n        }\\n        int p,q;\\n        while(pq.size()>1){\\n            p=pq.poll();\\n            q=pq.poll();\\n            // System.out.println(\\xF7p+\" \"+q);\\n            pq.add(p-q);\\n        }\\n        return pq.poll();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314775,
                "title": "c-priorityqueue-net6",
                "content": "Use c# PriorityQueue\\n\\n```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        PriorityQueue<int, int> queue = new();\\n        foreach(int s in stones)\\n        {\\n            queue.Enqueue(s,-s);\\n        }\\n        while(queue.Count >1)\\n        {\\n            int stone1 = queue.Dequeue();\\n            int stone2 = queue.Dequeue();\\n            if(stone1 != stone2)\\n            {\\n                int newStone = stone1 - stone2;\\n                newStone = newStone > 0 ? newStone : newStone * -1;\\n                queue.Enqueue(newStone, -newStone);\\n            }\\n        }\\n        if(queue.Count ==0)\\n        {\\n            return 0;\\n        }\\n        return queue.Dequeue();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        PriorityQueue<int, int> queue = new();\\n        foreach(int s in stones)\\n        {\\n            queue.Enqueue(s,-s);\\n        }\\n        while(queue.Count >1)\\n        {\\n            int stone1 = queue.Dequeue();\\n            int stone2 = queue.Dequeue();\\n            if(stone1 != stone2)\\n            {\\n                int newStone = stone1 - stone2;\\n                newStone = newStone > 0 ? newStone : newStone * -1;\\n                queue.Enqueue(newStone, -newStone);\\n            }\\n        }\\n        if(queue.Count ==0)\\n        {\\n            return 0;\\n        }\\n        return queue.Dequeue();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661271,
                "title": "c-88",
                "content": "```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        List<int> stoneList = new List<int>(stones);\\n        return stoneHelper(stoneList);\\n    }\\n    \\n    public int stoneHelper(List<int> stones) {\\n        \\n        if(stones.Count == 0 )\\n            return 0;\\n        else if (stones.Count == 1)\\n            return stones[0];\\n        else  {\\n            int max = stones.Max();\\n            stones.Remove(max);\\n            \\n            int sMax = stones.Max();\\n            stones.Remove(sMax);\\n\\n            if (sMax < max) {\\n                stones.Add(max-sMax);\\n            }\\n            return stoneHelper(stones); \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        List<int> stoneList = new List<int>(stones);\\n        return stoneHelper(stoneList);\\n    }\\n    \\n    public int stoneHelper(List<int> stones) {\\n        \\n        if(stones.Count == 0 )\\n            return 0;\\n        else if (stones.Count == 1)\\n            return stones[0];\\n        else  {\\n            int max = stones.Max();\\n            stones.Remove(max);\\n            \\n            int sMax = stones.Max();\\n            stones.Remove(sMax);\\n\\n            if (sMax < max) {\\n                stones.Add(max-sMax);\\n            }\\n            return stoneHelper(stones); \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518940,
                "title": "javascript-priority-queue-solution-o-n",
                "content": "```javascript\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n  const heap = new MaxHeap(stones);\\n  while (heap.size() > 1) {\\n    const max1 = heap.poll();\\n    const max2 = heap.poll();\\n    if (max1 > max2) heap.offer(max1 - max2);\\n  }\\n  return heap.size() === 1 ? heap.poll() : 0;\\n};\\n\\nclass MaxHeap {\\n  constructor(data = []) {\\n    this.data = data;\\n    this.comparator = (a, b) => b - a;\\n    this.heapify();\\n  }\\n\\n  // O(nlog(n)). In fact, O(n)\\n  heapify() {\\n    if (this.size() < 2) return;\\n    for (let i = 1; i < this.size(); i++) {\\n      this.bubbleUp(i);\\n    }\\n  }\\n\\n  // O(1)\\n  peek() {\\n    if (this.size() === 0) return null;\\n    return this.data[0];\\n  }\\n\\n  // O(log(n))\\n  offer(value) {\\n    this.data.push(value);\\n    this.bubbleUp(this.size() - 1);\\n  }\\n\\n  // O(log(n))\\n  poll() {\\n    if (this.size() === 0) return null;\\n    const result = this.data[0];\\n    const last = this.data.pop();\\n    if (this.size() !== 0) {\\n      this.data[0] = last;\\n      this.bubbleDown(0);\\n    }\\n    return result;\\n  }\\n\\n  // O(log(n))\\n  bubbleUp(index) {\\n    while (index > 0) {\\n      const parentIndex = (index - 1) >> 1;\\n      if (this.comparator(this.data[index], this.data[parentIndex]) < 0) {\\n        this.swap(index, parentIndex);\\n        index = parentIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(log(n))\\n  bubbleDown(index) {\\n    const lastIndex = this.size() - 1;\\n    while (true) {\\n      const leftIndex = index * 2 + 1;\\n      const rightIndex = index * 2 + 2;\\n      let findIndex = index;\\n      if (\\n        leftIndex <= lastIndex &&\\n        this.comparator(this.data[leftIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = leftIndex;\\n      }\\n      if (\\n        rightIndex <= lastIndex &&\\n        this.comparator(this.data[rightIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = rightIndex;\\n      }\\n      if (index !== findIndex) {\\n        this.swap(index, findIndex);\\n        index = findIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(1)\\n  swap(index1, index2) {\\n    [this.data[index1], this.data[index2]] = [\\n      this.data[index2],\\n      this.data[index1]\\n    ];\\n  }\\n\\n  // O(1)\\n  size() {\\n    return this.data.length;\\n  }\\n}\\n```\\n\\n* 70/70 cases passed (56 ms)\\n* Your runtime beats 84.25 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (35 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n  const heap = new MaxHeap(stones);\\n  while (heap.size() > 1) {\\n    const max1 = heap.poll();\\n    const max2 = heap.poll();\\n    if (max1 > max2) heap.offer(max1 - max2);\\n  }\\n  return heap.size() === 1 ? heap.poll() : 0;\\n};\\n\\nclass MaxHeap {\\n  constructor(data = []) {\\n    this.data = data;\\n    this.comparator = (a, b) => b - a;\\n    this.heapify();\\n  }\\n\\n  // O(nlog(n)). In fact, O(n)\\n  heapify() {\\n    if (this.size() < 2) return;\\n    for (let i = 1; i < this.size(); i++) {\\n      this.bubbleUp(i);\\n    }\\n  }\\n\\n  // O(1)\\n  peek() {\\n    if (this.size() === 0) return null;\\n    return this.data[0];\\n  }\\n\\n  // O(log(n))\\n  offer(value) {\\n    this.data.push(value);\\n    this.bubbleUp(this.size() - 1);\\n  }\\n\\n  // O(log(n))\\n  poll() {\\n    if (this.size() === 0) return null;\\n    const result = this.data[0];\\n    const last = this.data.pop();\\n    if (this.size() !== 0) {\\n      this.data[0] = last;\\n      this.bubbleDown(0);\\n    }\\n    return result;\\n  }\\n\\n  // O(log(n))\\n  bubbleUp(index) {\\n    while (index > 0) {\\n      const parentIndex = (index - 1) >> 1;\\n      if (this.comparator(this.data[index], this.data[parentIndex]) < 0) {\\n        this.swap(index, parentIndex);\\n        index = parentIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(log(n))\\n  bubbleDown(index) {\\n    const lastIndex = this.size() - 1;\\n    while (true) {\\n      const leftIndex = index * 2 + 1;\\n      const rightIndex = index * 2 + 2;\\n      let findIndex = index;\\n      if (\\n        leftIndex <= lastIndex &&\\n        this.comparator(this.data[leftIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = leftIndex;\\n      }\\n      if (\\n        rightIndex <= lastIndex &&\\n        this.comparator(this.data[rightIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = rightIndex;\\n      }\\n      if (index !== findIndex) {\\n        this.swap(index, findIndex);\\n        index = findIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(1)\\n  swap(index1, index2) {\\n    [this.data[index1], this.data[index2]] = [\\n      this.data[index2],\\n      this.data[index1]\\n    ];\\n  }\\n\\n  // O(1)\\n  size() {\\n    return this.data.length;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494982,
                "title": "rust-binary-heap",
                "content": "```\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        let mut heap = BinaryHeap::from(stones);\\n        while let Some(stone) = heap.pop() {\\n            match heap.pop() {\\n                Some(val)   => heap.push(stone - val),\\n                None        => return stone,\\n            }       \\n        }\\n        return 0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        let mut heap = BinaryHeap::from(stones);\\n        while let Some(stone) = heap.pop() {\\n            match heap.pop() {\\n                Some(val)   => heap.push(stone - val),\\n                None        => return stone,\\n            }       \\n        }\\n        return 0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3036497,
                "title": "java-don-t-worry-my-solution-is-best-100-92-39-6-mb",
                "content": "\\t*   class Solution {\\n\\t\\t\\tpublic  int lastStoneWeight(int[] stones) {\\n\\t\\t\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tfor (int a : stones) {\\n\\t\\t\\t\\t\\tlist.add(a);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tCollections.sort(list);\\n\\t\\t\\t\\twhile (list.size() > 1) {\\n\\t\\t\\t\\t\\tint a = list.size();\\n\\t\\t\\t\\t\\tif (list.get(a - 1) > list.get(a - 2)) {\\n\\t\\t\\t\\t\\t\\tlist.add(( list.get(a - 1) -list.get(a - 2)));\\n\\t\\t\\t\\t\\t\\tlist.remove(a-2);\\n\\t\\t\\t\\t\\t\\tlist.remove(a-2);\\n\\t\\t\\t\\t\\t\\tCollections.sort(list);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tlist.remove(a - 1);\\n\\t\\t\\t\\t\\t\\tlist.remove(a -2);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (list.size()==1){\\n\\t\\t\\t\\t\\treturn list.get(0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic  int lastStoneWeight(int[] stones) {\\n\\t\\t\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tfor (int a : stones) {\\n\\t\\t\\t\\t\\tlist.add(a);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2825881,
                "title": "java-runtime-1ms-faster-than-99-49-queue-and-iterative-solutions",
                "content": "PriorityQueue solution:\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Queue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        for (int i : stones) queue.offer(i);\\n\\n        while (queue.size() > 1) {\\n            int first = queue.poll();\\n            int next = queue.poll();\\n            if (first != next) {\\n                queue.offer(first - next);\\n            }\\n        }\\n        return queue.isEmpty() ? 0 : queue.poll();\\n    }\\n}\\n```\\n\\nWithout extra space solution:\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if (stones.length == 1) return stones[0];\\n        Arrays.sort(stones);\\n        int last = stones.length - 1;\\n        int prev = stones.length - 2;\\n        while (stones[last] != 0) {\\n            if (stones[prev] == 0) return stones[last];\\n            stones[last] = stones[last] - stones[prev];\\n            stones[prev] = 0;\\n            Arrays.sort(stones);\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c808e6a5-e57b-427e-98eb-31b4ffa029bb_1668743243.4978485.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Queue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        for (int i : stones) queue.offer(i);\\n\\n        while (queue.size() > 1) {\\n            int first = queue.poll();\\n            int next = queue.poll();\\n            if (first != next) {\\n                queue.offer(first - next);\\n            }\\n        }\\n        return queue.isEmpty() ? 0 : queue.poll();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if (stones.length == 1) return stones[0];\\n        Arrays.sort(stones);\\n        int last = stones.length - 1;\\n        int prev = stones.length - 2;\\n        while (stones[last] != 0) {\\n            if (stones[prev] == 0) return stones[last];\\n            stones[last] = stones[last] - stones[prev];\\n            stones[prev] = 0;\\n            Arrays.sort(stones);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596771,
                "title": "c-easy-priority-queue-solution-100-time",
                "content": "```\\nint lastStoneWeight(vector<int>& stones) {\\n\\n\\tpriority_queue<int>pq;\\n\\tfor(auto x: stones)\\n\\t{\\n\\t\\tpq.push(x);\\n\\t}\\n\\n\\twhile(!p.empty())\\n\\t{\\n\\t\\tint y = pq.top();\\n\\t\\tif(pq.size()==1)return y;\\n\\t\\tpq.pop();\\n\\t\\tint rem = abs(y - pq.top());\\n\\t\\tpq.pop();\\n\\t\\tpq.push(rem);\\n\\n        }\\n        return 0;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint lastStoneWeight(vector<int>& stones) {\\n\\n\\tpriority_queue<int>pq;\\n\\tfor(auto x: stones)\\n\\t{\\n\\t\\tpq.push(x);\\n\\t}\\n\\n\\twhile(!p.empty())\\n\\t{\\n\\t\\tint y = pq.top();\\n\\t\\tif(pq.size()==1)return y;\\n\\t\\tpq.pop();\\n\\t\\tint rem = abs(y - pq.top());\\n\\t\\tpq.pop();\\n\\t\\tpq.push(rem);\\n\\n        }\\n        return 0;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524599,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        use std::collections::BinaryHeap;\\n\\n        let mut h = BinaryHeap::from(stones);\\n        while h.len() > 1 {\\n            let s1 = h.pop().unwrap();\\n            let s2 = h.pop().unwrap();\\n            h.push(s1 - s2)\\n        }\\n        h.pop().unwrap_or(0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        use std::collections::BinaryHeap;\\n\\n        let mut h = BinaryHeap::from(stones);\\n        while h.len() > 1 {\\n            let s1 = h.pop().unwrap();\\n            let s2 = h.pop().unwrap();\\n            h.push(s1 - s2)\\n        }\\n        h.pop().unwrap_or(0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 833091,
                "title": "python-heapq",
                "content": "```\\n\"\"\"\\nChoose two heaviest stones and smash them together\\n\\nx==y: destroyed\\nx != y, new weight is difference, return weight of stome\\n\\nApproach:\\nuse max heap, get difference\\n\"\"\"\\nimport heapq\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-x for x in stones]\\n        heapq.heapify(stones)\\n        \\n        while len(stones) > 1:\\n            stone1 = -(heapq.heappop(stones))\\n            stone2 = -(heapq.heappop(stones))\\n            \\n            if stone1 == stone2: continue\\n            heapq.heappush(stones,-(abs(stone1-stone2)))\\n            \\n        if len(stones) == 0: return 0\\n        return -(heapq.heappop(stones))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\"\"\"\\nChoose two heaviest stones and smash them together\\n\\nx==y: destroyed\\nx != y, new weight is difference, return weight of stome\\n\\nApproach:\\nuse max heap, get difference\\n\"\"\"\\nimport heapq\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-x for x in stones]\\n        heapq.heapify(stones)\\n        \\n        while len(stones) > 1:\\n            stone1 = -(heapq.heappop(stones))\\n            stone2 = -(heapq.heappop(stones))\\n            \\n            if stone1 == stone2: continue\\n            heapq.heappush(stones,-(abs(stone1-stone2)))\\n            \\n        if len(stones) == 0: return 0\\n        return -(heapq.heappop(stones))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488945,
                "title": "c-vector-100-time-and-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        while(stones.size() > 1){\\n            sort(stones.begin(),stones.end(),greater<int>());\\n            if(stones[0] == stones[1])\\n                stones.erase(stones.begin(),stones.begin()+2);\\n            else{\\n                stones.push_back(abs(stones[0] - stones[1]));\\n                stones.erase(stones.begin(),stones.begin()+2);         \\n            }\\n        }\\n        if(!stones.empty())\\n            return stones[0];\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        while(stones.size() > 1){\\n            sort(stones.begin(),stones.end(),greater<int>());\\n            if(stones[0] == stones[1])\\n                stones.erase(stones.begin(),stones.begin()+2);\\n            else{\\n                stones.push_back(abs(stones[0] - stones[1]));\\n                stones.erase(stones.begin(),stones.begin()+2);         \\n            }\\n        }\\n        if(!stones.empty())\\n            return stones[0];\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649893,
                "title": "c-easy-short-faster-than-100-priority-queue",
                "content": "![image](https://assets.leetcode.com/users/images/e3870a6c-2992-4394-80e6-0251c9344bc1_1664696002.4909544.png)\\n\\n**T->O(n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint lastStoneWeight(vector<int>& st) {\\n\\t\\t\\t\\tint n=st.size();\\n\\t\\t\\t\\tpriority_queue<int>q;\\n\\t\\t\\t\\tfor(auto i: st) q.push(i);\\n\\t\\t\\t\\twhile(q.size()!=1){\\n\\t\\t\\t\\t\\tint x=q.top();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tint y=q.top();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tq.push(max(x,y)-min(x,y));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn q.top();\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint lastStoneWeight(vector<int>& st) {\\n\\t\\t\\t\\tint n=st.size();\\n\\t\\t\\t\\tpriority_queue<int>q;\\n\\t\\t\\t\\tfor(auto i: st) q.push(i);\\n\\t\\t\\t\\twhile(q.size()!=1){\\n\\t\\t\\t\\t\\tint x=q.top();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tint y=q.top();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tq.push(max(x,y)-min(x,y));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1922870,
                "title": "c-naive-solution",
                "content": "```\\nint lastStoneWeight(vector<int>& stones) {\\n        sort(stones.begin(),stones.end());\\n        int a=stones.size()-1;\\n        if(a==0){\\n            return stones[a];\\n        }\\n        for(int i=0;i<stones.size();i++){\\n            sort(stones.begin(),stones.end());\\n            if(stones[a]>0 && stones[a-1]>0){\\n                stones[a]=stones[a]-stones[a-1];\\n                stones[a-1]=0;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return stones[a];\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint lastStoneWeight(vector<int>& stones) {\\n        sort(stones.begin(),stones.end());\\n        int a=stones.size()-1;\\n        if(a==0){\\n            return stones[a];\\n        }\\n        for(int i=0;i<stones.size();i++){\\n            sort(stones.begin(),stones.end());\\n            if(stones[a]>0 && stones[a-1]>0){\\n                stones[a]=stones[a]-stones[a-1];\\n                stones[a-1]=0;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return stones[a];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1922210,
                "title": "java-priority-queue",
                "content": "```\\npublic int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int stone : stones) {\\n            queue.offer(stone);\\n        }\\n\\n        while (queue.size() > 1) {\\n            queue.offer(queue.poll() - queue.poll());\\n        }\\n\\n        return queue.isEmpty() ? 0 : queue.peek();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int stone : stones) {\\n            queue.offer(stone);\\n        }\\n\\n        while (queue.size() > 1) {\\n            queue.offer(queue.poll() - queue.poll());\\n        }\\n\\n        return queue.isEmpty() ? 0 : queue.peek();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921123,
                "title": "very-easy-code-with-explanation",
                "content": "**step 1  create a priority queue\\nstep 2 Put all elements into a priority queue.\\nstep 3 take two bigest element \\npush the difference into queue until\\ntwo more element left.**\\n\\n**Complexity\\nTime O(NlogN)\\nSpace O(N)**\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& nums) {\\n       priority_queue<int> pq;\\n      for(auto i : nums)      \\n          pq.push(i);\\n      while(pq.size() > 1)\\n      {\\n          int a = pq.top();\\n          pq.pop();\\n          int b = pq.top(); \\n          pq.pop();\\n       if(a>b)\\n              pq.push(a-b);\\n      }\\n      return pq.empty()?0:pq.top();  \\n        \\n    }\\n};\\n\\nif(ishelpfull)\\n(upvote);\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& nums) {\\n       priority_queue<int> pq;\\n      for(auto i : nums)      \\n          pq.push(i);\\n      while(pq.size() > 1)\\n      {\\n          int a = pq.top();\\n          pq.pop();\\n          int b = pq.top(); \\n          pq.pop();\\n       if(a>b)\\n              pq.push(a-b);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1921120,
                "title": "last-stone-weight-python-easy-48-ms",
                "content": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while(len(stones)>1):\\n            p = max(stones)\\n            pi= stones.index(p)\\n            stones.pop(pi)\\n            q = max(stones)\\n            qi = stones.index(q)\\n            stones.pop(qi)\\n            stones.append(p-q)\\n        return stones[0]    \\n ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while(len(stones)>1):\\n            p = max(stones)\\n            pi= stones.index(p)\\n            stones.pop(pi)\\n            q = max(stones)\\n            qi = stones.index(q)\\n            stones.pop(qi)\\n            stones.append(p-q)\\n        return stones[0]    \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1378654,
                "title": "java-easy-solution-o-nlogn-time-complexity-priority-queue",
                "content": "The efficient way to retrieve the max from array is to use a max heap, which in Java is a PriorityQueue (min heap) with a reverse comparator.\\n\\n Follow 4 Easy steps-\\n**Step1** : Create a max priority queue.\\n**Step2** : Add all the elements to queue.\\n**Step3** : Remove two max element at a time, find the difference and then add into the queue.\\n**Step4** : Check if queue is empty return 0, else return the element\\n\\n\\n```\\n    public int lastStoneWeight(int[] stones) {\\n        \\n        // Create a max priority queue         \\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        // Add all the elements to queue        \\n        for(int i : stones) {\\n        \\tqueue.add(i);\\n        }\\n        \\n        // Remove two max element at a time, find the difference and then add into the queue         \\n        while(queue.size() > 1) {\\n            int num1 = queue.poll();\\n            int num2 = queue.poll();\\n            int num = num1 - num2;\\n            queue.add(num);\\n        }\\n        \\n        // Check if queue is empty return 0, else return the element         \\n        if(queue.isEmpty()) {\\n        \\treturn 0;\\n        }\\n        return queue.poll();\\n    }\\n```\\n\\nTime Complexity - ```o(nlogn)```\\nSpace Complexity - ```o(n)```",
                "solutionTags": [],
                "code": "```\\n    public int lastStoneWeight(int[] stones) {\\n        \\n        // Create a max priority queue         \\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        // Add all the elements to queue        \\n        for(int i : stones) {\\n        \\tqueue.add(i);\\n        }\\n        \\n        // Remove two max element at a time, find the difference and then add into the queue         \\n        while(queue.size() > 1) {\\n            int num1 = queue.poll();\\n            int num2 = queue.poll();\\n            int num = num1 - num2;\\n            queue.add(num);\\n        }\\n        \\n        // Check if queue is empty return 0, else return the element         \\n        if(queue.isEmpty()) {\\n        \\treturn 0;\\n        }\\n        return queue.poll();\\n    }\\n```\n```o(nlogn)```\n```o(n)```",
                "codeTag": "Unknown"
            },
            {
                "id": 594316,
                "title": "javascript-99-time",
                "content": "It\\'s not optimal but it\\'s efficient without using a priority queue. Just array manipulation \\n\\n```/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    let size = stones.length;\\n     \\n    while(size >= 2){\\n        stones.sort((a,b)=> { return a-b })\\n        \\n        x = stones.pop(); \\n        y = stones.pop();\\n        \\n        if(x == y){\\n            size -= 2;\\n        }else{\\n            size -= 1; \\n            stones.unshift(x - y); \\n        }\\n    }\\n    \\n    return stones;\\n};\\n",
                "solutionTags": [],
                "code": "It\\'s not optimal but it\\'s efficient without using a priority queue. Just array manipulation \\n\\n```/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    let size = stones.length;\\n     \\n    while(size >= 2){\\n        stones.sort((a,b)=> { return a-b })\\n        \\n        x = stones.pop(); \\n        y = stones.pop();\\n        \\n        if(x == y){\\n            size -= 2;\\n        }else{\\n            size -= 1; \\n            stones.unshift(x - y); \\n        }\\n    }\\n    \\n    return stones;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 575384,
                "title": "c-solution-with-explanation",
                "content": "**Priority Queue Implementation**\\n* Make  a priority queue(binary max heap) which automatically arrange the element in sorted order.\\n* Then pick the first element (which is maximum) and 2nd element(2nd max) , if both are equal  we dont have to push anything , if not equal push difference of both in queue.\\n* Do the above steps till queue size is equal to 1, then return last element. If queue becomes empty before reaching size==1 then return 0.\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            pq.push(stones[i]);\\n        }\\n        int m1,m2;\\n        while(!pq.empty())\\n        {\\n            if(pq.size()==1)\\n                return pq.top();\\n            m1=pq.top();\\n            pq.pop();\\n            m2=pq.top();\\n            pq.pop();\\n            \\n            if(m1!=m2)\\n                pq.push(m1-m2);\\n        }\\n            return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            pq.push(stones[i]);\\n        }\\n        int m1,m2;\\n        while(!pq.empty())\\n        {\\n            if(pq.size()==1)\\n                return pq.top();\\n            m1=pq.top();\\n            pq.pop();\\n            m2=pq.top();\\n            pq.pop();\\n            \\n            if(m1!=m2)\\n                pq.push(m1-m2);\\n        }\\n            return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549801,
                "title": "golang-using-container-heap",
                "content": "```\\npackage main\\n\\nimport (\\n\\t\"container/heap\"\\n)\\n\\nfunc lastStoneWeight(stones []int) int {\\n\\tpq := IntHeap(stones)\\n\\theap.Init(&pq)\\n\\tfor pq.Len() > 1 {\\n\\t\\theap.Push(&pq, heap.Pop(&pq).(int)-heap.Pop(&pq).(int))\\n\\n\\t}\\n\\treturn heap.Pop(&pq).(int)\\n}\\n\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t// Push and Pop use pointer receivers because they modify the slice\\'s length,\\n\\t// not just its contents.\\n\\t*h = append(*h, x.(int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"container/heap\"\\n)\\n\\nfunc lastStoneWeight(stones []int) int {\\n\\tpq := IntHeap(stones)\\n\\theap.Init(&pq)\\n\\tfor pq.Len() > 1 {\\n\\t\\theap.Push(&pq, heap.Pop(&pq).(int)-heap.Pop(&pq).(int))\\n\\n\\t}\\n\\treturn heap.Pop(&pq).(int)\\n}\\n\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t// Push and Pop use pointer receivers because they modify the slice\\'s length,\\n\\t// not just its contents.\\n\\t*h = append(*h, x.(int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 467505,
                "title": "python-very-simple-solution-95-fast",
                "content": "```\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        while len(stones) > 1:\\n            stones.sort()\\n            x, y = stones[-2], stones[-1]\\n            stones = stones[:-2]\\n       \\n            if x != y:\\n                stones.append(y - x)\\n                \\n        return stones[0] if stones else 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        while len(stones) > 1:\\n            stones.sort()\\n            x, y = stones[-2], stones[-1]\\n            stones = stones[:-2]\\n       \\n            if x != y:\\n                stones.append(y - x)\\n                \\n        return stones[0] if stones else 0",
                "codeTag": "Java"
            },
            {
                "id": 437380,
                "title": "python-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\t\\t\\tstones.sort()\\n\\t\\t\\twhile len(stones)>1:\\n\\t\\t\\t\\tt = stones.pop()\\n\\t\\t\\t\\tu = stones.pop()\\n\\t\\t\\t\\tif t==u:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstones.append(t-u)\\n\\t\\t\\t\\t\\tstones.sort()\\n\\t\\t\\treturn stones[0] if stones else 0\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\t\\t\\tstones.sort()\\n\\t\\t\\twhile len(stones)>1:\\n\\t\\t\\t\\tt = stones.pop()\\n\\t\\t\\t\\tu = stones.pop()\\n\\t\\t\\t\\tif t==u:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstones.append(t-u)\\n\\t\\t\\t\\t\\tstones.sort()\\n\\t\\t\\treturn stones[0] if stones else 0\\n",
                "codeTag": "Java"
            },
            {
                "id": 3449828,
                "title": "better-than-100-in-runtime-simple-c-approach",
                "content": "# Approach\\nAlright, in this I am using Priority Queue. In this first I am adding all elements of the vector \"stones\" in the priority queue called \"pq\". Now I am initializing a while loop, setting the condition that, the size of \"pq\" must be greater than 1. I am simply checking the top 2 elements and doing the required manipulations in the question. In the end, if size of \"pq\" is 0, return 0; else we should return the top element of the same.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n=stones.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push(stones[i]);\\n        }    \\n        while(pq.size()>1)\\n        {\\n            int a=pq.top();\\n            pq.pop();\\n            int b=pq.top();\\n            pq.pop();\\n            if(a!=b)\\n            {\\n                int c=a-b;\\n                pq.push(c);\\n            }\\n        }\\n        if(pq.size()==0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            int l=pq.top();\\n            return l;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n=stones.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push(stones[i]);\\n        }    \\n        while(pq.size()>1)\\n        {\\n            int a=pq.top();\\n            pq.pop();\\n            int b=pq.top();\\n            pq.pop();\\n            if(a!=b)\\n            {\\n                int c=a-b;\\n                pq.push(c);\\n            }\\n        }\\n        if(pq.size()==0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            int l=pq.top();\\n            return l;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449596,
                "title": "java-easy-solution-lbeginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        //creating a heap to store elements in descending order\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i = 0 ; i < stones.length; i ++){\\n            q.add(stones[i]);\\n        }\\n        while(q.size() > 1){\\n            int x = q.poll();\\n            int y = q.poll();\\n            if(x == y){\\n                continue;\\n            }else{\\n                q.add(Math.abs(y - x));\\n            }\\n        }\\n        if(q.size() == 1){\\n            return q.poll();\\n        }\\n        return 0;\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        //creating a heap to store elements in descending order\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i = 0 ; i < stones.length; i ++){\\n            q.add(stones[i]);\\n        }\\n        while(q.size() > 1){\\n            int x = q.poll();\\n            int y = q.poll();\\n            if(x == y){\\n                continue;\\n            }else{\\n                q.add(Math.abs(y - x));\\n            }\\n        }\\n        if(q.size() == 1){\\n            return q.poll();\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448701,
                "title": "easy-java-solution-using-maxheap-beginner-friendly",
                "content": "# Intuition\\nNeed to maitain a DS to get top-2 stone, PriorityQueue is best for this\\n\\n# Approach\\n1. Push all elments in prioriyQueue as MaxHeap.\\n2. Pick top 2 elements form maxHeap, if there is only one element left then that is answer.\\n3. If both element are same, no action needed and continue the process.\\n4. If both element are different, push the differece again.\\n5. Answer will be if only one stone is left or no stone is left, **In case of only one stone is left, that is the answer, if no stoner are left, 0 is the answer.**\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((stone1, stone2) -> stone2 - stone1);\\n\\n        for(int stone: stones) {\\n            maxHeap.add(stone);\\n        }\\n\\n        while(!maxHeap.isEmpty()) {\\n            // take haviest stone\\n            int y = maxHeap.poll();\\n            if(maxHeap.isEmpty()) {\\n                // if the was only one stone left, so that is answer\\n                return y;\\n            } else {\\n                // take second haviest stone\\n                int x = maxHeap.poll();\\n                // if both are no equal then push the difference, no action needed for equal\\n                if(x != y) {\\n                    maxHeap.add(y - x);\\n                }\\n            }\\n        }\\n\\n        // if no stone left in heap\\n        return 0;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((stone1, stone2) -> stone2 - stone1);\\n\\n        for(int stone: stones) {\\n            maxHeap.add(stone);\\n        }\\n\\n        while(!maxHeap.isEmpty()) {\\n            // take haviest stone\\n            int y = maxHeap.poll();\\n            if(maxHeap.isEmpty()) {\\n                // if the was only one stone left, so that is answer\\n                return y;\\n            } else {\\n                // take second haviest stone\\n                int x = maxHeap.poll();\\n                // if both are no equal then push the difference, no action needed for equal\\n                if(x != y) {\\n                    maxHeap.add(y - x);\\n                }\\n            }\\n        }\\n\\n        // if no stone left in heap\\n        return 0;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448681,
                "title": "daily-leetcoding-challenge-april-day-24",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3425201,
                "title": "c-simple-solution-with-priorityqueue",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n\\n        var heap = new PriorityQueue<int, int>();\\n        \\n        foreach (var stone in stones)\\n            heap.Enqueue(stone, 0 - stone);\\n\\n        while (heap.Count > 1)\\n        {\\n            var newStone = heap.Dequeue() - heap.Dequeue();\\n            if (newStone > 0)\\n                heap.Enqueue(newStone, 0 - newStone);\\n        }\\n        \\n        return heap.Count > 0 ? heap.Dequeue() : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n\\n        var heap = new PriorityQueue<int, int>();\\n        \\n        foreach (var stone in stones)\\n            heap.Enqueue(stone, 0 - stone);\\n\\n        while (heap.Count > 1)\\n        {\\n            var newStone = heap.Dequeue() - heap.Dequeue();\\n            if (newStone > 0)\\n                heap.Enqueue(newStone, 0 - newStone);\\n        }\\n        \\n        return heap.Count > 0 ? heap.Dequeue() : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375538,
                "title": "java-heap-fight-of-the-stones",
                "content": "\\n```\\nclass Heap\\n{\\n    int [] heap;\\n    int size;\\n    Heap(int[] stones)\\n    {\\n        heap = new int[stones.length];\\n        size = 0;\\n        for (int i = 0; i < stones.length; i++)\\n            addStone(stones[i]);\\n    }\\n    public int removeMax() //size--\\n    {\\n        int answ = heap[0];\\n        if (size > 0) {\\n            heap[0] = heap[size - 1];\\n            size--;\\n        }\\n        siftDown();\\n        return answ;\\n    }\\n    public void addStone(int stone) //size++\\n    {\\n        size++;\\n        heap[size - 1] = stone;\\n        siftUp();\\n    }\\n\\n    public int[] changePlace(int child, int[] start)\\n    {\\n        int tmp;\\n\\n        tmp = heap[child];\\n        heap[child] = heap[start[0]];\\n        heap[start[0]] = tmp;\\n        start[0] = child;\\n        return new int[]{getLeftChild(start[0]), getRightChild(start[0])};\\n    }\\n\\n    public void siftDown()\\n    {\\n        int []start = new int[]{0};\\n        int []leftAndRight = new int[2];\\n        leftAndRight[0] = getLeftChild(start[0]);\\n        leftAndRight[1] = getRightChild(start[0]);\\n        int tmp;\\n        while (true)\\n        {\\n            if (leftAndRight[0] < size && leftAndRight[1] < size)\\n            {\\n                if(heap[leftAndRight[0]] >= heap[leftAndRight[1]] && heap[start[0]] <= heap[leftAndRight[0]])\\n                    leftAndRight = changePlace(leftAndRight[0], start);\\n                else if(heap[leftAndRight[1]] > heap[leftAndRight[0]] && heap[start[0]] <= heap[leftAndRight[1]])\\n                    leftAndRight = changePlace(leftAndRight[1], start);\\n                else\\n                    break;\\n            }\\n            else if (leftAndRight[0] < size && heap[start[0]] <= heap[leftAndRight[0]])\\n                leftAndRight = changePlace(leftAndRight[0], start);\\n            else if (leftAndRight[1] < size && heap[start[0]] <= heap[leftAndRight[1]])\\n                leftAndRight = changePlace(leftAndRight[1], start);\\n            else\\n                break;\\n        }\\n    }\\n\\n    public void siftUp()\\n    {\\n        int child = size - 1;\\n        int parent = getParent(child);\\n        int tmp;\\n        while (parent > -1 && heap[parent] < heap[child])\\n        {\\n            tmp = heap[child];\\n            heap[child] = heap[parent];\\n            heap[parent] = tmp;\\n            child = parent;\\n            parent = getParent(child);\\n        }\\n    }\\n\\n    public int getParent(int child)\\n    {\\n        return (child - 1) / 2;\\n    }\\n\\n    public int getLeftChild(int parent)\\n    {\\n        return parent * 2 + 1;\\n    }\\n\\n    public int getRightChild(int parent)\\n    {\\n        return parent * 2 + 2;\\n    }\\n}\\n\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Heap heap = new Heap(stones);\\n        int diff;\\n        while (heap.size > 1)\\n        {\\n            diff = Math.abs(heap.removeMax() - heap.removeMax());\\n            if (diff != 0)\\n                heap.addStone(diff);\\n        }\\n        if (heap.size > 0)\\n            return heap.removeMax();\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Heap\\n{\\n    int [] heap;\\n    int size;\\n    Heap(int[] stones)\\n    {\\n        heap = new int[stones.length];\\n        size = 0;\\n        for (int i = 0; i < stones.length; i++)\\n            addStone(stones[i]);\\n    }\\n    public int removeMax() //size--\\n    {\\n        int answ = heap[0];\\n        if (size > 0) {\\n            heap[0] = heap[size - 1];\\n            size--;\\n        }\\n        siftDown();\\n        return answ;\\n    }\\n    public void addStone(int stone) //size++\\n    {\\n        size++;\\n        heap[size - 1] = stone;\\n        siftUp();\\n    }\\n\\n    public int[] changePlace(int child, int[] start)\\n    {\\n        int tmp;\\n\\n        tmp = heap[child];\\n        heap[child] = heap[start[0]];\\n        heap[start[0]] = tmp;\\n        start[0] = child;\\n        return new int[]{getLeftChild(start[0]), getRightChild(start[0])};\\n    }\\n\\n    public void siftDown()\\n    {\\n        int []start = new int[]{0};\\n        int []leftAndRight = new int[2];\\n        leftAndRight[0] = getLeftChild(start[0]);\\n        leftAndRight[1] = getRightChild(start[0]);\\n        int tmp;\\n        while (true)\\n        {\\n            if (leftAndRight[0] < size && leftAndRight[1] < size)\\n            {\\n                if(heap[leftAndRight[0]] >= heap[leftAndRight[1]] && heap[start[0]] <= heap[leftAndRight[0]])\\n                    leftAndRight = changePlace(leftAndRight[0], start);\\n                else if(heap[leftAndRight[1]] > heap[leftAndRight[0]] && heap[start[0]] <= heap[leftAndRight[1]])\\n                    leftAndRight = changePlace(leftAndRight[1], start);\\n                else\\n                    break;\\n            }\\n            else if (leftAndRight[0] < size && heap[start[0]] <= heap[leftAndRight[0]])\\n                leftAndRight = changePlace(leftAndRight[0], start);\\n            else if (leftAndRight[1] < size && heap[start[0]] <= heap[leftAndRight[1]])\\n                leftAndRight = changePlace(leftAndRight[1], start);\\n            else\\n                break;\\n        }\\n    }\\n\\n    public void siftUp()\\n    {\\n        int child = size - 1;\\n        int parent = getParent(child);\\n        int tmp;\\n        while (parent > -1 && heap[parent] < heap[child])\\n        {\\n            tmp = heap[child];\\n            heap[child] = heap[parent];\\n            heap[parent] = tmp;\\n            child = parent;\\n            parent = getParent(child);\\n        }\\n    }\\n\\n    public int getParent(int child)\\n    {\\n        return (child - 1) / 2;\\n    }\\n\\n    public int getLeftChild(int parent)\\n    {\\n        return parent * 2 + 1;\\n    }\\n\\n    public int getRightChild(int parent)\\n    {\\n        return parent * 2 + 2;\\n    }\\n}\\n\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Heap heap = new Heap(stones);\\n        int diff;\\n        while (heap.size > 1)\\n        {\\n            diff = Math.abs(heap.removeMax() - heap.removeMax());\\n            if (diff != 0)\\n                heap.addStone(diff);\\n        }\\n        if (heap.size > 0)\\n            return heap.removeMax();\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224561,
                "title": "using-heap-1ms-java-beat",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i:stones)\\n            pq.add(i);\\n\\n        int x;\\n        int y;\\n\\n        while(pq.size()>1){\\n\\n             x=pq.poll();\\n             y=pq.poll();\\n\\n            if(x>y)\\n                pq.add(x-y);\\n\\n            }\\n            \\n        return pq.isEmpty()?0:pq.poll();\\n    }\\n}\\n```\\n![478xve.jpg](https://assets.leetcode.com/users/images/1296130b-2e6f-4f1a-b8dc-344f9b151589_1677230001.423075.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i:stones)\\n            pq.add(i);\\n\\n        int x;\\n        int y;\\n\\n        while(pq.size()>1){\\n\\n             x=pq.poll();\\n             y=pq.poll();\\n\\n            if(x>y)\\n                pq.add(x-y);\\n\\n            }\\n            \\n        return pq.isEmpty()?0:pq.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188840,
                "title": "golang-maxheap",
                "content": "# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunc lastStoneWeight(stones []int) int {\\n    maxHeap := &MaxHeap{}\\n\\n    for _, stone := range stones {\\n        heap.Push(maxHeap, stone)\\n    }\\n\\n    for maxHeap.Len() > 1 {\\n        stone1 := heap.Pop(maxHeap).(int)\\n        stone2 := heap.Pop(maxHeap).(int)\\n\\n        if stone1 != stone2 {\\n            heap.Push(maxHeap, stone1 - stone2)\\n        }\\n    }\\n\\n    res := 0\\n    if maxHeap.Len() == 1 {\\n        res = (*maxHeap)[0]\\n    }\\n    return res\\n}\\n\\ntype MaxHeap []int\\n\\nfunc (h MaxHeap) Len() int           { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h MaxHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MaxHeap) Push(x interface{}) {\\n    *h = append(*h, x.(int))\\n}\\n\\nfunc (h *MaxHeap) Pop() interface{} {\\n    x := (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\treturn x\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc lastStoneWeight(stones []int) int {\\n    maxHeap := &MaxHeap{}\\n\\n    for _, stone := range stones {\\n        heap.Push(maxHeap, stone)\\n    }\\n\\n    for maxHeap.Len() > 1 {\\n        stone1 := heap.Pop(maxHeap).(int)\\n        stone2 := heap.Pop(maxHeap).(int)\\n\\n        if stone1 != stone2 {\\n            heap.Push(maxHeap, stone1 - stone2)\\n        }\\n    }\\n\\n    res := 0\\n    if maxHeap.Len() == 1 {\\n        res = (*maxHeap)[0]\\n    }\\n    return res\\n}\\n\\ntype MaxHeap []int\\n\\nfunc (h MaxHeap) Len() int           { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h MaxHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MaxHeap) Push(x interface{}) {\\n    *h = append(*h, x.(int))\\n}\\n\\nfunc (h *MaxHeap) Pop() interface{} {\\n    x := (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\treturn x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027670,
                "title": "python-heapq-min-with-negative-values-equivalent-to-heap-max",
                "content": "https://leetcode.com/submissions/detail/875123729/  \\nRuntime: **29 ms**, faster than 94.25% of Python3 online submissions for Last Stone Weight.  \\nMemory Usage: 13.8 MB, less than 61.08% of Python3 online submissions for Last Stone Weight.  \\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        s = [-s for s in stones]\\n        heapify(s)\\n        while len(s)>1:\\n            heapq.heappush(s, -abs(heappop(s) - heappop(s)))\\n        return -s[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        s = [-s for s in stones]\\n        heapify(s)\\n        while len(s)>1:\\n            heapq.heappush(s, -abs(heappop(s) - heappop(s)))\\n        return -s[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907947,
                "title": "kotlin-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\n    fun lastStoneWeight(stones: IntArray): Int {\\n        val h = PriorityQueue<Int> { a, b -> b.compareTo(a) }\\n        stones.forEach { h.add(it) }\\n\\n        while (h.size > 1) { \\n            h.add(h.poll() - h.poll())\\n        }\\n \\n        return h.poll()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    fun lastStoneWeight(stones: IntArray): Int {\\n        val h = PriorityQueue<Int> { a, b -> b.compareTo(a) }\\n        stones.forEach { h.add(it) }\\n\\n        while (h.size > 1) { \\n            h.add(h.poll() - h.poll())\\n        }\\n \\n        return h.poll()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168036,
                "title": "javascript-using-maxpriorityqueue",
                "content": "Finally, there\\'s a Max/MinPriorityQueue for JavaScript!\\n\\nadd -> enqueue( )\\nremove -> dequeue( )\\nhighest number (peek) -> front( )\\n.element -> actual value\\n\\n```\\nvar lastStoneWeight = function(stones) {\\n    const m = new MaxPriorityQueue()\\n    for(const w of stones) m.enqueue(w)\\n    \\n    while(m.size() > 1){\\n        const diff = m.dequeue().element - m.dequeue().element\\n        if(diff > 0) m.enqueue(diff)\\n    }\\n \\n    return m.size() === 0 ? 0 : m.front().element\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar lastStoneWeight = function(stones) {\\n    const m = new MaxPriorityQueue()\\n    for(const w of stones) m.enqueue(w)\\n    \\n    while(m.size() > 1){\\n        const diff = m.dequeue().element - m.dequeue().element\\n        if(diff > 0) m.enqueue(diff)\\n    }\\n \\n    return m.size() === 0 ? 0 : m.front().element\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1922969,
                "title": "c-solution-with-image-explanation-no-extra-space",
                "content": "![image](https://assets.leetcode.com/users/images/2926ac92-fc16-4e57-ba90-57edfee68604_1649334079.7444394.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        while(stones.size() > 1) {\\n            sort(stones.begin(), stones.end());\\n            int n = stones.size();\\n            \\n            if(stones[n - 2] == stones[n - 1]) {\\n                stones.pop_back();\\n                stones.pop_back();\\n            }\\n            else {\\n                stones[n - 2] = stones[n - 1] - stones[n - 2];\\n                stones.pop_back();\\n            }\\n        }\\n        return stones.empty() ? 0:stones[0];\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        while(stones.size() > 1) {\\n            sort(stones.begin(), stones.end());\\n            int n = stones.size();\\n            \\n            if(stones[n - 2] == stones[n - 1]) {\\n                stones.pop_back();\\n                stones.pop_back();\\n            }\\n            else {\\n                stones[n - 2] = stones[n - 1] - stones[n - 2];\\n                stones.pop_back();\\n            }\\n        }\\n        return stones.empty() ? 0:stones[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922677,
                "title": "python-simple-python-solution-using-three-approach",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Apporach 1 Using Priority Queue :-\\n# Runtime: 39 ms, faster than 55.89% of Python3 online submissions for Last Stone Weight.\\n# Memory Usage: 14.1 MB, less than 13.28% of Python3 online submissions for Last Stone Weight.\\n\\n\\tfrom queue import PriorityQueue\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\tpq = PriorityQueue()\\n\\n\\t\\t\\tfor stone in stones:\\n\\t\\t\\t\\tpq.put(-stone)\\n\\n\\t\\t\\twhile pq.qsize() >= 2:\\n\\t\\t\\t\\tfirst_heavy = -(pq.get())\\n\\t\\t\\t\\tsecond_heavy = -(pq.get())\\n\\n\\t\\t\\t\\tif first_heavy == second_heavy:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpq.put(-(first_heavy - second_heavy))\\n\\n\\t\\t\\tif pq.qsize() == 1:\\n\\t\\t\\t\\treturn -pq.get()\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 0\\n\\n# Approach 2 Using Sorting :-\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\twhile len(stones)>1:\\n\\n\\t\\t\\t\\tsort_stones = sorted(stones)\\n\\n\\t\\t\\t\\tsmall_num, large_num = sort_stones[-2], sort_stones[-1]\\n\\n\\t\\t\\t\\tif small_num == large_num :\\n\\n\\t\\t\\t\\t\\tstones = sort_stones[:-2]\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tsort_stones.remove(small_num)\\n\\n\\t\\t\\t\\t\\tsort_stones.remove(large_num)\\n\\n\\t\\t\\t\\t\\tsort_stones.append(large_num - small_num)\\n\\n\\t\\t\\t\\t\\tstones = sort_stones\\n\\n\\t\\t\\tif len(stones)==1:\\n\\n\\t\\t\\t\\treturn stones[0]\\n\\n\\t\\t\\telse:\\n\\n\\t\\t\\t\\treturn 0\\n\\n# Approach 3 Using SortedList:\\n# Runtime: 47 ms, faster than 7.84% of Python3 online submissions for Last Stone Weight.\\n# Memory Usage: 14.2 MB, less than 8.03% of Python3 online submissions for Last Stone Weight.\\nfrom sortedcontainers import SortedList\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\tstones = SortedList(stones)\\n\\n\\t\\t\\twhile len(stones) > 1:\\n\\n\\t\\t\\t\\tlast = stones.pop(-1)\\n\\t\\t\\t\\tsecond_last = stones.pop(-1)\\n\\n\\t\\t\\t\\tif last == second_last:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstones.add(last - second_last)\\n\\n\\t\\t\\tif len(stones) > 0:\\n\\t\\t\\t\\treturn stones[0]\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 0\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Apporach 1 Using Priority Queue :-\\n# Runtime: 39 ms, faster than 55.89% of Python3 online submissions for Last Stone Weight.\\n# Memory Usage: 14.1 MB, less than 13.28% of Python3 online submissions for Last Stone Weight.\\n\\n\\tfrom queue import PriorityQueue\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\tpq = PriorityQueue()\\n\\n\\t\\t\\tfor stone in stones:\\n\\t\\t\\t\\tpq.put(-stone)\\n\\n\\t\\t\\twhile pq.qsize() >= 2:\\n\\t\\t\\t\\tfirst_heavy = -(pq.get())\\n\\t\\t\\t\\tsecond_heavy = -(pq.get())\\n\\n\\t\\t\\t\\tif first_heavy == second_heavy:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpq.put(-(first_heavy - second_heavy))\\n\\n\\t\\t\\tif pq.qsize() == 1:\\n\\t\\t\\t\\treturn -pq.get()\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 0\\n\\n# Approach 2 Using Sorting :-\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\twhile len(stones)>1:\\n\\n\\t\\t\\t\\tsort_stones = sorted(stones)\\n\\n\\t\\t\\t\\tsmall_num, large_num = sort_stones[-2], sort_stones[-1]\\n\\n\\t\\t\\t\\tif small_num == large_num :\\n\\n\\t\\t\\t\\t\\tstones = sort_stones[:-2]\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tsort_stones.remove(small_num)\\n\\n\\t\\t\\t\\t\\tsort_stones.remove(large_num)\\n\\n\\t\\t\\t\\t\\tsort_stones.append(large_num - small_num)\\n\\n\\t\\t\\t\\t\\tstones = sort_stones\\n\\n\\t\\t\\tif len(stones)==1:\\n\\n\\t\\t\\t\\treturn stones[0]\\n\\n\\t\\t\\telse:\\n\\n\\t\\t\\t\\treturn 0\\n\\n# Approach 3 Using SortedList:\\n# Runtime: 47 ms, faster than 7.84% of Python3 online submissions for Last Stone Weight.\\n# Memory Usage: 14.2 MB, less than 8.03% of Python3 online submissions for Last Stone Weight.\\nfrom sortedcontainers import SortedList\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\tstones = SortedList(stones)\\n\\n\\t\\t\\twhile len(stones) > 1:\\n\\n\\t\\t\\t\\tlast = stones.pop(-1)\\n\\t\\t\\t\\tsecond_last = stones.pop(-1)\\n\\n\\t\\t\\t\\tif last == second_last:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstones.add(last - second_last)\\n\\n\\t\\t\\tif len(stones) > 0:\\n\\t\\t\\t\\treturn stones[0]\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 0\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Java"
            },
            {
                "id": 1922512,
                "title": "simplest-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;  //create max heap having maximum element at top\\n        for(int x:stones)               //insert all elements into priority queue \\n            pq.push(x);\\n        while(pq.size()>1){        //iterate until size is equal to 1\\n            int fval=pq.top();      //fval is first max val\\n            pq.pop();\\n            int sval=pq.top();     //sval is second max val\\n            pq.pop();\\n            if(fval==sval){          //if both equal simply push 0 since both stones destroyed\\n                pq.push(0);\\n            }\\n            else if(fval>sval){         //if both not equal substract small val to larger  one and insert \\n                pq.push(fval-sval);\\n            }\\n        }\\n        return pq.top();       //finally return top value\\n    }\\n};\\n```\\nTC : O(nlogn)     \\nSC : O(N)\\nIf you like the solution please upvote. :)",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;  //create max heap having maximum element at top\\n        for(int x:stones)               //insert all elements into priority queue \\n            pq.push(x);\\n        while(pq.size()>1){        //iterate until size is equal to 1\\n            int fval=pq.top();      //fval is first max val\\n            pq.pop();\\n            int sval=pq.top();     //sval is second max val\\n            pq.pop();\\n            if(fval==sval){          //if both equal simply push 0 since both stones destroyed\\n                pq.push(0);\\n            }\\n            else if(fval>sval){         //if both not equal substract small val to larger  one and insert \\n                pq.push(fval-sval);\\n            }\\n        }\\n        return pq.top();       //finally return top value\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357203,
                "title": "easy-python-solution-99-91",
                "content": "Runtime: 16 ms, faster than 99.91% of Python3 online submissions for Last Stone Weight.\\nMemory Usage: 14.1 MB, less than 78.97% of Python3 online submissions for Last Stone Weight.\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) != 1:\\n            stones.sort()\\n            if len(stones)>2:\\n                if stones[-1]==stones[-2]:\\n                    del stones[-1]\\n                    del stones[-1]\\n                elif stones[-1]>stones[-2]:\\n                    stones[-1]-=stones[-2]\\n                    del stones[-2]\\n            else:\\n                return stones[-1]-stones[-2]        \\n        return stones[0]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 16 ms, faster than 99.91% of Python3 online submissions for Last Stone Weight.\\nMemory Usage: 14.1 MB, less than 78.97% of Python3 online submissions for Last Stone Weight.\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) != 1:\\n            stones.sort()\\n            if len(stones)>2:\\n                if stones[-1]==stones[-2]:\\n                    del stones[-1]\\n                    del stones[-1]\\n                elif stones[-1]>stones[-2]:\\n                    stones[-1]-=stones[-2]\\n                    del stones[-2]\\n            else:\\n                return stones[-1]-stones[-2]        \\n        return stones[0]",
                "codeTag": "Java"
            },
            {
                "id": 709185,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while(stones.length > 1) {\\n        stones.sort((a,b) => b-a);\\n\\n        let first = stones.shift();\\n        let second = stones.shift();\\n\\n        if(first !== second) {\\n            stones.push(Math.abs(first-second));\\n        }\\n    }\\n\\n    if(stones.length == 0) {\\n        return 0;\\n    }\\n\\n    return stones[0];\\n};\\n\\n// Runtime (64ms) - Faster than 65.95% of Javascript submissions\\n// Memory Usage ( 34.1 MB ) - Less than 79% of Javascript submissions\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while(stones.length > 1) {\\n        stones.sort((a,b) => b-a);\\n\\n        let first = stones.shift();\\n        let second = stones.shift();\\n\\n        if(first !== second) {\\n            stones.push(Math.abs(first-second));\\n        }\\n    }\\n\\n    if(stones.length == 0) {\\n        return 0;\\n    }\\n\\n    return stones[0];\\n};\\n\\n// Runtime (64ms) - Faster than 65.95% of Javascript submissions\\n// Memory Usage ( 34.1 MB ) - Less than 79% of Javascript submissions\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674125,
                "title": "java-heap",
                "content": "```\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        for (int st : stones) {\\n            pq.offer(st);\\n        }\\n        \\n        while (pq.size() > 1) {\\n            int x = pq.poll(), y = pq.poll();\\n            int rem = x - y;\\n            if (rem > 0) pq.offer(rem);\\n        }\\n        \\n        return pq.size() > 0 ? pq.poll() : 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        for (int st : stones) {\\n            pq.offer(st);\\n        }\\n        \\n        while (pq.size() > 1) {\\n            int x = pq.poll(), y = pq.poll();\\n            int rem = x - y;\\n            if (rem > 0) pq.offer(rem);\\n        }\\n        \\n        return pq.size() > 0 ? pq.poll() : 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 464917,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    if(stones.length < 2) return stones;\\n    while(stones.length > 1){\\n        let index1 = stones.indexOf(Math.max(...stones));\\n        let stone1 = stones.splice(index1,1);\\n        let index2 = stones.indexOf(Math.max(...stones));\\n        let stone2 = stones.splice(index2,1);\\n        stones.push(stone1-stone2);        \\n    }\\n    return stones;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    if(stones.length < 2) return stones;\\n    while(stones.length > 1){\\n        let index1 = stones.indexOf(Math.max(...stones));\\n        let stone1 = stones.splice(index1,1);\\n        let index2 = stones.indexOf(Math.max(...stones));\\n        let stone2 = stones.splice(index2,1);\\n        stones.push(stone1-stone2);        \\n    }\\n    return stones;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 398322,
                "title": "c-minimum-heap-using-c-sorteddictionary",
                "content": "The algorithm can be solved using minimum heap. To convert maximum two numbers to minimum two numbers, negative value is used instead. \\n\\nHere are highlights:\\n1. Understand C# SortedDictionary can be used to impelement minimum heap first; \\n2. Apply all ement value to negative one, so maximum heap turns into a minimum heap problem;\\n3. Get familiar with IEnumberable First API and it can be used to get the minimum one from the heap. \\n\\n```\\npublic class Solution {\\n    /// <summary>\\n        /// Oct.4, 2019\\n        /// Implement a maximum heap - \\n        /// what I can do is to use negative value \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public int LastStoneWeight(int[] stones)\\n        {\\n            var sorted = new SortedDictionary<int, int>();\\n\\n            // put all numbers into minimum heap - default - negative value\\n            foreach (var number in stones)\\n            {\\n                var key = number * (-1);\\n                if (!sorted.ContainsKey(key))\\n                {\\n                    sorted.Add(key, 0);\\n                }\\n\\n                sorted[key]++; \\n            }\\n\\n            while (!((sorted.Keys.Count == 1 && sorted[sorted.Keys.ToList()[0]] == 1) || sorted.Keys.Count == 0))\\n            {\\n                // get minimum two values from minimum heap\\n                var key = sorted.Keys.First();\\n                var hasAtLeastTwo = sorted[key] > 1;\\n                if (hasAtLeastTwo)\\n                {\\n                    sorted[key] -= 2;\\n                    if(sorted[key] == 0)\\n                    {\\n                        sorted.Remove(key);\\n                    }\\n                }\\n                else \\n                {\\n                    var minimum = key;\\n                    sorted.Remove(key);\\n                    var next = sorted.Keys.First();\\n                    sorted[next]--;\\n\\n                    if (sorted[next] == 0)\\n                    {\\n                        sorted.Remove(next);\\n                    }\\n\\n                    var diff = Math.Abs(minimum - next);\\n                    var newKey = diff * (-1);\\n\\n                    if (newKey == 0)\\n                        continue;\\n\\n                    if (!sorted.ContainsKey(newKey))\\n                    {\\n                        sorted.Add(newKey, 0);\\n                    }\\n\\n                    sorted[newKey]++;\\n                }                \\n            }\\n\\n            if (sorted.Keys.Count == 0)\\n                return 0;\\n\\n            return sorted.Keys.ToList()[0] * (-1);\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /// <summary>\\n        /// Oct.4, 2019\\n        /// Implement a maximum heap - \\n        /// what I can do is to use negative value \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public int LastStoneWeight(int[] stones)\\n        {\\n            var sorted = new SortedDictionary<int, int>();\\n\\n            // put all numbers into minimum heap - default - negative value\\n            foreach (var number in stones)\\n            {\\n                var key = number * (-1);\\n                if (!sorted.ContainsKey(key))\\n                {\\n                    sorted.Add(key, 0);\\n                }\\n\\n                sorted[key]++; \\n            }\\n\\n            while (!((sorted.Keys.Count == 1 && sorted[sorted.Keys.ToList()[0]] == 1) || sorted.Keys.Count == 0))\\n            {\\n                // get minimum two values from minimum heap\\n                var key = sorted.Keys.First();\\n                var hasAtLeastTwo = sorted[key] > 1;\\n                if (hasAtLeastTwo)\\n                {\\n                    sorted[key] -= 2;\\n                    if(sorted[key] == 0)\\n                    {\\n                        sorted.Remove(key);\\n                    }\\n                }\\n                else \\n                {\\n                    var minimum = key;\\n                    sorted.Remove(key);\\n                    var next = sorted.Keys.First();\\n                    sorted[next]--;\\n\\n                    if (sorted[next] == 0)\\n                    {\\n                        sorted.Remove(next);\\n                    }\\n\\n                    var diff = Math.Abs(minimum - next);\\n                    var newKey = diff * (-1);\\n\\n                    if (newKey == 0)\\n                        continue;\\n\\n                    if (!sorted.ContainsKey(newKey))\\n                    {\\n                        sorted.Add(newKey, 0);\\n                    }\\n\\n                    sorted[newKey]++;\\n                }                \\n            }\\n\\n            if (sorted.Keys.Count == 0)\\n                return 0;\\n\\n            return sorted.Keys.ToList()[0] * (-1);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294929,
                "title": "simple-binary-search-based-solution-o-nlogn",
                "content": "``` csharp\\npublic class Solution {\\n  public int LastStoneWeight(int[] stones)\\n        {\\n            if (stones.Length == 2)\\n            {\\n                return Math.Abs(stones[1] - stones[0]);\\n            }\\n\\n            Array.Sort(stones);\\n            List<int> s = new List<int>(stones);\\n\\n            while (s.Count > 1)\\n            {\\n                int first = s.ElementAt(s.Count - 1);\\n                int second = s.ElementAt(s.Count - 2);\\n                int smash = first - second;\\n                s.RemoveAt(s.Count - 1);\\n                s.RemoveAt(s.Count - 1);\\n\\n                if (smash != 0)\\n                {\\n                    int index = s.BinarySearch(smash);\\n                    if (index < 0)\\n                    {\\n                        index = ~index;\\n                    }\\n                    s.Insert(index, smash);\\n                }\\n            }\\n\\n            return s.FirstOrDefault();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "``` csharp\\npublic class Solution {\\n  public int LastStoneWeight(int[] stones)\\n        {\\n            if (stones.Length == 2)\\n            {\\n                return Math.Abs(stones[1] - stones[0]);\\n            }\\n\\n            Array.Sort(stones);\\n            List<int> s = new List<int>(stones);\\n\\n            while (s.Count > 1)\\n            {\\n                int first = s.ElementAt(s.Count - 1);\\n                int second = s.ElementAt(s.Count - 2);\\n                int smash = first - second;\\n                s.RemoveAt(s.Count - 1);\\n                s.RemoveAt(s.Count - 1);\\n\\n                if (smash != 0)\\n                {\\n                    int index = s.BinarySearch(smash);\\n                    if (index < 0)\\n                    {\\n                        index = ~index;\\n                    }\\n                    s.Insert(index, smash);\\n                }\\n            }\\n\\n            return s.FirstOrDefault();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294884,
                "title": "java-priorityqueue-solution",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a);\\n        \\n        for (int stone : stones) {\\n            pq.offer(stone);\\n        }\\n        \\n        while (pq.size() > 1) {\\n            int x = pq.poll();\\n            int y = pq.poll();\\n            if (x != y) {\\n                pq.offer(x - y);\\n            }\\n        }\\n        \\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a);\\n        \\n        for (int stone : stones) {\\n            pq.offer(stone);\\n        }\\n        \\n        while (pq.size() > 1) {\\n            int x = pq.poll();\\n            int y = pq.poll();\\n            if (x != y) {\\n                pq.offer(x - y);\\n            }\\n        }\\n        \\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451705,
                "title": "java-easy-solution-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere i have used concept of priorityQueue(But this question also we can slove the help of Arraylist)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n     PriorityQueue<Integer> queue=new PriorityQueue<>(Collections.reverseOrder()) ;\\n     for(int i=0;i<stones.length;i++)  {\\n         queue.add(stones[i]);\\n     }\\n     while(queue.size()>1){\\n         int val2=queue.poll();\\n         int val1=queue.poll();\\n         if(val2>val1){\\n             queue.offer(val2-val1);\\n         }\\n     }\\n     if(queue.size()==0) return 0;\\n     return queue.poll();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n     PriorityQueue<Integer> queue=new PriorityQueue<>(Collections.reverseOrder()) ;\\n     for(int i=0;i<stones.length;i++)  {\\n         queue.add(stones[i]);\\n     }\\n     while(queue.size()>1){\\n         int val2=queue.poll();\\n         int val1=queue.poll();\\n         if(val2>val1){\\n             queue.offer(val2-val1);\\n         }\\n     }\\n     if(queue.size()==0) return 0;\\n     return queue.poll();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451178,
                "title": "java-easy-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- In this code we first sort the stones to get the 2 heaviest stones at the end of the array.\\n- Now we repetedly smashes(calculates the diff of the two heaviest stones,then setting the heaviest stone with that diff and second heaviest stone with 0) the two heaviest stones until there is only one stone left.\\n- Again sort the stones after the smash.\\n- This loop ends when the weigth of the second heaviest stone is 0.\\n- This indicates that there is only one stone left.\\n# Complexity\\n- Time complexity: O(n^2 log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        if(stones.length == 1) return stones[0];\\n        int n = stones.length;\\n        while(stones[n - 2] > 0){\\n            int diff = stones[n - 1] - stones[n - 2];\\n            stones[n - 2] = 0;\\n            stones[n - 1] = diff;\\n            Arrays.sort(stones);\\n        }\\n        return stones[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        if(stones.length == 1) return stones[0];\\n        int n = stones.length;\\n        while(stones[n - 2] > 0){\\n            int diff = stones[n - 1] - stones[n - 2];\\n            stones[n - 2] = 0;\\n            stones[n - 1] = diff;\\n            Arrays.sort(stones);\\n        }\\n        return stones[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449600,
                "title": "c-priority-queue",
                "content": "````\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(auto &i: stones){\\n            pq.push(i);\\n        }\\n        int a,b;\\n        while(pq.size()>1){\\n            a  = pq.top();pq.pop();\\n            b  = pq.top();pq.pop();\\n            if(a!=b){\\n                pq.push(abs(a-b));\\n            }\\n        }\\n        if(pq.empty())return 0;\\n        return pq.top();\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(auto &i: stones){\\n            pq.push(i);\\n        }\\n        int a,b;\\n        while(pq.size()>1){\\n            a  = pq.top();pq.pop();\\n            b  = pq.top();pq.pop();\\n            if(a!=b){\\n                pq.push(abs(a-b));\\n            }\\n        }\\n        if(pq.empty())return 0;\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449106,
                "title": "c-solution-heap-easy-and-explained",
                "content": "# Explanation\\n- At any point of time we need largest 2 stones that\\'s why I used priority queue.\\n- If the diffrence of these two stones is > 0, the we push it in the queue.\\n- And if diffrence is 0, i.e. both stones are destroyed\\n- At the end of the loop is the queue is empty, i.e. all the stones were destroyed during the game, that means we have to return 0\\n- Else we just return the last stone that\\'s left in the queue.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq(stones.begin(),stones.end());    \\n        while(pq.size()>1){\\n            int s1=pq.top();\\n            pq.pop();\\n            int s2=pq.top();\\n            pq.pop();\\n            if(s1-s2){\\n                pq.push(s1-s2);\\n            }            \\n        }\\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n```\\n![upvote cat.jpeg](https://assets.leetcode.com/users/images/c2726930-6086-475f-aea7-648d6c6f15c6_1682309289.295028.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq(stones.begin(),stones.end());    \\n        while(pq.size()>1){\\n            int s1=pq.top();\\n            pq.pop();\\n            int s2=pq.top();\\n            pq.pop();\\n            if(s1-s2){\\n                pq.push(s1-s2);\\n            }            \\n        }\\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448970,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# My youtube channel - KeetCode(Ex-Amazon)\\nI create 155 videos for leetcode questions as of April 24, 2023. I believe my channel helps you prepare for the coming technical interviews. Please subscribe my channel!\\n\\n### Please subscribe my channel - KeetCode(Ex-Amazon) from here.\\n\\n**I created a video for this question. I believe you can understand easily with visualization.** \\n\\n**My youtube channel - KeetCode(Ex-Amazon)**\\nThere is my channel link under picture in LeetCode profile.\\nhttps://leetcode.com/niits/\\n\\n![aaaaaaa.webp](https://assets.leetcode.com/users/images/d6a4c7b9-262c-497c-b943-a950c6ebdb9f_1682305218.8948395.webp)\\n\\n\\n# Intuition\\nUse heap to store stones.\\n\\n# Approach\\n- This is Python algorithm. Other languages might be different.\\n\\n1. Initialize a variable stones as a heap of negative values of the input stones list using list comprehension. This is done to create a min heap where the most negative value (i.e., the largest absolute value) will be at the root of the heap.\\n\\n2. Convert the stones list into a heap using the heapify function from the heapq module.\\n\\n3. While the length of stones is greater than 1, perform the following steps in a loop:\\n\\n    - Pop the two smallest (most negative) values from the heap and store them in variables s1 and s2.\\n    - Check if s1 and s2 are not equal. If they are not equal, calculate the difference between s1 and s2 and negate it (to maintain the negative value) before pushing it back to the heap using the heappush function.\\n\\n4. After the loop, if the stones heap is not empty, return the negation of the root value (the only remaining value in the heap), which represents the last stone weight. Otherwise, return 0 to indicate that all stones have been destroyed.\\n\\n---\\n\\n\\n**If you don\\'t understand the algorithm, let\\'s check my video solution.\\nThere is my channel link under picture in LeetCode profile.**\\nhttps://leetcode.com/niits/\\n\\n\\n---\\n\\n# Complexity\\n- Time complexity: O(n log n)\\nn is the number of elements in the input stones list. This is because the heapify function has a time complexity of O(n) and the while loop iterates n/2 times at most (since two elements are popped from the heap in each iteration), and each iteration involves push and pop operations on the heap which take O(log n) time. Therefore, the overall time complexity is dominated by the heapify function, resulting in O(n log n) time complexity.\\n\\n- Space complexity: O(n)\\nThe stones list is modified in place by converting it into a heap using heapify. No additional data structures are used, and the variables used in the code have constant space requirements. Therefore, the space complexity is proportional to the size of the input stones list, i.e., O(n).\\n\\n# Python\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        if len(stones) == 1:\\n            return stones[0]\\n        \\n        stones = [-s for s in stones]\\n        heapq.heapify(stones)\\n\\n        while len(stones) > 1:\\n            s1 = -(heapq.heappop(stones))\\n            s2 = -(heapq.heappop(stones))\\n\\n            if s1 != s2:\\n                heapq.heappush(stones, -(s1-s2))\\n        \\n        return -(stones[0]) if stones else 0\\n```\\n# JavaScript\\n```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    const queue = new MaxPriorityQueue();\\n    \\n    for (stone of stones) queue.enqueue(stone)\\n    \\n    while (queue.size() > 1) {\\n        let first = queue.dequeue().element;\\n        let second = queue.dequeue().element;\\n        if (first !== second) queue.enqueue(first-second)\\n    }\\n    \\n    return queue.size() === 0 ? 0 : queue.front().element   \\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        \\n        for (int stone : stones) {\\n            queue.offer(stone);\\n        }\\n        \\n        while (queue.size() > 1) {\\n            int first = queue.poll();\\n            int second = queue.poll();\\n            \\n            if (first != second) {\\n                queue.offer(first - second);\\n            }\\n        }\\n        \\n        return queue.size() == 0 ? 0 : queue.peek();\\n    }\\n}\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int, vector<int>> queue;\\n        int s1, s2;\\n        \\n        for(auto s1:stones)\\n            queue.push(s1);\\n        \\n        while(queue.size() != 1){\\n            s2 = queue.top();\\n            queue.pop();\\n            s1 = queue.top();\\n            queue.pop();\\n\\n            queue.push(s2-s1);\\n        }\\n        \\n        return queue.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        if len(stones) == 1:\\n            return stones[0]\\n        \\n        stones = [-s for s in stones]\\n        heapq.heapify(stones)\\n\\n        while len(stones) > 1:\\n            s1 = -(heapq.heappop(stones))\\n            s2 = -(heapq.heappop(stones))\\n\\n            if s1 != s2:\\n                heapq.heappush(stones, -(s1-s2))\\n        \\n        return -(stones[0]) if stones else 0\\n```\n```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    const queue = new MaxPriorityQueue();\\n    \\n    for (stone of stones) queue.enqueue(stone)\\n    \\n    while (queue.size() > 1) {\\n        let first = queue.dequeue().element;\\n        let second = queue.dequeue().element;\\n        if (first !== second) queue.enqueue(first-second)\\n    }\\n    \\n    return queue.size() === 0 ? 0 : queue.front().element   \\n};\\n```\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        \\n        for (int stone : stones) {\\n            queue.offer(stone);\\n        }\\n        \\n        while (queue.size() > 1) {\\n            int first = queue.poll();\\n            int second = queue.poll();\\n            \\n            if (first != second) {\\n                queue.offer(first - second);\\n            }\\n        }\\n        \\n        return queue.size() == 0 ? 0 : queue.peek();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int, vector<int>> queue;\\n        int s1, s2;\\n        \\n        for(auto s1:stones)\\n            queue.push(s1);\\n        \\n        while(queue.size() != 1){\\n            s2 = queue.top();\\n            queue.pop();\\n            s1 = queue.top();\\n            queue.pop();\\n\\n            queue.push(s2-s1);\\n        }\\n        \\n        return queue.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448700,
                "title": "java-priority-queue-beats-98-10-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int lastStoneWeight(int[] stones) {\\n    int x = 0, y = 0;\\n    var queue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n\\n    for (var stone : stones)\\n      queue.offer(stone);\\n    \\n    while (!queue.isEmpty()) {\\n      y = queue.poll();\\n      if (queue.isEmpty()) return y;\\n\\n      x = queue.poll();\\n      if (x != y) queue.offer(y - x);\\n    }\\n    return 0;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n  public int lastStoneWeight(int[] stones) {\\n    int x = 0, y = 0;\\n    var queue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n\\n    for (var stone : stones)\\n      queue.offer(stone);\\n    \\n    while (!queue.isEmpty()) {\\n      y = queue.poll();\\n      if (queue.isEmpty()) return y;\\n\\n      x = queue.poll();\\n      if (x != y) queue.offer(y - x);\\n    }\\n    return 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448500,
                "title": "c-easy-and-readable-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/8deee7e3-6578-4e6c-98c0-c9b2ceadefe8_1682281633.5742104.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        List<int> ls = stones.ToList();\\n        while (ls.Count > 1)\\n        {\\n            ls = ls.OrderByDescending(s => s).ToList();\\n            int a = ls[0];\\n            int b = ls[1];\\n            if (a == b)\\n            {\\n                ls.RemoveAt(1);\\n                ls.RemoveAt(0);\\n            }\\n            else\\n            {\\n                ls[1] = a - b;\\n                ls.RemoveAt(0);\\n            }\\n        }\\n        return ls.Count > 0 ? ls.First() : 0;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        List<int> ls = stones.ToList();\\n        while (ls.Count > 1)\\n        {\\n            ls = ls.OrderByDescending(s => s).ToList();\\n            int a = ls[0];\\n            int b = ls[1];\\n            if (a == b)\\n            {\\n                ls.RemoveAt(1);\\n                ls.RemoveAt(0);\\n            }\\n            else\\n            {\\n                ls[1] = a - b;\\n                ls.RemoveAt(0);\\n            }\\n        }\\n        return ls.Count > 0 ? ls.First() : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376991,
                "title": "simple-solution-with-priority-queue",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int n= stones.length;\\n        if(n==1) return stones[0];\\n        Queue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.offer(stones[i]);\\n        }\\n        while(pq.size()>1)\\n        {\\n            int a = pq.poll();\\n            int b = pq.poll();\\n            int diff = Math.max(a,b) - Math.min(a,b);\\n            if(diff>0)\\n                pq.offer(diff);\\n        }\\n        int weight = 0;\\n        if(!pq.isEmpty())\\n        {\\n            weight= pq.poll();\\n        }\\n        return weight;\\n    }\\n}\\n```\\n\\n![87473a41-9c53-4e65-967e-15f92ebc9310_1677233624.267395.jpeg](https://assets.leetcode.com/users/images/00e56b65-7f40-4a62-9ee2-6d272278b5b0_1680578844.8665698.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int n= stones.length;\\n        if(n==1) return stones[0];\\n        Queue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.offer(stones[i]);\\n        }\\n        while(pq.size()>1)\\n        {\\n            int a = pq.poll();\\n            int b = pq.poll();\\n            int diff = Math.max(a,b) - Math.min(a,b);\\n            if(diff>0)\\n                pq.offer(diff);\\n        }\\n        int weight = 0;\\n        if(!pq.isEmpty())\\n        {\\n            weight= pq.poll();\\n        }\\n        return weight;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233363,
                "title": "c-priority-queue",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int>pq (stones.begin(),stones.end());\\n        while(pq.size()>=2)\\n        {\\n            int y=pq.top();\\n            pq.pop();\\n            int x=pq.top();\\n            pq.pop();\\n            if(x==y)\\n            {\\n                \\n            }\\n            else\\n            {\\n                pq.push(y-x);\\n            }\\n        }\\n        if(!pq.empty()) return pq.top();\\n        return 0;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int>pq (stones.begin(),stones.end());\\n        while(pq.size()>=2)\\n        {\\n            int y=pq.top();\\n            pq.pop();\\n            int x=pq.top();\\n            pq.pop();\\n            if(x==y)\\n            {\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3135101,
                "title": "0ms-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int n=stones.length;\\n        while(n>1){\\n            Arrays.sort(stones);\\n            int x=stones[n-1]-stones[n-2];\\n            n--;\\n            stones[n-1]=x;\\n        }\\n        return stones[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int n=stones.length;\\n        while(n>1){\\n            Arrays.sort(stones);\\n            int x=stones[n-1]-stones[n-2];\\n            n--;\\n            stones[n-1]=x;\\n        }\\n        return stones[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094838,
                "title": "java-0ms",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue=new PriorityQueue<Integer>(Collections.reverseOrder()); \\n\\n        for(int i :stones){\\n            queue.add(i);\\n        } \\n\\n        while(!queue.isEmpty()){\\n            int x=queue.poll();\\n            if(queue.isEmpty()){\\n                return x;\\n            }\\n            int y=queue.poll();\\n\\n            queue.add(x-y);\\n        }\\n        return queue.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue=new PriorityQueue<Integer>(Collections.reverseOrder()); \\n\\n        for(int i :stones){\\n            queue.add(i);\\n        } \\n\\n        while(!queue.isEmpty()){\\n            int x=queue.poll();\\n            if(queue.isEmpty()){\\n                return x;\\n            }\\n            int y=queue.poll();\\n\\n            queue.add(x-y);\\n        }\\n        return queue.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868752,
                "title": "beats-98-heapq-python",
                "content": "\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [ -n for n in stones]\\n        heapq.heapify(stones)\\n        while len(stones) >=2:\\n            diff = heapq.heappop(stones) - heapq.heappop(stones)\\n            print(diff)\\n            if diff != 0:\\n                heapq.heappush(stones,diff)\\n        return -stones[0] if len(stones) == 1 else 0\\n```\\n\\n**Upvote if you like the solution.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [ -n for n in stones]\\n        heapq.heapify(stones)\\n        while len(stones) >=2:\\n            diff = heapq.heappop(stones) - heapq.heappop(stones)\\n            print(diff)\\n            if diff != 0:\\n                heapq.heappush(stones,diff)\\n        return -stones[0] if len(stones) == 1 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543347,
                "title": "simple-c-solution-while-loop-accepted",
                "content": "In the following code ...we are using a while loop when the size of array /vector is greater than 1..and sorting the vector at each itetation and then storing the value of the last two maximum elements in variable \\' a \\'. then we pop the last two elements of that array ..and append that value .and again in while loop we sort again and repeat the process\\nat last we return the only value in the vector which is the LAST STONE WEIGHT\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones)\\n   {while(stones.size()>1){\\n       sort(stones.begin(),stones.end());\\n          int a=stones[stones.size()-1]-stones[stones.size()-2];\\n           stones.pop_back();\\n           stones.pop_back();\\n           stones.push_back(a);\\n       }\\n        return stones[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones)\\n   {while(stones.size()>1){\\n       sort(stones.begin(),stones.end());\\n          int a=stones[stones.size()-1]-stones[stones.size()-2];\\n           stones.pop_back();\\n           stones.pop_back();\\n           stones.push_back(a);\\n       }\\n        return stones[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447318,
                "title": "python-easy-tc-o-n-sc-o-1-without-heap",
                "content": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) >= 2:\\n            stones.sort(reverse = True)\\n            first = stones.pop(0)\\n            second = stones.pop(0)\\n            if first == second:\\n                continue\\n            else:\\n                stones.append(first-second)\\n        if stones:\\n            return stones[0]\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) >= 2:\\n            stones.sort(reverse = True)\\n            first = stones.pop(0)\\n            second = stones.pop(0)\\n            if first == second:\\n                continue\\n            else:\\n                stones.append(first-second)\\n        if stones:\\n            return stones[0]\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433222,
                "title": "java-easiest-solution-3ms-runtime-beginner-friendly-approach-high-runtime-easy-approch",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i: stones){\\n            arr.add(i);\\n        }\\n        while(arr.size() > 1){\\n            Collections.sort(arr);   \\n            int size = arr.size();\\n            int max = arr.get(size-1);\\n            int min = arr.get(size-2);\\n            arr.remove(size-1);\\n            arr.remove(size-2);\\n            if(min != max){\\n                max = max - min;\\n                arr.add(max);\\n            }\\n        }\\n        return arr.size()==1?arr.get(0):0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i: stones){\\n            arr.add(i);\\n        }\\n        while(arr.size() > 1){\\n            Collections.sort(arr);   \\n            int size = arr.size();\\n            int max = arr.get(size-1);\\n            int min = arr.get(size-2);\\n            arr.remove(size-1);\\n            arr.remove(size-2);\\n            if(min != max){\\n                max = max - min;\\n                arr.add(max);\\n            }\\n        }\\n        return arr.size()==1?arr.get(0):0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922172,
                "title": "easiest-simplest-explained-solution",
                "content": "**Priority Queue Implementation**\\n\\nMake a priority queue(binary max heap) which automatically arrange the element in sorted order.\\nThen pick the first element (which is maximum) and 2nd element(2nd max) , if both are equal we dont have to push anything , if not equal push difference of both in queue.\\nDo the above steps till queue size is equal to 1, then return last element. If queue becomes empty before reaching size==1 then return 0.\\n```\\n// Please upvote , if u like my solution :)\\nint lastStoneWeight(vector<int>& nums) {\\n        priority_queue<int> q;\\n        int ans = 0;\\n        for(auto it:nums){\\n            q.push(it);\\n        }\\n        while(true){\\n            if(q.size()==1 || q.size()==0) break;\\n            int v1 = q.top(); q.pop();\\n            int v2 = q.top(); q.pop();\\n            if(v1 != v2){\\n                q.push(v1-v2);\\n            }\\n        }\\n        if(q.size()) ans = q.top();\\n        return ans;\\n    }\\n// Please upvote , if u like my solution :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Please upvote , if u like my solution :)\\nint lastStoneWeight(vector<int>& nums) {\\n        priority_queue<int> q;\\n        int ans = 0;\\n        for(auto it:nums){\\n            q.push(it);\\n        }\\n        while(true){\\n            if(q.size()==1 || q.size()==0) break;\\n            int v1 = q.top(); q.pop();\\n            int v2 = q.top(); q.pop();\\n            if(v1 != v2){\\n                q.push(v1-v2);\\n            }\\n        }\\n        if(q.size()) ans = q.top();\\n        return ans;\\n    }\\n// Please upvote , if u like my solution :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921987,
                "title": "simple-java-solution-using-priority-queue",
                "content": "class Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones.length==1)return stones[0];\\n        if(stones.length==2)return Math.abs(stones[0]-stones[1]);\\n        PriorityQueue<Integer> q=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int s:stones){\\n            q.add(s);\\n        }\\n        while(!q.isEmpty()){\\n            int x=q.poll();\\n            int y=q.poll();\\n            if(x!=y){\\n                q.add(Math.abs(x-y));\\n            }\\n            if(q.size()==1){\\n                return q.poll();\\n            }\\n            \\n        }\\n        return 0;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones.length==1)return stones[0];\\n        if(stones.length==2)return Math.abs(stones[0]-stones[1]);\\n        PriorityQueue<Integer> q=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int s:stones){\\n            q.add(s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1921944,
                "title": "java-basic-priority-queue-solution",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> q = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++){\\n\\t\\t//Add elements to the priority queue\\n            q.add(stones[i]);\\n        }\\n        int i = q.peek();\\n        int j = i;\\n        while(!q.isEmpty()){\\n            //Get max element\\n            i = q.poll();\\n            if(q.isEmpty()){\\n                break;\\n            }else{\\n                // get second max element\\n                j = q.poll();\\n            }\\n            // check if x != y\\n            if(i != j){\\n                // y = y - x\\n                i = i-j;\\n                q.add(i);\\n            }else if(i == j && q.isEmpty()){\\n                return 0;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> q = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++){\\n\\t\\t//Add elements to the priority queue\\n            q.add(stones[i]);\\n        }\\n        int i = q.peek();\\n        int j = i;\\n        while(!q.isEmpty()){\\n            //Get max element\\n            i = q.poll();\\n            if(q.isEmpty()){\\n                break;\\n            }else{\\n                // get second max element\\n                j = q.poll();\\n            }\\n            // check if x != y\\n            if(i != j){\\n                // y = y - x\\n                i = i-j;\\n                q.add(i);\\n            }else if(i == j && q.isEmpty()){\\n                return 0;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921911,
                "title": "priority-queue-understandable-c-easy-solution",
                "content": "int lastStoneWeight(vector<int>& stones) {\\n        \\n         priority_queue<int>pd(stones.begin(),stones.end());\\n        \\n        while(1){\\n            \\n            if(pd.size()==0)\\n                return 0;\\n            \\n            if(pd.size()==1){ \\n                return pd.top();\\n            \\n            \\n                pd.pop();}\\n            \\n            int t=pd.top();\\n              pd.pop();\\n            int m=pd.top();\\n               pd.pop();\\n            \\n            if(t!=m){ \\n                pd.push(abs(t-m));}\\n               \\n            \\n        }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "int lastStoneWeight(vector<int>& stones) {\\n        \\n         priority_queue<int>pd(stones.begin(),stones.end());\\n        \\n        while(1){\\n            \\n            if(pd.size()==0)\\n                return 0;\\n            \\n            if(pd.size()==1){ \\n                return pd.top();\\n            \\n            \\n                pd.pop();}\\n            \\n            int t=pd.top();\\n              pd.pop();\\n            int m=pd.top();\\n               pd.pop();\\n            \\n            if(t!=m){ \\n                pd.push(abs(t-m));}\\n               \\n            \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1921822,
                "title": "simple-easy-to-understand-beats-100-c-submissions",
                "content": "```\\n    int lastStoneWeight(vector<int>& s) {\\n        int n = s.size();\\n        if(n == 1) return s[0];\\n        sort(s.begin(), s.end());\\n        int i = n-1;\\n        while(i >= 1){\\n            if(s[i-1] == s[i])\\n                i = i - 2;\\n            else{\\n                s[i-1] = s[i] - s[i-1];\\n                i = i -1;\\n                int j = i;\\n                while( j > 0 and s[j-1] > s[j] ){\\n                    swap( s[j-1] , s[j] );\\n                    j--;\\n                }\\n            }\\n        }\\n        if( i == 0 )\\n            return s[i];\\n        else \\n            return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int lastStoneWeight(vector<int>& s) {\\n        int n = s.size();\\n        if(n == 1) return s[0];\\n        sort(s.begin(), s.end());\\n        int i = n-1;\\n        while(i >= 1){\\n            if(s[i-1] == s[i])\\n                i = i - 2;\\n            else{\\n                s[i-1] = s[i] - s[i-1];\\n                i = i -1;\\n                int j = i;\\n                while( j > 0 and s[j-1] > s[j] ){\\n                    swap( s[j-1] , s[j] );\\n                    j--;\\n                }\\n            }\\n        }\\n        if( i == 0 )\\n            return s[i];\\n        else \\n            return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921283,
                "title": "c-faster-than-100-00",
                "content": "Runtime: 68 ms, faster than 100.00% of C# online submissions for Last Stone Weight.\\nMemory Usage: 39.3 MB, less than 5.42% of C# online submissions for Last Stone Weight.\\n\\n```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {        \\n        var list = stones.ToList();\\n        \\n        while(list.Count() >  1)\\n        {\\n            list = list.OrderByDescending(x=>x).ToList();\\n            int f = list[0], s = list[1];\\n            if(f == s)\\n            {\\n                list.RemoveAt(0);\\n                list.RemoveAt(0);\\n            }\\n            else\\n            {\\n                list[1] = f-s;\\n                list.RemoveAt(0);\\n            }\\n        }\\n        return list.Count() > 0 ? list.First() : 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int LastStoneWeight(int[] stones) {        \\n        var list = stones.ToList();\\n        \\n        while(list.Count() >  1)\\n        {\\n            list = list.OrderByDescending(x=>x).ToList();\\n            int f = list[0], s = list[1];\\n            if(f == s)\\n            {\\n                list.RemoveAt(0);\\n                list.RemoveAt(0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1921069,
                "title": "python-heap",
                "content": "```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heapify(max_heap := [-s for s in stones])\\n        \\n        while len(max_heap) > 1:\\n            x = -heappop(max_heap)\\n            y = -heappop(max_heap)\\n            z = x - y\\n            heappush(max_heap, -z) if z else None\\n        \\n        return 0 if not max_heap else -max_heap[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heapify(max_heap := [-s for s in stones])\\n        \\n        while len(max_heap) > 1:\\n            x = -heappop(max_heap)\\n            y = -heappop(max_heap)\\n            z = x - y\\n            heappush(max_heap, -z) if z else None\\n        \\n        return 0 if not max_heap else -max_heap[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792538,
                "title": "java-not-the-best-solution-but-easy-to-understand-1ms-beats-98-48",
                "content": "Disclaimer: This is NOT the most efficient or best way to solve this problem, but in my opinion, it is the easiest way to understand. \\n\\nBasically, if the array is sorted, you want to compare the last two elements until the second to last element becomes zero (because the problem states that at most, there is one stone left).\\n\\nThen, you can just keep iterating through the array using a while loop, while comparing the last two values and changing them accordingly. You need to sort it each time so that the new largest values keep shifting to the right as the smaller stones are being \"destroyed\" aka set to zero. Then, when only one stone remains, you can return that value!\\n\\n```\\npublic int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        int len = stones.length;\\n        \\n        if (len == 1)\\n            return stones[0];\\n        \\n        while (stones[len-2] != 0)\\n        {\\n            int x = stones[len-2];\\n            int y = stones[len-1];\\n            \\n            if (x == y)\\n            {\\n                stones[len-1] = 0;\\n                stones[len-2] = 0;\\n            }\\n            else\\n            {\\n                stones[len-1] = y - x;\\n                stones[len-2] = 0;\\n            }\\n\\n            Arrays.sort(stones);\\n        }\\n        \\n        return stones[len-1];\\n    }\\n\\t\\n```\\n\\t\\nThis runs in 1ms and beats 98.48% of the people.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        int len = stones.length;\\n        \\n        if (len == 1)\\n            return stones[0];\\n        \\n        while (stones[len-2] != 0)\\n        {\\n            int x = stones[len-2];\\n            int y = stones[len-1];\\n            \\n            if (x == y)\\n            {\\n                stones[len-1] = 0;\\n                stones[len-2] = 0;\\n            }\\n            else\\n            {\\n                stones[len-1] = y - x;\\n                stones[len-2] = 0;\\n            }\\n\\n            Arrays.sort(stones);\\n        }\\n        \\n        return stones[len-1];\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171395,
                "title": "c-detailed-explanation-easy-solution",
                "content": "Firstly,we will maintain a priority_queue(max-heap);\\nWHY?\\nBecause the max-heap will keep the heaviest stone by weight on top,as we are allowed to pick the two heaviest elements.\\nNow everytime we need to pick two largest stones,operate on them and then push the result(if non-zero i.e when the stones have unequal weights,we will have to insert the absolute value of the differences into the array).Hmm,so lets think of the data structure which will continuously keep the heaviest stone by weight on top,even after we insert something in the array???Did u guess it??\\nYes,thats a priority-queue,a max-heap by default in C++.\\nSo we will pick the top two elements,pop them out of the queue,if they are equal in weights,they will destroy themselves,so no need to insert a new element into the queue,\\nelse    we will insert the absolute difference of the two into the queue and still end up with the heaviest stone on top due to the nature of priority-queue.\\nTill when do we need to do this,till the priority-queue\\'s size is greater than 1.\\n```\\nint lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<stones.size();i++){\\n            pq.push(stones[i]);\\n        }\\n        while(pq.size()>1){\\n            int curr=pq.top();\\n            pq.pop();\\n            int curr2=pq.top();\\n            pq.pop();\\n            if(curr!=curr2){\\n                pq.push(abs(curr-curr2));\\n            }\\n        }\\n        return pq.empty()?0:pq.top();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<stones.size();i++){\\n            pq.push(stones[i]);\\n        }\\n        while(pq.size()>1){\\n            int curr=pq.top();\\n            pq.pop();\\n            int curr2=pq.top();\\n            pq.pop();\\n            if(curr!=curr2){\\n                pq.push(abs(curr-curr2));\\n            }\\n        }\\n        return pq.empty()?0:pq.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1115372,
                "title": "java-simple-and-easy-to-understand-solution-using-maxheap-1-ms-faster-than-91-16-with-comments",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        /*\\n          Intituation\\n          Here we are using maxHeap,\\n          property of maxHeao:- \\n           The root node has the maximum value.\\n        */\\n        \\n        //maxHeap\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>((a, b) -> (b - a));\\n        \\n        //store all stones, maxHeap\\n        for(int stone : stones) maxHeap.add(stone);\\n        \\n        //iterate till it size is greater than 1\\n        while(maxHeap.size() > 1){\\n            //get first two maximum stone\\n            int stone1 = maxHeap.remove();\\n            int stone2 = maxHeap.remove();\\n            \\n            //add the resultant smashed stone in maxHeap\\n            maxHeap.add(Math.abs(stone1 - stone2));\\n        }\\n        \\n        //last left stone\\n        return maxHeap.remove();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        /*\\n          Intituation\\n          Here we are using maxHeap,\\n          property of maxHeao:- \\n           The root node has the maximum value.\\n        */\\n        \\n        //maxHeap\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>((a, b) -> (b - a));\\n        \\n        //store all stones, maxHeap\\n        for(int stone : stones) maxHeap.add(stone);\\n        \\n        //iterate till it size is greater than 1\\n        while(maxHeap.size() > 1){\\n            //get first two maximum stone\\n            int stone1 = maxHeap.remove();\\n            int stone2 = maxHeap.remove();\\n            \\n            //add the resultant smashed stone in maxHeap\\n            maxHeap.add(Math.abs(stone1 - stone2));\\n        }\\n        \\n        //last left stone\\n        return maxHeap.remove();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841406,
                "title": "go-sorted-array-solution-0ms",
                "content": "We use two standard library functions:\\n\\n**sort.Ints():** sorts an integer slice\\n**sort.SearchInts():** returns the index in which the integer value should be inserted in a sorted slice. \\n\\nhttps://github.com/phea/leetcode-go\\n\\n```go\\nfunc lastStoneWeight(stones []int) int {\\n\\tsort.Ints(stones)\\n\\n\\tfor len(stones) >= 2 {\\n\\t\\tstone := stones[len(stones)-1] - stones[len(stones)-2]\\n\\t\\tstones = stones[:len(stones)-2]\\n\\t\\tif stone > 0 {\\n\\t\\t\\t// push stone in sorted list\\n\\t\\t\\tidx := sort.SearchInts(stones, stone)\\n\\t\\t\\tif idx >= len(stones) {\\n\\t\\t\\t\\tstones = append(stones, stone)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstones = append(stones[:idx], append([]int{stone}, stones[idx:]...)...)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif len(stones) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\treturn stones[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc lastStoneWeight(stones []int) int {\\n\\tsort.Ints(stones)\\n\\n\\tfor len(stones) >= 2 {\\n\\t\\tstone := stones[len(stones)-1] - stones[len(stones)-2]\\n\\t\\tstones = stones[:len(stones)-2]\\n\\t\\tif stone > 0 {\\n\\t\\t\\t// push stone in sorted list\\n\\t\\t\\tidx := sort.SearchInts(stones, stone)\\n\\t\\t\\tif idx >= len(stones) {\\n\\t\\t\\t\\tstones = append(stones, stone)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstones = append(stones[:idx], append([]int{stone}, stones[idx:]...)...)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif len(stones) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\treturn stones[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 638675,
                "title": "most-efficient-c-solution-using-multiset-0-ms-7-8-mb-100-100",
                "content": "```\\nint lastStoneWeight(vector<int>& stones) {\\n        multiset<int, greater<int>> s;\\n        for(auto val: stones) s.insert(val);\\n        while(s.size()>=2){\\n            auto itr = s.begin();\\n            itr++;\\n            int temp = *s.begin()-*itr;\\n\\n            s.erase(s.begin());\\n            s.erase(s.begin());\\n            if(temp>0) s.insert(temp);\\n        }\\n        return *s.begin();\\n    }\\n\\t\\n\\t\\n\\tThe algorithm uses multiset which keeps the values sorted in descending order.\\n\\tThe substraction of first two values is kept in temp which is inserted if its value > 0.\\n\\tThe only value left at last is the answer.",
                "solutionTags": [],
                "code": "```\\nint lastStoneWeight(vector<int>& stones) {\\n        multiset<int, greater<int>> s;\\n        for(auto val: stones) s.insert(val);\\n        while(s.size()>=2){\\n            auto itr = s.begin();\\n            itr++;\\n            int temp = *s.begin()-*itr;\\n\\n            s.erase(s.begin());\\n            s.erase(s.begin());\\n            if(temp>0) s.insert(temp);\\n        }\\n        return *s.begin();\\n    }\\n\\t\\n\\t\\n\\tThe algorithm uses multiset which keeps the values sorted in descending order.\\n\\tThe substraction of first two values is kept in temp which is inserted if its value > 0.\\n\\tThe only value left at last is the answer.",
                "codeTag": "Unknown"
            },
            {
                "id": 622601,
                "title": "python-3-heap-max-heap",
                "content": "##### as the question it self said pick the largest 2 elements ,by changing the signs +ve to -ve a min heap will behave as a max heap and performing the operations \\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones=list(stones[i]*(-1) for i in range(len(stones)))\\n        heapq.heapify(stones)\\n        while len(stones)>1 :\\n            x=heapq.heappop(stones)\\n            y=heapq.heappop(stones)\\n            if x!=y :\\n                heapq.heappush(stones,x-y)\\n            print(stones)\\n        if len(stones)==0 :\\n            return 0\\n        return -(stones[0])\\n```\\n**hope who ever watches understand it :)**",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones=list(stones[i]*(-1) for i in range(len(stones)))\\n        heapq.heapify(stones)\\n        while len(stones)>1 :\\n            x=heapq.heappop(stones)\\n            y=heapq.heappop(stones)\\n            if x!=y :\\n                heapq.heappush(stones,x-y)\\n            print(stones)\\n        if len(stones)==0 :\\n            return 0\\n        return -(stones[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576555,
                "title": "java-solution-with-o-1-space-and-using-arrays-sort",
                "content": "Idea is to keep the max elements at the end all the time, and keep smashing the stones, till we are left with one at stones[stones.length - 1].\\n\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length < 1) {\\n            return 0;\\n        }\\n        if(stones.length == 1) {\\n            return stones[0];\\n        }\\n        Arrays.sort(stones);\\n        int i = stones.length - 2;\\n        int j = stones.length - 1;\\n        while(i >= 0 && j >= 0 && stones[i] != 0) {\\n            stones[i] = stones[j] - stones[i];\\n            stones[j] = 0;\\n            Arrays.sort(stones);\\n        }\\n        return stones[j];\\n    }\\n}\\n```\\n\\nAny feedback is appreciated :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length < 1) {\\n            return 0;\\n        }\\n        if(stones.length == 1) {\\n            return stones[0];\\n        }\\n        Arrays.sort(stones);\\n        int i = stones.length - 2;\\n        int j = stones.length - 1;\\n        while(i >= 0 && j >= 0 && stones[i] != 0) {\\n            stones[i] = stones[j] - stones[i];\\n            stones[j] = 0;\\n            Arrays.sort(stones);\\n        }\\n        return stones[j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576350,
                "title": "java-simple-and-clean-in-place-solution-beats-100-time",
                "content": "Since input constraints are certain and we only change values of 2 items in an already sorted array , there is no need to worry about sorting the array again in each iteration. \\n\\nThe main logic is that when you smash 2 stones both will lose weight at the amount of the lighter one. If 2 has the same weight, they both will become 0 weight as called destroyed. Here is the code \\n\\n```\\npublic static int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n\\n        if (stones.length == 0){\\n            return 0;\\n        }\\n\\n        if(stones.length == 1){\\n            return stones[0];\\n        }\\n\\t\\t\\n\\t\\t//Smash until all stones smashed and there is no pair to smash (There will be only 1 stone or none)\\n        while (stones[stones.length - 2] > 0) {\\n            stones[stones.length - 1] -= stones[stones.length - 2];\\n            stones[stones.length - 2] -= stones[stones.length - 2];\\n            Arrays.sort(stones);\\n        }\\n        \\n        return stones[stones.length - 1];\\n    }\\n```\\n\\nRuntime: 0 ms\\nMemory Usage: 37 MB",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n\\n        if (stones.length == 0){\\n            return 0;\\n        }\\n\\n        if(stones.length == 1){\\n            return stones[0];\\n        }\\n\\t\\t\\n\\t\\t//Smash until all stones smashed and there is no pair to smash (There will be only 1 stone or none)\\n        while (stones[stones.length - 2] > 0) {\\n            stones[stones.length - 1] -= stones[stones.length - 2];\\n            stones[stones.length - 2] -= stones[stones.length - 2];\\n            Arrays.sort(stones);\\n        }\\n        \\n        return stones[stones.length - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575344,
                "title": "java-priority-queue-heap-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length == 0){\\n            return 0;\\n        }\\n        \\n        Comparator<Integer> comparator = (o1, o2) -> o2-o1;\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(comparator);\\n        for(int stone : stones){\\n            queue.offer(stone);\\n        }\\n        \\n        while(queue.size() > 1){\\n            int num1 = queue.poll();\\n            int num2 = queue.poll();\\n            if(num1!= num2){\\n                queue.offer(num1-num2);\\n            }\\n        }\\n        \\n        return queue.isEmpty()?0: queue.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length == 0){\\n            return 0;\\n        }\\n        \\n        Comparator<Integer> comparator = (o1, o2) -> o2-o1;\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(comparator);\\n        for(int stone : stones){\\n            queue.offer(stone);\\n        }\\n        \\n        while(queue.size() > 1){\\n            int num1 = queue.poll();\\n            int num2 = queue.poll();\\n            if(num1!= num2){\\n                queue.offer(num1-num2);\\n            }\\n        }\\n        \\n        return queue.isEmpty()?0: queue.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465787,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer>queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int item : stones)queue.add(item);\\n        while (queue.size()>1){\\n            int i1 = queue.poll();\\n            int i2 = queue.poll();\\n            if (i1!=i2)queue.add(Math.abs(i1-i2));\\n        }\\n        return queue.isEmpty()?0:queue.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer>queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int item : stones)queue.add(item);\\n        while (queue.size()>1){\\n            int i1 = queue.poll();\\n            int i2 = queue.poll();\\n            if (i1!=i2)queue.add(Math.abs(i1-i2));\\n        }\\n        return queue.isEmpty()?0:queue.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426273,
                "title": "python-beginner-99-81-fast-100-memo-simple-sort-loop-explained",
                "content": "```\\ndef lastStoneWeight(self, stones: List[int]) -> int:\\n\\tfor i in range(len(stones)-1):                # loop till the lastone remain\\n\\t\\tstones.sort()                             # smash the heaviest, the heaviest to end of the list\\n\\t\\tstones[-2] = abs(stones[-2] - stones[-1]) # y-x / 0 doent matter which one is bigger\\n\\t\\tstones.pop()                              # Destroy the stone \\n\\treturn stones[0]                              # return the only element in the list\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef lastStoneWeight(self, stones: List[int]) -> int:\\n\\tfor i in range(len(stones)-1):                # loop till the lastone remain\\n\\t\\tstones.sort()                             # smash the heaviest, the heaviest to end of the list\\n\\t\\tstones[-2] = abs(stones[-2] - stones[-1]) # y-x / 0 doent matter which one is bigger\\n\\t\\tstones.pop()                              # Destroy the stone \\n\\treturn stones[0]                              # return the only element in the list\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 423312,
                "title": "python-100-100-simple-6-liner-with-max-heapq-o-nlogn",
                "content": "```\\nimport heapq as h\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        for i in range(len(stones)):stones[i]*=-1\\n        heapq.heapify(stones)\\n        while len(stones)>1:\\n            a, b = abs(h.heappop(stones)), abs(h.heappop(stones))\\n            if a!=b:    h.heappush(stones, b-a)\\n        return abs(stones[0]) if stones else 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq as h\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        for i in range(len(stones)):stones[i]*=-1\\n        heapq.heapify(stones)\\n        while len(stones)>1:\\n            a, b = abs(h.heappop(stones)), abs(h.heappop(stones))\\n            if a!=b:    h.heappush(stones, b-a)\\n        return abs(stones[0]) if stones else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419535,
                "title": "java-implementation-using-max-heap-priority-queue-with-explanation",
                "content": "basic idea is to sort the array using a max heap(Priority Queue). Then we pop the largest two values and subtract(smash) them, then push the result back to the heap \\n\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n    \\n    //max heap using priority queue    \\n    PriorityQueue<Integer> queue = new PriorityQueue<>((o1,o2) -> o2-o1);\\n    \\n    //sorting using max heap    \\n    for(int stone : stones)\\n    queue.offer(stone);   \\n    \\n    // remove the largest two values and subtract them. Add the result back to the heap\\n    while(queue.size()>1)\\n    queue.offer(queue.poll()-queue.poll());\\n        \\n    return queue.poll();    \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int lastStoneWeight(int[] stones) {\\n    \\n    //max heap using priority queue    \\n    PriorityQueue<Integer> queue = new PriorityQueue<>((o1,o2) -> o2-o1);\\n    \\n    //sorting using max heap    \\n    for(int stone : stones)\\n    queue.offer(stone);   \\n    \\n    // remove the largest two values and subtract them. Add the result back to the heap\\n    while(queue.size()>1)\\n    queue.offer(queue.poll()-queue.poll());\\n        \\n    return queue.poll();    \\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 396108,
                "title": "easy-c-solution-0ms-beats-100-using-priority-queue",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Last Stone Weight.\\nMemory Usage: 8.3 MB, less than 100.00% of C++ online submissions for Last Stone Weight.\\n\\n```\\nint lastStoneWeight(vector<int>& stones) {\\n        \\n        priority_queue<int> pq;\\n        int n = stones.size();\\n        \\n        for(int i=0; i<n; i++)\\n            pq.push(stones[i]);\\n        \\n        while(!pq.empty())\\n        {\\n            if(pq.size() == 1)\\n                return pq.top();\\n            \\n            int y = pq.top();\\n            pq.pop();\\n            \\n            int x = pq.top();\\n            pq.pop();\\n            \\n            if(x != y)\\n                pq.push(y - x);\\n        }\\n        \\n        if(pq.size() == 0)\\n            return 0;\\n        return pq.top();\\n    }",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Last Stone Weight.\\nMemory Usage: 8.3 MB, less than 100.00% of C++ online submissions for Last Stone Weight.\\n\\n```\\nint lastStoneWeight(vector<int>& stones) {\\n        \\n        priority_queue<int> pq;\\n        int n = stones.size();\\n        \\n        for(int i=0; i<n; i++)\\n            pq.push(stones[i]);\\n        \\n        while(!pq.empty())\\n        {\\n            if(pq.size() == 1)\\n                return pq.top();\\n            \\n            int y = pq.top();\\n            pq.pop();\\n            \\n            int x = pq.top();\\n            pq.pop();\\n            \\n            if(x != y)\\n                pq.push(y - x);\\n        }\\n        \\n        if(pq.size() == 0)\\n            return 0;\\n        return pq.top();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 382436,
                "title": "priority-queue-with-javascript",
                "content": "\\tfunction PriorityQueue() {\\n\\t\\tthis.heap = [null];\\n\\t\\tthis.insert = function(value) {\\n\\t\\t\\tthis.heap.push(value);\\n\\t\\t\\tlet currentNodeIdx = this.heap.length - 1;\\n\\t\\t\\tlet currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\\n\\t\\t\\twhile (\\n\\t\\t\\t  this.heap[currentNodeParentIdx] &&\\n\\t\\t\\t  value > this.heap[currentNodeParentIdx]\\n\\t\\t\\t) {\\n\\t\\t\\t  let parent = this.heap[currentNodeParentIdx];\\n\\t\\t\\t  this.heap[currentNodeParentIdx] = value;\\n\\t\\t\\t  this.heap[currentNodeIdx] = parent;\\n\\t\\t\\t  currentNodeIdx = currentNodeParentIdx;\\n\\t\\t\\t  currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\n\\t\\tthis.remove = function() {\\n\\t\\t  if (this.heap.length < 3) {\\n\\t\\t\\tconst toReturn = this.heap.pop();\\n\\t\\t\\tthis.heap[0] = null;\\n\\t\\t\\treturn toReturn;\\n\\t\\t  }\\n\\t\\t  const toRemove = this.heap[1];\\n\\t\\t  this.heap[1] = this.heap.pop();\\n\\t\\t  let currentIdx = 1;\\n\\t\\t  let [left, right] = [2*currentIdx, 2*currentIdx + 1];\\n\\t\\t  let currentChildIdx = this.heap[right] && \\n\\t\\t\\t  this.heap[right] >= this.heap[left] ? right : left;\\n\\t\\t  while (this.heap[currentChildIdx] && this.heap[currentIdx] < this.heap[currentChildIdx]) {\\n\\t\\t\\tlet currentNode = this.heap[currentIdx]\\n\\t\\t\\tlet currentChildNode = this.heap[currentChildIdx];\\n\\t\\t\\tthis.heap[currentChildIdx] = currentNode;\\n\\t\\t\\tthis.heap[currentIdx] = currentChildNode;\\n\\t\\t\\t currentIdx = currentChildIdx;\\n\\t\\t\\t[left, right] = [2*currentIdx, 2*currentIdx + 1];\\n\\t\\t\\tcurrentChildIdx = this.heap[right] && \\n\\t\\t\\t  this.heap[right] >= this.heap[left] ? right : left;\\n\\t\\t  }\\n\\t\\t  return toRemove;\\n\\t\\t}\\n\\t}\\n\\n\\tvar lastStoneWeight = function(stones) {\\n\\t\\tconst pq = new PriorityQueue();\\n\\t\\tfor(let i=0; i<stones.length; i++){\\n\\t\\t\\tpq.insert(stones[i]);\\n\\t\\t}\\n\\t\\twhile(pq.heap.length > 2){\\n\\t\\t\\tlet x = pq.remove();\\n\\t\\t\\tlet y = pq.remove();\\n\\t\\t\\tif(x != y){\\n\\t\\t\\t\\tlet max = Math.max(x, y);\\n\\t\\t\\t\\tlet min = Math.min(x, y);\\n\\t\\t\\t\\tlet z = max - min;\\n\\t\\t\\t\\tpq.insert(z);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn pq.remove();\\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "\\tfunction PriorityQueue() {\\n\\t\\tthis.heap = [null];\\n\\t\\tthis.insert = function(value) {\\n\\t\\t\\tthis.heap.push(value);\\n\\t\\t\\tlet currentNodeIdx = this.heap.length - 1;\\n\\t\\t\\tlet currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\\n\\t\\t\\twhile (\\n\\t\\t\\t  this.heap[currentNodeParentIdx] &&\\n\\t\\t\\t  value > this.heap[currentNodeParentIdx]\\n\\t\\t\\t) {\\n\\t\\t\\t  let parent = this.heap[currentNodeParentIdx];\\n\\t\\t\\t  this.heap[currentNodeParentIdx] = value;\\n\\t\\t\\t  this.heap[currentNodeIdx] = parent;\\n\\t\\t\\t  currentNodeIdx = currentNodeParentIdx;\\n\\t\\t\\t  currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\n\\t\\tthis.remove = function() {\\n\\t\\t  if (this.heap.length < 3) {\\n\\t\\t\\tconst toReturn = this.heap.pop();\\n\\t\\t\\tthis.heap[0] = null;\\n\\t\\t\\treturn toReturn;\\n\\t\\t  }\\n\\t\\t  const toRemove = this.heap[1];\\n\\t\\t  this.heap[1] = this.heap.pop();\\n\\t\\t  let currentIdx = 1;\\n\\t\\t  let [left, right] = [2*currentIdx, 2*currentIdx + 1];\\n\\t\\t  let currentChildIdx = this.heap[right] && \\n\\t\\t\\t  this.heap[right] >= this.heap[left] ? right : left;\\n\\t\\t  while (this.heap[currentChildIdx] && this.heap[currentIdx] < this.heap[currentChildIdx]) {\\n\\t\\t\\tlet currentNode = this.heap[currentIdx]\\n\\t\\t\\tlet currentChildNode = this.heap[currentChildIdx];\\n\\t\\t\\tthis.heap[currentChildIdx] = currentNode;\\n\\t\\t\\tthis.heap[currentIdx] = currentChildNode;\\n\\t\\t\\t currentIdx = currentChildIdx;\\n\\t\\t\\t[left, right] = [2*currentIdx, 2*currentIdx + 1];\\n\\t\\t\\tcurrentChildIdx = this.heap[right] && \\n\\t\\t\\t  this.heap[right] >= this.heap[left] ? right : left;\\n\\t\\t  }\\n\\t\\t  return toRemove;\\n\\t\\t}\\n\\t}\\n\\n\\tvar lastStoneWeight = function(stones) {\\n\\t\\tconst pq = new PriorityQueue();\\n\\t\\tfor(let i=0; i<stones.length; i++){\\n\\t\\t\\tpq.insert(stones[i]);\\n\\t\\t}\\n\\t\\twhile(pq.heap.length > 2){\\n\\t\\t\\tlet x = pq.remove();\\n\\t\\t\\tlet y = pq.remove();\\n\\t\\t\\tif(x != y){\\n\\t\\t\\t\\tlet max = Math.max(x, y);\\n\\t\\t\\t\\tlet min = Math.min(x, y);\\n\\t\\t\\t\\tlet z = max - min;\\n\\t\\t\\t\\tpq.insert(z);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn pq.remove();\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 305460,
                "title": "python-use-heapq",
                "content": "```\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        stones = [-1*i for i in stones]\\n        while len(stones)>1:\\n            heapq.heapify(stones)\\n            s1 = heapq.heappop(stones)\\n            s2 = heapq.heappop(stones)\\n            dlt = s1-s2\\n            if dlt != 0:\\n                heapq.heappush(stones,dlt)\\n        return -1*stones[0] if stones else 0\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        stones = [-1*i for i in stones]\\n        while len(stones)>1:\\n            heapq.heapify(stones)\\n            s1 = heapq.heappop(stones)\\n            s2 = heapq.heappop(stones)\\n            dlt = s1-s2\\n            if dlt != 0:\\n                heapq.heappush(stones,dlt)\\n        return -1*stones[0] if stones else 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 300230,
                "title": "intuitive-c-solution-100-run-time-100-memory",
                "content": "```class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {        \\n        while(stones.size() > 1)\\n        {\\n            sort(stones.begin(),stones.end());\\n            int y = stones[stones.size()-1];\\n            int x = stones[stones.size()-2];\\n            \\n            if(x == y)\\n            {\\n                stones.erase(stones.begin() + stones.size()-1);\\n                stones.erase(stones.begin() + stones.size()-1); // removes the two biggest numbers.\\n            }\\n            else\\n            {\\n                stones[stones.size()-2] = stones[stones.size()-1] - stones[stones.size()-2];\\n                \\n                stones.erase(stones.begin() + stones.size()-1);                \\n            }\\n        }\\n        \\n        if(stones.size() == 1)\\n            return stones[0];\\n        \\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {        \\n        while(stones.size() > 1)\\n        {\\n            sort(stones.begin(),stones.end());\\n            int y = stones[stones.size()-1];\\n            int x = stones[stones.size()-2];\\n            \\n            if(x == y)\\n            {\\n                stones.erase(stones.begin() + stones.size()-1);\\n                stones.erase(stones.begin() + stones.size()-1); // removes the two biggest numbers.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 297053,
                "title": "c-0ms-faster-than-100-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> qu(stones.begin(),stones.end());\\n        \\n        while(qu.size() != 0 && qu.size() != 1){\\n            int temp1 = qu.top();\\n            qu.pop();\\n            int temp2 = qu.top();\\n            qu.pop();\\n            \\n            if(temp2 != temp1) qu.push(temp1 - temp2); \\n        }\\n        \\n        if(!qu.size()) return 0;\\n        else return qu.top();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> qu(stones.begin(),stones.end());\\n        \\n        while(qu.size() != 0 && qu.size() != 1){\\n            int temp1 = qu.top();\\n            qu.pop();\\n            int temp2 = qu.top();\\n            qu.pop();\\n            \\n            if(temp2 != temp1) qu.push(temp1 - temp2); \\n        }\\n        \\n        if(!qu.size()) return 0;\\n        else return qu.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296057,
                "title": "1046-php-solutions-using-sort-and-priority-queue",
                "content": "The two solutions seem to be pretty equivalent speed-wise.\\n\\nHere\\'s a sort-based solution.\\n\\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[] $stones\\n     * @return Integer\\n     */\\n    function lastStoneWeight($stones)\\n    {\\n        while (1 < count($stones)) {\\n            rsort($stones, SORT_NUMERIC);\\n            $outcome = array_shift($stones) - array_shift($stones);\\n            if (0 < $outcome) array_push($stones, $outcome);\\n        }\\n        return $stones[0] ?? 0;\\n    }\\n}\\n```\\n\\nAnd here\\'s a priority queue-based solution.\\n\\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[] $stones\\n     * @return Integer\\n     */\\n    function lastStoneWeight($stones)\\n    {\\n        $pq = new SplPriorityQueue();\\n        $pq->setExtractFlags(SplPriorityQueue::EXTR_DATA);\\n        foreach ($stones as $stone) $pq->insert($stone, $stone);\\n        while (1 < $pq->count()) {\\n            $outcome = $pq->extract() - $pq->extract();\\n            if (0 < $outcome) $pq->insert($outcome, $outcome);\\n        }\\n        return $pq->current() ?? 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[] $stones\\n     * @return Integer\\n     */\\n    function lastStoneWeight($stones)\\n    {\\n        while (1 < count($stones)) {\\n            rsort($stones, SORT_NUMERIC);\\n            $outcome = array_shift($stones) - array_shift($stones);\\n            if (0 < $outcome) array_push($stones, $outcome);\\n        }\\n        return $stones[0] ?? 0;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[] $stones\\n     * @return Integer\\n     */\\n    function lastStoneWeight($stones)\\n    {\\n        $pq = new SplPriorityQueue();\\n        $pq->setExtractFlags(SplPriorityQueue::EXTR_DATA);\\n        foreach ($stones as $stone) $pq->insert($stone, $stone);\\n        while (1 < $pq->count()) {\\n            $outcome = $pq->extract() - $pq->extract();\\n            if (0 < $outcome) $pq->insert($outcome, $outcome);\\n        }\\n        return $pq->current() ?? 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295468,
                "title": "simple-c-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) \\n    {\\n        for(int i=stones.size()-1; i>=1;)\\n        { \\n            sort(stones.begin(),stones.end());\\n            \\n            auto iNum           = stones[i];\\n            auto iM1Num         = stones[i-1];\\n            auto temp           = iNum - iM1Num;\\n\\n            stones.pop_back();\\n            stones.pop_back();\\n\\n             if(iNum  != iM1Num)\\n                stones.push_back(temp);\\n\\n            i = stones.size()-1;\\n        }\\n        return stones.size() > 0 ? stones[0] : 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) \\n    {\\n        for(int i=stones.size()-1; i>=1;)\\n        { \\n            sort(stones.begin(),stones.end());\\n            \\n            auto iNum           = stones[i];\\n            auto iM1Num         = stones[i-1];\\n            auto temp           = iNum - iM1Num;\\n\\n            stones.pop_back();\\n            stones.pop_back();\\n\\n             if(iNum  != iM1Num)\\n                stones.push_back(temp);\\n\\n            i = stones.size()-1;\\n        }\\n        return stones.size() > 0 ? stones[0] : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295449,
                "title": "python-solution-heapq-beats-100-time-and-memory-20-ms",
                "content": "```\\nimport heapq\\n\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        heapq.heapify(stones)\\n        \\n        while len(stones) > 1:\\n            largest = heapq.nlargest(2, stones)\\n            diff = abs(largest[0] - largest[1])\\n    \\n            for item in largest:\\n                stones.remove(item)\\n                \\n            if diff > 0:\\n                heapq.heappush(stones, diff)\\n            \\n        if stones:\\n            return stones[0]\\n        return 0\\n\\t",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        heapq.heapify(stones)\\n        \\n        while len(stones) > 1:\\n            largest = heapq.nlargest(2, stones)\\n            diff = abs(largest[0] - largest[1])\\n    \\n            for item in largest:\\n                stones.remove(item)\\n                \\n            if diff > 0:\\n                heapq.heappush(stones, diff)\\n            \\n        if stones:\\n            return stones[0]\\n        return 0\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 295107,
                "title": "java-solution-using-priorityqueue",
                "content": "* Store all elements in the Priority Queue in decreasing order.\\n* Each time, poll 2 elements from the Priority Queue until its size is 1 and add the absolute difference between the 2 elements back to the queue.\\n* Return 0 if the PriorityQueue is empty or return the last element remaining in the PriorityQueue\\n```\\npublic int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length == 0)\\n            return 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++)\\n            pq.add(stones[i]);\\n        while(pq.size() > 1) {\\n            int a = pq.poll();\\n            int b = pq.poll();\\n            if(a - b != 0)\\n                pq.add(Math.abs(a - b));\\n        }\\n        if(pq.size() == 1)\\n            return pq.poll();\\n        else\\n            return 0;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length == 0)\\n            return 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++)\\n            pq.add(stones[i]);\\n        while(pq.size() > 1) {\\n            int a = pq.poll();\\n            int b = pq.poll();\\n            if(a - b != 0)\\n                pq.add(Math.abs(a - b));\\n        }\\n        if(pq.size() == 1)\\n            return pq.poll();\\n        else\\n            return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295005,
                "title": "java-simplest-easiest-priority-queue",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for (int s : stones) {\\n            queue.add(s);\\n        }\\n        while (queue.size() > 1) {\\n            int weight1 = queue.poll();\\n            int weight2 = queue.poll();\\n            queue.add(weight1 - weight2);\\n        }\\n        return queue.size() == 0? 0 : queue.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for (int s : stones) {\\n            queue.add(s);\\n        }\\n        while (queue.size() > 1) {\\n            int weight1 = queue.poll();\\n            int weight2 = queue.poll();\\n            queue.add(weight1 - weight2);\\n        }\\n        return queue.size() == 0? 0 : queue.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294959,
                "title": "python-4-liner",
                "content": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        for _ in range(len(stones) - 1):\\n            bisect.insort(stones, stones.pop() - stones.pop())\\n        return stones[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        for _ in range(len(stones) - 1):\\n            bisect.insort(stones, stones.pop() - stones.pop())\\n        return stones[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294949,
                "title": "easy-and-concise-c",
                "content": "class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& a) {\\n        \\n        if(!a.size())\\n            return 0;\\n        int i,j = a[0];\\n        int n = a.size();\\n        \\n        while(a.size()>1)\\n        {\\n            sort(a.begin(),a.end(),greater<int>());\\n            a[1]=a[0]-a[1];\\n            a.erase(a.begin());\\n        }\\n        return a[0];\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& a) {\\n        \\n        if(!a.size())\\n            return 0;\\n        int i,j = a[0];\\n        int n = a.size();\\n        \\n        while(a.size()>1)\\n        {\\n            sort(a.begin(),a.end(),greater<int>());\\n            a[1]=a[0]-a[1];\\n            a.erase(a.begin());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4105275,
                "title": "beats-100-of-c-users",
                "content": "![image.png](https://assets.leetcode.com/users/images/606b6310-cfdc-4d82-9375-496a448765e6_1695990050.8100019.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* Simple application on priority queues. \\n* All we just need to get the biggest two elements in the priority queue, and then check if both are equal, get rid of both of them, else, insert the new stone with the new value. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Create a priority queue of integers. \\n* insert all elements in it. \\n* while there are still some stones :\\n    * get the top element with biggest value. \\n    * remove it from the queue\\n    * if there are no more stones, return that stone. \\n    * else get the second stone. \\n    * check if both are equal, then just continue. \\n    * else check which is smaller, then subtract it from the bigger, then insert the result in the queue again.  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n* O(n + m), where n is the number of node, and m is the largest possible value. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n* O(n) for the priority queue. \\n# Code\\n```\\nclass Solution {\\npublic:\\n   #define DPSolver ios_base ::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\n\\nint lastStoneWeight(vector<int> &stones)\\n{\\n    DPSolver;\\n    priority_queue<int> pq;\\n    for (auto stone : stones)\\n        pq.push(stone);\\n\\n    while (pq.size())\\n    {\\n        int top1 = pq.top();\\n        pq.pop();\\n        if (pq.empty())\\n            return top1;\\n        int top2 = pq.top();\\n        pq.pop();\\n        if (top1 <= top2)\\n        {\\n            if (top1 == top2)\\n                continue;\\n            else\\n            {\\n                top2 -= top1;\\n                pq.push(top2);\\n            }\\n        }\\n        else\\n        {\\n            if (top1 == top2)\\n                continue;\\n            else\\n            {\\n                top1 -= top2;\\n                pq.push(top1);\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   #define DPSolver ios_base ::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\n\\nint lastStoneWeight(vector<int> &stones)\\n{\\n    DPSolver;\\n    priority_queue<int> pq;\\n    for (auto stone : stones)\\n        pq.push(stone);\\n\\n    while (pq.size())\\n    {\\n        int top1 = pq.top();\\n        pq.pop();\\n        if (pq.empty())\\n            return top1;\\n        int top2 = pq.top();\\n        pq.pop();\\n        if (top1 <= top2)\\n        {\\n            if (top1 == top2)\\n                continue;\\n            else\\n            {\\n                top2 -= top1;\\n                pq.push(top2);\\n            }\\n        }\\n        else\\n        {\\n            if (top1 == top2)\\n                continue;\\n            else\\n            {\\n                top1 -= top2;\\n                pq.push(top1);\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3996347,
                "title": "c-solution-using-maxheap-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nput all the elements in a maxheap and keep comparing the top two elements until the heap is empty or only one element is left in heap.\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int x: stones){\\n            pq.push(x);\\n        }\\n        int ans = 0;\\n        while(!pq.empty()){\\n            int m = pq.top();\\n            pq.pop();\\n            if(pq.empty()) ans = m;\\n            if(!pq.empty()){\\n                if(m == pq.top()){\\n                    pq.pop();\\n                }\\n                else if(pq.top() < m){\\n                    m = m - pq.top();\\n                    pq.pop();\\n                    pq.push(m);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int x: stones){\\n            pq.push(x);\\n        }\\n        int ans = 0;\\n        while(!pq.empty()){\\n            int m = pq.top();\\n            pq.pop();\\n            if(pq.empty()) ans = m;\\n            if(!pq.empty()){\\n                if(m == pq.top()){\\n                    pq.pop();\\n                }\\n                else if(pq.top() < m){\\n                    m = m - pq.top();\\n                    pq.pop();\\n                    pq.push(m);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935461,
                "title": "0ms-solution-c-maxheap",
                "content": "# Intuition\\nThe problem asks us to repeatedly smash the two largest stones until there is either one stone left or no stones left. To do this efficiently, we can use a max-heap (priority_queue) to always select the two largest stones for smashing.\\n\\n# Approach\\n1. Initialize a max-heap (priority_queue) called maxheap.\\n2. Add all the stones to the maxheap.\\n3. Continue the following steps until there is either one stone or no stones left:\\n   a. Check if the size of maxheap is 1. If so, return the value of the last remaining stone as it is the final result.\\n   b. Check if the size of maxheap is 0. If so, return 0 because all stones have been smashed and there are no stones left.\\n   c. Pop the first largest stone (maxheap.top()) from maxheap and store it in the variable \\'first\\'.\\n   d. Pop the second largest stone (maxheap.top()) from maxheap and store it in the variable \\'second\\'.\\n   e. Check if \\'first\\' is not equal to \\'second\\'. If they are not equal, it means they can be smashed into a smaller stone.\\n   f. Push the difference between \\'first\\' and \\'second\\' back into maxheap to represent the smashed stone.\\n4. Return the result obtained from step 3a.\\n\\n# Complexity\\n- Time complexity:\\n  - Inserting all n stones into the maxheap initially takes O(n * log(n)) time.\\n  - In each iteration, we perform constant time operations until the size of maxheap reduces to 1 or 0. Therefore, the overall time complexity is O(n * log(n)) where n is the number of stones.\\n- Space complexity:\\n  - The space complexity is O(n) to store the maxheap, where n is the number of stones.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> maxheap;\\n        for(auto elm: stones)\\n        {\\n            maxheap.push(elm);\\n        }\\n        while(true)\\n        {\\n            if(maxheap.size()==1)\\n            return maxheap.top();\\n            if(maxheap.size()==0)\\n            return 0;\\n            int first=maxheap.top();\\n            maxheap.pop();\\n            int second= maxheap.top();\\n            maxheap.pop();\\n            if(first!=second)\\n            {\\n                maxheap.push((first-second));\\n                \\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> maxheap;\\n        for(auto elm: stones)\\n        {\\n            maxheap.push(elm);\\n        }\\n        while(true)\\n        {\\n            if(maxheap.size()==1)\\n            return maxheap.top();\\n            if(maxheap.size()==0)\\n            return 0;\\n            int first=maxheap.top();\\n            maxheap.pop();\\n            int second= maxheap.top();\\n            maxheap.pop();\\n            if(first!=second)\\n            {\\n                maxheap.push((first-second));\\n                \\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478482,
                "title": "python-simple-clean-solution-using-python-library",
                "content": "# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        s = SortedList(stones)\\n        while len(s) > 1:\\n            y = s.pop()\\n            x = s.pop()\\n\\n            if x != y:\\n                y -= x\\n                s.add(y)\\n        if s:\\n            return s[0]\\n        return 0\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        s = SortedList(stones)\\n        while len(s) > 1:\\n            y = s.pop()\\n            x = s.pop()\\n\\n            if x != y:\\n                y -= x\\n                s.add(y)\\n        if s:\\n            return s[0]\\n        return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478283,
                "title": "0ms-runtime-c-easy-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& A) {\\n          priority_queue<int> pq(begin(A), end(A));\\n        while (pq.size() > 1) {\\n            int x = pq.top(); pq.pop();\\n            int y = pq.top(); pq.pop();\\n            if (x > y) pq.push(x - y);\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& A) {\\n          priority_queue<int> pq(begin(A), end(A));\\n        while (pq.size() > 1) {\\n            int x = pq.top(); pq.pop();\\n            int y = pq.top(); pq.pop();\\n            if (x > y) pq.push(x - y);\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451681,
                "title": "easy-c-solution-beats-100-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n            /* please upvote if found solution helpful \\uD83D\\uDE04*/\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n       priority_queue<int>sequence(stones.begin(),stones.end());\\n\\n       //using priority queue to get access to heighest weight values direcly\\n\\n       while(sequence.size()>1){\\n           int a=sequence.top();\\n           sequence.pop();\\n           int b=sequence.top();\\n           sequence.pop();\\n\\n           //now we have got the top two values\\n           //now we want to reduce their weight if they are not equal\\n           if(a!=b){\\n               sequence.push(abs(a-b));\\n           }\\n       }\\n       return sequence.empty() ?  0 :  sequence.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n            /* please upvote if found solution helpful \\uD83D\\uDE04*/\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n       priority_queue<int>sequence(stones.begin(),stones.end());\\n\\n       //using priority queue to get access to heighest weight values direcly\\n\\n       while(sequence.size()>1){\\n           int a=sequence.top();\\n           sequence.pop();\\n           int b=sequence.top();\\n           sequence.pop();\\n\\n           //now we have got the top two values\\n           //now we want to reduce their weight if they are not equal\\n           if(a!=b){\\n               sequence.push(abs(a-b));\\n           }\\n       }\\n       return sequence.empty() ?  0 :  sequence.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451440,
                "title": "easy-solution-in-c-simple-using-loop-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n5 5\\n[1 1 2 4 7 8] \\n[1 1 2 4 0 1]  \\n\\n4 5\\n[0 1 1 1 2 4] \\n[0 1 1 1 0 2]\\n\\n3 5\\n[0 0 1 1 1 2]\\n[0 0 1 1 0 1]  \\n\\n2 5\\n[0 0 0 1 1 1 ]\\n[0 0 0 1 0 0]\\n\\n1 5\\n[0 0 0 0 0 1]\\n[0 0 0 0 0 1]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n       int i=stones.size()-1;\\n       int j=stones.size()-1;\\n       while(j>0){\\n            sort(stones.begin(),stones.end());\\n            if(stones[i]==stones[i-1]){\\n                stones[i]=0;\\n                stones[i-1]=0;\\n            }\\n            else{\\n                stones[i]=stones[i]-stones[i-1];\\n                stones[i-1]=0;\\n            }\\n            j--;\\n       }\\n        int k=stones.size()-1;\\n        return stones[k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n       int i=stones.size()-1;\\n       int j=stones.size()-1;\\n       while(j>0){\\n            sort(stones.begin(),stones.end());\\n            if(stones[i]==stones[i-1]){\\n                stones[i]=0;\\n                stones[i-1]=0;\\n            }\\n            else{\\n                stones[i]=stones[i]-stones[i-1];\\n                stones[i-1]=0;\\n            }\\n            j--;\\n       }\\n        int k=stones.size()-1;\\n        return stones[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451266,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n\\n        for (int i = 0; i < stones.length; i++) {\\n            list.add(stones[i]);\\n        }\\n\\n        while (list.size() > 1) {\\n            Collections.sort(list);\\n            int x = list.get(list.size() - 2);\\n            int y = list.get(list.size() - 1);\\n            list.remove(list.size() - 1);\\n            list.remove(list.size() - 1);\\n            if (x != y) {\\n                list.add(y - x);\\n            }\\n        }\\n\\n        return list.isEmpty() ? 0 : list.get(0);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n\\n        for (int i = 0; i < stones.length; i++) {\\n            list.add(stones[i]);\\n        }\\n\\n        while (list.size() > 1) {\\n            Collections.sort(list);\\n            int x = list.get(list.size() - 2);\\n            int y = list.get(list.size() - 1);\\n            list.remove(list.size() - 1);\\n            list.remove(list.size() - 1);\\n            if (x != y) {\\n                list.add(y - x);\\n            }\\n        }\\n\\n        return list.isEmpty() ? 0 : list.get(0);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450669,
                "title": "java-priorityqueue-1-ms",
                "content": "\\n# Complexity\\n- Time complexity:\\nO ( nlog(n) )\\n\\n- Space complexity:\\nO ( n )\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int res=0;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i: stones){\\n            pq.add(i);\\n        }\\n        while(!pq.isEmpty()){\\n            if(pq.size()==1){\\n                return pq.poll();\\n            }\\n            int f=pq.poll();\\n            int s=pq.poll();\\n            if(Math.abs(f-s)!=0){\\n                pq.add(Math.abs(f-s));\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int res=0;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i: stones){\\n            pq.add(i);\\n        }\\n        while(!pq.isEmpty()){\\n            if(pq.size()==1){\\n                return pq.poll();\\n            }\\n            int f=pq.poll();\\n            int s=pq.poll();\\n            if(Math.abs(f-s)!=0){\\n                pq.add(Math.abs(f-s));\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449920,
                "title": "most-optimised-solution-with-detailed-explanation-clean-code",
                "content": "\\n\\n# Approach\\nWe are given an array of integers stones where stones[i] is the weight of the ith stone. We need to play a game with the stones, where on each turn, we choose the heaviest two stones and smash them together. The result of this smash is:\\n\\n- If x == y, both stones are destroyed.\\n- If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\\nThe game continues until there is at most one stone left, and we need to return the weight of the last remaining stone. If there are no stones left, we need to return 0.\\n\\nTo solve this problem, we can simulate the game using a priority queue (heap) in C++. The priority queue can be used to keep track of the heaviest stones.\\n\\nWe can start by inserting all the stones into the priority queue. The priority queue will automatically sort the stones in descending order based on their weight. Therefore, the heaviest stone will be at the front of the queue.\\n\\nIn each turn of the game, we can remove the two heaviest stones from the priority queue using the top() method. We can then smash the stones together according to the rules of the game and insert the resulting stone (if any) back into the priority queue using the push() method.\\n\\nWe can continue this process until there is only one stone left in the priority queue, which will be the result of the game. We can then return the weight of this stone using the top() method.\\n\\nIf there are no stones left in the priority queue, we need to return 0.\\n\\nHere is the step-by-step process of the algorithm:\\n\\n1. Create a priority queue pq and insert all the stones into it.\\n2. While pq has more than 1 stone:\\n- Remove the two heaviest stones y and x from pq.\\n- If x != y, calculate the difference y - x and insert it back into pq.\\n3. Return the weight of the last remaining stone in pq (using the top() method) if there is one, otherwise return 0.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(std::vector<int>& stones) {\\n        std::sort(stones.rbegin(), stones.rend());\\n        while (stones.size() > 1) {\\n            int y = stones[0]; \\n            int x = stones[1];\\n            stones.erase(stones.begin(), stones.begin()+2);\\n            if (x != y) {\\n                stones.insert(std::upper_bound(stones.begin(), stones.end(), y-x, std::greater<int>()), y-x);\\n            }\\n        }\\n        return stones.empty() ? 0 : stones[0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(std::vector<int>& stones) {\\n        std::sort(stones.rbegin(), stones.rend());\\n        while (stones.size() > 1) {\\n            int y = stones[0]; \\n            int x = stones[1];\\n            stones.erase(stones.begin(), stones.begin()+2);\\n            if (x != y) {\\n                stones.insert(std::upper_bound(stones.begin(), stones.end(), y-x, std::greater<int>()), y-x);\\n            }\\n        }\\n        return stones.empty() ? 0 : stones[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449625,
                "title": "simple-priorityqueue-question-java-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++) q.offer(stones[i]);\\n        while(q.size() > 1) {\\n            int a = q.poll();\\n            int b = q.poll();\\n            q.offer(a-b);\\n        }\\n        if(q.isEmpty()) return 0;\\n        else return q.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++) q.offer(stones[i]);\\n        while(q.size() > 1) {\\n            int a = q.poll();\\n            int b = q.poll();\\n            q.offer(a-b);\\n        }\\n        if(q.isEmpty()) return 0;\\n        else return q.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1872390,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1828053,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872557,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1566055,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872394,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1576558,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1575436,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872441,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872758,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872432,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872390,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1828053,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872557,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1566055,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872394,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1576558,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1575436,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872441,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872758,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872432,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1576588,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1992059,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1940250,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872810,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872776,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872771,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872765,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872538,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872524,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872450,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Swaps to Arrange a Binary Grid",
        "question_content": "<p>Given an <code>n x n</code> binary <code>grid</code>, in one step you can choose two <strong>adjacent rows</strong> of the grid and swap them.</p>\n\n<p>A grid is said to be <strong>valid</strong> if all the cells above the main diagonal are <strong>zeros</strong>.</p>\n\n<p>Return <em>the minimum number of steps</em> needed to make the grid valid, or <strong>-1</strong> if the grid cannot be valid.</p>\n\n<p>The main diagonal of a grid is the diagonal that starts at cell <code>(1, 1)</code> and ends at cell <code>(n, n)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/28/fw.jpg\" style=\"width: 750px; height: 141px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,0,1],[1,1,0],[1,0,0]]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/16/e2.jpg\" style=\"width: 270px; height: 270px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> All rows are similar, swaps have no effect on the grid.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/16/e3.jpg\" style=\"width: 200px; height: 200px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,0,0],[1,1,0],[1,1,1]]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code> <code>== grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 767912,
                "title": "java-16-lines-bubble-sort-with-line-by-line-explanation-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/62ae8e60-d867-4e7d-8b37-06e5b5a15cc9_1596343724.4730008.png)\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length, res=0;\\n        List<Integer> row = new LinkedList<>();\\n        for (int i=0; i<n; i++){\\n            int trailingZeroCnt=0;\\n            for (int j=n-1; j>-1 && grid[i][j]==0; j--) trailingZeroCnt++;\\n            row.add(trailingZeroCnt);\\n        }\\n        for (int curRowIdx=0, minTrailingZeros=n-1; curRowIdx<n; curRowIdx++, minTrailingZeros--){\\n            int satisfiedRowIdx =curRowIdx;\\n            while (satisfiedRowIdx <n && row.get(satisfiedRowIdx)<minTrailingZeros) satisfiedRowIdx++;\\n            if (satisfiedRowIdx ==n) return -1;\\n            int toRemove = row.remove(satisfiedRowIdx);\\n            row.add(curRowIdx, toRemove);\\n            res+=satisfiedRowIdx -curRowIdx;\\n        }\\n        return res;\\n    }\\n}\\n```\\nHappy Coding!\\n\\nPS: I\\'m glad that someone thinks this solution is from a textbook, but I just wrote this down after solving it in contest :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length, res=0;\\n        List<Integer> row = new LinkedList<>();\\n        for (int i=0; i<n; i++){\\n            int trailingZeroCnt=0;\\n            for (int j=n-1; j>-1 && grid[i][j]==0; j--) trailingZeroCnt++;\\n            row.add(trailingZeroCnt);\\n        }\\n        for (int curRowIdx=0, minTrailingZeros=n-1; curRowIdx<n; curRowIdx++, minTrailingZeros--){\\n            int satisfiedRowIdx =curRowIdx;\\n            while (satisfiedRowIdx <n && row.get(satisfiedRowIdx)<minTrailingZeros) satisfiedRowIdx++;\\n            if (satisfiedRowIdx ==n) return -1;\\n            int toRemove = row.remove(satisfiedRowIdx);\\n            row.add(curRowIdx, toRemove);\\n            res+=satisfiedRowIdx -curRowIdx;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768020,
                "title": "c-easy-solution-greedy-prove-example",
                "content": "Observation:\\nLet\\'s use Example 1 for illustration:\\n[[0,0,1],[1,1,0],[1,0,0]]\\ntailing zero counts are:   [0, 1, 2]  (starting status)\\nThe desired final goal is: [2,1, 0]   (ending status)\\n\\nSo, the problems is converted to find the minimal ajacent swaping from starting status to ending status:\\n\\nComment: If you think this post is helpful, please help upvote.\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        const int n = grid.size();\\n        vector<int> t(n); //t[i]: tailing zero count for i-th row        \\n        for(int i=0;i<n;i++){\\n            int count = 0;\\n            for(int j = n;--j>=0 && !grid[i][j]; )  count++;                \\n            t[i] = count;\\n        }\\n        int ans = 0;        \\n        for(int i=0;i< n;i++){\\n            int k = i;\\n            int req = n-1 - i; // desired tailing zero count\\n            while(k<n && t[k]<req) k++; // greedily find first swaping candidate and log the result into k. Note1\\n            if(k==n) return -1; // k is out of range. Fail in searching\\n\\n            //Core part of the question: moving up k-th row up, moving down [i, k-1\\n            //Part 1: move k-th row up to i-th row\\n            ans += k-i; // accumulate the operation cost of moving k to i\\n            \\n            //Part 2: move the rest involved row downward by offset 1\\n            while(k>i){ // simulate swaping operation of two adjacent rows in range of [i, k-1 ]\\n                t[k] = t[k-1];\\n                k--;\\n            }\\n        }    \\n        \\n        return ans;\\n    }\\n};\\n/*Note 1: why dose greedy approach work? \\nRecall the row scanning is performed one by one from row 0, which ask most tailing 0; \\nSuppose, current row (i-th row) asks for a row with at least 4 zeros, and the neaerst downward row (j-th) has 5 tailing zeros. You can greedily but aslo safely choose it as candidate. any rows after than i-th row will ask for less than 4 tailing rows. So you greedy approach will cause no trouble at all.\\n*/\\n```\\nreference:\\n[1] https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/discuss/767974/C%2B%2B-Solution",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        const int n = grid.size();\\n        vector<int> t(n); //t[i]: tailing zero count for i-th row        \\n        for(int i=0;i<n;i++){\\n            int count = 0;\\n            for(int j = n;--j>=0 && !grid[i][j]; )  count++;                \\n            t[i] = count;\\n        }\\n        int ans = 0;        \\n        for(int i=0;i< n;i++){\\n            int k = i;\\n            int req = n-1 - i; // desired tailing zero count\\n            while(k<n && t[k]<req) k++; // greedily find first swaping candidate and log the result into k. Note1\\n            if(k==n) return -1; // k is out of range. Fail in searching\\n\\n            //Core part of the question: moving up k-th row up, moving down [i, k-1\\n            //Part 1: move k-th row up to i-th row\\n            ans += k-i; // accumulate the operation cost of moving k to i\\n            \\n            //Part 2: move the rest involved row downward by offset 1\\n            while(k>i){ // simulate swaping operation of two adjacent rows in range of [i, k-1 ]\\n                t[k] = t[k-1];\\n                k--;\\n            }\\n        }    \\n        \\n        return ans;\\n    }\\n};\\n/*Note 1: why dose greedy approach work? \\nRecall the row scanning is performed one by one from row 0, which ask most tailing 0; \\nSuppose, current row (i-th row) asks for a row with at least 4 zeros, and the neaerst downward row (j-th) has 5 tailing zeros. You can greedily but aslo safely choose it as candidate. any rows after than i-th row will ask for less than 4 tailing rows. So you greedy approach will cause no trouble at all.\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768010,
                "title": "python-clean-greedy-solution-with-detailed-explanation-o-n-2",
                "content": "**Explaination**\\n\\nFirst we count the number of trailing zeroes in each row and store the numbers in `arr`.\\n\\nFor `grid = [[0,0,1],[1,1,0],[1,0,0]]`, we have `arr = [0,1,2]`.\\n\\nWe are hoping to rearrange `arr` so that `arr[i] >= n - i - 1`. In this case, `arr` will become `[2,1,0]` after rearrangement.\\n\\nWe can use greedy approach to do the rearrangement: \\n1. find the smallest `j` such that `j >= i` and `arr[j] >= n - i - 1`\\n2. do `j - i` swaps to bring `arr[j]` to index `i`\\n\\nThe reason why greedy approach works is that `arr` will be in \"descending\" order after rearragement, so it\\'s fine to push smaller numbers downwards. \\n\\nHere the \"descending\" order is not strict. `arr` is good as long as `arr[i] >= n - i - 1`. For example, `arr = [4,3,4,4]` is valid.\\n\\n<br />\\n\\n**Complexity**\\n\\nTime complexity: `O(N^2)`\\nSpace complexity: `O(N)`\\n\\n<br />\\n\\n**Python**\\n```Python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        def count(arr):\\n            ans = 0\\n            for i in range(n-1, -1, -1):\\n                if arr[i] == 0:\\n                    ans += 1\\n                else:\\n                    break\\n            return ans\\n            \\n        arr = [count(row) for row in grid]\\n        ans = 0\\n        for i in range(n):\\n            target = n - i - 1\\n            if arr[i] >= target:\\n                continue\\n            flag = False\\n            for j in range(i+1, n):\\n                if arr[j] >= target:\\n                    flag = True\\n                    ans += (j - i)\\n                    arr[i+1:j+1] = arr[i:j]\\n                    break\\n            if not flag:\\n                return -1\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        def count(arr):\\n            ans = 0\\n            for i in range(n-1, -1, -1):\\n                if arr[i] == 0:\\n                    ans += 1\\n                else:\\n                    break\\n            return ans\\n            \\n        arr = [count(row) for row in grid]\\n        ans = 0\\n        for i in range(n):\\n            target = n - i - 1\\n            if arr[i] >= target:\\n                continue\\n            flag = False\\n            for j in range(i+1, n):\\n                if arr[j] >= target:\\n                    flag = True\\n                    ans += (j - i)\\n                    arr[i+1:j+1] = arr[i:j]\\n                    break\\n            if not flag:\\n                return -1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769090,
                "title": "java-count-trailing-zeros-greedy-solution-with-visualization",
                "content": "Since we want all zeros above the diagonal lines, We only care about the trailing zeros of each row. So the matrix can be simplified into a 1D array containing the trailing zeros of each row. \\n\\nThen we want to satisfy the trailing zero requirements for each row to make all zeros above diagonal. For example if it was a 4 * 4 Matrix we want \\n```\\ntrailing zeros >= 3 for row 1\\ntrailing zeros >= 2 for row 2\\ntrailing zeros >= 1 for row 3\\nno requirement for row 4\\n```\\n![image](https://assets.leetcode.com/users/images/7244744f-839b-4ae5-8ad3-88490b54a95d_1596378127.094143.png)\\n\\nThe greedy approach is here: For each row from top to bottom we want to go down to subsequent rows to find the closest row that satisfy the requirement for this row and perform the swaps. Notice that since we want minimum number of swaps we don\\'t necessarily want the biggest trailing zero number, since it might be too far away and cost more steps. We simply want the closest one that meet the requirement. \\n\\nHere is an example: \\n![image](https://assets.leetcode.com/users/images/ad36f0ca-0076-4900-a2fb-27ccf584e17e_1596378351.518053.png)\\nWe can see that for the first row we directly use the row with 5 zeros because it was two steps away. For the second row since it is already satisfied, we don\\'t need to pull the row with 4 trailing zeros up. Then the 1D array is not completly sorted in the end but we meet all the requirements. \\n\\nIf at any stage we can\\'t find any more qualifying numbers, then we return -1. \\n\\nHere is my code: \\n```Java\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] conseq0 = new int[n]; // Count trailing zeros for all rows\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int counter = 0;\\n            for (int j = n - 1; j >= 0; --j)\\n            {\\n                if (grid[i][j] != 0)\\n                    break;\\n                counter++;\\n            }\\n            conseq0[i] = counter;\\n        }\\n        int numNeeded = n - 1;\\n        int ans = 0;\\n        while (numNeeded > 0)\\n        {\\n            boolean flag = false;\\n            for (int i = n - numNeeded - 1; i < n; ++i)\\n            {\\n                if (conseq0[i] >= numNeeded)\\n                {\\n                    //Perform the swaps\\n                    int temp = conseq0[i];\\n                    for (int k = i; k > n - numNeeded - 1; --k)\\n                        conseq0[k] = conseq0[k - 1];\\n                    conseq0[n - numNeeded - 1] = temp;\\n                    flag = true;\\n                    //Calculate the number of swaps\\n                    ans += i - (n - numNeeded - 1);\\n                    break;\\n                }\\n            }\\n            if (!flag)\\n                return -1;\\n            numNeeded--;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\ntrailing zeros >= 3 for row 1\\ntrailing zeros >= 2 for row 2\\ntrailing zeros >= 1 for row 3\\nno requirement for row 4\\n```\n```Java\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] conseq0 = new int[n]; // Count trailing zeros for all rows\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int counter = 0;\\n            for (int j = n - 1; j >= 0; --j)\\n            {\\n                if (grid[i][j] != 0)\\n                    break;\\n                counter++;\\n            }\\n            conseq0[i] = counter;\\n        }\\n        int numNeeded = n - 1;\\n        int ans = 0;\\n        while (numNeeded > 0)\\n        {\\n            boolean flag = false;\\n            for (int i = n - numNeeded - 1; i < n; ++i)\\n            {\\n                if (conseq0[i] >= numNeeded)\\n                {\\n                    //Perform the swaps\\n                    int temp = conseq0[i];\\n                    for (int k = i; k > n - numNeeded - 1; --k)\\n                        conseq0[k] = conseq0[k - 1];\\n                    conseq0[n - numNeeded - 1] = temp;\\n                    flag = true;\\n                    //Calculate the number of swaps\\n                    ans += i - (n - numNeeded - 1);\\n                    break;\\n                }\\n            }\\n            if (!flag)\\n                return -1;\\n            numNeeded--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768003,
                "title": "java-bubble-sort",
                "content": "The idea is for each row, we count the number of zeros from the end and try to assign a target row for it. For example, if row 1 has 0 zeros, then it should goes to row n-1. If a row has 1 ending zero, it should goes to row n-2.\\nOnce we found the target indexes, we just need to do a bubble sort to count how many time we want to swap.\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        HashSet<Integer> found = new HashSet();\\n        int steps = 0;\\n        \\n        int[] arr = new int[n];        \\n        for(int i=0; i<n; i++){\\n            int count = 0;\\n            int j = n-1;\\n            while(j>=0 && grid[i][j]==0) {\\n                count++;\\n                j--;\\n            }            \\n            for(int k=n-1; k>=0; k--){\\n                if(count>=k && !found.contains(k)){ //move from row i to row n-1-k\\n                    found.add(k);               \\n                    arr[i] = n-1-k;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(found.size()!=n) return -1;\\n        \\n        return bubblesort(arr);\\n    }\\n    private int bubblesort(int[] arr){\\n        int k=0;\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=0; j<arr.length-i-1; j++){\\n                if(arr[j]>arr[j+1]){\\n                    int tmp = arr[j];\\n                    arr[j] = arr[j+1];\\n                    arr[j+1] = tmp;\\n                    k++;\\n                }\\n            }\\n        }\\n        \\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        HashSet<Integer> found = new HashSet();\\n        int steps = 0;\\n        \\n        int[] arr = new int[n];        \\n        for(int i=0; i<n; i++){\\n            int count = 0;\\n            int j = n-1;\\n            while(j>=0 && grid[i][j]==0) {\\n                count++;\\n                j--;\\n            }            \\n            for(int k=n-1; k>=0; k--){\\n                if(count>=k && !found.contains(k)){ //move from row i to row n-1-k\\n                    found.add(k);               \\n                    arr[i] = n-1-k;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(found.size()!=n) return -1;\\n        \\n        return bubblesort(arr);\\n    }\\n    private int bubblesort(int[] arr){\\n        int k=0;\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=0; j<arr.length-i-1; j++){\\n                if(arr[j]>arr[j+1]){\\n                    int tmp = arr[j];\\n                    arr[j] = arr[j+1];\\n                    arr[j+1] = tmp;\\n                    k++;\\n                }\\n            }\\n        }\\n        \\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769651,
                "title": "c-solution-with-steps-explained-beats-100",
                "content": "**Approach :** **In the grid in 1st row we need n-1 0s at the end, 2nd row n-2 0s, 3rd row n-3 0s and so on.**\\nProblem reduces to finding the zeroes at the end of each row and sorting it in decreasing order by **using operation :- swapping any two adjacent elements**\\nso we first find the number of 0s at the end of each row.\\n1. let\\'s say the grid is ```[[0,0,1],[1,1,0],[1,0,0]]```.\\n2. so the number of zeroes at the end in each row comes out to be ```[0,1,2]``` let\\'s call it array a.\\n3. now first row should have n-1 i.e 2 0s at the end so we have to bring 2 from 3rd position to 1st position in array a.\\n4. this can be done in 2 swaps and the array becomes ```[2,0,1]```. now first index is done since we have got the answer here.\\n5. repeat these steps for all the index and update the swaps count which will be the answer.\\n\\nPls Upvote if you like it.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size(),res=0;\\n        vector<int>a(n);\\n        for(int i=0 ; i<n ; i++)              //finding the zeroes at the end of each row.\\n        {\\n            int j=n-1,cnt=0;\\n            while(j>=0 and grid[i][j]==0) {cnt++;j--;}\\n            a[i]=cnt;\\n        }\\n        for(int i=0 ; i<n ; i++)               //for calculating the swaps count or sorting the array decreasing.\\n        {\\n            if(a[i]<n-1-i)\\n            {\\n                int j=i;\\n                while(j<n and a[j]<n-1-i) j++;\\n                if(j==n) return -1;\\n                while(i<j)\\n                {\\n                    swap(a[j],a[j-1]);\\n                    res++;\\n                    j--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```[[0,0,1],[1,1,0],[1,0,0]]```\n```[0,1,2]```\n```[2,0,1]```\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size(),res=0;\\n        vector<int>a(n);\\n        for(int i=0 ; i<n ; i++)              //finding the zeroes at the end of each row.\\n        {\\n            int j=n-1,cnt=0;\\n            while(j>=0 and grid[i][j]==0) {cnt++;j--;}\\n            a[i]=cnt;\\n        }\\n        for(int i=0 ; i<n ; i++)               //for calculating the swaps count or sorting the array decreasing.\\n        {\\n            if(a[i]<n-1-i)\\n            {\\n                int j=i;\\n                while(j<n and a[j]<n-1-i) j++;\\n                if(j==n) return -1;\\n                while(i<j)\\n                {\\n                    swap(a[j],a[j-1]);\\n                    res++;\\n                    j--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768030,
                "title": "python3-bubble-ish-sort",
                "content": "Algo \\nBasic idea is bubble sort. Here, we transform each row into a number which the location of last index of 1. Then, we use a modified bubble sort algo to compute the `ans`. For each row, we find the first value which can be moved to this position via swaps, and update the `ans`. \\n\\nEdit: added comments to aid understanding. \\n\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        #summarizing row into number \\n        row = [0]*m \\n        for i in range(m):\\n            row[i] = next((j for j in reversed(range(n)) if grid[i][j]), 0)\\n        \\n        ans = 0\\n        #sequentially looking for row to fill in \\n        for k in range(m): \\n            for i, v in enumerate(row): \\n                if v <= k: #enough trailing zeros \\n                    ans += i\\n                    row.pop(i) #value used \\n                    break \\n            else: return -1 #cannot find such row \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        #summarizing row into number \\n        row = [0]*m \\n        for i in range(m):\\n            row[i] = next((j for j in reversed(range(n)) if grid[i][j]), 0)\\n        \\n        ans = 0\\n        #sequentially looking for row to fill in \\n        for k in range(m): \\n            for i, v in enumerate(row): \\n                if v <= k: #enough trailing zeros \\n                    ans += i\\n                    row.pop(i) #value used \\n                    break \\n            else: return -1 #cannot find such row \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 768292,
                "title": "java-solution-with-explanation-for-each-step",
                "content": "The Idea :\\nIf we can swap the rows such that we can get a `Binary Grid`\\n\\n1. For i\\'th row to be fulfilled, there should be a row with (n - i - 1) trailing zeros \\n2. If we can\\'t find a candidate row then we can\\'t get a \\'Binary Grid\\'\\n3. If we found a candidate row, then we need to bubble it to the i\\'th index, since we can ONLY SWAP ADJECENT ROWS, we need |candidateIndex - i| swaps. And need to actually swap the items so that the subsequent steps can operate on the resulted array\\n\\n\\n```\\npublic int minSwaps(int[][] grid) {\\n        int[] numberOfTrailingZerosAtEachRow = new int[grid.length];\\n\\n        // below is to fill up the numberOfTrailingZerosAtEachRow array\\n        for (int i = 0; i < grid.length; ++i) {\\n            for (int j = grid.length - 1; j >= 0; --j) {\\n                if (grid[i][j] == 0) {\\n                    numberOfTrailingZerosAtEachRow[i]++;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        int n = numberOfTrailingZerosAtEachRow.length;\\n        int count = 0;\\n\\n        // we need to change the numberOfTrailingZerosAtEachRow such that\\n        // each index `i` has at least (n - i - 1) trailing zeros\\n\\n        // iterate through the numberOfTrailingZerosAtEachRow\\n        for (int i = 0; i < n; ++i) {\\n            // the candidate row should have at least `requiredZerosAtThisIndex` trailing zeros\\n            int requiredZerosAtThisIndex = n - i - 1;\\n            \\n            //  let\\'s find a candidate row to be the i\\'th row, no need to start from beginning, we should have fixed each previous rows, so no need to consider prevous ones \\n            for (int j = i; j < n; ++j) {\\n                // this is the condition to be a candidate for i\\'th row\\n                if (numberOfTrailingZerosAtEachRow[j] >= requiredZerosAtThisIndex) {\\n                    // since we found the candidate row, bubble-up the candidate row to the i\\'th position\\n                    for (int k = j; k > i; --k) {\\n                        int temp = numberOfTrailingZerosAtEachRow[k];\\n                        numberOfTrailingZerosAtEachRow[k] = numberOfTrailingZerosAtEachRow[k - 1];\\n                        numberOfTrailingZerosAtEachRow[k - 1] = temp;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// let\\'s count how many steps it took to bubble up, ultimately this is the answer we want right !!!\\n                        count++;\\n                    }\\n                    \\n                    // we filled the i\\'th position, let\\'s continue with the next position\\n                    break;\\n                }\\n                \\n                // if this is true, okay we have reached the end of the array, and we didn\\'t find a candidate for the i\\'th row\\n                if (j == n - 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n\\n        // return the swap count\\n        return count;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "The Idea :\\nIf we can swap the rows such that we can get a `Binary Grid`\\n\\n1. For i\\'th row to be fulfilled, there should be a row with (n - i - 1) trailing zeros \\n2. If we can\\'t find a candidate row then we can\\'t get a \\'Binary Grid\\'\\n3. If we found a candidate row, then we need to bubble it to the i\\'th index, since we can ONLY SWAP ADJECENT ROWS, we need |candidateIndex - i| swaps. And need to actually swap the items so that the subsequent steps can operate on the resulted array\\n\\n\\n```\\npublic int minSwaps(int[][] grid) {\\n        int[] numberOfTrailingZerosAtEachRow = new int[grid.length];\\n\\n        // below is to fill up the numberOfTrailingZerosAtEachRow array\\n        for (int i = 0; i < grid.length; ++i) {\\n            for (int j = grid.length - 1; j >= 0; --j) {\\n                if (grid[i][j] == 0) {\\n                    numberOfTrailingZerosAtEachRow[i]++;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        int n = numberOfTrailingZerosAtEachRow.length;\\n        int count = 0;\\n\\n        // we need to change the numberOfTrailingZerosAtEachRow such that\\n        // each index `i` has at least (n - i - 1) trailing zeros\\n\\n        // iterate through the numberOfTrailingZerosAtEachRow\\n        for (int i = 0; i < n; ++i) {\\n            // the candidate row should have at least `requiredZerosAtThisIndex` trailing zeros\\n            int requiredZerosAtThisIndex = n - i - 1;\\n            \\n            //  let\\'s find a candidate row to be the i\\'th row, no need to start from beginning, we should have fixed each previous rows, so no need to consider prevous ones \\n            for (int j = i; j < n; ++j) {\\n                // this is the condition to be a candidate for i\\'th row\\n                if (numberOfTrailingZerosAtEachRow[j] >= requiredZerosAtThisIndex) {\\n                    // since we found the candidate row, bubble-up the candidate row to the i\\'th position\\n                    for (int k = j; k > i; --k) {\\n                        int temp = numberOfTrailingZerosAtEachRow[k];\\n                        numberOfTrailingZerosAtEachRow[k] = numberOfTrailingZerosAtEachRow[k - 1];\\n                        numberOfTrailingZerosAtEachRow[k - 1] = temp;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// let\\'s count how many steps it took to bubble up, ultimately this is the answer we want right !!!\\n                        count++;\\n                    }\\n                    \\n                    // we filled the i\\'th position, let\\'s continue with the next position\\n                    break;\\n                }\\n                \\n                // if this is true, okay we have reached the end of the array, and we didn\\'t find a candidate for the i\\'th row\\n                if (j == n - 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n\\n        // return the swap count\\n        return count;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1724605,
                "title": "only-7-steps-c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid){\\n        int n = grid.size();\\n        int ans = 0;\\n        vector<int> t; // vector to keep track of trailing zeroes\\n        \\n        //Step 1 : Find all trailing zeroes\\n        for(int i=0;i<n;i++){\\n            int zero = 0;\\n            for(int j=n-1;j>=0;j--){\\n                if(grid[i][j]) break;\\n                zero++;\\n            }\\n            t.push_back(zero);\\n        }\\n        \\n        //Step 2 : Apply greedy method and solve problem row by row\\n        for(int i=0;i<n;i++){\\n            \\n            int curr = i;\\n            int req = n - 1 - i; // how many zeroes we want at this particular row \\n            \\n            // Step 4 : find nearest row which fullfill our zeroes requirement\\n            while(curr < n and t[curr] < req) curr++;\\n            \\n            // Step 5 : If we are not able to find any such rows --> return -1\\n            if(curr == n) return -1;\\n            \\n            // Step 6 : If we able to find such row then add cost to swap it\\n            ans += curr - i;\\n            \\n            // Step 7 : move all such rows 1 step ahead which are in b/w the source row and dest row\\n            while(curr > 0){\\n                t[curr] = t[curr - 1];\\n                curr--;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid){\\n        int n = grid.size();\\n        int ans = 0;\\n        vector<int> t; // vector to keep track of trailing zeroes\\n        \\n        //Step 1 : Find all trailing zeroes\\n        for(int i=0;i<n;i++){\\n            int zero = 0;\\n            for(int j=n-1;j>=0;j--){\\n                if(grid[i][j]) break;\\n                zero++;\\n            }\\n            t.push_back(zero);\\n        }\\n        \\n        //Step 2 : Apply greedy method and solve problem row by row\\n        for(int i=0;i<n;i++){\\n            \\n            int curr = i;\\n            int req = n - 1 - i; // how many zeroes we want at this particular row \\n            \\n            // Step 4 : find nearest row which fullfill our zeroes requirement\\n            while(curr < n and t[curr] < req) curr++;\\n            \\n            // Step 5 : If we are not able to find any such rows --> return -1\\n            if(curr == n) return -1;\\n            \\n            // Step 6 : If we able to find such row then add cost to swap it\\n            ans += curr - i;\\n            \\n            // Step 7 : move all such rows 1 step ahead which are in b/w the source row and dest row\\n            while(curr > 0){\\n                t[curr] = t[curr - 1];\\n                curr--;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398625,
                "title": "detailed-explanation-c-greedy-bubble",
                "content": "**Intution :**\\n\\n* This problem seem to be really difficult at first sight. But believe me, it is not that Hard once you start observing patterns in it. \\n\\n* Pattern that we need is : for lets say n = 6\\n\\t\\n\\ti=0  : #  0  0  0  0  0\\n\\ti=1  : #  #  0  0  0  0\\n\\ti=2  : #  #  #  0  0  0     \\n\\ti=3  : #  #  #  #  0  0         \\n\\ti=4  : #  #  #  #  #  0\\n \\ti=5  : #  #  #  #  #  #\\n\\t\\n\\t-> Here, for every i, there should be atleast (n-1-i) number of trailing zeros.\\n\\t-> If it is less then, we need to do swaps\\n\\n* Lets try to first find some important patterns : \\n\\t\\n\\t[0,0,1]  : 0 trailing zero < 2  (do swapping)                     [1,0,0] : 2 trailing zero\\n\\t[1,1,0]  : 1 trailing zero  >= 1               after all swaps -> [1,1,0] : 1 trailing zero \\n\\t[1,0,0]  : 2 trailing zero  >= 2                                  [0,0,1] : 0 trailing zero\\n\\t\\n\\t-> Now we can observe here that first row should have at least (n-1) trailing zeros before rightmost 1.\\n\\t-> Also, for ith row, number of trailing zeros should be always greater than [(n-1)-i]\\n\\t-> If there are less number of trailing zeros, then we need to do adjacent swaps from row i till the closest row j(>i) \\n\\t\\t-> such that numbers of trailing zeros is >= (n-1-i)\\n\\t-> Continue this process untill we get no. of trailing zeros >= (n-1-i) for all {i = 0 .... n-1}\\n\\t\\t\\n* If you got this pattern and observation, rest of the problem becomes a calkwalk.\\n* Now, that you have observerd the pattern and the approach lets do a dry run : \\n\\n\\t\\t[0,0,1]\\n\\t\\t[1,1,0]  => array of number of trailing zeros = [0,1,2]\\n\\t\\t[1,0,0]\\n\\t\\t\\n\\t\\t1. for i=0 , trailing zeros = 0 < (n-1-i) = (3-1-0) = 2 \\n\\t\\t\\t-> need to do adjacent swaps with the next closest j such that no. of trailing zeros >= 2\\n\\t\\t\\t-> j = 2 , swaps : [0,2,1] -> [2,0,1] \\n\\t\\t\\t-> final array = [2,0,1], swaps = 2\\n\\t\\t\\n\\t\\t2. for i=1, trailing zeros = 0 < (n-1-i) = (3-1-1) = 1\\n\\t\\t\\t-> need to do adjacent swaps with the next closest j such that no. of trailing zeros >= 1\\n\\t\\t\\t-> j = 2 , swaps : [0,1] -> [1,0] \\n\\t\\t\\t-> final array = [2,0,1], swaps = 1, totalSwaps = 2+1 = 3\\n\\t\\t\\t\\n\\t\\t3. for i=2, trailing zeros = 0 == (n-1-i) = (3-1-2) = 0\\n\\t\\t\\t-> since it is already in correct position, no need to do swaps\\n\\t\\t\\t-> final array = [2,0,1], swaps = 0, totalSwaps = 3+0 = 3\\n\\n# Code : \\n\\n```\\n int minSwaps(vector<vector<int>>& grid) {\\n        \\n\\tint n = grid.size();\\n\\tvector<int> trailingZeros(n, -1);\\n\\tfor(int i=0; i<n; i++)\\n\\t{\\n\\t\\tint j = n-1;\\n\\t\\tint zeros = 0;\\n\\t\\twhile(j >= 0 && grid[i][j] == 0)\\n\\t\\t{\\n\\t\\t\\tj--;\\n\\t\\t\\tzeros++;\\n\\t\\t}\\n\\t\\ttrailingZeros[i] = zeros;\\n\\t}\\n\\n\\t// for(auto& i : trailingZeros) cout << i << \" \";\\n\\tint swaps = 0;\\n\\n\\tfor(int i=0; i<n; i++)\\n\\t{\\n\\t\\tif(trailingZeros[i] < n-1-i) \\n\\t\\t{\\n\\t\\t\\tint j = i+1;\\n\\t\\t\\twhile(j<n && trailingZeros[j] < n-1-i) j++;\\n\\t\\t\\tif(j == n) return -1;\\n\\n\\t\\t\\twhile(j > i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswap(trailingZeros[j], trailingZeros[j-1]);\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t\\tswaps++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn swaps;\\n}\\n```\\n\\n**Time : O(N^N) in worst case**\\n**Space : O(N)**\\n\\n***Hope you understood the explanation. In case of any query feel free to ask.\\nAlso do upvote !!\\n***",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\n int minSwaps(vector<vector<int>>& grid) {\\n        \\n\\tint n = grid.size();\\n\\tvector<int> trailingZeros(n, -1);\\n\\tfor(int i=0; i<n; i++)\\n\\t{\\n\\t\\tint j = n-1;\\n\\t\\tint zeros = 0;\\n\\t\\twhile(j >= 0 && grid[i][j] == 0)\\n\\t\\t{\\n\\t\\t\\tj--;\\n\\t\\t\\tzeros++;\\n\\t\\t}\\n\\t\\ttrailingZeros[i] = zeros;\\n\\t}\\n\\n\\t// for(auto& i : trailingZeros) cout << i << \" \";\\n\\tint swaps = 0;\\n\\n\\tfor(int i=0; i<n; i++)\\n\\t{\\n\\t\\tif(trailingZeros[i] < n-1-i) \\n\\t\\t{\\n\\t\\t\\tint j = i+1;\\n\\t\\t\\twhile(j<n && trailingZeros[j] < n-1-i) j++;\\n\\t\\t\\tif(j == n) return -1;\\n\\n\\t\\t\\twhile(j > i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswap(trailingZeros[j], trailingZeros[j-1]);\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t\\tswaps++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn swaps;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 767919,
                "title": "python-reduction-to-1d-case-commented-code",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        def mv(x): #find the index of largest 1 entry in each row\\n            if sum(x):\\n                return max((i for i in range(len(x)) if x[i]==1))\\n            return 0\\n        line = [mv(e) for e in grid] #reduced to 1D array\\n            \\n        #return -1 if infeasible\\n        for i, e in enumerate(sorted(line)):\\n            if i < e:\\n                return -1\\n\\n        #at this point we know it\\'s feasible\\n        ret = 0\\n        i = 0\\n        while i < len(line):\\n            if line[i] > i: #this means the entry at i-th position is violating\\n                #now find the minimum possible value of j which would satisfy line[j] <= i\\n                #we can now swap this until the reach position i\\n                j = i+1\\n                while line[j] > i: \\n                    j += 1\\n                ret += j-i #the number of swaps needed, minimal at this step\\n                line[i:j+1] = [line[j]] + line[i:j] #rearrange the array based on swap order\\n            i += 1    \\n        return ret #ret equals to minimum number of swaps\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        def mv(x): #find the index of largest 1 entry in each row\\n            if sum(x):\\n                return max((i for i in range(len(x)) if x[i]==1))\\n            return 0\\n        line = [mv(e) for e in grid] #reduced to 1D array\\n            \\n        #return -1 if infeasible\\n        for i, e in enumerate(sorted(line)):\\n            if i < e:\\n                return -1\\n\\n        #at this point we know it\\'s feasible\\n        ret = 0\\n        i = 0\\n        while i < len(line):\\n            if line[i] > i: #this means the entry at i-th position is violating\\n                #now find the minimum possible value of j which would satisfy line[j] <= i\\n                #we can now swap this until the reach position i\\n                j = i+1\\n                while line[j] > i: \\n                    j += 1\\n                ret += j-i #the number of swaps needed, minimal at this step\\n                line[i:j+1] = [line[j]] + line[i:j] #rearrange the array based on swap order\\n            i += 1    \\n        return ret #ret equals to minimum number of swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768012,
                "title": "clean-python-3-straightforward",
                "content": "Just a straightforward approach with reversed way.\\nTime: `O(N^2)`\\nSpace: `O(N^2)` for input `grid`\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n, step = len(grid), 0\\n        grid = list(reversed(grid))\\n        for target in reversed(range(1, n)):\\n            r = target\\n            while r >= 0:\\n                row = grid[r]\\n                if sum(row[-target:]) == 0: break\\n                r -= 1\\n            else:\\n                return -1\\n            while r != target:\\n                grid[r], grid[r+1] = grid[r+1], grid[r]\\n                step += 1\\n                r += 1\\n        return step\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n, step = len(grid), 0\\n        grid = list(reversed(grid))\\n        for target in reversed(range(1, n)):\\n            r = target\\n            while r >= 0:\\n                row = grid[r]\\n                if sum(row[-target:]) == 0: break\\n                r -= 1\\n            else:\\n                return -1\\n            while r != target:\\n                grid[r], grid[r+1] = grid[r+1], grid[r]\\n                step += 1\\n                r += 1\\n        return step\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769759,
                "title": "python-clean-solution-with-video-explanation",
                "content": "Video with clear visualization and explanation:\\nhttps://youtu.be/88Tg3mWXvVM\\n\\nThis question is pretty tough for me. Tried my best to explain it as clear as possible.\\n\\nIntuition: Greedy Algorithm\\n\\nCode:\\nInspired by: https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/discuss/768010/Python-Clean-greedy-solution-with-detailed-explanation-O(N2)\\n\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n\\n        def countZeros(arr):\\n            n_zero = 0\\n            for i in range(n-1, -1, -1):\\n                if arr[i] == 0:\\n                    n_zero += 1\\n                else:\\n                    break\\n            return n_zero\\n\\n        zeros = [countZeros(row) for row in grid]\\n        res = 0\\n        \\n        for i in range(n):\\n            target = n - i - 1\\n            if zeros[i] >= target: continue\\n            possible = False\\n            for j in range(i+1, n):\\n                if zeros[j] >= target:\\n                    possible = True\\n                    res += (j - i)\\n                    zeros[i+1:j+1] = zeros[i:j]\\n                    break\\n            if not possible: return -1\\n\\n        return res\\n```\\n\\n\\nFeel free to subscribe to my channel. More LeetCoding videos coming up!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n\\n        def countZeros(arr):\\n            n_zero = 0\\n            for i in range(n-1, -1, -1):\\n                if arr[i] == 0:\\n                    n_zero += 1\\n                else:\\n                    break\\n            return n_zero\\n\\n        zeros = [countZeros(row) for row in grid]\\n        res = 0\\n        \\n        for i in range(n):\\n            target = n - i - 1\\n            if zeros[i] >= target: continue\\n            possible = False\\n            for j in range(i+1, n):\\n                if zeros[j] >= target:\\n                    possible = True\\n                    res += (j - i)\\n                    zeros[i+1:j+1] = zeros[i:j]\\n                    break\\n            if not possible: return -1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769131,
                "title": "c-simple-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), swaps = 0, k;\\n        bool swaps_performed = false;\\n        vector<int> rightmost(n);\\n        for (int i=0; i<n; ++i) {\\n            for (int j=0; j<n; ++j)\\n                if (grid[i][j] == 1)\\n                    rightmost[i] = j;\\n        }\\n        for (int i=0; i<n; ++i) {\\n            k = i + 1;\\n            while (rightmost[i] > i) {\\n                if (k >= n)\\n                    return -1;\\n                swap(rightmost[i], rightmost[k++]);\\n                ++swaps;\\n            }\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), swaps = 0, k;\\n        bool swaps_performed = false;\\n        vector<int> rightmost(n);\\n        for (int i=0; i<n; ++i) {\\n            for (int j=0; j<n; ++j)\\n                if (grid[i][j] == 1)\\n                    rightmost[i] = j;\\n        }\\n        for (int i=0; i<n; ++i) {\\n            k = i + 1;\\n            while (rightmost[i] > i) {\\n                if (k >= n)\\n                    return -1;\\n                swap(rightmost[i], rightmost[k++]);\\n                ++swaps;\\n            }\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767974,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int>t;\\n        for(int i=0;i<grid.size();i++){\\n            int count = 0;\\n            for(int j = grid[i].size()-1;j>=0;j--){\\n                if(grid[i][j] == 0) count++;\\n                else break;\\n            }\\n            t.push_back(count);\\n        }\\n        int ans = 0;\\n        \\n        for(int i=0;i<t.size();i++){\\n            int k = i;\\n            int req = grid.size()-i-1;\\n            while(k<grid.size() && t[k]<req){\\n                k++;\\n            }\\n            if(k==grid.size()) return -1;\\n            ans = ans + k-i;\\n            \\n            while(k>i){\\n                t[k] = t[k-1];\\n                k--;\\n            }\\n        }    \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int>t;\\n        for(int i=0;i<grid.size();i++){\\n            int count = 0;\\n            for(int j = grid[i].size()-1;j>=0;j--){\\n                if(grid[i][j] == 0) count++;\\n                else break;\\n            }\\n            t.push_back(count);\\n        }\\n        int ans = 0;\\n        \\n        for(int i=0;i<t.size();i++){\\n            int k = i;\\n            int req = grid.size()-i-1;\\n            while(k<grid.size() && t[k]<req){\\n                k++;\\n            }\\n            if(k==grid.size()) return -1;\\n            ans = ans + k-i;\\n            \\n            while(k>i){\\n                t[k] = t[k-1];\\n                k--;\\n            }\\n        }    \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1040130,
                "title": "java-1ms-100-fast-solution-with-explanation",
                "content": "Explanation: \\n   nothing implementation in this question just convert your thought into simple code.\\nSTEPS:\\n   1. convert 2d grid into 1-d array of size n\\n   2. sort 1-d array into reverse order such that only adjacents data swaps are allowed.\\n   3. swaps should be minimum\\n   4. to minimize the swaps solve greedily\\n\\nJAVA CODE IS:\\n\\n```\\nclass Solution {\\n    int find(int arr[],int low,int high,int val){\\n        for(int i=low;i<=high;i++){\\n            if(arr[i]>=val)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    public int minSwaps(int[][] grid) {\\n     int n=grid.length;\\n     int arr[]=new int[n];\\n        int i=0;\\n        for(int g[] : grid){\\n            int count=0,j=n-1;\\n            while(j>=0 && g[j--]==0)\\n                count++;\\n            arr[i++]=count;\\n        }\\n        int  swaps=0;\\n        for(i=0;i<n;i++){\\n            int index=find(arr,i,n-1,n-i-1);\\n            if(index==-1)\\n                return -1;\\n            swaps+=(index-i);\\n            //swap the data\\n            for(int j=index;j>i;j--){\\n                int temp=arr[j];\\n                arr[j]=arr[j-1];\\n                arr[j-1]=temp;\\n            }\\n        }\\n        return swaps;\\n    }\\n}\\n```\\nTime : O(n^2)+2*O(n^2)=O(n^2)\\nSpace : O(n).\\n**PLEASE,UPVOTE IF THIS IS REALLY HELPFUL FOR YOU**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int find(int arr[],int low,int high,int val){\\n        for(int i=low;i<=high;i++){\\n            if(arr[i]>=val)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    public int minSwaps(int[][] grid) {\\n     int n=grid.length;\\n     int arr[]=new int[n];\\n        int i=0;\\n        for(int g[] : grid){\\n            int count=0,j=n-1;\\n            while(j>=0 && g[j--]==0)\\n                count++;\\n            arr[i++]=count;\\n        }\\n        int  swaps=0;\\n        for(i=0;i<n;i++){\\n            int index=find(arr,i,n-1,n-i-1);\\n            if(index==-1)\\n                return -1;\\n            swaps+=(index-i);\\n            //swap the data\\n            for(int j=index;j>i;j--){\\n                int temp=arr[j];\\n                arr[j]=arr[j-1];\\n                arr[j-1]=temp;\\n            }\\n        }\\n        return swaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789981,
                "title": "simplest-c-with-explanation-100-fast-minimum-swaps-to-arrange-a-binary-grid",
                "content": "The basic funda is, boil down your grid to a one dimensional array.\\nAnd then find the min swaps to make it ordered.\\n\\nWhat is the order here?\\nIts kind of a sorting but not comparing the numbers inside the array, but the number and the array index.\\n\\nWhy this greedy works? (Leave this if you don\\'t want to think much)\\n1. Cause for a certain index(i) if you have found the nearest matching value down in a later index(j), no matter what, you have to perform j-i swaps to make the array ordered.\\n2. When you bring a value in an array up, all the middle values goes down also, improving the condition index<= (value in that index). So this is also an optimal approach.\\n\\nGive a cheer up if you ike this :)\\n\"\"\"\\n\\n\\t\\tpublic int MinSwaps(int[][] grid)\\n        {\\n            if (grid.Length <= 1) return 0;\\n            int n = grid.GetLength(0);\\n        \\n            //Creating an array repeseneting the total number of zeroes(right to left) for each row\\n            int[] ranks = new int[n];\\n            for (int i = 0; i < n; i++)\\n            {\\n                int j = n-1;\\n                while(j>=0 && grid[i][j]!=1) j--;\\n                ranks[i]=j;\\n            }\\n                        \\n            int ans=0,temp;\\n            for(int i=0; i<n; i++)\\n            {\\n\\t\\t\\t\\t//if the value is not suitable for the index go down and and find one\\n                if(ranks[i] >i)\\n                {\\n                    int j=i;\\n                    while(j<n && ranks[j]>i) j++;\\n                    \\n                    //return if a matching value is not there\\n                    if(j>=n) return -1;\\n                    \\n\\t\\t\\t\\t\\t//swap if a valid match is found\\n                    while(j!=i)\\n                    {\\n                        temp= ranks[j];\\n                        ranks[j] = ranks[j-1];\\n                        ranks[j-1]=temp;\\n                        j--;\\n                        ans++;\\n                    }\\n                }\\n            }\\n        return ans;\\n        }\\n\"\"\"",
                "solutionTags": [],
                "code": "The basic funda is, boil down your grid to a one dimensional array.\\nAnd then find the min swaps to make it ordered.\\n\\nWhat is the order here?\\nIts kind of a sorting but not comparing the numbers inside the array, but the number and the array index.\\n\\nWhy this greedy works? (Leave this if you don\\'t want to think much)\\n1. Cause for a certain index(i) if you have found the nearest matching value down in a later index(j), no matter what, you have to perform j-i swaps to make the array ordered.\\n2. When you bring a value in an array up, all the middle values goes down also, improving the condition index<= (value in that index). So this is also an optimal approach.\\n\\nGive a cheer up if you ike this :)\\n\"\"\"\\n\\n\\t\\tpublic int MinSwaps(int[][] grid)\\n        {\\n            if (grid.Length <= 1) return 0;\\n            int n = grid.GetLength(0);\\n        \\n            //Creating an array repeseneting the total number of zeroes(right to left) for each row\\n            int[] ranks = new int[n];\\n            for (int i = 0; i < n; i++)\\n            {\\n                int j = n-1;\\n                while(j>=0 && grid[i][j]!=1) j--;\\n                ranks[i]=j;\\n            }\\n                        \\n            int ans=0,temp;\\n            for(int i=0; i<n; i++)\\n            {\\n\\t\\t\\t\\t//if the value is not suitable for the index go down and and find one\\n                if(ranks[i] >i)\\n                {\\n                    int j=i;\\n                    while(j<n && ranks[j]>i) j++;\\n                    \\n                    //return if a matching value is not there\\n                    if(j>=n) return -1;\\n                    \\n\\t\\t\\t\\t\\t//swap if a valid match is found\\n                    while(j!=i)\\n                    {\\n                        temp= ranks[j];\\n                        ranks[j] = ranks[j-1];\\n                        ranks[j-1]=temp;\\n                        j--;\\n                        ans++;\\n                    }\\n                }\\n            }\\n        return ans;\\n        }\\n\"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 777254,
                "title": "java-100-faster-using-bubble-sort-with-code-comments",
                "content": "Reference : https://www.youtube.com/watch?v=OLA5Qwt4NKw\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        \\n        // first count the trailing zeroes in each row in grid\\n        int n = grid.length;\\n        \\n        int trailingZeroes [] = new int [n];\\n        for(int i = 0 ; i < grid.length; i++)\\n        {\\n            int count = 0;\\n            int j = n-1;\\n            while(j >= 0 && grid[i][j] == 0)\\n            {\\n                count += 1;\\n                j--;\\n            }\\n            // The row i has count trailing zeroes\\n            trailingZeroes[i] = count;\\n        }\\n        \\n        int minSwaps = 0;\\n        // Do a bubble sort \\n        for(int i = 0 ; i < trailingZeroes.length; i++ )\\n        {\\n            // No of trailing zeroes required for this row\\n            int target = n-i-1;\\n            \\n            int k = i;\\n            \\n            // Find the row index which has the target number of trailing zeroes to swap with i\\n            while(k < n && trailingZeroes[k] < target)\\n            {\\n\\n                k += 1;\\n            }\\n            \\n            // if k has reached end return -1\\n            if(k == n) return -1;\\n            \\n            // Increment count by number of swaps (from k to i)\\n            minSwaps += k-i;\\n            \\n            // bubble from k to i since we can only swap adjacent pairs\\n            while(k > i)\\n            {\\n                int temp = trailingZeroes[k];\\n                trailingZeroes[k] = trailingZeroes[k-1];\\n                trailingZeroes[k-1] = temp;\\n                k--;\\n            }\\n            \\n            \\n        }\\n        \\n        return minSwaps;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        \\n        // first count the trailing zeroes in each row in grid\\n        int n = grid.length;\\n        \\n        int trailingZeroes [] = new int [n];\\n        for(int i = 0 ; i < grid.length; i++)\\n        {\\n            int count = 0;\\n            int j = n-1;\\n            while(j >= 0 && grid[i][j] == 0)\\n            {\\n                count += 1;\\n                j--;\\n            }\\n            // The row i has count trailing zeroes\\n            trailingZeroes[i] = count;\\n        }\\n        \\n        int minSwaps = 0;\\n        // Do a bubble sort \\n        for(int i = 0 ; i < trailingZeroes.length; i++ )\\n        {\\n            // No of trailing zeroes required for this row\\n            int target = n-i-1;\\n            \\n            int k = i;\\n            \\n            // Find the row index which has the target number of trailing zeroes to swap with i\\n            while(k < n && trailingZeroes[k] < target)\\n            {\\n\\n                k += 1;\\n            }\\n            \\n            // if k has reached end return -1\\n            if(k == n) return -1;\\n            \\n            // Increment count by number of swaps (from k to i)\\n            minSwaps += k-i;\\n            \\n            // bubble from k to i since we can only swap adjacent pairs\\n            while(k > i)\\n            {\\n                int temp = trailingZeroes[k];\\n                trailingZeroes[k] = trailingZeroes[k-1];\\n                trailingZeroes[k-1] = temp;\\n                k--;\\n            }\\n            \\n            \\n        }\\n        \\n        return minSwaps;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775169,
                "title": "javascript-clean-intuitive-solution",
                "content": "```javascript\\nvar minSwaps = function(grid) {\\n    const arr = [];\\n    let count = 0;\\n    \\n    for(let row of grid) {\\n        arr.push(row.lastIndexOf(1));\\n    }\\n    \\n    function swap(i, j) {\\n        [arr[i], arr[j]] = [arr[j], arr[i]];\\n        count++;\\n    }\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        // if num <= i pass b/c it\\'s its correct spot\\n        if(arr[i] <= i) continue;\\n        let j = i;\\n        \\n        // scan forward looking for a num <= i\\n        while(arr[j] > i) {\\n            j++;\\n            if(j >= arr.length) return -1;\\n        }\\n        \\n        // swap as you move back to the right spot\\n        for(let k = j; k > i; k--) {\\n            swap(k, k-1);\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar minSwaps = function(grid) {\\n    const arr = [];\\n    let count = 0;\\n    \\n    for(let row of grid) {\\n        arr.push(row.lastIndexOf(1));\\n    }\\n    \\n    function swap(i, j) {\\n        [arr[i], arr[j]] = [arr[j], arr[i]];\\n        count++;\\n    }\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        // if num <= i pass b/c it\\'s its correct spot\\n        if(arr[i] <= i) continue;\\n        let j = i;\\n        \\n        // scan forward looking for a num <= i\\n        while(arr[j] > i) {\\n            j++;\\n            if(j >= arr.length) return -1;\\n        }\\n        \\n        // swap as you move back to the right spot\\n        for(let k = j; k > i; k--) {\\n            swap(k, k-1);\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774139,
                "title": "python-bubble-sort-approach-easy-to-read-beats-100-both-space-time",
                "content": "Bubble sort approach inspired by @FunBam\\nhttps://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/discuss/767912/Java-16-lines-bubble-sort-with-line-by-line-explanation-easy-to-understand\\n\\n```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        def count_trailing_zero(arr):\\n            idx = len(arr) - 1\\n            while idx >= 0 and arr[idx] == 0:\\n                idx -= 1\\n            return len(arr) - 1 - idx\\n\\n        ranks = [count_trailing_zero(grid[i]) for i in range(len(grid))]\\n        swaps = 0\\n\\t\\t\\n\\t\\t# bubble sort\\n        for i in range(len(ranks)):\\n            j = i\\n            while j < len(ranks) and ranks[j] < len(ranks) - 1 - i:\\n                j += 1\\n\\n\\t\\t\\t# grid is invalid because appropriate row replacement not found\\n            if j == len(ranks):\\n                return -1\\n\\n            tmp = ranks.pop(j)\\n            ranks.insert(i, tmp)\\n            swaps += j - i\\n\\n        return swaps\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        def count_trailing_zero(arr):\\n            idx = len(arr) - 1\\n            while idx >= 0 and arr[idx] == 0:\\n                idx -= 1\\n            return len(arr) - 1 - idx\\n\\n        ranks = [count_trailing_zero(grid[i]) for i in range(len(grid))]\\n        swaps = 0\\n\\t\\t\\n\\t\\t# bubble sort\\n        for i in range(len(ranks)):\\n            j = i\\n            while j < len(ranks) and ranks[j] < len(ranks) - 1 - i:\\n                j += 1\\n\\n\\t\\t\\t# grid is invalid because appropriate row replacement not found\\n            if j == len(ranks):\\n                return -1\\n\\n            tmp = ranks.pop(j)\\n            ranks.insert(i, tmp)\\n            swaps += j - i\\n\\n        return swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 771923,
                "title": "java-easy-solution-3ms-faster-than-100-00",
                "content": "**Runtime: 3 ms, faster than 100.00%, Memory Usage: 41.7 MB, less than 100.00% of Java online submissions**\\n\\n```\\n// O(N^2)time\\n// O(N)space\\npublic int minSwaps(int[][] grid) {\\n    //use linkedlist to save the continuous zero count from right to left\\n    LinkedList<Integer> list = new LinkedList<>();\\n    int r = grid.length, c = grid[0].length;\\n    for (int i = 0; i < r; i++) {\\n        int count = 0;\\n        for (int j = c - 1; j >= 0; j--) {\\n            if (grid[i][j] != 0) break;\\n            count++;\\n        }\\n        list.add(count);\\n    }\\n    int res = 0;\\n    for (int i = 0; i < r; i++) {\\n        int t = -1;\\n        //find the first zero count which is >= (r - 1 - i)\\n        //the index is the step\\n        for (int j = 0; j < list.size(); j++) {\\n            if (list.get(j) >= (r - 1 - i)) {\\n                t = list.remove(j);\\n                res += j;\\n                break;\\n            }\\n        }\\n        if (t == -1) return -1;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n// O(N^2)time\\n// O(N)space\\npublic int minSwaps(int[][] grid) {\\n    //use linkedlist to save the continuous zero count from right to left\\n    LinkedList<Integer> list = new LinkedList<>();\\n    int r = grid.length, c = grid[0].length;\\n    for (int i = 0; i < r; i++) {\\n        int count = 0;\\n        for (int j = c - 1; j >= 0; j--) {\\n            if (grid[i][j] != 0) break;\\n            count++;\\n        }\\n        list.add(count);\\n    }\\n    int res = 0;\\n    for (int i = 0; i < r; i++) {\\n        int t = -1;\\n        //find the first zero count which is >= (r - 1 - i)\\n        //the index is the step\\n        for (int j = 0; j < list.size(); j++) {\\n            if (list.get(j) >= (r - 1 - i)) {\\n                t = list.remove(j);\\n                res += j;\\n                break;\\n            }\\n        }\\n        if (t == -1) return -1;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 770135,
                "title": "java-bubble-sort-solution-with-explanation-beats-100",
                "content": "**Intuition:**\\n1. The questions itself suggests us that this is a variation of bubble sort. In bubble sort we swap the current number with its adjacent number and bubble it up(swap) if its greater than the next element(ascending order sort). \\n1. Using that concept, we can formulate our solution in such a way that we can bubble up the row containing the required number of zeroes to top. \\n\\n**Approach**\\n1. In every row, count the number of zeroes in the suffix. \\n  Eg: \\n        ```[1,1,0,0]: contains 2```\\n        ```[1.0.0.0]: contains 3```  \\n1. Once we have a list of the above values, each value representing number of zeroes from the end in each row we can use the bubble sort kind of logic to bubble up the required row to the top. \\n1. A small tricky thing to consider here. To maintain minimum number of swaps, we need to only bubble up the row containing required number of zeroes. For example for the below array: The numZeroes list looks like [0, 3, 4,5,5]. For row number 0, we need 4 zeroes, So we just need to swap 4 to top. No need to swap 5. That will increase number of swaps more than required. \\n  ```\\n    [[0,0,0,0,1]\\n\\t[1,1,0,0,0]\\n\\t[1,0,0,0,0]\\n\\t[0,0,0,0,0]\\n\\t[0,0,0,0,0]]\\n```\\t\\n \\n  \\n\\n\\n```\\n    public int minSwaps(int[][] nums) {        \\n        int result = 0;        \\n        int requiredZeroes = nums.length - 1;\\n        List<Integer> numZeroes = new ArrayList<>();   \\n        int index = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int count = 0;\\n            for (int j = nums.length - 1; j >= 0 && nums[i][j] == 0; j--) {\\n                count++;\\n            }\\n            numZeroes.add(count);\\n        }\\n        \\n        \\n        for (int i = 0; i < nums.length ; i++) {  \\n            int tempIndex = index;                        \\n            while (tempIndex < numZeroes.size() && numZeroes.get(tempIndex) < requiredZeroes) {\\n                tempIndex++;\\n            }\\n            if (tempIndex == nums.length) {\\n                return -1; \\n            }            \\n            result += tempIndex - index;                        \\n            numZeroes.add(i, numZeroes.remove(tempIndex));                \\n            requiredZeroes--;\\n            index++;\\n        }\\n                       \\n        return result;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```[1,1,0,0]: contains 2```\n```[1.0.0.0]: contains 3```\n```\\n    [[0,0,0,0,1]\\n\\t[1,1,0,0,0]\\n\\t[1,0,0,0,0]\\n\\t[0,0,0,0,0]\\n\\t[0,0,0,0,0]]\\n```\n```\\n    public int minSwaps(int[][] nums) {        \\n        int result = 0;        \\n        int requiredZeroes = nums.length - 1;\\n        List<Integer> numZeroes = new ArrayList<>();   \\n        int index = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int count = 0;\\n            for (int j = nums.length - 1; j >= 0 && nums[i][j] == 0; j--) {\\n                count++;\\n            }\\n            numZeroes.add(count);\\n        }\\n        \\n        \\n        for (int i = 0; i < nums.length ; i++) {  \\n            int tempIndex = index;                        \\n            while (tempIndex < numZeroes.size() && numZeroes.get(tempIndex) < requiredZeroes) {\\n                tempIndex++;\\n            }\\n            if (tempIndex == nums.length) {\\n                return -1; \\n            }            \\n            result += tempIndex - index;                        \\n            numZeroes.add(i, numZeroes.remove(tempIndex));                \\n            requiredZeroes--;\\n            index++;\\n        }\\n                       \\n        return result;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 768339,
                "title": "c-greedy-min-adj-swap-to-sort-an-array",
                "content": "class Solution {\\npublic:\\n\\n\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> v;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            int c=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(!grid[i][j])\\n                    c++;\\n                else\\n                    break;\\n            }\\n            v.push_back(c);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n && v[i]<m-i-1;j++){\\n                swap(v[i],v[j]);\\n                ans++;\\n            }\\n            if(v[i]<m-i-1)\\n                return -1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> v;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            int c=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(!grid[i][j])\\n                    c++;\\n                else\\n                    break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 768285,
                "title": "c-greedily-find-the-final-position-of-each-row-and-bubble-sort",
                "content": "**Main idea:**\\n1. Find the rightmost index of \"1\" in each row and convert the original grid to a 1D array. These indices also represent the \"topmost\" location of each row in the grid.\\n2. Figure out the final position of each row with a greedy approach: Try placing each row in its \"topmost\" location. If that location is already filled by another row, move the location down by 1 (increment the index).\\n3. Count the number of swaps required from original arrangement [0, 1, 2, ..., n-1] to the final arrangement using Bubble Sort.\\n\\nSpecial thanks to @xinyu95 for the clarification!\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n        // Find the location of rightmost \"1\", which is also its topmost location in grid\\n        vector<int> ones(n, n-1);\\n        for (int i=0; i<n; ++i) {\\n            for (int j=n-1; j>0; --j) {\\n                if (grid[i][j] != 1) {\\n                    --ones[i];\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        // This array greedily records the final position of each row.\\n        // In other words, pos[i] = j means that the jth row in the original grid should finally be placed\\n        // in the ith row to meet the standard.\\n        vector<int> pos(n, -1);\\n        for (int i=0; i<ones.size(); ++i) {\\n            // First find the topmost row position based on the location of rightmost \"1\"\\n            int f_pos = ones[i];\\n            // If that position is already filled by another row, increment the index\\n            while (pos[f_pos] != -1) {\\n                ++f_pos;\\n                // If index is out of range, this means we cannot find a valid position for the current row\\n                // so just return -1\\n                if (f_pos >= n) {\\n                    return -1;\\n                }\\n            }\\n            pos[f_pos] = i;\\n        }\\n        // The initial position is just [0, 1, 2, ..., n-1].\\n        // This means we need to transform \"pos\" to [0, 1, 2, ..., n-1] by only swapping adjacent rows.\\n        // Therefore we can use bubble sort.\\n        int swaps = INT_MAX;\\n        while (swaps > 0) {\\n            int tmp = 0;\\n            for (int i=0; i<n-1; ++i) {\\n                if (pos[i] > pos[i+1]) {\\n                    swap(pos[i], pos[i+1]);\\n                    ++tmp;\\n                }\\n            }\\n            res += tmp; swaps = tmp;\\n        }\\n        return res;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n        // Find the location of rightmost \"1\", which is also its topmost location in grid\\n        vector<int> ones(n, n-1);\\n        for (int i=0; i<n; ++i) {\\n            for (int j=n-1; j>0; --j) {\\n                if (grid[i][j] != 1) {\\n                    --ones[i];\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        // This array greedily records the final position of each row.\\n        // In other words, pos[i] = j means that the jth row in the original grid should finally be placed\\n        // in the ith row to meet the standard.\\n        vector<int> pos(n, -1);\\n        for (int i=0; i<ones.size(); ++i) {\\n            // First find the topmost row position based on the location of rightmost \"1\"\\n            int f_pos = ones[i];\\n            // If that position is already filled by another row, increment the index\\n            while (pos[f_pos] != -1) {\\n                ++f_pos;\\n                // If index is out of range, this means we cannot find a valid position for the current row\\n                // so just return -1\\n                if (f_pos >= n) {\\n                    return -1;\\n                }\\n            }\\n            pos[f_pos] = i;\\n        }\\n        // The initial position is just [0, 1, 2, ..., n-1].\\n        // This means we need to transform \"pos\" to [0, 1, 2, ..., n-1] by only swapping adjacent rows.\\n        // Therefore we can use bubble sort.\\n        int swaps = INT_MAX;\\n        while (swaps > 0) {\\n            int tmp = 0;\\n            for (int i=0; i<n-1; ++i) {\\n                if (pos[i] > pos[i+1]) {\\n                    swap(pos[i], pos[i+1]);\\n                    ++tmp;\\n                }\\n            }\\n            res += tmp; swaps = tmp;\\n        }\\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768147,
                "title": "simple-java-solution-bubble-sort",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n      \\n        int n=grid.length;\\n        int arr[]=new int[n];\\n        int check[]=new int[n];\\n        int k=0;\\n        for(int row[]:grid){\\n            int i=n-1;\\n            while(i>=0 && row[i]==0)\\n                i--;\\n            int val=n-i-1;\\n            for(int j=n-1;j>=0;j--){\\n                if(check[j]!=-1 && val>=j){\\n                    check[j]=-1;\\n                    arr[k++]=j;\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(check[i]==0)\\n                return -1;\\n        }\\n        int count=0;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=0;j<n-i-1;j++){\\n                if(arr[j]<arr[j+1]){\\n                    int temp=arr[j];\\n                    arr[j]=arr[j+1];\\n                    arr[j+1]=temp;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n      \\n        int n=grid.length;\\n        int arr[]=new int[n];\\n        int check[]=new int[n];\\n        int k=0;\\n        for(int row[]:grid){\\n            int i=n-1;\\n            while(i>=0 && row[i]==0)\\n                i--;\\n            int val=n-i-1;\\n            for(int j=n-1;j>=0;j--){\\n                if(check[j]!=-1 && val>=j){\\n                    check[j]=-1;\\n                    arr[k++]=j;\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(check[i]==0)\\n                return -1;\\n        }\\n        int count=0;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=0;j<n-i-1;j++){\\n                if(arr[j]<arr[j+1]){\\n                    int temp=arr[j];\\n                    arr[j]=arr[j+1];\\n                    arr[j+1]=temp;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768119,
                "title": "c-count-zeros-from-right-side",
                "content": "Runtime: 376 ms\\nMemory Usage: 31.4 MB\\n\\nIdea: \\n* Count the number of zeros for each line of the grid (stored in \"rightZeros\" array)\\n\\n* Traverse the grid starting at row 0. If the row has the proper number of zeros keep going; else find the closest row (A) after it that has the right number of zeros. \\n\\n* Instead of swapping the rows  I just mark the row (A), by adding it to \"ignorePos\" so we ignore it in the future. I could have used a list instead of an array for \"rightZeros\" and I could have easily removed it but didn\\'t think of it in the contest until to late. Because I am using a HashSet, I need to calculate the \"swapAdds\" value instead of using the difference between the row positions.  \\n\\nI could have done this in an iterative way instead of recursion, that would have been more efficient.\\n\\n```\\n    public int MinSwaps(int[][] grid) {\\n       int[] rightZeros = GetZeroCounts(grid);\\n       int result = int.MaxValue;\\n       HashSet<int> ignorePos = new HashSet<int>();\\n        \\n       Traverse(rightZeros, grid.Length-1, 0, ref result, 0, ignorePos);\\n        \\n       return (result == int.MaxValue)? -1: result;\\n    }\\n    \\n    public void Traverse(int[] rightZeros, int needed, int start, ref int result, int swaps, HashSet<int> ignorePos)\\n    {\\n        if (start == rightZeros.Length)\\n        {\\n            if (swaps < result) { result = swaps; }\\n            return;\\n        }\\n        \\n        if (ignorePos.Contains(start)) // row was moved to the top\\n        {\\n            Traverse(rightZeros, needed, start+1, ref result, swaps, ignorePos); \\n        }\\n        else if (rightZeros[start] >= needed) \\n        {\\n            Traverse(rightZeros, needed-1, start+1, ref result, swaps, ignorePos);\\n        }\\n        else\\n        {\\n            //find posible swaps \\n            int pos = GetPossibleSwapRow(rightZeros, needed, start+1, ignorePos);\\n            int swapAdds = 0;\\n            \\n            if (pos != -1) \\n            {\\n                ignorePos.Add(pos);\\n                \\n                for(int j = start; j < pos; j++)\\n                {\\n                    if (!ignorePos.Contains(j)) { swapAdds++; }\\n                }\\n                \\n                Traverse(rightZeros, needed-1, start, ref result, swaps + swapAdds, ignorePos);\\n                \\n                ignorePos.Remove(pos);\\n            }\\n        }\\n    }\\n    \\n    private int GetPossibleSwapRow(int[] rightZeros, int needed, int start, HashSet<int> ignorePos)\\n    {\\n       \\n        for(int i=start; i< rightZeros.Length; i++)\\n        {\\n            if (!ignorePos.Contains(i) && rightZeros[i] >= needed) { return i; }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public int[] GetZeroCounts(int[][] grid)\\n    {\\n        int[] rightZeros = new int[grid.Length];\\n        \\n        int count;\\n        \\n        for(int i=0; i< grid.Length; i++)\\n        {\\n            count = 0;\\n            for(int j= grid.Length - 1; j>=0; j--)\\n            {\\n                if (grid[i][j] != 0) { break; }\\n                count++;\\n            }\\n            rightZeros[i] = count;\\n        }\\n        \\n        return rightZeros;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 376 ms\\nMemory Usage: 31.4 MB\\n\\nIdea: \\n* Count the number of zeros for each line of the grid (stored in \"rightZeros\" array)\\n\\n* Traverse the grid starting at row 0. If the row has the proper number of zeros keep going; else find the closest row (A) after it that has the right number of zeros. \\n\\n* Instead of swapping the rows  I just mark the row (A), by adding it to \"ignorePos\" so we ignore it in the future. I could have used a list instead of an array for \"rightZeros\" and I could have easily removed it but didn\\'t think of it in the contest until to late. Because I am using a HashSet, I need to calculate the \"swapAdds\" value instead of using the difference between the row positions.  \\n\\nI could have done this in an iterative way instead of recursion, that would have been more efficient.\\n\\n```\\n    public int MinSwaps(int[][] grid) {\\n       int[] rightZeros = GetZeroCounts(grid);\\n       int result = int.MaxValue;\\n       HashSet<int> ignorePos = new HashSet<int>();\\n        \\n       Traverse(rightZeros, grid.Length-1, 0, ref result, 0, ignorePos);\\n        \\n       return (result == int.MaxValue)? -1: result;\\n    }\\n    \\n    public void Traverse(int[] rightZeros, int needed, int start, ref int result, int swaps, HashSet<int> ignorePos)\\n    {\\n        if (start == rightZeros.Length)\\n        {\\n            if (swaps < result) { result = swaps; }\\n            return;\\n        }\\n        \\n        if (ignorePos.Contains(start)) // row was moved to the top\\n        {\\n            Traverse(rightZeros, needed, start+1, ref result, swaps, ignorePos); \\n        }\\n        else if (rightZeros[start] >= needed) \\n        {\\n            Traverse(rightZeros, needed-1, start+1, ref result, swaps, ignorePos);\\n        }\\n        else\\n        {\\n            //find posible swaps \\n            int pos = GetPossibleSwapRow(rightZeros, needed, start+1, ignorePos);\\n            int swapAdds = 0;\\n            \\n            if (pos != -1) \\n            {\\n                ignorePos.Add(pos);\\n                \\n                for(int j = start; j < pos; j++)\\n                {\\n                    if (!ignorePos.Contains(j)) { swapAdds++; }\\n                }\\n                \\n                Traverse(rightZeros, needed-1, start, ref result, swaps + swapAdds, ignorePos);\\n                \\n                ignorePos.Remove(pos);\\n            }\\n        }\\n    }\\n    \\n    private int GetPossibleSwapRow(int[] rightZeros, int needed, int start, HashSet<int> ignorePos)\\n    {\\n       \\n        for(int i=start; i< rightZeros.Length; i++)\\n        {\\n            if (!ignorePos.Contains(i) && rightZeros[i] >= needed) { return i; }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public int[] GetZeroCounts(int[][] grid)\\n    {\\n        int[] rightZeros = new int[grid.Length];\\n        \\n        int count;\\n        \\n        for(int i=0; i< grid.Length; i++)\\n        {\\n            count = 0;\\n            for(int j= grid.Length - 1; j>=0; j--)\\n            {\\n                if (grid[i][j] != 0) { break; }\\n                count++;\\n            }\\n            rightZeros[i] = count;\\n        }\\n        \\n        return rightZeros;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 768106,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& g) {\\n        int n = g.size();\\n        vector<int> v(n,0);\\n        for(int i = 0;i < n;i++){\\n            int j = n - 1;\\n            while(j >= 0 && g[i][j] == 0)  // we are calculating number of zeros at end of each raw\\n                v[i]++,j--;\\n        }\\n        int sum = 0;\\n        for(int i = 0;i < n;i++){\\n            if(v[i] >= n - 1 - i) continue;   // if perticular raw have required zeros then continue \\n                                              //else check any other raw has required zeros or not \\n                                              //if not then return -1 else swap raws\\n            int f = 0;\\n            int k = -1;\\n            for(int j = i + 1;j < n;j++){\\n                if(v[j] >= n - 1 - i){\\n                    f = 1;\\n                    k = j;\\n                    break;\\n                }\\n            }\\n            if(!f) return -1;\\n            for(int j = k;j  > i;j--)\\n                swap(v[j],v[j-1]) , sum++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& g) {\\n        int n = g.size();\\n        vector<int> v(n,0);\\n        for(int i = 0;i < n;i++){\\n            int j = n - 1;\\n            while(j >= 0 && g[i][j] == 0)  // we are calculating number of zeros at end of each raw\\n                v[i]++,j--;\\n        }\\n        int sum = 0;\\n        for(int i = 0;i < n;i++){\\n            if(v[i] >= n - 1 - i) continue;   // if perticular raw have required zeros then continue \\n                                              //else check any other raw has required zeros or not \\n                                              //if not then return -1 else swap raws\\n            int f = 0;\\n            int k = -1;\\n            for(int j = i + 1;j < n;j++){\\n                if(v[j] >= n - 1 - i){\\n                    f = 1;\\n                    k = j;\\n                    break;\\n                }\\n            }\\n            if(!f) return -1;\\n            for(int j = k;j  > i;j--)\\n                swap(v[j],v[j-1]) , sum++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704602,
                "title": "c-95-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid){\\n        int n = grid.size();\\n        int ans = 0;\\n        vector<int> t; \\n        for(int i=0;i<n;i++){\\n            int zero = 0;\\n            for(int j=n-1;j>=0;j--){\\n                if(grid[i][j]) break;\\n                zero++;\\n            }\\n            t.push_back(zero);\\n        }\\n        for(int i=0;i<n;i++){\\n            \\n            int curr = i;\\n            int req = n - 1 - i; \\n            while(curr < n and t[curr] < req) curr++;\\n            \\n            if(curr == n) return -1;\\n            ans += curr - i;\\n            while(curr > 0){\\n                t[curr] = t[curr - 1];\\n                curr--;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid){\\n        int n = grid.size();\\n        int ans = 0;\\n        vector<int> t; \\n        for(int i=0;i<n;i++){\\n            int zero = 0;\\n            for(int j=n-1;j>=0;j--){\\n                if(grid[i][j]) break;\\n                zero++;\\n            }\\n            t.push_back(zero);\\n        }\\n        for(int i=0;i<n;i++){\\n            \\n            int curr = i;\\n            int req = n - 1 - i; \\n            while(curr < n and t[curr] < req) curr++;\\n            \\n            if(curr == n) return -1;\\n            ans += curr - i;\\n            while(curr > 0){\\n                t[curr] = t[curr - 1];\\n                curr--;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576538,
                "title": "c-brute-force-greedy-observation-cleanest-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        //brute force\\n        int res=0;\\n        int n=grid.size();\\n        for(int i=0;i<n;i++){\\n            //first row must have n-1 zeroes from the back;\\n            int counter=n-i-1;\\n            int j=n-1;\\n            int ctz=0;\\n            for(int k=j;k>i;k--){\\n                if(grid[i][k]==0){\\n                    ctz++;\\n                }\\n            }\\n            if(ctz==counter){\\n                continue;//this row is okay\\n            }\\n            //but if not we need to find the row which has counter number of zeroes\\n            int row=-1;\\n            for(int q=i+1;q<n;q++){\\n                int ctz1=0;\\n                for(int j=n-1;j>i;j--){\\n                    if(grid[q][j]==0){\\n                        ctz1++;\\n                    }\\n                }\\n                if(ctz1==counter){\\n                    row=q;\\n                    break;\\n                }\\n            }\\n            //cout<<row<<endl;\\n            if(row==-1){res=-1;break;}\\n            //else we have to bring this row i.e the qth row from the bottom to the top\\n            int swaps=row-i;\\n            while(swaps>0){\\n                for(int oo=n-1;oo>=0;oo--){\\n                    swap(grid[row][oo],grid[row-1][oo]);\\n                }\\n                row=row-1;\\n                swaps--;\\n                res++;\\n            }   \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        //brute force\\n        int res=0;\\n        int n=grid.size();\\n        for(int i=0;i<n;i++){\\n            //first row must have n-1 zeroes from the back;\\n            int counter=n-i-1;\\n            int j=n-1;\\n            int ctz=0;\\n            for(int k=j;k>i;k--){\\n                if(grid[i][k]==0){\\n                    ctz++;\\n                }\\n            }\\n            if(ctz==counter){\\n                continue;//this row is okay\\n            }\\n            //but if not we need to find the row which has counter number of zeroes\\n            int row=-1;\\n            for(int q=i+1;q<n;q++){\\n                int ctz1=0;\\n                for(int j=n-1;j>i;j--){\\n                    if(grid[q][j]==0){\\n                        ctz1++;\\n                    }\\n                }\\n                if(ctz1==counter){\\n                    row=q;\\n                    break;\\n                }\\n            }\\n            //cout<<row<<endl;\\n            if(row==-1){res=-1;break;}\\n            //else we have to bring this row i.e the qth row from the bottom to the top\\n            int swaps=row-i;\\n            while(swaps>0){\\n                for(int oo=n-1;oo>=0;oo--){\\n                    swap(grid[row][oo],grid[row-1][oo]);\\n                }\\n                row=row-1;\\n                swaps--;\\n                res++;\\n            }   \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2352475,
                "title": "bubble-sort",
                "content": "First I tried to do using some logic of counting inversion points using the concepts of MERGE SORT [as  I was practicing \"minimum adjacent swaps to make an array sorted\" , but later found that , I had to manipulate  the array in a more complex way  ] \\nThen  thought about greedly making the  swaps , and came up with the BUBBLE SORT technique\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        multiset<int> st; // to reject -1 case \\n        vector<int> main; //for correct order , to later apply bubble sort \\n        \\n        for( int i =0 ; i<n ; i++){\\n            \\n            int cnt =0;\\n            for( int j =n-1 ; j>=0 ; j--){\\n                if(grid[i][j] ==1 ) break;\\n                else if(grid[i][j] == 0 ) cnt++;\\n            }\\n            st.insert(cnt);\\n            main.push_back(cnt);\\n        }\\n        \\n        vector<int> tmp(n, 0);\\n        iota(tmp.begin() , tmp.end(), 0);  // to match the required order \\n        \\n        int k =0;\\n        \\n        \\n        for( auto c:st){\\n            if(c < tmp[k++]) return -1;\\n        }\\n        \\n        k = n-1;\\n        int cnt =0;\\n        for( int i =0 ; i<n-1 ; i++){\\n            \\n            if( main[i] >= k){   \\n                k--;\\n                continue;\\n            }\\n            else{\\n                int j = i+1;\\n                while(j < n  and main[j] < k){    \\n                    j++;\\n                }\\n                cnt += (j-i);\\n                while(j != i){\\n                    swap(main[j] , main[j-1]);  \\n                    j--;\\n                }\\n                k--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};**********\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        multiset<int> st; // to reject -1 case \\n        vector<int> main; //for correct order , to later apply bubble sort \\n        \\n        for( int i =0 ; i<n ; i++){\\n            \\n            int cnt =0;\\n            for( int j =n-1 ; j>=0 ; j--){\\n                if(grid[i][j] ==1 ) break;\\n                else if(grid[i][j] == 0 ) cnt++;\\n            }\\n            st.insert(cnt);\\n            main.push_back(cnt);\\n        }\\n        \\n        vector<int> tmp(n, 0);\\n        iota(tmp.begin() , tmp.end(), 0);  // to match the required order \\n        \\n        int k =0;\\n        \\n        \\n        for( auto c:st){\\n            if(c < tmp[k++]) return -1;\\n        }\\n        \\n        k = n-1;\\n        int cnt =0;\\n        for( int i =0 ; i<n-1 ; i++){\\n            \\n            if( main[i] >= k){   \\n                k--;\\n                continue;\\n            }\\n            else{\\n                int j = i+1;\\n                while(j < n  and main[j] < k){    \\n                    j++;\\n                }\\n                cnt += (j-i);\\n                while(j != i){\\n                    swap(main[j] , main[j-1]);  \\n                    j--;\\n                }\\n                k--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};**********\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688807,
                "title": "min-adjacent-swaps-to-sort-array-explained",
                "content": "from first rorw to last, count number of trailing zeroes. Record only the highest number not shown yet. For example, at row 0, trailing zeroes = 10, set it to 10. Row 1, trailing zeroes = 10 as well, because 10 already shown, set it to 9. One row to be 10 is ALREADY enough. (This will be explained later). \\n\\nWhen all number is recorded, this creates an array with unique integers. If array size is less than n, in other words, array is not 0, 1, 2, ..., n-1, then it\\'s impossible to form a VALID matrix. \\n\\nIf array size is n, we now calculate min adjacent swaps to sort the array. Notice for a correct swap of adjacent number i, j (i < j) to j, i, it reduces total number of inversion of the array by exactly 1. This means for a sorted array of inversion = 0, minimum number of swaps needed is exactly number of inversions. So we just calculate inversions. \\n\\nNow why we need to record highest different trailing zeroes? To avoid ambiguity for counting inversions. For an counter-example, for array  a1, a2, ..., a10, if a1 = 8, a2=9, a3=9, we only need to count a2 as an inversion, because a3 only needs 7 zeroes and stay at row 2 and matrix is still valid. Why take higest different  trailing zeroes starting from first row? It creates an array that needs minimum adacent  swaps.\\n\\n```python\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        arr = []\\n        S = set()\\n        for row in grid:\\n            c = 0\\n            for i in row[::-1]:\\n                if i:\\n                    break\\n                c += 1\\n            while c in S:\\n                c -= 1\\n            if c >= 0:\\n                S.add(c)\\n                arr += c,\\n            \\n        if len(arr) < n:\\n            return -1\\n        \\n        res = 0\\n        for i, v in enumerate(arr):\\n            for v2 in arr[i+1:]:\\n                if v2 > v:\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        arr = []\\n        S = set()\\n        for row in grid:\\n            c = 0\\n            for i in row[::-1]:\\n                if i:\\n                    break\\n                c += 1\\n            while c in S:\\n                c -= 1\\n            if c >= 0:\\n                S.add(c)\\n                arr += c,\\n            \\n        if len(arr) < n:\\n            return -1\\n        \\n        res = 0\\n        for i, v in enumerate(arr):\\n            for v2 in arr[i+1:]:\\n                if v2 > v:\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1399909,
                "title": "c-solution-easy-to-understand-image-explaination",
                "content": "The idea is to get the number of zeros in the suffix of each array. We will count the number of zeros on the right end of each row anf when we encounter one we break from that row, moreover we store the number of zeros in the right side of that row in a array.\\n\\nnow, ![image](https://assets.leetcode.com/users/images/2e732818-c6a7-4fe6-84e0-29a952997268_1628787555.2624369.png)\\n\\nKnowing the aboe logic the problem is being melt down to find the minimum number of adjecent swaps to sort the array in increasing order.\\n\\t\\n\\tint minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        //store the continous zeros in right side of each row\\n        vector<int> zeros(n, 0);\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=n-1; j>=1; j--){\\n                if(grid[i][j] == 0){\\n\\t\\t\\t\\t//if zeros is found the increment\\n                    zeros[i]++;\\n                } \\n\\t\\t\\t\\t//else break\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<n-1; i++){\\n\\t\\t//the required number of zeros in the corresponding row\\n            int req = n-i-1;\\n            int k=i;\\n            while(k < n && min(req, zeros[k]) != req){\\n                k++;\\n            }\\n            //if we are unable to find such then return -1 (not possible)\\n            if(k == n){\\n                return -1;\\n            }\\n            //else add hte number of swaps in the answer\\n            ans += (k - i);\\n\\t\\t\\t//drag the required number of zeros to the current index by swapping it with its previous elements.\\n            while(k > i){\\n                swap(zeros[k], zeros[k-1]);\\n                k--;\\n            }\\n        }\\n        //retrun the number of swaps\\n        return ans;\\n    }\\n\\t\\n**Hope it helped!**",
                "solutionTags": [
                    "C"
                ],
                "code": "The idea is to get the number of zeros in the suffix of each array. We will count the number of zeros on the right end of each row anf when we encounter one we break from that row, moreover we store the number of zeros in the right side of that row in a array.\\n\\nnow, ![image](https://assets.leetcode.com/users/images/2e732818-c6a7-4fe6-84e0-29a952997268_1628787555.2624369.png)\\n\\nKnowing the aboe logic the problem is being melt down to find the minimum number of adjecent swaps to sort the array in increasing order.\\n\\t\\n\\tint minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        //store the continous zeros in right side of each row\\n        vector<int> zeros(n, 0);\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=n-1; j>=1; j--){\\n                if(grid[i][j] == 0){\\n\\t\\t\\t\\t//if zeros is found the increment\\n                    zeros[i]++;\\n                } \\n\\t\\t\\t\\t//else break\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<n-1; i++){\\n\\t\\t//the required number of zeros in the corresponding row\\n            int req = n-i-1;\\n            int k=i;\\n            while(k < n && min(req, zeros[k]) != req){\\n                k++;\\n            }\\n            //if we are unable to find such then return -1 (not possible)\\n            if(k == n){\\n                return -1;\\n            }\\n            //else add hte number of swaps in the answer\\n            ans += (k - i);\\n\\t\\t\\t//drag the required number of zeros to the current index by swapping it with its previous elements.\\n            while(k > i){\\n                swap(zeros[k], zeros[k-1]);\\n                k--;\\n            }\\n        }\\n        //retrun the number of swaps\\n        return ans;\\n    }\\n\\t\\n**Hope it helped!**",
                "codeTag": "Unknown"
            },
            {
                "id": 1299896,
                "title": "c-easy-solution-greedy",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int ar[n+1];\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int num=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    num++;\\n                }\\n                else\\n                {\\n                    break ;\\n                }\\n            }\\n            ar[i]=num;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ar[i]>=n-i-1)\\n            {\\n                continue ;\\n            }\\n            int j=i+1;\\n            bool temp=false;\\n            for(;j<n;j++)\\n            {\\n                if(ar[j]>=n-i-1)\\n                {\\n                    temp=true;\\n                    break ;\\n                }\\n            }\\n            if(!temp)\\n            {\\n                return -1;\\n            }\\n            while(j!=i)\\n            {\\n                swap(ar[j],ar[j-1]);\\n                ans++;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int ar[n+1];\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int num=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    num++;\\n                }\\n                else\\n                {\\n                    break ;\\n                }\\n            }\\n            ar[i]=num;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ar[i]>=n-i-1)\\n            {\\n                continue ;\\n            }\\n            int j=i+1;\\n            bool temp=false;\\n            for(;j<n;j++)\\n            {\\n                if(ar[j]>=n-i-1)\\n                {\\n                    temp=true;\\n                    break ;\\n                }\\n            }\\n            if(!temp)\\n            {\\n                return -1;\\n            }\\n            while(j!=i)\\n            {\\n                swap(ar[j],ar[j-1]);\\n                ans++;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185469,
                "title": "c-c-n-2",
                "content": "```\\nclass Solution {\\n   \\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int res = 0;    \\n        int n = grid.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=n-1;\\n            while(j>=0 && grid[i][j]==0)\\n                j--;\\n            grid[i][0] = n-j-1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            for( int j=0; j<n; j++)\\n            {\\n                if (grid[j][0]>=n-i-1)\\n                {\\n                    res += c;\\n                    grid[j][0] = -1;\\n                    break;\\n                }\\n                if (grid[j][0]!=-1)\\n                    c++;\\n            }\\n            if(j==n)\\n                return -1;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   \\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int res = 0;    \\n        int n = grid.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=n-1;\\n            while(j>=0 && grid[i][j]==0)\\n                j--;\\n            grid[i][0] = n-j-1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            for( int j=0; j<n; j++)\\n            {\\n                if (grid[j][0]>=n-i-1)\\n                {\\n                    res += c;\\n                    grid[j][0] = -1;\\n                    break;\\n                }\\n                if (grid[j][0]!=-1)\\n                    c++;\\n            }\\n            if(j==n)\\n                return -1;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074051,
                "title": "clear-o-n-2-python-solution",
                "content": "Happy to clarify if any of this is unclear -- let me know.\\n\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        # For each row, we just need to make sure the column of the last 1\\n        # is <= the row\\'s position in the grid (row at index 0 can have a 1\\n        # at its 0th column, row at index 1 can have a 1 at its 1th column, etc.).\\n        # So we store the information about the column of the last 1.\\n        must_be_gte = [\\n            max([i for i in range(len(row)) if row[i] == 1], default=-1)\\n            for row in grid\\n        ]\\n        \\n        # Now at each index of the grid, we try to keep the current row.\\n        # If we can\\'t (b/c its last 1 is > the index of the row), we find\\n        # the next available row which does fit the condition, and swap it\\n        # bubble sort style leftwards all the way to the current index.\\n        swaps = 0\\n        for index in range(len(grid)):\\n            if must_be_gte[index] > index:\\n                found = False\\n                for swap_index in range(index + 1, len(grid)):\\n                    if must_be_gte[swap_index] <= index:\\n                        must_be_gte.insert(index, must_be_gte.pop(swap_index))\\n                        swaps += swap_index - index\\n                        found = True\\n                        break\\n                if not found:\\n                    return -1\\n        return swaps",
                "solutionTags": [],
                "code": "Happy to clarify if any of this is unclear -- let me know.\\n\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        # For each row, we just need to make sure the column of the last 1\\n        # is <= the row\\'s position in the grid (row at index 0 can have a 1\\n        # at its 0th column, row at index 1 can have a 1 at its 1th column, etc.).\\n        # So we store the information about the column of the last 1.\\n        must_be_gte = [\\n            max([i for i in range(len(row)) if row[i] == 1], default=-1)\\n            for row in grid\\n        ]\\n        \\n        # Now at each index of the grid, we try to keep the current row.\\n        # If we can\\'t (b/c its last 1 is > the index of the row), we find\\n        # the next available row which does fit the condition, and swap it\\n        # bubble sort style leftwards all the way to the current index.\\n        swaps = 0\\n        for index in range(len(grid)):\\n            if must_be_gte[index] > index:\\n                found = False\\n                for swap_index in range(index + 1, len(grid)):\\n                    if must_be_gte[swap_index] <= index:\\n                        must_be_gte.insert(index, must_be_gte.pop(swap_index))\\n                        swaps += swap_index - index\\n                        found = True\\n                        break\\n                if not found:\\n                    return -1\\n        return swaps",
                "codeTag": "Python3"
            },
            {
                "id": 1039987,
                "title": "brute-force-bubble-sort",
                "content": "```\\npublic int minSwaps(int[][] grid) {\\n        int m = grid.length, start = 1, ans = 0;\\n        int[] r = new int[m];\\n        for (int i = 1; i < m; i++){\\n            r[i] = i;\\n        }\\n        for (int i = 0; i < m; i++){\\n            if (isValid(grid,start,r[i])){\\n                start+=1;\\n                continue;\\n            }\\n            boolean flag = true;                // brute force\\n            for (int j = i+1; j < m; j++){\\n                if (isValid(grid,start,r[j])){\\n                    flag = false;\\n                    ans += swap(r,i,j);\\n                    break;\\n                }\\n            }\\n            if (flag) return -1;\\n            start++;\\n        }\\n        return ans; \\n    }\\n    boolean isValid(int[][] grid, int start, int row){\\n        for (int i = start; i < grid[0].length; i++){\\n            if (grid[row][i] == 1) return false;\\n        }\\n        return true;\\n    }\\n    int swap(int[] r, int start, int end){\\n        int cnt = 0;\\n        for (int i = end; i >= start+1; i--){\\n            int tmp = r[i];\\n            r[i] = r[i-1];\\n            r[i-1] = tmp;\\n            cnt +=1;\\n        }\\n        return cnt;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minSwaps(int[][] grid) {\\n        int m = grid.length, start = 1, ans = 0;\\n        int[] r = new int[m];\\n        for (int i = 1; i < m; i++){\\n            r[i] = i;\\n        }\\n        for (int i = 0; i < m; i++){\\n            if (isValid(grid,start,r[i])){\\n                start+=1;\\n                continue;\\n            }\\n            boolean flag = true;                // brute force\\n            for (int j = i+1; j < m; j++){\\n                if (isValid(grid,start,r[j])){\\n                    flag = false;\\n                    ans += swap(r,i,j);\\n                    break;\\n                }\\n            }\\n            if (flag) return -1;\\n            start++;\\n        }\\n        return ans; \\n    }\\n    boolean isValid(int[][] grid, int start, int row){\\n        for (int i = start; i < grid[0].length; i++){\\n            if (grid[row][i] == 1) return false;\\n        }\\n        return true;\\n    }\\n    int swap(int[] r, int start, int end){\\n        int cnt = 0;\\n        for (int i = end; i >= start+1; i--){\\n            int tmp = r[i];\\n            r[i] = r[i-1];\\n            r[i-1] = tmp;\\n            cnt +=1;\\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1023517,
                "title": "c-beat-100",
                "content": "```\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), res = 0;\\n        list<int> cnt0;\\n        for(const auto& v:grid) \\n            cnt0.push_back(find(v.rbegin(), v.rend(), 1) - v.rbegin());\\n        \\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            for(auto it = cnt0.begin(); it !=cnt0.end(); ++it, ++j){\\n                if(*it >= n-i-1){\\n                    res += j;\\n                    cnt0.erase(it);\\n                    break;\\n                }\\n            }\\n            if(j==n-i) return -1;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), res = 0;\\n        list<int> cnt0;\\n        for(const auto& v:grid) \\n            cnt0.push_back(find(v.rbegin(), v.rend(), 1) - v.rbegin());\\n        \\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            for(auto it = cnt0.begin(); it !=cnt0.end(); ++it, ++j){\\n                if(*it >= n-i-1){\\n                    res += j;\\n                    cnt0.erase(it);\\n                    break;\\n                }\\n            }\\n            if(j==n-i) return -1;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 836042,
                "title": "cpp-just-like-bubble-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int> zero_count;\\n        for (const auto &each : grid) {\\n            int count = 0;\\n            for (int i = n - 1; i >= 0; --i) {\\n                if (each[i]) break;\\n                count += 1;\\n            }\\n            zero_count.push_back(count);\\n        }\\n        int moves = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (zero_count[i] < n - 1 - i) {\\n                int end = i;\\n                while (end < n && zero_count[end] < n - 1 - i) {\\n                    ++end;\\n                }\\n                if (end == n) return -1;\\n                while (end > i) {\\n                    swap(zero_count[end], zero_count[end-1]);\\n                    --end;\\n                    ++moves;\\n                }\\n            }\\n        }\\n        return moves;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int> zero_count;\\n        for (const auto &each : grid) {\\n            int count = 0;\\n            for (int i = n - 1; i >= 0; --i) {\\n                if (each[i]) break;\\n                count += 1;\\n            }\\n            zero_count.push_back(count);\\n        }\\n        int moves = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (zero_count[i] < n - 1 - i) {\\n                int end = i;\\n                while (end < n && zero_count[end] < n - 1 - i) {\\n                    ++end;\\n                }\\n                if (end == n) return -1;\\n                while (end > i) {\\n                    swap(zero_count[end], zero_count[end-1]);\\n                    --end;\\n                    ++moves;\\n                }\\n            }\\n        }\\n        return moves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 817254,
                "title": "java-simple-bubble-sort",
                "content": "Ref: https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/discuss/767912/Java-16-lines-bubble-sort-with-line-by-line-explanation-easy-to-understand\\n```\\n    public int minSwaps(int[][] g) {\\n        List<Integer> l = new LinkedList<>();\\n        int m = g.length, n = g[0].length, res = 0;\\n        for (int i = 0, z = 0; i < m; i++, z = 0) {// z trailing zeros\\n            for (int j = n - 1; j >= 0 && g[i][j] == 0; j--) z++;\\n            l.add(z);\\n        }\\n        for (int i = 0, j = 0, z = m - 1; i < m; i++, z--, j = i) {\\n            while (l.get(j) < z) if (++j >= n) return -1;\\n            l.remove(j);\\n            l.add(i, z);\\n            res += j - i;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minSwaps(int[][] g) {\\n        List<Integer> l = new LinkedList<>();\\n        int m = g.length, n = g[0].length, res = 0;\\n        for (int i = 0, z = 0; i < m; i++, z = 0) {// z trailing zeros\\n            for (int j = n - 1; j >= 0 && g[i][j] == 0; j--) z++;\\n            l.add(z);\\n        }\\n        for (int i = 0, j = 0, z = m - 1; i < m; i++, z--, j = i) {\\n            while (l.get(j) < z) if (++j >= n) return -1;\\n            l.remove(j);\\n            l.add(i, z);\\n            res += j - i;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 776729,
                "title": "java-greedy-count-tailing-zeros-beats-100",
                "content": "1. Count tailing zeroes.\\n2. For each row find the first a row that fits\\n3. Reorder records from the current row to the one needed.\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] rows = new int[grid.length];\\n\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = grid.length-1; j>=0; j--) {\\n                if (grid[i][j] == 1)\\n                    break;\\n                \\n                rows[i]++;\\n            }\\n\\n        }\\n        \\n        return sort(rows);\\n    }\\n    \\n    private int sort(int[] a){\\n        int steps = 0;\\n        int n = a.length-1;\\n        \\n        for (int i=0; i<=n; i++) {\\n            int j = i;\\n            while (j <= n && a[j] < n-i) {\\n                j++;\\n            }\\n            \\n            if (j == n+1) return -1;\\n            \\n            if (i<j && i<n) {\\n                int tmp = a[i];\\n                for(int k=i+1; k<=j; k++){\\n                    int tt = a[k];\\n                    a[k] = tmp;\\n                    tmp = tt;\\n                }\\n                \\n                a[i] = tmp;\\n            }\\n            \\n            steps += j-i;\\n        }\\n        return steps;\\n    }\\n}\\n``",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] rows = new int[grid.length];\\n\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = grid.length-1; j>=0; j--) {\\n                if (grid[i][j] == 1)\\n                    break;\\n                \\n                rows[i]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 775934,
                "title": "c-insertion-sort-idea-100-faster",
                "content": "The idea here is we need atleast n-1 zeros at the end in zeroth row and n-2 in first row and atleast (n-1-i) zeros in ith row. So, we can maintain a count of zeros on the right in some array/vector and then check if we have enough zeros according to the condition above to check whether there exists any answer or not.\\nAnd if there exists some answer then we can simulate swaps like we do in insertion sort to sort the array on the vector containing count of zeros on the right.\\n\\n```\\nclass Solution {\\npublic:\\n\\t// Function to simulate swaps like insertion sort\\n    int SWAP(vector<int>& rightzero,int idx){   \\n        int n=rightzero.size(),ans=0;\\n        int x=rightzero[idx];\\n        for(int i=idx+1;i<n;i++){\\n            if(rightzero[i]>=n-1-idx){\\n                ans+=i-idx;   // The number of swaps would be the difference in these indices\\n                for(int j=i;j>idx;j--)  // Do swaps\\n                    swap(rightzero[j],rightzero[j-1]);\\n                break;\\n            }\\n        }    \\n        return ans;\\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(n==0)\\n            return 0;\\n        vector<int> rightzero(n,0);\\n\\t\\t// Creating the rightzero vector\\n        for(int i=0;i<n;i++){\\n            for(auto j=n-1;j>=0 && grid[i][j]!=1;j--)\\n                rightzero[i]++;\\n        }\\n        vector<int> temp=rightzero;\\n\\t\\t\\n\\t\\t// We can easily check after sorting that whether there exists some answer or not.\\n\\t\\t// We can swap in descending order also, here consider the matrix is turned upside down so last row is at the top.\\n\\t\\t//so number of zeros there should be >=0\\n        sort(temp.begin(),temp.end());\\n        for(int i=0;i<n;i++)\\n            if(temp[i]<i)\\n                return -1;\\n        int ans=0;\\n\\t\\t\\n\\t\\t// Insertion Sort Function\\n        for(int i=0;i<n;i++){\\n            if(rightzero[i]>=n-1-i)\\n                continue;\\n            ans+=SWAP(rightzero,i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// Function to simulate swaps like insertion sort\\n    int SWAP(vector<int>& rightzero,int idx){   \\n        int n=rightzero.size(),ans=0;\\n        int x=rightzero[idx];\\n        for(int i=idx+1;i<n;i++){\\n            if(rightzero[i]>=n-1-idx){\\n                ans+=i-idx;   // The number of swaps would be the difference in these indices\\n                for(int j=i;j>idx;j--)  // Do swaps\\n                    swap(rightzero[j],rightzero[j-1]);\\n                break;\\n            }\\n        }    \\n        return ans;\\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(n==0)\\n            return 0;\\n        vector<int> rightzero(n,0);\\n\\t\\t// Creating the rightzero vector\\n        for(int i=0;i<n;i++){\\n            for(auto j=n-1;j>=0 && grid[i][j]!=1;j--)\\n                rightzero[i]++;\\n        }\\n        vector<int> temp=rightzero;\\n\\t\\t\\n\\t\\t// We can easily check after sorting that whether there exists some answer or not.\\n\\t\\t// We can swap in descending order also, here consider the matrix is turned upside down so last row is at the top.\\n\\t\\t//so number of zeros there should be >=0\\n        sort(temp.begin(),temp.end());\\n        for(int i=0;i<n;i++)\\n            if(temp[i]<i)\\n                return -1;\\n        int ans=0;\\n\\t\\t\\n\\t\\t// Insertion Sort Function\\n        for(int i=0;i<n;i++){\\n            if(rightzero[i]>=n-1-i)\\n                continue;\\n            ans+=SWAP(rightzero,i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774371,
                "title": "c-100-100",
                "content": "```\\npublic int MinSwaps(int[][] grid) {\\n\\tvar search = grid.Select((_, i) => grid.Length - i - 1).ToArray();\\n\\tvar zeroes = grid.Select((r, i) => r.Reverse().TakeWhile(x => x == 0).Count()).ToArray();\\n\\tvar swaps = 0;\\n\\n\\tfor (var i = 0; i < grid.Length; i++) {\\n\\t\\tvar swap = (src: -1, dest: -1);\\n\\n\\t\\tfor (var j = i; j < grid.Length; j++) {\\n\\t\\t\\tif (zeroes[j] >= search[i]) {\\n\\t\\t\\t\\tswap = (src: j, dest: i);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (swap == (-1, -1)) return -1;\\n\\n\\t\\tswaps += swap.src - swap.dest;\\n\\t\\tfor (var k = swap.src; k > swap.dest; k--)\\n\\t\\t\\t(zeroes[k], zeroes[k - 1]) = (zeroes[k - 1], zeroes[k]);\\n\\t}\\n\\n\\treturn swaps;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MinSwaps(int[][] grid) {\\n\\tvar search = grid.Select((_, i) => grid.Length - i - 1).ToArray();\\n\\tvar zeroes = grid.Select((r, i) => r.Reverse().TakeWhile(x => x == 0).Count()).ToArray();\\n\\tvar swaps = 0;\\n\\n\\tfor (var i = 0; i < grid.Length; i++) {\\n\\t\\tvar swap = (src: -1, dest: -1);\\n\\n\\t\\tfor (var j = i; j < grid.Length; j++) {\\n\\t\\t\\tif (zeroes[j] >= search[i]) {\\n\\t\\t\\t\\tswap = (src: j, dest: i);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (swap == (-1, -1)) return -1;\\n\\n\\t\\tswaps += swap.src - swap.dest;\\n\\t\\tfor (var k = swap.src; k > swap.dest; k--)\\n\\t\\t\\t(zeroes[k], zeroes[k - 1]) = (zeroes[k - 1], zeroes[k]);\\n\\t}\\n\\n\\treturn swaps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 771357,
                "title": "java-1ms-100-fastest-solution-100-memory-efficient",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int arr[] = new int[grid.length];\\n        for(int i=0;i<grid.length;i++){\\n            int count=0;\\n            for(int j=grid.length-1;j>=0;j--){\\n                if(grid[i][j]==0)count++;\\n                else{\\n                    arr[i]=count;\\n                    break;\\n                }\\n            }\\n                \\n        }\\n        int swaps=0;\\n        int ref =arr.length-1;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>=ref){\\n                ref--;\\n                continue;\\n            } \\n            int j=i+1;\\n            while(j<arr.length&&arr[j]<ref)\\n            {\\n                int temp = arr[i];\\n                arr[i]=arr[j];\\n                arr[j]= temp;\\n                j++;\\n                swaps++;\\n            }\\n            if(j<arr.length){\\n            int temp = arr[i];\\n            arr[i]=arr[j];\\n            arr[j]= temp;\\n            swaps++;\\n            ref--;}\\n            else\\n                return -1;\\n\\n            \\n        }\\n        return swaps;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int arr[] = new int[grid.length];\\n        for(int i=0;i<grid.length;i++){\\n            int count=0;\\n            for(int j=grid.length-1;j>=0;j--){\\n                if(grid[i][j]==0)count++;\\n                else{\\n                    arr[i]=count;\\n                    break;\\n                }\\n            }\\n                \\n        }\\n        int swaps=0;\\n        int ref =arr.length-1;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>=ref){\\n                ref--;\\n                continue;\\n            } \\n            int j=i+1;\\n            while(j<arr.length&&arr[j]<ref)\\n            {\\n                int temp = arr[i];\\n                arr[i]=arr[j];\\n                arr[j]= temp;\\n                j++;\\n                swaps++;\\n            }\\n            if(j<arr.length){\\n            int temp = arr[i];\\n            arr[i]=arr[j];\\n            arr[j]= temp;\\n            swaps++;\\n            ref--;}\\n            else\\n                return -1;\\n\\n            \\n        }\\n        return swaps;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770909,
                "title": "python3-580ms-greedy-o-n-2",
                "content": "For each row find the target row and do \"insert\" the target row to the destination greedily.\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        for i, x in enumerate(grid):\\n            found = False\\n            for j in range(i, len(grid)):\\n                ok = True\\n                for k in range(i+1, len(grid[j])):\\n                    if grid[j][k] == 1:\\n                        ok = False\\n                        break\\n                if ok:\\n                    found = True\\n                    while j > i:\\n                        res += 1\\n                        grid[j], grid[j-1] = grid[j-1], grid[j]\\n                        j -= 1\\n                    break\\n            if not found: return -1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        for i, x in enumerate(grid):\\n            found = False\\n            for j in range(i, len(grid)):\\n                ok = True\\n                for k in range(i+1, len(grid[j])):\\n                    if grid[j][k] == 1:\\n                        ok = False\\n                        break\\n                if ok:\\n                    found = True\\n                    while j > i:\\n                        res += 1\\n                        grid[j], grid[j-1] = grid[j-1], grid[j]\\n                        j -= 1\\n                    break\\n            if not found: return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770756,
                "title": "java-bubble-sort-with-comments",
                "content": "````\\n\\tpublic int minSwaps(int[][] grid) {\\n        int n = grid.length, A[] = new int[n], res = 0;\\n        \\n        // A[i] - number of zeros at end of ith row = grid[i]\\n        for (int i = 0; i < n; i++) \\n            for (int j = n-1; j >= 0 && grid[i][j] == 0; j--) \\n                A[i]++;                \\n        \\n        // sort by descending the number of zeros\\n        // to be above the main diagonal are zeros: A[i] >= n-i-1;\\n        for (int i = 0; i < n; i++) {\\n            \\n            // above diagonal itself\\n            if (A[i] >= n-i-1) continue;\\n            \\n            // under diagonal we search j: A[j] >= n-i-1\\n            int j = i+1;\\n            while (j < n && A[j] < n-i-1) j++;\\n            \\n            // if not found\\n            if (j == n) return -1;\\n            \\n            // if found j: swap 2 adjacent rows\\n            while (j > i) {\\n                swap(A, j-1, j--);\\n                res++;\\n            }\\n        } \\n                        \\n        return res;                \\n    }\\n    \\n    private void swap(int[] A, int i, int j) {\\n        int tmp = A[i]; A[i] = A[j]; A[j] = tmp;\\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n\\tpublic int minSwaps(int[][] grid) {\\n        int n = grid.length, A[] = new int[n], res = 0;\\n        \\n        // A[i] - number of zeros at end of ith row = grid[i]\\n        for (int i = 0; i < n; i++) \\n            for (int j = n-1; j >= 0 && grid[i][j] == 0; j--) \\n                A[i]++;                \\n        \\n        // sort by descending the number of zeros\\n        // to be above the main diagonal are zeros: A[i] >= n-i-1;\\n        for (int i = 0; i < n; i++) {\\n            \\n            // above diagonal itself\\n            if (A[i] >= n-i-1) continue;\\n            \\n            // under diagonal we search j: A[j] >= n-i-1\\n            int j = i+1;\\n            while (j < n && A[j] < n-i-1) j++;\\n            \\n            // if not found\\n            if (j == n) return -1;\\n            \\n            // if found j: swap 2 adjacent rows\\n            while (j > i) {\\n                swap(A, j-1, j--);\\n                res++;\\n            }\\n        } \\n                        \\n        return res;                \\n    }\\n    \\n    private void swap(int[] A, int i, int j) {\\n        int tmp = A[i]; A[i] = A[j]; A[j] = tmp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 769619,
                "title": "python-greedy-solution-100-time-and-space",
                "content": "Same greedy idea as other posts. Both time and space achieves 100. It is provable by contradiction that greedy is always best solution. \\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        status = []\\n        def gettrailzeros(row):\\n            for j in range(n-1, -1, -1):\\n                if grid[row][j] != 0:\\n                    return n-1-j\\n            return n\\n        for i in range(n):\\n            status.append(gettrailzeros(i))\\n        target = [n-i for i in range(1,n+1)]\\n        # greedy\\n        step = 0\\n        for i in range(n):\\n            if status[i] >= target[i]:\\n                continue\\n            for j in range(i+1, n):\\n                if status[j] >= target[i]:\\n                    for pos in range(j, i,-1):\\n                        status[pos], status[pos-1] = status[pos-1], status[pos]\\n                        step += 1\\n                    break\\n            else:\\n                return -1\\n        return step\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        status = []\\n        def gettrailzeros(row):\\n            for j in range(n-1, -1, -1):\\n                if grid[row][j] != 0:\\n                    return n-1-j\\n            return n\\n        for i in range(n):\\n            status.append(gettrailzeros(i))\\n        target = [n-i for i in range(1,n+1)]\\n        # greedy\\n        step = 0\\n        for i in range(n):\\n            if status[i] >= target[i]:\\n                continue\\n            for j in range(i+1, n):\\n                if status[j] >= target[i]:\\n                    for pos in range(j, i,-1):\\n                        status[pos], status[pos-1] = status[pos-1], status[pos]\\n                        step += 1\\n                    break\\n            else:\\n                return -1\\n        return step\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 768931,
                "title": "intuitive-approach-in-c-with-explanation",
                "content": "My idea is  based on an important observation/fact that i th row requires (n-i-1) zeroes. You can see it yourself with an example e.g. Matrix of size 4 * 4 - first row requires 3 zeroes -  i.e. (n-(rownumber)) = n-1 = 3. Similarly 2nd row requires 4-2=2 zeroes and 4th row requires 4-4=0 zeroes. Since we have 0 based indexing so n-(i+1)= n-i-1.\\n\\nStep 1: Find number of zeroes present in each row from right. \\nStep 2: If number of zeroes in a row is sufficient for the row i..e >= n-i-1 then we don;t do anything. \\n            Else we target to swap the row with its next nearest row which has sufficient zeroes. And in this  \\n\\t\\t\\tway our starting rows are getting their sufficient zeroes ( kind of bubble sort )\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        \\n        vector<int>rowzero(n,0);\\n        \\n        //counting the number of zeroes in each row from right\\n        for(int i=0;i<n;++i)\\n        {   \\n            for(int j=n-1;j>=0;--j)\\n            {\\n                if(grid[i][j]==1)\\n                    break;\\n                else\\n                    rowzero[i]++;\\n                   }\\n        }\\n        \\n        int ans=0;\\n        \\n      // finding the correct and nearest row to swap with  \\n       for(int i=0;i<n;++i)\\n       {\\n           if(rowzero[i]>=(n-i-1))\\n               continue;\\n           else{\\n              \\n               int ans1=INT_MAX;\\n               \\n               int j=i+1;   \\n           for( j=i+1;j<n;++j)\\n           {\\n               if(rowzero[j]>=(n-i-1))\\n               {\\n                   ans1=j-i;\\n                   break;\\n               }\\n           }\\n               \\n               if(j==n && ans1==INT_MAX)\\n                   return -1;\\n               \\n                 while(j-1>=i)\\n                 {\\n                     swap(rowzero[j], rowzero[j-1]);\\n                     j--;\\n                 }\\n                 \\n                  ans+=ans1;\\n                }\\n       }\\n      \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```\\n\\nIf you still have any doubt in approach or code, feel free to comment and ask.\\n\\nThank You for reading.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        \\n        vector<int>rowzero(n,0);\\n        \\n        //counting the number of zeroes in each row from right\\n        for(int i=0;i<n;++i)\\n        {   \\n            for(int j=n-1;j>=0;--j)\\n            {\\n                if(grid[i][j]==1)\\n                    break;\\n                else\\n                    rowzero[i]++;\\n                   }\\n        }\\n        \\n        int ans=0;\\n        \\n      // finding the correct and nearest row to swap with  \\n       for(int i=0;i<n;++i)\\n       {\\n           if(rowzero[i]>=(n-i-1))\\n               continue;\\n           else{\\n              \\n               int ans1=INT_MAX;\\n               \\n               int j=i+1;   \\n           for( j=i+1;j<n;++j)\\n           {\\n               if(rowzero[j]>=(n-i-1))\\n               {\\n                   ans1=j-i;\\n                   break;\\n               }\\n           }\\n               \\n               if(j==n && ans1==INT_MAX)\\n                   return -1;\\n               \\n                 while(j-1>=i)\\n                 {\\n                     swap(rowzero[j], rowzero[j-1]);\\n                     j--;\\n                 }\\n                 \\n                  ans+=ans1;\\n                }\\n       }\\n      \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768601,
                "title": "explained-greedy-n-2-prefix-sum-cpp-solution-commented-beats-100",
                "content": "**APPROACH**\\nWe want zeros on upper triange of the matrix so for every row we need to find if there exist a row in required format.Like \\nsay **n=4** the required formats are\\nRow 1  **x000**\\nRow 2  **xx00**\\nRow 3  **xxx0**\\nRow 4  **xxxx**\\n\\n**Here if our answer exist it will be in above format with rows distorted like instead of R1234 it can be R3214 or R1423 so we need to just find the required row position.** Now say at ith row we start seeking the row which fits with ith format and we get that at xth position then we can reach there by swapping every row above x consequently till we reach i that is (x-i) swaps. \\nWe\\'ll do it for every row and count number of swaps. \\nSince there can be multiple rows fitting in a format (like for xxx0 it can be 1010 or 1000) we\\'ll take the one which is nearer because we need to minimize the swaps.\\n..\\n**Wait.... how will you check the format??\\nIts simple use prefix sum from right.\\nLike for R = xx00 if a row satisfies the format then at index 1 sum will be either (0 or 1 if R[1]==1)**\\n\\n**Walk through the Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<vector<int>> v=grid;\\n        int n=grid.size();\\n        if(n==1) return grid[0][0]==1?0:-1;\\n        for(int i=0;i<n;i++){\\n            for(int j=n-2;j>=0;j--){\\n                v[i][j]+=v[i][j+1];                  // Building prefix sum array from right  end\\n            }\\n        }\\n        \\n        int c=0;\\n        for(int i=0;i<n-1;i++){\\n            if(v[i][i]>1 || (grid[i][i]==0 && v[i][i]==1)){             //If row doesn\\'t satisfies the format\\n                int idx=-1;                                               \\n                for(int x=i+1;x<n;x++){                                      // Start searching from below\\n                    if(v[x][i]==0 || (v[x][i]==1 && grid[x][i]==1)){\\n                        idx=x;                                                         //Stop immediately as you get the format\\n                        break;\\n                    }\\n                }\\n                if(idx==-1) return -1;                                    //If we can\\'t find the format return -1\\n                c+=(idx-i);\\n                \\n                v.insert(v.begin()+i,v[idx]);                            //Insert the (idx)th to ith position and remove it from prev position \\n                grid.insert(grid.begin()+i,grid[idx]);\\n                v.erase(v.begin()+idx+1);                               //Do the same insertion and deletion to both original and prefix arrays\\n                grid.erase(grid.begin()+idx+1);\\n                \\n            }\\n        }\\n        return c;\\n        \\n    }\\n};\\n```\\n**STATS**\\n**Runtime: 196 ms, faster than 100.00%** of C++ online submissions for Minimum Swaps to Arrange a Binary Grid.\\n**Memory Usage: 31.2 MB, less than 100.00%** of C++ online submissions for Minimum Swaps to Arrange a Binary Grid.\\nAs on 02/08/2020\\n\\n//Don\\'t know whether v.insert() or v.erase() will cause it to go N^3 please correct me if soln is N^3",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<vector<int>> v=grid;\\n        int n=grid.size();\\n        if(n==1) return grid[0][0]==1?0:-1;\\n        for(int i=0;i<n;i++){\\n            for(int j=n-2;j>=0;j--){\\n                v[i][j]+=v[i][j+1];                  // Building prefix sum array from right  end\\n            }\\n        }\\n        \\n        int c=0;\\n        for(int i=0;i<n-1;i++){\\n            if(v[i][i]>1 || (grid[i][i]==0 && v[i][i]==1)){             //If row doesn\\'t satisfies the format\\n                int idx=-1;                                               \\n                for(int x=i+1;x<n;x++){                                      // Start searching from below\\n                    if(v[x][i]==0 || (v[x][i]==1 && grid[x][i]==1)){\\n                        idx=x;                                                         //Stop immediately as you get the format\\n                        break;\\n                    }\\n                }\\n                if(idx==-1) return -1;                                    //If we can\\'t find the format return -1\\n                c+=(idx-i);\\n                \\n                v.insert(v.begin()+i,v[idx]);                            //Insert the (idx)th to ith position and remove it from prev position \\n                grid.insert(grid.begin()+i,grid[idx]);\\n                v.erase(v.begin()+idx+1);                               //Do the same insertion and deletion to both original and prefix arrays\\n                grid.erase(grid.begin()+idx+1);\\n                \\n            }\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768536,
                "title": "python-clear-straight-detail-explanation",
                "content": "```\\nclass Solution:\\n    def count_trailing_zero(self,array,n):\\n        # takes an array and returns number of trailing zeros in that array\\n\\n        count = 0\\n        # traversing array from end to start \\n        for i in range(n-1,-1,-1):\\n            if array[i] == 0:\\n                count += 1\\n            else:       # break as soon we found a non zero element\\n                break\\n        return count    # return count\\n    \\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        # initialize empty array to store count of trailing zeros at each row\\n        trail_zeros = [0]*n\\n        \\n        # getting trailing zeros for all rows\\n        for i in range(n):\\n            trail_zeros[i] = self.count_trailing_zero( grid[i], n ) \\n            \\n        \\n        swaps = 0\\n        for i in range(n-1):\\n            # target = number of zeros we required at row i, when i = 0 we requires n-1 trailing zeros\\n            target = n-1-i\\n            \\n            # if condition already meet than continue\\n            if target <= trail_zeros[i]:\\n                continue\\n            \\n            # else search for required target in row below current row\\n            found_target = False\\n            for j in range(i+1,n):\\n                if trail_zeros[j] >= target:\\n                    found_target = True\\n                    swaps += (j-i)\\n                    # save j th element in t (target value)\\n                    t = trail_zeros[j]\\n                    # shift right all element by 1 in index range i to j\\n                    trail_zeros[i+1:j+1] = trail_zeros[i:j]\\n                    # replace target value at required position\\n                    trail_zeros[i] = t\\n                    break\\n                \\n            if not found_target:\\n                return -1\\n        return swaps\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def count_trailing_zero(self,array,n):\\n        # takes an array and returns number of trailing zeros in that array\\n\\n        count = 0\\n        # traversing array from end to start \\n        for i in range(n-1,-1,-1):\\n            if array[i] == 0:\\n                count += 1\\n            else:       # break as soon we found a non zero element\\n                break\\n        return count    # return count\\n    \\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        # initialize empty array to store count of trailing zeros at each row\\n        trail_zeros = [0]*n\\n        \\n        # getting trailing zeros for all rows\\n        for i in range(n):\\n            trail_zeros[i] = self.count_trailing_zero( grid[i], n ) \\n            \\n        \\n        swaps = 0\\n        for i in range(n-1):\\n            # target = number of zeros we required at row i, when i = 0 we requires n-1 trailing zeros\\n            target = n-1-i\\n            \\n            # if condition already meet than continue\\n            if target <= trail_zeros[i]:\\n                continue\\n            \\n            # else search for required target in row below current row\\n            found_target = False\\n            for j in range(i+1,n):\\n                if trail_zeros[j] >= target:\\n                    found_target = True\\n                    swaps += (j-i)\\n                    # save j th element in t (target value)\\n                    t = trail_zeros[j]\\n                    # shift right all element by 1 in index range i to j\\n                    trail_zeros[i+1:j+1] = trail_zeros[i:j]\\n                    # replace target value at required position\\n                    trail_zeros[i] = t\\n                    break\\n                \\n            if not found_target:\\n                return -1\\n        return swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768534,
                "title": "python-easy-solution-with-full-explanation-why-sorting",
                "content": "\\n\\t\\n\\tUsing count inversions we can easily solve this problem.\\n\\t.Just by selecting the first most satisfying position of\\n\\trequired value we can create the list by storing it.\\n\\tAnd then easily counting inversions in it.\\n\\t\\n\\tEveryone might have doubt that why sorting?\\n\\tHere is the answer:\\n\\tsuppose the position list to satisfy is:\\n\\t(4*4 matrix)\\n\\t1 0 0 1\\n\\t1 0 0 0\\n\\t1 1 1 0\\n\\t1 1 0 0 \\n\\tposition array is:--     [4,3,1]   (0 based indexing)\\n\\tunrequired row:--    0 so swap req to send it to end = (n-1-miss)=(3-0)=3\\n\\tnow position array should become:---    [2,1,0]\\n\\tand it will require same inversions as required to sort array([4,3,1] )\\n\\t\\n\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n=len(grid);d=[-1]*(n-1)\\n        if(n==1 and grid[0][0]==1):return 0\\n        for i in range(n):\\n            cnt=0\\n            for j in grid[i][::-1]:\\n                if(j==0):cnt+=1\\n                else:break\\n            for j in range(n-2,-1,-1):\\n                if(d[j]==-1 and j+1<=cnt):       #storing all the first most satisfying position\\n                    d[j]=i\\n                    break     \\n        for i in d:\\n            if(i==-1):return -1     #some row remain unsatisfied\\n        miss=(n*(n-1))//2-sum(d)                            #finding the unrequired row\\n        d=d[::-1];\\n\\t\\tinv=n-1-miss                                              #sending the unrequired value to end.\\n        n=len(d)\\n        for i in range(n): \\n            for j in range(i + 1, n): \\n                if (d[i] > d[j]): \\n                    inv += 1                                  #counting all inversions to sort it.\\n        return inv",
                "solutionTags": [],
                "code": "\\n\\t\\n\\tUsing count inversions we can easily solve this problem.\\n\\t.Just by selecting the first most satisfying position of\\n\\trequired value we can create the list by storing it.\\n\\tAnd then easily counting inversions in it.\\n\\t\\n\\tEveryone might have doubt that why sorting?\\n\\tHere is the answer:\\n\\tsuppose the position list to satisfy is:\\n\\t(4*4 matrix)\\n\\t1 0 0 1\\n\\t1 0 0 0\\n\\t1 1 1 0\\n\\t1 1 0 0 \\n\\tposition array is:--     [4,3,1]   (0 based indexing)\\n\\tunrequired row:--    0 so swap req to send it to end = (n-1-miss)=(3-0)=3\\n\\tnow position array should become:---    [2,1,0]\\n\\tand it will require same inversions as required to sort array([4,3,1] )\\n\\t\\n\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n=len(grid);d=[-1]*(n-1)\\n        if(n==1 and grid[0][0]==1):return 0\\n        for i in range(n):\\n            cnt=0\\n            for j in grid[i][::-1]:\\n                if(j==0):cnt+=1\\n                else:break\\n            for j in range(n-2,-1,-1):\\n                if(d[j]==-1 and j+1<=cnt):       #storing all the first most satisfying position\\n                    d[j]=i\\n                    break     \\n        for i in d:\\n            if(i==-1):return -1     #some row remain unsatisfied\\n        miss=(n*(n-1))//2-sum(d)                            #finding the unrequired row\\n        d=d[::-1];\\n\\t\\tinv=n-1-miss                                              #sending the unrequired value to end.\\n        n=len(d)\\n        for i in range(n): \\n            for j in range(i + 1, n): \\n                if (d[i] > d[j]): \\n                    inv += 1                                  #counting all inversions to sort it.\\n        return inv",
                "codeTag": "Java"
            },
            {
                "id": 768422,
                "title": "java-python-detailed-explanation-of-how-to-construct-the-greedy-bubble",
                "content": "**First, let\\'s transfer the problem to a 1d array problem.**\\n\\nFor each row, we can count from the right for consecutive 0s. We record the place of the **first 0** of these consecutive ending zeros. For example, in the first test case\\n```[[0,0,1],[1,1,0],[1,0,0]]```\\nThat\\'s basically a \\n```[3, 2, 1]```\\nAll we need to do is actually sort it to be [1, 2, 3]\\n\\nNote that, we do not need to fully sort the array. Because the requirement is only to make it all zero above diagonal. So for some numbers they don\\'t need to be fully sorted, they only need to be at position\\n```arr[i] >= i+1 ```\\nFor example a matrix of all 0 can have a arr of [3,3,3], which satisfy the requirement.\\n\\n**Now, how to tackle the problem.**\\nYou could read from other answers that what we need to do is to perform a bubble. But how to construct the bubble requires thinking.\\n\\nTo further simplify the arr for understanding, I did another transformation: I changed the number arr[i] to \\n``` right[i] = arr[i] - (i+1)```\\nwhich means the number of steps it needs to go right.\\nSo our test case 1 becomes\\n```[2, 0, -2]```\\nwhich means the first number **must** to go right 2 steps, and the last number **can** go left for 2 steps.\\nIn the end, we need the right[i] array to be all smaller or equal to zero.\\n\\nSo, how to construct the bubble? I will share my step by step thinking here.\\n1) A straight forward thinking is, if we meet with a positive number (means it must go right), we then move it to right, let it bubble up. \\nHowever, this could be wrong, because in the bubbling process, it could be swapping with other positive numbers, and this causes extra swaps.\\n```Think of  [4, 3, 0, 0, -5, -5], when move 4 first and swap with 3``` \\n2) Now, a revised version of bubble could be, we start from right to the left, and move the rightmost positive number first.\\n\\tSadly it turned out this does not work either. You could solve the problem of positive numbers swapping, but cannot solve the problem of negative number swapping. \\n\\t```For example for case [...,5,-1,0,0,-8,...], you cannot decide -1 or -8, which to move first. If there are positive numbers to the left of 5, it might be correct to bubble -8 down, not bubble 5 up ```\\n\\t\\n**The final answer**: We need to take a step back: The right bubbling strategy comes from bubble for **POSITION**, rather than for number. \\nWhen we meet a positive number `right[i]`, it is certain that this position must be switched to another number. And we can find the candidate by going step by step to the right of this position one.\\nIf we can find a `right[j]`, s.t.\\n```|right[j]| > steps between i and j```\\nthen we can definitely bubble the `right[j]` to `right[i]`.\\nNow, since `right[j]` is the FIRST candidate we meet, this can guarantee that moving j to i is using the smallest number of swaps. And since we are securing the position i one by one. All the swaps we have are optimal. This could be an explanation to why the \\'greedy-like\\' bubble choice works.\\nLast, when we cannot find a `right[j]`, definately the position i cannot be filled by anyone properly, we can return -1.\\n\\n**And by this we can construct our bubble strategy**: \\nTo secure the position i from left to right. Each time find the smallest candidate j, which can bubble down to position i. And by our analysis above we know, this approach is optimal.\\n\\nA sample Java Code here:\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] arr = calc(grid);\\n        int[] right = new int[arr.length];//right[i] -> the steps this number needs to go right\\n        for (int i = 0; i < arr.length; i++) {\\n            right[i] = arr[i] - i-1;\\n        }\\n\\t\\t\\n\\t\\t//perform bubble\\n        int count = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (right[i] <= 0) {\\n                continue;\\n            }\\n            //find the next one can fit this position\\n\\t\\t\\t//the toMove is the \\'j\\' in the explanation above\\n            int toMove = i+1;\\n            while(toMove < arr.length) {\\n                if (-right[toMove] >= toMove - i) {\\n                    break;\\n                }\\n                toMove++;\\n            }\\n            if (toMove == arr.length) {\\n                return -1;\\n            }\\n            \\n            //bubble toMove to i\\n            int prev = right[toMove];\\n            for (int j = toMove-1; j >= i; j--) {\\n                right[j+1] = right[j] -1;\\n                count++;\\n            }\\n            right[i] = prev + (toMove - i);\\n        }\\n        return count;\\n        \\n    }\\n    \\n\\t//calculate the position of first 0 in the ending zero sequence\\n    private int[] calc(int[][] grid) {\\n        int[] arr = new int[grid.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            int count = 0;\\n            for (int j = grid[0].length-1; j>=0; j--) {\\n                if (grid[i][j] != 0) {\\n                    break;\\n                }\\n                count++;\\n            }\\n            arr[i] = grid.length - count;\\n        }\\n        return arr;\\n    }\\n}\\n```\\n\\nPython Code:\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        arr = self.calc(grid)\\n        n = len(arr)\\n\\t\\t#right[i] -> the steps this number needs to go right\\n        right = [0 for x in range(n)]\\n        for i in range(n):\\n            right[i] = arr[i] - i - 1\\n        \\n\\t\\t#bubble\\n        count = 0\\n        for i in range(n):\\n            if (right[i] <= 0):\\n                continue\\n            \\n\\t\\t\\t#find the j (toMove)\\n            toMove = i+1\\n            while(toMove < n):\\n                if (-right[toMove] >= toMove - i):\\n                    break\\n                toMove += 1\\n                \\n            if (toMove == n):\\n                return -1\\n            \\n            prev = right[toMove]\\n            for j in range(toMove-1, i-1, -1):\\n                right[j+1] = right[j] - 1\\n                count += 1\\n            right[i] = prev + (toMove - i)\\n            \\n        return count\\n        \\n\\t#calculate the position of first 0 in the ending zero sequence\\n    def calc(self, grid):\\n        arr = [0 for x in range(len(grid))]\\n        for i in range(len(arr)):\\n            count = 0\\n            j = len(grid[0])-1\\n            while(j >= 0):\\n                if (grid[i][j] != 0):\\n                    break\\n                j -= 1\\n                count += 1\\n            arr[i] = len(grid[0]) - count\\n        return arr\\n   \\n```",
                "solutionTags": [],
                "code": "```[[0,0,1],[1,1,0],[1,0,0]]```\n```[3, 2, 1]```\n```arr[i] >= i+1 ```\n``` right[i] = arr[i] - (i+1)```\n```[2, 0, -2]```\n```Think of  [4, 3, 0, 0, -5, -5], when move 4 first and swap with 3```\n```For example for case [...,5,-1,0,0,-8,...], you cannot decide -1 or -8, which to move first. If there are positive numbers to the left of 5, it might be correct to bubble -8 down, not bubble 5 up ```\n```|right[j]| > steps between i and j```\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] arr = calc(grid);\\n        int[] right = new int[arr.length];//right[i] -> the steps this number needs to go right\\n        for (int i = 0; i < arr.length; i++) {\\n            right[i] = arr[i] - i-1;\\n        }\\n\\t\\t\\n\\t\\t//perform bubble\\n        int count = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (right[i] <= 0) {\\n                continue;\\n            }\\n            //find the next one can fit this position\\n\\t\\t\\t//the toMove is the \\'j\\' in the explanation above\\n            int toMove = i+1;\\n            while(toMove < arr.length) {\\n                if (-right[toMove] >= toMove - i) {\\n                    break;\\n                }\\n                toMove++;\\n            }\\n            if (toMove == arr.length) {\\n                return -1;\\n            }\\n            \\n            //bubble toMove to i\\n            int prev = right[toMove];\\n            for (int j = toMove-1; j >= i; j--) {\\n                right[j+1] = right[j] -1;\\n                count++;\\n            }\\n            right[i] = prev + (toMove - i);\\n        }\\n        return count;\\n        \\n    }\\n    \\n\\t//calculate the position of first 0 in the ending zero sequence\\n    private int[] calc(int[][] grid) {\\n        int[] arr = new int[grid.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            int count = 0;\\n            for (int j = grid[0].length-1; j>=0; j--) {\\n                if (grid[i][j] != 0) {\\n                    break;\\n                }\\n                count++;\\n            }\\n            arr[i] = grid.length - count;\\n        }\\n        return arr;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        arr = self.calc(grid)\\n        n = len(arr)\\n\\t\\t#right[i] -> the steps this number needs to go right\\n        right = [0 for x in range(n)]\\n        for i in range(n):\\n            right[i] = arr[i] - i - 1\\n        \\n\\t\\t#bubble\\n        count = 0\\n        for i in range(n):\\n            if (right[i] <= 0):\\n                continue\\n            \\n\\t\\t\\t#find the j (toMove)\\n            toMove = i+1\\n            while(toMove < n):\\n                if (-right[toMove] >= toMove - i):\\n                    break\\n                toMove += 1\\n                \\n            if (toMove == n):\\n                return -1\\n            \\n            prev = right[toMove]\\n            for j in range(toMove-1, i-1, -1):\\n                right[j+1] = right[j] - 1\\n                count += 1\\n            right[i] = prev + (toMove - i)\\n            \\n        return count\\n        \\n\\t#calculate the position of first 0 in the ending zero sequence\\n    def calc(self, grid):\\n        arr = [0 for x in range(len(grid))]\\n        for i in range(len(arr)):\\n            count = 0\\n            j = len(grid[0])-1\\n            while(j >= 0):\\n                if (grid[i][j] != 0):\\n                    break\\n                j -= 1\\n                count += 1\\n            arr[i] = len(grid[0]) - count\\n        return arr\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 768352,
                "title": "converting-matrix-to-array-to-keep-count-last-0-s-in-each-row-greedy",
                "content": "E.g. Grid:\\n011\\n110\\n100\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n\\t\\t\\n\\t\\t//Keeps count of consecutive zeros from end\\n\\t\\t// For given eg. [0,1,2]\\n        int[] zeroCount = new int[n];\\n        int largest = 0;\\n        for(int i=0; i<n;i++){\\n            int count =0;\\n            for(int j=n-1; j>=0;j--){\\n                if(grid[i][j] ==0) count++;\\n                if(grid[i][j] == 1) break;\\n            }\\n            zeroCount[i] = count;\\n            largest = Math.max(largest, count);\\n        }\\n\\t\\t//If there is no row with sufficient 0s to replace first row, return -1\\n        if(largest < n-1) return -1;\\n\\t\\t\\n\\t\\t//To keep track of used values from zeroCount[] arr\\n        int[] isUsed = new int[n];\\n\\t\\t\\n\\t\\t//New order of rows\\n        int[] arr = new int[n];\\n        int ans = 0;\\n        \\n\\t\\t//We are basically trying to sort zeroCount array in descending order\\n\\t\\t//This is more like selection sort\\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t   //Minumum number of trailing 0s required\\n            int reqmt = n - i -1;\\n\\t\\t\\t//This keeps track of how many consecutive rows we need to swap to reach i\\n            int countRows = 0;\\n\\t\\t\\t\\n            for(int j=0; j<n;j++)\\n            {   \\n\\t\\t\\t\\t//FInd the first non-used row to fulfill this condition. - Greedy\\n                if(isUsed[j] == 1) continue;\\n                if(zeroCount[j] >= reqmt)\\n                {\\n                      ans+=countRows; \\n\\t\\t\\t\\t\\t\\tisUsed[j] = 1;\\n                    reqmt = -1;\\n                    arr[i] = zeroCount[j];\\n                    break;\\n                }    \\n                else countRows++;\\n            }\\n\\t\\t\\t//If we don\\'t find any row satisfying reqmt\\n            if(reqmt > -1) return -1;\\n\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n\\t\\t\\n\\t\\t//Keeps count of consecutive zeros from end\\n\\t\\t// For given eg. [0,1,2]\\n        int[] zeroCount = new int[n];\\n        int largest = 0;\\n        for(int i=0; i<n;i++){\\n            int count =0;\\n            for(int j=n-1; j>=0;j--){\\n                if(grid[i][j] ==0) count++;\\n                if(grid[i][j] == 1) break;\\n            }\\n            zeroCount[i] = count;\\n            largest = Math.max(largest, count);\\n        }\\n\\t\\t//If there is no row with sufficient 0s to replace first row, return -1\\n        if(largest < n-1) return -1;\\n\\t\\t\\n\\t\\t//To keep track of used values from zeroCount[] arr\\n        int[] isUsed = new int[n];\\n\\t\\t\\n\\t\\t//New order of rows\\n        int[] arr = new int[n];\\n        int ans = 0;\\n        \\n\\t\\t//We are basically trying to sort zeroCount array in descending order\\n\\t\\t//This is more like selection sort\\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t   //Minumum number of trailing 0s required\\n            int reqmt = n - i -1;\\n\\t\\t\\t//This keeps track of how many consecutive rows we need to swap to reach i\\n            int countRows = 0;\\n\\t\\t\\t\\n            for(int j=0; j<n;j++)\\n            {   \\n\\t\\t\\t\\t//FInd the first non-used row to fulfill this condition. - Greedy\\n                if(isUsed[j] == 1) continue;\\n                if(zeroCount[j] >= reqmt)\\n                {\\n                      ans+=countRows; \\n\\t\\t\\t\\t\\t\\tisUsed[j] = 1;\\n                    reqmt = -1;\\n                    arr[i] = zeroCount[j];\\n                    break;\\n                }    \\n                else countRows++;\\n            }\\n\\t\\t\\t//If we don\\'t find any row satisfying reqmt\\n            if(reqmt > -1) return -1;\\n\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768271,
                "title": "c-o-1-memory-solution-faster-than-100-less-memory-than-100",
                "content": "Just use the first column instead of allocating a vector:\\n\\n```\\n    static int minSwaps(vector<vector<int>>& grid) noexcept {\\n        const int n = static_cast<int>(grid.size());\\n\\n        for (int i = 0; i < n; ++i) {\\n            grid[i][0] = 0; //Use first column as the rowSize vector.\\n            for (int j = n - 1; j >= 1; --j) {\\n                if (grid[i][j] == 1) break;\\n                ++grid[i][0];\\n            }\\n        }\\n        \\n        int steps = 0;\\n        for (int i = 0; i < n - 1; ++i) {\\n            const int expectedSize = n - 1 - i;\\n            for (int j = i; j < n; ++j) {\\n                if (grid[j][0] >= expectedSize) {\\n                    while (j > i) swap(grid[j--][0], grid[j][0]);\\n                    break;\\n                }\\n                ++steps;\\n            }\\n            \\n            if (grid[i][0] < expectedSize) return -1;\\n        }\\n        return steps;\\n    }",
                "solutionTags": [],
                "code": "Just use the first column instead of allocating a vector:\\n\\n```\\n    static int minSwaps(vector<vector<int>>& grid) noexcept {\\n        const int n = static_cast<int>(grid.size());\\n\\n        for (int i = 0; i < n; ++i) {\\n            grid[i][0] = 0; //Use first column as the rowSize vector.\\n            for (int j = n - 1; j >= 1; --j) {\\n                if (grid[i][j] == 1) break;\\n                ++grid[i][0];\\n            }\\n        }\\n        \\n        int steps = 0;\\n        for (int i = 0; i < n - 1; ++i) {\\n            const int expectedSize = n - 1 - i;\\n            for (int j = i; j < n; ++j) {\\n                if (grid[j][0] >= expectedSize) {\\n                    while (j > i) swap(grid[j--][0], grid[j][0]);\\n                    break;\\n                }\\n                ++steps;\\n            }\\n            \\n            if (grid[i][0] < expectedSize) return -1;\\n        }\\n        return steps;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 768204,
                "title": "c-easy-greedy-idea-o-n-2",
                "content": "Let\\'s say we have 4 X 4 matrix,\\nO O X X\\nO O O O\\nO X X X\\nX O O X\\nwe can make an array to present the consecutive `X` count from back to front:  src = `[2, 0, 3, 1]`\\n\\nThen we want the new matrix to be:\\nO X X X\\nO O X X\\nX O O X\\nO O O O\\nwe can convert this to a target array: target `[3, 2, 1]`. And we can come up with a greedy solution, we can iterate the target array( i-th), and try to find the the most close element in src(`j-th`) which is equal or large than the target element, then we insert this element to the  i-th index of src and remove the original one. then we can calculate the steps: `ans += j - i`.\\n\\nfor this example, target is [3,2,1], first element is 3,  we try to find the most closed elemetn in src which is equal or larger than 3, it will be `[2, 0, 3, 1]` ==> `[3, 2, 0 ,1]` and the move step should be `2 - 0 = 0`, we keep doing this steps, unitl we finish all the target element. if we can\\'t find an element which should be equal or larger than the target element, then we return `-1`.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> src;\\n        for(int j = 0; j < grid.size(); ++j) {\\n            auto &v = grid[j];\\n            int cnt = 0;\\n            for(int i = v.size() - 1; i > 0; --i) {\\n                if(v[i] == 0) ++cnt;\\n                else break;\\n            }\\n            src.push_back(cnt);\\n        }\\n        vector<int> t;\\n        int ans = 0;\\n        for(int i = grid.size() - 1; i > 0; --i) t.push_back(i);\\n        for(int i = 0; i < t.size(); ++i) {\\n            int a = t[i];\\n            bool f = false;\\n            for(int j = i; j < src.size(); ++j) {\\n                if(src[j] >= a) {\\n                    src.erase(src.begin() + j);\\n                    src.insert(src.begin() + i, a);\\n                    ans += j - i;\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            if(!f) return -1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> src;\\n        for(int j = 0; j < grid.size(); ++j) {\\n            auto &v = grid[j];\\n            int cnt = 0;\\n            for(int i = v.size() - 1; i > 0; --i) {\\n                if(v[i] == 0) ++cnt;\\n                else break;\\n            }\\n            src.push_back(cnt);\\n        }\\n        vector<int> t;\\n        int ans = 0;\\n        for(int i = grid.size() - 1; i > 0; --i) t.push_back(i);\\n        for(int i = 0; i < t.size(); ++i) {\\n            int a = t[i];\\n            bool f = false;\\n            for(int j = i; j < src.size(); ++j) {\\n                if(src[j] >= a) {\\n                    src.erase(src.begin() + j);\\n                    src.insert(src.begin() + i, a);\\n                    ans += j - i;\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            if(!f) return -1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768151,
                "title": "python3-mimic-bubble-sort",
                "content": "1. Find the number of zeros per row.\\n2. From the first row, find the first row with enough zeros, and swap all the way\\n\\n```Python3\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        zero_count = [0] * n  # the number of zeros per row\\n        for i, row in enumerate(grid):\\n            j = n - 1\\n            while j >= 0 and row[j] == 0:\\n                j -= 1\\n            zero_count[i] = n - 1 - j\\n\\n        res = 0\\n        for i in range(n - 1):\\n            # find the row that has n - i - 1 zero\\n            j = 0\\n            zeros = n - i - 1\\n            while j < len(zero_count) and zero_count[j] < zeros:  # find the first row with enough zeros\\n                j += 1\\n            if j == len(zero_count):\\n                return -1\\n            zero_count.pop(j)\\n            res += j\\n        return res\\n```",
                "solutionTags": [],
                "code": "```Python3\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        zero_count = [0] * n  # the number of zeros per row\\n        for i, row in enumerate(grid):\\n            j = n - 1\\n            while j >= 0 and row[j] == 0:\\n                j -= 1\\n            zero_count[i] = n - 1 - j\\n\\n        res = 0\\n        for i in range(n - 1):\\n            # find the row that has n - i - 1 zero\\n            j = 0\\n            zeros = n - i - 1\\n            while j < len(zero_count) and zero_count[j] < zeros:  # find the first row with enough zeros\\n                j += 1\\n            if j == len(zero_count):\\n                return -1\\n            zero_count.pop(j)\\n            res += j\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768130,
                "title": "java-2ms-greedy-with-comment-both-100",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] cnt = new int[n];     // Counter for trailing 0s\\n        for(int i = 0; i < n; i++)\\n            for(int j = n - 1; j >= 0 && grid[i][j] == 0; j--)\\n                cnt[i] += 1;\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n - 1; i++){\\n            // If current row doesn\\'t have enough 0\\n            if(cnt[i] < n - 1 - i){\\n                // Try to find a row below which has enough 0s with minimum times of swap\\n                for(int j = i + 1; j < n; j++){\\n                    // If find one row with enough 0s\\n                    if(cnt[j] >= n - 1 - i){\\n                        ans += j - i;\\n                        int tmp = cnt[i];\\n                        // swap it to cnt[i]\\n                        cnt[i] = cnt[j];\\n                        // push cnt[i, j - 1] one position forward\\n                        for(int k = j; k > i + 1; k--)\\n                            cnt[k] = cnt[k - 1];\\n                        cnt[i + 1] = tmp;\\n                        break;\\n                    }\\n                    // Can\\'t find a row with enough 0s, return -1\\n                    if(j >= n - 1)\\n                        return -1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] cnt = new int[n];     // Counter for trailing 0s\\n        for(int i = 0; i < n; i++)\\n            for(int j = n - 1; j >= 0 && grid[i][j] == 0; j--)\\n                cnt[i] += 1;\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n - 1; i++){\\n            // If current row doesn\\'t have enough 0\\n            if(cnt[i] < n - 1 - i){\\n                // Try to find a row below which has enough 0s with minimum times of swap\\n                for(int j = i + 1; j < n; j++){\\n                    // If find one row with enough 0s\\n                    if(cnt[j] >= n - 1 - i){\\n                        ans += j - i;\\n                        int tmp = cnt[i];\\n                        // swap it to cnt[i]\\n                        cnt[i] = cnt[j];\\n                        // push cnt[i, j - 1] one position forward\\n                        for(int k = j; k > i + 1; k--)\\n                            cnt[k] = cnt[k - 1];\\n                        cnt[i + 1] = tmp;\\n                        break;\\n                    }\\n                    // Can\\'t find a row with enough 0s, return -1\\n                    if(j >= n - 1)\\n                        return -1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768089,
                "title": "python-using-linked-list-time-100-space-100",
                "content": "- Count the number of straight-up zeros from the right side of each row (`zero_count`), then store each row\\'s `zero_count` to a linked list node.\\n- Call `looking`, a variable that represents the number of `zero_count` needed for the current row (starting from **row length - 1** to **1**). \\n- For each `looking`, we will have to loop through the linked list to find the row with the `zero_count` greater than that.  For each node we traverse, increament `curr_move` which will be the number of moves we need to add to the total `move` if we find *the row*. In case we cannot find it (when reaching the of the linked list), return -1\\n \\nTime: 100%\\nSpace: 100%\\n\\n```python\\nclass LLNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        \\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n,m = len(grid), len(grid[0])\\n        head, curr = None, None\\n        \\n        # Count the number of straight-up zeros from the right side of each row (zero_count)\\n        # Store each row\\'s zero_count to a linked list node \\n        for i in range(n):\\n            zero_count = 0\\n            for j in range(m-1,-1,-1):\\n                if grid[i][j] != 0: break\\n                zero_count += 1    \\n            if not head:\\n                head = LLNode(zero_count)    \\n                curr = head\\n            else:    \\n                curr.next = LLNode(zero_count)\\n                curr = curr.next\\n        \\n        # \"looking\" is the number of zero we are looking for the current row\\n        # Starting at length of row - 1 to 1\\n        move = 0\\n        for looking in range(m-1,0,-1): \\n            # Go through the linked list to find a row with zero count greater than the looking\\n            curr_move = 0\\n            curr = head\\n            prev = None\\n            while curr and curr.val < looking:\\n                prev = curr\\n                curr = curr.next\\n                curr_move += 1\\n                \\n            # - If cannot find any node with the value greater than looking, then return -1 \\n            if not curr: return -1    \\n            \\n            # - If we find it:\\n            # -- Add the number of moves\\n            move += curr_move \\n            # -- Remove it out of the linked list\\n            if prev:\\n                prev.next = curr.next\\n            else:    \\n                head = head.next\\n            \\n        return move    \\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass LLNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        \\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n,m = len(grid), len(grid[0])\\n        head, curr = None, None\\n        \\n        # Count the number of straight-up zeros from the right side of each row (zero_count)\\n        # Store each row\\'s zero_count to a linked list node \\n        for i in range(n):\\n            zero_count = 0\\n            for j in range(m-1,-1,-1):\\n                if grid[i][j] != 0: break\\n                zero_count += 1    \\n            if not head:\\n                head = LLNode(zero_count)    \\n                curr = head\\n            else:    \\n                curr.next = LLNode(zero_count)\\n                curr = curr.next\\n        \\n        # \"looking\" is the number of zero we are looking for the current row\\n        # Starting at length of row - 1 to 1\\n        move = 0\\n        for looking in range(m-1,0,-1): \\n            # Go through the linked list to find a row with zero count greater than the looking\\n            curr_move = 0\\n            curr = head\\n            prev = None\\n            while curr and curr.val < looking:\\n                prev = curr\\n                curr = curr.next\\n                curr_move += 1\\n                \\n            # - If cannot find any node with the value greater than looking, then return -1 \\n            if not curr: return -1    \\n            \\n            # - If we find it:\\n            # -- Add the number of moves\\n            move += curr_move \\n            # -- Remove it out of the linked list\\n            if prev:\\n                prev.next = curr.next\\n            else:    \\n                head = head.next\\n            \\n        return move    \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 768055,
                "title": "c-greedy",
                "content": "```\\n// 0 1 2\\n// 2 1 0\\n// 1 0 2\\n// \\nclass Solution {\\npublic:\\nint minSwaps(vector<vector<int>>& grid)\\n{\\n\\tvector<int> cnt(grid.size());\\n\\tfor (int i = 0; i < grid.size(); i++)\\n\\t{\\n\\t\\tfor (int j = grid.size() - 1; j >= 0; j--)\\n\\t\\t{\\n\\t\\t\\tif (grid[i][j] == 0)\\n\\t\\t\\t\\tcnt[i]++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tint res = 0;\\n\\tint i = 0;\\n\\twhile(i < cnt.size())\\n\\t{\\n\\t\\tif (cnt[i] < grid.size() - 1 - i)\\n\\t\\t{\\n\\t\\t\\tint j = i;\\n\\t\\t\\twhile (j < grid.size() && cnt[j] < grid.size() - 1 - i) ++j;\\n\\t\\t\\tres += j - i;\\n            \\n            if(j == grid.size())\\n                return -1;\\n            \\n\\t\\t\\twhile (j > i)\\n            {\\n                swap(cnt[j], cnt[j - 1]);\\n                --j;\\n            }\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\t++i;\\n\\t}\\n\\n\\treturn res;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// 0 1 2\\n// 2 1 0\\n// 1 0 2\\n// \\nclass Solution {\\npublic:\\nint minSwaps(vector<vector<int>>& grid)\\n{\\n\\tvector<int> cnt(grid.size());\\n\\tfor (int i = 0; i < grid.size(); i++)\\n\\t{\\n\\t\\tfor (int j = grid.size() - 1; j >= 0; j--)\\n\\t\\t{\\n\\t\\t\\tif (grid[i][j] == 0)\\n\\t\\t\\t\\tcnt[i]++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tint res = 0;\\n\\tint i = 0;\\n\\twhile(i < cnt.size())\\n\\t{\\n\\t\\tif (cnt[i] < grid.size() - 1 - i)\\n\\t\\t{\\n\\t\\t\\tint j = i;\\n\\t\\t\\twhile (j < grid.size() && cnt[j] < grid.size() - 1 - i) ++j;\\n\\t\\t\\tres += j - i;\\n            \\n            if(j == grid.size())\\n                return -1;\\n            \\n\\t\\t\\twhile (j > i)\\n            {\\n                swap(cnt[j], cnt[j - 1]);\\n                --j;\\n            }\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\t++i;\\n\\t}\\n\\n\\treturn res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768049,
                "title": "clean-python",
                "content": "```\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        swaps = 0\\n        zeroesNeeded = len(grid)-1 \\n        start = 1\\n        \\n        for i in range(len(grid)):\\n            temp = i\\n            while temp < len(grid) and grid[temp][start:] != [0]*zeroesNeeded:\\n                temp += 1\\n                \\n            if temp >= len(grid):\\n                return -1\\n            \\n            start += 1\\n            zeroesNeeded -= 1\\n            \\n            while temp > i:\\n                grid[temp], grid[temp-1] = grid[temp-1], grid[temp]\\n                temp -= 1\\n                swaps += 1\\n                \\n        return swaps\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        swaps = 0\\n        zeroesNeeded = len(grid)-1 \\n        start = 1\\n        \\n        for i in range(len(grid)):\\n            temp = i\\n            while temp < len(grid) and grid[temp][start:] != [0]*zeroesNeeded:\\n                temp += 1\\n                \\n            if temp >= len(grid):\\n                return -1\\n            \\n            start += 1\\n            zeroesNeeded -= 1\\n            \\n            while temp > i:\\n                grid[temp], grid[temp-1] = grid[temp-1], grid[temp]\\n                temp -= 1\\n                swaps += 1\\n                \\n        return swaps\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 768013,
                "title": "c-simple-and-greedy-solution",
                "content": "```\\n\\tvoid countSwaps(vector<int>& v, int p, int q)\\n    {\\n        if(p==q)\\n            return;\\n        for(int i=q-1; i>=p; i--)\\n            swap(v[i], v[i+1]);\\n        return;\\n    }\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = 0;\\n        vector<int> v;\\n        for(int i=0; i<n; i++)\\n        {\\n            int count = 0;\\n            for(int j=grid[i].size()-1; j>=0; j--)\\n            {\\n                if(grid[i][j]==0)\\n                    count++;\\n                else\\n                    break;\\n            }\\n            v.push_back(count);\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            bool flag = false;\\n            for(int j=i; j<n; j++)\\n            {\\n                if(v[j] >= n-1-i)\\n                {\\n                    flag = true;\\n                    countSwaps(v, i, j);\\n                    ans += (j-i);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n                return -1;\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tvoid countSwaps(vector<int>& v, int p, int q)\\n    {\\n        if(p==q)\\n            return;\\n        for(int i=q-1; i>=p; i--)\\n            swap(v[i], v[i+1]);\\n        return;\\n    }\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = 0;\\n        vector<int> v;\\n        for(int i=0; i<n; i++)\\n        {\\n            int count = 0;\\n            for(int j=grid[i].size()-1; j>=0; j--)\\n            {\\n                if(grid[i][j]==0)\\n                    count++;\\n                else\\n                    break;\\n            }\\n            v.push_back(count);\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            bool flag = false;\\n            for(int j=i; j<n; j++)\\n            {\\n                if(v[j] >= n-1-i)\\n                {\\n                    flag = true;\\n                    countSwaps(v, i, j);\\n                    ans += (j-i);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n                return -1;\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 768008,
                "title": "java-simple-clean-code-with-explanation",
                "content": "Key Point:\\nEverytime, which row do we want most?\\n\\nAfter drawing several pictures, we can find that, in the final valid state, the first row, can only have one 1 in the first column position, the second row, can only have two 1 in the first two columns.....\\n\\nIn a word, for row i, its last 1 must be in column i or before. Thus, we can first record every row\\'s last 1\\'s position, then choose valid row from top to bottom (last second row).\\n\\n**lastOne:** store every row\\'s last 1\\'s position. Here we use a list for convenience.\\n\\nAnd, then choose the valid row by using minimum steps.\\n\\n\\n**If you find this helpful, please upvote, thanks!**\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int row = grid.length, col = grid[0].length;\\n        List<Integer> lastOne = new ArrayList<>(row + 1);\\n        for (int i = 0; i < row; i++) {\\n            lastOne.add(i, -1);\\n            for (int j = col - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    lastOne.set(i, j);\\n                    break;\\n                }\\n            }\\n        }\\n        int step = 0;\\n        for (int i = 0; i < row - 1; i++) {\\n            if (lastOne.get(i) <= i) {\\n                continue;\\n            }\\n            boolean flag = false;\\n            for (int j = i + 1; j < row; j++) {\\n                if (lastOne.get(j) <= i) {\\n                    flag = true;\\n                    step += j - i;\\n                    int curFind = lastOne.get(j);\\n                    lastOne.remove(j);\\n                    lastOne.add(i, curFind);\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// if there is no valid row left, return -1 directly\\n            if (!flag) {\\n                return -1;\\n            }\\n        }\\n        return step;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int row = grid.length, col = grid[0].length;\\n        List<Integer> lastOne = new ArrayList<>(row + 1);\\n        for (int i = 0; i < row; i++) {\\n            lastOne.add(i, -1);\\n            for (int j = col - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    lastOne.set(i, j);\\n                    break;\\n                }\\n            }\\n        }\\n        int step = 0;\\n        for (int i = 0; i < row - 1; i++) {\\n            if (lastOne.get(i) <= i) {\\n                continue;\\n            }\\n            boolean flag = false;\\n            for (int j = i + 1; j < row; j++) {\\n                if (lastOne.get(j) <= i) {\\n                    flag = true;\\n                    step += j - i;\\n                    int curFind = lastOne.get(j);\\n                    lastOne.remove(j);\\n                    lastOne.add(i, curFind);\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// if there is no valid row left, return -1 directly\\n            if (!flag) {\\n                return -1;\\n            }\\n        }\\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767981,
                "title": "python-best-soln-with-code",
                "content": "BRUTEFORCE\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        ans=0\\n        n=len(grid)\\n        for i in range(n-1):\\n            flag=0\\n            for j in range(i,n):\\n                f=1\\n                for k in range(i+1,n):\\n                    if grid[j][k]==1:\\n                        f=0\\n                        break\\n                if f==1:\\n                    flag=1\\n                    for k in range(j,i,-1):\\n                        grid[k],grid[k-1]=grid[k-1],grid[k]\\n                    break\\n            \\n            ans+=j-i\\n            if flag==0:\\n                return -1\\n            \\n        return ans\\n                \\n            \\n        \\n                \\n            ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        ans=0\\n        n=len(grid)\\n        for i in range(n-1):\\n            flag=0\\n            for j in range(i,n):\\n                f=1\\n                for k in range(i+1,n):\\n                    if grid[j][k]==1:\\n                        f=0\\n                        break\\n                if f==1:\\n                    flag=1\\n                    for k in range(j,i,-1):\\n                        grid[k],grid[k-1]=grid[k-1],grid[k]\\n                    break\\n            \\n            ans+=j-i\\n            if flag==0:\\n                return -1\\n            \\n        return ans\\n                \\n            \\n        \\n                \\n            ```",
                "codeTag": "Java"
            },
            {
                "id": 767943,
                "title": "java-reduce-to-1d-greedy-o-n-2",
                "content": "```\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] zeros = new int[n];\\n        for(int i=0; i<n; i++){\\n            for(int j=n-1; j>=0; j--){\\n                if(grid[i][j]!=0){\\n                    break;\\n                }\\n                zeros[i]++;\\n            }\\n        }\\n        boolean[] checked = new boolean[n];\\n        int res = 0;\\n        for(int i=0; i<n; i++){\\n            int req = n-i-1;\\n            int count = 0;\\n            boolean isFeasible = false;\\n            for(int j=0; j<n; j++){\\n                if(checked[j]){\\n                    continue;\\n                }\\n                \\n                if(zeros[j]<req){\\n                    count++;\\n                }\\n                else{\\n                    isFeasible = true;\\n                    checked[j] = true;\\n                    break;\\n                }\\n            }\\n            if(!isFeasible){\\n                return -1;\\n            }\\n            res += count;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] zeros = new int[n];\\n        for(int i=0; i<n; i++){\\n            for(int j=n-1; j>=0; j--){\\n                if(grid[i][j]!=0){\\n                    break;\\n                }\\n                zeros[i]++;\\n            }\\n        }\\n        boolean[] checked = new boolean[n];\\n        int res = 0;\\n        for(int i=0; i<n; i++){\\n            int req = n-i-1;\\n            int count = 0;\\n            boolean isFeasible = false;\\n            for(int j=0; j<n; j++){\\n                if(checked[j]){\\n                    continue;\\n                }\\n                \\n                if(zeros[j]<req){\\n                    count++;\\n                }\\n                else{\\n                    isFeasible = true;\\n                    checked[j] = true;\\n                    break;\\n                }\\n            }\\n            if(!isFeasible){\\n                return -1;\\n            }\\n            res += count;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990227,
                "title": "java-count-swaps-clean",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] arr = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = n-1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    break;\\n                }\\n                arr[i]++;\\n            }\\n        }\\n\\n        int swaps = 0;\\n        int i = 0;\\n        for (int search = n-1; search >= 0; search--) {\\n            int j = i;\\n            while (arr[j] < search) {\\n                j++;\\n                if (j == n) {\\n                    return -1;\\n                }\\n            }\\n            while (j > i) {\\n                int tmp = arr[j];\\n                arr[j] = arr[j-1];\\n                arr[j-1] = tmp;\\n                swaps++;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return swaps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] arr = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = n-1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    break;\\n                }\\n                arr[i]++;\\n            }\\n        }\\n\\n        int swaps = 0;\\n        int i = 0;\\n        for (int search = n-1; search >= 0; search--) {\\n            int j = i;\\n            while (arr[j] < search) {\\n                j++;\\n                if (j == n) {\\n                    return -1;\\n                }\\n            }\\n            while (j > i) {\\n                int tmp = arr[j];\\n                arr[j] = arr[j-1];\\n                arr[j-1] = tmp;\\n                swaps++;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return swaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953404,
                "title": "best-short-solution-to-the-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n       \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> maxRight(n,-1);\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    maxRight[i]=j;\\n                    \\n                }\\n            }\\n           \\n        }\\n        vector<int> s=maxRight;\\n        sort(s.begin(),s.end());\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<s[i])return -1;\\n            \\n        }\\n        \\n\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(maxRight[i]<=i){i++;continue;}\\n           \\n            int j;\\n            for(j=i+1;j<n;j++)\\n            {\\n                if(maxRight[j]<=i)\\n                {\\n                    break;\\n                }\\n            }\\n           \\n            while(j>i)\\n            {\\n                swap(maxRight[j-1],maxRight[j]);\\n                j--;\\n               count++;\\n           }\\n        \\n         i++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n       \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> maxRight(n,-1);\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    maxRight[i]=j;\\n                    \\n                }\\n            }\\n           \\n        }\\n        vector<int> s=maxRight;\\n        sort(s.begin(),s.end());\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<s[i])return -1;\\n            \\n        }\\n        \\n\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(maxRight[i]<=i){i++;continue;}\\n           \\n            int j;\\n            for(j=i+1;j<n;j++)\\n            {\\n                if(maxRight[j]<=i)\\n                {\\n                    break;\\n                }\\n            }\\n           \\n            while(j>i)\\n            {\\n                swap(maxRight[j-1],maxRight[j]);\\n                j--;\\n               count++;\\n           }\\n        \\n         i++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902946,
                "title": "easy-to-understand-javascript-solution-bubble-sort",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar minSwaps = function(grid) {\\n    const zeros = [];\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    let result = 0;\\n\\n    for (let row = 0; row < m; row++) {\\n        let count = 0;\\n        for (let col = n - 1; col >= 0; col--) {\\n            const value = grid[row][col];\\n\\n            if (value) break;\\n            count += 1;\\n        }\\n        zeros.push(count);\\n    }\\n    for (let row = 0; row < m; row++) {\\n        const target = m - row - 1;\\n        let swapRow = row;\\n\\n        while (swapRow < m && zeros[swapRow] < target) swapRow += 1;\\n        if (swapRow === m) return -1;\\n\\n        for (let index = swapRow; index > row; index--) {\\n            [zeros[index], zeros[index - 1]] = [zeros[index - 1], zeros[index]];\\n            result += 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSwaps = function(grid) {\\n    const zeros = [];\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    let result = 0;\\n\\n    for (let row = 0; row < m; row++) {\\n        let count = 0;\\n        for (let col = n - 1; col >= 0; col--) {\\n            const value = grid[row][col];\\n\\n            if (value) break;\\n            count += 1;\\n        }\\n        zeros.push(count);\\n    }\\n    for (let row = 0; row < m; row++) {\\n        const target = m - row - 1;\\n        let swapRow = row;\\n\\n        while (swapRow < m && zeros[swapRow] < target) swapRow += 1;\\n        if (swapRow === m) return -1;\\n\\n        for (let index = swapRow; index > row; index--) {\\n            [zeros[index], zeros[index - 1]] = [zeros[index - 1], zeros[index]];\\n            result += 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593626,
                "title": "javascript-1536-minimum-swaps-to-arrange-a-binary-grid",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nconst minSwaps = function (g) {\\n  const m = g.length\\n  const n = g[0].length\\n\\n  function swapRows(r1,r2) {\\n    for (let C = 0; C < n; C++)\\n      [g[r1][C],g[r2][C]] = [g[r2][C],g[r1][C]]\\n  }\\n\\n  function rowWithEnoughZerosAfterMainDiagonal(R2) {\\n    const zNeeded = n - (R2 + 1)\\n    for (let R = R2; R < m; R++) {\\n      const zc = g[R].slice(R2 + 1)\\n        .join(\\'\\')\\n        .replaceAll(\\'1\\',\\'\\')\\n      if (zc.length >= zNeeded)\\n        return R\\n    }\\n    return -1\\n  }\\n\\n  let cc = 0\\n  for (let R = 0; R < m; R++) {\\n    const rNeededToSwapTo = rowWithEnoughZerosAfterMainDiagonal(R)\\n    if (rNeededToSwapTo === -1)\\n      return -1\\n    if (R !== rNeededToSwapTo)\\n      for (let R2 = rNeededToSwapTo; R2 > R; R2--) {\\n        swapRows(R2,R2 - 1)\\n        cc += 1\\n      }\\n  }\\n  return cc\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst minSwaps = function (g) {\\n  const m = g.length\\n  const n = g[0].length\\n\\n  function swapRows(r1,r2) {\\n    for (let C = 0; C < n; C++)\\n      [g[r1][C],g[r2][C]] = [g[r2][C],g[r1][C]]\\n  }\\n\\n  function rowWithEnoughZerosAfterMainDiagonal(R2) {\\n    const zNeeded = n - (R2 + 1)\\n    for (let R = R2; R < m; R++) {\\n      const zc = g[R].slice(R2 + 1)\\n        .join(\\'\\')\\n        .replaceAll(\\'1\\',\\'\\')\\n      if (zc.length >= zNeeded)\\n        return R\\n    }\\n    return -1\\n  }\\n\\n  let cc = 0\\n  for (let R = 0; R < m; R++) {\\n    const rNeededToSwapTo = rowWithEnoughZerosAfterMainDiagonal(R)\\n    if (rNeededToSwapTo === -1)\\n      return -1\\n    if (R !== rNeededToSwapTo)\\n      for (let R2 = rNeededToSwapTo; R2 > R; R2--) {\\n        swapRows(R2,R2 - 1)\\n        cc += 1\\n      }\\n  }\\n  return cc\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584818,
                "title": "easy-to-understand-python-solution-with-comments",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n^2)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n\\n        # Time  : O(n^2)\\n        # Space : O(n)\\n\\n        n = len(grid)\\n        zeroesArr = []\\n\\n        # Calculate trailing zeroes for each row \\n        for i in range(n):\\n            trailingZeroes = 0\\n            for j in range(n-1, -1, -1):\\n                if grid[i][j] == 1:\\n                    break\\n                trailingZeroes += 1\\n            zeroesArr.append(trailingZeroes)\\n\\n        # Min number of trailing zeroes expected in 1st row\\n        minZeroesExpected = n - 1\\n        res = 0\\n\\n        for i in range(n):\\n            currMax = -1\\n            currMaxIndex = -1\\n\\n            # Find closest row with trailing zeroes >= minZeroesExpected\\n            for j in range(i, n):\\n                if zeroesArr[j] >= minZeroesExpected:\\n                    currMax = zeroesArr[j]\\n                    currMaxIndex = j\\n                    break\\n\\n            # We couldn\\'t find any row with minZeroesExpected\\n            if currMax < minZeroesExpected:\\n                return - 1\\n            \\n            # Simulate stable swapping of rows \\n            # Stability in sorting means preserving the relative order between keys with same values\\n            # we need to maintain relative order of rows since we can only swap two adjacent rows.\\n            # Bubble Sort is preferred as it\\'s a stable sorting algorithm\\n            while currMaxIndex > i:\\n                temp = zeroesArr[currMaxIndex]\\n                zeroesArr[currMaxIndex] = zeroesArr[currMaxIndex - 1]\\n                zeroesArr[currMaxIndex - 1] = temp\\n                res += 1\\n                currMaxIndex -= 1\\n\\n            # Decrease minZeroesExpected for next row by 1\\n            minZeroesExpected -= 1\\n\\n        return res\\n\\n\\n             \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n\\n        # Time  : O(n^2)\\n        # Space : O(n)\\n\\n        n = len(grid)\\n        zeroesArr = []\\n\\n        # Calculate trailing zeroes for each row \\n        for i in range(n):\\n            trailingZeroes = 0\\n            for j in range(n-1, -1, -1):\\n                if grid[i][j] == 1:\\n                    break\\n                trailingZeroes += 1\\n            zeroesArr.append(trailingZeroes)\\n\\n        # Min number of trailing zeroes expected in 1st row\\n        minZeroesExpected = n - 1\\n        res = 0\\n\\n        for i in range(n):\\n            currMax = -1\\n            currMaxIndex = -1\\n\\n            # Find closest row with trailing zeroes >= minZeroesExpected\\n            for j in range(i, n):\\n                if zeroesArr[j] >= minZeroesExpected:\\n                    currMax = zeroesArr[j]\\n                    currMaxIndex = j\\n                    break\\n\\n            # We couldn\\'t find any row with minZeroesExpected\\n            if currMax < minZeroesExpected:\\n                return - 1\\n            \\n            # Simulate stable swapping of rows \\n            # Stability in sorting means preserving the relative order between keys with same values\\n            # we need to maintain relative order of rows since we can only swap two adjacent rows.\\n            # Bubble Sort is preferred as it\\'s a stable sorting algorithm\\n            while currMaxIndex > i:\\n                temp = zeroesArr[currMaxIndex]\\n                zeroesArr[currMaxIndex] = zeroesArr[currMaxIndex - 1]\\n                zeroesArr[currMaxIndex - 1] = temp\\n                res += 1\\n                currMaxIndex -= 1\\n\\n            # Decrease minZeroesExpected for next row by 1\\n            minZeroesExpected -= 1\\n\\n        return res\\n\\n\\n             \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193676,
                "title": "naive-solution",
                "content": "# Approach\\nIf we look from top row to bottom we can see that every valid row has at leat n-1-i zeroes on the left (n - len of grid, i - row number). We make a slice couting zeroes (e.g. [0,1,2]). Now we can just \"bubble sort\" it from the top. For example, for upper level we need to move last row up and it will take 2 swaps ([0,1,2] -> [2,1,0]). We just count those swaps.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n\\n# Code\\n```\\nfunc minSwaps(grid [][]int) int {\\n    zero := make([]int, len(grid))\\n    for j, row := range grid {\\n        zeros := 0\\n        for i:=len(row)-1; i>=0; i-- {\\n            if row[i] == 0 {\\n                zeros++\\n                continue\\n            }\\n            break\\n        }\\n        zero[j] = zeros\\n    }\\n    swaps := 0\\n    for i:=0; i<len(grid); i++{\\n        num := len(grid)-1-i\\n        rowNum := -1\\n        for j:=i; j<len(grid); j++ {\\n            if zero[j]>=num {\\n                rowNum = j\\n                break\\n            }\\n        }\\n        if rowNum == -1 {\\n            return -1\\n        }\\n        swaps += rowNum-i\\n        if rowNum>i {\\n            // rearranging slice, j-row to i-place\\n            tempz := []int{}\\n            tempz = append(tempz, zero[:i]...)\\n            tempz = append(tempz, zero[rowNum])\\n            tempz = append(tempz, zero[i:rowNum]...)\\n            tempz = append(tempz, zero[rowNum+1:]...)\\n            zero = tempz\\n        }\\n    }\\n    return swaps\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minSwaps(grid [][]int) int {\\n    zero := make([]int, len(grid))\\n    for j, row := range grid {\\n        zeros := 0\\n        for i:=len(row)-1; i>=0; i-- {\\n            if row[i] == 0 {\\n                zeros++\\n                continue\\n            }\\n            break\\n        }\\n        zero[j] = zeros\\n    }\\n    swaps := 0\\n    for i:=0; i<len(grid); i++{\\n        num := len(grid)-1-i\\n        rowNum := -1\\n        for j:=i; j<len(grid); j++ {\\n            if zero[j]>=num {\\n                rowNum = j\\n                break\\n            }\\n        }\\n        if rowNum == -1 {\\n            return -1\\n        }\\n        swaps += rowNum-i\\n        if rowNum>i {\\n            // rearranging slice, j-row to i-place\\n            tempz := []int{}\\n            tempz = append(tempz, zero[:i]...)\\n            tempz = append(tempz, zero[rowNum])\\n            tempz = append(tempz, zero[i:rowNum]...)\\n            tempz = append(tempz, zero[rowNum+1:]...)\\n            zero = tempz\\n        }\\n    }\\n    return swaps\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3167441,
                "title": "python-greedy-solution-92-faster",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        arr = []\\n        for row in grid:\\n            total = 0\\n            for i in range(len(row)-1,-1,-1):\\n                if row[i] == 1: break\\n                total += 1\\n            \\n            arr.append(total)\\n\\n        left = []\\n        res = 0\\n\\n        for i in range(len(grid)-1):\\n            target = len(grid)-1-i\\n            index = float(\"inf\")\\n            temp = []\\n            \\n            for j in range(len(arr)):\\n                if arr[j] >= target:\\n                    index = j\\n                    break\\n            \\n            if index == float(\"inf\"):return -1\\n\\n            for j in range(len(arr)):\\n                if j != index:\\n                    temp.append(arr[j])\\n            \\n            left.append(arr[index])\\n            arr = temp\\n            res += index\\n        \\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        arr = []\\n        for row in grid:\\n            total = 0\\n            for i in range(len(row)-1,-1,-1):\\n                if row[i] == 1: break\\n                total += 1\\n            \\n            arr.append(total)\\n\\n        left = []\\n        res = 0\\n\\n        for i in range(len(grid)-1):\\n            target = len(grid)-1-i\\n            index = float(\"inf\")\\n            temp = []\\n            \\n            for j in range(len(arr)):\\n                if arr[j] >= target:\\n                    index = j\\n                    break\\n            \\n            if index == float(\"inf\"):return -1\\n\\n            for j in range(len(arr)):\\n                if j != index:\\n                    temp.append(arr[j])\\n            \\n            left.append(arr[index])\\n            arr = temp\\n            res += index\\n        \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167180,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_swaps(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut zeros = vec![0; grid.len()];\\n        for (i, row) in grid.iter().enumerate() {\\n            zeros[i] = row.iter().rev().take_while(|&&x| x == 0).count() as i32;\\n        }\\n        let mut swaps = 0;\\n        for i in 0..zeros.len() {\\n            if zeros[i] < (zeros.len() - i - 1) as i32 {\\n                let mut j = i + 1;\\n                while j < zeros.len() && zeros[j] < (zeros.len() - i - 1) as i32 {\\n                    j += 1;\\n                }\\n                if j == zeros.len() {\\n                    return -1;\\n                }\\n                while j > i {\\n                    zeros.swap(j, j - 1);\\n                    swaps += 1;\\n                    j -= 1;\\n                }\\n            }\\n        }\\n        swaps\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_swaps(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut zeros = vec![0; grid.len()];\\n        for (i, row) in grid.iter().enumerate() {\\n            zeros[i] = row.iter().rev().take_while(|&&x| x == 0).count() as i32;\\n        }\\n        let mut swaps = 0;\\n        for i in 0..zeros.len() {\\n            if zeros[i] < (zeros.len() - i - 1) as i32 {\\n                let mut j = i + 1;\\n                while j < zeros.len() && zeros[j] < (zeros.len() - i - 1) as i32 {\\n                    j += 1;\\n                }\\n                if j == zeros.len() {\\n                    return -1;\\n                }\\n                while j > i {\\n                    zeros.swap(j, j - 1);\\n                    swaps += 1;\\n                    j -= 1;\\n                }\\n            }\\n        }\\n        swaps\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3013309,
                "title": "python-10-line-solution-time-o-n-2",
                "content": "```\\ndef minSwaps(self, grid: List[List[int]]) -> int:\\n\\tm, n, ans = len(grid), len(grid[0]), 0\\n\\tnums = [max([i for i in range(m) if r[i]==1] or [0]) for r in grid]\\n\\tif any(i<x for i, x in enumerate(sorted(nums))):\\n\\t\\treturn -1\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i]>i:\\n\\t\\t\\tj = min(k for k in range(i+1, n) if nums[k]<=i)\\n\\t\\t\\tnums[i:j+1] = [nums[j]]+nums[i:j]\\n\\t\\t\\tans += j-i\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef minSwaps(self, grid: List[List[int]]) -> int:\\n\\tm, n, ans = len(grid), len(grid[0]), 0\\n\\tnums = [max([i for i in range(m) if r[i]==1] or [0]) for r in grid]\\n\\tif any(i<x for i, x in enumerate(sorted(nums))):\\n\\t\\treturn -1\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i]>i:\\n\\t\\t\\tj = min(k for k in range(i+1, n) if nums[k]<=i)\\n\\t\\t\\tnums[i:j+1] = [nums[j]]+nums[i:j]\\n\\t\\t\\tans += j-i\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2933324,
                "title": "sorting-c-easy-solution-95",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n       \\n        vector<int> vec;  //find order of zero:\\n        for(int i=0;i<grid.size();i++){\\n            int counter=0;\\n            for(int j=grid[0].size()-1;j>=0;j--){\\n               if(grid[i][j]==0){\\n                   counter++;\\n               }\\n               else if(grid[i][j]==1){\\n                   break;\\n               }\\n            }\\n            vec.push_back(counter);\\n        }\\n \\n        int ans=0;\\n        for(int i=0;i<n;i++){    \\n            int curr = i;\\n            int req = n - 1 - i; \\n            while(curr < n and vec[curr] < req){\\n                 curr++;\\n            }\\n            if(curr == n) return -1;\\n            ans+=curr - i;\\n            while(curr > 0){\\n                vec[curr] = vec[curr - 1];\\n                curr--;\\n            }\\n        }\\n        return ans;\\n       \\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n          \\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n       \\n        vector<int> vec;  //find order of zero:\\n        for(int i=0;i<grid.size();i++){\\n            int counter=0;\\n            for(int j=grid[0].size()-1;j>=0;j--){\\n               if(grid[i][j]==0){\\n                   counter++;\\n               }\\n               else if(grid[i][j]==1){\\n                   break;\\n               }\\n            }\\n            vec.push_back(counter);\\n        }\\n \\n        int ans=0;\\n        for(int i=0;i<n;i++){    \\n            int curr = i;\\n            int req = n - 1 - i; \\n            while(curr < n and vec[curr] < req){\\n                 curr++;\\n            }\\n            if(curr == n) return -1;\\n            ans+=curr - i;\\n            while(curr > 0){\\n                vec[curr] = vec[curr - 1];\\n                curr--;\\n            }\\n        }\\n        return ans;\\n       \\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918203,
                "title": "just-do-bubble-sort-and-count-number-of-swap-to-sort-the-array",
                "content": "Solution from Hint: \\n        \\n        n = len(grid)\\n        a = [0]*n\\n        res = 0\\n        \\n        for i in range(n):\\n            for j in range(n-1,-1,-1):\\n                if grid[i][j]:\\n                    a[i] = j\\n                    break \\n        \\n        b = a.copy()\\n        b.sort()\\n        for i in range(len(b)):\\n            if b[i]>i:  \\n                return -1 \\n            \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if a[i]>i:\\n                    a[i],a[j] = a[j],a[i]\\n                    res+=1   \\n\\n        return res",
                "solutionTags": [],
                "code": "Solution from Hint: \\n        \\n        n = len(grid)\\n        a = [0]*n\\n        res = 0\\n        \\n        for i in range(n):\\n            for j in range(n-1,-1,-1):\\n                if grid[i][j]:\\n                    a[i] = j\\n                    break \\n        \\n        b = a.copy()\\n        b.sort()\\n        for i in range(len(b)):\\n            if b[i]>i:  \\n                return -1 \\n            \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if a[i]>i:\\n                    a[i],a[j] = a[j],a[i]\\n                    res+=1   \\n\\n        return res",
                "codeTag": "Unknown"
            },
            {
                "id": 2880627,
                "title": "python3-easy-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int: \\n        n = len(grid)\\n        # count trailing zeros \\n        count = []\\n        for i in range(n):\\n            cnt = 0 \\n            for j in range(n -1 , -1 , -1 ):\\n                if grid[i][j] != 0 : \\n                    break \\n                cnt += 1\\n            count.append(cnt)\\n        # Perforn Swapping \\n        req = n - 1 \\n        ans = 0 \\n        for i in range(n):\\n            check = False \\n            for j in range(i, n):\\n                if count[j] >= req:\\n                    while j !=  i : \\n                        count[j], count[j- 1] = count[j - 1] , count[j]\\n                        j -= 1 \\n                        ans += 1\\n                    req -= 1 \\n                    check  = True\\n                    break \\n            if check == False : \\n                return - 1 \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int: \\n        n = len(grid)\\n        # count trailing zeros \\n        count = []\\n        for i in range(n):\\n            cnt = 0 \\n            for j in range(n -1 , -1 , -1 ):\\n                if grid[i][j] != 0 : \\n                    break \\n                cnt += 1\\n            count.append(cnt)\\n        # Perforn Swapping \\n        req = n - 1 \\n        ans = 0 \\n        for i in range(n):\\n            check = False \\n            for j in range(i, n):\\n                if count[j] >= req:\\n                    while j !=  i : \\n                        count[j], count[j- 1] = count[j - 1] , count[j]\\n                        j -= 1 \\n                        ans += 1\\n                    req -= 1 \\n                    check  = True\\n                    break \\n            if check == False : \\n                return - 1 \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843246,
                "title": "linked-list-solution-fully-explained-python",
                "content": "For each row we count the number of consecutive zeros from the end.\\nWe then store that count in some sequential data structure (in this case linked list)\\n\\nthe count list might look something like this:\\n`[3,4,4,5,2], if n = 5`\\nwe want to turn this list into something like this:\\n```\\nfor general n\\n[a[0]>=n-1, a[1]>=n-2, a[2]>=n-3,.....a[n-1]>=1, a[n] >= whatever]\\n0th row must have atleast n-1 0s, thats why a[0] >= n-1,\\n...\\nn-1th row must have atleast 1 0s\\n```\\nso for 0th row we look for the first value in the list that is >=n-1, we then keep swapping that value until we reach 0th index. Instead of actually swapping you just find the index of that \"first value\" because thats the number of swaps needed.\\nYou also must remove that \"first value\" from the list because we can not use it again.\\n\\nIf we never find that \"first value\", then we return -1 because no solution exists\\n\\nYou can remove an element in O(1) using a linked list thats why I decided to use that instead of a list. \\n**Time: O(n^2)\\nSpace: O(n)**\\n```\\nclass Node:\\n    def __init__(self, val, nex=None):\\n        self.val = val\\n        self.nex = None\\n\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        head = c_tail = Node(-1) #dummy node\\n        for row in grid:\\n            c = 0\\n            for v in reversed(row):\\n                if v: break\\n                c += 1\\n            newNode = Node(c)\\n            c_tail.nex = newNode\\n            c_tail = newNode\\n\\n        moves = 0\\n        for c in range(n-1, 0, -1):\\n            \\n            i = 0\\n            c_node = head\\n            while c_node.nex:\\n                if c_node.nex.val >= c:\\n                    moves += i\\n                    c_node.nex = c_node.nex.nex\\n                    break\\n                i += 1\\n                c_node = c_node.nex\\n            else:\\n                return -1\\n\\n        return moves\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Greedy"
                ],
                "code": "```\\nfor general n\\n[a[0]>=n-1, a[1]>=n-2, a[2]>=n-3,.....a[n-1]>=1, a[n] >= whatever]\\n0th row must have atleast n-1 0s, thats why a[0] >= n-1,\\n...\\nn-1th row must have atleast 1 0s\\n```\n```\\nclass Node:\\n    def __init__(self, val, nex=None):\\n        self.val = val\\n        self.nex = None\\n\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        head = c_tail = Node(-1) #dummy node\\n        for row in grid:\\n            c = 0\\n            for v in reversed(row):\\n                if v: break\\n                c += 1\\n            newNode = Node(c)\\n            c_tail.nex = newNode\\n            c_tail = newNode\\n\\n        moves = 0\\n        for c in range(n-1, 0, -1):\\n            \\n            i = 0\\n            c_node = head\\n            while c_node.nex:\\n                if c_node.nex.val >= c:\\n                    moves += i\\n                    c_node.nex = c_node.nex.nex\\n                    break\\n                i += 1\\n                c_node = c_node.nex\\n            else:\\n                return -1\\n\\n        return moves\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811787,
                "title": "python-leverage-syntactic-sugar",
                "content": "# Approach\\nThe same idea as others. Counting the tail zeros and bubble sort.\\n\\n# Complexity\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        A = [sum(int(x == 0) for x in accumulate(row[::-1])) for row in grid]\\n        n = len(grid)\\n\\n        res = 0\\n        for i in range(n):\\n            for j in range(i, n):\\n                if A[j] >= n - 1 - i:\\n                    A = A[:i] + A[j:j+1] + A[i:j] + A[j+1:]\\n                    res += j - i\\n                    break\\n            else:\\n                return -1\\n        \\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        A = [sum(int(x == 0) for x in accumulate(row[::-1])) for row in grid]\\n        n = len(grid)\\n\\n        res = 0\\n        for i in range(n):\\n            for j in range(i, n):\\n                if A[j] >= n - 1 - i:\\n                    A = A[:i] + A[j:j+1] + A[i:j] + A[j+1:]\\n                    res += j - i\\n                    break\\n            else:\\n                return -1\\n        \\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795839,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        //store the number of zeroes in every row of grid\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        vector<int> arr;\\n        for(int i=0;i<rows;i++)\\n        {\\n            int cnt=0;\\n            int j=cols-1;\\n            while(j>=0 && grid[i][j]==0)\\n                cnt++,j--;\\n            arr.push_back(cnt);\\n        }\\n       \\n        \\n        int req=cols-1;\\n        int swaps=0;\\n        //now try to swap the rows\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int j;\\n            for(j=i;j<arr.size();j++)\\n            {\\n               if(arr[j]>=req)\\n                  break;\\n            }\\n            if(j==arr.size())\\n                return -1;\\n            swaps+=j-i;\\n            //now swap the values\\n            while(j>i){\\n                swap(arr[j],arr[j-1]);j--;\\n            }\\n            req--;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        //store the number of zeroes in every row of grid\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        vector<int> arr;\\n        for(int i=0;i<rows;i++)\\n        {\\n            int cnt=0;\\n            int j=cols-1;\\n            while(j>=0 && grid[i][j]==0)\\n                cnt++,j--;\\n            arr.push_back(cnt);\\n        }\\n       \\n        \\n        int req=cols-1;\\n        int swaps=0;\\n        //now try to swap the rows\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int j;\\n            for(j=i;j<arr.size();j++)\\n            {\\n               if(arr[j]>=req)\\n                  break;\\n            }\\n            if(j==arr.size())\\n                return -1;\\n            swaps+=j-i;\\n            //now swap the values\\n            while(j>i){\\n                swap(arr[j],arr[j-1]);j--;\\n            }\\n            req--;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789597,
                "title": "greedy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    void swap(vector<vector<int>> &grid, int i1, int i2){\\n        for(int i=0; i<n; i++){\\n            int t=grid[i1][i];\\n            grid[i1][i]=grid[i2][i];\\n            grid[i2][i]=t;\\n        }\\n    }\\n    \\n    bool isValid(vector<vector<int>> &grid){\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(grid[i][j]==1) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        n=grid[0].size();\\n        int ans=0;\\n        int n=grid.size();\\n        if(isValid(grid)) return 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int counter=n-i-1;\\n            int ctz=0;\\n            for(int k=n-1;k>i;k--){\\n                if(grid[i][k]==0){\\n                    ctz++;\\n                }\\n            }\\n            \\n            if(ctz==counter) continue;\\n            \\n            int row=-1;\\n            for(int q=i+1; q<n; q++){\\n                int ctz1=0;\\n                for(int j=n-1;j>i;j--){\\n                    if(grid[q][j]==0){\\n                        ctz1++;\\n                    }\\n                }\\n                \\n                if(ctz1==counter){\\n                    row=q;\\n                    break;\\n                }\\n            }\\n            \\n            //cout<<row<<endl;\\n            if(row==-1){\\n                ans=-1;\\n                break;\\n            }\\n            \\n            int swaps=row-i;\\n            while(swaps>0){\\n                swap(grid, row, row-1);\\n                row=row-1;\\n                swaps--;\\n                ans++;\\n            }   \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    void swap(vector<vector<int>> &grid, int i1, int i2){\\n        for(int i=0; i<n; i++){\\n            int t=grid[i1][i];\\n            grid[i1][i]=grid[i2][i];\\n            grid[i2][i]=t;\\n        }\\n    }\\n    \\n    bool isValid(vector<vector<int>> &grid){\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(grid[i][j]==1) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        n=grid[0].size();\\n        int ans=0;\\n        int n=grid.size();\\n        if(isValid(grid)) return 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int counter=n-i-1;\\n            int ctz=0;\\n            for(int k=n-1;k>i;k--){\\n                if(grid[i][k]==0){\\n                    ctz++;\\n                }\\n            }\\n            \\n            if(ctz==counter) continue;\\n            \\n            int row=-1;\\n            for(int q=i+1; q<n; q++){\\n                int ctz1=0;\\n                for(int j=n-1;j>i;j--){\\n                    if(grid[q][j]==0){\\n                        ctz1++;\\n                    }\\n                }\\n                \\n                if(ctz1==counter){\\n                    row=q;\\n                    break;\\n                }\\n            }\\n            \\n            //cout<<row<<endl;\\n            if(row==-1){\\n                ans=-1;\\n                break;\\n            }\\n            \\n            int swaps=row-i;\\n            while(swaps>0){\\n                swap(grid, row, row-1);\\n                row=row-1;\\n                swaps--;\\n                ans++;\\n            }   \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2784644,
                "title": "c",
                "content": "Runtime: 116 ms, faster than 100.00% of C online submissions for Minimum Swaps to Arrange a Binary Grid.\\nMemory Usage: 10 MB, less than 33.33% of C online submissions for Minimum Swaps to Arrange a Binary Grid.\\n```\\nint minSwaps(int** grid, int gridSize, int* gridColSize){\\n    int n = gridSize;\\n    int* TailZero = malloc(n * sizeof(int));\\n    for(int i = 0; i < n; i++){\\n        int cn = 0;\\n        for(int j = n-1; j >= 0; j--){\\n            if(grid[i][j] == 1)\\n                break;\\n            cn++;\\n        }\\n        TailZero[i] = cn;\\n    }\\n\\n    int step = 0;\\n    for(int i = 0; i < n ; i ++){\\n        for(int j = i;  j < n; j++){\\n            if(TailZero[j] >= (n-1-i)){\\n                step += (j - i);\\n                if(j == i)\\n                    break;\\n                for(int k = j; k > i; k--){\\n                    TailZero[k] = TailZero[k-1];   \\n                }\\n                TailZero[i] = i;\\n                break;\\n            }\\n            if(j == n-1)\\n                return -1;\\n        }\\n    }\\n    return step;   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minSwaps(int** grid, int gridSize, int* gridColSize){\\n    int n = gridSize;\\n    int* TailZero = malloc(n * sizeof(int));\\n    for(int i = 0; i < n; i++){\\n        int cn = 0;\\n        for(int j = n-1; j >= 0; j--){\\n            if(grid[i][j] == 1)\\n                break;\\n            cn++;\\n        }\\n        TailZero[i] = cn;\\n    }\\n\\n    int step = 0;\\n    for(int i = 0; i < n ; i ++){\\n        for(int j = i;  j < n; j++){\\n            if(TailZero[j] >= (n-1-i)){\\n                step += (j - i);\\n                if(j == i)\\n                    break;\\n                for(int k = j; k > i; k--){\\n                    TailZero[k] = TailZero[k-1];   \\n                }\\n                TailZero[i] = i;\\n                break;\\n            }\\n            if(j == n-1)\\n                return -1;\\n        }\\n    }\\n    return step;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2515729,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        vector<int>t(n,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=n-1;j>=0;j--){\\n                if(grid[i][j]==0)\\n                    t[i]++;\\n                else break;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int req=n-i-1;\\n            int pos=i;\\n            while(pos<n && t[pos]<req)\\n                pos++;\\n            if(pos==n)\\n                return -1;\\n            ans+=pos-i;\\n            for(int k=pos-1;k>=i;k--)\\n                t[k+1]=t[k];\\n            t[i]=t[pos];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        vector<int>t(n,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=n-1;j>=0;j--){\\n                if(grid[i][j]==0)\\n                    t[i]++;\\n                else break;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int req=n-i-1;\\n            int pos=i;\\n            while(pos<n && t[pos]<req)\\n                pos++;\\n            if(pos==n)\\n                return -1;\\n            ans+=pos-i;\\n            for(int k=pos-1;k>=i;k--)\\n                t[k+1]=t[k];\\n            t[i]=t[pos];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492404,
                "title": "python-to-1d-greedy",
                "content": "\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        # grid --> back-lead zero needed\\n        back_zero_rows = [0] * n\\n        for i in range(n):\\n            back_zero_count = 0\\n            for x in reversed(grid[i]):\\n                if x == 0:\\n                    back_zero_count += 1\\n                else:\\n                    break\\n            back_zero_rows[i] = back_zero_count\\n\\n        # count the step\\n        counter = 0\\n        for i in range(n):\\n            zero_needed = n-1-i\\n            # if need no enough zero, u need to find a line to swap\\n            if back_zero_rows[i] < zero_needed:\\n                for j in range(i + 1, n):\\n                    if back_zero_rows[j] >= zero_needed:\\n                        # NOTION: not swap (counter)\\n                        # back_zero_rows[i], back_zero_rows[j] = back_zero_rows[j], back_zero_rows[i]\\n                        # difference: remove + insert\\n                        line = back_zero_rows.pop(j)\\n                        back_zero_rows.insert(i, line)\\n                        counter += j - i\\n                        break\\n                else:\\n                    return -1\\n        return counter\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        # grid --> back-lead zero needed\\n        back_zero_rows = [0] * n\\n        for i in range(n):\\n            back_zero_count = 0\\n            for x in reversed(grid[i]):\\n                if x == 0:\\n                    back_zero_count += 1\\n                else:\\n                    break\\n            back_zero_rows[i] = back_zero_count\\n\\n        # count the step\\n        counter = 0\\n        for i in range(n):\\n            zero_needed = n-1-i\\n            # if need no enough zero, u need to find a line to swap\\n            if back_zero_rows[i] < zero_needed:\\n                for j in range(i + 1, n):\\n                    if back_zero_rows[j] >= zero_needed:\\n                        # NOTION: not swap (counter)\\n                        # back_zero_rows[i], back_zero_rows[j] = back_zero_rows[j], back_zero_rows[i]\\n                        # difference: remove + insert\\n                        line = back_zero_rows.pop(j)\\n                        back_zero_rows.insert(i, line)\\n                        counter += j - i\\n                        break\\n                else:\\n                    return -1\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475416,
                "title": "swap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void swaps(int from, int need, vector<int> &len) {\\n        for (int i = need - 1; i >= 0; i--) {\\n            int temp = len[from + i];\\n            len[from + i] = len[from + i + 1];\\n            len[from + i + 1] = temp;\\n        }\\n    }\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> len(grid.size());\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int k = grid[i].size() - 1; k > 0 && grid[i][k] == 0; k--) {\\n                \\n                len[i]++;\\n            }\\n        }\\n        int size = len.size();\\n        priority_queue<int> pq;\\n        int res = 0;\\n        for (int i = 0; i < size; i++) {\\n            int need = 0;\\n            if (!pq.empty() && pq.top() >= size - i - 1) {\\n                pq.pop();\\n                continue;\\n            }\\n            for (int j = i; j < size && !(len[j] >= size - i - 1); j++) {\\n                need++;\\n            }\\n            if (need > size - i - 1) {\\n                return - 1;\\n            }\\n            swaps(i, need, len);\\n            cout << endl;\\n            res += need;\\n        }\\n        return res;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void swaps(int from, int need, vector<int> &len) {\\n        for (int i = need - 1; i >= 0; i--) {\\n            int temp = len[from + i];\\n            len[from + i] = len[from + i + 1];\\n            len[from + i + 1] = temp;\\n        }\\n    }\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> len(grid.size());\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int k = grid[i].size() - 1; k > 0 && grid[i][k] == 0; k--) {\\n                \\n                len[i]++;\\n            }\\n        }\\n        int size = len.size();\\n        priority_queue<int> pq;\\n        int res = 0;\\n        for (int i = 0; i < size; i++) {\\n            int need = 0;\\n            if (!pq.empty() && pq.top() >= size - i - 1) {\\n                pq.pop();\\n                continue;\\n            }\\n            for (int j = i; j < size && !(len[j] >= size - i - 1); j++) {\\n                need++;\\n            }\\n            if (need > size - i - 1) {\\n                return - 1;\\n            }\\n            swaps(i, need, len);\\n            cout << endl;\\n            res += need;\\n        }\\n        return res;\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 2410212,
                "title": "python-count-and-swap",
                "content": "**Solution**:\\n    Start by counting consecutive zeros in each row starting from the end of the column. Store (row, zero count) in an ordered dictionary. We will use this like a stack but we can remove any item in O(1).  \\n\\nNext, iterate through all rows and calculate how many zeros is needed in such row. Then, find the first row in the ordered dictionary that contains at least that much zeros. The index of such first row will be the amount of steps we need to swap to move such row to the correct position. Delete used row.  \\n\\n    ie. Given grid = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]]\\n\\n    1. Count zeroes\\n        orderedDict = {0:3, 1:0, 2:3, 3:3}\\n\\n    2. Calculate steps\\n        row     zerosNeeded     orderedDict           firstRow    firstRowIndex    swaps\\n        0       3               {0:3, 1:0, 2:3, 3:3}  0           0                0\\n        1       2               {1:0, 2:3, 3:3}       2           1                1\\n        2       1               {1:0, 3:3}            3           1                2\\n        3       0               {1:0}                 1           0                2\\n\\n**Complexity**:\\n    Time: O(n ** 2)\\n    Space: O(n)\\n\\t\\n```\\nfrom collections import OrderedDict\\n\\nclass Solution:\\n    def minSwaps(self, grid: list[list[int]]) -> int:\\n\\n        # Get the number of rows and cols\\n        n = len(grid)\\n\\n        # Calcualte zeros for each row\\n        # Initialize the ordered dict to store rows and their zeros\\n        zeroCounts = OrderedDict()\\n\\n        # Iterate through all rows\\n        for row in range(n):\\n\\n            count = 0\\n\\n            # Count the number of consecutive zeros\\n            for col in range(n - 1, -1, -1):\\n\\n                # End the count when we see the first one\\n                if grid[row][col] == 1:\\n                    break\\n\\n                # Increment the zeros count\\n                count += 1\\n\\n            # Save the row and its zeros count to the dict\\n            zeroCounts[row] = count\\n\\n\\n        # Calculate the number of swaps \\n        # Intialize the swap to 0\\n        swaps = 0\\n\\n        # Iterate through all rows\\n        for row in range(n):\\n\\n            # Find the first row that has the required zeros\\n            for i, (col, count) in enumerate(zeroCounts.items()):\\n\\n                # If we found one\\n                if count >= n - row - 1:\\n\\n                    # Increment the swap based on the row index in the dict\\n                    swaps += i\\n\\n                    # Remove such row\\n                    zeroCounts.pop(col)\\n\\n                    # Continue to the next row\\n                    break\\n\\n                # Else, if we couldn\\'t find one, return -1\\n                if i == len(zeroCounts) - 1:\\n                    return -1\\n\\n        return swaps\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import OrderedDict\\n\\nclass Solution:\\n    def minSwaps(self, grid: list[list[int]]) -> int:\\n\\n        # Get the number of rows and cols\\n        n = len(grid)\\n\\n        # Calcualte zeros for each row\\n        # Initialize the ordered dict to store rows and their zeros\\n        zeroCounts = OrderedDict()\\n\\n        # Iterate through all rows\\n        for row in range(n):\\n\\n            count = 0\\n\\n            # Count the number of consecutive zeros\\n            for col in range(n - 1, -1, -1):\\n\\n                # End the count when we see the first one\\n                if grid[row][col] == 1:\\n                    break\\n\\n                # Increment the zeros count\\n                count += 1\\n\\n            # Save the row and its zeros count to the dict\\n            zeroCounts[row] = count\\n\\n\\n        # Calculate the number of swaps \\n        # Intialize the swap to 0\\n        swaps = 0\\n\\n        # Iterate through all rows\\n        for row in range(n):\\n\\n            # Find the first row that has the required zeros\\n            for i, (col, count) in enumerate(zeroCounts.items()):\\n\\n                # If we found one\\n                if count >= n - row - 1:\\n\\n                    # Increment the swap based on the row index in the dict\\n                    swaps += i\\n\\n                    # Remove such row\\n                    zeroCounts.pop(col)\\n\\n                    # Continue to the next row\\n                    break\\n\\n                # Else, if we couldn\\'t find one, return -1\\n                if i == len(zeroCounts) - 1:\\n                    return -1\\n\\n        return swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340223,
                "title": "intuitive-do-as-hints-say-reduce-problem-to-number-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int> max_right;\\n        for (auto g : grid) {\\n            int right = 0;\\n            for (int i = 0; i < n; ++i) {\\n                if (g[i])\\n                    right = max(right, i);\\n            }\\n            max_right.push_back(right);\\n        }\\n        \\n        auto check = max_right;\\n        sort(check.begin(), check.end());\\n        for (int i = 0; i < n; ++i) {\\n            if (check[i] > i)\\n                return -1;\\n        }\\n        \\n        int swaps = 0;\\n        for (int i = 0; i < n; ++i) {\\n\\n            int idx = -1;\\n            for (int j = i; j < n; ++j) {\\n                if (max_right[j] <= i) {\\n                    idx = j;\\n                    break;\\n                }\\n            }\\n            for (int j = idx; j > i; --j) {\\n                max_right[j] = max_right[j - 1];\\n                ++swaps;\\n            }\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int> max_right;\\n        for (auto g : grid) {\\n            int right = 0;\\n            for (int i = 0; i < n; ++i) {\\n                if (g[i])\\n                    right = max(right, i);\\n            }\\n            max_right.push_back(right);\\n        }\\n        \\n        auto check = max_right;\\n        sort(check.begin(), check.end());\\n        for (int i = 0; i < n; ++i) {\\n            if (check[i] > i)\\n                return -1;\\n        }\\n        \\n        int swaps = 0;\\n        for (int i = 0; i < n; ++i) {\\n\\n            int idx = -1;\\n            for (int j = i; j < n; ++j) {\\n                if (max_right[j] <= i) {\\n                    idx = j;\\n                    break;\\n                }\\n            }\\n            for (int j = idx; j > i; --j) {\\n                max_right[j] = max_right[j - 1];\\n                ++swaps;\\n            }\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289175,
                "title": "c-detailed-explanation-greedy-basic-sorting-technique-used",
                "content": "## *****INTUITION-:\\n\\n## ****  suppose n=6\\n    \\n /*    no . of zeros from end consecutively at each rows is [ 2 , 3 , 5 , 2 , 5 , 2]\\n    \\n     after first iteration we need at least 5 zeros at 0th index\\n    \\n     array will be [ 5 , 2 , 3 , 2 , 5 , 2] -> swap=2\\n    \\n     firstly 2 goes to 1st index , then 3 goes to 2nd index , we found our answer 5\\n    \\n     5 comes to required position 0th index \\n    \\n     [ 5 , 2 , 3 , 2 , 5 , 2] -> now we are at 1st index value is 2 , but \\n    \\n     we require at least 4 zeros \\n    \\n    go on same way the array will be [5 , 5 , 2 , 3 , 2 , 2] swaps =3 \\n    \\n    now we need at least 3 zeros , [5 , 5 , 3 , 2 , 2 , 2] swaps=1\\n    \\n    now no more swappings are required as no of required zeros is fulfilling */\\n\\t\\n\\t\\n\\n```\\n \\n\\n\\n\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        \\n        vector<int> nums(n , 0);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            nums[i]=count;\\n        }\\n        \\n        // now we have to make tha nums array sorting acccording to values \\n        \\n        // lets say nums array is [ 1, 2 , 3 , 4]\\n        \\n        // requirement is at least 3 zeros at 0th index\\n        \\n        // at least 2 zeros at 1st index\\n        \\n        //  at least 1 zeros at 2nd index \\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            int required_zero=n-i-1;\\n            \\n            if(nums[i]>=required_zero)\\n            {\\n                continue;\\n            }\\n            \\n            int curr_val=nums[i];\\n            bool f=false;\\n            \\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[j]>=(required_zero))\\n                {\\n                    nums[i]=nums[j];\\n                    nums[j]=curr_val; \\n                    ans++;\\n                    f=true;\\n                    break;\\n                }\\n                else\\n                {\\n                    int temp=nums[j];\\n                    nums[j]=curr_val;\\n                    curr_val=temp;\\n                    ans++;\\n                }\\n            }\\n            if(f==false)\\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n``` \\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        \\n        vector<int> nums(n , 0);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            nums[i]=count;\\n        }\\n        \\n        // now we have to make tha nums array sorting acccording to values \\n        \\n        // lets say nums array is [ 1, 2 , 3 , 4]\\n        \\n        // requirement is at least 3 zeros at 0th index\\n        \\n        // at least 2 zeros at 1st index\\n        \\n        //  at least 1 zeros at 2nd index \\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            int required_zero=n-i-1;\\n            \\n            if(nums[i]>=required_zero)\\n            {\\n                continue;\\n            }\\n            \\n            int curr_val=nums[i];\\n            bool f=false;\\n            \\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[j]>=(required_zero))\\n                {\\n                    nums[i]=nums[j];\\n                    nums[j]=curr_val; \\n                    ans++;\\n                    f=true;\\n                    break;\\n                }\\n                else\\n                {\\n                    int temp=nums[j];\\n                    nums[j]=curr_val;\\n                    curr_val=temp;\\n                    ans++;\\n                }\\n            }\\n            if(f==false)\\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n \\n\\n\\n\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        \\n        vector<int> nums(n , 0);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            nums[i]=count;\\n        }\\n        \\n        // now we have to make tha nums array sorting acccording to values \\n        \\n        // lets say nums array is [ 1, 2 , 3 , 4]\\n        \\n        // requirement is at least 3 zeros at 0th index\\n        \\n        // at least 2 zeros at 1st index\\n        \\n        //  at least 1 zeros at 2nd index \\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            int required_zero=n-i-1;\\n            \\n            if(nums[i]>=required_zero)\\n            {\\n                continue;\\n            }\\n            \\n            int curr_val=nums[i];\\n            bool f=false;\\n            \\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[j]>=(required_zero))\\n                {\\n                    nums[i]=nums[j];\\n                    nums[j]=curr_val; \\n                    ans++;\\n                    f=true;\\n                    break;\\n                }\\n                else\\n                {\\n                    int temp=nums[j];\\n                    nums[j]=curr_val;\\n                    curr_val=temp;\\n                    ans++;\\n                }\\n            }\\n            if(f==false)\\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2207558,
                "title": "bubble-sort-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        vector<int> mr(n,0);\\n        vector<int> br(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                    mr[i] = j;\\n            }\\n        }\\n        br = mr;\\n        sort(mr.begin(),mr.end());\\n        for(int i=0;i<n;i++)\\n            if(mr[i]>i)\\n                return -1;\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(br[i]>i){\\n                    swap(br[i],br[j]);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        vector<int> mr(n,0);\\n        vector<int> br(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                    mr[i] = j;\\n            }\\n        }\\n        br = mr;\\n        sort(mr.begin(),mr.end());\\n        for(int i=0;i<n;i++)\\n            if(mr[i]>i)\\n                return -1;\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(br[i]>i){\\n                    swap(br[i],br[j]);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191159,
                "title": "c-greedy-solution-bubble-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        vector<int> mr(n,0);\\n        vector<int> br(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                    mr[i] = j;\\n            }\\n        }\\n        br = mr;\\n        sort(mr.begin(),mr.end());\\n        for(int i=0;i<n;i++)\\n            if(mr[i]>i)\\n                return -1;\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(br[i]>i){\\n                    swap(br[i],br[j]);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        vector<int> mr(n,0);\\n        vector<int> br(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                    mr[i] = j;\\n            }\\n        }\\n        br = mr;\\n        sort(mr.begin(),mr.end());\\n        for(int i=0;i<n;i++)\\n            if(mr[i]>i)\\n                return -1;\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(br[i]>i){\\n                    swap(br[i],br[j]);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081294,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& g) {\\n        int r=g.size(),s=0;\\n        vector<int>z(r);\\n        for(int i=0;i<r;i++)\\n            for(int j=r-1;j>=0;j--){\\n                if(g[i][j])break;\\n                z[i]++;\\n            }\\n        for(int i=0;i<r;i++){\\n            int cur=i,req=r-1-i;\\n            if(z[cur]>=req)continue;\\n            while(cur<r && z[cur]<req)cur++;\\n            if(cur==r) return -1;\\n            s+=cur-i;\\n            while(cur>i){\\n                z[cur]=z[cur-1];\\n                --cur;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& g) {\\n        int r=g.size(),s=0;\\n        vector<int>z(r);\\n        for(int i=0;i<r;i++)\\n            for(int j=r-1;j>=0;j--){\\n                if(g[i][j])break;\\n                z[i]++;\\n            }\\n        for(int i=0;i<r;i++){\\n            int cur=i,req=r-1-i;\\n            if(z[cur]>=req)continue;\\n            while(cur<r && z[cur]<req)cur++;\\n            if(cur==r) return -1;\\n            s+=cur-i;\\n            while(cur>i){\\n                z[cur]=z[cur-1];\\n                --cur;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066690,
                "title": "c-simply-try-fit-every-row",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        vector<int> zeroCounts(n, 0);                  //calc ending zero count of each row\\n        for (int i = 0; i < n; ++i)\\n            for (int j =n - 1; j >= 0 && grid[i][j] == 0; --j, ++zeroCounts[i]);\\n\\n        int steps = 0,i=0,j=0;\\n        for ( ; i < n; ++i) {                           //try to match each row (ending zero count euqal to i-1)\\n            if (zeroCounts[i] >= n - i - 1) continue;   //already matched\\n            \\n            for ( j = i + 1; j < n; ++j)                //find out a correct row to switch with current row\\n                if (zeroCounts[j] >= n - i - 1) \\n                {\\n                    for (int k = j; k > i; --k) { \\n                        swap(grid[k], grid[k - 1]);\\n                        swap(zeroCounts[k], zeroCounts[k - 1]);\\n                    }\\n\\n                    steps += j - i;\\n                    break;\\n                }\\n\\n            if (j == n) return -1;\\n        }\\n\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        vector<int> zeroCounts(n, 0);                  //calc ending zero count of each row\\n        for (int i = 0; i < n; ++i)\\n            for (int j =n - 1; j >= 0 && grid[i][j] == 0; --j, ++zeroCounts[i]);\\n\\n        int steps = 0,i=0,j=0;\\n        for ( ; i < n; ++i) {                           //try to match each row (ending zero count euqal to i-1)\\n            if (zeroCounts[i] >= n - i - 1) continue;   //already matched\\n            \\n            for ( j = i + 1; j < n; ++j)                //find out a correct row to switch with current row\\n                if (zeroCounts[j] >= n - i - 1) \\n                {\\n                    for (int k = j; k > i; --k) { \\n                        swap(grid[k], grid[k - 1]);\\n                        swap(zeroCounts[k], zeroCounts[k - 1]);\\n                    }\\n\\n                    steps += j - i;\\n                    break;\\n                }\\n\\n            if (j == n) return -1;\\n        }\\n\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036684,
                "title": "simple-c-o-n-3-solution",
                "content": "Time complexity : O(N^3)\\nSpace Complexity : O(1)\\n```\\nclass Solution {\\npublic:\\n    #define vi vector<int>\\n    #define vvi vector<vi>\\n    \\n    void printGrid(vvi grid){\\n        cout<<\"Grid : \\\\n\";\\n        for(auto ele:grid){\\n            for(auto every:ele){\\n                cout<<every<<\" \";\\n            }\\n            cout<<endl;\\n            \\n        }\\n        \\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int i=0;\\n        \\n        int R = grid.size();\\n        int C = grid[0].size();\\n        \\n        int ans=0;\\n        \\n        // iterate over each row to find best possible row for any index i\\n        // NOTE: best possible row is row with max suffix zeros >= (C-i-1) and with minimum index (I)\\n        while(i<R){\\n            \\n            int I =i;\\n            int ind = INT_MAX;\\n            \\n            // iterate throw all rows >=i to count suffix 0\\'s following above stated criteria\\n            while(I<R){\\n                \\n                int J = C-1;\\n                int count = 0;\\n                \\n                // count suffix 0s    \\n                while(J>=0&&grid[I][J]==0){\\n                    count++;    \\n                    J--;\\n                }\\n                \\n                // take ind to be that I where suffix 0\\'s count >= (C-i-1)\\n                if(count>=C-i-1){\\n                    ind = min(ind,I);\\n                }\\n                I++;\\n            }\\n            \\n            if(ind!=INT_MAX){\\n                \\n                // perform swapping of of every j & j+1 rows till j reaches i\\n                int j = ind-1;\\n                while(j>=i){\\n\\n                    int l = 0;\\n                    while(l<C){\\n                        int t = grid[j][l];\\n                        grid[j][l] = grid[j+1][l];\\n                        grid[j+1][l]=t;\\n                        l++;\\n                    }\\n\\n                    ans++;\\n                    j--;\\n                }\\n            }\\n            else return -1; // this is edge case where best possible row to be swapped for row i is never found in grid so return -1\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define vi vector<int>\\n    #define vvi vector<vi>\\n    \\n    void printGrid(vvi grid){\\n        cout<<\"Grid : \\\\n\";\\n        for(auto ele:grid){\\n            for(auto every:ele){\\n                cout<<every<<\" \";\\n            }\\n            cout<<endl;\\n            \\n        }\\n        \\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int i=0;\\n        \\n        int R = grid.size();\\n        int C = grid[0].size();\\n        \\n        int ans=0;\\n        \\n        // iterate over each row to find best possible row for any index i\\n        // NOTE: best possible row is row with max suffix zeros >= (C-i-1) and with minimum index (I)\\n        while(i<R){\\n            \\n            int I =i;\\n            int ind = INT_MAX;\\n            \\n            // iterate throw all rows >=i to count suffix 0\\'s following above stated criteria\\n            while(I<R){\\n                \\n                int J = C-1;\\n                int count = 0;\\n                \\n                // count suffix 0s    \\n                while(J>=0&&grid[I][J]==0){\\n                    count++;    \\n                    J--;\\n                }\\n                \\n                // take ind to be that I where suffix 0\\'s count >= (C-i-1)\\n                if(count>=C-i-1){\\n                    ind = min(ind,I);\\n                }\\n                I++;\\n            }\\n            \\n            if(ind!=INT_MAX){\\n                \\n                // perform swapping of of every j & j+1 rows till j reaches i\\n                int j = ind-1;\\n                while(j>=i){\\n\\n                    int l = 0;\\n                    while(l<C){\\n                        int t = grid[j][l];\\n                        grid[j][l] = grid[j+1][l];\\n                        grid[j+1][l]=t;\\n                        l++;\\n                    }\\n\\n                    ans++;\\n                    j--;\\n                }\\n            }\\n            else return -1; // this is edge case where best possible row to be swapped for row i is never found in grid so return -1\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1999181,
                "title": "java-from-top-to-bottom-comments",
                "content": "**Idea**\\n1. Treat each row and a number and we can swap it directly. No need to do any transformation.\\n\\n2. We should always sort it from the top and work our way downward. It is because during this process, the smaller (later ones) can be pushed closer to its fitting row as a side effect. If we had start from anything other than the top row, while we are swapping into the top row, it will also mess up all the previous ones that we\\'ve sorted. Intuitively speaking, it only makes sense to start from the top.\\n```Java\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length, ans = 0, cur = 0;\\n        for (int k = 0; k < n - 1; k++){ // looking for the fitting row for row k\\n            for (int i = k; i < n; i++){ // start from row k looking downward\\n                for (int j = k + 1; j < n; j++){ // all cell after and at k + 1 must be 0\\n                    if (grid[i][j] == 1)\\n                        break;\\n                    if (j < n - 1)\\n                        continue;\\n                    for (int m = i; m > k; m--){ // j == n - 1 here, so we found a valid row\\n                        int[] tmp = grid[m - 1];  // swap it into the correct row - row k\\n                        grid[m - 1] = grid[m];\\n                        grid[m] = tmp;\\n                        ans++;\\n                    }\\n                    i = n;\\n                }\\n                if (i == n - 1) // i reaches the end and did not find a fitting row, return -1\\n                    return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length, ans = 0, cur = 0;\\n        for (int k = 0; k < n - 1; k++){ // looking for the fitting row for row k\\n            for (int i = k; i < n; i++){ // start from row k looking downward\\n                for (int j = k + 1; j < n; j++){ // all cell after and at k + 1 must be 0\\n                    if (grid[i][j] == 1)\\n                        break;\\n                    if (j < n - 1)\\n                        continue;\\n                    for (int m = i; m > k; m--){ // j == n - 1 here, so we found a valid row\\n                        int[] tmp = grid[m - 1];  // swap it into the correct row - row k\\n                        grid[m - 1] = grid[m];\\n                        grid[m] = tmp;\\n                        ans++;\\n                    }\\n                    i = n;\\n                }\\n                if (i == n - 1) // i reaches the end and did not find a fitting row, return -1\\n                    return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859085,
                "title": "python-count-swaps-by-reducing-array-of-right-most-ones",
                "content": "For any grid, we want the right-most 1 to be at most 0, 1, 2, ... n for the respective rows\\n\\n0000\\n?000\\n??00\\n???0\\n\\n1. For each row check the rightmost 1\\n2. Validate that a solution is possible by sorting array and verifying that the right-most one is at most at pos n for row n\\n3. Simulate the swaps by reducing the array of right-most ones\\n\\nFor step 3 - if our grid is `[[0, 0, 1], [1, 1, 0], [1, 0, 0]]` so our array of right-most ones is `[2, 1, 0]` we get the following\\n\\n1. Find 0 (or less) at position 2 - it will take **2 steps** to get the 0 to position 0 - Reduce array to `[2, 1]` - we have 2 rows left to position\\n2. Find 1 (or less) at position 1 - it will take **1 step** to get the 1 to position 0 - Reduce array to `[2]` - we have 1 row left to position\\n3. Find 2 (or less) at position 0 - it will take **0 steps** to get the 2 to position 0 - Reduce array to `[]` - DONE! \\n\\nThe result is 2 + 1 + 0 steps\\n\\n```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n\\n        def get_rightmost_one(row):\\n            for i in range(n - 1, -1, -1):\\n                if row[i] == 1:\\n                    return i\\n            return -1\\n\\n        def solution_is_possible(max_right):\\n            sorted_right = list(sorted(max_right))\\n\\n            for pos, val in enumerate(sorted_right):\\n                if val > pos:\\n                    return False\\n            return True\\n\\n        max_right = [get_rightmost_one(row) for row in grid]\\n        if not solution_is_possible(max_right):\\n            return -1\\n\\n        swaps = 0\\n        for pos in range(n):\\n            idx = 0\\n            while max_right[idx] > pos:\\n                idx += 1\\n\\n            max_right = max_right[:idx] + max_right[idx + 1:]\\n            swaps += idx\\n\\n        return swaps\\n\\n\\nsolution = Solution()\\nassert solution.minSwaps([[0, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 0]]) == -1\\nassert solution.minSwaps([[0, 0, 1], [1, 1, 0], [1, 0, 0]]) == 3\\nassert solution.minSwaps([[1, 0, 0], [1, 1, 0], [1, 1, 1]]) == 0\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n\\n        def get_rightmost_one(row):\\n            for i in range(n - 1, -1, -1):\\n                if row[i] == 1:\\n                    return i\\n            return -1\\n\\n        def solution_is_possible(max_right):\\n            sorted_right = list(sorted(max_right))\\n\\n            for pos, val in enumerate(sorted_right):\\n                if val > pos:\\n                    return False\\n            return True\\n\\n        max_right = [get_rightmost_one(row) for row in grid]\\n        if not solution_is_possible(max_right):\\n            return -1\\n\\n        swaps = 0\\n        for pos in range(n):\\n            idx = 0\\n            while max_right[idx] > pos:\\n                idx += 1\\n\\n            max_right = max_right[:idx] + max_right[idx + 1:]\\n            swaps += idx\\n\\n        return swaps\\n\\n\\nsolution = Solution()\\nassert solution.minSwaps([[0, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 0]]) == -1\\nassert solution.minSwaps([[0, 0, 1], [1, 1, 0], [1, 0, 0]]) == 3\\nassert solution.minSwaps([[1, 0, 0], [1, 1, 0], [1, 1, 1]]) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729993,
                "title": "java-greedy-solution",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length, ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            if (valid(grid[i], i)) continue;\\n            boolean found = false;\\n            for (int j = i+1; j<n; j++) {\\n                if (valid(grid[j], i)) {\\n                    // swap row i and j\\n                    grid = swap(grid, i, j);\\n                    ans += j-i;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if (!found) return -1;\\n        }\\n        return ans;\\n    }\\n    public int[][] swap(int[][] grid, int i, int j) {\\n        int [] j_row = grid[j].clone();\\n        for (int k = j-1; k>=i; k--) {\\n            grid[k+1] = grid[k];\\n        }\\n        grid[i] = j_row;\\n        //System.out.println(Arrays.deepToString(grid));\\n        return grid;\\n    }\\n    public boolean valid(int[] r, int idx) {\\n        for (int i = idx+1; i<r.length; i++) {\\n            if (r[i]==1) return false;\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length, ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            if (valid(grid[i], i)) continue;\\n            boolean found = false;\\n            for (int j = i+1; j<n; j++) {\\n                if (valid(grid[j], i)) {\\n                    // swap row i and j\\n                    grid = swap(grid, i, j);\\n                    ans += j-i;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if (!found) return -1;\\n        }\\n        return ans;\\n    }\\n    public int[][] swap(int[][] grid, int i, int j) {\\n        int [] j_row = grid[j].clone();\\n        for (int k = j-1; k>=i; k--) {\\n            grid[k+1] = grid[k];\\n        }\\n        grid[i] = j_row;\\n        //System.out.println(Arrays.deepToString(grid));\\n        return grid;\\n    }\\n    public boolean valid(int[] r, int idx) {\\n        for (int i = idx+1; i<r.length; i++) {\\n            if (r[i]==1) return false;\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649269,
                "title": "convert-grid-swap-to-list-swap",
                "content": "```\\nr\\'\\'\\'\\n1536. Minimum Swaps to Arrange a Binary Grid\\n\\n0: 001 2\\n1: 110 1\\n2: 100 0\\n\\nthe problem becomese making 210 to 012 by swaping adjacent elements\\n\\nif there are same rows, for example 0320\\n\\n0320 -> 0023 : 3\\n0320 >(2) 0032 > 0023\\n\\n1210 -> 0112 : 4\\n1210 >(3) 0121 > 0112\\n\\ni: 0123\\nr: 1210\\n\\nfor each i\\n   find the j from i where r[j]<=i\\n   if not found return -1\\n   swaps += j-i\\n   push i..j-1 one step right\\n\\ntime complexity\\n. get r: O(n^2)\\n. get swaps: O(n^2)\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def minSwaps(self, grid):\\n        # convert grid to r\\n        n, r = len(grid), []\\n        for i in range(n):\\n            for j in range(n-1, -1, -1):\\n                if grid[i][j] == 1:\\n                    r.append(j)\\n                    break\\n            else: r.append(-1)\\n\\n        # swap r\\n        swaps = 0\\n        for i in range(n):\\n            for j in range(i, n):\\n                if r[j] <= i:\\n                    swaps += (j-i)\\n                    for k in range(j-1, i-1, -1): r[k+1] = r[k]\\n                    break\\n            else: return -1\\n        return swaps\\n```",
                "solutionTags": [],
                "code": "```\\nr\\'\\'\\'\\n1536. Minimum Swaps to Arrange a Binary Grid\\n\\n0: 001 2\\n1: 110 1\\n2: 100 0\\n\\nthe problem becomese making 210 to 012 by swaping adjacent elements\\n\\nif there are same rows, for example 0320\\n\\n0320 -> 0023 : 3\\n0320 >(2) 0032 > 0023\\n\\n1210 -> 0112 : 4\\n1210 >(3) 0121 > 0112\\n\\ni: 0123\\nr: 1210\\n\\nfor each i\\n   find the j from i where r[j]<=i\\n   if not found return -1\\n   swaps += j-i\\n   push i..j-1 one step right\\n\\ntime complexity\\n. get r: O(n^2)\\n. get swaps: O(n^2)\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def minSwaps(self, grid):\\n        # convert grid to r\\n        n, r = len(grid), []\\n        for i in range(n):\\n            for j in range(n-1, -1, -1):\\n                if grid[i][j] == 1:\\n                    r.append(j)\\n                    break\\n            else: r.append(-1)\\n\\n        # swap r\\n        swaps = 0\\n        for i in range(n):\\n            for j in range(i, n):\\n                if r[j] <= i:\\n                    swaps += (j-i)\\n                    for k in range(j-1, i-1, -1): r[k+1] = r[k]\\n                    break\\n            else: return -1\\n        return swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635751,
                "title": "java-swap-o-n2-time-o-n-space-solution",
                "content": "Explanation -\\n1. A valid solution matrix is such that for a row at index i, this row should contain **atleast** n - index - 1 continuos zeros from right side after swaps. There can be multiple such valid matrix and we need to find one with min number of swaps\\n2. Preprocessing Step - As mentioned above we only care about number of continous zeros from right side for each row. In this pre-processing step we compute this - Time complexity - O(n2) . Space Complexity - O(n)\\n3. Once we have this preprocessed array we need to swap entries in this array such that we have an array where entry at index i >= (n - i - 1). For this we can use a greedy approach (closest valid entry for a index) to find correct entry for a particular index and swap all values between current value & required value.\\n4. Answer is sum of all the swaps required for all index\\n\\n```\\nclass Solution \\n{\\n    public int minSwaps(int[][] grid) \\n    {\\n        int len = grid.length;\\n        int swap = 0;\\n        int[] preProcess = new int[len];\\n        for(int i = 0; i < len; i++)\\n        {\\n            preProcess[i] = countRightZeros(grid[i]);\\n        }\\n        for(int i = 0; i < len; i++)\\n        {\\n            int minValueRequired = len - i - 1;\\n            \\n            int j = i;\\n            while(j < len && preProcess[j] < minValueRequired)\\n            {\\n                j++;\\n            }\\n            \\n            if(j == len)\\n                return -1;\\n            \\n            while(j != i)\\n            {\\n                swap++;\\n                int temp = preProcess[j];\\n                preProcess[j] = preProcess[j-1];\\n                preProcess[j-1] = temp;\\n                j--;\\n            }\\n        }\\n        \\n        return swap;\\n    }\\n    \\n    private int countRightZeros(int[] row)\\n    {\\n        int cnt = 0;\\n        for(int i = row.length - 1; i >= 0; i--)\\n        {\\n            if(row[i] != 0)\\n                break;\\n            cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minSwaps(int[][] grid) \\n    {\\n        int len = grid.length;\\n        int swap = 0;\\n        int[] preProcess = new int[len];\\n        for(int i = 0; i < len; i++)\\n        {\\n            preProcess[i] = countRightZeros(grid[i]);\\n        }\\n        for(int i = 0; i < len; i++)\\n        {\\n            int minValueRequired = len - i - 1;\\n            \\n            int j = i;\\n            while(j < len && preProcess[j] < minValueRequired)\\n            {\\n                j++;\\n            }\\n            \\n            if(j == len)\\n                return -1;\\n            \\n            while(j != i)\\n            {\\n                swap++;\\n                int temp = preProcess[j];\\n                preProcess[j] = preProcess[j-1];\\n                preProcess[j-1] = temp;\\n                j--;\\n            }\\n        }\\n        \\n        return swap;\\n    }\\n    \\n    private int countRightZeros(int[] row)\\n    {\\n        int cnt = 0;\\n        for(int i = row.length - 1; i >= 0; i--)\\n        {\\n            if(row[i] != 0)\\n                break;\\n            cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556882,
                "title": "go",
                "content": "```\\nfunc minSwaps(grid [][]int) int {\\n    n := len(grid)\\n    var list []int\\n    for i := 0; i < n; i++ {\\n        cnt := 0\\n        for j := n - 1; j >= 0; j-- {\\n            if grid[i][j] == 0 {\\n                cnt++\\n            } else {\\n                break\\n            }\\n        }\\n        list = append(list, cnt)\\n    }\\n    res := 0\\n    LOOP:\\n    for i := 0; i < n; i++ {\\n        if list[i] >= n - 1 - i {\\n            continue\\n        } else {\\n            for j := i + 1; j < n; j++ {\\n                if list[j] >= n - 1 - i {\\n                    for k := j - 1; k >= i; k-- {\\n                        list[k], list[k + 1] = list[k + 1], list[k]\\n                        res++\\n                    }\\n                    continue LOOP\\n                }\\n            }\\n            return -1\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minSwaps(grid [][]int) int {\\n    n := len(grid)\\n    var list []int\\n    for i := 0; i < n; i++ {\\n        cnt := 0\\n        for j := n - 1; j >= 0; j-- {\\n            if grid[i][j] == 0 {\\n                cnt++\\n            } else {\\n                break\\n            }\\n        }\\n        list = append(list, cnt)\\n    }\\n    res := 0\\n    LOOP:\\n    for i := 0; i < n; i++ {\\n        if list[i] >= n - 1 - i {\\n            continue\\n        } else {\\n            for j := i + 1; j < n; j++ {\\n                if list[j] >= n - 1 - i {\\n                    for k := j - 1; k >= i; k-- {\\n                        list[k], list[k + 1] = list[k + 1], list[k]\\n                        res++\\n                    }\\n                    continue LOOP\\n                }\\n            }\\n            return -1\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1508193,
                "title": "c-o-n-2-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void swap(vector<int>&index, int i, int j){\\n        int temp = index[i];\\n        index[i] = index[j];\\n        index[j] = temp;\\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int>index(n);\\n        int i, j, k, l;\\n        for(i = 0; i < n; i++){\\n            k = 0;\\n            for(j = n - 1; j >= 0; j--){\\n                if(grid[i][j] == 0){\\n                    k++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            index[i] = k;\\n        }\\n        int ans = 0;\\n        for(i = 0; i < n; i++){\\n            j = n - 1 - i;\\n            for(k = i; k < n; k++){\\n                if(index[k] >= j){\\n                    break;\\n                }\\n            }\\n            if(k == n){\\n                return -1;\\n            }\\n            else{\\n                for(l = k; l > i; l--){\\n                    swap(index, l, l - 1);\\n                }\\n                ans += k - i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void swap(vector<int>&index, int i, int j){\\n        int temp = index[i];\\n        index[i] = index[j];\\n        index[j] = temp;\\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int>index(n);\\n        int i, j, k, l;\\n        for(i = 0; i < n; i++){\\n            k = 0;\\n            for(j = n - 1; j >= 0; j--){\\n                if(grid[i][j] == 0){\\n                    k++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            index[i] = k;\\n        }\\n        int ans = 0;\\n        for(i = 0; i < n; i++){\\n            j = n - 1 - i;\\n            for(k = i; k < n; k++){\\n                if(index[k] >= j){\\n                    break;\\n                }\\n            }\\n            if(k == n){\\n                return -1;\\n            }\\n            else{\\n                for(l = k; l > i; l--){\\n                    swap(index, l, l - 1);\\n                }\\n                ans += k - i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483615,
                "title": "short-c-solution-by-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), res;\\n        if(n<=1) return 0;   // Base Case\\n\\t\\t\\n        int m = grid[0].size();\\n        bool flag=true;\\n\\t\\t\\n        for(int i=0; i<n; i++)\\n\\t\\t{\\n            for(int j=m-1; j>m-n; j--)\\n                if(grid[i][j] == 1)\\n\\t\\t\\t\\t{\\n                    flag=false;\\n                    break;\\n                }\\n            if(flag==true)\\n\\t\\t\\t{\\n                grid.erase(grid.begin()+i);\\n                res = minSwaps(grid);\\n                return (res+i>=i) ? i+res : -1;\\n            }\\n            flag=true;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), res;\\n        if(n<=1) return 0;   // Base Case\\n\\t\\t\\n        int m = grid[0].size();\\n        bool flag=true;\\n\\t\\t\\n        for(int i=0; i<n; i++)\\n\\t\\t{\\n            for(int j=m-1; j>m-n; j--)\\n                if(grid[i][j] == 1)\\n\\t\\t\\t\\t{\\n                    flag=false;\\n                    break;\\n                }\\n            if(flag==true)\\n\\t\\t\\t{\\n                grid.erase(grid.begin()+i);\\n                res = minSwaps(grid);\\n                return (res+i>=i) ? i+res : -1;\\n            }\\n            flag=true;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473577,
                "title": "python-greedy-without-actually-swap-the-array",
                "content": "Count trailing zeros for each row and build an array. For each element in the array, if it doesn\\'t satisfy its requirements, find the nearest element on its right which is good, and swap them. At the same time, plus the cost of swaps to the result. If no good element can\\'t be found, then return \"-1\".\\n\\nBy marking swapped element in the array as \"-1\" and tracking a variable \"shift\" ,we can avoid the cost of actually rearranging the element in the array after swapping. \\n\\nHere is my code:\\n\\'\\'\\'\\nclass Solution:\\n\\n\\tdef minSwaps(self, grid: List[List[int]]) -> int:\\t\\n        N = len(grid)\\n        def count_zeros(row):\\n            i = len(row) - 1\\n            while i >= 0 and not row[i]:\\n                i -= 1\\n            return len(row) - 1 - i\\n        \\n        # zeors[i] == -1 means it has been swapped\\n        zeros = [count_zeros(row) for row in grid]\\n        def find_nearest_alter(i, demand):\\n            cost = 0\\n            j = i\\n            while j < N and (zeros[j] < demand):\\n                # only count the number of elements which haven\\'t been swapped as a cost\\n                cost += (zeros[j] >= 0)\\n                j += 1\\n            return j, cost\\n        \\n        i = res = shift = 0\\n        while i + shift < N:\\n            # the ith element has been swapped.\\n            if zeros[i] < 0:\\n                i += 1\\n                shift -= 1\\n                continue\\n            \\n            # uses shift to calculate the actual number of cur row: (i + shift) and get the demand of it\\n            demand = N - (i + shift) - 1\\n            if zeros[i] < demand:\\n                j, cost = find_nearest_alter(i, demand)\\n                \\n                # return if the next good element can\\'t be found\\n                if j == N:\\n                    return -1\\n                \\n                # mark the jth element as swapped by changing its value to -1\\n                zeros[j] = -1\\n                res += cost\\n                shift += 1\\n            else:\\n                i += 1\\n        return res\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "Count trailing zeros for each row and build an array. For each element in the array, if it doesn\\'t satisfy its requirements, find the nearest element on its right which is good, and swap them. At the same time, plus the cost of swaps to the result. If no good element can\\'t be found, then return \"-1\".\\n\\nBy marking swapped element in the array as \"-1\" and tracking a variable \"shift\" ,we can avoid the cost of actually rearranging the element in the array after swapping. \\n\\nHere is my code:\\n\\'\\'\\'\\nclass Solution:\\n\\n\\tdef minSwaps(self, grid: List[List[int]]) -> int:\\t\\n        N = len(grid)\\n        def count_zeros(row):\\n            i = len(row) - 1\\n            while i >= 0 and not row[i]:\\n                i -= 1\\n            return len(row) - 1 - i\\n        \\n        # zeors[i] == -1 means it has been swapped\\n        zeros = [count_zeros(row) for row in grid]\\n        def find_nearest_alter(i, demand):\\n            cost = 0\\n            j = i\\n            while j < N and (zeros[j] < demand):\\n                # only count the number of elements which haven\\'t been swapped as a cost\\n                cost += (zeros[j] >= 0)\\n                j += 1\\n            return j, cost\\n        \\n        i = res = shift = 0\\n        while i + shift < N:\\n            # the ith element has been swapped.\\n            if zeros[i] < 0:\\n                i += 1\\n                shift -= 1\\n                continue\\n            \\n            # uses shift to calculate the actual number of cur row: (i + shift) and get the demand of it\\n            demand = N - (i + shift) - 1\\n            if zeros[i] < demand:\\n                j, cost = find_nearest_alter(i, demand)\\n                \\n                # return if the next good element can\\'t be found\\n                if j == N:\\n                    return -1\\n                \\n                # mark the jth element as swapped by changing its value to -1\\n                zeros[j] = -1\\n                res += cost\\n                shift += 1\\n            else:\\n                i += 1\\n        return res\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1455050,
                "title": "o-n-2-java-solution",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int []arr = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    break;\\n                }\\n                arr[i]++;\\n            }\\n        }\\n\\n        int sum = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            boolean notfound = true;\\n            for (int j = 0; j < n; j++) {\\n                if (set.contains(j)) {\\n                    continue;\\n                }\\n                if (arr[j] >= i) {\\n                    set.add(j);\\n                    notfound = false;\\n                    break;\\n                } else {\\n                    sum++;\\n                }\\n            }\\n            if (notfound) {\\n                return -1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int []arr = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    break;\\n                }\\n                arr[i]++;\\n            }\\n        }\\n\\n        int sum = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            boolean notfound = true;\\n            for (int j = 0; j < n; j++) {\\n                if (set.contains(j)) {\\n                    continue;\\n                }\\n                if (arr[j] >= i) {\\n                    set.add(j);\\n                    notfound = false;\\n                    break;\\n                } else {\\n                    sum++;\\n                }\\n            }\\n            if (notfound) {\\n                return -1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399169,
                "title": "java-bubble-sort-hashset-o-n2-time-o-n-space-soution",
                "content": "```\\n// using bubble sort to count no of swaps\\nclass Solution {\\n\\n    public int minSwaps(int[][] grid) {\\n        int res = 0;\\n        \\n        int n = grid.length;\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        // fill the array with no of trailing zeroes in each row\\n        int[] arr = new int[n];        \\n        \\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            int j = n-1;\\n            \\n            while(j >= 0 && grid[i][j--] == 0) count++;\\n            \\n            \\n            // if the number of trailing zeroes is greater than required then \\n            // cut down the zeroes to required only\\n            if (set.contains(count)) {\\n                while (set.contains(count)) {\\n                    count--;\\n                }\\n            }\\n            if (count < 0) continue;\\n            set.add(count);\\n            arr[i] = count;\\n        }\\n        \\n        // the set should now contain count of zeroes from 0 to n - 1 else \\n        // solution is not possible\\n        \\n        if(set.size() != n) return -1;\\n\\n        // bubble sort\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = 0; j < n - i - 1; j++) {\\n                if (arr[j + 1] > arr[j]) {\\n                    res++;\\n                    // swap arr[j+1] and arr[j]\\n                    int temp = arr[j];\\n                    arr[j] = arr[j+1];\\n                    arr[j+1] = temp;                    \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// using bubble sort to count no of swaps\\nclass Solution {\\n\\n    public int minSwaps(int[][] grid) {\\n        int res = 0;\\n        \\n        int n = grid.length;\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        // fill the array with no of trailing zeroes in each row\\n        int[] arr = new int[n];        \\n        \\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            int j = n-1;\\n            \\n            while(j >= 0 && grid[i][j--] == 0) count++;\\n            \\n            \\n            // if the number of trailing zeroes is greater than required then \\n            // cut down the zeroes to required only\\n            if (set.contains(count)) {\\n                while (set.contains(count)) {\\n                    count--;\\n                }\\n            }\\n            if (count < 0) continue;\\n            set.add(count);\\n            arr[i] = count;\\n        }\\n        \\n        // the set should now contain count of zeroes from 0 to n - 1 else \\n        // solution is not possible\\n        \\n        if(set.size() != n) return -1;\\n\\n        // bubble sort\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = 0; j < n - i - 1; j++) {\\n                if (arr[j + 1] > arr[j]) {\\n                    res++;\\n                    // swap arr[j+1] and arr[j]\\n                    int temp = arr[j];\\n                    arr[j] = arr[j+1];\\n                    arr[j+1] = temp;                    \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324765,
                "title": "java-1ms-100-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int minSwaps(int[][] grid) {\\n\\t\\t\\tint n=grid.length,count[]=new int[n],minSwaps=0;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint cnt=0;\\n\\t\\t\\t\\tfor(int j=n-1;j>=0 && grid[i][j]==0;j--)    cnt++;\\n\\t\\t\\t\\tcount[i]=cnt;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n && minSwaps!=-1;i++){\\n\\t\\t\\t\\tif(count[i]<n-i-1){\\n\\t\\t\\t\\t\\tint j=i;\\n\\t\\t\\t\\t\\twhile(j<n && count[j]<n-i-1)    j++;\\n\\t\\t\\t\\t\\tif(j<n && count[j]>=n-i-1){\\n\\t\\t\\t\\t\\t\\twhile(j>i){\\n\\t\\t\\t\\t\\t\\t\\tswap(count,j--);\\n\\t\\t\\t\\t\\t\\t\\tminSwaps++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse minSwaps=-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn minSwaps;\\n\\t\\t}\\n\\t\\tprivate void swap(int count[],int j){\\n\\t\\t\\tint t=count[j-1];\\n\\t\\t\\tcount[j-1]=count[j];\\n\\t\\t\\tcount[j--]=t;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int minSwaps(int[][] grid) {\\n\\t\\t\\tint n=grid.length,count[]=new int[n],minSwaps=0;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint cnt=0;\\n\\t\\t\\t\\tfor(int j=n-1;j>=0 && grid[i][j]==0;j--)    cnt++;\\n\\t\\t\\t\\tcount[i]=cnt;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1324019,
                "title": "c-easy-solution-100-beat",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int ans=0;\\n        vector<pair<int,int>>vec;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            int total=0;\\n            for(int j=grid.size()-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    total++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            vec.push_back({i,total});\\n        }\\n        for(int t=grid.size()-1;t>0;t--)\\n        {\\n            bool u=false;\\n            for(int j=0;j<vec.size();j++)\\n            {\\n                if(vec[j].second >= t)\\n                {\\n                    u=true;\\n                    ans+=(vec[j].first - vec[0].first);\\n                    for(int k=0;k<j;k++)\\n                    {\\n                        vec[k].first+=1;\\n                    }\\n                    vec.erase(vec.begin()+j);\\n                    break;\\n                }\\n            }\\n            if(u==false)\\n            {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int ans=0;\\n        vector<pair<int,int>>vec;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            int total=0;\\n            for(int j=grid.size()-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    total++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            vec.push_back({i,total});\\n        }\\n        for(int t=grid.size()-1;t>0;t--)\\n        {\\n            bool u=false;\\n            for(int j=0;j<vec.size();j++)\\n            {\\n                if(vec[j].second >= t)\\n                {\\n                    u=true;\\n                    ans+=(vec[j].first - vec[0].first);\\n                    for(int k=0;k<j;k++)\\n                    {\\n                        vec[k].first+=1;\\n                    }\\n                    vec.erase(vec.begin()+j);\\n                    break;\\n                }\\n            }\\n            if(u==false)\\n            {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280008,
                "title": "bubble-sort-javascript-solution-76-ms",
                "content": "```\\nvar minSwaps = function(grid) {\\n    const n = grid.length;\\n    const lastIndex = n - 1;\\n    const mostRight = new Array(n);\\n    let result = 0;\\n    let tmp;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        for (let j = lastIndex; j >= 0; --j) {\\n            if (grid[i][j] === 1) {\\n                mostRight[i] = j;\\n                break;\\n            }\\n        }\\n        if (mostRight[i] === undefined) mostRight[i] = -1;\\n    }\\n    \\n    for (let i = 0; i < lastIndex; ++i) {\\n        if (mostRight[i] <= i) continue;\\n        \\n        for (let j = i + 1; j < n; ++j) {\\n            if (mostRight[j] <= i) {\\n                while (j !== i) {\\n                    tmp = mostRight[j];\\n                    mostRight[j] = mostRight[j - 1];\\n                    mostRight[j - 1] = tmp;\\n                    ++result;\\n                    --j;\\n                }\\n                break;\\n            }\\n            if (j === lastIndex) return -1;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minSwaps = function(grid) {\\n    const n = grid.length;\\n    const lastIndex = n - 1;\\n    const mostRight = new Array(n);\\n    let result = 0;\\n    let tmp;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        for (let j = lastIndex; j >= 0; --j) {\\n            if (grid[i][j] === 1) {\\n                mostRight[i] = j;\\n                break;\\n            }\\n        }\\n        if (mostRight[i] === undefined) mostRight[i] = -1;\\n    }\\n    \\n    for (let i = 0; i < lastIndex; ++i) {\\n        if (mostRight[i] <= i) continue;\\n        \\n        for (let j = i + 1; j < n; ++j) {\\n            if (mostRight[j] <= i) {\\n                while (j !== i) {\\n                    tmp = mostRight[j];\\n                    mostRight[j] = mostRight[j - 1];\\n                    mostRight[j - 1] = tmp;\\n                    ++result;\\n                    --j;\\n                }\\n                break;\\n            }\\n            if (j === lastIndex) return -1;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1248647,
                "title": "javascript-greedy",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minSwaps = function(grid) {\\n    const nums = grid.map(row => row.lastIndexOf(1))\\n    const len = nums.length\\n    \\n    \\n    let result = 0\\n    for (let fromIndex = 0; fromIndex < len; fromIndex++) {\\n        let bestIndex = -1\\n        let bestVal = Infinity\\n        \\n        for (let i = fromIndex; i < len; i++) {\\n            const val = nums[i]\\n            if (val <= fromIndex) {\\n                bestIndex = i\\n                bestVal = val\\n                break\\n            }\\n        }\\n        if (bestIndex === -1)   return -1\\n        \\n        for (let i = bestIndex; i > fromIndex; i--) {\\n            nums[i] = nums[-1 + i]\\n        }\\n        nums[fromIndex] = bestVal\\n\\n        result += bestIndex - fromIndex\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minSwaps = function(grid) {\\n    const nums = grid.map(row => row.lastIndexOf(1))\\n    const len = nums.length\\n    \\n    \\n    let result = 0\\n    for (let fromIndex = 0; fromIndex < len; fromIndex++) {\\n        let bestIndex = -1\\n        let bestVal = Infinity\\n        \\n        for (let i = fromIndex; i < len; i++) {\\n            const val = nums[i]\\n            if (val <= fromIndex) {\\n                bestIndex = i\\n                bestVal = val\\n                break\\n            }\\n        }\\n        if (bestIndex === -1)   return -1\\n        \\n        for (let i = bestIndex; i > fromIndex; i--) {\\n            nums[i] = nums[-1 + i]\\n        }\\n        nums[fromIndex] = bestVal\\n\\n        result += bestIndex - fromIndex\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1248181,
                "title": "c-approach",
                "content": "since this is **good and standard question** ,,  dry run please \\n\\none thing i expect from you is at first sight you will see the final ans where you found out that every row will have fixed number of zeros for valid test case.\\nso your work is to replace all the grid at their best position .. \\nso , for that you must have to know that at any index total zeros count required here is at which grid .. once you store this .. now\\nyou just have to bring that grid at their best position .. \\n*key point*: in this process those grid which should have to be in upper grid they will reaching at their grid ... a valid test case will always push rest grid at their position \\nyour work is to swap current grid to respective place ,rest will replaced auto.\\ni\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        // ios_base::sync_with_stdio(false);\\n        // cin.tie(NULL);\\n        // cout.tie(NULL);\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> vect;\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=m-1;j>=0;j--){\\n                if(grid[i][j]==0){\\n                    count++;\\n                }\\n                else{\\n                    vect.push_back(count);\\n                    break;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        n=vect.size();\\n        for (int i=0; i<n; i++) {\\n            //check that if vect[i] is at right position or it should go down \\n            //a good valid test case will always arrange itself because when you finding right place\\n            //to place that index you will find or not .will indicate you vaid test case or not\\n            // we have to just swap\\n            if (vect[i] < (n-i-1)) {\\n                int k=i;\\n                while (k < n && vect[k] < (n-i-1)) {\\n                    k++;\\n                }\\n\\t\\t\\t\\t//here if we didn\\'t find valid position then swapping means nothing at the end.\\n                if (k == n) {     \\n                    return -1;  \\n                }\\n                while (k>i) {\\n                    swap(vect[k], vect[k-1]);\\n                    ans++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        // ios_base::sync_with_stdio(false);\\n        // cin.tie(NULL);\\n        // cout.tie(NULL);\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> vect;\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=m-1;j>=0;j--){\\n                if(grid[i][j]==0){\\n                    count++;\\n                }\\n                else{\\n                    vect.push_back(count);\\n                    break;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        n=vect.size();\\n        for (int i=0; i<n; i++) {\\n            //check that if vect[i] is at right position or it should go down \\n            //a good valid test case will always arrange itself because when you finding right place\\n            //to place that index you will find or not .will indicate you vaid test case or not\\n            // we have to just swap\\n            if (vect[i] < (n-i-1)) {\\n                int k=i;\\n                while (k < n && vect[k] < (n-i-1)) {\\n                    k++;\\n                }\\n\\t\\t\\t\\t//here if we didn\\'t find valid position then swapping means nothing at the end.\\n                if (k == n) {     \\n                    return -1;  \\n                }\\n                while (k>i) {\\n                    swap(vect[k], vect[k-1]);\\n                    ans++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1236145,
                "title": "swift-solution-bubble-sort",
                "content": "Solution explained in comments\\n```\\nclass Solution {\\n    func minSwaps(_ grid: [[Int]]) -> Int {\\n        let n = grid.count\\n        var result = 0\\n        // For each row of the grid calculate the most right 1 in the grid in the array maxRight\\n        var maxRight = grid.reduce(into: [Int](), { $0.append($1.lastIndex(where: { $0 == 1 }) ?? 0) })\\n        // To check if there exist answer, sort maxRight and check if maxRight[i] \\u2264 i for all possible i\\'s\\n        for (i, v) in Array(0..<n).sorted(by: { maxRight[$0] < maxRight[$1] }).enumerated() where maxRight[v] > i {\\n            return -1\\n        }\\n        // An answer exists, let\\'s simulate the swaps using bubble sort\\n        forrow1: for row1 in 0..<(n - 1) where maxRight[row1] > row1 { // for all rows that requires swap\\n            for row2 in (row1 + 1)..<n where maxRight[row2] <= row1 { // find nearest suitable row\\n                for row in stride(from: row2, to: row1, by: -1) { // apply swaps (bubble pops up)\\n                    maxRight.swapAt(row, row - 1)\\n                    result += 1\\n                }\\n                continue forrow1 // proceed next row\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minSwaps(_ grid: [[Int]]) -> Int {\\n        let n = grid.count\\n        var result = 0\\n        // For each row of the grid calculate the most right 1 in the grid in the array maxRight\\n        var maxRight = grid.reduce(into: [Int](), { $0.append($1.lastIndex(where: { $0 == 1 }) ?? 0) })\\n        // To check if there exist answer, sort maxRight and check if maxRight[i] \\u2264 i for all possible i\\'s\\n        for (i, v) in Array(0..<n).sorted(by: { maxRight[$0] < maxRight[$1] }).enumerated() where maxRight[v] > i {\\n            return -1\\n        }\\n        // An answer exists, let\\'s simulate the swaps using bubble sort\\n        forrow1: for row1 in 0..<(n - 1) where maxRight[row1] > row1 { // for all rows that requires swap\\n            for row2 in (row1 + 1)..<n where maxRight[row2] <= row1 { // find nearest suitable row\\n                for row in stride(from: row2, to: row1, by: -1) { // apply swaps (bubble pops up)\\n                    maxRight.swapAt(row, row - 1)\\n                    result += 1\\n                }\\n                continue forrow1 // proceed next row\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194951,
                "title": "c-brutal-force",
                "content": "* We can figure out that for ith row, the index of last 1 has to be <= i. So we rearrange the rows and check which one should be the 1st, 2nd, ... up to the end.\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int size = grid.size(), res = 0;\\n        for (int i = 0; i < size; ++i)\\n        {\\n            int j = i;\\n            while (j < size)\\n            {\\n                int k = size - 1;\\n                while (k >= 0 && grid[j][k] == 0)\\n                {\\n                    --k;\\n                }\\n                \\n                if (k <= i)\\n                {\\n                    res += j - i;\\n                    for (int r = j; r > i; --r)\\n                    {\\n                        swap(grid[r], grid[r - 1]);\\n                    }\\n                    \\n                    break;\\n                }\\n                \\n                ++j;\\n            }\\n            \\n            if (j >= size)\\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int size = grid.size(), res = 0;\\n        for (int i = 0; i < size; ++i)\\n        {\\n            int j = i;\\n            while (j < size)\\n            {\\n                int k = size - 1;\\n                while (k >= 0 && grid[j][k] == 0)\\n                {\\n                    --k;\\n                }\\n                \\n                if (k <= i)\\n                {\\n                    res += j - i;\\n                    for (int r = j; r > i; --r)\\n                    {\\n                        swap(grid[r], grid[r - 1]);\\n                    }\\n                    \\n                    break;\\n                }\\n                \\n                ++j;\\n            }\\n            \\n            if (j >= size)\\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182836,
                "title": "two-indices-90-speed",
                "content": "Runtime: 504 ms, faster than 90.43% of Python3 online submissions for Minimum Swaps to Arrange a Binary Grid.\\nMemory Usage: 15.4 MB, less than 58.26% of Python3 online submissions for Minimum Swaps to Arrange a Binary Grid.\\n```\\nclass Solution:\\n    def minSwaps(self, grid) -> int:\\n        n = len(grid)\\n        max_right = [-1] * n\\n        for r, row in enumerate(grid):\\n            for c in range(n - 1, -1, -1):\\n                if row[c] == 1:\\n                    max_right[r] = c\\n                    break\\n        if all(v <= i for i, v in enumerate(sorted(max_right))):\\n            swaps = 0\\n            i = 0\\n            while i < n:\\n                while i < n and max_right[i] <= i:\\n                    i += 1\\n                if i == n:\\n                    break\\n                j = i\\n                while j < n and max_right[j] > i:\\n                    j += 1\\n                swaps += j - i\\n                max_right[i], max_right[i + 1: j + 1] = (max_right[j],\\n                                                         max_right[i: j])\\n                i += 1\\n            return swaps\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid) -> int:\\n        n = len(grid)\\n        max_right = [-1] * n\\n        for r, row in enumerate(grid):\\n            for c in range(n - 1, -1, -1):\\n                if row[c] == 1:\\n                    max_right[r] = c\\n                    break\\n        if all(v <= i for i, v in enumerate(sorted(max_right))):\\n            swaps = 0\\n            i = 0\\n            while i < n:\\n                while i < n and max_right[i] <= i:\\n                    i += 1\\n                if i == n:\\n                    break\\n                j = i\\n                while j < n and max_right[j] > i:\\n                    j += 1\\n                swaps += j - i\\n                max_right[i], max_right[i + 1: j + 1] = (max_right[j],\\n                                                         max_right[i: j])\\n                i += 1\\n            return swaps\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180631,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int> a;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(grid[i][n - 1] == 0) {\\n                int j = n - 1;\\n                count++;\\n                while(j > 0 && grid[i][j] == grid[i][j - 1]) {\\n                    j--;\\n                    count++;\\n                }\\n            }\\n            a.emplace_back(count);\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(a[i] < n - i - 1) {\\n                int pos = -1;\\n                for(int j = i + 1; j < n; j++) {\\n                    if(a[j] >= n - 1 - i) {\\n                        pos = j;\\n                        break;\\n                    }\\n                }\\n                if(pos == -1) {\\n                    return -1;\\n                }\\n                int val = a[pos];\\n                while(pos > i) {\\n                    a[pos] = a[pos - 1];\\n                    pos--;\\n                    ans++;\\n                }\\n                a[i] = val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int> a;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(grid[i][n - 1] == 0) {\\n                int j = n - 1;\\n                count++;\\n                while(j > 0 && grid[i][j] == grid[i][j - 1]) {\\n                    j--;\\n                    count++;\\n                }\\n            }\\n            a.emplace_back(count);\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(a[i] < n - i - 1) {\\n                int pos = -1;\\n                for(int j = i + 1; j < n; j++) {\\n                    if(a[j] >= n - 1 - i) {\\n                        pos = j;\\n                        break;\\n                    }\\n                }\\n                if(pos == -1) {\\n                    return -1;\\n                }\\n                int val = a[pos];\\n                while(pos > i) {\\n                    a[pos] = a[pos - 1];\\n                    pos--;\\n                    ans++;\\n                }\\n                a[i] = val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139339,
                "title": "python-3-bubble-sort-o-n-2",
                "content": "Similar algorithm as bubble sort. Search for the first valid row and move it to the top, and repeat the process.\\n```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        ans = 0\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if grid[i][j] != 0:\\n                    break\\n            else:\\n                continue\\n            for k in range(i+1, n):\\n                if grid[k][i+1:] == [0] * (n-i-1):\\n                    ans += (k-i)\\n                    grid[i:k+1] = grid[k:k+1] + grid[i:k]  \\n                    break\\n            else:\\n                return -1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        ans = 0\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if grid[i][j] != 0:\\n                    break\\n            else:\\n                continue\\n            for k in range(i+1, n):\\n                if grid[k][i+1:] == [0] * (n-i-1):\\n                    ans += (k-i)\\n                    grid[i:k+1] = grid[k:k+1] + grid[i:k]  \\n                    break\\n            else:\\n                return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096785,
                "title": "java-solution-with-arraylist",
                "content": "\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        List<Integer> l = new ArrayList<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = grid[i].length-1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    l.add(j);\\n                    break;\\n                }\\n            }\\n            if (l.size() < i+1) l.add(0);\\n        }\\n        \\n        int res = 0;\\n        // System.out.println(l);\\n        for (int i = 0; i < l.size(); i++) {\\n            if (l.get(i) <= i) continue;\\n            int k = -1;\\n            for (int j = i + 1; j < l.size(); j++) {\\n                if (l.get(j) <= i) {\\n                    k = j;\\n                    break;\\n                }\\n            }\\n            if (k == -1) return -1;\\n            int v = l.remove(k);\\n            l.add(0, v);\\n            // System.out.println(l);\\n            res += k - i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        List<Integer> l = new ArrayList<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = grid[i].length-1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    l.add(j);\\n                    break;\\n                }\\n            }\\n            if (l.size() < i+1) l.add(0);\\n        }\\n        \\n        int res = 0;\\n        // System.out.println(l);\\n        for (int i = 0; i < l.size(); i++) {\\n            if (l.get(i) <= i) continue;\\n            int k = -1;\\n            for (int j = i + 1; j < l.size(); j++) {\\n                if (l.get(j) <= i) {\\n                    k = j;\\n                    break;\\n                }\\n            }\\n            if (k == -1) return -1;\\n            int v = l.remove(k);\\n            l.add(0, v);\\n            // System.out.println(l);\\n            res += k - i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026690,
                "title": "python-greedy-o-n-2",
                "content": "First, count the number of trailing 0s for each row as zeros.\\nSecond, for i-th row, which needs n - i - 1 trailing 0s, just find the nearest j that j >= i and zeros[j] >= n - i - 1, then the swap operation needed is j - i - 1, so that j-th row move forward to i-th row. If deque is applied to zeros, then zeros denotes the rows not used. for i-th row, find the nearest j that zeros[j] >= n - i - 1, then the swap operation needed is j. Then pop j-th since it is used.\\n```\\nclass Solution(object):\\n    def minSwaps(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        zeros = []\\n        need = n - 1\\n        ans = 0\\n        for i in range(n):\\n            cur_zeros = n\\n            for j in range(n - 1, -1, -1):\\n                if grid[i][j] == 1:\\n                    cur_zeros = n - j - 1\\n                    break\\n            zeros.append(cur_zeros)\\n        while zeros:\\n            for i in range(len(zeros)):\\n                if zeros[i] >= need:\\n                    need -= 1\\n                    break\\n            else:\\n                return -1\\n            ans += i\\n            zeros.pop(i)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minSwaps(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        zeros = []\\n        need = n - 1\\n        ans = 0\\n        for i in range(n):\\n            cur_zeros = n\\n            for j in range(n - 1, -1, -1):\\n                if grid[i][j] == 1:\\n                    cur_zeros = n - j - 1\\n                    break\\n            zeros.append(cur_zeros)\\n        while zeros:\\n            for i in range(len(zeros)):\\n                if zeros[i] >= need:\\n                    need -= 1\\n                    break\\n            else:\\n                return -1\\n            ans += i\\n            zeros.pop(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024982,
                "title": "java-greedy",
                "content": "LinkedList should be used but arraylist is faster somehow\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int rows = grid.length;\\n        List<Integer> l = new ArrayList();\\n        for(int i=0; i<rows; i++)\\n            l.add(getTrailZeros(grid, i));\\n        int res = 0;\\n        while(l.size()>1){\\n            int expect = l.size()-1;\\n            if(l.get(0)>=expect){\\n                l.remove(0);\\n                continue;\\n            }\\n            for(int j=1; j<l.size(); j++){\\n                if(l.get(j)>=expect){\\n                    res += j;\\n                    l.remove(j);\\n                    break;\\n                }\\n            }\\n            if(l.size() == expect+1)\\n                return -1;\\n        }\\n        return res;\\n    }\\n    public int getTrailZeros(int[][] grid, int idx){\\n        int len = grid.length;\\n        int cnt = 0;\\n        for(int i=len-1; i>=0; i--){\\n            if(grid[idx][i] == 0)\\n                cnt++;\\n            else\\n                break;\\n        }\\n        return cnt;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minSwaps(int[][] grid) {\\n        int rows = grid.length;\\n        List<Integer> l = new ArrayList();\\n        for(int i=0; i<rows; i++)\\n            l.add(getTrailZeros(grid, i));\\n        int res = 0;\\n        while(l.size()>1){\\n            int expect = l.size()-1;\\n            if(l.get(0)>=expect){\\n                l.remove(0);\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1014602,
                "title": "c-100-100",
                "content": "class Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& v)\\n    {\\n        int n=v.size();\\n        //int m=v[0].size();\\n        int dp[n];\\n        for(int i=0;i<n;i++)\\n            dp[i]=-1;\\n        \\n        for(int i=0;i<n;i++)\\n        {  \\n            int x=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(v[i][j]==1)\\n                {\\n                    x=j;\\n                    break;\\n                }\\n            }\\n            int t=0;\\n            while(x+t<n && dp[x+t]!=-1)\\n                t++;\\n            \\n            if(x+t==n)\\n                return -1;\\n            else\\n                dp[x+t]=i;\\n        }\\n        int ans=0;\\n        for(int j=0;j<n;j++)\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(dp[i]>dp[i+1])\\n                {swap(dp[i],dp[i+1]);\\n                    ans++;}\\n                \\n            }\\n        \\n       for(int i=0;i<n;i++)\\n            cout<<dp[i]<<\" \";\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& v)\\n    {\\n        int n=v.size();\\n        //int m=v[0].size();\\n        int dp[n];\\n        for(int i=0;i<n;i++)\\n            dp[i]=-1;\\n        \\n        for(int i=0;i<n;i++)\\n        {  \\n            int x=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(v[i][j]==1)\\n                {\\n                    x=j;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1004162,
                "title": "c-short-solution",
                "content": "Run-time is `O(N^2)`, space is `O(N)`. Idea is to greedily pick the closest row that works (has enough trailing zeros). Implementation using a list is slightly faster (do not need a second pass to shift elements to the right after removing the target row). But the run-time using a vector implementation will still be `O(N^2)`. \\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        std::list<int> rows;\\n        int size{(int)grid.size()};\\n        for(const auto &r: grid) {\\n            int i{size-1}, count{0};\\n            while(i >= 0 && r[i] == 0) ++count, --i;\\n            rows.emplace_back(count);\\n        }\\n        \\n        int cost{0};\\n        for(int i{size-1}; i > 0; --i) {\\n            int l{0};\\n            for(auto it{rows.begin()}; it != rows.end(); ++it, ++l) {\\n                if(*it >= i) {\\n                    cost += l, rows.erase(it);\\n                    goto next;\\n                }\\n            }\\n            \\n            return -1;\\n            \\n            next:\\n            continue;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        std::list<int> rows;\\n        int size{(int)grid.size()};\\n        for(const auto &r: grid) {\\n            int i{size-1}, count{0};\\n            while(i >= 0 && r[i] == 0) ++count, --i;\\n            rows.emplace_back(count);\\n        }\\n        \\n        int cost{0};\\n        for(int i{size-1}; i > 0; --i) {\\n            int l{0};\\n            for(auto it{rows.begin()}; it != rows.end(); ++it, ++l) {\\n                if(*it >= i) {\\n                    cost += l, rows.erase(it);\\n                    goto next;\\n                }\\n            }\\n            \\n            return -1;\\n            \\n            next:\\n            continue;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993046,
                "title": "java-greedy-77",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        //strategy: Greedy\\n        int n = grid.length, answer = 0;\\n        //calculate the length of the trailing zeroes\\n        ArrayList<Integer> trailing = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            int count = 0;\\n            //go from the back until we reach a one\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    break;\\n                } else {\\n                    count++;\\n                }\\n            }\\n            //add to ArrayList\\n            trailing.add(count);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            //this is the needed amt to curr row valid\\n            int needed = n - i - 1;\\n            boolean flag = false;\\n            //only needed to check ith row onwards because we already set up the first ith rows\\n            for (int j = i; j < n; j++) {\\n                //find the closest row\\n                if (trailing.get(j) >= needed) {\\n                    //add to swaps\\n                    answer += j - i;\\n                    //simulate swaps\\n                    trailing.add(i, trailing.remove(j));\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            //didn\\'t find it\\n            if (!flag) {\\n                return -1;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        //strategy: Greedy\\n        int n = grid.length, answer = 0;\\n        //calculate the length of the trailing zeroes\\n        ArrayList<Integer> trailing = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            int count = 0;\\n            //go from the back until we reach a one\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    break;\\n                } else {\\n                    count++;\\n                }\\n            }\\n            //add to ArrayList\\n            trailing.add(count);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            //this is the needed amt to curr row valid\\n            int needed = n - i - 1;\\n            boolean flag = false;\\n            //only needed to check ith row onwards because we already set up the first ith rows\\n            for (int j = i; j < n; j++) {\\n                //find the closest row\\n                if (trailing.get(j) >= needed) {\\n                    //add to swaps\\n                    answer += j - i;\\n                    //simulate swaps\\n                    trailing.add(i, trailing.remove(j));\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            //didn\\'t find it\\n            if (!flag) {\\n                return -1;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982817,
                "title": "java-greedy-approach-using-list-of-trailing-zeros",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n\\n        int swaps = 0;\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int[] arr : grid) {\\n            list.add(trailingZeros(arr));\\n        }\\n        // For the first level we are expecting at least n-1 zeros, so start with that\\n\\t\\t// Iterate through the list, once an index matches where we have at least expected amount use it and delete\\n        // Since we are using a greedy approach, first selection would give the best outcome\\n\\t\\tfor(int i = grid.length - 1; i > 0; i--) {\\n            boolean found = false;\\n            for(int j = 0; j < list.size(); j++) {\\n                if(list.get(j) >= i) {\\n                    swaps += j;\\n                    list.remove(j);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(!found) return -1;\\n        }\\n        \\n        return swaps;\\n    }\\n    private int trailingZeros(int[] grid) {\\n        int count = 0;\\n        for(int j = grid.length - 1; j >= 0; j--) {\\n            if(grid[j] == 0) {\\n                count++;\\n            } else break;\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n\\n        int swaps = 0;\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int[] arr : grid) {\\n            list.add(trailingZeros(arr));\\n        }\\n        // For the first level we are expecting at least n-1 zeros, so start with that\\n\\t\\t// Iterate through the list, once an index matches where we have at least expected amount use it and delete\\n        // Since we are using a greedy approach, first selection would give the best outcome\\n\\t\\tfor(int i = grid.length - 1; i > 0; i--) {\\n            boolean found = false;\\n            for(int j = 0; j < list.size(); j++) {\\n                if(list.get(j) >= i) {\\n                    swaps += j;\\n                    list.remove(j);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(!found) return -1;\\n        }\\n        \\n        return swaps;\\n    }\\n    private int trailingZeros(int[] grid) {\\n        int count = 0;\\n        for(int j = grid.length - 1; j >= 0; j--) {\\n            if(grid[j] == 0) {\\n                count++;\\n            } else break;\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979200,
                "title": "python-linked-list-version",
                "content": "- The idea is greedy (same as most of other posts). \\n- For implementation, I used a linkedlist here. No significant improvement or disadvantage here. passed with \"faster than 70%\"\\n```\\nclass Node:\\n    def __init__(self, val = 0, nxt = None):\\n        self.val = val\\n        self.nxt = nxt\\n\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        # convert to array\\n        head = Node()\\n        p = head\\n        for row in grid:\\n            for i in range(len(row)-1,-1,-1):\\n                if row[i] == 1: break\\n            p.nxt = Node(len(row)-1-i)\\n            p = p.nxt\\n        \\n        # find target one by one\\n        res = 0\\n        targets = list(range(len(grid)-1,-1,-1))\\n        for t in targets:\\n            q, p = head, head.nxt\\n            while p and p.val < t:\\n                p = p.nxt\\n                q = q.nxt\\n                res += 1\\n            if not p:\\n                return -1\\n            q.nxt = p.nxt\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self, val = 0, nxt = None):\\n        self.val = val\\n        self.nxt = nxt\\n\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        # convert to array\\n        head = Node()\\n        p = head\\n        for row in grid:\\n            for i in range(len(row)-1,-1,-1):\\n                if row[i] == 1: break\\n            p.nxt = Node(len(row)-1-i)\\n            p = p.nxt\\n        \\n        # find target one by one\\n        res = 0\\n        targets = list(range(len(grid)-1,-1,-1))\\n        for t in targets:\\n            q, p = head, head.nxt\\n            while p and p.val < t:\\n                p = p.nxt\\n                q = q.nxt\\n                res += 1\\n            if not p:\\n                return -1\\n            q.nxt = p.nxt\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956039,
                "title": "java",
                "content": "Replace each rows first entry with count of consecutive zeroes at end of row\\nNow for a row i, it must have coutnConsecZeroes >= n-row-1\\nFor examplt at row 0, must have n-0-1 consec zeroes at first row\\nNow for a current row, go down and as soon as we find grid[r ][0] >= n-row-1, for all r>row and  r<n\\nNow if r>=n , not able to find approiate row for currentRow, then return -1\\nelse perform (r-currRow) swaps as thses many will make r row to swap current\\nAlso push down values from currentRow to r\\n7\\n6\\n4\\n3\\n1\\n5\\n6 \\nNow after swap 6(last) with 7\\n6\\n7\\n6\\n4\\n3\\n1\\n5\\nThis work because we go from top to down so if the first row down works for currentRow, then if some greater ele row is prsent it can take the smaller ones",
                "solutionTags": [],
                "code": "Replace each rows first entry with count of consecutive zeroes at end of row\\nNow for a row i, it must have coutnConsecZeroes >= n-row-1\\nFor examplt at row 0, must have n-0-1 consec zeroes at first row\\nNow for a current row, go down and as soon as we find grid[r ][0] >= n-row-1, for all r>row and  r<n\\nNow if r>=n , not able to find approiate row for currentRow, then return -1\\nelse perform (r-currRow) swaps as thses many will make r row to swap current\\nAlso push down values from currentRow to r\\n7\\n6\\n4\\n3\\n1\\n5\\n6 \\nNow after swap 6(last) with 7\\n6\\n7\\n6\\n4\\n3\\n1\\n5\\nThis work because we go from top to down so if the first row down works for currentRow, then if some greater ele row is prsent it can take the smaller ones",
                "codeTag": "C++"
            },
            {
                "id": 937289,
                "title": "c-greedy-list",
                "content": "class Solution {\\npublic:\\n    \\n\\tint minSwaps(vector<vector<int>>& grid) {\\n        ListNode root;\\n        ListNode *cur = &root;\\n        int n = grid.size();\\n        for (int i=0; i<n; ++i) {\\n            int zeroCnt = 0;\\n            for (int j=n-1; j>=1; j--) {\\n                if (grid[i][j]!=0) break;\\n                zeroCnt++;\\n            }\\n            cur->next = new ListNode(zeroCnt);\\n            cur = cur->next;\\n        }\\n        cur = root.next;\\n        int rowIdx = 0;\\n        int ans = 0;\\n        while (cur && rowIdx<n) {\\n            int targetCnt = n - 1 - rowIdx++;\\n            ListNode* tn = cur;\\n            ListNode* pre = NULL;\\n            int swapCnt = 0;\\n            // greedy to find the nearest available targetCnt\\n            while (tn && tn->val < targetCnt) {\\n                pre = tn;\\n                tn = tn->next;\\n                swapCnt++;\\n            }\\n            // return -1 if no valid found\\n            if (!tn) return -1;\\n            // add the swapCnt\\n            ans += swapCnt;\\n            // Adjust the list after swap\\n            // Basically, it could be regarded as the targetCnt node\\n            // is removed from the original position\\n            // c     tn\\n            // 4->3->5->2->1\\n            // <After sdjacent wap process>\\n            // tn c\\n            // 5->4->3->2->1\\n            if (!pre) {\\n                cur = cur->next;\\n            } else {\\n                pre->next = tn->next;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n\\tint minSwaps(vector<vector<int>>& grid) {\\n        ListNode root;\\n        ListNode *cur = &root;\\n        int n = grid.size();\\n        for (int i=0; i<n; ++i) {\\n            int zeroCnt = 0;\\n            for (int j=n-1; j>=1; j--) {\\n                if (grid[i][j]!=0) break;\\n                zeroCnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 891723,
                "title": "python-100-thinking-it-as-a-1d-array-problem",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        \\n        ############ O(N^N); O(N)\\n        \\n        # Converting 2d array problem to 1d array\\n        \\n        # initialize zeros list, which will include each rows count of consecutive zeros from right to left\\n        zeros=[]\\n        for each in range(len(grid)):\\n            temp=0\\n            for end in range(len(grid[0])-1,-1,-1):\\n                if grid[each][end]==0:\\n                    temp+=1\\n                else:\\n                    break\\n            zeros.append(temp)\\n       \\n        # initialize count i.e swaps \\n        cnt=0\\n        \\n        # currentzero is the required zeros at index \\n        currentzero=len(grid)-1\\n        index=0\\n        while index<=len(grid)-1:\\n            temp=zeros[index]\\n            \\n            # check if zeros[index] is greater or equal to required or currentzero, if it is: mark it as visited (-1) and increment count\\n            if temp>=currentzero:\\n                zeros[index]=-1\\n                index+=1\\n            \\n            else:\\n                # if above condition fails, look for nearest on right which is greater or equal to currentzero\\n                flag=False\\n                for each in range(index,len(zeros)):\\n                    \\n                    # if the current element already visited in previous operation continue\\n                    if zeros[each]==-1:\\n                        continue\\n                    \\n                    # if found, mark as visited and mark flag as visited\\n                    if zeros[each]>=currentzero:\\n                        zeros[each]=-1\\n                        flag=True\\n                        break\\n                    else:\\n                        \\n                        # increment count and look for another element on right which satisfies the above condition\\n                        cnt+=1\\n                \\n                # check if we found the element on right, if not return -1 (not possible to satisfy the problem statement)\\n                if not flag:\\n                    return -1\\n                \\n            # Otherwise decrement currentzero\\n            currentzero-=1\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        \\n        ############ O(N^N); O(N)\\n        \\n        # Converting 2d array problem to 1d array\\n        \\n        # initialize zeros list, which will include each rows count of consecutive zeros from right to left\\n        zeros=[]\\n        for each in range(len(grid)):\\n            temp=0\\n            for end in range(len(grid[0])-1,-1,-1):\\n                if grid[each][end]==0:\\n                    temp+=1\\n                else:\\n                    break\\n            zeros.append(temp)\\n       \\n        # initialize count i.e swaps \\n        cnt=0\\n        \\n        # currentzero is the required zeros at index \\n        currentzero=len(grid)-1\\n        index=0\\n        while index<=len(grid)-1:\\n            temp=zeros[index]\\n            \\n            # check if zeros[index] is greater or equal to required or currentzero, if it is: mark it as visited (-1) and increment count\\n            if temp>=currentzero:\\n                zeros[index]=-1\\n                index+=1\\n            \\n            else:\\n                # if above condition fails, look for nearest on right which is greater or equal to currentzero\\n                flag=False\\n                for each in range(index,len(zeros)):\\n                    \\n                    # if the current element already visited in previous operation continue\\n                    if zeros[each]==-1:\\n                        continue\\n                    \\n                    # if found, mark as visited and mark flag as visited\\n                    if zeros[each]>=currentzero:\\n                        zeros[each]=-1\\n                        flag=True\\n                        break\\n                    else:\\n                        \\n                        # increment count and look for another element on right which satisfies the above condition\\n                        cnt+=1\\n                \\n                # check if we found the element on right, if not return -1 (not possible to satisfy the problem statement)\\n                if not flag:\\n                    return -1\\n                \\n            # Otherwise decrement currentzero\\n            currentzero-=1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887726,
                "title": "javascript-92ms",
                "content": "```\\nconst minSwaps = (grid) => {\\n    let n = grid.length;\\n    let a = new Array(n).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (grid[i][n - 1 - j] != 0) break;\\n            a[i]++;\\n        }\\n    }\\n    let res = 0;\\n    top:\\n        for (let i = 0; i < n; i++) {\\n            for (let j = i; j < n; j++) {\\n                if (a[j] >= n - i - 1) {\\n                    for (let k = j - 1; k >= i; k--) {\\n                        [a[k], a[k + 1]] = [a[k + 1], a[k]];  // swap\\n                        res++;\\n                    }\\n                    continue top;\\n                }\\n            }\\n            return -1;\\n        }\\n    return res;\\n};\\n\\n/////////////////// improve to 88ms ///////////////////////\\nconst minSwaps = (grid) => {\\n    let n = grid.length;\\n    let a = new Array(n).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (grid[i][n - 1 - j] != 0) break;\\n            a[i]++;\\n        }\\n    }\\n    let res = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i; j < n; j++) {\\n            if (a[j] >= n - i - 1) {\\n                for (let k = j - 1; k >= i; k--) {\\n                    [a[k], a[k + 1]] = [a[k + 1], a[k]];\\n                    res++;\\n                }\\n                break;\\n            }\\n        }\\n        if (a[i] < n - i - 1) return -1;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst minSwaps = (grid) => {\\n    let n = grid.length;\\n    let a = new Array(n).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (grid[i][n - 1 - j] != 0) break;\\n            a[i]++;\\n        }\\n    }\\n    let res = 0;\\n    top:\\n        for (let i = 0; i < n; i++) {\\n            for (let j = i; j < n; j++) {\\n                if (a[j] >= n - i - 1) {\\n                    for (let k = j - 1; k >= i; k--) {\\n                        [a[k], a[k + 1]] = [a[k + 1], a[k]];  // swap\\n                        res++;\\n                    }\\n                    continue top;\\n                }\\n            }\\n            return -1;\\n        }\\n    return res;\\n};\\n\\n/////////////////// improve to 88ms ///////////////////////\\nconst minSwaps = (grid) => {\\n    let n = grid.length;\\n    let a = new Array(n).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (grid[i][n - 1 - j] != 0) break;\\n            a[i]++;\\n        }\\n    }\\n    let res = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i; j < n; j++) {\\n            if (a[j] >= n - i - 1) {\\n                for (let k = j - 1; k >= i; k--) {\\n                    [a[k], a[k + 1]] = [a[k + 1], a[k]];\\n                    res++;\\n                }\\n                break;\\n            }\\n        }\\n        if (a[i] < n - i - 1) return -1;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 874289,
                "title": "python-no-sort-beats-100",
                "content": "```\\nclass Solution(object):\\n    def minSwaps(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        size=len(grid)\\n        if size==1: return 0\\n        l=[]\\n        cnt=0\\n        \\n        for i in grid:\\n            cnt=0\\n            for j in i[::-1]:\\n                if j: break\\n                cnt-=1\\n            l.append(cnt)\\n\\n        target=size-1\\n        pos=0 #search position in l\\n        ans=0\\n        \\n        while target>0:\\n            pos=0\\n            while pos<len(l):\\n                if l[pos]+target<=0: break\\n                pos+=1         \\n            else:\\n                return -1\\n            ans+=pos\\n            l.pop(pos)\\n            target-=1\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minSwaps(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        size=len(grid)\\n        if size==1: return 0\\n        l=[]\\n        cnt=0\\n        \\n        for i in grid:\\n            cnt=0\\n            for j in i[::-1]:\\n                if j: break\\n                cnt-=1\\n            l.append(cnt)\\n\\n        target=size-1\\n        pos=0 #search position in l\\n        ans=0\\n        \\n        while target>0:\\n            pos=0\\n            while pos<len(l):\\n                if l[pos]+target<=0: break\\n                pos+=1         \\n            else:\\n                return -1\\n            ans+=pos\\n            l.pop(pos)\\n            target-=1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874075,
                "title": "c-simple",
                "content": "```\\nint minSwaps(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        if(!m)\\n            return 0;\\n        vector<int> arr(m, INT_MIN);\\n        for(int i=0;i<m;i++){\\n            int index = -1;\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1)\\n                    index = j;\\n            }\\n            if(index!=-1)\\n                arr[i] = index;\\n                \\n        }\\n        vector<int> temp(arr.begin(), arr.end());\\n        sort(temp.begin(), temp.end());\\n        for(int i=0;i<m;i++){\\n            if(temp[i] > i)\\n                return -1;\\n        }\\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int j=i;\\n            while(arr[j] > i)\\n                j++;\\n            count+= j -i;\\n            if(j < arr.size()){\\n                int k = j;\\n                while(k > i){\\n                    swap(arr[k], arr[k-1]);\\n                    k--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minSwaps(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        if(!m)\\n            return 0;\\n        vector<int> arr(m, INT_MIN);\\n        for(int i=0;i<m;i++){\\n            int index = -1;\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1)\\n                    index = j;\\n            }\\n            if(index!=-1)\\n                arr[i] = index;\\n                \\n        }\\n        vector<int> temp(arr.begin(), arr.end());\\n        sort(temp.begin(), temp.end());\\n        for(int i=0;i<m;i++){\\n            if(temp[i] > i)\\n                return -1;\\n        }\\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int j=i;\\n            while(arr[j] > i)\\n                j++;\\n            count+= j -i;\\n            if(j < arr.size()){\\n                int k = j;\\n                while(k > i){\\n                    swap(arr[k], arr[k-1]);\\n                    k--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 870956,
                "title": "python3-sort-to-check-viability-then-simulate-minimum-swaps-to-arrange-a-binary-grid",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        def lastOne(row):\\n            return next((i for i in range(n-1, -1, -1) if row[i]), -1)\\n        rightZeros = [n - 1 - lastOne(row) for row in grid]\\n        for i, rz in enumerate(sorted(rightZeros)):\\n            if rz < i:\\n                return -1\\n        ans = 0    \\n        for i in range(n):\\n            target = n + ~i\\n            if rightZeros[i] < target:\\n                j = i + 1\\n                while rightZeros[j] < target:\\n                    j += 1\\n                ans += j - i     \\n                rightZeros[i:j+1] = [rightZeros[j]] + rightZeros[i:j]\\n        return ans          \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        def lastOne(row):\\n            return next((i for i in range(n-1, -1, -1) if row[i]), -1)\\n        rightZeros = [n - 1 - lastOne(row) for row in grid]\\n        for i, rz in enumerate(sorted(rightZeros)):\\n            if rz < i:\\n                return -1\\n        ans = 0    \\n        for i in range(n):\\n            target = n + ~i\\n            if rightZeros[i] < target:\\n                j = i + 1\\n                while rightZeros[j] < target:\\n                    j += 1\\n                ans += j - i     \\n                rightZeros[i:j+1] = [rightZeros[j]] + rightZeros[i:j]\\n        return ans          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 868117,
                "title": "python-one-pass-greedy-solution-beats-99-9",
                "content": "There are some good solutions in discussion. posting notes on an approach which calculates the solution in one pass by applying a \"greedy\" algorithm based on selecting the optimal destination of each grid row in a final grid starting from the top. This allows us to determine the optimal solution in one pass rather than processing the grid and then going back to apply greedy algorithm.\\n\\nSummary: we can iterate through the grid from the top row, calculating the optimal final destination of each row in a greedy way and also determine how many swaps the row must add to the final solution based on previously-processed rows.\\n\\n## High-level algorithm in more detail:\\n\\n1. Create an array, `filled`, of length n representing \"filled\" rows of final solution matrix\\n2. Set `min_swaps = 0`\\n3. Start from \"top\" of input matrix and go row by row. For each input row,\\n\\t**(a)** Determine the optimal final destination of the row by \"filling\" in the highest unfilled row which the row is valid for. A row is valid for any indexes, `i`, in `filled` where `i >= n - trailing_zeros(row) - 1` e.g. a row with n trailing zeros is valid for all indices > -1, a row with n-1 trailing zeros is valid for all indices > 0, etc... (both values n-1 and n are valid for all indices in `filled`)\\n\\t**(b)** If there aren\\'t any valid rows remaining to fill, then this matrix is invalid.\\n\\t**(c)** Add to `min_swaps` the number of rows which have already been filled that are \"lower\" (e.g. have a higher index in `filled`) than the final destination row for the current row\\n4. Return `min_swaps`\\n\\n## Proof ideas/notes\\n\\n**(a)** assign each row to its optimal destination based on its original position and number of trailing 0s\\n\\t- idea1: if two rows `i` and `j` of same # trailing zeros exist, the optimal destination for the earlier row, `i`, (closest to top of grid) must be higher than later row, `j`, since in order for `j` to end up higher than `i` in the final solution, there must be a swap involving `i` and `j` which could just be removed from that solution to get the same result for one less move\\n\\t- idea2: based on above, we can \"greedily\" determine optimal destination of a row starting from the top of the grid by placing it in the highest valid row which hasn\\'t already been filled by a previous row\\n\\n**(b)** based on above, and since we\\'re re-arranging n rows into n places, if one row doesn\\'t have a valid slot to fill in the final solution, we know that there will be an empty row in the final solution, so we can early return in this case\\n\\n**(c)** we actually know how many moves will be required to \"move\" a row into its optimal end position as we\\'re processing. we just need to count the number of rows we\\'ve already processed which need to end up in later rows\\n\\n**proof idea:** assume that we have an array, `arr` of numbers 0..n-1 which we need to sort in reverse with adj swaps\\n\\tthis is effectively what we end up with after the \"greedy\" optimal destination selection above, where we\\'ve mapped the input rows to their final destination. note that at this point, we don\\'t care about trailing zeros.\\n\\nThe min number of swaps this sort can possibly take if we always swap a higher number with a lower one:\\n- For each num `i` in `arr`, we know that at some point, we must swap `i` with any index `j` before `i` in `arr` where`num[j] < num[i]`\\n\\t\\te.g.  `count(arr[j] if arr[j] < arr[i] for j in range(i))`\\n\\tSo the min number of swaps possible to sort the entire array must be `sum(count(arr[j] if arr[j] < arr[i] for j in range(i) for i in range(n)` if we only ever do useful swaps.\\n\\nNow note that we can always choose to swap a higher number with a lower one in the array because if we can\\'t, then it means the array is already sorted properly\\n\\nSo the above number is the true min number of swaps required to sort array accordingly\\n\\nFinally, mapping back to our solution, the `count(arr[j] if arr[j] < arr[i] for j in range(i))` is effectively equivalent to the number of \"lower\" rows already-filled in the final optimal solution grid when we fill row `i`\\n\\t\\t\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        def fill(arr, idx):\\n            # try to fill with simple cascade try the highest and go next until we find an empty slot or can\\'t fill\\n            # where lower index in input arr represents \"higher\" row in potential optimal solution\\n            # potential improvement\\n            while idx < len(arr) and arr[idx]:\\n                idx += 1\\n            if idx < len(arr):\\n                arr[idx] = True\\n                return idx\\n            return -1\\n        \\n        def count_swaps(arr, from_idx):\\n            # count number of rows which have already been filled at a higher index (e.g. a \"lower\" row in solution grid)\\n            # potential improvement\\n            return sum(arr[i] for i in range(from_idx + 1, len(arr))\\n        \\n        def get_trailing_zeros(row):\\n            zeros = 0\\n            for i in reversed(range(len(row))):\\n                if row[i] == 1:\\n                    break\\n                zeros += 1\\n            return zeros\\n        \\n        if len(grid) < 1:\\n            return -1\\n        \\n        n = len(grid)\\n        \\n        # initialize final optimal solution \"filled\" grid\\n        filled_rows = [False for i in range(n)]\\n        \\n        num_swaps = 0\\n        \\n        # O(n) w/ O(n) inner loop -> O(n^2)\\n        for row in grid:\\n                       \\n            # O(n)\\n            trailing_zeros = get_trailing_zeros(row)\\n                       \\n            # print(f\\'row: {row}, trailing 0s: {trailing_zeros}\\')\\n            \\n            # fill in the highest valid row in optimal solution\\n            # the highest row we can fill is determined by number of trailing zeros\\n            # if there are n trailing zeros, set to 0 index (highest row of grid)\\n            # O(n)\\n            fill_idx = fill(filled_rows, max(0, n - trailing_zeros - 1))\\n            \\n            if fill_idx == -1:\\n                # if can\\'t fill one row, we can\\'t get a valid solution\\n                return -1\\n            else:\\n                # use fill_idx to determine how many rows exist prior to this one\\n                # which we need to swap over, and add this to min swaps\\n                # O(n)\\n                num_swaps += count_swaps(filled_rows, fill_idx)\\n                       \\n        assert(all(filled_rows))\\n        return num_swaps\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        def fill(arr, idx):\\n            # try to fill with simple cascade try the highest and go next until we find an empty slot or can\\'t fill\\n            # where lower index in input arr represents \"higher\" row in potential optimal solution\\n            # potential improvement\\n            while idx < len(arr) and arr[idx]:\\n                idx += 1\\n            if idx < len(arr):\\n                arr[idx] = True\\n                return idx\\n            return -1\\n        \\n        def count_swaps(arr, from_idx):\\n            # count number of rows which have already been filled at a higher index (e.g. a \"lower\" row in solution grid)\\n            # potential improvement\\n            return sum(arr[i] for i in range(from_idx + 1, len(arr))\\n        \\n        def get_trailing_zeros(row):\\n            zeros = 0\\n            for i in reversed(range(len(row))):\\n                if row[i] == 1:\\n                    break\\n                zeros += 1\\n            return zeros\\n        \\n        if len(grid) < 1:\\n            return -1\\n        \\n        n = len(grid)\\n        \\n        # initialize final optimal solution \"filled\" grid\\n        filled_rows = [False for i in range(n)]\\n        \\n        num_swaps = 0\\n        \\n        # O(n) w/ O(n) inner loop -> O(n^2)\\n        for row in grid:\\n                       \\n            # O(n)\\n            trailing_zeros = get_trailing_zeros(row)\\n                       \\n            # print(f\\'row: {row}, trailing 0s: {trailing_zeros}\\')\\n            \\n            # fill in the highest valid row in optimal solution\\n            # the highest row we can fill is determined by number of trailing zeros\\n            # if there are n trailing zeros, set to 0 index (highest row of grid)\\n            # O(n)\\n            fill_idx = fill(filled_rows, max(0, n - trailing_zeros - 1))\\n            \\n            if fill_idx == -1:\\n                # if can\\'t fill one row, we can\\'t get a valid solution\\n                return -1\\n            else:\\n                # use fill_idx to determine how many rows exist prior to this one\\n                # which we need to swap over, and add this to min swaps\\n                # O(n)\\n                num_swaps += count_swaps(filled_rows, fill_idx)\\n                       \\n        assert(all(filled_rows))\\n        return num_swaps\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 853689,
                "title": "simple-python-solution-beat-91",
                "content": "```\\n        n = len(grid)\\n        m = [n] * n\\n        for i in range(n):\\n            for j in range(n-1,-1,-1):\\n                if grid[i][j] == 1:\\n                    m[i] = n-j-1\\n                    break\\n        t,ans = 0,0\\n        for i in range(n):\\n            t += 1\\n            flag = False\\n            for j in range(i,n):\\n                if m[j] >= n-t:\\n                    ans += j-i\\n                    flag = True\\n                    break\\n            if not flag: return -1\\n            m[i+1:j+1] = m[i:j]\\n        return ans",
                "solutionTags": [],
                "code": "```\\n        n = len(grid)\\n        m = [n] * n\\n        for i in range(n):\\n            for j in range(n-1,-1,-1):\\n                if grid[i][j] == 1:\\n                    m[i] = n-j-1\\n                    break\\n        t,ans = 0,0\\n        for i in range(n):\\n            t += 1\\n            flag = False\\n            for j in range(i,n):\\n                if m[j] >= n-t:\\n                    ans += j-i\\n                    flag = True\\n                    break\\n            if not flag: return -1\\n            m[i+1:j+1] = m[i:j]\\n        return ans",
                "codeTag": "Unknown"
            },
            {
                "id": 848773,
                "title": "python-o-mn-o-m",
                "content": "```\\nclass Solution(object):\\n    def minSwaps(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        n = len(grid)\\n        zeroCount = self.getZeroCount(grid)\\n        for i in range(len(grid)):\\n            if zeroCount[i] < n-i-1:\\n                j = i\\n                while j < n and zeroCount[j] < n - i - 1:\\n                    j += 1\\n                if j == n:\\n                    return -1\\n                while j > i:\\n                    zeroCount[j], zeroCount[j-1] = zeroCount[j-1], zeroCount[j]\\n                    j -= 1\\n                    res += 1\\n            \\n        return res\\n    \\n    def getZeroCount(self, grid):\\n        zeroCount = []\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            count = 0\\n            for j in range(n-1, -1, -1):\\n                if grid[i][j] == 0:\\n                    count+=1\\n                else:\\n                    break\\n            zeroCount.append(count)\\n        \\n        return zeroCount\\n                \\n \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minSwaps(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        n = len(grid)\\n        zeroCount = self.getZeroCount(grid)\\n        for i in range(len(grid)):\\n            if zeroCount[i] < n-i-1:\\n                j = i\\n                while j < n and zeroCount[j] < n - i - 1:\\n                    j += 1\\n                if j == n:\\n                    return -1\\n                while j > i:\\n                    zeroCount[j], zeroCount[j-1] = zeroCount[j-1], zeroCount[j]\\n                    j -= 1\\n                    res += 1\\n            \\n        return res\\n    \\n    def getZeroCount(self, grid):\\n        zeroCount = []\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            count = 0\\n            for j in range(n-1, -1, -1):\\n                if grid[i][j] == 0:\\n                    count+=1\\n                else:\\n                    break\\n            zeroCount.append(count)\\n        \\n        return zeroCount\\n                \\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 823386,
                "title": "simple-approach-but-doesnt-pass-all-tests",
                "content": "This approach fails on 106/129th test case due to number of swaps. However the idea is that, count the trailing zeros, use sort to count the swaps & then check the order from the sorted list. It takes only additional O(n) space & time complexity depends on choice of your sort (I used bubble sort - O(n^2))\\n\\n    int minSwaps(vector<vector<int>>& grid) {\\n      vector<int> zeroCount;\\n      int swapCount = 0;\\n      \\n      // count the number of trailing zeros\\n      for (int i = 0; i < grid.size(); i++) {\\n        int count = 0;\\n        for (int j = grid[i].size() - 1; j >= 0; j--) {\\n          if (grid[i][j] != 0) {\\n            break;\\n          }\\n          count++;\\n        }\\n        zeroCount.push_back(count);\\n      }\\n      \\n      // bubble sort the array (and keep track of swaps)\\n      // TODO: which sorting does minimum swaps?\\n      for (int i = 0; i < zeroCount.size() - 1; i++) {\\n        for (int j = 0; j < zeroCount.size()-i-1; j++) {\\n          if (zeroCount[j] < zeroCount[j+1]) {\\n            int tmp = zeroCount[j];\\n            zeroCount[j] = zeroCount[j+1];\\n            zeroCount[j+1] = tmp;\\n            swapCount++;\\n          }\\n        }\\n      }\\n      \\n      // if the array is not sorted(descending order), then solution is not possible\\n      for (int i = 0; i < zeroCount.size(); i++) {\\n        if (zeroCount[i] < (zeroCount.size() - i - 1)) {\\n          return -1;\\n        }\\n      }\\n      \\n      return swapCount;\\n    }",
                "solutionTags": [],
                "code": "This approach fails on 106/129th test case due to number of swaps. However the idea is that, count the trailing zeros, use sort to count the swaps & then check the order from the sorted list. It takes only additional O(n) space & time complexity depends on choice of your sort (I used bubble sort - O(n^2))\\n\\n    int minSwaps(vector<vector<int>>& grid) {\\n      vector<int> zeroCount;\\n      int swapCount = 0;\\n      \\n      // count the number of trailing zeros\\n      for (int i = 0; i < grid.size(); i++) {\\n        int count = 0;\\n        for (int j = grid[i].size() - 1; j >= 0; j--) {\\n          if (grid[i][j] != 0) {\\n            break;\\n          }\\n          count++;\\n        }\\n        zeroCount.push_back(count);\\n      }\\n      \\n      // bubble sort the array (and keep track of swaps)\\n      // TODO: which sorting does minimum swaps?\\n      for (int i = 0; i < zeroCount.size() - 1; i++) {\\n        for (int j = 0; j < zeroCount.size()-i-1; j++) {\\n          if (zeroCount[j] < zeroCount[j+1]) {\\n            int tmp = zeroCount[j];\\n            zeroCount[j] = zeroCount[j+1];\\n            zeroCount[j+1] = tmp;\\n            swapCount++;\\n          }\\n        }\\n      }\\n      \\n      // if the array is not sorted(descending order), then solution is not possible\\n      for (int i = 0; i < zeroCount.size(); i++) {\\n        if (zeroCount[i] < (zeroCount.size() - i - 1)) {\\n          return -1;\\n        }\\n      }\\n      \\n      return swapCount;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 823309,
                "title": "golang-simple-solution",
                "content": "```go\\nfunc minSwaps(grid [][]int) int {\\n    // calculate and storage row infos\\n\\tmagic := make([]int, 0, len(grid))\\n\\tloop1:\\n\\tfor _, v := range grid {\\n\\t\\tfor i := len(v)-1; i >= 0; i-- {\\n\\t\\t\\tif v[i] == 1 {\\n\\t\\t\\t\\tmagic = append(magic, i)\\n\\t\\t\\t\\tcontinue loop1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmagic = append(magic, 0)\\n\\t}\\n\\tstep := 0\\n\\tloop2:\\n\\tfor curr := 0; curr < len(grid); curr++ {\\n\\t\\tfor i, v := range magic {\\n\\t\\t\\tif v <= curr {\\n\\t\\t\\t\\tcopy(magic[1:i+1], magic[:i])\\n\\t\\t\\t\\tmagic = magic[1:]\\n\\t\\t\\t\\tstep += i\\n\\t\\t\\t\\tcontinue loop2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1\\n\\t}\\n\\treturn step\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minSwaps(grid [][]int) int {\\n    // calculate and storage row infos\\n\\tmagic := make([]int, 0, len(grid))\\n\\tloop1:\\n\\tfor _, v := range grid {\\n\\t\\tfor i := len(v)-1; i >= 0; i-- {\\n\\t\\t\\tif v[i] == 1 {\\n\\t\\t\\t\\tmagic = append(magic, i)\\n\\t\\t\\t\\tcontinue loop1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmagic = append(magic, 0)\\n\\t}\\n\\tstep := 0\\n\\tloop2:\\n\\tfor curr := 0; curr < len(grid); curr++ {\\n\\t\\tfor i, v := range magic {\\n\\t\\t\\tif v <= curr {\\n\\t\\t\\t\\tcopy(magic[1:i+1], magic[:i])\\n\\t\\t\\t\\tmagic = magic[1:]\\n\\t\\t\\t\\tstep += i\\n\\t\\t\\t\\tcontinue loop2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1\\n\\t}\\n\\treturn step\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 810576,
                "title": "my-solution-using-priority-queue",
                "content": "Using Priority Queue and TreeSet. Run time may be better for larger arrays.\\n```\\npublic class MinSwapGrid {\\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();// find nearest row.\\n    TreeSet<Integer> usedSet = new TreeSet<>();// used Allow to calculate the compensation due to row change.\\n    Map<Integer, List<Integer>> mValue = new HashMap<>();// list of rows with key number of trailing zeros\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int move = 0;\\n        for(int i =0; i < n;i++) {\\n            int key = 0;\\n            for(int j = n-1;j >=0;j--) {\\n                if (grid[i][j] != 0) break;\\n                key++;//Number of zeros\\n            }//\\n            List<Integer> lVal = mValue.getOrDefault(key,new LinkedList<Integer>());\\n            lVal.add(i);\\n            mValue.put(key,lVal);\\n        }\\n        int rr =0;\\n        for(int i =n; i >= 1;i--) {\\n            List<Integer> nList = mValue.get(i);\\n            if (nList != null) {\\n                for(int jj : nList) minHeap.add(jj);\\n            }\\n            if (i == n) continue;\\n            if (minHeap.isEmpty()) return  -1;\\n            int row = minHeap.poll();\\n            Set<Integer> ss = usedSet.tailSet(row);\\n            move += (row+ ((ss == null)?0:ss.size()))-rr;\\n            usedSet.add(row);\\n            rr++;\\n        }\\n\\n        return move;\\n    }\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MinSwapGrid {\\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();// find nearest row.\\n    TreeSet<Integer> usedSet = new TreeSet<>();// used Allow to calculate the compensation due to row change.\\n    Map<Integer, List<Integer>> mValue = new HashMap<>();// list of rows with key number of trailing zeros\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int move = 0;\\n        for(int i =0; i < n;i++) {\\n            int key = 0;\\n            for(int j = n-1;j >=0;j--) {\\n                if (grid[i][j] != 0) break;\\n                key++;//Number of zeros\\n            }//\\n            List<Integer> lVal = mValue.getOrDefault(key,new LinkedList<Integer>());\\n            lVal.add(i);\\n            mValue.put(key,lVal);\\n        }\\n        int rr =0;\\n        for(int i =n; i >= 1;i--) {\\n            List<Integer> nList = mValue.get(i);\\n            if (nList != null) {\\n                for(int jj : nList) minHeap.add(jj);\\n            }\\n            if (i == n) continue;\\n            if (minHeap.isEmpty()) return  -1;\\n            int row = minHeap.poll();\\n            Set<Integer> ss = usedSet.tailSet(row);\\n            move += (row+ ((ss == null)?0:ss.size()))-rr;\\n            usedSet.add(row);\\n            rr++;\\n        }\\n\\n        return move;\\n    }\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789410,
                "title": "c-o-nlgn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint minSwaps(vector<vector<int>>& A) {\\n\\t\\tconst int N=A.size();\\n\\t\\tvector<vector<int>> G(N);\\n\\t\\t// O(N^2)\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tint x=N;\\n\\t\\t\\twhile(--x && !A[i][x]);\\n\\t\\t\\tG[N-x-1].push_back(i);\\n\\t\\t}\\n\\t\\t// O(NlgN)\\n\\t\\tint sum=0;\\n\\t\\tvector<int> T(N+1);\\n\\t\\tpriority_queue<int> Q;\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tfor(int j:G[N-i-1]) Q.push(-j);\\n\\t\\t\\tif(Q.empty()) return -1;\\n\\t\\t\\tint j=-Q.top();\\n\\t\\t\\tQ.pop();\\n\\t\\t\\tsum+=j-i;\\n\\t\\t\\tfor(int k=N-j; k; k-=k&-k) sum+=T[k];\\n\\t\\t\\tfor(int k=N-j; k<=N; k+=k&-k) T[k]++;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minSwaps(vector<vector<int>>& A) {\\n\\t\\tconst int N=A.size();\\n\\t\\tvector<vector<int>> G(N);\\n\\t\\t// O(N^2)\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tint x=N;\\n\\t\\t\\twhile(--x && !A[i][x]);\\n\\t\\t\\tG[N-x-1].push_back(i);\\n\\t\\t}\\n\\t\\t// O(NlgN)\\n\\t\\tint sum=0;\\n\\t\\tvector<int> T(N+1);\\n\\t\\tpriority_queue<int> Q;\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tfor(int j:G[N-i-1]) Q.push(-j);\\n\\t\\t\\tif(Q.empty()) return -1;\\n\\t\\t\\tint j=-Q.top();\\n\\t\\t\\tQ.pop();\\n\\t\\t\\tsum+=j-i;\\n\\t\\t\\tfor(int k=N-j; k; k-=k&-k) sum+=T[k];\\n\\t\\t\\tfor(int k=N-j; k<=N; k+=k&-k) T[k]++;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778158,
                "title": "faster-than-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        unordered_map<int,int>mp,mp2;\\n        for(int i=0;i<n;i++)\\n        {\\n            int c1=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==0)\\n                    c1++;\\n                else\\n                    break;\\n            }\\n            mp[i]=c1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=mp[i];\\n            int l=(n-i-1);\\n            int j=i;\\n            while(x<l && j<n-1)\\n            {\\n                ans++;\\n                x=mp[++j];\\n                if(j==(n-1) && x<l)\\n                    return -1;\\n            }\\n            for(int l=j;l>=i+1;l--)\\n                mp[l]=mp[l-1];\\n            mp[i]=l;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        unordered_map<int,int>mp,mp2;\\n        for(int i=0;i<n;i++)\\n        {\\n            int c1=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==0)\\n                    c1++;\\n                else\\n                    break;\\n            }\\n            mp[i]=c1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=mp[i];\\n            int l=(n-i-1);\\n            int j=i;\\n            while(x<l && j<n-1)\\n            {\\n                ans++;\\n                x=mp[++j];\\n                if(j==(n-1) && x<l)\\n                    return -1;\\n            }\\n            for(int l=j;l>=i+1;l--)\\n                mp[l]=mp[l-1];\\n            mp[i]=l;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777078,
                "title": "java-just-count-the-trailing-zeros-for-each-row-and-apply-greedy-selection",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] cntZeros = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int cnt = 0;\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] != 0) {\\n                    break;\\n                }\\n                cnt++;\\n            }\\n            cntZeros[i] = cnt;\\n        }\\n        int res = 0;\\n        int target = n - 1;\\n        for (int i = 0; i < n; i++) {\\n            int j;\\n            for (j = i; j < n; j++) {\\n                if (target <= cntZeros[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == n) {\\n                return -1;\\n            }\\n            res += j - i;\\n            moveToFront(cntZeros, i, j);    \\n            target--;\\n        }\\n        return res;\\n    }\\n    \\n    private void moveToFront(int[] cntZeros, int i, int j) {\\n        int temp = cntZeros[j];\\n        for (int k = j; k > i; k--) {\\n            cntZeros[k] = cntZeros[k - 1];\\n        }\\n        cntZeros[i] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] cntZeros = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int cnt = 0;\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] != 0) {\\n                    break;\\n                }\\n                cnt++;\\n            }\\n            cntZeros[i] = cnt;\\n        }\\n        int res = 0;\\n        int target = n - 1;\\n        for (int i = 0; i < n; i++) {\\n            int j;\\n            for (j = i; j < n; j++) {\\n                if (target <= cntZeros[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == n) {\\n                return -1;\\n            }\\n            res += j - i;\\n            moveToFront(cntZeros, i, j);    \\n            target--;\\n        }\\n        return res;\\n    }\\n    \\n    private void moveToFront(int[] cntZeros, int i, int j) {\\n        int temp = cntZeros[j];\\n        for (int k = j; k > i; k--) {\\n            cntZeros[k] = cntZeros[k - 1];\\n        }\\n        cntZeros[i] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776913,
                "title": "python3-easy-solution",
                "content": "```\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        count, size, rowN, tag, has = 0, len(grid), 0, 0, {}\\n        tmpCount = 0\\n        while rowN < size-1 and tag < size:\\n            if tag in has.keys():\\n                tag += 1\\n                tmpCount += 1\\n                continue\\n            if 1 not in grid[tag][rowN+1:]:\\n                count += tag - tmpCount\\n                rowN += 1\\n                has[tag] = tag\\n                tag, tmpCount = 0,0\\n            else:\\n                tag += 1\\n        return count if rowN == size-1 else -1\\n```",
                "solutionTags": [],
                "code": "```\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        count, size, rowN, tag, has = 0, len(grid), 0, 0, {}\\n        tmpCount = 0\\n        while rowN < size-1 and tag < size:\\n            if tag in has.keys():\\n                tag += 1\\n                tmpCount += 1\\n                continue\\n            if 1 not in grid[tag][rowN+1:]:\\n                count += tag - tmpCount\\n                rowN += 1\\n                has[tag] = tag\\n                tag, tmpCount = 0,0\\n            else:\\n                tag += 1\\n        return count if rowN == size-1 else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 775736,
                "title": "java-clean-solution-in-o-n",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] zeroes = calculateZeroesFromRight(grid);\\n        int steps = countSortSteps(zeroes);\\n        return steps;\\n    }\\n    \\n    private int[] calculateZeroesFromRight(int[][] grid) {\\n        int n = grid.length;\\n        int[] zeroes = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int j;\\n            for (j = n - 1; j >= 0 && grid[i][j] == 0; j--);\\n            \\n            zeroes[i] = n - j - 1;\\n        }\\n        \\n        return zeroes;\\n    }\\n    \\n    private int countSortSteps(int[] arr) {\\n        int n = arr.length;\\n        int steps = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int target = n - i - 1;\\n            int j = i;\\n            \\n            while (j < n && arr[j] < target) {\\n                j++;\\n            }\\n            \\n            if(j >= n) {\\n                return -1;\\n            }\\n            \\n            steps += j - i;\\n            while (j > i) {\\n                swap(arr, j, j - 1);\\n                j--;\\n            }\\n        }\\n        \\n        return steps;\\n    }\\n    \\n    private void swap(int[] arr, int i, int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] zeroes = calculateZeroesFromRight(grid);\\n        int steps = countSortSteps(zeroes);\\n        return steps;\\n    }\\n    \\n    private int[] calculateZeroesFromRight(int[][] grid) {\\n        int n = grid.length;\\n        int[] zeroes = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int j;\\n            for (j = n - 1; j >= 0 && grid[i][j] == 0; j--);\\n            \\n            zeroes[i] = n - j - 1;\\n        }\\n        \\n        return zeroes;\\n    }\\n    \\n    private int countSortSteps(int[] arr) {\\n        int n = arr.length;\\n        int steps = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int target = n - i - 1;\\n            int j = i;\\n            \\n            while (j < n && arr[j] < target) {\\n                j++;\\n            }\\n            \\n            if(j >= n) {\\n                return -1;\\n            }\\n            \\n            steps += j - i;\\n            while (j > i) {\\n                swap(arr, j, j - 1);\\n                j--;\\n            }\\n        }\\n        \\n        return steps;\\n    }\\n    \\n    private void swap(int[] arr, int i, int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775593,
                "title": "python-solution",
                "content": "This is my code in python\\n\\n```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        lenth=len(grid)\\n        zeros=[0]*lenth\\n        for i in range(lenth):\\n            row=grid[i]\\n            for j in range(lenth):\\n                if row[-j-1]==0:\\n                    zeros[i]=j+1\\n                else:\\n                    break\\n        \\n        \\n        count=0\\n        \\n        for i in range(lenth):\\n            print(zeros)\\n            if zeros[i]<lenth-1-i:\\n                \\n                did=0\\n                for next in range(lenth-i-1):\\n                    if zeros[i+next+1]>=lenth-1-i:\\n                        did=1\\n                        k=i+next+1\\n                        while k - i >0:\\n                            count+=1\\n                            zeros[k],zeros[k-1] =zeros[k-1],zeros[k]\\n                            k-=1\\n                        break\\n                        \\n                if did==0:\\n                    return -1\\n        return count\\n                    \\n    ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        lenth=len(grid)\\n        zeros=[0]*lenth\\n        for i in range(lenth):\\n            row=grid[i]\\n            for j in range(lenth):\\n                if row[-j-1]==0:\\n                    zeros[i]=j+1\\n                else:\\n                    break\\n        \\n        \\n        count=0\\n        \\n        for i in range(lenth):\\n            print(zeros)\\n            if zeros[i]<lenth-1-i:\\n                \\n                did=0\\n                for next in range(lenth-i-1):\\n                    if zeros[i+next+1]>=lenth-1-i:\\n                        did=1\\n                        k=i+next+1\\n                        while k - i >0:\\n                            count+=1\\n                            zeros[k],zeros[k-1] =zeros[k-1],zeros[k]\\n                            k-=1\\n                        break\\n                        \\n                if did==0:\\n                    return -1\\n        return count\\n                    \\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 775457,
                "title": "java-solution-using-priorityqueue-and-treeset",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        if (grid == null || grid.length == 0) {\\n            return -1;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] counts = new int[m];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((x, y) -> counts[x] == counts[y] ? x - y : counts[y] - counts[x]);\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i = 0; i < m; i++) {\\n            counts[i] = count(grid[i]);\\n            set.add(i);\\n        }\\n        for (int i = 0; i < m; i++) {\\n            pq.add(i);\\n        }\\n        PriorityQueue<Integer> rank = new PriorityQueue<>();\\n        int result = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!pq.isEmpty() && counts[pq.peek()] >= i) {\\n                rank.add(pq.poll());\\n            }\\n            if (rank.isEmpty()) {\\n                return -1;\\n            }\\n            int selectedRow = rank.poll();\\n            result += set.headSet(selectedRow).size();\\n            set.remove(selectedRow);\\n        }\\n        return result;\\n    }\\n    \\n    private int count(int[] row) {\\n        int count = 0;\\n        for (int i = row.length - 1; i >= 0; i--) {\\n            if (row[i] == 0) {\\n                count++;\\n            } else {\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        if (grid == null || grid.length == 0) {\\n            return -1;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] counts = new int[m];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((x, y) -> counts[x] == counts[y] ? x - y : counts[y] - counts[x]);\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i = 0; i < m; i++) {\\n            counts[i] = count(grid[i]);\\n            set.add(i);\\n        }\\n        for (int i = 0; i < m; i++) {\\n            pq.add(i);\\n        }\\n        PriorityQueue<Integer> rank = new PriorityQueue<>();\\n        int result = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!pq.isEmpty() && counts[pq.peek()] >= i) {\\n                rank.add(pq.poll());\\n            }\\n            if (rank.isEmpty()) {\\n                return -1;\\n            }\\n            int selectedRow = rank.poll();\\n            result += set.headSet(selectedRow).size();\\n            set.remove(selectedRow);\\n        }\\n        return result;\\n    }\\n    \\n    private int count(int[] row) {\\n        int count = 0;\\n        for (int i = row.length - 1; i >= 0; i--) {\\n            if (row[i] == 0) {\\n                count++;\\n            } else {\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775116,
                "title": "javascript-clean-code-beat-100-speed-and-memory",
                "content": "```javascript\\nvar minSwaps = function(grid) {\\n    const arr = [];\\n    let count = 0;\\n    \\n    for(let row of grid) {\\n        arr.push(row.lastIndexOf(1));\\n    }\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        for(let j = 0; j < arr.length; j++) {\\n            if(arr[j] != null && arr[j] <= i) {\\n                arr[j] = null; break;\\n            } else if(arr[j] != null) count++;\\n        }\\n    }\\n    if(arr.every(x => x == null)) return count;\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar minSwaps = function(grid) {\\n    const arr = [];\\n    let count = 0;\\n    \\n    for(let row of grid) {\\n        arr.push(row.lastIndexOf(1));\\n    }\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        for(let j = 0; j < arr.length; j++) {\\n            if(arr[j] != null && arr[j] <= i) {\\n                arr[j] = null; break;\\n            } else if(arr[j] != null) count++;\\n        }\\n    }\\n    if(arr.every(x => x == null)) return count;\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774625,
                "title": "java-short-solution",
                "content": "Bubble Sort !!!\\n\\n```\\n    public int minSwaps(int[][] g) {\\n        int[] res = new int[g.length];\\n        int idx = 0;\\n        for(int[] r : g) {\\n            int count = 0;\\n            for(int i = r.length-1; i >= 0; i--) {\\n                if(r[i] != 0) break;\\n                count++;\\n            }\\n            res[idx++] = count;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < g.length -1; i++) {\\n            int t = g.length - i - 1;\\n            if(res[i] >= t) continue;\\n            int j = i + 1;\\n            while(j < g.length && res[j] < t) j++;\\n            if(j == g.length) return -1;\\n            ans += j-i;\\n            while(j > i) {\\n                int z = res[j];\\n                res[j] = res[j-1];\\n                res[j-1] = z;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minSwaps(int[][] g) {\\n        int[] res = new int[g.length];\\n        int idx = 0;\\n        for(int[] r : g) {\\n            int count = 0;\\n            for(int i = r.length-1; i >= 0; i--) {\\n                if(r[i] != 0) break;\\n                count++;\\n            }\\n            res[idx++] = count;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < g.length -1; i++) {\\n            int t = g.length - i - 1;\\n            if(res[i] >= t) continue;\\n            int j = i + 1;\\n            while(j < g.length && res[j] < t) j++;\\n            if(j == g.length) return -1;\\n            ans += j-i;\\n            while(j > i) {\\n                int z = res[j];\\n                res[j] = res[j-1];\\n                res[j-1] = z;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774007,
                "title": "greedy-approach-java",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        \\n        int[] zc = zeroCount(grid);\\n        \\n        int res=0;\\n        for(int i=0;i<zc.length;i++){\\n            int needed = grid.length-i-1;\\n            \\n            // if needed is available - no swaps required\\n            if(zc[i] >= needed){\\n                continue;        \\n            }\\n            \\n            // check next available (needed) value\\n            boolean found = false;\\n            int j=i+1;\\n            for(;j<zc.length;j++){\\n                if(zc[j] >= needed){\\n                    found = true;\\n                    break;\\n                }          \\n            }\\n            \\n            // if found - swap and increment swaps count\\n            if(found){\\n                int countSwaps=0;\\n                for(int k=j;k>i;k--){\\n                    swap(zc, k-1, k);\\n                    countSwaps++;\\n                }\\n                res += countSwaps;\\n            } else {\\n               return -1; \\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n    void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    int[] zeroCount(int[][] grid){\\n        int[] zeroCount = new int[grid.length];\\n        \\n        for(int i=0;i<grid.length;i++){\\n            int count = 0;\\n            for(int j=grid.length-1;j>=0;j--){\\n                if(grid[i][j] != 0){\\n                    break;\\n                }\\n                count++;\\n            }\\n            zeroCount[i] = count;\\n        }\\n        return zeroCount;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        \\n        int[] zc = zeroCount(grid);\\n        \\n        int res=0;\\n        for(int i=0;i<zc.length;i++){\\n            int needed = grid.length-i-1;\\n            \\n            // if needed is available - no swaps required\\n            if(zc[i] >= needed){\\n                continue;        \\n            }\\n            \\n            // check next available (needed) value\\n            boolean found = false;\\n            int j=i+1;\\n            for(;j<zc.length;j++){\\n                if(zc[j] >= needed){\\n                    found = true;\\n                    break;\\n                }          \\n            }\\n            \\n            // if found - swap and increment swaps count\\n            if(found){\\n                int countSwaps=0;\\n                for(int k=j;k>i;k--){\\n                    swap(zc, k-1, k);\\n                    countSwaps++;\\n                }\\n                res += countSwaps;\\n            } else {\\n               return -1; \\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n    void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    int[] zeroCount(int[][] grid){\\n        int[] zeroCount = new int[grid.length];\\n        \\n        for(int i=0;i<grid.length;i++){\\n            int count = 0;\\n            for(int j=grid.length-1;j>=0;j--){\\n                if(grid[i][j] != 0){\\n                    break;\\n                }\\n                count++;\\n            }\\n            zeroCount[i] = count;\\n        }\\n        return zeroCount;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773879,
                "title": "ruby-solution-minimum-swaps-to-arrange-a-binary-grid",
                "content": "Runtime: 92 ms\\nMemory Usage: 10.6 MB\\n\\n```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef min_swaps(grid)\\n    step, n = 0, grid.size\\n    (0..(n - 2)).each do |row|\\n        next if grid[row][(row + 1)..-1].sum == 0\\n        expect = -1\\n        ((row + 1)..(n - 1)).each do |j|\\n            if grid[j][(row + 1)..-1].sum == 0\\n                expect = j\\n                break\\n            end\\n        end\\n        return -1 if expect == -1\\n        expect.downto(row + 1) do |switch|\\n            grid[switch], grid[switch - 1] = grid[switch - 1], grid[switch]\\n            step += 1\\n        end\\n    end\\n    step\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef min_swaps(grid)\\n    step, n = 0, grid.size\\n    (0..(n - 2)).each do |row|\\n        next if grid[row][(row + 1)..-1].sum == 0\\n        expect = -1\\n        ((row + 1)..(n - 1)).each do |j|\\n            if grid[j][(row + 1)..-1].sum == 0\\n                expect = j\\n                break\\n            end\\n        end\\n        return -1 if expect == -1\\n        expect.downto(row + 1) do |switch|\\n            grid[switch], grid[switch - 1] = grid[switch - 1], grid[switch]\\n            step += 1\\n        end\\n    end\\n    step\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 773791,
                "title": "python-o-n-2",
                "content": "we just have to count occurance of zeros(from the end) and put the row and 0s in a q. \\nWhen we iterate through the q, we increase the index of all element iterated by one to mimic the swapping. \\nThen we just have to find diff of current row vs row which target number of zero is at.\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        row,col = len(grid),len(grid[0])\\n        q = []\\n        for i in range(row):\\n            count = 0\\n            for j in range(col-1, -1, -1):\\n                if grid[i][j] == 1:\\n                    break\\n                count += 1\\n            q.append([i,count])\\n        total = 0 \\n        for i in range(row):\\n            target = row - i - 1\\n            p1 = 0 \\n            while p1 < row:\\n                if q[p1][1] >= target:\\n                    total += q[p1][0] - i\\n                    q[p1][0] += 1\\n                    q[p1][1] = 0\\n                    break\\n                q[p1][0] += 1\\n                p1 += 1\\n            if p1 == row:\\n                return -1\\n        return total",
                "solutionTags": [],
                "code": "we just have to count occurance of zeros(from the end) and put the row and 0s in a q. \\nWhen we iterate through the q, we increase the index of all element iterated by one to mimic the swapping. \\nThen we just have to find diff of current row vs row which target number of zero is at.\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        row,col = len(grid),len(grid[0])\\n        q = []\\n        for i in range(row):\\n            count = 0\\n            for j in range(col-1, -1, -1):\\n                if grid[i][j] == 1:\\n                    break\\n                count += 1\\n            q.append([i,count])\\n        total = 0 \\n        for i in range(row):\\n            target = row - i - 1\\n            p1 = 0 \\n            while p1 < row:\\n                if q[p1][1] >= target:\\n                    total += q[p1][0] - i\\n                    q[p1][0] += 1\\n                    q[p1][1] = 0\\n                    break\\n                q[p1][0] += 1\\n                p1 += 1\\n            if p1 == row:\\n                return -1\\n        return total",
                "codeTag": "Java"
            },
            {
                "id": 773455,
                "title": "python-no-need-swap-do-it-lazily-time-beast-100",
                "content": "I see almost every post does the swap operation. In fact, because we just want to know the number of swap operations, we do not really need perform the swap operation, though it does not help reduce time complexity (Time complexity still `O(n^2)`).\\n\\nThe trick is to mark an empty slot with `-1`.\\n\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        A = []\\n        for row in grid:\\n            zero = 0\\n            for x in row[::-1]:\\n                if x == 0:\\n                    zero += 1\\n                else:\\n                    break\\n            A.append(zero)\\n        \\n        n = len(grid[0])\\n        i, need, res = 0, n - 1, 0\\n        while i < n:\\n            if A[i] == -1:\\n                i += 1\\n                continue\\n            if A[i] >= need:\\n                i += 1\\n                need -= 1\\n                continue\\n            j = i\\n            while j < n and A[j] < need:\\n                res += 1 if A[j] != -1 else 0\\n                j += 1\\n            if j == n:\\n                return -1\\n            A[j] = -1\\n            need -= 1\\n        return res",
                "solutionTags": [],
                "code": "I see almost every post does the swap operation. In fact, because we just want to know the number of swap operations, we do not really need perform the swap operation, though it does not help reduce time complexity (Time complexity still `O(n^2)`).\\n\\nThe trick is to mark an empty slot with `-1`.\\n\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        A = []\\n        for row in grid:\\n            zero = 0\\n            for x in row[::-1]:\\n                if x == 0:\\n                    zero += 1\\n                else:\\n                    break\\n            A.append(zero)\\n        \\n        n = len(grid[0])\\n        i, need, res = 0, n - 1, 0\\n        while i < n:\\n            if A[i] == -1:\\n                i += 1\\n                continue\\n            if A[i] >= need:\\n                i += 1\\n                need -= 1\\n                continue\\n            j = i\\n            while j < n and A[j] < need:\\n                res += 1 if A[j] != -1 else 0\\n                j += 1\\n            if j == n:\\n                return -1\\n            A[j] = -1\\n            need -= 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 773381,
                "title": "straightforward-c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> zero = vector<int>{};\\n        int n = grid.size();\\n        for (int i = 0; i < n; i++) {\\n            zero.push_back(countEndingZeros(grid[i]));\\n        }\\n        int sum = 0;\\n        for (int i = n - 1; i > 0; i--) {\\n            bool found = false;\\n            for (int j = 0; j < zero.size(); j++) {\\n                int z = zero[j];\\n                if (z >= i) {\\n                    sum += j;\\n                    zero.erase(zero.begin()+j);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if (!found) {\\n                return -1;\\n            }\\n        }\\n        return sum;\\n    }\\n    \\n    int countEndingZeros(vector<int>& row) {\\n        int n = row.size();\\n        int count = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (row[i] == 0) {\\n                count++;\\n            } else {\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> zero = vector<int>{};\\n        int n = grid.size();\\n        for (int i = 0; i < n; i++) {\\n            zero.push_back(countEndingZeros(grid[i]));\\n        }\\n        int sum = 0;\\n        for (int i = n - 1; i > 0; i--) {\\n            bool found = false;\\n            for (int j = 0; j < zero.size(); j++) {\\n                int z = zero[j];\\n                if (z >= i) {\\n                    sum += j;\\n                    zero.erase(zero.begin()+j);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if (!found) {\\n                return -1;\\n            }\\n        }\\n        return sum;\\n    }\\n    \\n    int countEndingZeros(vector<int>& row) {\\n        int n = row.size();\\n        int count = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (row[i] == 0) {\\n                count++;\\n            } else {\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772878,
                "title": "java-time-100-space-100",
                "content": "count[i] is repreasent the trailing 0 count at row i\\nValid condition: count[i] >= n - 1- i\\nif there is a count array [3,4,1,2], how many steps does it need to move? The answer is 0.\\nWe don\\'t need to sort it as [4,3,2,1] because it has already matched the valid condition. \\nThat\\'s why I don\\'t need to use the sort algorithm. \\n\\nif there is a count array [1,2,3,4], what would I do? \\nAt row 0, it is invalid because 1 < 4 - 1 - 0. Therefore, I need to find another row count[i] >= 4 - 1- 0;\\nAfter iteration, I found row 2 is matched count[2] >= 4-1-0, and I move row 2 to row 0. ==> [3,1,2,4]\\nThen, I start to check the row 1 and move ==> [3,2,1,4]\\nAnd the row 2 and row 3 are already valid. The final count array is [3,2,1,4]\\n\\nif the count array [0,2,3,0]\\nrow 0 ==> [3,0,2,0]\\nrow 1 ==> [3,2,0,0]\\nrow 2 ==> invalid\\n==> invalid array\\n\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] counts = new int[grid.length];\\n        int n = grid.length;\\n        int steps = 0;\\n        // count contiguous zero from right to left\\n        for (int i = 0; i < n; i++) {\\n            for (int j = n-1; j >= 0; j--) {\\n                if (grid[i][j] == 0) {\\n                    counts[i]++;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (counts[i] < n - 1 - i) {\\n                boolean isValid = false;\\n                for (int j = i + 1; j < n; j++) {\\n                    if (counts[j] >= n-1-i) {\\n                        steps+= move(counts,i,j);\\n                        isValid = true;\\n                        break;\\t\\n                    }\\n                }\\n                if (!isValid) return -1;\\n            } \\n        }\\n        return steps;\\n    }\\n    private int move(int[] count, int dst, int src) {\\n        int m = 0;\\n        for (int i = src; i > dst; i--) {\\n            swap(count, i, i-1);\\n            m++;\\n        }\\n        return m;\\n    }\\n    private void swap(int[] ary, int i, int j) {\\n        int temp = ary[i];\\n        ary[i] = ary[j];\\n        ary[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] counts = new int[grid.length];\\n        int n = grid.length;\\n        int steps = 0;\\n        // count contiguous zero from right to left\\n        for (int i = 0; i < n; i++) {\\n            for (int j = n-1; j >= 0; j--) {\\n                if (grid[i][j] == 0) {\\n                    counts[i]++;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (counts[i] < n - 1 - i) {\\n                boolean isValid = false;\\n                for (int j = i + 1; j < n; j++) {\\n                    if (counts[j] >= n-1-i) {\\n                        steps+= move(counts,i,j);\\n                        isValid = true;\\n                        break;\\t\\n                    }\\n                }\\n                if (!isValid) return -1;\\n            } \\n        }\\n        return steps;\\n    }\\n    private int move(int[] count, int dst, int src) {\\n        int m = 0;\\n        for (int i = src; i > dst; i--) {\\n            swap(count, i, i-1);\\n            m++;\\n        }\\n        return m;\\n    }\\n    private void swap(int[] ary, int i, int j) {\\n        int temp = ary[i];\\n        ary[i] = ary[j];\\n        ary[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772760,
                "title": "python-greedy-548-ms-100-time-100-space",
                "content": "This greedy idea was taken from Larry\\'s apprach with a twist.\\nHere we\\'re counting number of zeroes in the end each row and then we just count the min swaps needed to sort the list of integers.\\n\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        arr, N = [], len(grid)\\n        if N == 1:\\n            return -1 if grid[0][0] else 0\\n        \\n        issorted = True\\n        for i in range(N):\\n            zeroes = 0\\n            for j in range(N-1, -1, -1):\\n                if grid[i][j]: \\n                    break\\n                zeroes += 1\\n            arr.append(zeroes)\\n            if len(arr) > 1 and issorted:\\n                issorted = arr[-2] > arr[-1]\\n        \\n        if issorted:\\n            return 0\\n        \\n        swaps = 0\\n        for i in range(N - 1, -1, -1):\\n            lans = 0\\n            for j in range(N):\\n                if arr[j] is not None and arr[j] >= i:\\n                    arr[j] = None\\n                    swaps += lans\\n                    break\\n                elif arr[j] is not None:\\n                    lans += 1\\n            else:\\n                return -1\\n        \\n        return swaps\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        arr, N = [], len(grid)\\n        if N == 1:\\n            return -1 if grid[0][0] else 0\\n        \\n        issorted = True\\n        for i in range(N):\\n            zeroes = 0\\n            for j in range(N-1, -1, -1):\\n                if grid[i][j]: \\n                    break\\n                zeroes += 1\\n            arr.append(zeroes)\\n            if len(arr) > 1 and issorted:\\n                issorted = arr[-2] > arr[-1]\\n        \\n        if issorted:\\n            return 0\\n        \\n        swaps = 0\\n        for i in range(N - 1, -1, -1):\\n            lans = 0\\n            for j in range(N):\\n                if arr[j] is not None and arr[j] >= i:\\n                    arr[j] = None\\n                    swaps += lans\\n                    break\\n                elif arr[j] is not None:\\n                    lans += 1\\n            else:\\n                return -1\\n        \\n        return swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772411,
                "title": "my-solution-beats-100-answer",
                "content": "```\\nint minSwaps(vector<vector<int>>& grid){\\n    int ans = 0;\\n    int n = grid.size();\\n    if (!n) return 0;\\n    vector<int> vec(n, -1);\\n    for (int i = 0; i < n; ++i) {\\n        int count = 0;\\n        for (int j = n - 1; j >= 0; --j) {\\n            if (grid[i][j] == 1) break;\\n            ++count;\\n        }\\n        vec[i] = count;\\n    }\\n\\n    int limit = n - 1;\\n    while (limit) {\\n        int count = 0;\\n        bool flag = false;\\n        for (int i = 0; i < n; ++i) {\\n            if (vec[i] >= limit) {\\n                ans += count;\\n                vec[i] = -1;\\n                flag = true;\\n                break;\\n            } else if (vec[i] >= 0) {\\n                ++count;\\n            }\\n        }\\n        if (!flag) return -1;\\n        limit--;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minSwaps(vector<vector<int>>& grid){\\n    int ans = 0;\\n    int n = grid.size();\\n    if (!n) return 0;\\n    vector<int> vec(n, -1);\\n    for (int i = 0; i < n; ++i) {\\n        int count = 0;\\n        for (int j = n - 1; j >= 0; --j) {\\n            if (grid[i][j] == 1) break;\\n            ++count;\\n        }\\n        vec[i] = count;\\n    }\\n\\n    int limit = n - 1;\\n    while (limit) {\\n        int count = 0;\\n        bool flag = false;\\n        for (int i = 0; i < n; ++i) {\\n            if (vec[i] >= limit) {\\n                ans += count;\\n                vec[i] = -1;\\n                flag = true;\\n                break;\\n            } else if (vec[i] >= 0) {\\n                ++count;\\n            }\\n        }\\n        if (!flag) return -1;\\n        limit--;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1575271,
                "content": [
                    {
                        "username": "winner07",
                        "content": "see, at the end we have to swap if current value is lesser than required one.  But if we swap with first greater element then all middle elements will be shifted by 1 unit. No matter which greater value we choose whether first occurring one or last occuring one, those middle element are bound to shift.\\nSo now  consider a element in this middle range( say at present it is smaller than its required value). since it is shifted by one, the distance between its required value and its postion will be either remains same or will decrease( if larger required value is in middle range then diff will be same, else the middle element will be shifted by one and larger element will remains at  same postion hence decreasing distnace between them). thus required steps will decrease. So if we choose first greater element, then it will have high chances of reducing distance as compared to that of last occuring greater element. \\n \\n Sorry for bad english. I have tried my best to make myself clear.  Please write in comments. i will try my best to make it clearer(if possible). Please upvote if you liked it.\\n"
                    }
                ]
            }
        ]
    }
]