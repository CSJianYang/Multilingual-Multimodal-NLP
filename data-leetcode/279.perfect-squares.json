[
    {
        "title": "Perfect Squares",
        "question_content": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\n&nbsp;\nExample 1:\n\nInput: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.\n\nExample 2:\n\nInput: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 104",
        "solutions": [
            {
                "id": 71488,
                "title": "summary-of-4-different-solutions-bfs-dp-static-dp-and-mathematics",
                "content": "Came up with the 2 solutions of breadth-first search and dynamic programming. Also \"copied\" StefanPochmann's static dynamic programming solution (https://leetcode.com/discuss/56993/static-dp-c-12-ms-python-172-ms-ruby-384-ms) and davidtan1890's mathematical solution (https://leetcode.com/discuss/57066/4ms-c-code-solve-it-mathematically) here with minor style changes and some comments. Thank Stefan and David for posting their nice solutions!\\n\\n**1.Dynamic Programming:** 440ms\\n\\n    class Solution \\n    {\\n    public:\\n        int numSquares(int n) \\n        {\\n            if (n <= 0)\\n            {\\n                return 0;\\n            }\\n            \\n            // cntPerfectSquares[i] = the least number of perfect square numbers \\n            // which sum to i. Note that cntPerfectSquares[0] is 0.\\n            vector<int> cntPerfectSquares(n + 1, INT_MAX);\\n            cntPerfectSquares[0] = 0;\\n            for (int i = 1; i <= n; i++)\\n            {\\n                // For each i, it must be the sum of some number (i - j*j) and \\n                // a perfect square number (j*j).\\n                for (int j = 1; j*j <= i; j++)\\n                {\\n                    cntPerfectSquares[i] = \\n                        min(cntPerfectSquares[i], cntPerfectSquares[i - j*j] + 1);\\n                }\\n            }\\n            \\n            return cntPerfectSquares.back();\\n        }\\n    };\\n\\n**2.Static Dynamic Programming:** 12ms\\n\\n    class Solution \\n    {\\n    public:\\n        int numSquares(int n) \\n        {\\n            if (n <= 0)\\n            {\\n                return 0;\\n            }\\n            \\n            // cntPerfectSquares[i] = the least number of perfect square numbers \\n            // which sum to i. Since cntPerfectSquares is a static vector, if \\n            // cntPerfectSquares.size() > n, we have already calculated the result \\n            // during previous function calls and we can just return the result now.\\n            static vector<int> cntPerfectSquares({0});\\n            \\n            // While cntPerfectSquares.size() <= n, we need to incrementally \\n            // calculate the next result until we get the result for n.\\n            while (cntPerfectSquares.size() <= n)\\n            {\\n                int m = cntPerfectSquares.size();\\n                int cntSquares = INT_MAX;\\n                for (int i = 1; i*i <= m; i++)\\n                {\\n                    cntSquares = min(cntSquares, cntPerfectSquares[m - i*i] + 1);\\n                }\\n                \\n                cntPerfectSquares.push_back(cntSquares);\\n            }\\n            \\n            return cntPerfectSquares[n];\\n        }\\n    };\\n\\n**3.Mathematical Solution:** 4ms\\n\\n    class Solution \\n    {  \\n    private:  \\n        int is_square(int n)\\n        {  \\n            int sqrt_n = (int)(sqrt(n));  \\n            return (sqrt_n*sqrt_n == n);  \\n        }\\n        \\n    public:\\n        // Based on Lagrange's Four Square theorem, there \\n        // are only 4 possible results: 1, 2, 3, 4.\\n        int numSquares(int n) \\n        {  \\n            // If n is a perfect square, return 1.\\n            if(is_square(n)) \\n            {\\n                return 1;  \\n            }\\n            \\n            // The result is 4 if and only if n can be written in the \\n            // form of 4^k*(8*m + 7). Please refer to \\n            // Legendre's three-square theorem.\\n            while ((n & 3) == 0) // n%4 == 0  \\n            {\\n                n >>= 2;  \\n            }\\n            if ((n & 7) == 7) // n%8 == 7\\n            {\\n                return 4;\\n            }\\n            \\n            // Check whether 2 is the result.\\n            int sqrt_n = (int)(sqrt(n)); \\n            for(int i = 1; i <= sqrt_n; i++)\\n            {  \\n                if (is_square(n - i*i)) \\n                {\\n                    return 2;  \\n                }\\n            }  \\n            \\n            return 3;  \\n        }  \\n    }; \\n\\n**4.Breadth-First Search:** 80ms\\n\\n    class Solution \\n    {\\n    public:\\n        int numSquares(int n) \\n        {\\n            if (n <= 0)\\n            {\\n                return 0;\\n            }\\n            \\n            // perfectSquares contain all perfect square numbers which \\n            // are smaller than or equal to n.\\n            vector<int> perfectSquares;\\n            // cntPerfectSquares[i - 1] = the least number of perfect \\n            // square numbers which sum to i.\\n            vector<int> cntPerfectSquares(n);\\n            \\n            // Get all the perfect square numbers which are smaller than \\n            // or equal to n.\\n            for (int i = 1; i*i <= n; i++)\\n            {\\n                perfectSquares.push_back(i*i);\\n                cntPerfectSquares[i*i - 1] = 1;\\n            }\\n            \\n            // If n is a perfect square number, return 1 immediately.\\n            if (perfectSquares.back() == n)\\n            {\\n                return 1;\\n            }\\n            \\n            // Consider a graph which consists of number 0, 1,...,n as\\n            // its nodes. Node j is connected to node i via an edge if  \\n            // and only if either j = i + (a perfect square number) or \\n            // i = j + (a perfect square number). Starting from node 0, \\n            // do the breadth-first search. If we reach node n at step \\n            // m, then the least number of perfect square numbers which \\n            // sum to n is m. Here since we have already obtained the \\n            // perfect square numbers, we have actually finished the \\n            // search at step 1.\\n            queue<int> searchQ;\\n            for (auto& i : perfectSquares)\\n            {\\n                searchQ.push(i);\\n            }\\n            \\n            int currCntPerfectSquares = 1;\\n            while (!searchQ.empty())\\n            {\\n                currCntPerfectSquares++;\\n                \\n                int searchQSize = searchQ.size();\\n                for (int i = 0; i < searchQSize; i++)\\n                {\\n                    int tmp = searchQ.front();\\n                    // Check the neighbors of node tmp which are the sum \\n                    // of tmp and a perfect square number.\\n                    for (auto& j : perfectSquares)\\n                    {\\n                        if (tmp + j == n)\\n                        {\\n                            // We have reached node n.\\n                            return currCntPerfectSquares;\\n                        }\\n                        else if ((tmp + j < n) && (cntPerfectSquares[tmp + j - 1] == 0))\\n                        {\\n                            // If cntPerfectSquares[tmp + j - 1] > 0, this is not \\n                            // the first time that we visit this node and we should \\n                            // skip the node (tmp + j).\\n                            cntPerfectSquares[tmp + j - 1] = currCntPerfectSquares;\\n                            searchQ.push(tmp + j);\\n                        }\\n                        else if (tmp + j > n)\\n                        {\\n                            // We don't need to consider the nodes which are greater ]\\n                            // than n.\\n                            break;\\n                        }\\n                    }\\n                    \\n                    searchQ.pop();\\n                }\\n            }\\n            \\n            return 0;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution \\n    {\\n    public:\\n        int numSquares(int n) \\n        {\\n            if (n <= 0)\\n            {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71495,
                "title": "an-easy-understanding-dp-solution-in-java",
                "content": "dp[n] indicates that the perfect squares count of the given n, and we have:\\n\\n    dp[0] = 0 \\n    dp[1] = dp[0]+1 = 1\\n    dp[2] = dp[1]+1 = 2\\n    dp[3] = dp[2]+1 = 3\\n    dp[4] = Min{ dp[4-1*1]+1, dp[4-2*2]+1 } \\n          = Min{ dp[3]+1, dp[0]+1 } \\n          = 1\\t\\t\\t\\t\\n    dp[5] = Min{ dp[5-1*1]+1, dp[5-2*2]+1 } \\n          = Min{ dp[4]+1, dp[1]+1 } \\n          = 2\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n    dp[13] = Min{ dp[13-1*1]+1, dp[13-2*2]+1, dp[13-3*3]+1 } \\n           = Min{ dp[12]+1, dp[9]+1, dp[4]+1 } \\n           = 2\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n    dp[n] = Min{ dp[n - i*i] + 1 },  n - i*i >=0 && i >= 1\\n\\n\\n\\nand the sample code is like below:\\n\\n    public int numSquares(int n) {\\n\\t\\tint[] dp = new int[n + 1];\\n\\t\\tArrays.fill(dp, Integer.MAX_VALUE);\\n\\t\\tdp[0] = 0;\\n\\t\\tfor(int i = 1; i <= n; ++i) {\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint j = 1;\\n\\t\\t\\twhile(i - j*j >= 0) {\\n\\t\\t\\t\\tmin = Math.min(min, dp[i - j*j] + 1);\\n\\t\\t\\t\\t++j;\\n\\t\\t\\t}\\n\\t\\t\\tdp[i] = min;\\n\\t\\t}\\t\\t\\n\\t\\treturn dp[n];\\n\\t}\\n\\nHope it can help to understand the DP solution.",
                "solutionTags": [],
                "code": "dp[n] indicates that the perfect squares count of the given n, and we have:\\n\\n    dp[0] = 0 \\n    dp[1] = dp[0]+1 = 1\\n    dp[2] = dp[1]+1 = 2\\n    dp[3] = dp[2]+1 = 3\\n    dp[4] = Min{ dp[4-1*1]+1, dp[4-2*2]+1 } \\n          = Min{ dp[3]+1, dp[0]+1 } \\n          = 1\\t\\t\\t\\t\\n    dp[5] = Min{ dp[5-1*1]+1, dp[5-2*2]+1 } \\n          = Min{ dp[4]+1, dp[1]+1 } \\n          = 2\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n    dp[13] = Min{ dp[13-1*1]+1, dp[13-2*2]+1, dp[13-3*3]+1 } \\n           = Min{ dp[12]+1, dp[9]+1, dp[4]+1 } \\n           = 2\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n    dp[n] = Min{ dp[n - i*i] + 1 },  n - i*i >=0 && i >= 1\\n\\n\\n\\nand the sample code is like below:\\n\\n    public int numSquares(int n) {\\n\\t\\tint[] dp = new int[n + 1];\\n\\t\\tArrays.fill(dp, Integer.MAX_VALUE);\\n\\t\\tdp[0] = 0;\\n\\t\\tfor(int i = 1; i <= n; ++i) {\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint j = 1;\\n\\t\\t\\twhile(i - j*j >= 0) {\\n\\t\\t\\t\\tmin = Math.min(min, dp[i - j*j] + 1);\\n\\t\\t\\t\\t++j;\\n\\t\\t\\t}\\n\\t\\t\\tdp[i] = min;\\n\\t\\t}\\t\\t\\n\\t\\treturn dp[n];\\n\\t}\\n\\nHope it can help to understand the DP solution.",
                "codeTag": "Unknown"
            },
            {
                "id": 71475,
                "title": "short-python-solution-using-bfs",
                "content": "    def numSquares(self, n):\\n        if n < 2:\\n            return n\\n        lst = []\\n        i = 1\\n        while i * i <= n:\\n            lst.append( i * i )\\n            i += 1\\n        cnt = 0\\n        toCheck = {n}\\n        while toCheck:\\n            cnt += 1\\n            temp = set()\\n            for x in toCheck:\\n                for y in lst:\\n                    if x == y:\\n                        return cnt\\n                    if x < y:\\n                        break\\n                    temp.add(x-y)\\n            toCheck = temp\\n    \\n        return cnt\\n\\nThe basic idea of this solution is a BSF search for shortest path, take 12 as an example, as shown below, the shortest path is 12-8-4-0:\\n\\n![0_1467720854827_XCoQwiN.png](/uploads/files/1467720855285-xcoqwin.png)",
                "solutionTags": [],
                "code": "    def numSquares(self, n):\\n        if n < 2:\\n            return n\\n        lst = []\\n        i = 1\\n        while i * i <= n:\\n            lst.append( i * i )\\n            i += 1\\n        cnt = 0\\n        toCheck = {n}\\n        while toCheck:\\n            cnt += 1\\n            temp = set()\\n            for x in toCheck:\\n                for y in lst:\\n                    if x == y:\\n                        return cnt\\n                    if x < y:\\n                        break\\n                    temp.add(x-y)\\n            toCheck = temp\\n    \\n        return cnt\\n\\nThe basic idea of this solution is a BSF search for shortest path, take 12 as an example, as shown below, the shortest path is 12-8-4-0:\\n\\n![0_1467720854827_XCoQwiN.png](/uploads/files/1467720855285-xcoqwin.png)",
                "codeTag": "Python3"
            },
            {
                "id": 1520447,
                "title": "c-dp-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/6f9ff4fa-088f-41db-b464-307c119d55ba_1634187491.871502.jpeg)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        //vector for updating the dp array/values\\n        vector<int> dp(n+1,INT_MAX);\\n        //base case\\n        dp[0]=0;\\n        int count = 1;\\n        while(count*count <= n) {\\n        int sq = count*count;\\n        for(int i = sq; i < n+1; i++) {\\n            dp[i] = min(dp[i-sq] + 1,dp[i]);\\n        }\\n        count++;\\n    }\\n    return dp[n];\\n    }\\n};\\n\\n```\\n\\nComplexity\\n\\nTime complexity: **O(n*sqrt(n))** outer loop is of sqrt(n) iterations and in the inner loop <n iterations roughly.\\n\\nSpace Complexity: **O(n)**.\\n\\n*like it? upvote if you can..!*\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        //vector for updating the dp array/values\\n        vector<int> dp(n+1,INT_MAX);\\n        //base case\\n        dp[0]=0;\\n        int count = 1;\\n        while(count*count <= n) {\\n        int sq = count*count;\\n        for(int i = sq; i < n+1; i++) {\\n            dp[i] = min(dp[i-sq] + 1,dp[i]);\\n        }\\n        count++;\\n    }\\n    return dp[n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71532,
                "title": "o-sqrt-n-about-0-034-ms-and-0-018-ms",
                "content": "For better measurement, I wrapped the actual solution in a 10000-loop. This got accepted in 344 ms (every time in three submits), so without the wrapper it should take about 0.0344 ms. I tried a few variations and this is the fastest I managed to do.\\n\\n(**Update:** After qgambit2's challenge, I [optimized my my original approach](https://leetcode.com/discuss/57185/o-sqrt-n-about-0-03-ms?show=57682#c57682) and now that's my fastest, with about 180 ms.)\\n\\nFirst I use the fact that [four squares always suffice](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem) and the fact that [four squares are only needed for numbers of the form 4<sup>a</sup>(8b+7)](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem). After that part, I know that the answer is 1, 2 or 3, and I try to build n as sum of one or two squares.\\n\\nFor that, I use a kind of two-pointers-approach. Instead of going through squares a<sup>2</sup> and checking whether n-a<sup>2</sup> is a square (which would involve computing lots of square roots), imagine you start with a=0<sup>2</sup> and b=floor(sqrt(n))<sup>2</sup> and as long as a<=b, either make `a` the next larger square or make `b` the next smaller square, depending on whether the sum of the two squares is too small or too large (or return 2, if it's exactly right).\\n\\nBut in order to improve speed further, I use that squares are sums of consecutive odd numbers starting at 1 (for example, 25=1+3+5+7+9), and my `a` and `b` aren't squares but the corresponding odd numbers. And instead of computing the sum of the two squares, I just add to or subtract from n, trying to reach zero. This way, my main part doesn't even have multiplications. Just simple addition/subtraction and comparisons.\\n\\nThe solution:\\n\\n    int numSquaresReal(int n) {\\n        while (n % 4 == 0)\\n            n /= 4;\\n        if (n % 8 == 7)\\n            return 4;\\n        int a = -1, b = sqrt(n);\\n        n -= b * b;\\n        b += b + 1;\\n        while (a <= b) {\\n            if (n < 0)\\n                n += b -= 2;\\n            else if (n > 0)\\n                n -= a += 2;\\n            else\\n                return a < 0 ? 1 : 2;\\n        }\\n        return 3;\\n    }\\n\\n    \\nThe wrapper for better time measurement:\\n\\n    int numSquares(int n) {\\n        int sum = 0;\\n        for (int i=0; i<10000; i++)\\n            sum += numSquaresReal(n);\\n        return sum / 10000;\\n    }",
                "solutionTags": [],
                "code": "For better measurement, I wrapped the actual solution in a 10000-loop. This got accepted in 344 ms (every time in three submits), so without the wrapper it should take about 0.0344 ms. I tried a few variations and this is the fastest I managed to do.\\n\\n(**Update:** After qgambit2's challenge, I [optimized my my original approach](https://leetcode.com/discuss/57185/o-sqrt-n-about-0-03-ms?show=57682#c57682) and now that's my fastest, with about 180 ms.)\\n\\nFirst I use the fact that [four squares always suffice](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem) and the fact that [four squares are only needed for numbers of the form 4<sup>a</sup>(8b+7)](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem). After that part, I know that the answer is 1, 2 or 3, and I try to build n as sum of one or two squares.\\n\\nFor that, I use a kind of two-pointers-approach. Instead of going through squares a<sup>2</sup> and checking whether n-a<sup>2</sup> is a square (which would involve computing lots of square roots), imagine you start with a=0<sup>2</sup> and b=floor(sqrt(n))<sup>2</sup> and as long as a<=b, either make `a` the next larger square or make `b` the next smaller square, depending on whether the sum of the two squares is too small or too large (or return 2, if it's exactly right).\\n\\nBut in order to improve speed further, I use that squares are sums of consecutive odd numbers starting at 1 (for example, 25=1+3+5+7+9), and my `a` and `b` aren't squares but the corresponding odd numbers. And instead of computing the sum of the two squares, I just add to or subtract from n, trying to reach zero. This way, my main part doesn't even have multiplications. Just simple addition/subtraction and comparisons.\\n\\nThe solution:\\n\\n    int numSquaresReal(int n) {\\n        while (n % 4 == 0)\\n            n /= 4;\\n        if (n % 8 == 7)\\n            return 4;\\n        int a = -1, b = sqrt(n);\\n        n -= b * b;\\n        b += b + 1;\\n        while (a <= b) {\\n            if (n < 0)\\n                n += b -= 2;\\n            else if (n > 0)\\n                n -= a += 2;\\n            else\\n                return a < 0 ? 1 : 2;\\n        }\\n        return 3;\\n    }\\n\\n    \\nThe wrapper for better time measurement:\\n\\n    int numSquares(int n) {\\n        int sum = 0;\\n        for (int i=0; i<10000; i++)\\n            sum += numSquaresReal(n);\\n        return sum / 10000;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71512,
                "title": "static-dp-c-12-ms-python-172-ms-ruby-384-ms",
                "content": "There are so **many** \"large\" test cases that it's worthwhile to keep data between test cases rather than recomputing from scratch all the time. At least in the slower languages. My `dp` tells the numbers of squares needed for the first integers, and when asked about a new `n`, I extend `dp` just as much as necessary.\\n\\n---\\n\\n**C++** ... 28 ms\\n\\n    int numSquares(int n) {\\n        static vector<int> dp {0};\\n        while (dp.size() <= n) {\\n            int m = dp.size(), squares = INT_MAX;\\n            for (int i=1; i*i<=m; ++i)\\n                squares = min(squares, dp[m-i*i] + 1);\\n            dp.push_back(squares);\\n        }\\n        return dp[n];\\n    }\\n\\n**C++** ... 12 ms\\n\\nSwitching the loops makes it less nice but faster:\\n\\n    int numSquares(int n) {\\n        static vector<int> dp {0};\\n        int m = dp.size();\\n        dp.resize(max(m, n+1), INT_MAX);\\n        for (int i=1, i2; (i2 = i*i)<=n; ++i)\\n            for (int j=max(m, i2); j<=n; ++j)\\n                if (dp[j] > dp[j-i2] + 1)\\n                    dp[j] = dp[j-i2] + 1;\\n        return dp[n];\\n    }\\n\\n---\\n\\n**Python** ... 172 ms\\n\\n    class Solution(object):\\n        _dp = [0]\\n        def numSquares(self, n):\\n            dp = self._dp\\n            while len(dp) <= n:\\n                dp += min(dp[-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1,\\n            return dp[n]\\n\\n---\\n\\n**Ruby** ... 384 ms\\n\\n    $dp = [0]\\n    def num_squares(n)\\n      $dp << (1..$dp.size**0.5).map { |i| $dp[-i*i] }.min + 1 until $dp[n]\\n      $dp[n]\\n    end\\n\\nThere's probably a cleaner way than using a global variable, but I'm new to Ruby and don't know one.",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Ruby",
                    "Dynamic Programming"
                ],
                "code": "class Solution(object):\\n        _dp = [0]\\n        def numSquares(self, n):\\n            dp = self._dp\\n            while len(dp) <= n:\\n                dp += min(dp[-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1,\\n            return dp[n]\\n\\n---\\n\\n**Ruby** ... 384 ms\\n\\n    $dp = [0]\\n    def num_squares(n)\\n      $dp << (1..$dp.size**0.5).map { |i| $dp[-i*i] }",
                "codeTag": "Java"
            },
            {
                "id": 707526,
                "title": "python-fastest-o-sqrt-n-solution-with-math-explanied",
                "content": "First of all, there is a statement that any number can be represented as sum of 4 squares:\\nhttps://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem. So, answer always will be 4? No, when we talk about `4` squares, it means that some of them can be equal to zero. So, we have `4` options: either `1`, `2`, `3` or `4` squares and we need to choose one of these numbers.\\n\\n1. How to check if number is full square? Just compare square of integer part of root and this number. Complexity of this part is `O(1)`.\\n2. How to check if number is sum of `2` squares: `n = i*i + j*j`? iterate ovell all `i < sqrt(n)` and check that `n - i*i` is full square. Complexity of this part is `O(sqrt(n))`.\\n3. How to check that number is sum of `4` squares? In the same link for wikipedia: \\n` by proving that a positive integer can be expressed as the sum of three squares if and only if it is not of the form 4^k(8m+7) for integers k and m`. So, what we need to do is to check this condition and return true if it fulfilled. Complexity is `O(log n)`\\n4. Do we need to check anything else? No, because we have only one options left: `3` squares.\\n\\n**Complexity**: time complexity is `O(sqrt(n))` and space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def numSquares(self, n):\\n        if int(sqrt(n))**2 == n: return 1\\n        for j in range(int(sqrt(n)) + 1):\\n            if int(sqrt(n - j*j))**2 == n - j*j: return 2\\n            \\n        while n % 4 == 0: \\n            n >>= 2\\n        if n % 8 == 7: return 4\\n        return 3\\n```\\n\\n**Further discussion**. What if you do not know this `4^k(8m+7)` formula on real interview? Then you need to check if number is sum of `3` squares by hands: `n = i*i + j*j + k*k` with complexity `O(n)`: we check all pairs `i,j < sqrt(n)`. What if we do not know, that each number is sum of `4` squares? Then we need to check also possible sums of `4` squares with complexity `O(n sqrt(n))`.\\n\\nWe can handle our problem as **dynamic programming** one, where `dp[i]` is minumum numer of squares to get `i`. Then to evaluate `dp[i]` we need to look at all `j`, such that `j*j <= i`. Complexity of this approach is `O(n sqrt(n))`.\\n\\nNote, that there is also a way to check if `n` is sum of two squares, https://en.wikipedia.org/wiki/Sum_of_two_squares_theorem, each odd prive divisor should have a form `4k + 1`, but this is a bit more difficult to check and complexity will be also `O(sqrt(n))`.\\n\\n Open question, is there solution with comlexity better than `O(sqrt(n))`. If you have ideas, let me know!\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n):\\n        if int(sqrt(n))**2 == n: return 1\\n        for j in range(int(sqrt(n)) + 1):\\n            if int(sqrt(n - j*j))**2 == n - j*j: return 2\\n            \\n        while n % 4 == 0: \\n            n >>= 2\\n        if n % 8 == 7: return 4\\n        return 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275311,
                "title": "python-dp-bfs",
                "content": "First solution is to use DP.\\nSuppose ```dp[i]``` records to least number of perfect square numbers that sum up to ```i```. And there are multiple ways for perfect square numbers to sum up to ```i```. \\nThe candidate way is to add a perfect square number ```j*j``` to a sum of perfect square numbers that equals to ```i```. And it can be generized as ```i-j*j + j*j```. So the least number of perfect square numbers that sum up to ```i-j*j``` is ```dp[i-j*j]```. So candidate answer is ```dp[i-j*j]+1```(add one more number ```j*j```). \\nSo for ```dp[i]```, we just pick the minimum of all candidates:\\n```\\ndp[i] = min(dp[i-j*j] for j in range(1, int(i**0.5)+1)) + 1\\n```\\nTime complexity is O(n\\u221An). Actually running time is 2500ms.\\n```\\ndef numSquares(n):\\n\\tdp = [0] + [float(\\'inf\\')]*n\\n\\tfor i in range(1, n+1):\\n\\t\\tdp[i] = min(dp[i-j*j] for j in range(1, int(i**0.5)+1)) + 1\\n\\treturn dp[n]\\n```\\n\\nAnother solution is to use BFS.\\nThe root node is ```n```, and we are trying to keep reduce a perfect square number from it each layer. So the next layer nodes are ```{n - i**2 for i in range(1, int(n**0.5)+1)}```. And target leaf node is ```0```, indicates ```n``` is made up of a number of perfect square numbers and depth is the least number of perfect square numbers.\\n```\\ndef numSquares(self, n):\\n\\tsquares = [i**2 for i in range(1, int(n**0.5)+1)]\\n\\td, q, nq = 1, {n}, set()\\n\\twhile q:\\n\\t\\tfor node in q:\\n\\t\\t\\tfor square in squares:\\n\\t\\t\\t\\tif node == square: return d\\n\\t\\t\\t\\tif node < square: break\\n\\t\\t\\t\\tnq.add(node-square)\\n\\t\\tq, nq, d = nq, set(), d+1\\n```\\nEach while loop takes ```Si```, which is the number of the values that is within range ```{1, n}``` whose least number of perfect squares is ```i```. E.g. ```S1 = \\u221An```. \\nSo total time cost should be ```c\\u2211Si = cS1+cS2+...+cSd```. Since I used a set for queue here, ```\\u2211Si \\u2264 n```, and time complexity is O(n). The worst case would be ```n``` happen to have a larger least number of perfect square than any number from ```{1, n-1}```. Actually running time is 220ms.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```dp[i]```\n```i```\n```i```\n```j*j```\n```i```\n```i-j*j + j*j```\n```i-j*j```\n```dp[i-j*j]```\n```dp[i-j*j]+1```\n```j*j```\n```dp[i]```\n```\\ndp[i] = min(dp[i-j*j] for j in range(1, int(i**0.5)+1)) + 1\\n```\n```\\ndef numSquares(n):\\n\\tdp = [0] + [float(\\'inf\\')]*n\\n\\tfor i in range(1, n+1):\\n\\t\\tdp[i] = min(dp[i-j*j] for j in range(1, int(i**0.5)+1)) + 1\\n\\treturn dp[n]\\n```\n```n```\n```{n - i**2 for i in range(1, int(n**0.5)+1)}```\n```0```\n```n```\n```\\ndef numSquares(self, n):\\n\\tsquares = [i**2 for i in range(1, int(n**0.5)+1)]\\n\\td, q, nq = 1, {n}, set()\\n\\twhile q:\\n\\t\\tfor node in q:\\n\\t\\t\\tfor square in squares:\\n\\t\\t\\t\\tif node == square: return d\\n\\t\\t\\t\\tif node < square: break\\n\\t\\t\\t\\tnq.add(node-square)\\n\\t\\tq, nq, d = nq, set(), d+1\\n```\n```Si```\n```{1, n}```\n```i```\n```S1 = \\u221An```\n```c\\u2211Si = cS1+cS2+...+cSd```\n```\\u2211Si \\u2264 n```\n```n```\n```{1, n-1}```",
                "codeTag": "Python3"
            },
            {
                "id": 71533,
                "title": "o-sqrt-n-in-ruby-c-c",
                "content": "These solutions use some number theory (see explanation further down).\\n\\n---\\n\\n**Ruby solution**\\n\\n    require 'prime'\\n    \\n    def num_squares(n)\\n      n /= 4 while n % 4 == 0\\n      return 4 if n % 8 == 7\\n      return 3 if n.prime_division.any? { |p, e| p % 4 == 3 && e.odd? }\\n      (n**0.5).to_i**2 == n ? 1 : 2\\n    end\\n\\nOr:\\n\\n    require 'prime'\\n    \\n    def num_squares(n)\\n      n /= 4 while n % 4 == 0\\n      return 4 if n % 8 == 7\\n      pd = n.prime_division\\n      return 3 if pd.any? { |p, e| p % 4 == 3 && e.odd? }\\n      pd.any? { |_, e| e.odd? } ? 2 : 1\\n    end\\n\\n---\\n\\n**C++ solution**\\n\\n    int numSquares(int n) {\\n        while (n % 4 == 0)\\n            n /= 4;\\n        if (n % 8 == 7)\\n            return 4;\\n        bool min2 = false;\\n        for (int i=2; i<=n; ++i) {\\n            if (i > n/i)\\n                i = n;\\n            int e = 0;\\n            while (n % i == 0)\\n                n /= i, ++e;\\n            if (e % 2 && i % 4 == 3)\\n                return 3;\\n            min2 |= e % 2;\\n        }\\n        return 1 + min2;\\n    }\\n\\n---\\n\\n**C solution**\\n\\nInspired by [kevin36's solution](https://leetcode.com/discuss/57020/java-solution-o-n-1-2-time-and-o-1-space). We don't really need to compute the prime factorization. Knowing that four squares always suffice and using the three-squares test is enough. Single-square and sum-of-two-squares cases can be done simpler.\\n\\n    int numSquares(int n) {\\n        while (n % 4 == 0)\\n            n /= 4;\\n        if (n % 8 == 7)\\n            return 4;\\n        for (int a=0; a*a<=n; ++a) {\\n            int b = sqrt(n - a*a);\\n            if (a*a + b*b == n)\\n                return 1 + !!a;\\n        }\\n        return 3;\\n    }\\n\\n---\\n\\n**Explanation**\\n\\nI happen to have given a little talk about just this topic a while back in a number theory seminar. This problem is completely solved, in the sense of being reduced to simple checks of a number's prime factorization. A natural number is...\\n\\n- ... a **square** if and only if each prime factor occurs to an even power in the number's prime factorization.\\n- ... a [**sum of two squares**](https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares) if and only if each prime factor that's 3 modulo 4 occurs to an even power in the number's prime factorization.\\n- ... a [**sum of three squares**](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem) if and only if it's not of the form 4<sup>a</sup>(8b+7) with integers a and b.\\n- ... a [**sum of four squares**](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem). Period. No condition. You never need more than four.\\n\\nOf course single squares can also be identified by comparing a given number with the square of the rounded root of the number.\\n\\nThe problem statement says *\"1, 4, 9, 16, ...\"*, for some reason apparently excluding 0, but it really is a perfect square and the above theorems do consider it one. With that, you can for example always extend a sum of two squares a<sup>2</sup>+b<sup>2</sup> to the sum of three squares a<sup>2</sup>+b<sup>2</sup>+0<sup>2</sup>. Put differently, if n isn't a sum of three squares, then it also isn't a sum of two squares. So you can read the above statements as *\"... a sum of m **(or fewer)** squares\"*. Thanks to ruben3 for asking about this in the comments.\\n\\nIn my above solutions, I first divide the given number by 4 as often as possible and then do the three-squares check. Dividing by 4 doesn't affect the other checks, and the n % 8 == 7 is cheaper than the prime factorization, so this saves time in cases where we do need four squares.\\n\\nArmed with just the knowledge that you never need more than four squares, it's also easy to write O(n) solutions, e.g.:\\n\\n    int numSquares(int n) {\\n        int ub = sqrt(n);\\n        for (int a=0; a<=ub; ++a) {\\n            for (int b=a; b<=ub; ++b) {\\n                int c = sqrt(n - a*a - b*b);\\n                if (a*a + b*b + c*c == n)\\n                    return !!a + !!b + !!c;\\n            }\\n        }\\n        return 4;\\n    }",
                "solutionTags": [
                    "C++",
                    "Ruby",
                    "Math"
                ],
                "code": "These solutions use some number theory (see explanation further down).\\n\\n---\\n\\n**Ruby solution**\\n\\n    require 'prime'\\n    \\n    def num_squares(n)\\n      n /= 4 while n % 4 == 0\\n      return 4 if n % 8 == 7\\n      return 3 if n.prime_division.any? { |p, e| p % 4 == 3 && e.odd? }\\n      (n**0.5).to_i**2 == n ? 1 : 2\\n    end\\n\\nOr:\\n\\n    require 'prime'\\n    \\n    def num_squares(n)\\n      n /= 4 while n % 4 == 0\\n      return 4 if n % 8 == 7\\n      pd = n.prime_division\\n      return 3 if pd.any? { |p, e| p % 4 == 3 && e.odd? }\\n      pd.any? { |_, e| e.odd? } ? 2 : 1\\n    end\\n\\n---\\n\\n**C++ solution**\\n\\n    int numSquares(int n) {\\n        while (n % 4 == 0)\\n            n /= 4;\\n        if (n % 8 == 7)\\n            return 4;\\n        bool min2 = false;\\n        for (int i=2; i<=n; ++i) {\\n            if (i > n/i)\\n                i = n;\\n            int e = 0;\\n            while (n % i == 0)\\n                n /= i, ++e;\\n            if (e % 2 && i % 4 == 3)\\n                return 3;\\n            min2 |= e % 2;\\n        }\\n        return 1 + min2;\\n    }\\n\\n---\\n\\n**C solution**\\n\\nInspired by [kevin36's solution](https://leetcode.com/discuss/57020/java-solution-o-n-1-2-time-and-o-1-space). We don't really need to compute the prime factorization. Knowing that four squares always suffice and using the three-squares test is enough. Single-square and sum-of-two-squares cases can be done simpler.\\n\\n    int numSquares(int n) {\\n        while (n % 4 == 0)\\n            n /= 4;\\n        if (n % 8 == 7)\\n            return 4;\\n        for (int a=0; a*a<=n; ++a) {\\n            int b = sqrt(n - a*a);\\n            if (a*a + b*b == n)\\n                return 1 + !!a;\\n        }\\n        return 3;\\n    }\\n\\n---\\n\\n**Explanation**\\n\\nI happen to have given a little talk about just this topic a while back in a number theory seminar. This problem is completely solved, in the sense of being reduced to simple checks of a number's prime factorization. A natural number is...\\n\\n- ... a **square** if and only if each prime factor occurs to an even power in the number's prime factorization.\\n- ... a [**sum of two squares**](https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares) if and only if each prime factor that's 3 modulo 4 occurs to an even power in the number's prime factorization.\\n- ... a [**sum of three squares**](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem) if and only if it's not of the form 4<sup>a</sup>(8b+7) with integers a and b.\\n- ... a [**sum of four squares**](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem). Period. No condition. You never need more than four.\\n\\nOf course single squares can also be identified by comparing a given number with the square of the rounded root of the number.\\n\\nThe problem statement says *\"1, 4, 9, 16, ...\"*, for some reason apparently excluding 0, but it really is a perfect square and the above theorems do consider it one. With that, you can for example always extend a sum of two squares a<sup>2</sup>+b<sup>2</sup> to the sum of three squares a<sup>2</sup>+b<sup>2</sup>+0<sup>2</sup>. Put differently, if n isn't a sum of three squares, then it also isn't a sum of two squares. So you can read the above statements as *\"... a sum of m **(or fewer)** squares\"*. Thanks to ruben3 for asking about this in the comments.\\n\\nIn my above solutions, I first divide the given number by 4 as often as possible and then do the three-squares check. Dividing by 4 doesn't affect the other checks, and the n % 8 == 7 is cheaper than the prime factorization, so this saves time in cases where we do need four squares.\\n\\nArmed with just the knowledge that you never need more than four squares, it's also easy to write O(n) solutions, e.g.:\\n\\n    int numSquares(int n) {\\n        int ub = sqrt(n);\\n        for (int a=0; a<=ub; ++a) {\\n            for (int b=a; b<=ub; ++b) {\\n                int c = sqrt(n - a*a - b*b);\\n                if (a*a + b*b + c*c == n)\\n                    return !!a + !!b + !!c;\\n            }\\n        }\\n        return 4;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 2837992,
                "title": "java-recursion-memoization-dp-3-square-theorem-explained",
                "content": "**Approach #1: Brute Force (Recursion) - TLE**\\n\\n```\\npublic int numSquares(int n) {\\n\\tif (n < 4)\\n\\t\\treturn n;\\n\\t\\n\\tint ans = n;\\n\\t\\n\\tfor (int i = 1; i * i <= n; i++) {\\n\\t\\tint square = i * i;\\n\\t\\tans = Math.min(ans, 1 + numSquares(n - square));\\n\\t}\\n\\t\\n\\treturn ans;\\n}\\n```\\n\\n**Approach #2: Top Down DP (Recursion + Memoization)**\\n\\n```\\n// Time complexity: O(N * sqrt(N))\\n// Space complexity: O(N)\\n\\t\\nclass Solution {\\n    public int numSquares(int n) {\\n        int[] memo = new int[n + 1];\\n        return helper(n, memo);\\n    }\\n    \\n    public int helper(int n, int[] memo) {\\n        if (n < 4)\\n            return n;\\n        \\n        if (memo[n] != 0)\\n            return memo[n];\\n        \\n        int ans = n;\\n        \\n        for (int i = 1; i * i <= n; i++) {\\n            int square = i * i;\\n            ans = Math.min(ans, 1 + helper(n - square, memo));\\n        }\\n        \\n        return memo[n] = ans;\\n    }\\n}\\n```\\n\\n**Approach #3: Bottom UP DP (Using DP Array)**\\n\\n```\\n// Time complexity: O(N * sqrt(N))\\n// Space complexity: O(N)\\n\\npublic int numSquares(int n) {\\n\\tint[] dp = new int[n + 1];\\n\\tdp[0] = 0;\\n\\t\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tdp[i] = i;\\n\\t\\t\\n\\t\\tfor (int j = 1; j * j <= i; j++) {\\n\\t\\t\\tint square = j * j;\\n\\t\\t\\tdp[i] = Math.min(dp[i], 1 + dp[i - square]);\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn dp[n];\\n}\\n```\\n\\n**Approach #4: Legendre\\'s 3-Square Theorem**\\n\\n* 4-Square theorem: Every natural no is sum of 4 squares.\\n* 3-Square Theorem: Every natural no is sum of 3 squares if it does not satisfies 4^a (8b + 7) = N\\n* So our answer will be 1, 2, 3 or 4.\\n\\n**Steps:**\\n* If it\\'s perfect square, return 1\\n* If it satisfies 4^a (8b + 7), return 4\\n* If it\\'s sum of 2 perfect squares, return 2\\n* Otherwise, return 3\\n\\n```\\n// Time complexity: O(sqrt(N))\\n// Space complexity: O(1)\\n\\t\\npublic int numSquares(int n) {\\n\\tint sqrt = (int) Math.sqrt(n);\\n\\n\\tif (sqrt * sqrt == n) // Perfect square\\n\\t\\treturn 1;\\n\\n\\twhile (n % 4 == 0) // 4^a (8b + 7)\\n\\t\\tn = n / 4;\\n\\n\\tif (n % 8 == 7)\\n\\t\\treturn 4;\\n\\n\\tfor (int i = 1; i * i <= n; i++) { // Sum of two perfect squares\\n\\t\\tint square = i * i;\\n\\t\\tint base = (int) Math.sqrt(n - square);\\n\\n\\t\\tif (base * base == n - square)\\n\\t\\t\\treturn 2;\\n\\t}\\n\\n\\treturn 3;\\n}\\n```\\n\\n**Please upvote if you find these solutions useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\npublic int numSquares(int n) {\\n\\tif (n < 4)\\n\\t\\treturn n;\\n\\t\\n\\tint ans = n;\\n\\t\\n\\tfor (int i = 1; i * i <= n; i++) {\\n\\t\\tint square = i * i;\\n\\t\\tans = Math.min(ans, 1 + numSquares(n - square));\\n\\t}\\n\\t\\n\\treturn ans;\\n}\\n```\n```\\n// Time complexity: O(N * sqrt(N))\\n// Space complexity: O(N)\\n\\t\\nclass Solution {\\n    public int numSquares(int n) {\\n        int[] memo = new int[n + 1];\\n        return helper(n, memo);\\n    }\\n    \\n    public int helper(int n, int[] memo) {\\n        if (n < 4)\\n            return n;\\n        \\n        if (memo[n] != 0)\\n            return memo[n];\\n        \\n        int ans = n;\\n        \\n        for (int i = 1; i * i <= n; i++) {\\n            int square = i * i;\\n            ans = Math.min(ans, 1 + helper(n - square, memo));\\n        }\\n        \\n        return memo[n] = ans;\\n    }\\n}\\n```\n```\\n// Time complexity: O(N * sqrt(N))\\n// Space complexity: O(N)\\n\\npublic int numSquares(int n) {\\n\\tint[] dp = new int[n + 1];\\n\\tdp[0] = 0;\\n\\t\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tdp[i] = i;\\n\\t\\t\\n\\t\\tfor (int j = 1; j * j <= i; j++) {\\n\\t\\t\\tint square = j * j;\\n\\t\\t\\tdp[i] = Math.min(dp[i], 1 + dp[i - square]);\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn dp[n];\\n}\\n```\n```\\n// Time complexity: O(sqrt(N))\\n// Space complexity: O(1)\\n\\t\\npublic int numSquares(int n) {\\n\\tint sqrt = (int) Math.sqrt(n);\\n\\n\\tif (sqrt * sqrt == n) // Perfect square\\n\\t\\treturn 1;\\n\\n\\twhile (n % 4 == 0) // 4^a (8b + 7)\\n\\t\\tn = n / 4;\\n\\n\\tif (n % 8 == 7)\\n\\t\\treturn 4;\\n\\n\\tfor (int i = 1; i * i <= n; i++) { // Sum of two perfect squares\\n\\t\\tint square = i * i;\\n\\t\\tint base = (int) Math.sqrt(n - square);\\n\\n\\t\\tif (base * base == n - square)\\n\\t\\t\\treturn 2;\\n\\t}\\n\\n\\treturn 3;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71605,
                "title": "java-dp-solution-with-explanation",
                "content": "    public class Solution {\\n    public int numSquares(int n) {\\n        int[] dp = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int sqrt = (int)Math.sqrt(i);\\n            \\n            // If the number is already a perfect square,\\n            // then dp[number] can be 1 directly. This is\\n            // just a optimization for this DP solution.\\n            if (sqrt * sqrt == i) {\\n                dp[i] = 1;\\n                continue;                \\n            }\\n            \\n            // To get the value of dp[n], we should choose the min\\n            // value from:\\n            //     dp[n - 1] + 1,\\n            //     dp[n - 4] + 1,\\n            //     dp[n - 9] + 1,\\n            //     dp[n - 16] + 1\\n            //     and so on...\\n            for (int j = 1; j <= sqrt; j++) {\\n                int dif = i - j * j;\\n                dp[i] = Math.min(dp[i], (dp[dif] + 1));\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numSquares(int n) {\\n        int[] dp = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = Integer.MAX_VALUE;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2838408,
                "title": "python-c-java-rust-faster-than-99-math-dp-bonus-one-liner-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs several facts from mathematics and a cheap brute force. Time complexity **O(sqrtN)**. Space complexity is **O(1)**. \\n****\\n\\n**Comment.** This solution employs the following known facts from mathematics regarding the decomposition of a number into a sum of squares:\\n * [**Lagrange\\'s four-square theorem**](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem), stating that every natural number can be represented as the sum of four integer squares, and\\n * [**Legendre\\'s three-square theorem**](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem), stating that a natural number `n` can be represented as the sum of three squares of integers if and only if `n` is **NOT** of the form `n=4**a * (8*b+7)` for nonnegative integers `a` and `b`.\\n\\nThus, our strategy for solving this problem is to perform trivial tests for 1 & 3 summands, brute force for 2 summands and return 4 if all of those tests failed.\\n\\n**Python #1.** Smart brute-force (for only pairs of squares). This [**solution**](https://leetcode.com/submissions/detail/847883817/) demonstrated **25 ms runtime (99.95%)**. \\n```\\nfrom math import isqrt\\n\\nclass Solution:\\n    def numSquares(self , n):\\n        \\n        if isqrt(n)**2 == n : return 1               # [1] already a square\\n        \\n        for i in range(1,isqrt(n)+1):                # [2] check pairs of squares\\n            if (j := n - i**2) == isqrt(j)**2:\\n                return 2\\n            \\n        while n % 4 == 0 : n /= 4                    # [3] well, it\\'s maths, namely,\\n        if    n % 8 != 7 : return 3                  #     the Legendre\\'s theorem\\n        \\n        return 4                                     # [4] the only remaining option\\n```\\n\\nFor those who are not satisified with using math tricks...\\n\\n**Python #2.** Straightforward DP. Here we use a trick with `dp` being a variable that is initialized just once for all tests (thx **@md2030** for the hint that I modified a bit).\\n```\\nfrom math import isqrt\\n\\nclass Solution:\\n    \\n    def numSquares(self, n: int, dp = [0]) -> int:\\n\\n        for k in range(len(dp), n+1):\\n            if k == len(dp) : dp.append(inf)\\n            for i in range(1, isqrt(k)+1):\\n                dp[k] = min(dp[k], 1 + dp[k - (i*i)])\\n                \\n        return dp[n]\\n```\\n\\nFirst solution in other languages.\\n\\n<iframe src=\"https://leetcode.com/playground/GMVFzZkR/shared\" frameBorder=\"0\" width=\"800\" height=\"400\"></iframe>\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python #3.** This one-liner uses the same approach with `dp` being a shared map for all tests. Please note the trick with memoization of values and their extraction right inside the one-liner.\\n```\\nfrom math import isqrt\\n\\nclass Solution:\\n    def numSquares(self, n: int, dp={}) -> int:\\n        return min((dp.update({s:self.numSquares(s)}) is None) * dp[s]\\n                   if (s:=n-k**2) not in dp else dp[s]\\n                   for k in range(1,isqrt(n)+1)) + 1 if n != isqrt(n)**2 else 1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import isqrt\\n\\nclass Solution:\\n    def numSquares(self , n):\\n        \\n        if isqrt(n)**2 == n : return 1               # [1] already a square\\n        \\n        for i in range(1,isqrt(n)+1):                # [2] check pairs of squares\\n            if (j := n - i**2) == isqrt(j)**2:\\n                return 2\\n            \\n        while n % 4 == 0 : n /= 4                    # [3] well, it\\'s maths, namely,\\n        if    n % 8 != 7 : return 3                  #     the Legendre\\'s theorem\\n        \\n        return 4                                     # [4] the only remaining option\\n```\n```\\nfrom math import isqrt\\n\\nclass Solution:\\n    \\n    def numSquares(self, n: int, dp = [0]) -> int:\\n\\n        for k in range(len(dp), n+1):\\n            if k == len(dp) : dp.append(inf)\\n            for i in range(1, isqrt(k)+1):\\n                dp[k] = min(dp[k], 1 + dp[k - (i*i)])\\n                \\n        return dp[n]\\n```\n```\\nfrom math import isqrt\\n\\nclass Solution:\\n    def numSquares(self, n: int, dp={}) -> int:\\n        return min((dp.update({s:self.numSquares(s)}) is None) * dp[s]\\n                   if (s:=n-k**2) not in dp else dp[s]\\n                   for k in range(1,isqrt(n)+1)) + 1 if n != isqrt(n)**2 else 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71505,
                "title": "simple-java-dp-solution",
                "content": "Just regular DP. Time Complexity: n * sqrt(n)   Space: O(n)\\n\\n    public class Solution {\\n        public int numSquares(int n) {\\n           int[] dp = new int[n + 1];\\n           Arrays.fill(dp, Integer.MAX_VALUE);\\n           dp[0] = 0;\\n           for(int i = 0; i <= n; i++){\\n               for(int j = 1; i + j * j <= n; j++){\\n                   dp[i  + j * j] = Math.min(dp[i + j * j], dp[i] + 1);\\n                }\\n           }\\n           return dp[n];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int numSquares(int n) {\\n           int[] dp = new int[n + 1];\\n           Arrays.fill(dp, Integer.MAX_VALUE);\\n           dp[0] = 0;\\n           for(int i = 0; i <= n; i++){\\n               for(int j = 1; i + j * j <= n; j++){\\n                   dp[i  + j * j] = Math.min(dp[i + j * j], dp[i] + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2837770,
                "title": "python3-dp-with-detailed-explanations-o-n-sqrt-n-not-tle",
                "content": "DP is the best solution I can comeup with, there is a [mathematics solution](https://leetcode.com/problems/perfect-squares/discuss/2837639/Python-3-oror-no-dp-just-mathematics-wbrief-explanation-oror-TM%3A-10084), I\\'m not sure what the interviewer is expecting, anyone has any ideas?\\n\\n**naive DP (TLE)**\\n(1) ```dp[i]``` means the least number of perfect squares that sum to ```i```, so return ```dp[n]``` at the end.\\n(2) ```dp[i] = 1``` if ```i``` is a perfect square.\\n(3) ```dp[i] = min(dp[i], dp[i-j] + dp[j] )```, where 0<=j<i. \\nThis is because:\\n - the least number of perfect squares that sum to ```i``` **=** the least number of perfect squares that sum to ```i-j``` **+** the least number of perfect squares that sum to ```j```.\\n - since j<i, we already know the least number of perfect squares that sum to ```j``` and ```i-j``` in our ```dp``` array.\\n\\n(4) return dp[n]\\n\\n**TC: O(n^2)** Since for each ```i``` 1<=i<=n, we need to check all j, where 0<=j<i.\\n\\n```python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\n        # The dp array.\\n        dp = [inf] * (n+1)\\n        \\n        for i in range(1,n+1):\\n            \\n            # calculate the square of i, dp[i_sq] to 1.\\n            i_sq = pow(i,2)\\n            if i_sq <= n:\\n                dp[i_sq] = 1\\n            \\n            # dp equation\\n            for j in range(i):\\n                dp[i] = min(dp[i],dp[i-j]+dp[j])\\n\\n        return dp[n]\\n```\\n\\n**Better DP (sometimes TLE)**\\nThe most time comsuming process from the last solution is to check all j, where 0<=j<i.\\nA better solution would be not checking all ```j```, but only check ```j``` if ```j``` is a prefect square. The reason behind this are:\\n - Let\\'s say the two numbers which sum up to ```i``` are ```j``` and ```i-j```, but none of them is prefect square, then there has to be at least one perfect square which was used to construct ```j```. Same thing for ```i-j```.\\n - The number of perfect squares in ```dp[j] = a non zero + 1``` and ```dp[i-j] = a non zero + 1```. There is a non zero number because ```j``` and ```i-j``` are not perfect squares (if they are, they will be 1).\\n - Then, ```dp[j] + dp[i-j] = a non zero + 1  +  a non zero + 1 = a non zero + 2``` which will be larger than if either ```j``` or ```i-j``` is a perfect square.\\n - e.g., if ```j``` is a perfect square, then dp[j] = 1, and ```dp[j] + dp[i-j] = a non zero + 1```\\n This lead to the next dp algorithm, which we will only check ```j``` if ```j``` is a perfect square.\\n \\n The dp equation becomes\\n ```dp[i] = min(dp[i], dp[i-j] + dp[j] )```, where 0<=j<i. **```j``` is a perfect square**.\\n\\n note that since j is a perfect square, then dp[j]=1, the equation becomes:\\n ```dp[i] = min(dp[i], dp[i-j] + 1 )```, where 0<=j<i. **```j``` is a perfect square**.\\n\\n**TC: O(n sqrt(n))** Since for each ```i``` 0<=i<=n, we only check ```j``` if ```j``` is a perfect square and there are at most sqrt(n) perfect squares smaller than n.\\n\\n```python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        # Store all perfect square <= n.\\n        perfectSq = []\\n        \\n        # The dp array.\\n        dp = [inf] * (n+1)\\n        \\n        for i in range(1,n+1):\\n            \\n            # calculate the square of i, dp[i_sq] to 1.\\n            # if i_sq is smaller than or equal to n, we store it, for the dp equation.\\n            i_sq = pow(i,2)\\n            if i_sq <= n:\\n                perfectSq.append(i_sq)\\n                dp[i_sq] = 1\\n            \\n            # dp equation\\n            for ps in perfectSq:\\n            \\t# i has to be smaller than the perfect square number that is used to construct i\\n                if i<ps: break\\n                \\n                dp[i] = min(dp[i],1+dp[i-ps])\\n                # it is the same as dp[i] = min(dp[i],dp[ps]+dp[i-ps]) because dp[ps]=1\\n\\n        return dp[n]\\n```\\n\\n**Not Time Limit Exceeded:** You may get TLE using the previous one, here is an interesting modification: **Make ```dp``` a class variable**, so that it will not rebuild ```dp``` from 0 for different testing cases.\\n\\n```python\\nclass Solution:\\n    \\n    # Make dp a class variable :)\\n    dp = [0]\\n\\n    def numSquares(self, n: int) -> int:\\n\\n        dp = self.dp\\n        \\n        # Precompute the perfect squares.\\n        perfectSq = [pow(i,2) for i in range(1, int(sqrt(n))+1)]\\n        \\n        # We are building dp up to length n+1.\\n        while len(dp) < n+1:\\n            \\n            # Will add this new element to dp\\n            dpI = inf\\n            \\n            # dp equation\\n            for ps in perfectSq:\\n                if len(dp)<ps: break\\n                dpI = min(dpI,1+dp[-ps])\\n            \\n            dp.append(dpI)\\n        \\n        return dp[n]\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```dp[i]```\n```i```\n```dp[n]```\n```dp[i] = 1```\n```i```\n```dp[i] = min(dp[i], dp[i-j] + dp[j] )```\n```i```\n```i-j```\n```j```\n```j```\n```i-j```\n```dp```\n```i```\n```python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\n        # The dp array.\\n        dp = [inf] * (n+1)\\n        \\n        for i in range(1,n+1):\\n            \\n            # calculate the square of i, dp[i_sq] to 1.\\n            i_sq = pow(i,2)\\n            if i_sq <= n:\\n                dp[i_sq] = 1\\n            \\n            # dp equation\\n            for j in range(i):\\n                dp[i] = min(dp[i],dp[i-j]+dp[j])\\n\\n        return dp[n]\\n```\n```j```\n```j```\n```j```\n```i```\n```j```\n```i-j```\n```j```\n```i-j```\n```dp[j] = a non zero + 1```\n```dp[i-j] = a non zero + 1```\n```j```\n```i-j```\n```dp[j] + dp[i-j] = a non zero + 1  +  a non zero + 1 = a non zero + 2```\n```j```\n```i-j```\n```j```\n```dp[j] + dp[i-j] = a non zero + 1```\n```j```\n```j```\n```dp[i] = min(dp[i], dp[i-j] + dp[j] )```\n```j```\n```dp[i] = min(dp[i], dp[i-j] + 1 )```\n```j```\n```i```\n```j```\n```j```\n```python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        # Store all perfect square <= n.\\n        perfectSq = []\\n        \\n        # The dp array.\\n        dp = [inf] * (n+1)\\n        \\n        for i in range(1,n+1):\\n            \\n            # calculate the square of i, dp[i_sq] to 1.\\n            # if i_sq is smaller than or equal to n, we store it, for the dp equation.\\n            i_sq = pow(i,2)\\n            if i_sq <= n:\\n                perfectSq.append(i_sq)\\n                dp[i_sq] = 1\\n            \\n            # dp equation\\n            for ps in perfectSq:\\n            \\t# i has to be smaller than the perfect square number that is used to construct i\\n                if i<ps: break\\n                \\n                dp[i] = min(dp[i],1+dp[i-ps])\\n                # it is the same as dp[i] = min(dp[i],dp[ps]+dp[i-ps]) because dp[ps]=1\\n\\n        return dp[n]\\n```\n```dp```\n```dp```\n```python\\nclass Solution:\\n    \\n    # Make dp a class variable :)\\n    dp = [0]\\n\\n    def numSquares(self, n: int) -> int:\\n\\n        dp = self.dp\\n        \\n        # Precompute the perfect squares.\\n        perfectSq = [pow(i,2) for i in range(1, int(sqrt(n))+1)]\\n        \\n        # We are building dp up to length n+1.\\n        while len(dp) < n+1:\\n            \\n            # Will add this new element to dp\\n            dpI = inf\\n            \\n            # dp equation\\n            for ps in perfectSq:\\n                if len(dp)<ps: break\\n                dpI = min(dpI,1+dp[-ps])\\n            \\n            dp.append(dpI)\\n        \\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513258,
                "title": "very-easy-to-understand-with-picture-python-recursion-memoization",
                "content": "**279. Perfect Squares**\\n\\nHey Everyone I will try to explain the solution through some pictures. **How each piece of code is working**!!!\\nWas going through DISCUSS Section but coudn\\'t wrap my head around why certain lines were written, so after figuring out I tried to share it out here to save someone\\'s else time.This question has been tagged under **AMAZON** in some places..LET\\'S BEGIN.\\n\\n **RECURSIVE CODE** [ TLE ]\\n________________________________\\n\\n````\\ndef solve(n):\\n\\n    if n==0:                                                     # part 1\\n        return 0\\n\\t\\t\\n    if n<0:                                                      # part 2\\n        return float(\"inf\")\\n\\t\\t\\n    mini = n                                                     # part 3 \\n\\t\\n    i = 1\\n    while i*i<=n:                                                # part 4\\n        mini = min(mini, solve(n-(i*i)))\\n        i+=1\\n\\t\\t\\n    return mini+1                                                # part 5\\n\\nsolve(n)\\n````\\n\\n**Edit ( TC )** - First we have to pay attention on while loop. It takes O( sqrt(n) ). Next we have to pay attention on the recursive call ```min( mini,  solve( n- ( i * i )))```. In case when our ```i == 1``` we are able to create the longest way. Because of that we can come to a conclusion that the maximum number of levels in a decision tree will be n. Taking all of this into consideration and knowing the width of a tree level and the height of the whole tree we can say that the overall TC of brute recusion is **O( sqrt(n) ^ n - 1 )**  . \\n**Credit** -  [Maxim](https://leetcode.com/_Maximus_/)\\n\\n--------\\n\\n\\nLet\\'s First Have A Look Over How Our DECISION TREE Looks Like !! \\n\\n\\n![image](https://assets.leetcode.com/users/images/4bda9ee4-a4d3-41bc-9180-5f1f931bab23_1633835670.4654868.jpeg)\\n\\n\\n__________________________\\n--> **PART 1 [ BASE CASE  ]**\\n____________________________\\n\\nWhen our call hits base case and n becomes 0 we know there is a possible way to split our target.\\nSince in ques we have to find the **min** possible way.\\nThere is no case where mini becomes less than 0 . So we return 0 that indicates we found a **Possible Set Of Candidates.**\\n______________________________\\n--> **PART 2**\\n_______________\\nSame logic as above if our n becomes less than 0 we know there is no possible way to split our target.\\n\\n___________________________________________________\\n--> **PART 3 [  WHY ```mini = n ??``` THIS PART WAS HARD FOR ME TO UNDERSTAND :( ]**\\n_______________________\\n\\nSuppose we are at a point in our recursion call where n = 12 !!\\nwhat could be the max count to split 12 so that each element is a perfect square??\\n\\nYES u are right :)  **12 = 1 + 1+ 1+ 1+1+ 1+ 1+1 +1+1+1 +1 ( 12 times 1 )**\\nwe cant get any maximum value than 12 for 12  thats why mini = n which is 12 in this case.\\n___________________________________\\n--> **PART 4 [ WHILE LOOP PART ]**\\n_______________________________\\n\\nWhat is ***least possible perfect Square candidate*** for our ans??\\nYES It is 1 so we start our loop from ```i=1```\\n\\nNow upto what value of ```i``` our loop should execute???\\nYES till  ```n >= i^2``` ( in short upto that value when n - i^2 is +ve )\\n\\nWHY??\\nbecause after that we will call at value < 0  which anyhow our function will **return infinity** since n<0 **remember base case  PART 2. but will lead to infinite looping**\\n____________________\\n--> **PART 5  [ WHY ```mini+1```?? ]**\\n_________________\\n\\nWe are counting the steps isnt it??\\n\\nWhen we hit the base case ```n==0``` we return **0**.  \\n\\nAlso one path for 5 = 1+1+1+1+1 .\\n**Last 1 will get 0** (BASE CASE)  and  **it will be returning 0+1**\\n\\nso ```step count = 0 + 1 + 1 + 1 + 1 + 1 = 5```\\n\\nsee the picture for better understanding\\n\\n![image](https://assets.leetcode.com/users/images/7f856800-999e-4aea-99b1-1c3e74622761_1633835643.2424138.jpeg)\\n\\n\\n**MEMOIZATION [ ACCEPTED ]**\\n____________________________\\n```\\ndef solve(n):\\n    if n==0:\\n        return 0\\n    if n<0:\\n        return float(\"inf\")\\n    if memo[n]!=-1:\\n        return memo[n]\\n    mini = n\\n    i = 1\\n    while i*i<=n:\\n        mini = min(mini, solve(n-(i*i)))\\n        i+=1\\n    memo[n] = mini+1\\n    return memo[n]\\n    \\nmemo = [-1]*(n+1)\\nsolve(n)\\n```\\n\\nthank you!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "````\\ndef solve(n):\\n\\n    if n==0:                                                     # part 1\\n        return 0\\n\\t\\t\\n    if n<0:                                                      # part 2\\n        return float(\"inf\")\\n\\t\\t\\n    mini = n                                                     # part 3 \\n\\t\\n    i = 1\\n    while i*i<=n:                                                # part 4\\n        mini = min(mini, solve(n-(i*i)))\\n        i+=1\\n\\t\\t\\n    return mini+1                                                # part 5\\n\\nsolve(n)\\n```\n```min( mini,  solve( n- ( i * i )))```\n```i == 1```\n```mini = n ??```\n```i=1```\n```i```\n```n >= i^2```\n```mini+1```\n```n==0```\n```step count = 0 + 1 + 1 + 1 + 1 + 1 = 5```\n```\\ndef solve(n):\\n    if n==0:\\n        return 0\\n    if n<0:\\n        return float(\"inf\")\\n    if memo[n]!=-1:\\n        return memo[n]\\n    mini = n\\n    i = 1\\n    while i*i<=n:\\n        mini = min(mini, solve(n-(i*i)))\\n        i+=1\\n    memo[n] = mini+1\\n    return memo[n]\\n    \\nmemo = [-1]*(n+1)\\nsolve(n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 71618,
                "title": "4ms-c-code-solve-it-mathematically",
                "content": "    class Solution {  \\n    public:  \\n        int is_square(int n){  \\n            int temp = (int) sqrt(n);  \\n            return temp * temp == n;  \\n        }  \\n        int numSquares(int n) {  \\n            while ((n & 3) == 0) //n%4 == 0  \\n                n >>= 2;  \\n            if ((n & 7) == 7) return 4; //n % 8 == 7  \\n            if(is_square(n)) return 1;  \\n            int sqrt_n = (int) sqrt(n);  \\n            for(int i = 1; i<= sqrt_n; i++){  \\n                if (is_square(n-i*i)) return 2;  \\n            }  \\n            return 3;  \\n        }  \\n    };  \\n\\nUPDATE: in order to understand, I suggest u read:\\n\\nhere is the Lagrange's Four Square theorem - Limit the result to <= 4:\\n[https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem)\\n\\nAnd this article, in which you can also find the way to present a number as a sum of four squares:\\n[http://www.alpertron.com.ar/4SQUARES.HTM](http://www.alpertron.com.ar/4SQUARES.HTM)",
                "solutionTags": [],
                "code": "class Solution {  \\n    public:  \\n        int is_square(int n){  \\n            int temp = (int) sqrt(n);  \\n            return temp * temp == n;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2837639,
                "title": "python-3-no-dp-just-mathematics-w-brief-explanation-t-m-100-82",
                "content": "(*Updated March 2023*)\\n\\nThe following theorems allow a straight-forward path to the solution for any positive integer:\\n*  k = 1:     *Spaulding\\'s One-Square Theorem*\\n*  k = 2: *Fermat\\'s Two-Square Theorem*\\n*   k = 3: *Legendre\\'s Three-Square Theorem*\\n*    k = 4: *Lagrange\\'s Four-Square Theorem*\\n    \\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\n        def CheckTwo(c):                       \\n            while c%2==0: c=c//2\\n            while c%5==0: c=c//5\\n            while c%9==0: c=c//9\\n\\n            if c%3==0: return False\\n\\n            if c in (0,1,13,17): return True\\n\\n            i, j = 0, isqrt(c)\\n\\n            while i <= j:\\n                if i*i + j*j == c: return True\\n                if i*i + j*j < c: i += 1\\n                if i*i + j*j > c: j -= 1\\n\\n            return  False\\n\\n        if n == isqrt(n)**2:return 1                # case k = 1       \\n\\n        if CheckTwo(n): return 2                    # case k = 2\\n\\n        while n%4 ==0: n//=4                        # case k = 3  \\n        if n%8 != 7: return 3 \\n        \\n        return 4                                    # case k = 4\\n```\\n[https://leetcode.com/problems/perfect-squares/submissions/928021429/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\n        def CheckTwo(c):                       \\n            while c%2==0: c=c//2\\n            while c%5==0: c=c//5\\n            while c%9==0: c=c//9\\n\\n            if c%3==0: return False\\n\\n            if c in (0,1,13,17): return True\\n\\n            i, j = 0, isqrt(c)\\n\\n            while i <= j:\\n                if i*i + j*j == c: return True\\n                if i*i + j*j < c: i += 1\\n                if i*i + j*j > c: j -= 1\\n\\n            return  False\\n\\n        if n == isqrt(n)**2:return 1                # case k = 1       \\n\\n        if CheckTwo(n): return 2                    # case k = 2\\n\\n        while n%4 ==0: n//=4                        # case k = 3  \\n        if n%8 != 7: return 3 \\n        \\n        return 4                                    # case k = 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837605,
                "title": "complete-intuition-explained-recursion-memo-dp",
                "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\n**Take the given target, subtract perfect squares to make it \"0\".**\\n\\n#We need to subtract perfect squares optimally to make the target 0\\n#We need to keep perfect squares as minimum as possible\\n#But we have **many options** of perfect squares to subtract \\n->**For target = 18**\\n->**we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]**\\n#If you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n  18 - (4^2) = 2\\n  2 - (1^2) = 1   //Future    \\n  1 - (1^2) = 0   //Future   **[3 STEPS]**\\n\\n#But actually picking (9) at first step would prove to be optimal here\\n  18 - (3^3) = 9\\n  9 - (3^3) = 0 //Future **[2 STEPS]**\\n\\n\\n\\n#We are **\"NOT SURE\"** if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\n#So whenever you are not sure which step would be optimal, **no need to stress on guessing** the optimal one, just =>\\n**\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"**\\n#So for any given target, just try all the perfect squares you can subtract \\n\\n    target(18) => [18 - (1^2) = 17] =>target(17)\\n\\ttarget(18) => [18 - (2^2) = 14] => target(14)\\n    target(18) => [18 - (3^2) = 9] => target(9)\\n    target(18) => [18 - (4^2) = 2] => target(2)\\n                \\n#Now we have a smaller subproblem, which could be solved using recursion \\n#so \\n  for **target(18) = 1 + min (target(17), target(14), target(9), target(2))**\\n#Let recursion do it\\'s work and you just use those hardworked results in you favour :)\\n//========================================================================================================\\n#### RECURSION ==> \\n```\\nclass Solution {\\npublic:\\n    int solve(int n)\\n    {\\n        if (n == 0) return 0;\\n        \\n        int mnCount = INT_MAX;\\n        for (int num = 1; num <= sqrt(n); num++)\\n        {\\n            int sqNum = num * num;\\n            int currCount = 1 + solve(n - sqNum);\\n            mnCount = min(mnCount, currCount);\\n        }\\n        return mnCount;\\n    }\\n    int numSquares(int n) \\n    {\\n        return solve(n);\\n    }\\n};\\n```\\n//==========================================================================================================================\\n#### MEMOIZATION ==>\\n```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int>&dp)\\n    {\\n        if (n == 0) return 0;\\n        if (dp[n] != -1) return dp[n];\\n        \\n        int mnCount = INT_MAX;\\n        for (int num = 1; num <= sqrt(n); num++)\\n        {\\n            int sqNum = num * num;\\n            int currCount = 1 + solve(n - sqNum, dp);\\n            mnCount = min(mnCount, currCount);\\n        }\\n        return dp[n] = mnCount;\\n    }\\n    int numSquares(int n) \\n    {\\n        vector<int>dp(n + 1, -1);\\n        return solve(n, dp);\\n    }\\n};\\n```\\n//====================================================================================================================\\n#### DP ==>\\n```\\nclass Solution {\\npublic:\\n    int solve(int n)\\n    {\\n        vector<int>dp(n + 1, INT_MAX);\\n        dp[0] = 0; \\n        for (int target = 1; target <= n; target++)\\n        {\\n            int mnCount = INT_MAX;\\n            for (int num = 1; num <= sqrt(target); num++)\\n            {\\n                int sqNum = num * num;\\n                int currCount = 1 + dp[target - sqNum];\\n                mnCount = min(mnCount, currCount);\\n            }\\n            dp[target] = mnCount;\\n        }\\n        return dp[n];\\n    } \\n    int numSquares(int n) \\n    {\\n        return solve(n);\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n)\\n    {\\n        if (n == 0) return 0;\\n        \\n        int mnCount = INT_MAX;\\n        for (int num = 1; num <= sqrt(n); num++)\\n        {\\n            int sqNum = num * num;\\n            int currCount = 1 + solve(n - sqNum);\\n            mnCount = min(mnCount, currCount);\\n        }\\n        return mnCount;\\n    }\\n    int numSquares(int n) \\n    {\\n        return solve(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int>&dp)\\n    {\\n        if (n == 0) return 0;\\n        if (dp[n] != -1) return dp[n];\\n        \\n        int mnCount = INT_MAX;\\n        for (int num = 1; num <= sqrt(n); num++)\\n        {\\n            int sqNum = num * num;\\n            int currCount = 1 + solve(n - sqNum, dp);\\n            mnCount = min(mnCount, currCount);\\n        }\\n        return dp[n] = mnCount;\\n    }\\n    int numSquares(int n) \\n    {\\n        vector<int>dp(n + 1, -1);\\n        return solve(n, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int n)\\n    {\\n        vector<int>dp(n + 1, INT_MAX);\\n        dp[0] = 0; \\n        for (int target = 1; target <= n; target++)\\n        {\\n            int mnCount = INT_MAX;\\n            for (int num = 1; num <= sqrt(target); num++)\\n            {\\n                int sqNum = num * num;\\n                int currCount = 1 + dp[target - sqNum];\\n                mnCount = min(mnCount, currCount);\\n            }\\n            dp[target] = mnCount;\\n        }\\n        return dp[n];\\n    } \\n    int numSquares(int n) \\n    {\\n        return solve(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71632,
                "title": "beautiful-8-lines-java-solution",
                "content": "    public class Solution {\\n        public int numSquares(int n) {\\n            int[] record = new int[n+1];\\n            for(int i=0;i<=n;i++){\\n                record[i] = i;\\n                for(int j=1;j*j<=i;j++){\\n                    record[i] = Math.min(record[i-j*j]+1,record[i]);\\n                }\\n            }\\n            return record[n];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int numSquares(int n) {\\n            int[] record = new int[n+1];\\n            for(int i=0;i<=n;i++){\\n                record[i] = i;\\n                for(int j=1;j*j<=i;j++){\\n                    record[i] = Math.min(record[i-j*j]+1,record[i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 71587,
                "title": "explanation-of-the-dp-solution",
                "content": "The most common solution for this problem is using DP, BFS or Number theory. Here I will give a brief explanation of the DP solution. The solution is as following:\\n\\n    public int NumSquares(int n) {\\n           int[] DP = new int[n + 1];\\n            for (int i = 1; i <= n; i++)\\n            {\\n                int min= int.MaxValue;\\n                for (int j = 1; j * j <= i; j++)\\n                {\\n                    min= Math.Min(min, DP[i - j * j] + 1);\\n                }\\n                DP[i] = min;\\n            }\\n            return DP[n];\\n    }\\n\\nFirst of all, we created the DP array as usual. This DP array stands for the least number of perfect square numbers for its index. For example DP[13]=2 stands for if you want to decompose 13 into some perfect square numbers, it will contains at least two terms which are 3*3 and 2*2. \\n\\nAfter the initialization of the DP array. We want to iterate through the array to fill all indices. During each iteration we're actually doing this: `dp[i] = 1 + min (dp[i-j*j] for j*j<=i)`. The formula itself is a little bit hard to understand. Here's an example of how it works: (C#)\\n\\nSuppose we want to get DP[13] and we already have the previous indices filled. \\n\\nDP[13] = DP[13-1x1]+DP[1] = DP[12]+1 = 3;\\n\\n\\nDP[13] = DP[13-2x2]+DP[2x2] = DP[9]+1 = 2;\\n\\n\\nDP[13] = DP[13-3x3] + DP[3x3] = DP[4] + 1 = 2;\\n\\nWe pick the smallest one which is 2 so DP[13] = 2. Hope it helps.",
                "solutionTags": [],
                "code": "The most common solution for this problem is using DP, BFS or Number theory. Here I will give a brief explanation of the DP solution. The solution is as following:\\n\\n    public int NumSquares(int n) {\\n           int[] DP = new int[n + 1];\\n            for (int i = 1; i <= n; i++)\\n            {\\n                int min= int.MaxValue;\\n                for (int j = 1; j * j <= i; j++)\\n                {\\n                    min= Math.Min(min, DP[i - j * j] + 1);\\n                }\\n                DP[i] = min;\\n            }\\n            return DP[n];\\n    }\\n\\nFirst of all, we created the DP array as usual. This DP array stands for the least number of perfect square numbers for its index. For example DP[13]=2 stands for if you want to decompose 13 into some perfect square numbers, it will contains at least two terms which are 3*3 and 2*2. \\n\\nAfter the initialization of the DP array. We want to iterate through the array to fill all indices. During each iteration we're actually doing this: `dp[i] = 1 + min (dp[i-j*j] for j*j<=i)`. The formula itself is a little bit hard to understand. Here's an example of how it works: (C#)\\n\\nSuppose we want to get DP[13] and we already have the previous indices filled. \\n\\nDP[13] = DP[13-1x1]+DP[1] = DP[12]+1 = 3;\\n\\n\\nDP[13] = DP[13-2x2]+DP[2x2] = DP[9]+1 = 2;\\n\\n\\nDP[13] = DP[13-3x3] + DP[3x3] = DP[4] + 1 = 2;\\n\\nWe pick the smallest one which is 2 so DP[13] = 2. Hope it helps.",
                "codeTag": "Unknown"
            },
            {
                "id": 707517,
                "title": "python-no-dp-o-n",
                "content": "You don\\'t need more than 4 summands ([Lagrange\\'s four-square theorem](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem#:~:text=Lagrange\\'s%20four%2Dsquare%20theorem%2C%20also,sum%20of%20four%20integer%20squares.))\\n\\n\\nIf you cannot find a solution with at most 3 elements, return 4.\\n\\nFor 3 elements this is equivalent to a 3-sum problem. Since the length of the array is `sqrt(N)` and 3-sum can be implemented with quadratic complexity, the overall cost is `O(N)`.\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        arr, i = [], 1\\n        while i**2 <= n:\\n            arr.append(i**2)\\n            i += 1\\n        \\n        #one-sum O(N^(1/2))\\n        if n in arr:\\n            return 1\\n        \\n        #two-sum O(N)\\n        for e in arr:\\n            if n-e in arr:\\n                return 2\\n        \\n        #three-sum O(N)\\n        arr_set = set(arr)\\n        for i in range(len(arr)):\\n            for j in range(len(arr)):\\n                if n-arr[i]-arr[j] in arr_set:\\n                    return 3\\n        \\n        #four-sum O(1)\\n        return 4\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        arr, i = [], 1\\n        while i**2 <= n:\\n            arr.append(i**2)\\n            i += 1\\n        \\n        #one-sum O(N^(1/2))\\n        if n in arr:\\n            return 1\\n        \\n        #two-sum O(N)\\n        for e in arr:\\n            if n-e in arr:\\n                return 2\\n        \\n        #three-sum O(N)\\n        arr_set = set(arr)\\n        for i in range(len(arr)):\\n            for j in range(len(arr)):\\n                if n-arr[i]-arr[j] in arr_set:\\n                    return 3\\n        \\n        #four-sum O(1)\\n        return 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317378,
                "title": "java-3-solutions-bfs-dp-maths-with-explanation",
                "content": "**BFS**\\n\\n```\\n   public int numSquares(int n) {\\n       Queue<Integer> queue = new LinkedList<>();\\n       Set<Integer> reviewedSet = new HashSet<>();\\n         \\n       if(n >0) queue.offer(n);  \\n       int level = 0;\\n       while(!queue.isEmpty()){\\n           level++; \\n           int size = queue.size();\\n           for(int i=0; i<size; i++) {\\n               int val = queue.poll();\\n               if(!reviewedSet.add(val)) continue;\\n               \\n               for(int j=1; j<=Math.sqrt(val); j++){\\n                   if(val-(j*j) == 0) return level;\\n                   queue.offer(val-(j*j));\\n               }\\n           }\\n       }  \\n        \\n       return level;\\n    }\\n```\\n\\n**DP**\\n\\ndp[n] indicates that the perfect squares count of the given n, and we have:\\n\\n```\\ndp[0] = 0 \\ndp[1] = dp[0]+1 = 1\\ndp[2] = dp[1]+1 = 2\\ndp[3] = dp[2]+1 = 3\\ndp[4] = Min{ dp[4-1*1]+1, dp[4-2*2]+1 } \\n      = Min{ dp[3]+1, dp[0]+1 } \\n      = 1\\t\\t\\t\\t\\ndp[5] = Min{ dp[5-1*1]+1, dp[5-2*2]+1 } \\n      = Min{ dp[4]+1, dp[1]+1 } \\n      = 2\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\ndp[13] = Min{ dp[13-1*1]+1, dp[13-2*2]+1, dp[13-3*3]+1 } \\n       = Min{ dp[12]+1, dp[9]+1, dp[4]+1 } \\n       = 2\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\ndp[n] = Min{ dp[n - i*i] + 1 },  n - i*i >=0 && i >= 1\\nand the sample code is like below:\\n```\\n\\n```\\npublic int numSquares(int n) {\\n       int[] dp = new int[n+1];\\n       \\n       Arrays.fill(dp, Integer.MAX_VALUE);\\n       dp[0] = 0;\\n        \\n       for(int i=1; i<=n; i++){\\n               \\n           for(int j=1; j<=Math.sqrt(i); j++){\\n               dp[i] = Math.min(dp[i], (dp[i-(j*j)]+1));\\n           }    \\n       } \\n        \\n        return dp[n];\\n    }\\n```\\nHope it can help to understand the DP solution.\\n\\n**Mathemetics**\\n\\n```\\npublic int numSquares(int n) {\\n\\n// Lagrange\\'s Four Square theorem : every positive integer can be written as the sum of at most four squares\\n       // answer to this question can be 1 or 2 or 3 or 4 only.\\n\\t   \\n\\t   \\n        if(n == 0) return 0;\\n        \\n\\t\\t// case 1:\\n        if(isSqrt(n)) return 1;\\n        \\n\\t\\t   // case 2 :If answer is 2 => one factor has to be (int)square_root and remaining other number has to be a perfect square\\n        for(int i=1; i<=Math.sqrt(n); i++){\\n            if(isSqrt(n-(i*i))) return 2;\\n        }\\n        \\n\\t\\t // case 4: a positive integer can be expressed as the sum of three squares if and only if it is not of the form 4^k(8m+7) for some int k and m see \"not of\" in above line\\n\\t\\t \\n        // in order to pass 28 as 4\\n        while(n%4 ==0)\\n            n=n/4;\\n        \\n        if(n%8 == 7){\\n            return 4;    // handling 4^k\\n        }\\n        \\n\\t\\t // case 3\\n        return 3;\\n    }\\n    \\n    private boolean isSqrt(int n){\\n        int sqrt = (int)Math.sqrt(n);\\n        \\n        return n-(sqrt*sqrt)==0;\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\n   public int numSquares(int n) {\\n       Queue<Integer> queue = new LinkedList<>();\\n       Set<Integer> reviewedSet = new HashSet<>();\\n         \\n       if(n >0) queue.offer(n);  \\n       int level = 0;\\n       while(!queue.isEmpty()){\\n           level++; \\n           int size = queue.size();\\n           for(int i=0; i<size; i++) {\\n               int val = queue.poll();\\n               if(!reviewedSet.add(val)) continue;\\n               \\n               for(int j=1; j<=Math.sqrt(val); j++){\\n                   if(val-(j*j) == 0) return level;\\n                   queue.offer(val-(j*j));\\n               }\\n           }\\n       }  \\n        \\n       return level;\\n    }\\n```\n```\\ndp[0] = 0 \\ndp[1] = dp[0]+1 = 1\\ndp[2] = dp[1]+1 = 2\\ndp[3] = dp[2]+1 = 3\\ndp[4] = Min{ dp[4-1*1]+1, dp[4-2*2]+1 } \\n      = Min{ dp[3]+1, dp[0]+1 } \\n      = 1\\t\\t\\t\\t\\ndp[5] = Min{ dp[5-1*1]+1, dp[5-2*2]+1 } \\n      = Min{ dp[4]+1, dp[1]+1 } \\n      = 2\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\ndp[13] = Min{ dp[13-1*1]+1, dp[13-2*2]+1, dp[13-3*3]+1 } \\n       = Min{ dp[12]+1, dp[9]+1, dp[4]+1 } \\n       = 2\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\ndp[n] = Min{ dp[n - i*i] + 1 },  n - i*i >=0 && i >= 1\\nand the sample code is like below:\\n```\n```\\npublic int numSquares(int n) {\\n       int[] dp = new int[n+1];\\n       \\n       Arrays.fill(dp, Integer.MAX_VALUE);\\n       dp[0] = 0;\\n        \\n       for(int i=1; i<=n; i++){\\n               \\n           for(int j=1; j<=Math.sqrt(i); j++){\\n               dp[i] = Math.min(dp[i], (dp[i-(j*j)]+1));\\n           }    \\n       } \\n        \\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1173545,
                "title": "java-all-3-solutions-recursive-memoized-dp",
                "content": "**Recursive(TLE):**\\n```\\nclass Solution {\\n    public int numSquares(int n){\\n        return helper(n);\\n    }\\n    \\n    public int helper(int n){\\n        if(n<0) return Integer.MAX_VALUE;  //Taking min later on\\n        if(n==0) return 0;\\n        \\n        int min=n;\\n        \\n        for(int i=1;i*i<=n;i++){\\n            min=Math.min(min,helper(n-(i*i)));\\n        }\\n        return min+1;\\n    }\\n}\\n```\\n\\n**Memoization:**\\n```\\nclass Solution {\\n    public int numSquares(int n){\\n        int arr[]=new int[n+1];\\n        return helper(n,arr);\\n    }\\n    \\n    public int helper(int n,int arr[]){\\n        if(n<0) return Integer.MAX_VALUE;  //Taking min later on\\n        if(n==0) return 0;\\n        \\n        if(arr[n]>0) return arr[n];\\n        \\n        int min=n;\\n        \\n        for(int i=1;i*i<=n;i++){\\n            min=Math.min(min,helper(n-(i*i),arr));\\n        }\\n        arr[n]=min+1;\\n        return min+1;\\n    }\\n}\\n```\\n\\n**Dynamic Programming:**\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[]=new int [n+1];\\n        dp[0]=0;\\n        dp[1]=1;\\n        \\n        for(int i=2;i<dp.length;i++){\\n            int min=Integer.MAX_VALUE;\\n            for(int j=1;j*j<=i;j++){\\n                min=Math.min(min,dp[i-j*j]);\\n            }\\n            dp[i]=min+1;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n){\\n        return helper(n);\\n    }\\n    \\n    public int helper(int n){\\n        if(n<0) return Integer.MAX_VALUE;  //Taking min later on\\n        if(n==0) return 0;\\n        \\n        int min=n;\\n        \\n        for(int i=1;i*i<=n;i++){\\n            min=Math.min(min,helper(n-(i*i)));\\n        }\\n        return min+1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n){\\n        int arr[]=new int[n+1];\\n        return helper(n,arr);\\n    }\\n    \\n    public int helper(int n,int arr[]){\\n        if(n<0) return Integer.MAX_VALUE;  //Taking min later on\\n        if(n==0) return 0;\\n        \\n        if(arr[n]>0) return arr[n];\\n        \\n        int min=n;\\n        \\n        for(int i=1;i*i<=n;i++){\\n            min=Math.min(min,helper(n-(i*i),arr));\\n        }\\n        arr[n]=min+1;\\n        return min+1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[]=new int [n+1];\\n        dp[0]=0;\\n        dp[1]=1;\\n        \\n        for(int i=2;i<dp.length;i++){\\n            int min=Integer.MAX_VALUE;\\n            for(int j=1;j*j<=i;j++){\\n                min=Math.min(min,dp[i-j*j]);\\n            }\\n            dp[i]=min+1;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725325,
                "title": "c-bottom-up-top-down-dynamic-programming",
                "content": "The concept is similar to Coin Change Problem.\\nexcept the coins array, we can use all the squares until `n` (example for n=18, your coins will be `[1,4,9,16]`)\\n\\nSpace : `O(n)`\\nTime : `O(n*sqrt(n))`\\n### Top Down Method\\n```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int> &dp) {\\n        if (n == 0) return 0;\\n        if (dp[n] != -1) return dp[n];\\n        dp[n] = INT_MAX;\\n        for(int i=1; i*i<=n; i++) {\\n            dp[n] = min(dp[n], solve(n-(i*i), dp)+1);\\n        }\\n        return dp[n];\\n    }\\n    int numSquares(int n) {\\n        vector <int> dp(n+1, -1);\\n        int ans = solve(n, dp);\\n        return ans;\\n    }\\n};\\n```\\n\\n### Bottom Up Method\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector <int> dp(n+1, INT_MAX);\\n        dp[0] = 0;\\n        for(int sq=1; sq<=n; sq++) {\\n            // sq is the current number to be checked\\n            for(int i=1; i*i<=sq; i++) {\\n                dp[sq] = min(dp[sq], dp[sq-(i*i)]+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int> &dp) {\\n        if (n == 0) return 0;\\n        if (dp[n] != -1) return dp[n];\\n        dp[n] = INT_MAX;\\n        for(int i=1; i*i<=n; i++) {\\n            dp[n] = min(dp[n], solve(n-(i*i), dp)+1);\\n        }\\n        return dp[n];\\n    }\\n    int numSquares(int n) {\\n        vector <int> dp(n+1, -1);\\n        int ans = solve(n, dp);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector <int> dp(n+1, INT_MAX);\\n        dp[0] = 0;\\n        for(int sq=1; sq<=n; sq++) {\\n            // sq is the current number to be checked\\n            for(int i=1; i*i<=sq; i++) {\\n                dp[sq] = min(dp[sq], dp[sq-(i*i)]+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71648,
                "title": "sharing-simple-bfs-python-solution",
                "content": "def minSquare(n):\\n\\n\\ts = [i*i for i in range(1,int(math.sqrt(n))+1)] # Square numbers <= n\\n\\tl = 0  # BFS level\\n\\tcurrentLevel = [0]  # List of numbers in BFS level l\\n\\n\\twhile True:\\n\\t\\tnextLevel = []\\n\\t\\tfor a in currentLevel:\\n\\t\\t\\tfor b in s:\\n\\t\\t\\t\\tif a+b == n: return l+1  # Found n\\n\\t\\t\\t\\tif a+b < n:  nextLevel.append(a+b)\\n\\t\\tcurrentLevel = list(set(nextLevel))  # Remove duplicates\\n\\t\\tl += 1",
                "solutionTags": [],
                "code": "def minSquare(n):\\n\\n\\ts = [i*i for i in range(1,int(math.sqrt(n))+1)] # Square numbers <= n\\n\\tl = 0  # BFS level\\n\\tcurrentLevel = [0]  # List of numbers in BFS level l\\n\\n\\twhile True:\\n\\t\\tnextLevel = []\\n\\t\\tfor a in currentLevel:\\n\\t\\t\\tfor b in s:\\n\\t\\t\\t\\tif a+b == n: return l+1  # Found n\\n\\t\\t\\t\\tif a+b < n:  nextLevel.append(a+b)\\n\\t\\tcurrentLevel = list(set(nextLevel))  # Remove duplicates\\n\\t\\tl += 1",
                "codeTag": "Python3"
            },
            {
                "id": 71662,
                "title": "very-straightforward-c-dp-solution",
                "content": "For each i , the max # of perfect square is always i (when square = 1*1). So the boundary of each dp[i] = i.\\n\\n    class Solution {\\n    public:\\n        int numSquares(int n) {\\n            if (n == 0) return 0;\\n            \\n            vector<int> dp(n+1, 0);\\n            \\n            for (int i=0; i<=n; ++i) {\\n                dp[i] = i;\\n                for (int j = 2; j<=sqrt(i); ++j) {\\n                    dp[i] = min(dp[i], 1 + dp[i - j*j]);\\n                }\\n            }\\n            \\n            return dp[n];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int numSquares(int n) {\\n            if (n == 0) return 0;\\n            \\n            vector<int> dp(n+1, 0);\\n            \\n            for (int i=0; i<=n; ++i) {\\n                dp[i] = i;\\n                for (int j = 2; j<=sqrt(i); ++j) {\\n                    dp[i] = min(dp[i], 1 + dp[i - j*j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 476318,
                "title": "math-solution-explained-beats-100-javascript-whiteboard",
                "content": "*Lagrange\\'s theorem* for four squares states:\\n**Every number can be written as the sum of four squares of integers**\\n so my potential answers are **0,1,2,3,4**\\n*  **0** never happens because there\\'s always an answer\\n*  **1** happens when the number itself is a valid square \\n\\nSo **2,3,4** are the only available solutions.\\n *Legendre\\'s* three square theorem states: \\n**A number  n can be written as the sum of  at most three squares if n  =/= 4^a (8*b+7)**\\n\\nSo I can immediately deduce if it can be  written as a sum of 4 if  n==4^a (8*b+7), by contradicting the above Theorem.\\nAll  I have to do is divide n by 4 as many times as possible and mod8 the final result, to test if result%8==7\\nIf result%8==7, Legendre\\'s theorem is contradicted and my number cannot be written as a sum of (at most) three squares. Therefore utilizing Lagrange\\'s theorem, my solution is immediately 4.\\n\\n\\nOtherwise, having ruled out the option 4, I have 2 and 3 remaining as the potential solutions.\\n\\nI can manually check If It\\'s a sum of 2 numbers:\\nsay that n=a^2 +b^2 then I can easily find a^2 If i search for every number less than n.\\nIf i happen to find any number x, such that n-x*x is a valid square, then i m done, because\\nn =x^2 + (n-x^2)^2  (a sum of 2 squares)\\n\\nHaving ruled out the solution 2, only 3 remains as the only solution\\n\\nHere\\'s a whiteboard recap:\\n![image](https://assets.leetcode.com/users/georgechryso/image_1578682701.png)\\n\\n\\n```\\nvar numSquares=n=>{\\n\\n    //returns if the number x is a valid square root ( can be represented as the square of an integer)\\n    let isSquare=x=>Math.floor(Math.sqrt(x))**2===x\\n\\n    if(isSquare(n))\\n\\t\\treturn 1 // that would be the fact that its equal to itself\\n\\n    // Legendre\\'s three square theorem: A natural number n can be represented as \\n\\t// the sum of AT MOST three squares of integers if and only if : n!= 4^x ( 8*m+7)\\n    while(n%4===0)\\n\\t\\tn/=4\\n\\t//Try contradicting Legendre\\n    if(n%8===7) \\n\\t\\treturn 4 \\n\\t\\t\\n    // Manually checking for result 2, because Legendre states  AT MOST 3, \\n\\t// so 2 is possible aswell\\n    for (let i = 0; i <=n ; i++) \\n        // if x=n-i*i   and x is a valid square then OBVIOUSLY\\n        // n=i^2 +sqrt(x)^2  ,so n is a square of two numbers   \\n        if(isSquare(n-i*i))\\n\\t\\t\\treturn 2\\n    \\n\\t// Legendre applies\\n    return 3\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar numSquares=n=>{\\n\\n    //returns if the number x is a valid square root ( can be represented as the square of an integer)\\n    let isSquare=x=>Math.floor(Math.sqrt(x))**2===x\\n\\n    if(isSquare(n))\\n\\t\\treturn 1 // that would be the fact that its equal to itself\\n\\n    // Legendre\\'s three square theorem: A natural number n can be represented as \\n\\t// the sum of AT MOST three squares of integers if and only if : n!= 4^x ( 8*m+7)\\n    while(n%4===0)\\n\\t\\tn/=4\\n\\t//Try contradicting Legendre\\n    if(n%8===7) \\n\\t\\treturn 4 \\n\\t\\t\\n    // Manually checking for result 2, because Legendre states  AT MOST 3, \\n\\t// so 2 is possible aswell\\n    for (let i = 0; i <=n ; i++) \\n        // if x=n-i*i   and x is a valid square then OBVIOUSLY\\n        // n=i^2 +sqrt(x)^2  ,so n is a square of two numbers   \\n        if(isSquare(n-i*i))\\n\\t\\t\\treturn 2\\n    \\n\\t// Legendre applies\\n    return 3\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71628,
                "title": "python-accepted-solution",
                "content": "I've seen that the dp solution is not accepted in Python. Some use static *dp* in order to use it. And we can also solve it using number theory knowledge. But **what if in a competition we don't know that theory? What if we are not allowed to use static dp?** Here is an accepted solution using BFS:\\n\\n    class Solution(object):\\n        def numSquares(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n           \\n            q1 = [0]\\n            q2 = []\\n            level = 0\\n            visited = [False] * (n+1)\\n            while True:\\n                level += 1\\n                for v in q1:\\n                    i = 0\\n                    while True:\\n                        i += 1\\n                        t = v + i * i\\n                        if t == n: return level\\n                        if t > n: break\\n                        if visited[t]: continue\\n                        q2.append(t)\\n                        visited[t] = True\\n                q1 = q2\\n                q2 = []\\n                    \\n            return 0",
                "solutionTags": [],
                "code": "I've seen that the dp solution is not accepted in Python. Some use static *dp* in order to use it. And we can also solve it using number theory knowledge. But **what if in a competition we don't know that theory? What if we are not allowed to use static dp?** Here is an accepted solution using BFS:\\n\\n    class Solution(object):\\n        def numSquares(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n           \\n            q1 = [0]\\n            q2 = []\\n            level = 0\\n            visited = [False] * (n+1)\\n            while True:\\n                level += 1\\n                for v in q1:\\n                    i = 0\\n                    while True:\\n                        i += 1\\n                        t = v + i * i\\n                        if t == n: return level\\n                        if t > n: break\\n                        if visited[t]: continue\\n                        q2.append(t)\\n                        visited[t] = True\\n                q1 = q2\\n                q2 = []\\n                    \\n            return 0",
                "codeTag": "Java"
            },
            {
                "id": 1520667,
                "title": "c-simple-and-easy-dp-solution",
                "content": "**Idea:**\\nThis question is very similar to coin change https://leetcode.com/problems/coin-change/discuss/1104203/C%2B%2B-Super-Simple-and-Short-Dynamic-Programming-Solution.\\nThe only difference is that in coin change we get a vector of coins and here we know that the coins are all the perfect squares.\\nSo our first step will be to construct a \"coin\" vector.\\nThen, we do it the same way as coin change.\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> squares;\\n        int p = 1, curr = 1;\\n        \\n        while (curr <= n) {\\n            curr = pow(p++, 2);\\n            squares.push_back(curr);\\n        }\\n        \\n        vector<int> dp(n+1, n+1);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++)\\n            for (auto s : squares)\\n                if (s <= i) dp[i] = min(dp[i], dp[i-s]+1);\\n\\n        return dp[n];\\n    }\\n};\\n\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> squares;\\n        int p = 1, curr = 1;\\n        \\n        while (curr <= n) {\\n            curr = pow(p++, 2);\\n            squares.push_back(curr);\\n        }\\n        \\n        vector<int> dp(n+1, n+1);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++)\\n            for (auto s : squares)\\n                if (s <= i) dp[i] = min(dp[i], dp[i-s]+1);\\n\\n        return dp[n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065202,
                "title": "python-bfs-with-tree-illustration-and-explanation",
                "content": "Why use Breadth-First Search (BFS)? \\n\\nRefer to the below tree (not complete), I draw this tree where the root is n and the difference between two nodes is a perfect square number. We want to get the least number of perfect square numbers that sum to ```n```. This **is equivalent to** find the shortest path from node ```n``` to node ```0```.\\n\\nHow I code:\\n1. Use list comprehension to generate all perfect squares that are less than the target n.\\n2. Use queue to store ```[n, d]``` (node and current depth).\\n3. Use a set ```seen``` to record the node we have seen to avoid duplicated calculation.\\n4. BFS the queue, when the node is a perfect square, return the current depth ```d```; Otherwise, if we haven\\'t calculate ```node-s```, add ```node-s``` to the ```seen``` and the ```(node-s, d+1)``` to the ```queue```.\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        sq = [x*x for x in range(1,n) if x*x <= n]\\n        queue = deque([(n,1)])\\n        seen = set()\\n        seen.add(n)\\n        while queue:\\n            node, d = queue.popleft()\\n            if node in sq:\\n                return d\\n            for s in sq:\\n                if node <= s:\\n                    break\\n                if node - s not in seen:\\n                    seen.add(node - s)\\n                    queue.append((node - s, d + 1))\\n        return n\\n```\\nHope this helps. Feel free to comment if you have any questions.\\n![image](https://assets.leetcode.com/users/images/d3a0f3ce-38fc-4a9e-9144-3126789cc3d8_1653267079.7320004.png)\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```n```\n```n```\n```0```\n```[n, d]```\n```seen```\n```d```\n```node-s```\n```node-s```\n```seen```\n```(node-s, d+1)```\n```queue```\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        sq = [x*x for x in range(1,n) if x*x <= n]\\n        queue = deque([(n,1)])\\n        seen = set()\\n        seen.add(n)\\n        while queue:\\n            node, d = queue.popleft()\\n            if node in sq:\\n                return d\\n            for s in sq:\\n                if node <= s:\\n                    break\\n                if node - s not in seen:\\n                    seen.add(node - s)\\n                    queue.append((node - s, d + 1))\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238340,
                "title": "easy-understanding-solutions-recursion-memoization-dp",
                "content": "**IF YOU LIKE THE SOLUTION PLEASE UPVOTE IT.**\\n\\n**Recursive solution:(TLE)**\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n       if(n==0){\\n           return 0;\\n       } \\n        int minvalue=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int minperfectsquarepro=numSquares(n-i*i);\\n            minvalue=min(minvalue,minperfectsquarepro);\\n        }\\n        minvalue+=1;\\n    return minvalue;   \\n    }\\n};\\n```\\n**Memoization:**\\n**Time complexity:O(n\\u221An);**\\n```\\nclass Solution {\\npublic:\\n    int memodp(int n,vector<int> &dp){\\n\\t//we have to pass the vector by reference otherwise it gives TLE because it use different memory at every call stack.\\n        if(n==0){\\n           dp[0]=0;\\n           return 0;\\n       } \\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        int minvalue=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int minperfectsquarepro=memodp(n-i*i,dp);\\n            minvalue=min(minvalue,minperfectsquarepro+1);\\n        }\\n        // minvalue+=1;\\n        dp[n]=minvalue;\\n    return minvalue;  \\n    }\\n    int numSquares(int n) {\\n       vector<int>dp(n+1,-1);\\n        return memodp(n,dp);\\n    }\\n};\\n```\\n**Dynamic Programming:**\\n**Time complexity:O(n\\u221An);**\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        int dp[n+1];\\n        dp[0]=0;\\n        for(int problem=1;problem<=n;problem++){\\n        int minvalue=INT_MAX;\\n            for(int i=1;i*i<=problem;i++){\\n                int sub=dp[problem-i*i];\\n                minvalue=min(minvalue,sub+1);\\n            }\\n            dp[problem]=minvalue;\\n            \\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n**IF YOU LIKE THE SOLUTION PLEASE UPVOTE IT.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n       if(n==0){\\n           return 0;\\n       } \\n        int minvalue=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int minperfectsquarepro=numSquares(n-i*i);\\n            minvalue=min(minvalue,minperfectsquarepro);\\n        }\\n        minvalue+=1;\\n    return minvalue;   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int memodp(int n,vector<int> &dp){\\n\\t//we have to pass the vector by reference otherwise it gives TLE because it use different memory at every call stack.\\n        if(n==0){\\n           dp[0]=0;\\n           return 0;\\n       } \\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        int minvalue=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int minperfectsquarepro=memodp(n-i*i,dp);\\n            minvalue=min(minvalue,minperfectsquarepro+1);\\n        }\\n        // minvalue+=1;\\n        dp[n]=minvalue;\\n    return minvalue;  \\n    }\\n    int numSquares(int n) {\\n       vector<int>dp(n+1,-1);\\n        return memodp(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        int dp[n+1];\\n        dp[0]=0;\\n        for(int problem=1;problem<=n;problem++){\\n        int minvalue=INT_MAX;\\n            for(int i=1;i*i<=problem;i++){\\n                int sub=dp[problem-i*i];\\n                minvalue=min(minvalue,sub+1);\\n            }\\n            dp[problem]=minvalue;\\n            \\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006278,
                "title": "easy-python-dp-solution-with-explanation-dry-run",
                "content": "Simple python solution using DP.\\nLets concider n = 9\\n1. Create an array of size n+1, and fill the array with respective index.\\nex. [0,1,2,3,4,5,6]\\n2. Iterate over \"dp\" array.\\n3. For each index \"i\" in \"dp\" array check how many time do we have to reduce the value at index \"i\" to reach 0.\\n3.1 We start checking from 1 upto sqrt(n)\\n3.2 We find a way that can take us even lesser amount of steps to reach 0.\\nex. \\ndp = [0,1,2,3,4,5,6,7,8,9]   for i = 0,1,2,3\\ndp = [0,1,2,3, min(4,1) ,5,6,7,8,9]   for i = 4      \\ndp = [0,1,2,3,4, min(5, 2) ,6,7,8,9]   for i = 5\\ndp = [0,1,2,3,4,5, min(6, 3) ,7,8,9]   for i = 6    \\ndp = [0,1,2,3,4,5,6, min(7, 4) ,8,9]   for i = 7    \\ndp = [0,1,2,3,4,5,6,7, min(8, 2) ,9]   for i = 8    \\ndp = [0,1,2,3,4,5,6,7,8, min(9, 3, 1) ]   for i = 9    \\n\\nfinal dp arrar = [0,1,2,3,1,2,3,4,2,1]\\n\\nHence we are taking (step)*(number of step)  towards 0 when\\nj = 1 we take (1^2)*9 = 9 steps\\nj = 2 we take (2^2)*2 + (1^2)*1 = 3 steps\\nj = 3 we take (3^2)*3 = 1 step\\n\\nand then select the minimum step as answer\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\t\\t# step 1\\n        dp = [i for i in range(n+1)]\\n        \\n\\t\\t# step 2\\n        for i in range(n+1):\\n\\t        j = 1\\n\\t\\t\\t# step 3\\n\\t        while j*j <= i:\\n\\t            dp[i] = min(dp[i], dp[i-(j*j)] + 1)\\n\\t            j += 1\\n        \\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\t\\t# step 1\\n        dp = [i for i in range(n+1)]\\n        \\n\\t\\t# step 2\\n        for i in range(n+1):\\n\\t        j = 1\\n\\t\\t\\t# step 3\\n\\t        while j*j <= i:\\n\\t            dp[i] = min(dp[i], dp[i-(j*j)] + 1)\\n\\t            j += 1\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71478,
                "title": "why-is-python-dp-solution-tle",
                "content": " I made these two lists static however still TLE\\n   \\n       class Solution(object):\\n            def numSquares(self, n):\\n                \"\"\"\\n                :type n: int\\n                :rtype: int\\n                \"\"\"\\n                self.dp = [i for i in range(n+1)]\\n                self.squares = [i*i for i in range(1, int(n**0.5) + 1)]\\n                \\n                for i in range(1, n+1):\\n                    for sq in self.squares:\\n                        if i - sq < 0:\\n                            break \\n                        self.dp[i] = min(self.dp[i], self.dp[i - sq] + 1)\\n                        \\n                return self.dp[-1]",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": " I made these two lists static however still TLE\\n   \\n       class Solution(object):\\n            def numSquares(self, n):\\n                \"\"\"\\n                :type n: int\\n                :rtype: int\\n                \"\"\"\\n                self.dp = [i for i in range(n+1)]\\n                self.squares = [i*i for i in range(1, int(n**0.5) + 1)]\\n                \\n                for i in range(1, n+1):\\n                    for sq in self.squares:\\n                        if i - sq < 0:\\n                            break \\n                        self.dp[i] = min(self.dp[i], self.dp[i - sq] + 1)\\n                        \\n                return self.dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 71612,
                "title": "58ms-java-dp-solution-beating-over-90",
                "content": "    public class Solution {\\n    /**\\n     * s[i] denotes the least number of square numbers that add up to n\\n     * initial s[i] as maximum integer\\n     * for i from 1 to n, \\n     *      if i is perfect square, s[i]=1, \\n     *      otherwise get the square root of the maximum perfect square smaller than i\\n     * for j from 1 to square root, \\n     *      if(s[i-j*j]+1<s[i]) update s[i] as s[i-j*j]+1\\n     * \\n     * */\\n    public int numSquares(int n) {\\n        int[] s = new int[n+1];\\n        for(int i=0;i<n+1;i++) s[i] = Integer.MAX_VALUE;\\n        //note to me: no need to store a list of perfect squares, knowing the square root of the largest perfect square is sufficient\\n        //List<Integer> squares = new ArrayList<Integer>();\\n        for(int i = 1;i<n+1;i++){\\n            int sqrt = (int) Math.sqrt(i);\\n            if(i == sqrt*sqrt){s[i] = 1;continue;}\\n            for(int j = 1;j<=sqrt;j++){\\n                if(s[i-j*j]+1<s[i]) s[i] = s[i-j*j]+1;\\n            }\\n        }\\n        return s[n];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    /**\\n     * s[i] denotes the least number of square numbers that add up to n\\n     * initial s[i] as maximum integer\\n     * for i from 1 to n, \\n     *      if i is perfect square, s[i]=1, \\n     *      otherwise get the square root of the maximum perfect square smaller than i\\n     * for j from 1 to square root, \\n     *      if(s[i-j*j]+1<s[i]) update s[i] as s[i-j*j]+1\\n     * \\n     * */\\n    public int numSquares(int n) {\\n        int[] s = new int[n+1];\\n        for(int i=0;i<n+1;i++) s[i] = Integer.MAX_VALUE;\\n        //note to me: no need to store a list of perfect squares, knowing the square root of the largest perfect square is sufficient\\n        //List<Integer> squares = new ArrayList<Integer>();\\n        for(int i = 1;i<n+1;i++){\\n            int sqrt = (int) Math.sqrt(i);\\n            if(i == sqrt*sqrt){s[i] = 1;continue;}",
                "codeTag": "Java"
            },
            {
                "id": 3455332,
                "title": "all-three-main-approaches-using-dp-in-c",
                "content": "# recursive soln\\n```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        if(n==0)\\n            return 0;\\n        int ans=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int temp=i*i;\\n            ans=min(ans,1+solve(n-temp));\\n        }\\n        return ans;\\n    }\\n    int numSquares(int n) {\\n        return solve( n);\\n    }\\n};\\n```\\n# rec+mem\\n```\\nclass Solution {\\npublic:\\n    int solve(int n , vector<int>&dp){\\n        if(n==0)\\n            return 0;\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        int ans=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int temp=i*i;\\n            ans=min(ans,1+solve(n-temp,dp));\\n        }\\n        return dp[n]=ans;\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        return solve( n,dp);\\n    }\\n};\\n```\\n# tabulation\\n```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        \\n        for(int i=1;i<=n;i++)\\n        for(int j=1;j*j<=n;j++){\\n            int temp=j*j;\\n            if(i-temp>=0)\\n            dp[i]=min(dp[i],1+dp[i-temp]);\\n        }\\n        return dp[n];\\n    }\\n    int numSquares(int n) {\\n        \\n        return solve( n);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/e729b48b-a4d8-47de-b4da-a9f14e4a6232_1682461504.3277745.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        if(n==0)\\n            return 0;\\n        int ans=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int temp=i*i;\\n            ans=min(ans,1+solve(n-temp));\\n        }\\n        return ans;\\n    }\\n    int numSquares(int n) {\\n        return solve( n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int n , vector<int>&dp){\\n        if(n==0)\\n            return 0;\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        int ans=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int temp=i*i;\\n            ans=min(ans,1+solve(n-temp,dp));\\n        }\\n        return dp[n]=ans;\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        return solve( n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        \\n        for(int i=1;i<=n;i++)\\n        for(int j=1;j*j<=n;j++){\\n            int temp=j*j;\\n            if(i-temp>=0)\\n            dp[i]=min(dp[i],1+dp[i-temp]);\\n        }\\n        return dp[n];\\n    }\\n    int numSquares(int n) {\\n        \\n        return solve( n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709113,
                "title": "c-without-dp-lagrange-s-four-square-theorem-faster-than-90-solutions",
                "content": "Upvote if you find it useful!\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numSquares(int n) {\\n\\t\\t\\t//using Lagrange\\'s four-square theorem, also known as Bachet\\'s conjecture, states that every natural \\n\\t\\t\\t//number can be represented as the sum of four integer squares. \\n\\n\\t\\t\\tvector<int> sqr;\\n\\t\\t\\tint x=1;\\n\\t\\t\\twhile(x*x<=n){ //saving all squares till n\\n\\t\\t\\t\\tsqr.push_back(x*x);\\n\\t\\t\\t\\tx++;\\n\\t\\t\\t}\\n\\t\\t\\tint size= sqr.size();\\n\\n\\t\\t\\tfor(int i=0; i<size; i++){ //for one\\n\\t\\t\\t\\tif(sqr[i]==n)\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0; i<size; i++){\\n\\t\\t\\t\\tfor(int j=i; j<size; j++){ //for two\\n\\t\\t\\t\\t\\tif(sqr[i]+sqr[j]==n)\\n\\t\\t\\t\\t\\t\\treturn 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0; i<size; i++){ //for three\\n\\t\\t\\t\\tfor(int j=i; j<size; j++){\\n\\t\\t\\t\\t\\tfor(int k=j; k<size; k++){\\n\\t\\t\\t\\t\\t\\tif(sqr[i]+sqr[j]+sqr[k]==n)\\n\\t\\t\\t\\t\\t\\t\\treturn 3;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 4; //if not 1,2,3 then definitely 4\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numSquares(int n) {\\n\\t\\t\\t//using Lagrange\\'s four-square theorem, also known as Bachet\\'s conjecture, states that every natural \\n\\t\\t\\t//number can be represented as the sum of four integer squares. \\n\\n\\t\\t\\tvector<int> sqr;\\n\\t\\t\\tint x=1;\\n\\t\\t\\twhile(x*x<=n){ //saving all squares till n\\n\\t\\t\\t\\tsqr.push_back(x*x);\\n\\t\\t\\t\\tx++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2838514,
                "title": "c-2-line-most-easy-dp-solution-must-read",
                "content": "dp\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n    vector<int> dp(n+1,1000000);\\n    dp[0]=0;\\n    for(int i=1;i<=n;i++){\\n        for(int j=0;j*j<=i;j++) dp[i]=min(dp[i],1+dp[i-j*j]);\\n    }\\n    return dp[n];\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n    vector<int> dp(n+1,1000000);\\n    dp[0]=0;\\n    for(int i=1;i<=n;i++){\\n        for(int j=0;j*j<=i;j++) dp[i]=min(dp[i],1+dp[i-j*j]);\\n    }\\n    return dp[n];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71584,
                "title": "simple-java-solution",
                "content": "    public int numSquares(int n) {\\n        int[] min = new int[n+1];\\n        min[1] = 1;\\n        for(int i=2;i<=n;i++){\\n            int tmp = Integer.MAX_VALUE;\\n            for(int j=1;j*j<=i;j++){\\n                tmp = Math.min(tmp,min[i-j*j]+1);\\n            }\\n            min[i] = tmp;\\n        }\\n        return min[n];\\n    }",
                "solutionTags": [],
                "code": "    public int numSquares(int n) {\\n        int[] min = new int[n+1];\\n        min[1] = 1;\\n        for(int i=2;i<=n;i++){\\n            int tmp = Integer.MAX_VALUE;\\n            for(int j=1;j*j<=i;j++){\\n                tmp = Math.min(tmp,min[i-j*j]+1);\\n            }\\n            min[i] = tmp;\\n        }\\n        return min[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 540782,
                "title": "the-question-is-coin-problem-in-disguise",
                "content": "The above question is similar to leetcode 322 ( Coin Problem ).\\n\\nIn the coin problem we are given set of coins and we need to determine the minimum combination of coin to achive the give amount.\\n\\nThis is exactly what has been asked in the given problem, we need to determine the number of squares which could be used to form the amount ( n ). The list of valid square number would all the squares starting from 0 till square root of give number (n)\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\t\\t# The list of squareNumber is equivalent to the list of available coins in the Coin-Problem\\n        \\n\\t\\tsquareNumber =[ i**2 for i in range(0, int(n**(1/2)) + 1)] \\n\\t\\t\\n\\t\\tdp = [float(\\'inf\\')]*(n+1)\\n        dp[0] = 0\\n        for num in squareNumber:\\n            for amt in range(1,n+1):\\n                if amt >= num:\\n                    dp[amt] = min(dp[amt],dp[amt-num] + 1)\\n               \\n        return dp[-1]\\n        \\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "The above question is similar to leetcode 322 ( Coin Problem ).\\n\\nIn the coin problem we are given set of coins and we need to determine the minimum combination of coin to achive the give amount.\\n\\nThis is exactly what has been asked in the given problem, we need to determine the number of squares which could be used to form the amount ( n ). The list of valid square number would all the squares starting from 0 till square root of give number (n)\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\t\\t# The list of squareNumber is equivalent to the list of available coins in the Coin-Problem\\n        \\n\\t\\tsquareNumber =[ i**2 for i in range(0, int(n**(1/2)) + 1)] \\n\\t\\t\\n\\t\\tdp = [float(\\'inf\\')]*(n+1)\\n        dp[0] = 0\\n        for num in squareNumber:\\n            for amt in range(1,n+1):\\n                if amt >= num:\\n                    dp[amt] = min(dp[amt],dp[amt-num] + 1)\\n               \\n        return dp[-1]\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 71660,
                "title": "javascript-solution",
                "content": "```js\\nfunction numSquares(n) {\\n  const dp = [0];\\n  \\n  for (let i = 1; i <= n; i++) {\\n    dp[i] = Number.MAX_VALUE;\\n    for (let j = 1; j*j <= i; j++) {\\n      dp[i] = Math.min(dp[i], dp[i-j*j]+1);\\n    } \\n  }\\n  \\n  return dp[n];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction numSquares(n) {\\n  const dp = [0];\\n  \\n  for (let i = 1; i <= n; i++) {\\n    dp[i] = Number.MAX_VALUE;\\n    for (let j = 1; j*j <= i; j++) {\\n      dp[i] = Math.min(dp[i], dp[i-j*j]+1);\\n    } \\n  }\\n  \\n  return dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1522308,
                "title": "java-8-methods-reuse-lc-322",
                "content": "##### 1: Solve using the popular [Change making problem](https://en.wikipedia.org/wiki/Change-making_problem)\\n**Method 1:** Enlist all squares \\u2264 n, followed by [LC 322. Coin Change](https://leetcode.com/problems/coin-change/discuss/334483/Java-or-Iterative-or-Bottom-up-DP)\\n**T/S:** O(n ^ \\u221An)/O(\\u221An)\\n```\\npublic int numSquares(int n) {\\n\\tvar squares = new ArrayList<Integer>();\\n\\tfor (var i = 1; i * i <= n; i++)\\n\\t\\tsquares.add(i * i);\\n\\treturn numSquares(0, squares, n);\\n}\\n\\nprivate int numSquares(int idxSquare, List<Integer> squares, int n) {\\n\\tif (n == 0)\\n\\t\\treturn 0;\\n\\tif (n < 0 || idxSquare >= squares.size())\\n\\t\\treturn -1;\\n\\n\\tvar minSquares = Integer.MAX_VALUE;\\n\\n\\tfor (int i = 0, maxSquares = n / squares.get(idxSquare); i <= maxSquares; i++)\\n\\t\\tif (n >= i * squares.get(idxSquare)) {\\n\\t\\t\\tvar nCoins = numSquares(idxSquare + 1, squares, n - (i * squares.get(idxSquare)));\\n\\t\\t\\tif (nCoins != -1)\\n\\t\\t\\t\\tminSquares = Math.min(minSquares, nCoins + i);\\n\\t\\t}\\n\\n\\treturn (minSquares == Integer.MAX_VALUE) ? -1 : minSquares;\\n}\\n```\\n\\n**Method 2:** Top Down DP. Inject memoization in method 1\\n>**T/S:** O(n\\u221An)/O(\\u221An)\\n```\\npublic int numSquares(int n) {\\n\\tvar squares = new ArrayList<Integer>();\\n\\tfor (var i = 1; i * i <= n; i++)\\n\\t\\tsquares.add(i * i);\\n\\treturn (n < 1) ? 0 : numSquares(squares, n, new HashMap<>());\\n}\\n\\nprivate int numSquares(List<Integer> squares, int remainder, Map<Integer, Integer> map) {\\n\\tif (remainder < 0)\\n\\t\\treturn -1; // not valid\\n\\tif (remainder == 0)\\n\\t\\treturn 0; // completed\\n\\tif (map.containsKey(remainder - 1))\\n\\t\\treturn map.get(remainder - 1);\\n\\n\\tvar minCoins = Integer.MAX_VALUE;\\n\\tfor (var square : squares) {\\n\\t\\tvar res = numSquares(squares, remainder - square, map);\\n\\t\\tif (0 <= res && res < minCoins)\\n\\t\\t\\tminCoins = 1 + res;\\n\\t}\\n\\n\\tmap.put(remainder - 1, (minCoins == Integer.MAX_VALUE) ? -1 : minCoins);\\n\\treturn map.get(remainder - 1);\\n}\\n```\\n\\n**Method 3:** Bottom Up DP\\n>**T/S:** O(n\\u221An)/O(\\u221An)\\n```\\npublic int numSquares(int n) {\\n\\tvar squares = new ArrayList<Integer>();\\n\\tfor (var i = 1; i * i <= n; i++)\\n\\t\\tsquares.add(i * i);\\n\\n\\tvar dp = new int[n + 1];\\n\\tArrays.fill(dp, 1, dp.length, n + 1);\\n\\n\\tfor (var sum = 1; sum <= n; sum++) {\\n\\t\\tfor (var square : squares) {\\n\\t\\t\\tif (square > sum)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdp[sum] = Math.min(dp[sum], 1 + dp[sum - square]);\\n\\t\\t}\\n\\t}\\n\\treturn (dp[n] > n) ? -1 : dp[n];\\n}\\n```\\n---\\n##### 2. Typical DP Approaches. Draw decision tree and optimize\\n\\n**Method 4:** DFS\\n>**T/S:** O(n ^ \\u221An)/O(\\u221An)\\n```\\npublic int numSquares(int n) {\\n\\treturn numSquares(n, 1);\\n}\\n\\nprivate int numSquares(int n, int i) {\\n\\tif (n == 0)\\n\\t\\treturn 0;\\n\\tif (n < i * i)\\n\\t\\treturn Integer.MAX_VALUE;\\n\\n\\tvar minSquares = Integer.MAX_VALUE;\\n\\tfor (var j = i; j * j <= n; j++)\\n\\t\\tminSquares = Math.min(minSquares, numSquares(n - j * j, j));\\n\\n\\treturn (minSquares == Integer.MAX_VALUE) ? Integer.MAX_VALUE : minSquares + 1;\\n}\\n```\\n\\n**Method 5:** DFS with memoization aka Top Down DP. Inject memoization in method 4\\n> **T/S:** O(n\\u221An)/O(n)\\n ```\\npublic int numSquares(int n) {\\n\\treturn numSquares(n, 1, new HashMap<>());\\n}\\n\\nprivate int numSquares(int n, int i, Map<Integer, Integer> map) {\\n\\tif (n == 0)\\n\\t\\treturn 0;\\n\\tif (n < i * i)\\n\\t\\treturn Integer.MAX_VALUE;\\n\\tif (map.containsKey(n))\\n\\t\\treturn map.get(n);\\n\\n\\tvar minSquares = Integer.MAX_VALUE;\\n\\tfor (var j = i; j * j <= n; j++)\\n\\t\\tminSquares = Math.min(minSquares, numSquares(n - j * j, j, map));\\n\\n\\tmap.put(n, (minSquares == Integer.MAX_VALUE) ? Integer.MAX_VALUE : minSquares + 1);\\n\\treturn map.get(n);\\n}\\n```\\n\\n**Method 6:** Bottom Up DP\\n> **T/S:** O(n\\u221An)/O(n)\\n```\\npublic int numSquares(int n) {\\n\\tvar dp = new int[n + 1];\\n\\tArrays.fill(dp, 1, dp.length, Integer.MAX_VALUE);\\n\\n\\tfor (var i = 1; i < dp.length; i++)\\n\\t\\tfor (var j = 1; j * j <= i; j++)\\n\\t\\t\\tdp[i] = Math.min(dp[i], dp[i - j * j] + 1);\\n\\n\\treturn dp[n];\\n}\\n```\\n\\n**Method 7:** BFS. The first level at which n becomes 0 is the number of perfect squares required.\\n>**T/S:** O(\\u221An ^ h)/O(\\u221An), where h = height of the n-ary tree\\n![image](https://assets.leetcode.com/users/images/d98d646d-b4d3-460a-9eb8-2224bae5100b_1634280581.9635005.png)\\n```\\npublic int numSquares(int n) {\\n\\tvar q = new ArrayDeque<>(List.of(n));\\n\\tvar visited = new HashSet<Integer>();\\n\\tvar level = 0;\\n\\n\\twhile (!q.isEmpty()) {\\n\\t\\tlevel++;\\n\\t\\tfor (var i = q.size(); i > 0; i--) {\\n\\t\\t\\tvar head = q.poll();\\n\\t\\t\\tfor (var j = 1; j * j <= head; j++) {\\n\\t\\t\\t\\tvar remainder = head - j * j;\\n\\n\\t\\t\\t\\tif (remainder == 0)\\n\\t\\t\\t\\t\\treturn level;\\n\\t\\t\\t\\tif (visited.add(remainder))\\n\\t\\t\\t\\t\\tq.add(remainder);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn n;\\n}\\n```\\n\\n**Method 8:** Maths\\n* [Lagrange\\'s four-square theorem](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem) states that every natural number can be represented as the sum of four integer squares. This can also be stated as it requires upto 4 squares to sum up to a number, which means the answer to this problem \\u2208 {1, 2, 3, 4}\\n* If n is a perfect square, then answer is 1\\n* If n = a\\xB2 + b\\xB2, then answer is 2\\n* [Legendre\\'s three-square theorem](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem) states that a natural number can be represented as the sum of three squares of integers n=x\\xB2+y\\xB2+z\\xB2, iff n is not of the form n= (4^a) (8b+7) for whole numbers a and b. So, if n satisfies the form, then answer is 4 else 3.\\n* This method is just for knowledge purpose and no interviewer will expect it. BFS is the best method for interviews.\\n>**T/S:** O(\\u221An)/O(1)\\n```\\npublic int numSquares(int n) {\\n\\tif (isPerfectSquare(n))\\n\\t\\treturn 1;\\n\\n\\tfor (var i = 1; i * i <= n; i++) {\\n\\t\\tvar sqrt = (int) Math.sqrt(n - i * i);\\n\\t\\tif (sqrt * sqrt == n - i * i)\\n\\t\\t\\treturn 2;\\n\\t}\\n\\n\\treturn satisfiesForm(n) ? 4 : 3;\\n}\\n\\nprivate boolean isPerfectSquare(int n) {\\n\\tvar sqrt = Math.sqrt(n);\\n\\treturn Math.ceil(sqrt) == Math.floor(sqrt);\\n}\\n\\nprivate boolean satisfiesForm(int n) {\\n\\twhile (n % 4 == 0)\\n\\t\\tn /= 4;\\n\\treturn n % 8 == 7;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic int numSquares(int n) {\\n\\tvar squares = new ArrayList<Integer>();\\n\\tfor (var i = 1; i * i <= n; i++)\\n\\t\\tsquares.add(i * i);\\n\\treturn numSquares(0, squares, n);\\n}\\n\\nprivate int numSquares(int idxSquare, List<Integer> squares, int n) {\\n\\tif (n == 0)\\n\\t\\treturn 0;\\n\\tif (n < 0 || idxSquare >= squares.size())\\n\\t\\treturn -1;\\n\\n\\tvar minSquares = Integer.MAX_VALUE;\\n\\n\\tfor (int i = 0, maxSquares = n / squares.get(idxSquare); i <= maxSquares; i++)\\n\\t\\tif (n >= i * squares.get(idxSquare)) {\\n\\t\\t\\tvar nCoins = numSquares(idxSquare + 1, squares, n - (i * squares.get(idxSquare)));\\n\\t\\t\\tif (nCoins != -1)\\n\\t\\t\\t\\tminSquares = Math.min(minSquares, nCoins + i);\\n\\t\\t}\\n\\n\\treturn (minSquares == Integer.MAX_VALUE) ? -1 : minSquares;\\n}\\n```\n```\\npublic int numSquares(int n) {\\n\\tvar squares = new ArrayList<Integer>();\\n\\tfor (var i = 1; i * i <= n; i++)\\n\\t\\tsquares.add(i * i);\\n\\treturn (n < 1) ? 0 : numSquares(squares, n, new HashMap<>());\\n}\\n\\nprivate int numSquares(List<Integer> squares, int remainder, Map<Integer, Integer> map) {\\n\\tif (remainder < 0)\\n\\t\\treturn -1; // not valid\\n\\tif (remainder == 0)\\n\\t\\treturn 0; // completed\\n\\tif (map.containsKey(remainder - 1))\\n\\t\\treturn map.get(remainder - 1);\\n\\n\\tvar minCoins = Integer.MAX_VALUE;\\n\\tfor (var square : squares) {\\n\\t\\tvar res = numSquares(squares, remainder - square, map);\\n\\t\\tif (0 <= res && res < minCoins)\\n\\t\\t\\tminCoins = 1 + res;\\n\\t}\\n\\n\\tmap.put(remainder - 1, (minCoins == Integer.MAX_VALUE) ? -1 : minCoins);\\n\\treturn map.get(remainder - 1);\\n}\\n```\n```\\npublic int numSquares(int n) {\\n\\tvar squares = new ArrayList<Integer>();\\n\\tfor (var i = 1; i * i <= n; i++)\\n\\t\\tsquares.add(i * i);\\n\\n\\tvar dp = new int[n + 1];\\n\\tArrays.fill(dp, 1, dp.length, n + 1);\\n\\n\\tfor (var sum = 1; sum <= n; sum++) {\\n\\t\\tfor (var square : squares) {\\n\\t\\t\\tif (square > sum)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdp[sum] = Math.min(dp[sum], 1 + dp[sum - square]);\\n\\t\\t}\\n\\t}\\n\\treturn (dp[n] > n) ? -1 : dp[n];\\n}\\n```\n```\\npublic int numSquares(int n) {\\n\\treturn numSquares(n, 1);\\n}\\n\\nprivate int numSquares(int n, int i) {\\n\\tif (n == 0)\\n\\t\\treturn 0;\\n\\tif (n < i * i)\\n\\t\\treturn Integer.MAX_VALUE;\\n\\n\\tvar minSquares = Integer.MAX_VALUE;\\n\\tfor (var j = i; j * j <= n; j++)\\n\\t\\tminSquares = Math.min(minSquares, numSquares(n - j * j, j));\\n\\n\\treturn (minSquares == Integer.MAX_VALUE) ? Integer.MAX_VALUE : minSquares + 1;\\n}\\n```\n```\\npublic int numSquares(int n) {\\n\\treturn numSquares(n, 1, new HashMap<>());\\n}\\n\\nprivate int numSquares(int n, int i, Map<Integer, Integer> map) {\\n\\tif (n == 0)\\n\\t\\treturn 0;\\n\\tif (n < i * i)\\n\\t\\treturn Integer.MAX_VALUE;\\n\\tif (map.containsKey(n))\\n\\t\\treturn map.get(n);\\n\\n\\tvar minSquares = Integer.MAX_VALUE;\\n\\tfor (var j = i; j * j <= n; j++)\\n\\t\\tminSquares = Math.min(minSquares, numSquares(n - j * j, j, map));\\n\\n\\tmap.put(n, (minSquares == Integer.MAX_VALUE) ? Integer.MAX_VALUE : minSquares + 1);\\n\\treturn map.get(n);\\n}\\n```\n```\\npublic int numSquares(int n) {\\n\\tvar dp = new int[n + 1];\\n\\tArrays.fill(dp, 1, dp.length, Integer.MAX_VALUE);\\n\\n\\tfor (var i = 1; i < dp.length; i++)\\n\\t\\tfor (var j = 1; j * j <= i; j++)\\n\\t\\t\\tdp[i] = Math.min(dp[i], dp[i - j * j] + 1);\\n\\n\\treturn dp[n];\\n}\\n```\n```\\npublic int numSquares(int n) {\\n\\tvar q = new ArrayDeque<>(List.of(n));\\n\\tvar visited = new HashSet<Integer>();\\n\\tvar level = 0;\\n\\n\\twhile (!q.isEmpty()) {\\n\\t\\tlevel++;\\n\\t\\tfor (var i = q.size(); i > 0; i--) {\\n\\t\\t\\tvar head = q.poll();\\n\\t\\t\\tfor (var j = 1; j * j <= head; j++) {\\n\\t\\t\\t\\tvar remainder = head - j * j;\\n\\n\\t\\t\\t\\tif (remainder == 0)\\n\\t\\t\\t\\t\\treturn level;\\n\\t\\t\\t\\tif (visited.add(remainder))\\n\\t\\t\\t\\t\\tq.add(remainder);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn n;\\n}\\n```\n```\\npublic int numSquares(int n) {\\n\\tif (isPerfectSquare(n))\\n\\t\\treturn 1;\\n\\n\\tfor (var i = 1; i * i <= n; i++) {\\n\\t\\tvar sqrt = (int) Math.sqrt(n - i * i);\\n\\t\\tif (sqrt * sqrt == n - i * i)\\n\\t\\t\\treturn 2;\\n\\t}\\n\\n\\treturn satisfiesForm(n) ? 4 : 3;\\n}\\n\\nprivate boolean isPerfectSquare(int n) {\\n\\tvar sqrt = Math.sqrt(n);\\n\\treturn Math.ceil(sqrt) == Math.floor(sqrt);\\n}\\n\\nprivate boolean satisfiesForm(int n) {\\n\\twhile (n % 4 == 0)\\n\\t\\tn /= 4;\\n\\treturn n % 8 == 7;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 376795,
                "title": "100-o-log-n-python3-solution-lagrange-s-four-square-theorem",
                "content": "**Explanation**: Lagrange\\'s four-square theorem states every natural number can be represented by four integer squares. The default answer is then 4 and we check if 1,2 or 3 is possible. If the input is a perfect square, output 1. If the number can be broken down into two squares, output 2. If the input can\\'t be written in the form 4^k(8m+7) output 3 (*Lagendre proved that a positive integer can be expressed as the sum of three squares if and only if it is not of the form 4^k(8m+7) for integers k and m.*) https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem\\n\\n```\\nclass Solution:\\n    def isSquare(self, n: int) -> bool:\\n        sq = int(math.sqrt(n))\\n        return sq*sq == n\\n        \\n    def numSquares(self, n: int) -> int:\\n        # Lagrange\\'s four-square theorem\\n        if self.isSquare(n):\\n            return 1\\n        while (n & 3) == 0:\\n            n >>= 2\\n        if (n & 7) == 7:\\n            return 4\\n        sq = int(math.sqrt(n)) + 1\\n        for i in range(1,sq):\\n            if self.isSquare(n - i*i):\\n                return 2\\n        return 3\\n```\\nCredit to algorithm blog: http://www.zrzahid.com/least-number-of-perfect-squares-that-sums-to-n/",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSquare(self, n: int) -> bool:\\n        sq = int(math.sqrt(n))\\n        return sq*sq == n\\n        \\n    def numSquares(self, n: int) -> int:\\n        # Lagrange\\'s four-square theorem\\n        if self.isSquare(n):\\n            return 1\\n        while (n & 3) == 0:\\n            n >>= 2\\n        if (n & 7) == 7:\\n            return 4\\n        sq = int(math.sqrt(n)) + 1\\n        for i in range(1,sq):\\n            if self.isSquare(n - i*i):\\n                return 2\\n        return 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71553,
                "title": "evolve-from-brute-force",
                "content": "The most intuitive way is to try every square less than n and then solve the same subproblem. Time complexity is much better than O(2^n) but I am not sure how to come up a tighter bound.\\n```\\n    int numSquares(int n) {\\n        int sr = sqrt(n);\\n        if(sr*sr == n) return 1;\\n        int mn = n;\\n        for(int i=1;i<=sr;i++) mn = min(mn, numSquares(n-i*i));\\n        return mn+1;\\n    }\\n```\\nLike all dp problems, we can immediately optimize it with memoization and dp. Time complexity is O(n^3/2)\\n```\\n    int numSquares(int n) {\\n        vector<int> mem(n+1);\\n        return numSquares(n,mem);\\n    }\\n    int numSquares(int n, vector<int> &mem) {\\n        if(mem[n]) return mem[n];\\n        int sr = sqrt(n);\\n        if(sr*sr == n) return mem[n] = 1;\\n        int mn = n;\\n        for(int i=1;i<=sr;i++) mn = min(mn, numSquares(n-i*i));\\n        return mem[n] = mn+1;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(n+1,n);\\n        dp[0]=0;\\n        for(int i=1;i<=n;i++) \\n            for(int j=1;j*j<=i;j++) dp[i]=min(dp[i],1+dp[i-j*j]);\\n        return dp[n];\\n    } \\n```\\nFor problems asking for mininum number, BFS may be a good option because it generates the shortest path from the root. Time complexity is similar to dp O(n^3/2). Test cases show BFS is faster than dp. I think it is because BFS only visits numbers that are sum of some squares while dp visits all n numbers.\\n```\\n    int numSquares(int n) {\\n        vector<int> squares;\\n        for(int i=1;i*i<=n;i++) squares.push_back(i*i);\\n        queue<int> q({0});\\n        int level = 0;\\n        vector<bool> vstd(n+1);\\n        while(!q.empty()) {\\n            int s=q.size();\\n            level++;\\n            for(int i=0;i<s;i++) {\\n                int cur=q.front();\\n                q.pop();\\n                if(vstd[cur]) continue;\\n                vstd[cur]=true;\\n                for(auto sq:squares) {\\n                    int nxt = sq+cur;\\n                    if(nxt==n) return level;\\n                    else if(nxt>n) break;\\n                    else q.push(nxt);\\n                }\\n            }\\n        }\\n        return level;\\n    }\\n```\\nEventually, the optimal solution is actually O(n^1/2) using math theory. See [details](https://discuss.leetcode.com/topic/23808/o-sqrt-n-in-ruby-c-c)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int numSquares(int n) {\\n        int sr = sqrt(n);\\n        if(sr*sr == n) return 1;\\n        int mn = n;\\n        for(int i=1;i<=sr;i++) mn = min(mn, numSquares(n-i*i));\\n        return mn+1;\\n    }\\n```\n```\\n    int numSquares(int n) {\\n        vector<int> mem(n+1);\\n        return numSquares(n,mem);\\n    }\\n    int numSquares(int n, vector<int> &mem) {\\n        if(mem[n]) return mem[n];\\n        int sr = sqrt(n);\\n        if(sr*sr == n) return mem[n] = 1;\\n        int mn = n;\\n        for(int i=1;i<=sr;i++) mn = min(mn, numSquares(n-i*i));\\n        return mem[n] = mn+1;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(n+1,n);\\n        dp[0]=0;\\n        for(int i=1;i<=n;i++) \\n            for(int j=1;j*j<=i;j++) dp[i]=min(dp[i],1+dp[i-j*j]);\\n        return dp[n];\\n    } \\n```\n```\\n    int numSquares(int n) {\\n        vector<int> squares;\\n        for(int i=1;i*i<=n;i++) squares.push_back(i*i);\\n        queue<int> q({0});\\n        int level = 0;\\n        vector<bool> vstd(n+1);\\n        while(!q.empty()) {\\n            int s=q.size();\\n            level++;\\n            for(int i=0;i<s;i++) {\\n                int cur=q.front();\\n                q.pop();\\n                if(vstd[cur]) continue;\\n                vstd[cur]=true;\\n                for(auto sq:squares) {\\n                    int nxt = sq+cur;\\n                    if(nxt==n) return level;\\n                    else if(nxt>n) break;\\n                    else q.push(nxt);\\n                }\\n            }\\n        }\\n        return level;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71637,
                "title": "java-solution-o-n-1-2-time-and-o-1-space",
                "content": "public class Solution {\\n\\n        public int numSquares(int n) {\\n            int m = n;\\n            while( m % 4 == 0 )\\n                m = m>>2;\\n            if(m % 8 == 7)\\n                return 4;\\n            \\n            int sqrtOfn = (int) Math.sqrt(n);\\n            if(sqrtOfn * sqrtOfn == n)//Is it a Perfect square?\\n                return 1;\\n            else{\\n                    for(int i = 1; i <= sqrtOfn; ++i){\\n                        int remainder = n - i*i;\\n                        int sqrtOfNum = (int) Math.sqrt(remainder);\\n                        if(sqrtOfNum * sqrtOfNum == remainder)\\n                            return 2;\\n                    }\\n                }\\n             return 3;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n        public int numSquares(int n) {\\n            int m = n;\\n            while( m % 4 == 0 )\\n                m = m>>2;\\n            if(m % 8 == 7)\\n                return 4;\\n            \\n            int sqrtOfn = (int) Math.sqrt(n);\\n            if(sqrtOfn * sqrtOfn == n)//Is it a Perfect square?\\n                return 1;\\n            else{\\n                    for(int i = 1; i <= sqrtOfn; ++i){\\n                        int remainder = n - i*i;\\n                        int sqrtOfNum = (int) Math.sqrt(remainder);\\n                        if(sqrtOfNum * sqrtOfNum == remainder)\\n                            return 2;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2838462,
                "title": "python-simple-bfs-solution",
                "content": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        q=deque()\\n        visited=set()\\n        q.append((0,0))\\n        while q:\\n            s,count=q.popleft()\\n            count+=1\\n            for i in range(1,n+1):\\n                temp=s+i*i\\n                if temp>n:\\n                    break\\n                if temp==n:\\n                    return count\\n                if temp not in visited:\\n                    visited.add(temp)\\n                    q.append((temp,count))\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        q=deque()\\n        visited=set()\\n        q.append((0,0))\\n        while q:\\n            s,count=q.popleft()\\n            count+=1\\n            for i in range(1,n+1):\\n                temp=s+i*i\\n                if temp>n:\\n                    break\\n                if temp==n:\\n                    return count\\n                if temp not in visited:\\n                    visited.add(temp)\\n                    q.append((temp,count))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832376,
                "title": "java-dp-o-sqrt-n-solution",
                "content": "# Explanation\\n\\nFor every perfect square we go on find the number of steps required to form number **n**.\\nWe take an array dp of length **n+1** and start iterating from **i=1 and  i\\\\*i <= n**.\\n\\nrecursive formula :- **dp[i] = min( dp[j-square] + 1 , dp[j] );**\\n\\nconsider for sample testcase 1 :-\\n\\n```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0  max max max max max max max max max max max max\\n```\\n\\n**consider 1st Perfect square as 1 with square root ind = 1**\\n\\n**while(ind*ind <= n)**\\n\\nsquare = ind*ind;\\n\\nNow for every square iterate the dp array from **square to n** and use the recurssive formula \\n\\n**For square = 1**\\n```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\n```\\n\\n**For square = 4**\\n```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0   1   2   3   1   2   3   4   2   3   4   5   3\\n```\\n\\n**For square = 9**\\n```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0   1   2   3   4   5   6   7   8   1   2   3   3\\n ```\\n \\n Here, when j=12\\n \\n dp[j] = 3;\\n dp[j-square]+1 = 4;\\n hence we keep it as it is;\\n\\nAnd we get our final ans as dp[n] = 3;\\n\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int [] dp = new int[n+1];\\n        \\n        for(int i=0;i<=n;i++)dp[i] = Integer.MAX_VALUE;\\n        \\n        dp[0]=0;\\n        int ind=1;\\n        \\n        while(ind*ind <= n){\\n            int square = ind*ind;\\n            \\n            for(int i=square;i<=n;i++){\\n                dp[i] = Math.min(dp[i-square]+1,dp[i]);\\n            }\\n            ind++;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0  max max max max max max max max max max max max\\n```\n```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\n```\n```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0   1   2   3   1   2   3   4   2   3   4   5   3\\n```\n```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0   1   2   3   4   5   6   7   8   1   2   3   3\\n ```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int [] dp = new int[n+1];\\n        \\n        for(int i=0;i<=n;i++)dp[i] = Integer.MAX_VALUE;\\n        \\n        dp[0]=0;\\n        int ind=1;\\n        \\n        while(ind*ind <= n){\\n            int square = ind*ind;\\n            \\n            for(int i=square;i<=n;i++){\\n                dp[i] = Math.min(dp[i-square]+1,dp[i]);\\n            }\\n            ind++;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444851,
                "title": "python-solution-of-dp-bfs",
                "content": "Solution one: DP\\n \\ndp[i] represents how many squares number i needs at least \\ntransmisson is dp[i] = min(dp[i],dp[i-j*j]+1)\\n```\\nclass Solution(object):\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [i for i in range(n+1)]\\n        for i in range(2,n+1):\\n            for j in range(1,int(i ** 0.5) + 1):\\n                dp[i] = min(dp[i],dp[i-j*j]+1)\\n        return dp[n]\\n```\\nSolution Two: BFS\\nIf we use BFS directly, (I mean in my method without have_been_put  array), the memory limit will exceeds. This is becasue some values we have already visited and if it has been visited before, it must have fewer steps to reach there.\\n\\nHere is my solution:\\n1) Create a queue to record the current num and have many steps have been already taken\\n2) While the queue is not empty, pop the value and put all the possible values = num- j*j (j is square samller than num)\\n3) If the current num is equal to 0, we got the correct answer! Otherwise keep looking.\\n\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        q=deque([[n,0]])\\n        have_been_put = [0 for i in range(n+1)]\\n        while q:\\n            num,res = q.popleft()\\n            if num==0:\\n                break\\n            for j in range(1,int(num**0.5)+1):\\n                if(have_been_put[num-j*j] !=1):\\n                    q.append([num-j*j,res+1])\\n                have_been_put[num-j*j] = 1\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [i for i in range(n+1)]\\n        for i in range(2,n+1):\\n            for j in range(1,int(i ** 0.5) + 1):\\n                dp[i] = min(dp[i],dp[i-j*j]+1)\\n        return dp[n]\\n```\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        q=deque([[n,0]])\\n        have_been_put = [0 for i in range(n+1)]\\n        while q:\\n            num,res = q.popleft()\\n            if num==0:\\n                break\\n            for j in range(1,int(num**0.5)+1):\\n                if(have_been_put[num-j*j] !=1):\\n                    q.append([num-j*j,res+1])\\n                have_been_put[num-j*j] = 1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 71559,
                "title": "consise-java-dp-solution-beats-94-67",
                "content": "I had originally tried this problem in Python but I kept getting a time limit exceeded error. The same exact algorithm in Java outperforms ~95% of other submissions, so I think Python is simply too slow for this problem.\\n\\nAnyway, the algorithm here is pretty much exactly the same as in the \"coin change\" problem (#322), except the \"coins\" are just the set of perfect squares from 1 to n. If you're having trouble with this problem then I'd recommend first researching the coin change problem and understanding its solution, as almost exactly the same logic applies here.\\n\\n    public class Solution {\\n        public int numSquares(int n) {\\n            int[] memo = new int[n + 1];\\n            Arrays.fill(memo, Integer.MAX_VALUE);\\n            memo[0] = 0;\\n            int i = 0;\\n            while (++i * i <= n) {\\n                for (int j = i * i; j < memo.length; j++) {\\n                    memo[j] = Math.min(memo[j], memo[j - (i * i)] + 1);\\n                }\\n            }\\n            return memo[n];\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int numSquares(int n) {\\n            int[] memo = new int[n + 1];\\n            Arrays.fill(memo, Integer.MAX_VALUE);\\n            memo[0] = 0;\\n            int i = 0;\\n            while (++i * i <= n) {\\n                for (int j = i * i; j < memo.length; j++) {\\n                    memo[j] = Math.min(memo[j], memo[j - (i * i)] + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1475854,
                "title": "python-top-down-dp-clean-concise",
                "content": "**Solution 1: Top down DP**\\n- Let `dp(target)` donotes the least number of perfect square numbers that sum to `target`.\\n```python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        ps = []\\n        i = 1\\n        while i * i <= n:\\n            ps.append(i * i)\\n            i += 1\\n\\n        @lru_cache(None)\\n        def dp(target):\\n            if target == 0:\\n                return 0\\n\\n            ans = math.inf\\n            for num in ps:\\n                if target >= num:\\n                    ans = min(ans, dp(target - num) + 1)\\n            return ans\\n\\n        return dp(n)\\n```\\nComplexity:\\n- Time: `O(sqrt(N) * N)`, where `N <= 10^4`.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        ps = []\\n        i = 1\\n        while i * i <= n:\\n            ps.append(i * i)\\n            i += 1\\n\\n        @lru_cache(None)\\n        def dp(target):\\n            if target == 0:\\n                return 0\\n\\n            ans = math.inf\\n            for num in ps:\\n                if target >= num:\\n                    ans = min(ans, dp(target - num) + 1)\\n            return ans\\n\\n        return dp(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310668,
                "title": "heavily-commented-javascript-dynamic-programming-solution",
                "content": "```\\nfunction numSquares(n) {\\n    \\n    // General strategy is to build up a memoization array with the smallest amount of squares needed to make the number at each index\\n    // since the only square in the beginning is 1, until we see 4, it\\'s very boring:\\n    // to make 1, we use 1, to make 2 we use two 1\\'s, to make 3, we use three 1\\'s\\n    // mem[1] = 1, d[2] = 2, mem[3] = 3\\n    // initially, mem[4] will also use 1s and end up at 4\\n    // but now we can consider 2^2 too since the inner loop now allows it\\n    // we then compare, is what we have calculated so far better? or using this new square?\\n    // To answer that, we subtract the current square (4) from i (4) and look up in our mem lookup to see how many steps that took\\n    // mem[0] is zero of course, so we end up with Math.min(4, 0 + 1). The 2nd is less of course, so we set mem[4] to 1\\n    \\n    // Our memory lookup. Others often name this \\'dp\\'\\n    let mem = [0];\\n    let i, j;\\n    \\n    // Outer loop, where we build up till we reach n\\n    for (i = 1; i <= n; i++) {\\n        \\n        // Initially, we have no idea how many steps it will take\\n        mem[i] = Infinity;\\n        \\n        // Now loop over all squares that are smaller or equal to the current i.\\n        for (j = 1; j * j <= i; j++) {\\n                        \\n            // The smalles amount of squares is either what we already have, or what we can build with a new square and remainder\\n            mem[i] = Math.min(mem[i], mem[i - j*j] + 1)   \\n        }\\n        \\n        \\n    }\\n    return mem[n];\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction numSquares(n) {\\n    \\n    // General strategy is to build up a memoization array with the smallest amount of squares needed to make the number at each index\\n    // since the only square in the beginning is 1, until we see 4, it\\'s very boring:\\n    // to make 1, we use 1, to make 2 we use two 1\\'s, to make 3, we use three 1\\'s\\n    // mem[1] = 1, d[2] = 2, mem[3] = 3\\n    // initially, mem[4] will also use 1s and end up at 4\\n    // but now we can consider 2^2 too since the inner loop now allows it\\n    // we then compare, is what we have calculated so far better? or using this new square?\\n    // To answer that, we subtract the current square (4) from i (4) and look up in our mem lookup to see how many steps that took\\n    // mem[0] is zero of course, so we end up with Math.min(4, 0 + 1). The 2nd is less of course, so we set mem[4] to 1\\n    \\n    // Our memory lookup. Others often name this \\'dp\\'\\n    let mem = [0];\\n    let i, j;\\n    \\n    // Outer loop, where we build up till we reach n\\n    for (i = 1; i <= n; i++) {\\n        \\n        // Initially, we have no idea how many steps it will take\\n        mem[i] = Infinity;\\n        \\n        // Now loop over all squares that are smaller or equal to the current i.\\n        for (j = 1; j * j <= i; j++) {\\n                        \\n            // The smalles amount of squares is either what we already have, or what we can build with a new square and remainder\\n            mem[i] = Math.min(mem[i], mem[i - j*j] + 1)   \\n        }\\n        \\n        \\n    }\\n    return mem[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 176948,
                "title": "java-bfs-solution",
                "content": "Traverse every possibilities that squires number add squares number.\\nRecord the numbers of the squares number elements.\\nWhile traversing, if node - n.squares == 0, return deapth.\\n        //\\n```\\n        //Step 1. Build up HashSet to store the squares number\\n        Set<Integer> seen = new HashSet<>();\\n\\n        //Step 2. Initialize depth\\n        int depth = 0;\\n\\n        //Step 3. Build up Queue to store the sequence of (input - squares)\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(n);\\n\\n        //Step 4. Begin BFS\\n        while (!queue.isEmpty()){\\n            int size = queue.size();\\n            depth++;\\n            for (int i = 0; i < size; i++) {\\n                int node = queue.poll();\\n                if (!seen.add(node)) continue;\\n                for (int j = 1; j <= Math.sqrt(node); j++) {\\n                    int les = node - j * j;\\n                    if (les == 0) {\\n                        return depth;\\n                    }\\n                    queue.offer(les);\\n                }\\n            }\\n        }\\n\\n        return 0;\\n```",
                "solutionTags": [],
                "code": "```\\n        //Step 1. Build up HashSet to store the squares number\\n        Set<Integer> seen = new HashSet<>();\\n\\n        //Step 2. Initialize depth\\n        int depth = 0;\\n\\n        //Step 3. Build up Queue to store the sequence of (input - squares)\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(n);\\n\\n        //Step 4. Begin BFS\\n        while (!queue.isEmpty()){\\n            int size = queue.size();\\n            depth++;\\n            for (int i = 0; i < size; i++) {\\n                int node = queue.poll();\\n                if (!seen.add(node)) continue;\\n                for (int j = 1; j <= Math.sqrt(node); j++) {\\n                    int les = node - j * j;\\n                    if (les == 0) {\\n                        return depth;\\n                    }\\n                    queue.offer(les);\\n                }\\n            }\\n        }\\n\\n        return 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 486915,
                "title": "c-279-perfect-squares-bfs-solution",
                "content": "```\\n/* =========================*/\\n/* https://jasonchiucc.com  */\\n/* =========================*/\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        // Init\\n        unordered_set<int>  visited;\\n        queue<int>          q;\\n        vector<int>         vec; \\n        int                 step = 1;\\n        \\n        for(int i = 1; i*i <= n; i++ )\\n        {\\n            if( i*i == n) return step;\\n            q.push(i*i);\\n            visited.insert(i*i); \\n            vec.push_back(i*i);\\n        }                \\n           \\n        while( !q.empty() )\\n        {\\n            step += 1;\\n            int size = q.size();\\n            for (int i = 0 ; i < size; i++) \\n            {            \\n                int num = q.front();                 \\n                for (auto key : vec) \\n                { \\n                    int sum = num + key;\\n                    if( sum == n) return step;\\n                    if( sum < n && !visited.count(sum) )\\n                    {                        \\n                        q.push(sum);\\n                        visited.insert(sum);                         \\n                    }\\n                } \\n                q.pop();\\n            }\\n        }\\n        return -1;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/* =========================*/\\n/* https://jasonchiucc.com  */\\n/* =========================*/\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        // Init\\n        unordered_set<int>  visited;\\n        queue<int>          q;\\n        vector<int>         vec; \\n        int                 step = 1;\\n        \\n        for(int i = 1; i*i <= n; i++ )\\n        {\\n            if( i*i == n) return step;\\n            q.push(i*i);\\n            visited.insert(i*i); \\n            vec.push_back(i*i);\\n        }                \\n           \\n        while( !q.empty() )\\n        {\\n            step += 1;\\n            int size = q.size();\\n            for (int i = 0 ; i < size; i++) \\n            {            \\n                int num = q.front();                 \\n                for (auto key : vec) \\n                { \\n                    int sum = num + key;\\n                    if( sum == n) return step;\\n                    if( sum < n && !visited.count(sum) )\\n                    {                        \\n                        q.push(sum);\\n                        visited.insert(sum);                         \\n                    }\\n                } \\n                q.pop();\\n            }\\n        }\\n        return -1;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71567,
                "title": "simple-math-solution-4ms-in-c-explained-now",
                "content": "If you don't know Lagrange's four-square theorem, please check [wiki](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem) first and if you want to prove it, check [here](http://planetmath.org/proofoflagrangesfoursquaretheorem). In a summary, it's all about that the maximum will be 4 and in that case  it will follow the following equation, otherwise it will be 1, 2, 3.\\n\\n>  4^k(8m+7)\\n\\n    class Solution {\\n    public:\\n        int numSquares(int n) \\n        {\\n            while(!(n&3)) n /= 4;\\n            if(n%8 == 7) return 4;\\n            for(int a = sqrt(n); a > 0; --a)\\n            {\\n                int b = sqrt(n-a*a);\\n                if(a*a+b*b == n) return !b? 1 : 2;\\n            }\\n            return 3;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int numSquares(int n) \\n        {\\n            while(!(n&3)) n /= 4;\\n            if(n%8 == 7) return 4;\\n            for(int a = sqrt(n); a > 0; --a)\\n            {\\n                int b = sqrt(n-a*a);\\n                if(a*a+b*b == n) return !b? 1 : 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71597,
                "title": "12ms-recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "AT first, we all use the dp-method but the calculation exist many duplicate parts.\\n\\nSo we can avoid it by using a static-array to store the result .\\n\\n    class Solution {\\n    public:\\n        int numSquares(int n) {\\n            /*** first: you must initialize the dp-array ***/\\n            static vector<int> dp({0});\\n            /*** the-array-start-from-1 ***/\\n            if(dp.size() >= n+1)  return dp[n];\\n            /*** dp[n] means the dp.size()=n+1 ***/\\n            while(dp.size()<=n+1){\\n                /*** the-j-should-start-from-1 ***/\\n                int temp=INT_MAX;\\n                for(int j=1; j*j<=dp.size(); j++)\\n                    temp=min(temp, dp[dp.size()-j*j]+1);\\n                dp.push_back(temp);\\n            }\\n            return dp[n];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int numSquares(int n) {\\n            /*** first: you must initialize the dp-array ***/\\n            static vector<int> dp({0}",
                "codeTag": "Java"
            },
            {
                "id": 71661,
                "title": "o-sqrt-n-2-applying-fermat-s-theorm-with-brahmagupta-u2013fibonacci-identity",
                "content": "First I check if number if perfect square, next I check if number fits Legendre's condition for 4 squares 4^a(8b+7) .\\nI check if number is prime and is prime I check that n%4==1. See h[ttps://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares][1]\\nIf number is not a prime I check if the numbers it's composed of numbers that match Fermat's theorem.\\nBy Brahmagupta\\u2013Fibonacci identity\\n[https://en.wikipedia.org/wiki/Brahmagupta%E2%80%93Fibonacci_identity][2]\\nif all factors(or subfactors) are prime and match condtion n%4==1 I am guaranteed that my number is sum of 2 squares. Otherwise it's sum of 3 squares by Legendre's theorem .\\n\\n    public class Solution {\\n        public int numSquares(int n) {\\n            if (Math.pow((int)Math.sqrt(n), 2) == n){\\n        \\t    return 1;\\n        \\t}\\n            while (n%4 == 0){\\n                n = n/4;\\n        \\t}\\n            if (n%8 == 7){\\n                return 4;\\n            }\\n            if (n%2 == 0){\\n                n = n/2; //OK to divide by 2. If N/2 has is sum of 2 squares so will be N.\\n            }\\n            if (isMod41PrimeOrSubP(n)){\\n                return 2;\\n            }\\n        \\treturn 3;\\n        }\\n        private boolean isMod41PrimeOrSubP(int num) {\\n            if (num%4 != 1){\\n                return false;\\n            }\\n            for (int i=3; i*i<num; i=i+2){\\n                if (num%i == 0) {\\n                    if (num%(i*i) == 0){\\n             \\t        return isMod41PrimeOrSubP(num/(i*i));\\n                    } \\n                    return isMod41PrimeOrSubP(i)&&isMod41PrimeOrSubP(num/i);\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n\\n  [1]: https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n  [2]: https://en.wikipedia.org/wiki/Brahmagupta%E2%80%93Fibonacci_identity",
                "solutionTags": [],
                "code": "class Solution {\\n        public int numSquares(int n) {\\n            if (Math.pow((int)Math.sqrt(n), 2) == n){\\n        \\t    return 1;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 2584242,
                "title": "java-easiest-solution-bottom-up-dp",
                "content": "please do upvote if it helps\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,n);\\n        dp[0]=0;\\n        for(int i=0;i<n+1;i++){\\n            for(int j=1;j<i+1;j++){\\n                int square=j*j;\\n                if(i-square<0){\\n                    break;\\n                }else{\\n                    dp[i]=Math.min(dp[i],1+dp[i-square]);\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,n);\\n        dp[0]=0;\\n        for(int i=0;i<n+1;i++){\\n            for(int j=1;j<i+1;j++){\\n                int square=j*j;\\n                if(i-square<0){\\n                    break;\\n                }else{\\n                    dp[i]=Math.min(dp[i],1+dp[i-square]);\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1512708,
                "title": "java-recursion-memoization-dp-solutions",
                "content": "**Recursion : TLE**\\n```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int numSquares(int n) {\\n        if(n <= 3)return n;\\n        for(int i = 1;i*i<=n;i++){\\n            ans = Math.min(ans,1 + numSquares(n - (i*i)));\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Memoization : \\nRuntime: 75 ms, faster than 35.20% of Java online submissions for Perfect Squares.\\nMemory Usage: 39.4 MB, less than 46.60% of Java online submissions for Perfect Squares.**\\n```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int numSquares(int n) {\\n        int dp[] = new int[n+1];\\n        Arrays.fill(dp,-1);\\n        return helper(n,dp);\\n    }\\n    public int helper(int n,int dp[]){\\n        if(n <= 3)return dp[n] = n;\\n        if(dp[n] != -1)return dp[n];\\n        for(int i = 1;i*i<=n;i++){\\n            ans = Math.min(ans,1+helper(n-(i*i),dp));\\n        }\\n        return dp[n] = ans;\\n    }\\n}\\n```\\n**DP :\\nRuntime: 32 ms, faster than 73.82% of Java online submissions for Perfect Squares.\\nMemory Usage: 37.9 MB, less than 89.36% of Java online submissions for Perfect Squares.**\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[] = new int[n+1];\\n        for(int i = 1;i<=n;i++){\\n            dp[i] = i;\\n            for(int j = 1;j*j<=i;j++){\\n                dp[i] = Math.min(dp[i],1+dp[i-(j*j)]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int numSquares(int n) {\\n        if(n <= 3)return n;\\n        for(int i = 1;i*i<=n;i++){\\n            ans = Math.min(ans,1 + numSquares(n - (i*i)));\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int numSquares(int n) {\\n        int dp[] = new int[n+1];\\n        Arrays.fill(dp,-1);\\n        return helper(n,dp);\\n    }\\n    public int helper(int n,int dp[]){\\n        if(n <= 3)return dp[n] = n;\\n        if(dp[n] != -1)return dp[n];\\n        for(int i = 1;i*i<=n;i++){\\n            ans = Math.min(ans,1+helper(n-(i*i),dp));\\n        }\\n        return dp[n] = ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[] = new int[n+1];\\n        for(int i = 1;i<=n;i++){\\n            dp[i] = i;\\n            for(int j = 1;j*j<=i;j++){\\n                dp[i] = Math.min(dp[i],1+dp[i-(j*j)]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420219,
                "title": "simple-python-dp-or-bfs",
                "content": "**Dynamic Programming:**\\nLet dp[i] record the least number of perfect square numbers that sum to i. If i itself is a perfect square, dp[i] is simply 1. Otherwise, we go through all the i-j^2 and look for the smallest.\\n```Python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        dp = [float(\"inf\")]*(n+1)\\n        for i in range(len(dp)):\\n            if int(sqrt(i)) == sqrt(i):\\n                dp[i] = 1\\n            else:\\n                for j in range(int(sqrt(i))+1):\\n                    dp[i] = min(dp[i], dp[i-j*j]+1)\\n        return dp[-1]\\n```\\n\\n**BFS:**\\nWe can also see this problem as looking for the smallest number of steps between 0 and n. A standard BFS can find the shortest distance because edges are uniformly weighted (i.e. both 1^2, 2^2, 3^2... counts as 1 step).\\n```Python\\nfrom collections import deque\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        queue = deque([(n, 0)])\\n        while queue:\\n            cur_n, cur_steps = queue.popleft()\\n            if cur_n**0.5 == int(cur_n**0.5):\\n                return cur_steps+1\\n            for i in range(1, int(cur_n**0.5)+1):\\n                queue.append((cur_n-i*i, cur_steps+1))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```Python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        dp = [float(\"inf\")]*(n+1)\\n        for i in range(len(dp)):\\n            if int(sqrt(i)) == sqrt(i):\\n                dp[i] = 1\\n            else:\\n                for j in range(int(sqrt(i))+1):\\n                    dp[i] = min(dp[i], dp[i-j*j]+1)\\n        return dp[-1]\\n```\n```Python\\nfrom collections import deque\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        queue = deque([(n, 0)])\\n        while queue:\\n            cur_n, cur_steps = queue.popleft()\\n            if cur_n**0.5 == int(cur_n**0.5):\\n                return cur_steps+1\\n            for i in range(1, int(cur_n**0.5)+1):\\n                queue.append((cur_n-i*i, cur_steps+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356758,
                "title": "unbounded-knapsack-memoization-top-down-dp",
                "content": "```\\nclass Solution {\\npublic: \\n    \\n    int dp[102][10002];\\n\\n    int UKS (vector<int> &nums, int n, int sum) { \\n    \\n        if (sum == 0) { \\n            return dp[n][sum] = 0;\\n        } \\n        \\n        else if (n <= 0) { \\n            return dp[n][sum] = 1e8;\\n        } \\n         \\n        else if (dp[n][sum] != -1) { \\n            return dp[n][sum];\\n        }\\n        else if (nums[n-1] > sum) { \\n            return dp[n][sum] = UKS (nums, n-1, sum);\\n        } \\n        \\n        return dp[n][sum] = min(1 + UKS(nums, n, sum-nums[n-1]), UKS (nums, n-1, sum));\\n    \\n    } \\n\\n    int numSquares(int n) {  \\n        \\n        vector<int> nums;  \\n        \\n        memset(dp, -1, sizeof dp);\\n        \\n        for (int i = 1; i <= n; i++) { \\n            \\n            if (i * i <= n) { \\n                \\n                nums.push_back(i*i);\\n            \\n            }\\n        \\n        }  \\n            \\n       return UKS (nums, nums.size(), n);\\n    }\\n}; \\n\\n\\n \\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    \\n    int dp[102][10002];\\n\\n    int UKS (vector<int> &nums, int n, int sum) { \\n    \\n        if (sum == 0) { \\n            return dp[n][sum] = 0;\\n        } \\n        \\n        else if (n <= 0) { \\n            return dp[n][sum] = 1e8;\\n        } \\n         \\n        else if (dp[n][sum] != -1) { \\n            return dp[n][sum];\\n        }\\n        else if (nums[n-1] > sum) { \\n            return dp[n][sum] = UKS (nums, n-1, sum);\\n        } \\n        \\n        return dp[n][sum] = min(1 + UKS(nums, n, sum-nums[n-1]), UKS (nums, n-1, sum));\\n    \\n    } \\n\\n    int numSquares(int n) {  \\n        \\n        vector<int> nums;  \\n        \\n        memset(dp, -1, sizeof dp);\\n        \\n        for (int i = 1; i <= n; i++) { \\n            \\n            if (i * i <= n) { \\n                \\n                nums.push_back(i*i);\\n            \\n            }\\n        \\n        }  \\n            \\n       return UKS (nums, nums.size(), n);\\n    }\\n}; \\n\\n\\n \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707718,
                "title": "c-easy-understanding-time-100-faster-memory-85",
                "content": "***Please upvote if you found it helpful :)***\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        if(n<0)return 0;\\n        static vector<int> hg({0});\\n        while(hg.size()<=n){\\n            int temp=INT_MAX;\\n            int m=hg.size();\\n            for(int i=1;i*i<=m;i++){\\n                temp=min(temp,hg[m-i*i]+1);\\n            }\\n            hg.push_back(temp);\\n        }\\n        return hg[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        if(n<0)return 0;\\n        static vector<int> hg({0});\\n        while(hg.size()<=n){\\n            int temp=INT_MAX;\\n            int m=hg.size();\\n            for(int i=1;i*i<=m;i++){\\n                temp=min(temp,hg[m-i*i]+1);\\n            }\\n            hg.push_back(temp);\\n        }\\n        return hg[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301341,
                "title": "c-dp",
                "content": "```\\npublic class Solution {\\n    public int NumSquares(int n) {\\n        var dp = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = int.MaxValue;\\n            for (int j = 1; j * j <= i; j++) {\\n                dp[i] = Math.Min(dp[i], dp[i - j * j] + 1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumSquares(int n) {\\n        var dp = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = int.MaxValue;\\n            for (int j = 1; j * j <= i; j++) {\\n                dp[i] = Math.Min(dp[i], dp[i - j * j] + 1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71527,
                "title": "my-recursive-solution-java",
                "content": "Hi all, here's my Java solution.\\n\\n    public class Solution {\\n        public int numSquares(int n) {\\n            int result=n, num= 2;\\n            while(num*num<=n){\\n                int temp1= n/(num*num), temp2= n%(num*num);\\n                result= Math.min(result,temp1+numSquares(temp2));\\n                num++;\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int numSquares(int n) {\\n            int result=n, num= 2;\\n            while(num*num<=n){\\n                int temp1= n/(num*num), temp2= n%(num*num);\\n                result= Math.min(result,temp1+numSquares(temp2));\\n                num++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71685,
                "title": "concise-and-easy-to-understand-java-solution-with-detailed-explanation",
                "content": "    public class Solution {\\n    public int numSquares(int n) {\\n        if (n <= 1) {\\n            return n;\\n        }\\n        Set<Integer> squareSet = buildSet(n); // This set contains all perfect square numbers (1, 4, 9, 16, ...) <= n \\n        int[] dp = new int[n + 1]; // dp[i] means the least number of perfect suqare numbers sum to n.\\n        for (int i = 1; i <= n; i++) {\\n            if (squareSet.contains(i)) { // If this number is a perfect square number\\n                dp[i] = 1; // Set itself to 1\\n            }\\n            for (int j: squareSet) { // For each perfect square number j, \"the least number for i + j\" will be \"the number for i\" + 1.\\n                if (i + j > n) {\\n                    break;\\n                } else { \\n                    dp[i + j] = dp[i + j] == 0 ? dp[i] + 1 : Math.min(dp[i] + 1, dp[i + j]); // choose the smaller one if it isn't 0.\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n    \\n    private Set<Integer> buildSet(int n) { // Build the set of perfect square number\\n        Set<Integer> set = new TreeSet<Integer>();\\n        for (int i = 1; i * i <= n; i++) {\\n            set.add(i * i);\\n        }\\n        return set;\\n      }\\n    }\\n\\nThe basic idea is that for each number i less than n, it updates the least number sum to i + j after adding **one** perfect square number j. \\n\\nFor example, if n = 10, it builds the set containing all perfect square number less than 10, which are 1, 4, 9. Then for the first iteration, it updates the least number sum to 1, 1 + 1, 1 + 4 and 1 + 9. Then 2 + 1, 2 + 4, 2 + 9 (out of scope will break).\\n\\nThe time complexity is O(n * sqrt(n)) and space complexity is O(sqrt(n)). **If anyone has a better solution or has some ways to optimize this code, please write a comment on it. Thanks!**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int numSquares(int n) {\\n        if (n <= 1) {\\n            return n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3236383,
                "title": "279-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We first initialize a list dp with n+1 elements, where dp[i] represents the least number of perfect square numbers that sum to the index i. We set dp[0] = 0, since zero is not a perfect square and does not require any perfect squares to be summed up to it. We set all other elements to infinity initially.\\n\\n2. We iterate through all numbers from 1 to n. For each number i, we iterate through all possible perfect square numbers that are less than or equal to i. We use the square root function int(i ** 0.5) to get the largest perfect square number less than or equal to i. We start the inner loop from 1 to include the perfect square number 1.\\n\\n3. For each jth perfect square number less than or equal to i, we update the least number of perfect square numbers that sum to i as dp[i] = min(dp[i], dp[i - j*j] + 1). Here, dp[i - j*j] + 1 represents the number of perfect square numbers required to sum up to i-j*j, and we add 1 to account for the current perfect square number j*j.\\n\\n4. Finally, we return the least number of perfect square numbers that sum to n, which is stored in dp[n].\\n\\nThis solution uses dynamic programming to solve the problem, and is optimized by iterating through all perfect square numbers less than or equal to i, rather than all numbers less than or equal to i.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        # Initialize a list to store the least number of perfect square numbers that sum to the index i\\n        dp = [0] + [float(\\'inf\\')] * n\\n        \\n        # Iterate through all numbers from 1 to n\\n        for i in range(1, n + 1):\\n            # Iterate through all possible perfect square numbers that are less than or equal to i\\n            for j in range(1, int(i ** 0.5) + 1):\\n                # Update the least number of perfect square numbers that sum to i\\n                dp[i] = min(dp[i], dp[i - j*j] + 1)\\n        \\n        # Return the least number of perfect square numbers that sum to n\\n        return dp[n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        # Initialize a list to store the least number of perfect square numbers that sum to the index i\\n        dp = [0] + [float(\\'inf\\')] * n\\n        \\n        # Iterate through all numbers from 1 to n\\n        for i in range(1, n + 1):\\n            # Iterate through all possible perfect square numbers that are less than or equal to i\\n            for j in range(1, int(i ** 0.5) + 1):\\n                # Update the least number of perfect square numbers that sum to i\\n                dp[i] = min(dp[i], dp[i - j*j] + 1)\\n        \\n        # Return the least number of perfect square numbers that sum to n\\n        return dp[n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171453,
                "title": "maths-solution-beats-98-88-in-runtime-clean-simple-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        # Nice Approach 2nd fastest\\n        # if n <= 0:\\n        #     return 0\\n        #\\n        # cnt_perfect_square = [0]\\n        #\\n        # while len(cnt_perfect_square) <= n:\\n        #     m = len(cnt_perfect_square)\\n        #     cnt_square = sys.maxsize\\n        #     for i in range(1, int(math.sqrt(m)) + 1):\\n        #         cnt_square = min(cnt_square, cnt_perfect_square[m - i * i] + 1)\\n        #     cnt_perfect_square.append(cnt_square)\\n        # return cnt_perfect_square[n]\\n\\n        # We can Use Langrage\\'s 4 Square theorem to do this in very efficient manner\\n        def is_perfect_square(n):\\n            square_root = int(math.sqrt(n))\\n            return square_root**2 == n\\n        \\n        cpy_n = n\\n        if is_perfect_square(n):\\n            return 1\\n        # 4^k(8m + 7) if in this way a num. can be represented then it\\'s a sum of 4 square nums.\\n        while n & 3 == 0:    # divisible by 4\\n            n >>= 2           # divide by 4\\n        if n & 7 == 7:       # n & 7 ---> n % 8 == 0  and n & 7 == 7 means n % 8 == 7\\n            return 4\\n        n = cpy_n\\n        for i in range(1, int(math.sqrt(n)) + 1):\\n            if is_perfect_square(n - i*i):\\n                return 2\\n        return 3\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        # Nice Approach 2nd fastest\\n        # if n <= 0:\\n        #     return 0\\n        #\\n        # cnt_perfect_square = [0]\\n        #\\n        # while len(cnt_perfect_square) <= n:\\n        #     m = len(cnt_perfect_square)\\n        #     cnt_square = sys.maxsize\\n        #     for i in range(1, int(math.sqrt(m)) + 1):\\n        #         cnt_square = min(cnt_square, cnt_perfect_square[m - i * i] + 1)\\n        #     cnt_perfect_square.append(cnt_square)\\n        # return cnt_perfect_square[n]\\n\\n        # We can Use Langrage\\'s 4 Square theorem to do this in very efficient manner\\n        def is_perfect_square(n):\\n            square_root = int(math.sqrt(n))\\n            return square_root**2 == n\\n        \\n        cpy_n = n\\n        if is_perfect_square(n):\\n            return 1\\n        # 4^k(8m + 7) if in this way a num. can be represented then it\\'s a sum of 4 square nums.\\n        while n & 3 == 0:    # divisible by 4\\n            n >>= 2           # divide by 4\\n        if n & 7 == 7:       # n & 7 ---> n % 8 == 0  and n & 7 == 7 means n % 8 == 7\\n            return 4\\n        n = cpy_n\\n        for i in range(1, int(math.sqrt(n)) + 1):\\n            if is_perfect_square(n - i*i):\\n                return 2\\n        return 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837698,
                "title": "recursion-memoization-approach",
                "content": "# Intuition\\nWe have to check all possible paths to our sum and then find the smallest one to it.\\n\\n# Approach\\nUsing a dfs type apporach we generate all the sum possible at a level and add it to our sum and we only itrate till root of n as beyond it the sum would only increase\\n\\n# Complexity\\n- Time complexity: O(n * root(n)) n is the target value\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) n is the target value\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int sum , int target , vector<int>& dp){\\n        if(sum == target) return 0;\\n        if(sum > target) return 1e6;\\n        if(dp[sum] != -1) return dp[sum];\\n        int ans = INT_MAX;\\n        for(int i = 1 ; i <= sqrt(target) ; i++){\\n            int val = i * i;\\n            ans = min(ans , 1 + dfs(sum + val , target , dp));\\n        }\\n        return dp[sum] = ans;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(n + 1 , -1);\\n        return dfs(0 , n , dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int sum , int target , vector<int>& dp){\\n        if(sum == target) return 0;\\n        if(sum > target) return 1e6;\\n        if(dp[sum] != -1) return dp[sum];\\n        int ans = INT_MAX;\\n        for(int i = 1 ; i <= sqrt(target) ; i++){\\n            int val = i * i;\\n            ans = min(ans , 1 + dfs(sum + val , target , dp));\\n        }\\n        return dp[sum] = ans;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(n + 1 , -1);\\n        return dfs(0 , n , dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520562,
                "title": "c-mathematical-solution-0ms-faster-than-100-explained",
                "content": "Te main concept behind this is Lagaranges\\'s four square theorem. It states that every positive integer can be written as the sum of at most four squares.  In this problem since we need to find the minimum no of numbers required to make a perfect square the highest number of sum we need to find is 4.  A number can be expressed as a sum of 4 square if it satisfies the equation 4^a(8k+7).\\n```\\nclass Solution {\\npublic:\\n    int is_sq(int a)//Check whether given number is a perfect square or not\\n    {\\n        int r=(int)sqrt(a);\\n        if(r*r==a)\\n            return 1;\\n        return 0;\\n    }\\n    int numSquares(int n) {\\n      int count=0;\\n       while(n%4==0)\\n       {\\n           n/=4; \\n       }\\n        if(n%8==7)\\n            return 4;// TOcheck whether number satisfies 4^a(8k+7).\\n        if(is_sq(n))\\n            return 1;//if number is a perfect square\\n        for(int i=1;i*i<=n;i++ )\\n        {\\n            if(is_sq(n-i*i))\\n                return 2;//if number is a sum of two square\\n        }\\n        return 3;//if none of the conditions are satisfied\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int is_sq(int a)//Check whether given number is a perfect square or not\\n    {\\n        int r=(int)sqrt(a);\\n        if(r*r==a)\\n            return 1;\\n        return 0;\\n    }\\n    int numSquares(int n) {\\n      int count=0;\\n       while(n%4==0)\\n       {\\n           n/=4; \\n       }\\n        if(n%8==7)\\n            return 4;// TOcheck whether number satisfies 4^a(8k+7).\\n        if(is_sq(n))\\n            return 1;//if number is a perfect square\\n        for(int i=1;i*i<=n;i++ )\\n        {\\n            if(is_sq(n-i*i))\\n                return 2;//if number is a sum of two square\\n        }\\n        return 3;//if none of the conditions are satisfied\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369732,
                "title": "c-iterative-dp",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    int numSquares(int n)\\n    {\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 1; j * j <= i; j++)\\n            {\\n                if (i - j >= 0)\\n                    dp[i] = min(dp[i], dp[i - j * j] + 1);\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    int numSquares(int n)\\n    {\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 1; j * j <= i; j++)\\n            {\\n                if (i - j >= 0)\\n                    dp[i] = min(dp[i], dp[i - j * j] + 1);\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927387,
                "title": "dfs-dp-progression-with-explanation-o-n-2-o-n",
                "content": "In this problem, we are looking for the smallest combination of square numbers that sum up to a given number.  Therefore, we can solve this problem by looking through all combinations of square numbers that sum up to `n`, and return the smallest combination.  DFS is a great tool for this, as we can imagine an instance of the function as the current state, and each recursive call as a possible action to a future state.\\n```\\ndef dfs(n):\\n\\tif not n:\\n\\t\\treturn 0\\n\\tsquares = [i**2 for i in range(1, int(math.floor(math.sqrt(n))) + 1)]\\n\\tshortest = float(\"inf\")\\n\\tfor i in range(len(squares)):\\n\\t\\tshortest = min(shortest, 1 + dfs(n - squares[i]))\\n\\treturn shortest\\nreturn dfs(n)\\n```\\nLet\\'s take a look at the DFS tree this creates.\\n![image](https://assets.leetcode.com/users/images/ffe44e14-05ac-4d85-9892-ff43245fe1b5_1604794579.0745683.png)\\nThis is a very common pattern in DFS problems, where we traverse the DFS tree and acquire some `cost` at each node.  For this problem, since we are looking for the amount of square numbers of that add up to `n`, the cost would simply be 1.  Therefore, the solution to this problem would be to find the shortest root -> leaf path created in the DFS tree.\\nHowever, this method is far too slow and times out.  Why is that?  If we take a look at the DFS tree, notice the amount of redundant calculations there are.  For instance, we see `8` twice.  From 8 onwards, the calculation will always return the same value, but our implementation of DFS is not aware of that and will spend time recalculating it.  This becomes exponentially worse as the input becomes large and the DFS tree grows taller.  This is where the DP solution comes in.\\nThe DFS approach solves the problem from the top down, meaning it needs to recurse all the way down to the base case `(if not n: return 0` to have any idea of how long a path is.  Instead, let\\'s solve this problem from the bottom up, saving the solution to a given subproblem at every step.  Therefore if we come across a subproblem multiple times, we can simply reference the solution yielded from the first time it was calculated.\\n```\\ndef dp(n):\\n\\tA = [float(\"inf\") for _ in range(n + 1)]\\n\\tA[0] = 0\\n\\tfor j in range(1, n + 1):\\n\\t\\tfor i in range(1, int(math.floor(math.sqrt(j))) + 1):\\n\\t\\t\\tA[j] = min(A[j], 1 + A[j - i**2])\\n\\treturn A[-1]\\nreturn dp(n)\\n```\\nNotice the recursion relation is exactly the same as in the DFS approach, however now we are simply referencing the cached answer.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(n):\\n\\tif not n:\\n\\t\\treturn 0\\n\\tsquares = [i**2 for i in range(1, int(math.floor(math.sqrt(n))) + 1)]\\n\\tshortest = float(\"inf\")\\n\\tfor i in range(len(squares)):\\n\\t\\tshortest = min(shortest, 1 + dfs(n - squares[i]))\\n\\treturn shortest\\nreturn dfs(n)\\n```\n```\\ndef dp(n):\\n\\tA = [float(\"inf\") for _ in range(n + 1)]\\n\\tA[0] = 0\\n\\tfor j in range(1, n + 1):\\n\\t\\tfor i in range(1, int(math.floor(math.sqrt(j))) + 1):\\n\\t\\t\\tA[j] = min(A[j], 1 + A[j - i**2])\\n\\treturn A[-1]\\nreturn dp(n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 707666,
                "title": "tired-of-dp-solutions-check-this-different-approach-beats-96-of-python-solution",
                "content": "Tried this different approach in which I have used concept of 2sum and 3sum problem.\\n\\nAny  number can be represented by maximun 4 number which are perfect square  by minimizing no of perfect Squares.\\n\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        nums = set()\\n        \\n        if n == 0:\\n            return 0 #Base case\\n        \\n        #Find all the Squares les than equal to n\\n        \\n        for i in range(n+1):\\n            if i**2 <= n:\\n                nums.add(i**2)\\n                if i**2 == n : #if N is perfect square\\n                    return 1\\n            else:\\n                break\\n                \\n        res = 4 #N can be represented by maximun 4 numbers \\n        \\n        #check for 2 and 3 using 2sum and 3sum problem  \\n        \\n        for i in nums:\\n            \\n            if (n-i) in nums:\\n                res = min(res,2) #check for 2 Sum problem\\n                return res           # min is 2\\n            for j in nums :\\n                \\n                if (n-i-j) in nums :\\n                    \\n                    res = min(res,3) #check for 3 Sum problem\\n        \\n        return res\\n```\\n\\nPlease Upvote : )",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        nums = set()\\n        \\n        if n == 0:\\n            return 0 #Base case\\n        \\n        #Find all the Squares les than equal to n\\n        \\n        for i in range(n+1):\\n            if i**2 <= n:\\n                nums.add(i**2)\\n                if i**2 == n : #if N is perfect square\\n                    return 1\\n            else:\\n                break\\n                \\n        res = 4 #N can be represented by maximun 4 numbers \\n        \\n        #check for 2 and 3 using 2sum and 3sum problem  \\n        \\n        for i in nums:\\n            \\n            if (n-i) in nums:\\n                res = min(res,2) #check for 2 Sum problem\\n                return res           # min is 2\\n            for j in nums :\\n                \\n                if (n-i-j) in nums :\\n                    \\n                    res = min(res,3) #check for 3 Sum problem\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570758,
                "title": "28ms-99-4-python-simple-loop-solution",
                "content": "According to Lagrange\\'s four-square theorem\\nWe can solve this problem like this(Time complexity is O(n)):\\n\\n```python\\nclass Solution:\\n    def numSquares(self, n):\\n        sqr = sqrt(n)\\n        pool = {i**2 for i in range(int(sqr)+1)}\\n        test = [i**2 for i in range(int(sqr*0.71)+1)]\\n        \\n        for i in test:\\n            for j in test:\\n                if n-i-j in pool:\\n                    return 3-(i==0)-(j==0)\\n        return 4\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def numSquares(self, n):\\n        sqr = sqrt(n)\\n        pool = {i**2 for i in range(int(sqr)+1)}\\n        test = [i**2 for i in range(int(sqr*0.71)+1)]\\n        \\n        for i in test:\\n            for j in test:\\n                if n-i-j in pool:\\n                    return 3-(i==0)-(j==0)\\n        return 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462694,
                "title": "python3-simple-dp-solution",
                "content": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        if n == 0: return 0\\n        dp = [i for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,i*i):\\n                if i - j*j < 0:\\n                    break\\n                dp[i] = min(dp[i],dp[i-j*j]+1)\\n        return dp[-1]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        if n == 0: return 0\\n        dp = [i for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,i*i):\\n                if i - j*j < 0:\\n                    break\\n                dp[i] = min(dp[i],dp[i-j*j]+1)\\n        return dp[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71530,
                "title": "straightforward-java-bfs-beats-93-69",
                "content": "    public class Solution {\\n        public int numSquares(int n) {\\n    \\n            ArrayDeque<Integer> queue = new ArrayDeque<Integer>();\\n            queue.add(n);\\n            int depth = 1, m = 1, tmp = 0;\\n            \\n            while(true){\\n                if(m == 0){\\n                    depth++;\\n                    m = tmp;\\n                    tmp = 0;\\n                }\\n                \\n                int cur = queue.remove();\\n                m--;\\n                \\n                int l = (int) Math.sqrt(cur);\\n                for(int i=l; i>0; i--){\\n                    int sq = i*i;\\n                    int delta = cur - sq;\\n                    if(delta == 0)\\n                        return depth;\\n                    queue.add(delta);\\n                    tmp++;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int numSquares(int n) {\\n    \\n            ArrayDeque<Integer> queue = new ArrayDeque<Integer>();\\n            queue.add(n);\\n            int depth = 1, m = 1, tmp = 0;\\n            \\n            while(true){\\n                if(m == 0){\\n                    depth++;\\n                    m = tmp;\\n                    tmp = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 71602,
                "title": "my-simple-dfs-method-c",
                "content": "    class Solution {\\n    public:\\n        int numSquares(int n) {\\n           // int ret=INT_MAX;\\n            if(n==0)return 0;\\n            return  numSquares( n,1,INT_MAX); \\n        }\\n        \\n        \\n         int numSquares(int n,int deep,int min) {\\n            if(deep>=min)return min;\\n            int sq=sqrt(n);\\n            if(sq*sq==n) { return 1;}\\n            for(int i=sq;i>=1;i--)\\n            {\\n                int temp=1+numSquares(n-i*i,deep+1,min);\\n                if( temp<min)min=temp;\\n            }\\n            return  min;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int numSquares(int n) {\\n           // int ret=INT_MAX;\\n            if(n==0)return 0;\\n            return  numSquares( n,1,INT_MAX); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2838778,
                "title": "java-intuitive-dp-explained",
                "content": "# Intuition\\nFirst we need to build the squares array that represent the possible square values that we can have **upto** the given number n.\\n\\nThen it becomes a coin-change problem. We need to pick the least amount of values that can form our number n.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        List<Integer> squares = new ArrayList<>();\\n\\n        int cur = 1;\\n        // Build the squares array\\n        while (Math.pow(cur, 2) <= n) {\\n            squares.add((int) Math.pow(cur++, 2));\\n        }\\n\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n\\n        // Base case\\n        dp[0] = 0;\\n        for (int i = 1; i < n+1; i++ ) {\\n            // DP transition\\n            for (int j = 0; j < squares.size() && squares.get(j) <= i; j++) {\\n                dp[i] = Math.min(dp[i], 1 + dp[i-squares.get(j)]);\\n            }\\n        }\\n        return dp[n];\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        List<Integer> squares = new ArrayList<>();\\n\\n        int cur = 1;\\n        // Build the squares array\\n        while (Math.pow(cur, 2) <= n) {\\n            squares.add((int) Math.pow(cur++, 2));\\n        }\\n\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n\\n        // Base case\\n        dp[0] = 0;\\n        for (int i = 1; i < n+1; i++ ) {\\n            // DP transition\\n            for (int j = 0; j < squares.size() && squares.get(j) <= i; j++) {\\n                dp[i] = Math.min(dp[i], 1 + dp[i-squares.get(j)]);\\n            }\\n        }\\n        return dp[n];\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838235,
                "title": "golang-math-100-simple-fast-and-easy-with-explanation",
                "content": "# \\uD83D\\uDD25 Golang Math \\uD83D\\uDD25 || 100%  || Simple Fast and Easy || with Explanation\\n\\n```go\\nfunc numSquares(n int) int {\\n\\t// Four-square and three-square theorems.\\n\\tif isSquare(n) {\\n\\t\\treturn 1\\n\\t}\\n\\tfor n&3 == 0 { // n % 4 == 0\\n\\t\\tn >>= 2 // n /= 4\\n\\t}\\n\\tif n&7 == 7 { // n % 8 == 7\\n\\t\\treturn 4\\n\\t}\\n\\n\\t// Check if the number can be decomposed into sum of two squares.\\n\\tfor i := 1; i*i <= n; i++ {\\n\\t\\tif isSquare(n - i*i) {\\n\\t\\t\\treturn 2\\n\\t\\t}\\n\\t}\\n\\t// Bottom case of three-square theorem.\\n\\treturn 3\\n}\\n\\nfunc isSquare(n int) bool {\\n\\tvar squareRootN int = (int)(math.Sqrt(float64(n)))\\n\\treturn squareRootN*squareRootN == n\\n}\\n```\\n## [GitHub Link](https://github.com/ayoubzulfiqar/leetcode)",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```go\\nfunc numSquares(n int) int {\\n\\t// Four-square and three-square theorems.\\n\\tif isSquare(n) {\\n\\t\\treturn 1\\n\\t}\\n\\tfor n&3 == 0 { // n % 4 == 0\\n\\t\\tn >>= 2 // n /= 4\\n\\t}\\n\\tif n&7 == 7 { // n % 8 == 7\\n\\t\\treturn 4\\n\\t}\\n\\n\\t// Check if the number can be decomposed into sum of two squares.\\n\\tfor i := 1; i*i <= n; i++ {\\n\\t\\tif isSquare(n - i*i) {\\n\\t\\t\\treturn 2\\n\\t\\t}\\n\\t}\\n\\t// Bottom case of three-square theorem.\\n\\treturn 3\\n}\\n\\nfunc isSquare(n int) bool {\\n\\tvar squareRootN int = (int)(math.Sqrt(float64(n)))\\n\\treturn squareRootN*squareRootN == n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2652004,
                "title": "c-recursion-to-dp-explained-beginner-friendly",
                "content": "\\t\\t\\t\\t\\t\\t\\t\\t\\tIf it helps, please UPVOTE :)\\n**Recursion:**\\n```\\nclass Solution {\\npublic:\\n    int solve(int target)\\n    {\\n        if(target == 0)     //original target fulfilled, no need of any other integer now\\n            return 0;\\n        if(target < 0)      //target can\\'t be fulfilled so in min(mini, 1 + solve) we should have solve = INT_MAX - 1 so that we don\\'t consider solve way\\n            return INT_MAX - 1;\\n        \\n        int mini = INT_MAX;\\n        for(int i=1; i*i<=target; i++)                  //traverse i until (square of i) <= target as we need to subtract it from target\\n            mini = min(mini, 1 + solve(target - i*i));  // + 1 as we are taking this integer so it counts 1\\n        \\n        return mini;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        return solve(n);\\n    }\\n};\\n```\\n**Memoization:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int solve(int target)\\n    {\\n        if(target == 0)    \\n            return 0;\\n        if(target < 0)      \\n            return INT_MAX - 1;\\n        \\n        if(dp[target] != -1)\\n            return dp[target];\\n        \\n        int mini = INT_MAX;\\n        for(int i=1; i*i<=target; i++)\\n            mini = min(mini, 1 + solve(target - i*i));\\n        \\n        return dp[target] = mini;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        dp.resize(n+1, -1);\\n        return solve(n);\\n    }\\n};\\n```\\n\\n**Bottom up tabulation (DP):**\\n```\\n int numSquares(int n) \\n    {\\n        dp.resize(n+1, 0);                        //base case target = 0 is 0 so no need to mention again just run for loop from i = 1 till target\\n        \\n        for(int j=1; j<=n; j++)\\n        {\\n            int mini = INT_MAX;                    //copy recursive part\\n            for(int i=1; i*i<=j; i++)\\n                mini = min(mini, 1 + dp[j - i*i]);\\n            \\n            dp[j] = mini;                          //min no. of integers when target = j\\n        }\\n        return dp[n];                              //min no. of integers when target = n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int target)\\n    {\\n        if(target == 0)     //original target fulfilled, no need of any other integer now\\n            return 0;\\n        if(target < 0)      //target can\\'t be fulfilled so in min(mini, 1 + solve) we should have solve = INT_MAX - 1 so that we don\\'t consider solve way\\n            return INT_MAX - 1;\\n        \\n        int mini = INT_MAX;\\n        for(int i=1; i*i<=target; i++)                  //traverse i until (square of i) <= target as we need to subtract it from target\\n            mini = min(mini, 1 + solve(target - i*i));  // + 1 as we are taking this integer so it counts 1\\n        \\n        return mini;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        return solve(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int solve(int target)\\n    {\\n        if(target == 0)    \\n            return 0;\\n        if(target < 0)      \\n            return INT_MAX - 1;\\n        \\n        if(dp[target] != -1)\\n            return dp[target];\\n        \\n        int mini = INT_MAX;\\n        for(int i=1; i*i<=target; i++)\\n            mini = min(mini, 1 + solve(target - i*i));\\n        \\n        return dp[target] = mini;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        dp.resize(n+1, -1);\\n        return solve(n);\\n    }\\n};\\n```\n```\\n int numSquares(int n) \\n    {\\n        dp.resize(n+1, 0);                        //base case target = 0 is 0 so no need to mention again just run for loop from i = 1 till target\\n        \\n        for(int j=1; j<=n; j++)\\n        {\\n            int mini = INT_MAX;                    //copy recursive part\\n            for(int i=1; i*i<=j; i++)\\n                mini = min(mini, 1 + dp[j - i*i]);\\n            \\n            dp[j] = mini;                          //min no. of integers when target = j\\n        }\\n        return dp[n];                              //min no. of integers when target = n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162016,
                "title": "c-perfect-squares-2-solutions",
                "content": "Lagranges Theorem \\nTime Complexity: O(N^1/2)\\nFastest Approach\\n\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n     \\n        // Lagranges 3-Square Theorem\\n        // Every natural no can be represented as sum of 4 squares\\n        // So ans lies in range (1-4) -> 4 conditions\\n        // Time Complexity: O(N^1/2)\\n        \\n        // For value 1\\n        // Check if n is a perfect square\\n        \\n        int a = sqrt(n);\\n        if(a * a == n)\\n            return 1;\\n        \\n        // For value 4\\n        // Check if n is of form 4^a(8b + 7)\\n        \\n        while(n % 4 == 0)     // Removing 4^a terms\\n            n /= 4;\\n        if(n % 8 == 7)\\n            return 4;\\n        \\n        // For value 2\\n        // Break point which divides it into two perfect squares\\n        \\n        for(int i=1; i*i <= n; i++){\\n            \\n            int base = sqrt(n - i*i);   // other half\\n            if(base*base == (n - i*i))\\n                return 2;\\n        }\\n        \\n        // For value 3 (when all 3 are checked)\\n        \\n        return 3;\\n    }\\n};\\n```\\n\\n\\nDP Apporach\\nTime Complexity: O(N x N^1/2)\\n\\n\\n```\\nclass Solution{\\n\\tpublic:\\n\\tint MinSquares(int n)\\n\\t{\\n\\t    // DP Approach Tabulation Method\\n        // start from no. itself and check value at each break points\\n        // Time Complexity: O(N*N^1/2)\\n        \\n        vector<int> dp(n+1);\\n        \\n        if(n <= 3)       // Minimum Condition\\n            return n; \\n        \\n        int i = 0;\\n        while(i <= n){\\n            dp[i] = i;   // for 1^2 break points, eg: 3 = 1^2 + 1^2 + 1^2\\n            \\n            for(int j=1; j*j <= i; j++)    // for 2^2 and above break points\\n                dp[i] = min(dp[i], 1 + dp[i - j*j]);\\n            \\n            i++;\\n        }\\n         \\n        return dp[n];\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n     \\n        // Lagranges 3-Square Theorem\\n        // Every natural no can be represented as sum of 4 squares\\n        // So ans lies in range (1-4) -> 4 conditions\\n        // Time Complexity: O(N^1/2)\\n        \\n        // For value 1\\n        // Check if n is a perfect square\\n        \\n        int a = sqrt(n);\\n        if(a * a == n)\\n            return 1;\\n        \\n        // For value 4\\n        // Check if n is of form 4^a(8b + 7)\\n        \\n        while(n % 4 == 0)     // Removing 4^a terms\\n            n /= 4;\\n        if(n % 8 == 7)\\n            return 4;\\n        \\n        // For value 2\\n        // Break point which divides it into two perfect squares\\n        \\n        for(int i=1; i*i <= n; i++){\\n            \\n            int base = sqrt(n - i*i);   // other half\\n            if(base*base == (n - i*i))\\n                return 2;\\n        }\\n        \\n        // For value 3 (when all 3 are checked)\\n        \\n        return 3;\\n    }\\n};\\n```\n```\\nclass Solution{\\n\\tpublic:\\n\\tint MinSquares(int n)\\n\\t{\\n\\t    // DP Approach Tabulation Method\\n        // start from no. itself and check value at each break points\\n        // Time Complexity: O(N*N^1/2)\\n        \\n        vector<int> dp(n+1);\\n        \\n        if(n <= 3)       // Minimum Condition\\n            return n; \\n        \\n        int i = 0;\\n        while(i <= n){\\n            dp[i] = i;   // for 1^2 break points, eg: 3 = 1^2 + 1^2 + 1^2\\n            \\n            for(int j=1; j*j <= i; j++)    // for 2^2 and above break points\\n                dp[i] = min(dp[i], 1 + dp[i - j*j]);\\n            \\n            i++;\\n        }\\n         \\n        return dp[n];\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148455,
                "title": "java-recursive-memoization-tabulation-easy-to-understand-with-explanation",
                "content": "**1. Simple recursive approach. This will throw a TLE.**\\n* First store all the perfect square until n in a list.\\n* Now from the list we need to find the numbers that form a sum = n.\\n* At every index in the list, we can either pick the number or skip(notPick) the number.\\n* Also, we can only pick a number if the target(or remaining sum) is less than the number.\\n\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n <= 1)\\n            return n;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i*i <= n; i++) {\\n            list.add(i*i);\\n        }\\n        \\n        return getMinNos(list, list.size() - 1, n);\\n    }\\n    \\n    private int getMinNos(List<Integer> list, int index, int target) {\\n        if(target == 0)\\n            return 0;\\n        if(index == 0)\\n            return target; //Since we need to form the target with only the number 1 (the number at the 0th index of the list)\\n        \\n        int notPick = getMinNos(list, index-1, target);\\n        \\n        int pick = Integer.MAX_VALUE;\\n        if(target >= list.get(index))\\n            pick = 1 + getMinNos(list, index, target - list.get(index));\\n        \\n        return Math.min(notPick, pick);\\n    }\\n}\\n```\\n\\n**2. Memoized the above code**\\nIn the simple recursive approach, there are many overlapping subproblems and we\\'re solving all of them. We can use a cache to store the result of a subproblem and return it from the cache if it\\'s already solved. Since only target and index changes, I have taken a 2-D array to store the solution for each target and index combination.\\n\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n <= 1)\\n            return n;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i*i <= n; i++) {\\n            list.add(i*i);\\n        }\\n        \\n        int[][] memo = new int[list.size()][n+1];\\n        for(int i = 0; i < list.size(); i++)\\n            Arrays.fill(memo[i], -1);\\n        \\n        return getMinNos(list, list.size() - 1, n, memo);\\n    }\\n    \\n    private int getMinNos(List<Integer> list, int index, int target, int[][] memo) {\\n        if(target == 0)\\n            return 0;\\n        if(index == 0)\\n            return target;\\n        \\n        if(memo[index][target] != -1)\\n            return memo[index][target];\\n        \\n        int notPick = getMinNos(list, index-1, target, memo);\\n        \\n        int pick = Integer.MAX_VALUE;\\n        if(target >= list.get(index))\\n            pick = 1 + getMinNos(list, index, target - list.get(index), memo);\\n        \\n        memo[index][target] = Math.min(notPick, pick);\\n        return memo[index][target];\\n    }\\n}\\n```\\n\\n**3. Tabulation Method**\\nFirst store all the base cases of the above recursive code in the matrix. Now do a bottom up and calculate for each and every index, target combination.\\n\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n <= 1)\\n            return n;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i*i <= n; i++) {\\n            list.add(i*i);\\n        }\\n        \\n        int[][] memo = new int[list.size()][n+1];\\n        for(int target = 0; target <= n; target++) {\\n            memo[0][target] = target;\\n        }\\n        \\n        for(int index = 1; index < list.size(); index++) {\\n            for(int target = 1; target <= n; target++) {\\n                int notPick = memo[index-1][target];\\n                int pick = Integer.MAX_VALUE;\\n                if(target >= list.get(index))\\n                    pick = 1 + memo[index][target-list.get(index)];\\n                \\n                memo[index][target] = Math.min(pick, notPick);\\n            }\\n        }\\n        \\n        return memo[list.size()-1][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n <= 1)\\n            return n;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i*i <= n; i++) {\\n            list.add(i*i);\\n        }\\n        \\n        return getMinNos(list, list.size() - 1, n);\\n    }\\n    \\n    private int getMinNos(List<Integer> list, int index, int target) {\\n        if(target == 0)\\n            return 0;\\n        if(index == 0)\\n            return target; //Since we need to form the target with only the number 1 (the number at the 0th index of the list)\\n        \\n        int notPick = getMinNos(list, index-1, target);\\n        \\n        int pick = Integer.MAX_VALUE;\\n        if(target >= list.get(index))\\n            pick = 1 + getMinNos(list, index, target - list.get(index));\\n        \\n        return Math.min(notPick, pick);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n <= 1)\\n            return n;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i*i <= n; i++) {\\n            list.add(i*i);\\n        }\\n        \\n        int[][] memo = new int[list.size()][n+1];\\n        for(int i = 0; i < list.size(); i++)\\n            Arrays.fill(memo[i], -1);\\n        \\n        return getMinNos(list, list.size() - 1, n, memo);\\n    }\\n    \\n    private int getMinNos(List<Integer> list, int index, int target, int[][] memo) {\\n        if(target == 0)\\n            return 0;\\n        if(index == 0)\\n            return target;\\n        \\n        if(memo[index][target] != -1)\\n            return memo[index][target];\\n        \\n        int notPick = getMinNos(list, index-1, target, memo);\\n        \\n        int pick = Integer.MAX_VALUE;\\n        if(target >= list.get(index))\\n            pick = 1 + getMinNos(list, index, target - list.get(index), memo);\\n        \\n        memo[index][target] = Math.min(notPick, pick);\\n        return memo[index][target];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n <= 1)\\n            return n;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i*i <= n; i++) {\\n            list.add(i*i);\\n        }\\n        \\n        int[][] memo = new int[list.size()][n+1];\\n        for(int target = 0; target <= n; target++) {\\n            memo[0][target] = target;\\n        }\\n        \\n        for(int index = 1; index < list.size(); index++) {\\n            for(int target = 1; target <= n; target++) {\\n                int notPick = memo[index-1][target];\\n                int pick = Integer.MAX_VALUE;\\n                if(target >= list.get(index))\\n                    pick = 1 + memo[index][target-list.get(index)];\\n                \\n                memo[index][target] = Math.min(pick, notPick);\\n            }\\n        }\\n        \\n        return memo[list.size()-1][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715281,
                "title": "dp-easy-solution-c",
                "content": "# Perfect Squares\\n```\\nclass Solution {\\n\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n+1, 0);\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            int sqroot = sqrt(i);\\n            if(sqroot*sqroot==i) dp[i]=1;\\n            else\\n            {\\n                int m=INT_MAX;\\n                for(int j=sqroot; j>0; j--)\\n                    m=min(m, dp[i-j*j]);\\n                dp[i]=m+1;\\n            }           \\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n+1, 0);\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            int sqroot = sqrt(i);\\n            if(sqroot*sqroot==i) dp[i]=1;\\n            else\\n            {\\n                int m=INT_MAX;\\n                for(int j=sqroot; j>0; j--)\\n                    m=min(m, dp[i-j*j]);\\n                dp[i]=m+1;\\n            }           \\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704124,
                "title": "bfs-using-java-easy-visual-explanation",
                "content": "Key Idea with an example (below screenshot):\\n- Top-Down and Left-Right (BFS on k-ary tree) approach.\\n- Each input number `N` is considered a node, the number of children for each node = `[number of perfect squares upto N]`\\n- The children are the subtracted values from the parent. Each child\\'s value = `(parentValue - perfectSquare)`\\n- At each level, the queue holds the current level nodes. (Only unique values are pushed into the queue)\\n- From implementation perspective, you can append null at the end of every level.\\n\\t- During this course, at any point of time you find a node with value 0 - you have found the perfect sum, return the parent\\'s level (or current level based on how you implement - in my case, I update the level after parsing all the nodes of that *current* level).\\n\\t- The levels are ultimately how many numbers are involved in the perfect square sum.\\n\\t- Else at some point of time, the queue will be left with `null` after parsing through all possible unique values (`<= N`)\\n- The below screenshot is a visual representation:\\n![image](https://assets.leetcode.com/users/images/e1c87d13-98e4-4bd2-85e3-1e726a979965_1642663756.65276.png)\\n**Note:** The orange nodes indicate duplicate or negative values which are invalid. The green is the actual path that led to the required sum.\\n\\n**Time Complexity:** `O(sqrt(n) * n)`\\n**Space Complexity:** `O(k^(l-1))` (maximum number of nodes at a certain level in a queue), where  `k = sqrt(n)` and `l = level`\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int level = 1;\\n        \\n        //Perfect squares uptil n - O(sqrt(n))\\n        List<Integer> perfectSquares = new LinkedList<>();\\n        for(int num = 1; num * num <= n; ++num)\\n            perfectSquares.add(num * num);\\n        \\n        Set<Integer> visitedNumbers = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(n);\\n        queue.offer(null);\\n        \\n\\t\\t// O(sqrt(n) * n)\\n        while(queue.size() > 1) {\\n            Integer element = queue.poll();\\n            \\n            if(element != null) {\\n                for(Integer perfectSquare: perfectSquares) {\\n                    int remain = element - perfectSquare;\\n                    \\n                    if(remain < 0)\\n                        break;\\n                    else if(remain == 0)\\n                        return level;\\n                    else if(visitedNumbers.add(remain))\\n                        queue.offer(remain);\\n                }\\n            } else { // parsed all the nodes in the current level. Update the variable to current level\\n                level++;\\n                queue.offer(null);\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int level = 1;\\n        \\n        //Perfect squares uptil n - O(sqrt(n))\\n        List<Integer> perfectSquares = new LinkedList<>();\\n        for(int num = 1; num * num <= n; ++num)\\n            perfectSquares.add(num * num);\\n        \\n        Set<Integer> visitedNumbers = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(n);\\n        queue.offer(null);\\n        \\n\\t\\t// O(sqrt(n) * n)\\n        while(queue.size() > 1) {\\n            Integer element = queue.poll();\\n            \\n            if(element != null) {\\n                for(Integer perfectSquare: perfectSquares) {\\n                    int remain = element - perfectSquare;\\n                    \\n                    if(remain < 0)\\n                        break;\\n                    else if(remain == 0)\\n                        return level;\\n                    else if(visitedNumbers.add(remain))\\n                        queue.offer(remain);\\n                }\\n            } else { // parsed all the nodes in the current level. Update the variable to current level\\n                level++;\\n                queue.offer(null);\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520544,
                "title": "javascript-solution-dp",
                "content": "```\\nfunction numSquares(n) {\\n    let dp = Array(n+1).fill(Infinity);\\n    dp[0] = 0; // number of perfect square to get here;\\n    for(let g=1; g<=n; g++){\\n        for(let k=1; k*k<=g; k++){\\n            dp[g] = Math.min(dp[g], dp[g - (k*k)] + 1) \\n        }\\n    }\\n    return dp[n];\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction numSquares(n) {\\n    let dp = Array(n+1).fill(Infinity);\\n    dp[0] = 0; // number of perfect square to get here;\\n    for(let g=1; g<=n; g++){\\n        for(let k=1; k*k<=g; k++){\\n            dp[g] = Math.min(dp[g], dp[g - (k*k)] + 1) \\n        }\\n    }\\n    return dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1520487,
                "title": "easy-java-solution-dp-bfs-multiple-approaches",
                "content": "```\\n// Dynamic Programming - Bottom up\\n// Space Complexity: O(n)\\n// Time Complexity: O(n * k) where k is the number of integers whose square is less than n\\n\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[] = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        \\n        dp[0] = 0;\\n        \\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j * j <= i; j++) {\\n                dp[i] = Math.min(dp[i], 1 + dp[i - j * j]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\\n\\n**BFS**\\n\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n\\t    // Compute all the squares which is less than or equal to n\\n        List<Integer> squares = new ArrayList<>();\\n        for(int j = 1; j * j <= n; j++) {\\n            squares.add(j * j);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        Set<Integer> set = new HashSet<>();\\n        \\n        int count = 1, N = squares.size();\\n        while(queue.size() > 0) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                int num = queue.remove();\\n                for(int i = N - 1; i >= 0; i--) {\\n                    int newNum = num + squares.get(i);\\n                    if(newNum == n)\\n                        return count;\\n\\t\\t\\t\\t\\telse if(newNum > n)\\n\\t\\t\\t\\t\\t\\tcontinue;\\n                    if(!set.contains(newNum)) {\\n                        set.add(newNum);\\n                        queue.add(newNum);\\n                    }\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Dynamic Programming - Bottom up\\n// Space Complexity: O(n)\\n// Time Complexity: O(n * k) where k is the number of integers whose square is less than n\\n\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[] = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        \\n        dp[0] = 0;\\n        \\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j * j <= i; j++) {\\n                dp[i] = Math.min(dp[i], 1 + dp[i - j * j]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n\\t    // Compute all the squares which is less than or equal to n\\n        List<Integer> squares = new ArrayList<>();\\n        for(int j = 1; j * j <= n; j++) {\\n            squares.add(j * j);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        Set<Integer> set = new HashSet<>();\\n        \\n        int count = 1, N = squares.size();\\n        while(queue.size() > 0) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                int num = queue.remove();\\n                for(int i = N - 1; i >= 0; i--) {\\n                    int newNum = num + squares.get(i);\\n                    if(newNum == n)\\n                        return count;\\n\\t\\t\\t\\t\\telse if(newNum > n)\\n\\t\\t\\t\\t\\t\\tcontinue;\\n                    if(!set.contains(newNum)) {\\n                        set.add(newNum);\\n                        queue.add(newNum);\\n                    }\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343889,
                "title": "legendre-s-4-square-theorem-fastest-way-to-solve-this-o-rootn",
                "content": "If you find this helpful please upvote and like this :)\\n```\\n public int numSquares(int n) {\\n    if (isPerfectSquare(n))\\n        return 1;\\n\\n    /////// checking for possibility of 4 ---> 4^a(8b+7)///////\\n    while (n % 4 == 0) {\\n        n = n / 4;\\n    }\\n\\n    if (n % 8 == 7) {\\n        return 4;\\n    }\\n    ///////////////////////////////////////////////////////////\\n\\n    ////// possibility of 2 ---> where 2 numbers can be perfect squares///////\\n    for (int i = 1; i * i <= n; i++) {\\n        int otherHalf = n - (i * i);\\n\\n        if (isPerfectSquare(otherHalf))\\n            return 2;\\n    }\\n    /////////////////////////////////////////////////////////////////////////\\n\\n    return 3;\\n    // Since, our solution lies between 1-4, for anything else return 3\\n}\\n\\nprivate boolean isPerfectSquare(int n) {\\n    double sq = Math.sqrt(n);\\n\\n    return Math.ceil(sq) == Math.floor(sq);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int numSquares(int n) {\\n    if (isPerfectSquare(n))\\n        return 1;\\n\\n    /////// checking for possibility of 4 ---> 4^a(8b+7)///////\\n    while (n % 4 == 0) {\\n        n = n / 4;\\n    }\\n\\n    if (n % 8 == 7) {\\n        return 4;\\n    }\\n    ///////////////////////////////////////////////////////////\\n\\n    ////// possibility of 2 ---> where 2 numbers can be perfect squares///////\\n    for (int i = 1; i * i <= n; i++) {\\n        int otherHalf = n - (i * i);\\n\\n        if (isPerfectSquare(otherHalf))\\n            return 2;\\n    }\\n    /////////////////////////////////////////////////////////////////////////\\n\\n    return 3;\\n    // Since, our solution lies between 1-4, for anything else return 3\\n}\\n\\nprivate boolean isPerfectSquare(int n) {\\n    double sq = Math.sqrt(n);\\n\\n    return Math.ceil(sq) == Math.floor(sq);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1201091,
                "title": "same-as-coin-change-problem",
                "content": "The only difference is you have to build your coins array yourself and amount is given as n.\\nAfter this the whole problem is same as [https://leetcode.com/problems/coin-change/]this.\\n\\n**Here is my code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int amount) {\\n       // similiar to coin change problem\\n       // now you have to find the coins too, this is the only diff\\n       \\n       vector<int>coins;\\n       int i=1;\\n       while(i*i<=amount){\\n           coins.push_back(i*i);    // build coins array\\n           i++;\\n       }\\n        \\n        int n=coins.size();\\n        int dp[n+1][amount+1];\\n        \\n        for(int i=0;i<=n;i++) dp[i][0]=0;\\n        for(int i=1;i<=amount;i++) dp[0][i]=INT_MAX-1;\\n        \\n        for(int i=1;i<=amount;i++){\\n            if(i%coins[0]==0) dp[1][i]=(i/coins[0]);\\n            else dp[1][i]=INT_MAX-1;\\n        }\\n        \\n        for(int i=2;i<=n;i++){\\n             for(int j=1;j<=amount;j++){\\n                 if(coins[i-1]<=j) dp[i][j]=min(1+dp[i][j-coins[i-1]],dp[i-1][j]);\\n                 else dp[i][j]=dp[i-1][j];\\n             }\\n        }\\n       return dp[n][amount];\\n   }\\n};\\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int amount) {\\n       // similiar to coin change problem\\n       // now you have to find the coins too, this is the only diff\\n       \\n       vector<int>coins;\\n       int i=1;\\n       while(i*i<=amount){\\n           coins.push_back(i*i);    // build coins array\\n           i++;\\n       }\\n        \\n        int n=coins.size();\\n        int dp[n+1][amount+1];\\n        \\n        for(int i=0;i<=n;i++) dp[i][0]=0;\\n        for(int i=1;i<=amount;i++) dp[0][i]=INT_MAX-1;\\n        \\n        for(int i=1;i<=amount;i++){\\n            if(i%coins[0]==0) dp[1][i]=(i/coins[0]);\\n            else dp[1][i]=INT_MAX-1;\\n        }\\n        \\n        for(int i=2;i<=n;i++){\\n             for(int j=1;j<=amount;j++){\\n                 if(coins[i-1]<=j) dp[i][j]=min(1+dp[i][j-coins[i-1]],dp[i-1][j]);\\n                 else dp[i][j]=dp[i-1][j];\\n             }\\n        }\\n       return dp[n][amount];\\n   }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760046,
                "title": "runtime-4-ms-faster-than-96-37-of-c-online-submissions",
                "content": "\\n\\n//Legendre\\'s three-square theorem\\n//states that a natural number can be represented as the sum of three squares of integers\\n//if and only if n is not of the form {\\\\displaystyle n=4^{a}(8b+7)}n = 4^a(8b + 7) for nonnegative integers a and b.\\n//The first numbers that cannot be expressed as the sum of three squares\\n//The first numbers that cannot be expressed as the sum of three squares\\n\\n    int numSquares(int n) {\\n       if(ceil(sqrt(n)==floor(sqrt(n)))){\\n          return 1;\\n       }\\n\\t   \\n      int x=n;\\n      while(x%4==0)\\n          x/=4;\\n\\t  \\n      if(x%8==7){\\n          return 4;\\n      }\\n\\t  \\n     for(int i=1;i*i<=n;i++){\\n         int base=sqrt(n-i*i);\\n         if(base*base==(n-i*i))\\n         return 2;\\n     }\\n    return 3;\\n    }\\n\\n//https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem****\\n\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)\\n**",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\n//Legendre\\'s three-square theorem\\n//states that a natural number can be represented as the sum of three squares of integers\\n//if and only if n is not of the form {\\\\displaystyle n=4^{a}(8b+7)}n = 4^a(8b + 7) for nonnegative integers a and b.\\n//The first numbers that cannot be expressed as the sum of three squares\\n//The first numbers that cannot be expressed as the sum of three squares\\n\\n    int numSquares(int n) {\\n       if(ceil(sqrt(n)==floor(sqrt(n)))){\\n          return 1;\\n       }\\n\\t   \\n      int x=n;\\n      while(x%4==0)\\n          x/=4;\\n\\t  \\n      if(x%8==7){\\n          return 4;\\n      }\\n\\t  \\n     for(int i=1;i*i<=n;i++){\\n         int base=sqrt(n-i*i);\\n         if(base*base==(n-i*i))\\n         return 2;\\n     }\\n    return 3;\\n    }\\n\\n//https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem****\\n\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)\\n**",
                "codeTag": "Unknown"
            },
            {
                "id": 695856,
                "title": "java-recursion-memoization",
                "content": "Personally I find it easier to get  to the answer if we  can solve  it  recursively before tabulating.\\n\\n```\\nclass Solution {\\n    int[] mem;\\n    public int numSquares(int n) {\\n        mem = new int[n+1];\\n        Arrays.fill(mem, -1);\\n        \\n        return dfs(n);\\n    }\\n    \\n    int dfs(int n) {\\n        if (n < 0) return Integer.MAX_VALUE;\\n        if (n == 0) return 0;\\n        if (mem[n] != -1) return mem[n];\\n        int min = n+1;\\n        for (int i=1;i*i<=n;i++) {\\n            min = Math.min(dfs(n-(i*i)), min);\\n        }\\n        mem[n] = min+1;\\n        return min+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] mem;\\n    public int numSquares(int n) {\\n        mem = new int[n+1];\\n        Arrays.fill(mem, -1);\\n        \\n        return dfs(n);\\n    }\\n    \\n    int dfs(int n) {\\n        if (n < 0) return Integer.MAX_VALUE;\\n        if (n == 0) return 0;\\n        if (mem[n] != -1) return mem[n];\\n        int min = n+1;\\n        for (int i=1;i*i<=n;i++) {\\n            min = Math.min(dfs(n-(i*i)), min);\\n        }\\n        mem[n] = min+1;\\n        return min+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71481,
                "title": "c-6ms-static-dp",
                "content": "Non-static DP, 89ms.\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n        for(int i = 1; i <= n; i++)\\n            for(int j = 1; j * j <= i; j++)\\n                dp[i] = min(dp[i], dp[i - j * j] + 1);\\n        return dp[n];\\n    }\\n};\\n```\\n***\\nStatic DP, 6ms.\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        static vector<int>dp(1, 0);\\n        for(int i = dp.size(); i <= n; i++){\\n            dp.push_back(INT_MAX);\\n            for(int j = 1; j * j <= i; j++)\\n                dp[i] = min(dp[i], dp[i - j * j] + 1);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n        for(int i = 1; i <= n; i++)\\n            for(int j = 1; j * j <= i; j++)\\n                dp[i] = min(dp[i], dp[i - j * j] + 1);\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        static vector<int>dp(1, 0);\\n        for(int i = dp.size(); i <= n; i++){\\n            dp.push_back(INT_MAX);\\n            for(int j = 1; j * j <= i; j++)\\n                dp[i] = min(dp[i], dp[i - j * j] + 1);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71613,
                "title": "4ms-c-solution-without-dp-or-bfs",
                "content": "    class Solution {\\n        public:\\n        int numSquares(int n) {\\n            while (n % 4 == 0)    n /= 4;\\n            if (n % 8 == 7)    return 4;\\n            int m = sqrt(n);\\n            if (m * m == n)    return 1;\\n            if (n % 2 == 0)    n >>= 1;\\n            if (n % 4 == 3)    return 3;\\n            for (int i = 3; i * i < n; i += 4)\\n                if (n % i == 0) {\\n                    bool odd = true;\\n                    n /= i;\\n                    while (n % i == 0) {\\n                        odd = !odd;\\n                        n /= i;\\n                    }\\n                    if (odd)    return 3;\\n                }\\n            return 2;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n        int numSquares(int n) {\\n            while (n % 4 == 0)    n /= 4;\\n            if (n % 8 == 7)    return 4;\\n            int m = sqrt(n);\\n            if (m * m == n)    return 1;\\n            if (n % 2 == 0)    n >>= 1;\\n            if (n % 4 == 3)    return 3;\\n            for (int i = 3; i * i < n; i += 4)\\n                if (n % i == 0) {\\n                    bool odd = true;\\n                    n /= i;\\n                    while (n % i == 0) {\\n                        odd = !odd;\\n                        n /= i;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 71631,
                "title": "10-lines-c-solution-dp-with-explanation",
                "content": "class Solution {\\n\\npublic:\\n\\n    int numSquares(int n) {\\n        int dp[n+1];\\n        for(int i=0;i<=n;++i){\\n            dp[i]=i; //upper bound: sum up i 1's\\n            for(int j=1;i-j*j>=0;++j){\\n                if(dp[i-j*j]+1<dp[i]) dp[i]=dp[i-j*j]+1; //dp[i]=min(dp[i-j*j]+1 for all j from 1 to sqrt(i))\\n            }\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    int numSquares(int n) {\\n        int dp[n+1];\\n        for(int i=0;i<=n;++i){\\n            dp[i]=i; //upper bound: sum up i 1's\\n            for(int j=1;i-j*j>=0;++j){\\n                if(dp[i-j*j]+1<dp[i]) dp[i]=dp[i-j*j]+1; //dp[i]=min(dp[i-j*j]+1 for all j from 1 to sqrt(i))\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71635,
                "title": "python-common-bfs-with-fewer-lines",
                "content": "[Inspired by this][1]\\n\\n\\n  [1]: https://leetcode.com/discuss/57218/python-accepted-solution\\n\\n    def numSquares(self, n):\\n        queue = collections.deque([(0, 0)])\\n        visited = set()\\n        while queue:\\n            i, step = queue.popleft()\\n            step += 1\\n            for j in xrange(1, n + 1):\\n                k = i + j * j\\n                if k > n:\\n                    break\\n                if k == n:\\n                    return step\\n                if k not in visited:\\n                    visited.add(k)\\n                    queue.append((k, step))",
                "solutionTags": [],
                "code": "[Inspired by this][1]\\n\\n\\n  [1]: https://leetcode.com/discuss/57218/python-accepted-solution\\n\\n    def numSquares(self, n):\\n        queue = collections.deque([(0, 0)])\\n        visited = set()\\n        while queue:\\n            i, step = queue.popleft()\\n            step += 1\\n            for j in xrange(1, n + 1):\\n                k = i + j * j\\n                if k > n:\\n                    break\\n                if k == n:\\n                    return step\\n                if k not in visited:\\n                    visited.add(k)\\n                    queue.append((k, step))",
                "codeTag": "Python3"
            },
            {
                "id": 3728424,
                "title": "recursion-memoization-dp-tabulation-dp-c",
                "content": "# 1. Naive Recursive approach (TLE)\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(int i, int n){\\n        if(n==0) return 0;\\n\\n        if(i*i <= n){\\n            return min(1+helper(i, n-i*i), helper(i+1, n));\\n        }\\n        return 1e5;\\n    }\\n    int numSquares(int n) {\\n        return helper(1, n);\\n    }\\n};\\n\\n```\\n# 2. Memoization(DP)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(int i, int n, vector<int>&dp){\\n        if(n==0) return 0;\\n        if(dp[n]!=-1) return dp[n];\\n        if(i*i <= n){\\n            return dp[n]=min(1+helper(i, n-i*i, dp), helper(i+1, n, dp));\\n        }\\n        return dp[n]=1e5;\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1, -1);\\n        return helper(1, n, dp);\\n    }\\n};\\n```\\n\\n# 3. Tabulation(DP)\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n+1, 1e5);\\n        dp[0]=0;\\n        int j=1;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j*j<=i;j++){\\n                dp[i]=min(1+dp[i-j*j], dp[i]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i, int n){\\n        if(n==0) return 0;\\n\\n        if(i*i <= n){\\n            return min(1+helper(i, n-i*i), helper(i+1, n));\\n        }\\n        return 1e5;\\n    }\\n    int numSquares(int n) {\\n        return helper(1, n);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int i, int n, vector<int>&dp){\\n        if(n==0) return 0;\\n        if(dp[n]!=-1) return dp[n];\\n        if(i*i <= n){\\n            return dp[n]=min(1+helper(i, n-i*i, dp), helper(i+1, n, dp));\\n        }\\n        return dp[n]=1e5;\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1, -1);\\n        return helper(1, n, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n+1, 1e5);\\n        dp[0]=0;\\n        int j=1;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j*j<=i;j++){\\n                dp[i]=min(1+dp[i-j*j], dp[i]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839975,
                "title": "c-straightforward-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper (vector<int> &sq, int n, vector<int>&dp){\\n        if (n == 0)\\n            return 0;\\n        \\n        if (dp[n] != -1)\\n            return dp[n];        \\n        \\n        int val = INT_MAX;\\n        \\n        for (int j =0; j < sq.size (); j++){\\n            if(sq[j] > n)\\n                continue;\\n                      \\n            val = min (val,1+helper (sq,n-sq[j],dp));\\n        }\\n        \\n        return dp[n]=val;\\n    }\\n    int numSquares(int n) {\\n        vector<int> sq;\\n        \\n        int i = 1;\\n        int new_sq = 1;\\n        \\n        while (new_sq<=n){\\n            i++;\\n            sq.push_back (new_sq);\\n            new_sq = i*i;\\n        }\\n        \\n        vector<int> dp (n+1,-1);\\n        return helper (sq,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper (vector<int> &sq, int n, vector<int>&dp){\\n        if (n == 0)\\n            return 0;\\n        \\n        if (dp[n] != -1)\\n            return dp[n];        \\n        \\n        int val = INT_MAX;\\n        \\n        for (int j =0; j < sq.size (); j++){\\n            if(sq[j] > n)\\n                continue;\\n                      \\n            val = min (val,1+helper (sq,n-sq[j],dp));\\n        }\\n        \\n        return dp[n]=val;\\n    }\\n    int numSquares(int n) {\\n        vector<int> sq;\\n        \\n        int i = 1;\\n        int new_sq = 1;\\n        \\n        while (new_sq<=n){\\n            i++;\\n            sq.push_back (new_sq);\\n            new_sq = i*i;\\n        }\\n        \\n        vector<int> dp (n+1,-1);\\n        return helper (sq,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837882,
                "title": "c-solution-dynamic-programming",
                "content": "Here is the solution using dynamic programming:\\n``` C++ []\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>     dp(n + 1, (int) 1e9);\\n        int             i, j;\\n\\n        i = 0;\\n        dp[0] = 0;\\n        while (++i < n + 1)\\n        {\\n            j = 1;\\n            while (j * j < i + 1)\\n                dp[i] = min(dp[i], dp[i - j * j++] + 1);\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n\\n*Upvote if you liked it*",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>     dp(n + 1, (int) 1e9);\\n        int             i, j;\\n\\n        i = 0;\\n        dp[0] = 0;\\n        while (++i < n + 1)\\n        {\\n            j = 1;\\n            while (j * j < i + 1)\\n                dp[i] = min(dp[i], dp[i - j * j++] + 1);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520690,
                "title": "recursion-memoization-bottom-up-dp-bfs-queue",
                "content": "The intution of the problem can be derived by looking at top-down solution structure.\\n\\nStart from the given n which is the input.\\n\\n*Expectation:* To give the minimum possible count of perfect squares that sum upto n\\n\\n*Faith:* F(n)= 1 + F(n-sq) where sq is the perfect square no.\\n\\n*Base case:* Two base cases when F(N)==0 and F(N) < 0\\n\\n*Meeting Expectation with Faith:* Iterate over all possible square numbers uptil sqrt(N) and recursively find the answer result.\\n\\n\\n**Recursion + Memoization** \\n\\n```\\nint dp[10002];\\n        int solve(int n){\\n\\t\\t\\t//Base condition\\n            if(n==0){\\n                return 0;\\n            }\\n            if(n<0){\\n                return INT_MAX-1;\\n            }\\n            if(dp[n]!=-1){\\n                return dp[n];\\n            }\\n            int mx=INT_MAX;\\n            for(int i=1;i*i<=n;i++){\\n                int res=1+solve(n-(i*i));\\n                mx=min(res,mx);\\n            }\\n\\t\\t\\t//Memoization\\n            dp[n]=mx;\\n            return mx;\\n        }\\n        int numSquares(int n){\\n            memset(dp,-1,sizeof(dp));\\n            return solve(n);\\n        }\\n```\\n **Bottom-up DP**\\n```\\nint numSquares(int n){\\n\\t   int dp[10002]={0};\\n\\t   for(int i=1;i<=n;i++){\\n\\t\\t   int mn=INT_MAX;\\n\\t\\t   for(int j=1;j*j<=i;j++){\\n\\t\\t\\t   mn=min(mn,dp[i-(j*j)]);\\n\\t\\t\\t   dp[i]=1+mn;\\n\\t\\t   }\\n\\t   }\\n\\t   return dp[n];\\n   }\\n```\\n\\n**Breadth-First Search:**\\n\\nThis is the most optimal solution as we return once we encounter the base condition since we traverse breadth wise using queue.\\n\\n```\\nint numSquares(int n) {\\n\\t\\tqueue<int> q;\\n\\t\\tq.push(n);\\n\\t\\tint count=0;\\n\\t\\twhile(!q.empty()){\\n\\t\\t\\tint size=q.size();\\n\\t\\t\\twhile(size--){\\n\\t\\t\\t\\tint temp=q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tfor(int i=1;i*i<=temp;i++){\\n\\t\\t\\t\\t\\tif(temp-(i*i)>0){\\n\\t\\t\\t\\t\\t\\tq.push(temp-(i*i));\\n\\t\\t\\t\\t\\t}else if(temp-(i*i)==0){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\treturn count;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n```\\n\\n*# Please upvote the solution you found this useful. Any comments would be encouraged.*",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint dp[10002];\\n        int solve(int n){\\n\\t\\t\\t//Base condition\\n            if(n==0){\\n                return 0;\\n            }\\n            if(n<0){\\n                return INT_MAX-1;\\n            }\\n            if(dp[n]!=-1){\\n                return dp[n];\\n            }\\n            int mx=INT_MAX;\\n            for(int i=1;i*i<=n;i++){\\n                int res=1+solve(n-(i*i));\\n                mx=min(res,mx);\\n            }\\n\\t\\t\\t//Memoization\\n            dp[n]=mx;\\n            return mx;\\n        }\\n        int numSquares(int n){\\n            memset(dp,-1,sizeof(dp));\\n            return solve(n);\\n        }\\n```\n```\\nint numSquares(int n){\\n\\t   int dp[10002]={0};\\n\\t   for(int i=1;i<=n;i++){\\n\\t\\t   int mn=INT_MAX;\\n\\t\\t   for(int j=1;j*j<=i;j++){\\n\\t\\t\\t   mn=min(mn,dp[i-(j*j)]);\\n\\t\\t\\t   dp[i]=1+mn;\\n\\t\\t   }\\n\\t   }\\n\\t   return dp[n];\\n   }\\n```\n```\\nint numSquares(int n) {\\n\\t\\tqueue<int> q;\\n\\t\\tq.push(n);\\n\\t\\tint count=0;\\n\\t\\twhile(!q.empty()){\\n\\t\\t\\tint size=q.size();\\n\\t\\t\\twhile(size--){\\n\\t\\t\\t\\tint temp=q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tfor(int i=1;i*i<=temp;i++){\\n\\t\\t\\t\\t\\tif(temp-(i*i)>0){\\n\\t\\t\\t\\t\\t\\tq.push(temp-(i*i));\\n\\t\\t\\t\\t\\t}else if(temp-(i*i)==0){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\treturn count;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1520589,
                "title": "c-memoization-tabulation-o-n-sqrt-n-time-and-space-dp",
                "content": "*IT\\'S THE PROBLEM OF UNBOUNDED KNAPSACK AND IT\\'S ALMOST SIMILAR TO [MINIMUM COIN CHANGE PROBLEM](https://leetcode.com/problems/coin-change/)*.\\n\\n**RECURSIVE+MEMOIZED APPROACH -**\\n```\\nclass Solution {\\npublic: \\n    int dp[101][10001];\\n    int knapsack(int W, int n){\\n        if(W==0 || n==0)\\n            return INT_MAX;\\n        if(dp[n][W]!=-1)\\n            return dp[n][W];\\n        int ps=n*n;\\n        if(ps<=W){\\n            int temp=knapsack(W-ps, n);\\n            return dp[n][W]=min(1+(temp==INT_MAX?0:temp),knapsack(W,n-1));\\n        }\\n        else\\n            return dp[n][W]=knapsack(W,n-1);\\n    }\\n    int numSquares(int n){\\n        memset(dp, -1, sizeof(dp));\\n        return knapsack(n,(int)sqrt(n));\\n    }\\n};\\n```\\n\\n**TABULATION APPROACH -**\\n```\\nclass Solution {\\npublic: \\n    int numSquares(int n){\\n        int sq_root=(int)sqrt(n);\\n        int dp[sq_root+1][n+1];\\n        \\n        for(int i=0;i<=sq_root;i++)\\n            for(int j=0;j<=n;j++)\\n                if(i==0 || j==0)\\n                    dp[i][j]=INT_MAX;\\n        \\n        for(int i=1;i<=sq_root;i++){\\n            for(int j=1;j<=n;j++){\\n                int ps=i*i;\\n                if(ps<=j)\\n                    dp[i][j]=min(1+(dp[i][j-ps]==INT_MAX?0:dp[i][j-ps]), dp[i-1][j]);\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }       \\n        return dp[sq_root][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int dp[101][10001];\\n    int knapsack(int W, int n){\\n        if(W==0 || n==0)\\n            return INT_MAX;\\n        if(dp[n][W]!=-1)\\n            return dp[n][W];\\n        int ps=n*n;\\n        if(ps<=W){\\n            int temp=knapsack(W-ps, n);\\n            return dp[n][W]=min(1+(temp==INT_MAX?0:temp),knapsack(W,n-1));\\n        }\\n        else\\n            return dp[n][W]=knapsack(W,n-1);\\n    }\\n    int numSquares(int n){\\n        memset(dp, -1, sizeof(dp));\\n        return knapsack(n,(int)sqrt(n));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic: \\n    int numSquares(int n){\\n        int sq_root=(int)sqrt(n);\\n        int dp[sq_root+1][n+1];\\n        \\n        for(int i=0;i<=sq_root;i++)\\n            for(int j=0;j<=n;j++)\\n                if(i==0 || j==0)\\n                    dp[i][j]=INT_MAX;\\n        \\n        for(int i=1;i<=sq_root;i++){\\n            for(int j=1;j<=n;j++){\\n                int ps=i*i;\\n                if(ps<=j)\\n                    dp[i][j]=min(1+(dp[i][j-ps]==INT_MAX?0:dp[i][j-ps]), dp[i-1][j]);\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }       \\n        return dp[sq_root][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147600,
                "title": "c-recursion-memonization-bottom-up-solutions-with-explanation",
                "content": "```\\n    /*\\n     * TopDown Approach or Recursive Solution\\n     *\\n     * There will be n subproblems for each problem i.e.., for each remainder amount, each\\n     * perfect square will be substracted and it goes on until the remainder is 0 or 1 or 2\\n     * or 3, the loop can be run till i * i <= n\\n     * Eg:\\n     *  1 -> 1^2 => only one perfect square is needed in order to make the sum 1\\n     *  2 -> 1^2 + 1^2  => only 2 perfect squares are needed in order to make the sum 2\\n     *  3 -> 1^2 + 1^2 + 1^2 => only 3 perfect squares are needed to make the sum 3\\n     *\\n     * Eg: n = 12, we can see that i can only go from 1 ... 3, bcz 4*4 > 12, no need to check\\n     *             for it\\n     *                                        12\\n     *                                        |\\n     *                       ------------------------------------\\n     *                      |                  |                 |\\n     *                  11(12-1^2)        8(12-2^2)           3(12-3^2)\\n     *                     |\\n     *             -------------------------\\n     *            |           |             |\\n     *        10(11-1^2)   7(11-2^2)      2(11-3^2)\\n     *\\n     * From above it is clear that for each iteration, there will n loop where n is no of\\n     * numbers where i * i < n\\n     *\\n     *    for (int i = 1; i * i < n; i++) {\\n     *       minNumber = min(minNumber, 1+ numSquares(n - i*i));\\n     *    }\\n     *\\n     * Base cases:\\n     * If n is <= 3 then we have solution for that problem, return n\\n     *\\n     */\\n    int numSquares(int n) {\\n        // Check if n is lessthan or equal to 3\\n        if (n <= 3) {\\n            return n;\\n        }\\n\\n        // Value to store the result. As min value is needed, intialize with INT_MAX\\n        int minNo = INT_MAX;\\n\\n        // Loop for all elements whose squares are less than n\\n        for (int i = 1; i * i <= n; i++) {\\n            minNo = min(minNo, 1 + numSquares(n - i * i));\\n        }\\n\\n        return minNo;\\n    }\\n\\t/*\\n     * TopDown with Memonization\\n     *\\n     * As there are many duplicate subproblems and the solution to the problem can be\\n     * achieved if we have the solution to subproblems, dynamic programming can be\\n     * applied where intermediate solutions for the subproblems are stored in a map.\\n     * map points to num of perfect squares required that sum to n\\n    */\\n    std::vector<int> mp;\\n    int numSquares_memo(int n) {\\n        // Check if n is lessthan or equal to 3\\n        if (n <= 3) {\\n            return n;\\n        }\\n\\n        // check if this subproblem is already evaluated\\n        if (mp[n] != -1) {\\n            // Subproblem is already evaluated, return the solution of it\\n            return mp[n];\\n        }\\n\\n        // Value to store the result. As min value is needed, intialize with INT_MAX\\n        int minNo = INT_MAX;\\n\\n        // Loop for all elements whose squares are less than n\\n        for (int i = 1; i * i <= n; i++) {\\n            minNo = min(minNo, 1 + numSquares_memo(n - i * i));\\n        }\\n\\n        // store the value in dp and return\\n        return mp[n] = minNo;\\n    }\\n\\n    int numSquares(int n) {\\n        // resize the vector to size n +1, +1 is for index 0 with default value of\\n        // -1\\n        mp.resize(n+1, -1);\\n\\n        return numSquares_memo(n);\\n    }\\n    /*\\n     * PerfectSquare BottomUp solution\\n     * Since there are many overlapping subproblems in Recursive solution, and the Solution for the\\n     * main problem can ba attained if we have solutions of suproblems, Dynamic Programming can be\\n     * applied.\\n     * Dynamic Programming Bottom up solution, conditions are similar to recursive but the intemediate\\n     * results are stored in a dp table. Bottom up is to find bottom solutions first to yield the top \\n     * solution i.e.., solution of the problem\\n     *\\n     * The Dp table is of lenght amount + 1 where +1 is for to have the case when n is zero, and each\\n     * index i hods the min number of perfect squares that sum to i\\n      *\\n     * As the min no of perfect squares required to make up the remainder amount, initialize the dp\\n     * array with a maximum value i.e.., INT_MAX or n + 1\\n     *\\n     * Eg: n = 12;\\n     *   Loop for each value of i ranges from 4 ... n\\n     *    Loop for each value of j ranges from 1 to j*j <= i\\n     *       dp[i] = std::min (dp[i] - dp[j*j] + 1) only when i >= coins[j]\\n\\n     * Base cases:\\n     * When n is <=3\\n     */\\n    int numSquares(int n) {\\n        if (n <= 3) {\\n            return n;\\n        }\\n        \\n        // dp array to store the intermediate solutions\\n        vector<int> dp(n + 1, INT_MAX);\\n\\n        // Base cases\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 3;\\n\\n        for (int i = 4; i <= n; i++) {\\n            for (int j = 1; j * j <= i; j++) {\\n                dp[i] = min(dp[i], 1 + dp[i - j * j]);\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\t\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * TopDown Approach or Recursive Solution\\n     *\\n     * There will be n subproblems for each problem i.e.., for each remainder amount, each\\n     * perfect square will be substracted and it goes on until the remainder is 0 or 1 or 2\\n     * or 3, the loop can be run till i * i <= n\\n     * Eg:\\n     *  1 -> 1^2 => only one perfect square is needed in order to make the sum 1\\n     *  2 -> 1^2 + 1^2  => only 2 perfect squares are needed in order to make the sum 2\\n     *  3 -> 1^2 + 1^2 + 1^2 => only 3 perfect squares are needed to make the sum 3\\n     *\\n     * Eg: n = 12, we can see that i can only go from 1 ... 3, bcz 4*4 > 12, no need to check\\n     *             for it\\n     *                                        12\\n     *                                        |\\n     *                       ------------------------------------\\n     *                      |                  |                 |\\n     *                  11(12-1^2)        8(12-2^2)           3(12-3^2)\\n     *                     |\\n     *             -------------------------\\n     *            |           |             |\\n     *        10(11-1^2)   7(11-2^2)      2(11-3^2)\\n     *\\n     * From above it is clear that for each iteration, there will n loop where n is no of\\n     * numbers where i * i < n\\n     *\\n     *    for (int i = 1; i * i < n; i++) {\\n     *       minNumber = min(minNumber, 1+ numSquares(n - i*i));\\n     *    }\\n     *\\n     * Base cases:\\n     * If n is <= 3 then we have solution for that problem, return n\\n     *\\n     */\\n    int numSquares(int n) {\\n        // Check if n is lessthan or equal to 3\\n        if (n <= 3) {\\n            return n;\\n        }\\n\\n        // Value to store the result. As min value is needed, intialize with INT_MAX\\n        int minNo = INT_MAX;\\n\\n        // Loop for all elements whose squares are less than n\\n        for (int i = 1; i * i <= n; i++) {\\n            minNo = min(minNo, 1 + numSquares(n - i * i));\\n        }\\n\\n        return minNo;\\n    }\\n\\t/*\\n     * TopDown with Memonization\\n     *\\n     * As there are many duplicate subproblems and the solution to the problem can be\\n     * achieved if we have the solution to subproblems, dynamic programming can be\\n     * applied where intermediate solutions for the subproblems are stored in a map.\\n     * map points to num of perfect squares required that sum to n\\n    */\\n    std::vector<int> mp;\\n    int numSquares_memo(int n) {\\n        // Check if n is lessthan or equal to 3\\n        if (n <= 3) {\\n            return n;\\n        }\\n\\n        // check if this subproblem is already evaluated\\n        if (mp[n] != -1) {\\n            // Subproblem is already evaluated, return the solution of it\\n            return mp[n];\\n        }\\n\\n        // Value to store the result. As min value is needed, intialize with INT_MAX\\n        int minNo = INT_MAX;\\n\\n        // Loop for all elements whose squares are less than n\\n        for (int i = 1; i * i <= n; i++) {\\n            minNo = min(minNo, 1 + numSquares_memo(n - i * i));\\n        }\\n\\n        // store the value in dp and return\\n        return mp[n] = minNo;\\n    }\\n\\n    int numSquares(int n) {\\n        // resize the vector to size n +1, +1 is for index 0 with default value of\\n        // -1\\n        mp.resize(n+1, -1);\\n\\n        return numSquares_memo(n);\\n    }\\n    /*\\n     * PerfectSquare BottomUp solution\\n     * Since there are many overlapping subproblems in Recursive solution, and the Solution for the\\n     * main problem can ba attained if we have solutions of suproblems, Dynamic Programming can be\\n     * applied.\\n     * Dynamic Programming Bottom up solution, conditions are similar to recursive but the intemediate\\n     * results are stored in a dp table. Bottom up is to find bottom solutions first to yield the top \\n     * solution i.e.., solution of the problem\\n     *\\n     * The Dp table is of lenght amount + 1 where +1 is for to have the case when n is zero, and each\\n     * index i hods the min number of perfect squares that sum to i\\n      *\\n     * As the min no of perfect squares required to make up the remainder amount, initialize the dp\\n     * array with a maximum value i.e.., INT_MAX or n + 1\\n     *\\n     * Eg: n = 12;\\n     *   Loop for each value of i ranges from 4 ... n\\n     *    Loop for each value of j ranges from 1 to j*j <= i\\n     *       dp[i] = std::min (dp[i] - dp[j*j] + 1) only when i >= coins[j]\\n\\n     * Base cases:\\n     * When n is <=3\\n     */\\n    int numSquares(int n) {\\n        if (n <= 3) {\\n            return n;\\n        }\\n        \\n        // dp array to store the intermediate solutions\\n        vector<int> dp(n + 1, INT_MAX);\\n\\n        // Base cases\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 3;\\n\\n        for (int i = 4; i <= n; i++) {\\n            for (int j = 1; j * j <= i; j++) {\\n                dp[i] = min(dp[i], 1 + dp[i - j * j]);\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 805994,
                "title": "4-approaches-java",
                "content": "\\n**Recursion -**\\n(Time limit exceeded)\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<=3){\\n            return n;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 1; i*i<=n; i++){\\n            min = Math.min(min, numSquares(n-i*i)+1);\\n        }\\n        return min;\\n    }\\n}\\n```\\n\\n**Recursion using Memoization -** \\n(An array can also be used instead of hashmap)\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        return find(n, map);\\n    }\\n    public int find(int n, HashMap<Integer, Integer> map){\\n        if(n<=3){\\n            return n;\\n        }\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 1; i*i<=n; i++){\\n            min = Math.min(min, find(n-i*i,map)+1);\\n        }\\n        map.put(n,min);\\n        return min;\\n    }\\n}\\n```\\n\\n**Dynamic Programming -**\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<=3)\\n            return n;\\n        //int sq_root = Math.sqrt(n);\\n        int[] dp = new int[n+1];\\n        for(int i = 1; i<=n; i++){\\n            dp[i] = Integer.MAX_VALUE;\\n            for(int j=1; j*j<=i; j++){\\n                dp[i] = Math.min(dp[i],dp[i-j*j]+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n\\n**Lagrange\\'s four-square theorem**\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<=3)\\n            return n;\\n        while(n%4==0){\\n            n/=4;\\n        }\\n        if(n%8==7){\\n            return 4;\\n        }\\n        int sq_root = (int)Math.sqrt(n);\\n        if(sq_root*sq_root==n){\\n            return 1;\\n        }\\n        for(int i = 1; i*i<=n; i++){\\n            sq_root=(int)Math.sqrt(n-i*i);\\n            if(sq_root*sq_root==(n-i*i)){\\n                return 2;\\n            }\\n        }\\n        return 3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<=3){\\n            return n;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 1; i*i<=n; i++){\\n            min = Math.min(min, numSquares(n-i*i)+1);\\n        }\\n        return min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        return find(n, map);\\n    }\\n    public int find(int n, HashMap<Integer, Integer> map){\\n        if(n<=3){\\n            return n;\\n        }\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 1; i*i<=n; i++){\\n            min = Math.min(min, find(n-i*i,map)+1);\\n        }\\n        map.put(n,min);\\n        return min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<=3)\\n            return n;\\n        //int sq_root = Math.sqrt(n);\\n        int[] dp = new int[n+1];\\n        for(int i = 1; i<=n; i++){\\n            dp[i] = Integer.MAX_VALUE;\\n            for(int j=1; j*j<=i; j++){\\n                dp[i] = Math.min(dp[i],dp[i-j*j]+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<=3)\\n            return n;\\n        while(n%4==0){\\n            n/=4;\\n        }\\n        if(n%8==7){\\n            return 4;\\n        }\\n        int sq_root = (int)Math.sqrt(n);\\n        if(sq_root*sq_root==n){\\n            return 1;\\n        }\\n        for(int i = 1; i*i<=n; i++){\\n            sq_root=(int)Math.sqrt(n-i*i);\\n            if(sq_root*sq_root==(n-i*i)){\\n                return 2;\\n            }\\n        }\\n        return 3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796164,
                "title": "java-simple-dp-solution-similar-to-coin-change-problem-o-n",
                "content": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int[] squares = getPerfectSquares(n);        \\n        \\n        int[] dp = new int[n+1];\\n        for(int i = 1; i <= n; i++) {\\n            dp[i] = n + 1;\\n            for(int square : squares) {\\n                if(square <= i) {\\n                    dp[i] = Math.min(dp[i], dp[i - square] + 1);\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n    \\n    int[] getPerfectSquares(int n) {\\n        int totalSquares = (int) Math.sqrt(n);\\n        int[] squares = new int[totalSquares];\\n        \\n        for(int i = 1; i <= totalSquares; i++) {\\n            squares[i-1] = i * i;\\n        }\\n        \\n        return squares;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int[] squares = getPerfectSquares(n);        \\n        \\n        int[] dp = new int[n+1];\\n        for(int i = 1; i <= n; i++) {\\n            dp[i] = n + 1;\\n            for(int square : squares) {\\n                if(square <= i) {\\n                    dp[i] = Math.min(dp[i], dp[i - square] + 1);\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n    \\n    int[] getPerfectSquares(int n) {\\n        int totalSquares = (int) Math.sqrt(n);\\n        int[] squares = new int[totalSquares];\\n        \\n        for(int i = 1; i <= totalSquares; i++) {\\n            squares[i-1] = i * i;\\n        }\\n        \\n        return squares;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709099,
                "title": "java-dp-solution-o-nsqrt-n-easy",
                "content": "<hr>\\n\\n***upvote if you like the solution***\\n<hr>\\n\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<4)\\n            return n;\\n        int dp[] = new int[n+1];\\n        \\n        for(int i=1;i<=n;i++){\\n            dp[i]=i;\\n            for(int j=1;j*j<=i;j++){\\n                dp[i]=Math.min(dp[i],dp[i-j*j]+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<4)\\n            return n;\\n        int dp[] = new int[n+1];\\n        \\n        for(int i=1;i<=n;i++){\\n            dp[i]=i;\\n            for(int j=1;j*j<=i;j++){\\n                dp[i]=Math.min(dp[i],dp[i-j*j]+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 622567,
                "title": "python-sol-by-math-90-w-comment",
                "content": "Python sol by math. ( [Lagrange\\'s four-square theorem](https://www.alpertron.com.ar/4SQUARES.HTM) )\\n\\n---\\n\\n**Implementation** by math:\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        \\n        while( n % 4 == 0 ):\\n            # Reduction by factor of 4\\n            n //= 4\\n            \\n        if n % 8 == 7:\\n            # Quick response for n = 8k + 7\\n            return 4\\n        \\n        # Check whether n = a^2 + b^2\\n        for a in range( int(sqrt(n))+1 ):\\n            \\n            b = int( sqrt( n - a*a ) )\\n            \\n            if ( a**2 + b ** 2 ) == n :\\n                return (a>0) + (b>0)\\n            \\n        # n = a^2 + b^2 + c^2\\n        return 3\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Lagrange\\'s four-square theorem](https://en.wikipedia.org/wiki/Lagrange\\'s_four-square_theorem)\\n\\n[2] [Proof of four-square theorem by Dario Alpern\\'s Web site](https://www.alpertron.com.ar/ENGLISH.HTM)\\n\\n[3] [Proof of four-square theorem by PlanetMath](https://planetmath.org/proofoflagrangesfoursquaretheorem)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        \\n        while( n % 4 == 0 ):\\n            # Reduction by factor of 4\\n            n //= 4\\n            \\n        if n % 8 == 7:\\n            # Quick response for n = 8k + 7\\n            return 4\\n        \\n        # Check whether n = a^2 + b^2\\n        for a in range( int(sqrt(n))+1 ):\\n            \\n            b = int( sqrt( n - a*a ) )\\n            \\n            if ( a**2 + b ** 2 ) == n :\\n                return (a>0) + (b>0)\\n            \\n        # n = a^2 + b^2 + c^2\\n        return 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346249,
                "title": "simple-javascript-dp-solution",
                "content": "```\\nvar numSquares = function(n) {\\n    let arr = new Array(n + 1).fill(0);\\n    arr[1] = 1;\\n    for(let sqr = 1; sqr * sqr <= n; sqr++) {\\n        for(let i = sqr * sqr; i < arr.length; i++) {\\n            if(arr[i] == 0) {\\n                arr[i] = arr[i - (sqr * sqr)] + 1;\\n            } else {\\n                arr[i] = Math.min(arr[i - (sqr * sqr)] + 1, arr[i]);\\n            }\\n        }\\n    }\\n    return arr[n];\\n};\\n```\\n\\n# Idea to Approach\\nThe first I did was that I had to visual what the solutions would have been from something as small `1` and onwards:\\n\\n`1` --> `1 (1)`\\n`2` --> `2 (1 + 1)`\\n`3` --> `3 (1 + 1 + 1)`\\n`4` --> `1 (4)`\\n`5` --> `2 (4 + 1)`\\n\\nLooking at this pattern, I knew this was a dynamic programming question because all we had to do was look at the previous one and add one.\\n\\nI know that the outer loop has to be such that `sqr * sqr` has to be less than or equal to `n`. We can\\'t make a sum where `sqr * sqr` is greater than `n`.\\n\\nSo with the first iteration where `sqr = 1`, we have the following array for `n`:\\n\\n`[0, 1, 2, 3, 4, 5, 6, 7, ... , n]`\\n\\nNext, we move onto `sqr = 2` where `sqr * sqr = 2 * 2 = 4`.\\n\\nWe noticed that everything that could use a `4` can also use a `1`, so we see which is smaller: `Math.min(arr[i - (sqr * sqr)] + 1, arr[i])`. This basically says, is the current amount that is in the array smaller if I simply added `1` or would it be smaller if I kept it the way it is. This example becomes apparent when `n = 12` where you have a choice between `12 = 9 + 1 + 1 + 1` or `12 = 4 + 4 + 4`. \\n\\nWe do this and we should return `arr[n]`.\\n\\nTime Complexity: `O(sqrt(n) * n)`\\nSpace Complexity: `O(n)`.",
                "solutionTags": [],
                "code": "```\\nvar numSquares = function(n) {\\n    let arr = new Array(n + 1).fill(0);\\n    arr[1] = 1;\\n    for(let sqr = 1; sqr * sqr <= n; sqr++) {\\n        for(let i = sqr * sqr; i < arr.length; i++) {\\n            if(arr[i] == 0) {\\n                arr[i] = arr[i - (sqr * sqr)] + 1;\\n            } else {\\n                arr[i] = Math.min(arr[i - (sqr * sqr)] + 1, arr[i]);\\n            }\\n        }\\n    }\\n    return arr[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165688,
                "title": "bfs-and-dp",
                "content": "* **BFS**\\nThe least number of perfect square numbers which sum to n can be regarded as the **Shortest-path** problem.\\n\\n```\\n    public int numSquares(int n) {\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        int count = 0;\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n\\t\\t\\t\\t\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int sz = 0; sz < size; sz++) {\\n                int cur = queue.poll();\\n                if (cur > n) {\\n                    continue;\\n                }\\n                if (cur == n) {\\n                    return count;\\n                }\\n                for (int i = 1; cur + i * i <= n; i++) {\\n                    if (visited.contains(cur + i * i)) {\\n                        continue;\\n                    }\\n                    queue.add(cur + i * i);\\n                    visited.add(cur + i * i);\\n                }\\n            }\\n            count++;\\n        }\\n\\n        return -1;\\n    }\\n```\\n\\n* **DP**\\n**state definition**\\nperfect square numbers sum\\n**state function**\\n\\t\\t`state[i]`, min number of perfect square numbers sum to i\\n**goal state**\\n\\t\\tstate[n]\\n**base case**\\n\\t\\tstate[0] = 0\\n**state transition**\\n\\t\\t`min(state[i - j * j] + 1) = state[i]`\\n**filling direction** \\n\\t\\ti, j increasing\\n\\n```\\n    public int numSquares01(int n) {\\n\\n        int[] state = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            state[i] = i;\\n            for (int j = 1; j <= i; j++) {\\n                if (j * j > i) {\\n                    break;\\n                }\\n                state[i] = Math.min(state[i - j * j] + 1, state[i]);\\n            }\\n        }\\n\\n        return state[n];\\n    }\\n```\\nThanks for **VOTE UP** (\\u02CAo\\u0334\\u0336\\u0337\\u0324\\u2304o\\u0334\\u0336\\u0337\\u0324\\u02CB) ",
                "solutionTags": [],
                "code": "```\\n    public int numSquares(int n) {\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        int count = 0;\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n\\t\\t\\t\\t\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int sz = 0; sz < size; sz++) {\\n                int cur = queue.poll();\\n                if (cur > n) {\\n                    continue;\\n                }\\n                if (cur == n) {\\n                    return count;\\n                }\\n                for (int i = 1; cur + i * i <= n; i++) {\\n                    if (visited.contains(cur + i * i)) {\\n                        continue;\\n                    }\\n                    queue.add(cur + i * i);\\n                    visited.add(cur + i * i);\\n                }\\n            }\\n            count++;\\n        }\\n\\n        return -1;\\n    }\\n```\n```\\n    public int numSquares01(int n) {\\n\\n        int[] state = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            state[i] = i;\\n            for (int j = 1; j <= i; j++) {\\n                if (j * j > i) {\\n                    break;\\n                }\\n                state[i] = Math.min(state[i - j * j] + 1, state[i]);\\n            }\\n        }\\n\\n        return state[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71500,
                "title": "simple-python-dp-solution",
                "content": "\\n    def numSquares(self, n):\\n  \\n        dp = [float(\"inf\") for i in range(n+1)]\\n        dp[1] = 1\\n        perfect = [1]\\n        for i in range(2,n+1) :\\n            if not i**0.5 - int(i**0.5) :\\n                dp[i] = 1\\n                perfect.append(i)\\n            else :            \\n                for j in perfect :\\n                    dp[i] = min(dp[i], dp[i-j] + 1)\\n        return dp[-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\n    def numSquares(self, n):\\n  \\n        dp = [float(\"inf\") for i in range(n+1)]\\n        dp[1] = 1\\n        perfect = [1]\\n        for i in range(2,n+1) :\\n            if not i**0.5 - int(i**0.5) :\\n                dp[i] = 1\\n                perfect.append(i)\\n            else :            \\n                for j in perfect :\\n                    dp[i] = min(dp[i], dp[i-j] + 1)\\n        return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 3824644,
                "title": "c-beginner-friendly-rec-memo-tabulation",
                "content": "\\n# Recursive Approach\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        return helper(1, n);\\n    }\\n\\n    int helper(int i, int tar) {\\n        if (tar == 0) return 0;\\n\\n        if (tar < (i * i)) return 1e8;\\n\\n        int a = helper(i + 1, tar);\\n\\n        int b = 1e9;\\n\\n        if ((i * i) <= tar) {\\n            b = 1 + helper(i, tar - (i * i));\\n        }\\n\\n        return min(a, b);\\n    }\\n};\\n\\n```\\n\\n# Memoization Approach\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> memo(n + 1, -1);\\n        return helper(n, memo);\\n    }\\n\\n    int helper(int tar, vector<int>& memo) {\\n        if (tar == 0) return 0;\\n\\n        if (memo[tar] != -1) return memo[tar];\\n\\n        int res = 1e9;\\n        for (int i = 1; i * i <= tar; ++i) {\\n            res = min(res, 1 + helper(tar - i * i, memo));\\n        }\\n\\n        return memo[tar] = res;\\n    }\\n};\\n\\n```\\n\\n\\n# Tabulation Approach\\n\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j * j <= i; ++j) {\\n                dp[i] = min(dp[i], 1 + dp[i - j * j]);\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        return helper(1, n);\\n    }\\n\\n    int helper(int i, int tar) {\\n        if (tar == 0) return 0;\\n\\n        if (tar < (i * i)) return 1e8;\\n\\n        int a = helper(i + 1, tar);\\n\\n        int b = 1e9;\\n\\n        if ((i * i) <= tar) {\\n            b = 1 + helper(i, tar - (i * i));\\n        }\\n\\n        return min(a, b);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> memo(n + 1, -1);\\n        return helper(n, memo);\\n    }\\n\\n    int helper(int tar, vector<int>& memo) {\\n        if (tar == 0) return 0;\\n\\n        if (memo[tar] != -1) return memo[tar];\\n\\n        int res = 1e9;\\n        for (int i = 1; i * i <= tar; ++i) {\\n            res = min(res, 1 + helper(tar - i * i, memo));\\n        }\\n\\n        return memo[tar] = res;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j * j <= i; ++j) {\\n                dp[i] = min(dp[i], 1 + dp[i - j * j]);\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745996,
                "title": "recursive-approach-dp-c",
                "content": "Using a ```for``` loop, iterate over all the perfect squares which are less than or equal to ```n```\\n![image](https://assets.leetcode.com/users/images/8f16bf4f-9db0-4bed-bc50-3e5cd6bcf028_1689001268.4572203.jpeg)\\n\\nRecursive solution\\n```\\nclass Solution {\\n    int solve(int n){\\n        if(n == 0){\\n            return 0;\\n        }\\n        \\n        int ans = 1e9;\\n        \\n        for(int i = 1; i*i <= n; i++){\\n            ans = min(ans, 1 + solve(n - i*i));\\n        }\\n        \\n        return ans;\\n    }\\npublic:\\n    int numSquares(int n) {\\n        return solve(n);\\n    }\\n};\\n```\\n\\n\\nOptimization using Dynamic Programming, Tabulation\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 0;\\n        \\n        for(int i = 1; i<=n; i++){\\n            int ans = 1e9;\\n            for(int j = 1; j*j <= i; j++){\\n                ans = min(ans, 1 + dp[i - j*j]);\\n            }\\n            \\n            dp[i] = ans;\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```for```\n```n```\n```\\nclass Solution {\\n    int solve(int n){\\n        if(n == 0){\\n            return 0;\\n        }\\n        \\n        int ans = 1e9;\\n        \\n        for(int i = 1; i*i <= n; i++){\\n            ans = min(ans, 1 + solve(n - i*i));\\n        }\\n        \\n        return ans;\\n    }\\npublic:\\n    int numSquares(int n) {\\n        return solve(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 0;\\n        \\n        for(int i = 1; i<=n; i++){\\n            int ans = 1e9;\\n            for(int j = 1; j*j <= i; j++){\\n                ans = min(ans, 1 + dp[i - j*j]);\\n            }\\n            \\n            dp[i] = ans;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692440,
                "title": "easy-solution-1d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to check for every n - t (where t is every square less than n) for minimum . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a vector to store the minimum number of squares to every number \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp; int ml = -1; \\n    int numSquares(int n) {\\n        if(n == 0) return 0; \\n        if(ml == -1){\\n            vector<int> temp(n+1, -1); \\n            dp = temp; ml++; \\n        }\\n\\n        int temp = 1; int count = INT_MAX; \\n        while(temp* temp <= n){\\n            if(dp[n - temp*temp] == -1) dp[n - temp*temp] = numSquares(n - temp*temp) ; \\n            int t = dp[ n - temp*temp]; \\n            if(count > t + 1) count = t+1; temp++; \\n        }\\n\\n        if(count == INT_MAX) return 0 ;\\n        return count; \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp; int ml = -1; \\n    int numSquares(int n) {\\n        if(n == 0) return 0; \\n        if(ml == -1){\\n            vector<int> temp(n+1, -1); \\n            dp = temp; ml++; \\n        }\\n\\n        int temp = 1; int count = INT_MAX; \\n        while(temp* temp <= n){\\n            if(dp[n - temp*temp] == -1) dp[n - temp*temp] = numSquares(n - temp*temp) ; \\n            int t = dp[ n - temp*temp]; \\n            if(count > t + 1) count = t+1; temp++; \\n        }\\n\\n        if(count == INT_MAX) return 0 ;\\n        return count; \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108298,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(int i,int n,vector<int>&v,vector<vector<int>>&dp){\\n        if(i==0){\\n            if(n%v[0]==0) return n/v[0];\\n            else return 1e9;\\n        }\\n        if(dp[i][n]!=-1) return dp[i][n];\\n        int nt=0+f(i-1,n,v,dp);\\n        int tt=1e9;\\n        if(v[i]<=n){\\n            tt=1+f(i,n-v[i],v,dp);\\n        }\\n        return dp[i][n]=min(nt,tt);\\n    }\\n    int numSquares(int n) {\\n        \\n        vector<int>v;\\n        for(int i=1;i<=100;i++){\\n            v.push_back(i*i);\\n        }\\n        vector<vector<int>>dp(v.size(),vector<int>(n+1,-1));\\n        return f(99,n,v,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(int i,int n,vector<int>&v,vector<vector<int>>&dp){\\n        if(i==0){\\n            if(n%v[0]==0) return n/v[0];\\n            else return 1e9;\\n        }\\n        if(dp[i][n]!=-1) return dp[i][n];\\n        int nt=0+f(i-1,n,v,dp);\\n        int tt=1e9;\\n        if(v[i]<=n){\\n            tt=1+f(i,n-v[i],v,dp);\\n        }\\n        return dp[i][n]=min(nt,tt);\\n    }\\n    int numSquares(int n) {\\n        \\n        vector<int>v;\\n        for(int i=1;i<=100;i++){\\n            v.push_back(i*i);\\n        }\\n        vector<vector<int>>dp(v.size(),vector<int>(n+1,-1));\\n        return f(99,n,v,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937660,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n         vector<int> dp(n+1,INT_MAX);\\n        //base case\\n        dp[0]=0;\\n        int count = 1;\\n        while(count*count <= n)\\n        {\\n            int sq = count*count;\\n            for(int i = sq; i < n+1; i++) {\\n                dp[i] = min(dp[i-sq] + 1,dp[i]);\\n        }\\n        count++;\\n    }\\n    return dp[n];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n         vector<int> dp(n+1,INT_MAX);\\n        //base case\\n        dp[0]=0;\\n        int count = 1;\\n        while(count*count <= n)\\n        {\\n            int sq = count*count;\\n            for(int i = sq; i < n+1; i++) {\\n                dp[i] = min(dp[i-sq] + 1,dp[i]);\\n        }\\n        count++;\\n    }\\n    return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838509,
                "title": "c-clean-code-recursion-memoization-tabulation-easy-dp-approach-self-explanatory",
                "content": "**Upvote If It Helps**\\n\\n*Ask me in comments if you have any doubts*\\n\\n**Recursion Approach**\\n\\n*Getting TLE \\u26A0\\uFE0F\\u26A0\\uFE0F*\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(int i){\\n        if(i==0) return 0;\\n        int minCnt=INT_MAX;\\n        for(int num=1;num<=sqrt(i);++num){\\n            int curCnt=1+helper(i-(num*num));\\n            minCnt=min(curCnt,minCnt);\\n        }\\n        return minCnt;\\n    }\\n    \\n    int numSquares(int n) {\\n        return helper(n);\\n    }\\n};\\n```\\n\\n**Memoization Approach**\\n\\n*Accepted \\u2705\\u2705*\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(int i,vector<int>&dp){\\n        if(i==0) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int minCnt=INT_MAX;\\n        for(int num=1;num<=sqrt(i);++num){\\n            int curCnt=1+helper(i-(num*num),dp);\\n            minCnt=min(curCnt,minCnt);\\n        }\\n        return dp[i]=minCnt;\\n    }\\n    \\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        return helper(n,dp);\\n    }\\n};\\n```\\n\\n**Tabulation Approach**\\n\\n*Accepted \\u2705\\u2705*\\n\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        for(int nums=1;nums<=n;++nums){\\n            int minCnt = INT_MAX;\\n            for (int num = 1; num <= sqrt(nums); num++)\\n            {\\n                int curCnt = 1 + dp[nums - (num*num)];\\n                minCnt = min(minCnt, curCnt);\\n            }\\n            dp[nums] = minCnt;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i){\\n        if(i==0) return 0;\\n        int minCnt=INT_MAX;\\n        for(int num=1;num<=sqrt(i);++num){\\n            int curCnt=1+helper(i-(num*num));\\n            minCnt=min(curCnt,minCnt);\\n        }\\n        return minCnt;\\n    }\\n    \\n    int numSquares(int n) {\\n        return helper(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int i,vector<int>&dp){\\n        if(i==0) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int minCnt=INT_MAX;\\n        for(int num=1;num<=sqrt(i);++num){\\n            int curCnt=1+helper(i-(num*num),dp);\\n            minCnt=min(curCnt,minCnt);\\n        }\\n        return dp[i]=minCnt;\\n    }\\n    \\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        return helper(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        for(int nums=1;nums<=n;++nums){\\n            int minCnt = INT_MAX;\\n            for (int num = 1; num <= sqrt(nums); num++)\\n            {\\n                int curCnt = 1 + dp[nums - (num*num)];\\n                minCnt = min(minCnt, curCnt);\\n            }\\n            dp[nums] = minCnt;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838341,
                "title": "c-recursion-dp-comments-added",
                "content": "**\\u2705Please Upvote, If It Helps**\\n\\n**Approach 1 : USING RECURSION (TLE)**\\n\\n```\\nclass Solution {\\npublic:\\n    int find(int n)\\n    {\\n        // out of bound \\n        if(n==0) return 0;\\n        \\n        // trying to substract all possible perfect squares and take min one\\n        int mn = INT_MAX;\\n        for(int i=1;i<=sqrt(n);i++)\\n        {\\n            int curr = i*i;                      // current perfect square\\n            int steps = 1 + find(n-curr);       // substract curr square and go for next one\\n            \\n            mn = min(mn,steps);\\n        }\\n        \\n        return mn;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        return find(n);\\n    }\\n};\\n```\\n\\n\\n\\n**Approach 2 : DP (MEMOIZATION)**\\n\\n```\\nclass Solution {\\npublic:\\n    int find(int n,vector<int>& dp)\\n    {\\n        // out of bound \\n        if(n==0) return 0;\\n        \\n        if(dp[n]!=-1) return dp[n];\\n        \\n        // trying to substract all possible perfect squares and take min one\\n        int mn = INT_MAX;\\n        \\n        for(int i=1;i<=sqrt(n);i++)               // go till square root of n because if we substract bigger value from n then it will become minus so don\\'t do that\\n        {\\n            int curr = i*i;                      // current perfect square\\n            int steps = 1 + find(n-curr,dp);       // substract curr square and go for next one\\n            \\n            mn = min(mn,steps);\\n        }\\n        \\n        return dp[n] = mn;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        vector<int> dp(n+1,-1);\\n        return find(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int n)\\n    {\\n        // out of bound \\n        if(n==0) return 0;\\n        \\n        // trying to substract all possible perfect squares and take min one\\n        int mn = INT_MAX;\\n        for(int i=1;i<=sqrt(n);i++)\\n        {\\n            int curr = i*i;                      // current perfect square\\n            int steps = 1 + find(n-curr);       // substract curr square and go for next one\\n            \\n            mn = min(mn,steps);\\n        }\\n        \\n        return mn;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        return find(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int find(int n,vector<int>& dp)\\n    {\\n        // out of bound \\n        if(n==0) return 0;\\n        \\n        if(dp[n]!=-1) return dp[n];\\n        \\n        // trying to substract all possible perfect squares and take min one\\n        int mn = INT_MAX;\\n        \\n        for(int i=1;i<=sqrt(n);i++)               // go till square root of n because if we substract bigger value from n then it will become minus so don\\'t do that\\n        {\\n            int curr = i*i;                      // current perfect square\\n            int steps = 1 + find(n-curr,dp);       // substract curr square and go for next one\\n            \\n            mn = min(mn,steps);\\n        }\\n        \\n        return dp[n] = mn;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        vector<int> dp(n+1,-1);\\n        return find(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838107,
                "title": "c-solution-dp",
                "content": "```\\npublic int NumSquares(int n) {\\n    int[] dp = new int[n + 1];\\n    for (int i = 1; i <= n; i++)\\n    {\\n        dp[i] = i;\\n        for (int j = 1; j * j <= i; j++)\\n        {\\n            dp[i] = Math.Min(dp[i], dp[i - j * j] + 1);\\n        }\\n    }\\n    return dp[n];\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int NumSquares(int n) {\\n    int[] dp = new int[n + 1];\\n    for (int i = 1; i <= n; i++)\\n    {\\n        dp[i] = i;\\n        for (int j = 1; j * j <= i; j++)\\n        {\\n            dp[i] = Math.Min(dp[i], dp[i - j * j] + 1);\\n        }\\n    }\\n    return dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2837942,
                "title": "c-very-easy-bfs-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        queue<int>q;\\n        unordered_set<int>seen;\\n        for(int i = 1;i * i <= n;i++){\\n            q.push(i * i);\\n            seen.insert(i * i);\\n        }\\n        int res = 1;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                int cur = q.front();\\n                q.pop();\\n                if(cur == n){\\n                    return res;\\n                }\\n                for(int i = 1;i * i <= n;i++){\\n                    int newCur = cur + i * i;\\n                    if(newCur <= n and seen.find(newCur) == seen.end()){\\n                        q.push(newCur);\\n                        seen.insert(newCur);\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        queue<int>q;\\n        unordered_set<int>seen;\\n        for(int i = 1;i * i <= n;i++){\\n            q.push(i * i);\\n            seen.insert(i * i);\\n        }\\n        int res = 1;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                int cur = q.front();\\n                q.pop();\\n                if(cur == n){\\n                    return res;\\n                }\\n                for(int i = 1;i * i <= n;i++){\\n                    int newCur = cur + i * i;\\n                    if(newCur <= n and seen.find(newCur) == seen.end()){\\n                        q.push(newCur);\\n                        seen.insert(newCur);\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837850,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "Solution:\\n```\\nclass Solution {\\n    func numSquares(_ n: Int) -> Int {\\n        var dp = Array(0...n)\\n        \\n        for i in 1...n {\\n            var j = 1\\n            \\n            while j * j <= i {\\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\\n                j += 1\\n            }\\n        }\\n        \\n        return dp[n]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    func numSquares(_ n: Int) -> Int {\\n        var dp = Array(0...n)\\n        \\n        for i in 1...n {\\n            var j = 1\\n            \\n            while j * j <= i {\\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\\n                j += 1\\n            }\\n        }\\n        \\n        return dp[n]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837555,
                "title": "daily-leetcoding-challenge-november-day-22",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/perfect-squares/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute-force Enumeration [Time Limit Exceeded]\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Greedy Enumeration\n\n  \n**Approach 4:** Greedy + BFS (Breadth-First Search)\n\n  \n**Approach 5:** Mathematics \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/perfect-squares/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 4:** Greedy + BFS (Breadth-First Search)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2713405,
                "title": "python-js-java-c-by-dp-coin-change-demo-visualization",
                "content": "[My tutorial of DP problem solving framework to Perfect Square [ English ]](https://medium.com/@cutesciuridae/dive-into-dp-take-perfect-squares-for-example-9f2cade1aa0d)\\n\\n[Tutorial video in Chinese \\u4E2D\\u6587\\u89E3\\u984C\\u5F71\\u7247](https://youtu.be/fg8EpbagC6Y)\\n\\n---\\n\\n**Hint**:\\n\\nThis is a variant of [Coin Change (Leetcode #322 )](https://leetcode.com/problems/coin-change/)\\n\\n**Absact transform model**\\n\\n**Coins** = {1, 4, 9, 16, 25, ..., closet square number up to n }\\n\\n**Value** = n, which is given from input\\n\\nSo, **minimal decomposition of n by square number** \\n<=> **minimal number of coin change to n by speical coins**, \\nmade up by a sequence of square number 1 , 4 , 9 ....\\n\\n---\\n\\nObserve the decomposition and derive DP state transfer function as below\\n\\n```\\nBase case:\\n\\nDP[ 0 ] = 0 \\n\\n0 cannot decomposed by positive perfect square\\n```\\n\\n```\\nGeneral case:\\n\\nDP[ i ] = min( DP[ i] , DP[ i - square number] + 1 )\\nwhere square number = 1, 4, 9, 16, 25, ... and so on\\n```\\n\\n\\n**Demo & Visualization**\\n\\n<img src=\"https://i.imgur.com/ezIjSuf.png\">\\n\\n---\\n\\n**Implementation** by Python\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        \\n        INF = sys.maxsize\\n        dp = [ INF for _ in range(n+1) ]\\n        dp[0] = 0\\n        \\n        root = 1\\n        square = root*root\\n        \\n        # for each square number 1, 4, 9, 16, 25...\\n        while( square <= n ) :\\n            \\n            # update dp value for number from square to n\\n            for i in range(square, n+1) :\\n                \\n                dp[i] = min( dp[i], dp[i-square]+1 )\\n            \\n            # go to next square number\\n            root += 1\\n            square = root*root\\n        \\n        \\n        return dp[n]\\n```\\n\\n---\\n\\n**Implementation** by Javascript\\n\\n```\\nvar numSquares = function(n) {\\n    \\n    // Initialize with INT_MAX, except for dp[0] = 0 as base case\\n    let dp = new Array( n+1 ).fill( Number.MAX_SAFE_INTEGER );\\n        \\n    // Base case\\n    dp[0] = 0;\\n    \\n\\n    let root = 1;\\n    let square = root * root;\\n\\n    // for each square 1, 4, 9, 16, 25...\\n    while( square <= n ){\\n\\n        //  update dp value for number from square to n\\n        for( let i = square ; i <= n ; i++ ){\\n\\n            dp[ i ] = Math.min( dp[ i ], dp[ i - square ] + 1 );\\n        }\\n\\n        // go to next square number\\n        root ++;\\n        square = root * root;\\n    }\\n\\n    return dp[n];        \\n};\\n```\\n\\n---\\n\\n**Implementation** by Java\\n\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        \\n        \\n        int[] dp = new int[n+1];\\n        \\n        // Initialize with INT_MAX, except for dp[0] = 0 as base case\\n        for( int i = 1 ; i < dp.length; i++){\\n            dp[ i ] = Integer.MAX_VALUE;\\n        }\\n\\n        // Base case\\n        dp[0] = 0;\\n        \\n        int root = 1;\\n        int square = root * root;\\n        \\n        // for each square 1, 4, 9, 16, 25...\\n        while( square <= n ){\\n            \\n            //  update dp value for number from square to n\\n            for( int i = square ; i <= n ; i++ ){\\n                \\n                dp[ i ] = Math.min( dp[ i ], dp[ i - square ] + 1 );\\n            }\\n            \\n            // go to next square number\\n            root ++;\\n            square = root * root;\\n        }\\n        \\n        return dp[n];        \\n    }\\n}\\n```\\n\\n---\\n\\n**Implementation** by C++\\n\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        vector< int > dp = vector< int > (n+1, INT_MAX );\\n        \\n        // Base case\\n        dp[0] = 0;\\n        \\n        int root = 1;\\n        int square = root * root;\\n        \\n        // for each square 1, 4, 9, 16, 25...\\n        while( square <= n ){\\n            \\n            //  update dp value for number from square to n\\n            for( int i = square ; i <= n ; i++ ){\\n                \\n                dp[ i ] = min( dp[ i ], dp[ i - square ] + 1 );\\n            }\\n            \\n            // go to next square number\\n            root ++;\\n            square = root * root;\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n\\n---\\n\\nShare top-down DP solution\\n\\nPython\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\n        coins = [x**2 for x in range(1, 101) ]\\n\\n        dp = {0:0 }\\n        def coinChange( i ):\\n\\n            if i in dp:\\n                return dp[i]\\n            \\n            best = float(\\'inf\\')\\n            for coin in coins:\\n                if coin > i: break\\n                best = min(best, coinChange(i - coin) + 1 )\\n\\n            dp[i] = best\\n            return dp[i]\\n        \\n        # ------------------------------\\n        return coinChange(n)\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nBase case:\\n\\nDP[ 0 ] = 0 \\n\\n0 cannot decomposed by positive perfect square\\n```\n```\\nGeneral case:\\n\\nDP[ i ] = min( DP[ i] , DP[ i - square number] + 1 )\\nwhere square number = 1, 4, 9, 16, 25, ... and so on\\n```\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        \\n        INF = sys.maxsize\\n        dp = [ INF for _ in range(n+1) ]\\n        dp[0] = 0\\n        \\n        root = 1\\n        square = root*root\\n        \\n        # for each square number 1, 4, 9, 16, 25...\\n        while( square <= n ) :\\n            \\n            # update dp value for number from square to n\\n            for i in range(square, n+1) :\\n                \\n                dp[i] = min( dp[i], dp[i-square]+1 )\\n            \\n            # go to next square number\\n            root += 1\\n            square = root*root\\n        \\n        \\n        return dp[n]\\n```\n```\\nvar numSquares = function(n) {\\n    \\n    // Initialize with INT_MAX, except for dp[0] = 0 as base case\\n    let dp = new Array( n+1 ).fill( Number.MAX_SAFE_INTEGER );\\n        \\n    // Base case\\n    dp[0] = 0;\\n    \\n\\n    let root = 1;\\n    let square = root * root;\\n\\n    // for each square 1, 4, 9, 16, 25...\\n    while( square <= n ){\\n\\n        //  update dp value for number from square to n\\n        for( let i = square ; i <= n ; i++ ){\\n\\n            dp[ i ] = Math.min( dp[ i ], dp[ i - square ] + 1 );\\n        }\\n\\n        // go to next square number\\n        root ++;\\n        square = root * root;\\n    }\\n\\n    return dp[n];        \\n};\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        \\n        \\n        int[] dp = new int[n+1];\\n        \\n        // Initialize with INT_MAX, except for dp[0] = 0 as base case\\n        for( int i = 1 ; i < dp.length; i++){\\n            dp[ i ] = Integer.MAX_VALUE;\\n        }\\n\\n        // Base case\\n        dp[0] = 0;\\n        \\n        int root = 1;\\n        int square = root * root;\\n        \\n        // for each square 1, 4, 9, 16, 25...\\n        while( square <= n ){\\n            \\n            //  update dp value for number from square to n\\n            for( int i = square ; i <= n ; i++ ){\\n                \\n                dp[ i ] = Math.min( dp[ i ], dp[ i - square ] + 1 );\\n            }\\n            \\n            // go to next square number\\n            root ++;\\n            square = root * root;\\n        }\\n        \\n        return dp[n];        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        vector< int > dp = vector< int > (n+1, INT_MAX );\\n        \\n        // Base case\\n        dp[0] = 0;\\n        \\n        int root = 1;\\n        int square = root * root;\\n        \\n        // for each square 1, 4, 9, 16, 25...\\n        while( square <= n ){\\n            \\n            //  update dp value for number from square to n\\n            for( int i = square ; i <= n ; i++ ){\\n                \\n                dp[ i ] = min( dp[ i ], dp[ i - square ] + 1 );\\n            }\\n            \\n            // go to next square number\\n            root ++;\\n            square = root * root;\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\n        coins = [x**2 for x in range(1, 101) ]\\n\\n        dp = {0:0 }\\n        def coinChange( i ):\\n\\n            if i in dp:\\n                return dp[i]\\n            \\n            best = float(\\'inf\\')\\n            for coin in coins:\\n                if coin > i: break\\n                best = min(best, coinChange(i - coin) + 1 )\\n\\n            dp[i] = best\\n            return dp[i]\\n        \\n        # ------------------------------\\n        return coinChange(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623357,
                "title": "c-recursion-rec-memo-bottom-up-approach",
                "content": "**Recursion**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n<0)return INT_MAX-1;\\n        \\n        int mini=INT_MAX;\\n        \\n        for(int i=1;i*i<=n;i++){\\n           mini=min(mini,solve(n-(i*i))+1) ;\\n        }\\n        \\n        return mini;\\n    }\\n    \\n    int numSquares(int n) {        \\n        return solve(n);\\n    }\\n};\\n```\\n\\n**REC+MEMO**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,unordered_map<int,int>& dp){\\n        if(dp.find(n)!=dp.end())return dp[n];\\n        if(n<0)return dp[n]=INT_MAX-1;\\n        \\n        int mini=INT_MAX;\\n        \\n        for(int i=1;i*i<=n;i++){\\n           mini=min(mini,solve(n-(i*i),dp)+1) ;\\n        }\\n        \\n        return dp[n]=mini;\\n    }\\n    \\n    int numSquares(int n) {      \\n        unordered_map<int,int> dp;\\n        dp[0]=0;\\n        return solve(n,dp);\\n    }\\n};\\n```\\n\\n**Bottom up approach**\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {      \\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j*j<=n;j++){\\n                int temp=j*j;\\n                if(i-temp>=0)\\n                    dp[i]=min(dp[i],dp[i-temp]+1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n<0)return INT_MAX-1;\\n        \\n        int mini=INT_MAX;\\n        \\n        for(int i=1;i*i<=n;i++){\\n           mini=min(mini,solve(n-(i*i))+1) ;\\n        }\\n        \\n        return mini;\\n    }\\n    \\n    int numSquares(int n) {        \\n        return solve(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int n,unordered_map<int,int>& dp){\\n        if(dp.find(n)!=dp.end())return dp[n];\\n        if(n<0)return dp[n]=INT_MAX-1;\\n        \\n        int mini=INT_MAX;\\n        \\n        for(int i=1;i*i<=n;i++){\\n           mini=min(mini,solve(n-(i*i),dp)+1) ;\\n        }\\n        \\n        return dp[n]=mini;\\n    }\\n    \\n    int numSquares(int n) {      \\n        unordered_map<int,int> dp;\\n        dp[0]=0;\\n        return solve(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {      \\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j*j<=n;j++){\\n                int temp=j*j;\\n                if(i-temp>=0)\\n                    dp[i]=min(dp[i],dp[i-temp]+1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491871,
                "title": "python-elegant-short-three-lines-91-28-faster-top-down-dp-lru-cache",
                "content": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n*\\u221An)\\n\\t\\tMemory: O(log(n))\\n\\t\\t\"\"\"\\n\\n\\t\\tdef numSquares(self, n: int) -> int:\\n\\t\\t\\treturn self._decompose(n)\\n\\n\\t\\t@classmethod\\n\\t\\t@lru_cache(None)\\n\\t\\tdef _decompose(cls, n: int) -> int:\\n\\t\\t\\tif n < 2:\\n\\t\\t\\t\\treturn n\\n\\t\\t\\treturn 1 + min(cls._decompose(n - i * i) for i in range(1, isqrt(n) + 1))\\n\\n![image](https://assets.leetcode.com/users/images/55de7265-4db5-446a-8645-e70955d9850f_1661630018.4927058.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n*\\u221An)\\n\\t\\tMemory: O(log(n))\\n\\t\\t\"\"\"\\n\\n\\t\\tdef numSquares(self, n: int) -> int:\\n\\t\\t\\treturn self._decompose(n)\\n\\n\\t\\t@classmethod\\n\\t\\t@lru_cache(None)\\n\\t\\tdef _decompose(cls, n: int) -> int:\\n\\t\\t\\tif n < 2:\\n\\t\\t\\t\\treturn n\\n\\t\\t\\treturn 1 + min(cls._decompose(n - i * i) for i in range(1, isqrt(n) + 1))\\n\\n![image](https://assets.leetcode.com/users/images/55de7265-4db5-446a-8645-e70955d9850f_1661630018.4927058.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2281800,
                "title": "3-simple-c-solution",
                "content": "# Recursion\\n\\tclass Solution {\\n    int rec(int n)\\n    {\\n        if(n==0)\\n            return 0;\\n        \\n        int ans=n;\\n        \\n        for(int i=1;i*i<=n;++i)\\n            ans=min(ans,1+rec(n-i*i));\\n        return ans;\\n    }\\n\\tpublic:\\n    int numSquares(int n)\\n    {\\n        return rec(n);        \\n    }\\n};\\n\\n# memomization\\n\\t\\n\\tclass Solution {\\n    int rec(int n,vector<int>&dp)\\n    {\\n        if(n==0)\\n            return 0;\\n        \\n        int &ans=dp[n];\\n        \\n        if(ans!=-1)\\n            return ans;\\n        \\n        ans=INT_MAX;\\n        \\n        for(int i=1;i*i<=n;++i)\\n            ans=min(ans,1+rec(n-i*i,dp));\\n        return ans;\\n    }\\n\\tpublic:\\n    int numSquares(int n)\\n    {\\n        vector<int>dp(n+1,-1);\\n        return rec(n,dp);        \\n    }\\n\\t};\\n# tabulation\\n\\n\\n    int numSquares(int n)\\n    {\\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        for(int i=1;i<=n;++i)\\n        {\\n            for(int j=1;j*j<=n;++j)\\n            {\\n                if(i>=j*j)\\n                    dp[i]=min(dp[i],1+dp[i-(j*j)]);\\n            }\\n        }\\n        return dp[n];        \\n    }\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    int rec(int n)\\n    {\\n        if(n==0)\\n            return 0;\\n        \\n        int ans=n;\\n        \\n        for(int i=1;i*i<=n;++i)\\n            ans=min(ans,1+rec(n-i*i));\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2031998,
                "title": "java-dp-vs-bfs-easy-to-understand",
                "content": "##### DP\\nGiven `dp[i]` is number of squares for `i`,\\nWe find that `dp[i] = min(dp[i - sq])` where sq = j * j and j <= i\\n\\n- time: `O(n^(3/2))`\\n- space: `O(n)`\\n```java\\npublic int numSquares(int n) {\\n    int[] dp = new int[n + 1];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    dp[0] = 0;\\n\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j * j <= i; j++) {\\n            int sq = j * j;\\n            dp[i] = Math.min(dp[i], dp[i - sq] + 1);\\n        }\\n    }\\n    return dp[n];\\n}\\n```\\n\\n##### BFS\\n\\nStart with `0` as the root\\nGo through every valid branch  `num`, where num = square + parent <= n , square = i * i\\n\\nPrune:\\n1. prune the num already visited\\n2. prune the num > n\\n\\nGiven n = 12, the tree looks like this:\\n```\\n                     0\\n       /         /      \\\\        \\\\\\n      1\\t       2         4         9  \\n   /     \\\\    /   \\\\        \\\\\\n  2 3 5 10    6 11          8 \\n                    ...\\n```\\n\\n\\n- time: `O(n^(h/2))`, where `h` is the max number of recursion, `n^(1/2)` is the branch\\n- space: `O(n^(1/2))`, where `n^(1/2)` is the size of square numbers\\n```java\\npublic int numSquares(int n) {\\n    boolean[] visited = new boolean[n + 1];\\n    Queue<Integer> queue = new LinkedList<>();\\n    int count = 0;\\n\\n    queue.add(0);\\n\\n    while (!queue.isEmpty()) {\\n        Queue<Integer> temp = new LinkedList<>();\\n        while (!queue.isEmpty()) {\\n            int cur = queue.remove();\\n            if (cur == n) return count;\\n            for (int i = 1; cur + i * i <= n; i++) {\\n                int next = cur + i * i;\\n                if (!visited[next]) temp.add(next);\\n                visited[next] = true;\\n            }\\n        }\\n        queue = temp;\\n        count++;\\n    }\\n    return -1;\\n}\\n```\\n\\nPlease let me know if the explanation is helpful to you, thanks :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```java\\npublic int numSquares(int n) {\\n    int[] dp = new int[n + 1];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    dp[0] = 0;\\n\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j * j <= i; j++) {\\n            int sq = j * j;\\n            dp[i] = Math.min(dp[i], dp[i - sq] + 1);\\n        }\\n    }\\n    return dp[n];\\n}\\n```\n```\\n                     0\\n       /         /      \\\\        \\\\\\n      1\\t       2         4         9  \\n   /     \\\\    /   \\\\        \\\\\\n  2 3 5 10    6 11          8 \\n                    ...\\n```\n```java\\npublic int numSquares(int n) {\\n    boolean[] visited = new boolean[n + 1];\\n    Queue<Integer> queue = new LinkedList<>();\\n    int count = 0;\\n\\n    queue.add(0);\\n\\n    while (!queue.isEmpty()) {\\n        Queue<Integer> temp = new LinkedList<>();\\n        while (!queue.isEmpty()) {\\n            int cur = queue.remove();\\n            if (cur == n) return count;\\n            for (int i = 1; cur + i * i <= n; i++) {\\n                int next = cur + i * i;\\n                if (!visited[next]) temp.add(next);\\n                visited[next] = true;\\n            }\\n        }\\n        queue = temp;\\n        count++;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1520694,
                "title": "legendre-s-theorem-solution-0-ms-faster-than-100-00",
                "content": "According to Legendre\\'s theorem, every natural number ```n``` can be represented as the sum of 3 squares of integer.\\nIf and only if ```n``` is not of the form ``4``<sup>``a``</sup>``(8b + 7)`` where ```a and b``` are nonnegative integers.\\n\\n```\\nint numSquares(int n)\\n    {\\n        if (ceil(sqrt(n))==floor(sqrt(n)))\\n            return 1;\\n        \\n        while (n%4==0)\\n            n/=4;\\n        if (n%8==7)\\n            return 4;\\n        \\n        for (int i=1;i*i<=n;i++)\\n        {\\n            int x=sqrt(n-(i*i));\\n            if ((x*x)==n-(i*i))\\n                return 2;\\n        }\\n        return 3;\\n    }\\n```\\n\\n```Time complexity :``` **O(sqrt(n))**\\n```Space complexity :``` **O(1)**",
                "solutionTags": [],
                "code": "```n```\n```n```\n```a and b```\n```\\nint numSquares(int n)\\n    {\\n        if (ceil(sqrt(n))==floor(sqrt(n)))\\n            return 1;\\n        \\n        while (n%4==0)\\n            n/=4;\\n        if (n%8==7)\\n            return 4;\\n        \\n        for (int i=1;i*i<=n;i++)\\n        {\\n            int x=sqrt(n-(i*i));\\n            if ((x*x)==n-(i*i))\\n                return 2;\\n        }\\n        return 3;\\n    }\\n```\n```Time complexity :```\n```Space complexity :```",
                "codeTag": "Unknown"
            },
            {
                "id": 1385923,
                "title": "faster-easy",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) \\n    {\\n        vector<int> dp(n + 1);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        for(int i = 2 ; i <= n ; i++)\\n        {\\n            int mi = INT_MAX;\\n            for(int j = 1 ; j*j <= i ; j++)\\n            {\\n                int rem = i - j*j;\\n                if(dp[rem] < mi)\\n                {\\n                    mi = dp[rem];\\n                }\\n            }\\n            dp[i] = mi + 1;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) \\n    {\\n        vector<int> dp(n + 1);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        for(int i = 2 ; i <= n ; i++)\\n        {\\n            int mi = INT_MAX;\\n            for(int j = 1 ; j*j <= i ; j++)\\n            {\\n                int rem = i - j*j;\\n                if(dp[rem] < mi)\\n                {\\n                    mi = dp[rem];\\n                }\\n            }\\n            dp[i] = mi + 1;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069536,
                "title": "fastest-unique-method-using-python3",
                "content": "https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem\\nn = 4^a(8b + 7) for nonnegative integers a and b.\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        if(isqrt(n) ** 2 == n):    # if its a perfect squre check\\n            return 1\\n        while( n % 4 ==0):  #Check if number is of the form 4^a(8b + 7) \\n            n /= 4        \\n        if(n %8 ==7): # check the 7 now\\n            return 4\\n        \\n        i=1\\n\\t\\t#Now just chekc for 2 if not 2 return 3\\n\\t\\t# now will find a break point which square is n- i*i\\n        while(i*i <=n):   \\n            b = int(sqrt(n - i*i))\\n            if(b*b == (n - i*i)):\\n                return 2\\n            i += 1\\n        return 3\\n        \\n   \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        if(isqrt(n) ** 2 == n):    # if its a perfect squre check\\n            return 1\\n        while( n % 4 ==0):  #Check if number is of the form 4^a(8b + 7) \\n            n /= 4        \\n        if(n %8 ==7): # check the 7 now\\n            return 4\\n        \\n        i=1\\n\\t\\t#Now just chekc for 2 if not 2 return 3\\n\\t\\t# now will find a break point which square is n- i*i\\n        while(i*i <=n):   \\n            b = int(sqrt(n - i*i))\\n            if(b*b == (n - i*i)):\\n                return 2\\n            i += 1\\n        return 3\\n        \\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 892547,
                "title": "four-squares-theorem-python3",
                "content": "According to FOUR SQUARES THEOREM, any positive number can be expressed as a sum of 4 numbers including 0, so the answer is in 0,1,2,3,4. And when n % 8 = 7, the answer is 4.\\nWhen there exist a and b such that a^2 + b^2 = n, the answer is 1 or 2.\\nIn other cases, the answer is 3.\\nActually the answer can NOT be 0 since n is a positive number.\\nCode in PYTHON3:\\n\\n```\\n    def numSquares(self, n: int) -> int:\\n        while n % 4 == 0:\\n            n /= 4\\n        if n % 8 == 7:\\n            return 4\\n        a = 0\\n        while a**2 <= n:\\n            b = int((n-a**2)**0.5)\\n            if a**2 + b**2 == n:\\n                return bool(a) + bool(b)\\n            a += 1\\n        return 3\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def numSquares(self, n: int) -> int:\\n        while n % 4 == 0:\\n            n /= 4\\n        if n % 8 == 7:\\n            return 4\\n        a = 0\\n        while a**2 <= n:\\n            b = int((n-a**2)**0.5)\\n            if a**2 + b**2 == n:\\n                return bool(a) + bool(b)\\n            a += 1\\n        return 3\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 843569,
                "title": "c-dp-solution-same-coin-change-problem",
                "content": "**Keeping the perfect squares in an array, intuition of coin change problem**\\n\\n```\\nRuntime: 280 ms, faster than 40.15% of C++ online submissions for Perfect Squares.\\nMemory Usage: 6.2 MB, less than 82.07% of C++ online submissions for Perfect Squares.\\n\\n\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        if(n==0)return 0;\\n        int sqrt_n = sqrt(n);\\n        int perfectSquares[sqrt_n];\\n        for(int i=1;i<=sqrt_n;i++)\\n        {\\n            perfectSquares[i-1] = i*i;\\n        }\\n        \\n        int dp[n+1];\\n        dp[0] = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = INT_MAX;\\n            for(int s : perfectSquares)\\n            {\\n                if(i-s<0)break;\\n                \\n                dp[i] = min(dp[i],dp[i-s]+1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n.\\n\\n**Not keeping the perfect squares in an array, simplification of above approach**\\n\\n.\\n```\\nRuntime: 220 ms, faster than 56.93% of C++ online submissions for Perfect Squares.\\nMemory Usage: 6 MB, less than 92.56% of C++ online submissions for Perfect Squares.\\n\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        if(n==0)return 0;\\n        \\n        int dp[n+1];\\n        dp[0] = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = INT_MAX;\\n            for(int j=1;j*j<=i;j++)\\n            {\\n                dp[i] = min(dp[i],dp[i-j*j]+1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nRuntime: 280 ms, faster than 40.15% of C++ online submissions for Perfect Squares.\\nMemory Usage: 6.2 MB, less than 82.07% of C++ online submissions for Perfect Squares.\\n\\n\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        if(n==0)return 0;\\n        int sqrt_n = sqrt(n);\\n        int perfectSquares[sqrt_n];\\n        for(int i=1;i<=sqrt_n;i++)\\n        {\\n            perfectSquares[i-1] = i*i;\\n        }\\n        \\n        int dp[n+1];\\n        dp[0] = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = INT_MAX;\\n            for(int s : perfectSquares)\\n            {\\n                if(i-s<0)break;\\n                \\n                dp[i] = min(dp[i],dp[i-s]+1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\n```\\nRuntime: 220 ms, faster than 56.93% of C++ online submissions for Perfect Squares.\\nMemory Usage: 6 MB, less than 92.56% of C++ online submissions for Perfect Squares.\\n\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        if(n==0)return 0;\\n        \\n        int dp[n+1];\\n        dp[0] = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = INT_MAX;\\n            for(int j=1;j*j<=i;j++)\\n            {\\n                dp[i] = min(dp[i],dp[i-j*j]+1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707771,
                "title": "c-simple-dynamic-programming-solution",
                "content": "```csharp\\npublic int NumSquares(int n) \\n{\\n\\tint[] d = new int[n + 1];\\n\\n\\tfor(int i = 1; i <= n; i++)\\n\\t{\\n\\t\\td[i] = int.MaxValue;\\n\\n\\t\\tfor(int j = 1; j * j <= i; j++)\\n\\t\\t{\\n\\t\\t\\td[i] = Math.Min(d[i], d[i - j * j] + 1);\\n\\t\\t}            \\n\\t}\\n\\n\\treturn d[n];\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```csharp\\npublic int NumSquares(int n) \\n{\\n\\tint[] d = new int[n + 1];\\n\\n\\tfor(int i = 1; i <= n; i++)\\n\\t{\\n\\t\\td[i] = int.MaxValue;\\n\\n\\t\\tfor(int j = 1; j * j <= i; j++)\\n\\t\\t{\\n\\t\\t\\td[i] = Math.Min(d[i], d[i - j * j] + 1);\\n\\t\\t}            \\n\\t}\\n\\n\\treturn d[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 571528,
                "title": "c-fast-20ms-90-faster-solution-memoization-easy-to-understand-well-commented-solution",
                "content": "To understand concept of my code lets take an example of 12.\\nI will search for nearest square less than 12. Here it is 3^2=9. Let num=3=sqrt(n)\\nNow my value of num will chage from num to num/2, which can only give best answer.(its an observation)\\nLogic behind this is smaller values than num/2 can be used in next function call.\\n\\nI am writing cases on how function call will happen:-\\n3^2+1^2+1^2+1^2 \\n2^2+2^2+2^2    \\nans=3 steps\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int minSteps(int n,int* memo){\\n        //Base Case\\n        if(n==0)\\n            return 0;\\n        \\n        if(memo[n]!=-1)return memo[n];\\n        //I will search for closest square to n\\n        int num=sqrt(n);\\n        int ans=INT_MAX;\\n        //I observed for minimum steps our num varies from sqrt(n) to sqrt(n)/2\\n        //As we can use numbers below sqrt(n)/2 in next function call\\n        while(num>=sqrt(n)/2){\\n            int op=minSteps(n-num*num,memo);\\n            ans=min(ans,op);\\n            if(op<=1)break; //If our op<=1 that will be always our minimum, we can observe that\\n            num--;\\n        }\\n        memo[n]=1+ans;\\n        return 1+ans;\\n    }\\n    int numSquares(int n) {\\n        int* memo=new int[n+1];\\n        for(int i=0;i<=n;i++){\\n            memo[i]=-1;\\n        }\\n        return minSteps(n,memo);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minSteps(int n,int* memo){\\n        //Base Case\\n        if(n==0)\\n            return 0;\\n        \\n        if(memo[n]!=-1)return memo[n];\\n        //I will search for closest square to n\\n        int num=sqrt(n);\\n        int ans=INT_MAX;\\n        //I observed for minimum steps our num varies from sqrt(n) to sqrt(n)/2\\n        //As we can use numbers below sqrt(n)/2 in next function call\\n        while(num>=sqrt(n)/2){\\n            int op=minSteps(n-num*num,memo);\\n            ans=min(ans,op);\\n            if(op<=1)break; //If our op<=1 that will be always our minimum, we can observe that\\n            num--;\\n        }\\n        memo[n]=1+ans;\\n        return 1+ans;\\n    }\\n    int numSquares(int n) {\\n        int* memo=new int[n+1];\\n        for(int i=0;i<=n;i++){\\n            memo[i]=-1;\\n        }\\n        return minSteps(n,memo);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 406592,
                "title": "bfs-solution-python-easy-understand",
                "content": "```\\ndef numSquares(self, n: int) -> int:\\n\\tsquares = [i**2 for i in range(1, int(n**0.5)+1)]\\n\\tres, q, sub_q = 1, {n}, set()\\n\\twhile q:\\n\\t\\tfor node in q:\\n\\t\\t\\tfor square in squares:\\n\\t\\t\\t\\tif node == square: return res\\n\\t\\t\\t\\tif node < square: break\\n\\t\\t\\t\\tsub_q.add(node-square)\\n\\t\\tq, sub_q, res = sub_q, set(), res+1\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef numSquares(self, n: int) -> int:\\n\\tsquares = [i**2 for i in range(1, int(n**0.5)+1)]\\n\\tres, q, sub_q = 1, {n}, set()\\n\\twhile q:\\n\\t\\tfor node in q:\\n\\t\\t\\tfor square in squares:\\n\\t\\t\\t\\tif node == square: return res\\n\\t\\t\\t\\tif node < square: break\\n\\t\\t\\t\\tsub_q.add(node-square)\\n\\t\\tq, sub_q, res = sub_q, set(), res+1\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 395607,
                "title": "python-dp-solution-4-lines",
                "content": "```\\nclass Solution(object):\\n    def numSquares(self,n):\\n        dp = [0] * (n+1)\\n        for i in range(1,n+1):\\n            dp[i] = min([dp[i-j*j] for j in range(1,int(i**.5)+1)])+1\\n        return dp[n]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numSquares(self,n):\\n        dp = [0] * (n+1)\\n        for i in range(1,n+1):\\n            dp[i] = min([dp[i-j*j] for j in range(1,int(i**.5)+1)])+1\\n        return dp[n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325717,
                "title": "pure-math-python3-solution",
                "content": "According to [Lagrange\\'s four-square theorem](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem), the result must be one of [1,2,3,4] for any integer n. \\nQuick notes without proof:\\n1. the results for n and 4n are the same, so do n /= 4 until n%4 != 0.\\n2. if n%8 == 7, the result must be 4. Check the integer you get after step 1.\\n3. if 2 failed, use a for loop to check if n is sum of two perfect squares i and j. Note that i or j might be 0, in this situation, return 1. Otherwise, return 2. \\n\\nAll other situations return 3.\\nDiscussion regarding the mathematical proofs are welcomed. Credit to [Grandyang](https://www.cnblogs.com/grandyang/p/4800552.html)\\n\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        while not (n%4):       #results are the same for n and 4n\\n            n /= 4\\n        if n%8 == 7:\\n            return 4\\n        x = math.ceil(math.sqrt(n))\\n        for i in range(x):\\n            j = math.floor(math.sqrt(n - i*i))\\n            if i*i + j*j == n:\\n                if i > 0 and j > 0:\\n                    return 2\\n                else:\\n                    return 1           \\n        return 3  \\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        while not (n%4):       #results are the same for n and 4n\\n            n /= 4\\n        if n%8 == 7:\\n            return 4\\n        x = math.ceil(math.sqrt(n))\\n        for i in range(x):\\n            j = math.floor(math.sqrt(n - i*i))\\n            if i*i + j*j == n:\\n                if i > 0 and j > 0:\\n                    return 2\\n                else:\\n                    return 1           \\n        return 3  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 223357,
                "title": "c-0-s-100-math-solution",
                "content": "The idea is to use basic square-root check for 1, Lagrange\\'s 4 squares theorem for 4 (which is also the maximum, since theorem states every integer can be represented by sum of 4 squares). This only leaves case 2 and 3. To check case 2, all  we need is to iterate through to sqrt of n, and check if the difference between n and square of i is also a square. If this fails, then we know it must be 3.\\n\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        if(n == (int) sqrt((double) n) * sqrt((double) n)) return 1;\\n        while(n % 4 == 0)  n /= 4;\\n        if(n % 8 == 7) return 4;\\n        for(int i = 0; i*i < n; ++i) {\\n            int a = n - i*i;\\n            if(a == (int) sqrt((double) a) * sqrt((double) a)) return 2;\\n        }\\n        return 3;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        if(n == (int) sqrt((double) n) * sqrt((double) n)) return 1;\\n        while(n % 4 == 0)  n /= 4;\\n        if(n % 8 == 7) return 4;\\n        for(int i = 0; i*i < n; ++i) {\\n            int a = n - i*i;\\n            if(a == (int) sqrt((double) a) * sqrt((double) a)) return 2;\\n        }\\n        return 3;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 188250,
                "title": "python-bidirectional-bfs-72ms-beats-90-faster-than-some-of-the-math-theorem-solutions",
                "content": "```python\\ndef numSquares(self, n):\\n    front, back, pm = [0], [n], 1 # pm is \"plus minus\"\\n    depth = [0] + [None] * (n - 1) + [-1] # depth[0] == 0, depth[n] == -1, depth[everythingElse] == None\\n    while front:\\n        newFront = []\\n        for v in front:\\n            i = 1\\n            while True:\\n                w = v + pm * i * i # generate a neighbor\\n                if w < 0 or w > n: # all neighbors have been generated\\n                    break\\n                if depth[w] is None: # w has not been discovered\\n                    depth[w] = depth[v] + pm # mark it as discovered by assigning a depth to it\\n                    newFront.append(w)\\n                elif (depth[w] < 0) != (depth[v] < 0): # w has been discovered in the `back` tree, so we\\'re done\\n                    return abs(depth[w] - depth[v])\\n                i += 1\\n        front = newFront\\n        if len(front) > len(back):\\n            front, back, pm = back, front, -pm # always expand the tree with fewer leaves\\n```\\n### Explanation\\n\\nWe have a graph with `n + 1` vertices labeled `0` through `n`. There is an (unweighted) edge between vertices `i` and `j` if and only if `abs(i - j)` is a perfect square. The goal is to find the shortest path between `0` and `n`. This is a job for BFS.\\n\\nWe use bidirectional BFS starting from both `0` and `n` for efficiency. The 2 BFS trees rooted at `0` and `n` are called `front` and `back`; `front` always refers to the tree currently being expanded, which is always set to be the tree with fewer leaves. (This is a pretty standard trick for bidirectional BFS.)\\n\\nThe trick with `depth` is this: For the tree rooted at `0`, all its nodes have \"normal\" `depth`, i.e., `depth[0] == 0`, `depth[1] == 1`, `depth[4] == 1`, `depth[9] == 1`, etc. For the other tree rooted at `n`, all its nodes have negative depth; more precisely, their depths are recorded as the bitwise NOT of their \"normal\" depth, i.e., `depth[n] == ~0 == -1`, `depth[n-1] == ~1 == -2`, `depth[n-4] == ~1 == -2`, `depth[n-9] == ~1 == -2`, etc. Now if a node has non-negative depth, then we know it was discovered from the tree rooted at `0`; if a node has negative depth, then we know it was discovered from the tree rooted at `n`; **if it has both, then we have found the shortest path between `0` and `n`.**\\n\\n**More to come...**\\n\\n### Confession\\nAdmittedly, this algorithm is fast _because_ the theorem guarantees that no tree has to be searched beyond depth 2...",
                "solutionTags": [],
                "code": "```python\\ndef numSquares(self, n):\\n    front, back, pm = [0], [n], 1 # pm is \"plus minus\"\\n    depth = [0] + [None] * (n - 1) + [-1] # depth[0] == 0, depth[n] == -1, depth[everythingElse] == None\\n    while front:\\n        newFront = []\\n        for v in front:\\n            i = 1\\n            while True:\\n                w = v + pm * i * i # generate a neighbor\\n                if w < 0 or w > n: # all neighbors have been generated\\n                    break\\n                if depth[w] is None: # w has not been discovered\\n                    depth[w] = depth[v] + pm # mark it as discovered by assigning a depth to it\\n                    newFront.append(w)\\n                elif (depth[w] < 0) != (depth[v] < 0): # w has been discovered in the `back` tree, so we\\'re done\\n                    return abs(depth[w] - depth[v])\\n                i += 1\\n        front = newFront\\n        if len(front) > len(back):\\n            front, back, pm = back, front, -pm # always expand the tree with fewer leaves\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 178862,
                "title": "why-is-this-dp-python-solution-having-time-limit-exceeded",
                "content": "Straight-forward DP solution but TLE???\\n```\\nclass Solution:\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n<=3:\\n            return n\\n        dp = [ 0,1,2,3 ]\\n        for i in range(4,n+1):\\n            minimum = float(\\'inf\\')\\n            j = 1\\n            while (i-j*j>=0):\\n                minimum = min(minimum,dp[i-j*j]+1)\\n                j+=1\\n            dp.append(minimum)\\n        return dp[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n<=3:\\n            return n\\n        dp = [ 0,1,2,3 ]\\n        for i in range(4,n+1):\\n            minimum = float(\\'inf\\')\\n            j = 1\\n            while (i-j*j>=0):\\n                minimum = min(minimum,dp[i-j*j]+1)\\n                j+=1\\n            dp.append(minimum)\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71552,
                "title": "python-dp-accepted-the-secret-to-fix-the-python-tle-error",
                "content": "I just submitted a simple bottom-up DP solution in python and got a TLE. I searched through the discussions and saw many other people are struggling with TLE for their python code.\\n\\nAfter struggling with my code a little bit, I finally figure out the issue.\\nNote that in my accepted code below, my dp array is declared as a class variable. However, if you uncomment the __init__ function to turn it to an instance variable, then you get the TLE error. Thus it is pretty obvious that the test script is written in a bad way where a different instance is created every time a new number is tested.\\n\\nSo try to get your TLE'ed version of Python code, turn your dp array into a class variable, and try it again. It should be accepted. Note that you do not need any of the simple optimizations I made below to get the code accepted.\\n\\nTo the Admin of the site: Please fix the test script!\\n\\n\\n```\\nclass Solution(object):\\n    \\n    \"\"\"\\n    # making the dp array an instance variable would cause TLE\\n    def __init__(self):\\n        self.dp = [0]\\n    \"\"\"\\n        \\n    dp = [0] # so now dp is a class variable\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        for i in range(len(self.dp), n+1):\\n            result = sys.maxsize\\n            k = int(math.sqrt(i))\\n            if k * k == i:\\n                self.dp.append(1)\\n                continue\\n            for j in range(1, int(math.sqrt(i)) + 1):\\n                result = min(result, self.dp[i - j * j] + 1)\\n                if result is 2:\\n                    break\\n            self.dp.append(result)\\n        return self.dp[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \\n    \"\"\"\\n    # making the dp array an instance variable would cause TLE\\n    def __init__(self):\\n        self.dp = [0]\\n    \"\"\"\\n        \\n    dp = [0] # so now dp is a class variable\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        for i in range(len(self.dp), n+1):\\n            result = sys.maxsize\\n            k = int(math.sqrt(i))\\n            if k * k == i:\\n                self.dp.append(1)\\n                continue\\n            for j in range(1, int(math.sqrt(i)) + 1):\\n                result = min(result, self.dp[i - j * j] + 1)\\n                if result is 2:\\n                    break\\n            self.dp.append(result)\\n        return self.dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71595,
                "title": "java-use-lagrange-s-four-square-theorem",
                "content": "    public class Solution {\\n    public int numSquares(int n) {\\n        if(n <= 0)\\n            return 0;\\n        \\n        while(n % 4 == 0)\\n            n /= 4;\\n        \\n        //4condition\\n        if(n % 8 == 7)\\n            return 4;\\n        //1 or 2 condition\\n        for(int i = 0; i * i <= n; i++)\\n        {\\n            int j = (int)Math.sqrt(n - i * i);\\n            if(j * j + i * i == n)\\n            {\\n                return (i > 0 ? 1 : 0) + (j > 0 ? 1 : 0);\\n            }\\n        }\\n        //else 3\\n        return 3;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numSquares(int n) {\\n        if(n <= 0)\\n            return 0;\\n        \\n        while(n % 4 == 0)\\n            n /= 4;\\n        \\n        //4condition\\n        if(n % 8 == 7)\\n            return 4;\\n        //1 or 2 condition\\n        for(int i = 0; i * i <= n; i++)\\n        {\\n            int j = (int)Math.sqrt(n - i * i);\\n            if(j * j + i * i == n)\\n            {\\n                return (i > 0 ? 1 : 0) + (j > 0 ? 1 : 0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71634,
                "title": "5-lines-python-static-dp-160ms",
                "content": "    class Solution(object):\\n        numSquaresDP = [0]\\n        def numSquares(self, n):\\n            if len(self.numSquaresDP) <= n:\\n                perfectSqr = [v**2 for v in xrange(1, int(math.sqrt(n)) + 1)]\\n                for i in xrange(len(self.numSquaresDP), n + 1):\\n                    self.numSquaresDP.append( min(1 + self.numSquaresDP[i - sqr] for sqr in perfectSqr if sqr <= i))\\n            return self.numSquaresDP[n]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    class Solution(object):\\n        numSquaresDP = [0]\\n        def numSquares(self, n):\\n            if len(self.numSquaresDP) <= n:\\n                perfectSqr = [v**2 for v in xrange(1, int(math.sqrt(n)) + 1)]\\n                for i in xrange(len(self.numSquaresDP), n + 1):\\n                    self.numSquaresDP.append( min(1 + self.numSquaresDP[i - sqr] for sqr in perfectSqr if sqr <= i))\\n            return self.numSquaresDP[n]",
                "codeTag": "Java"
            },
            {
                "id": 71672,
                "title": "java-dp-solution-not-perfect-o-n-time-but-simple",
                "content": "    public class Solution {\\n        public int numSquares(int n) {\\n            if (n == 0) {\\n                return 0;\\n            }\\n            int[] table = new int[n];\\n            int count = 1;\\n            for (int i = 0; i < n; i++) {\\n                if ((i + 1) == count * count) {\\n                    table[i] = 1;\\n                    count++;\\n                } else {\\n                    table[i] = Integer.MAX_VALUE;\\n                    for (int j = count - 1; j > 0; j--) {\\n                        if (table[i - j * j] + 1 < table[i]) {\\n                            table[i] = table[i - j * j] + 1;\\n                        }\\n                    }\\n                }\\n            }\\n            return table[n - 1];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int numSquares(int n) {\\n            if (n == 0) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3656846,
                "title": "ezzzzzzzzzzzzzzzz",
                "content": "# Intuition\\nso the intuition here is solving for subproblems as we can have large cases .\\n\\n# Approach\\nBasic approach basically i made a helper fucntion\\nthen we will start computing sqaures of numbers less than n and we will see which number needs the lowest count. i*I is used because the sqaure cant exceed the number for example if 15 is given you cant take 9 because its sqaure will exceed 15 and that is of no use . \\n\\n# Complexity\\n- Time complexity:\\n- time will be \\n\\n\\n- Space complexity:\\ndp array space + recursion call stack ( can be eliminated by tabulation)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int solve (int n,vector<int>&dp ){\\n         if(n==0) return 0;\\n         if(dp[n]!=-1) return dp[n];\\n           int ans =n;\\n         for( int i =1;i*i<=n;i++){\\n             int temp =i*i;\\n          ans =  min(ans,1+ solve(n-temp,dp));\\n         }\\n         return dp[n]= ans;\\n     }\\n    int numSquares(int n) {\\n        vector<int> dp(n+1,-1);\\n       return solve (n,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int solve (int n,vector<int>&dp ){\\n         if(n==0) return 0;\\n         if(dp[n]!=-1) return dp[n];\\n           int ans =n;\\n         for( int i =1;i*i<=n;i++){\\n             int temp =i*i;\\n          ans =  min(ans,1+ solve(n-temp,dp));\\n         }\\n         return dp[n]= ans;\\n     }\\n    int numSquares(int n) {\\n        vector<int> dp(n+1,-1);\\n       return solve (n,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411226,
                "title": "python3-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        dp = [20000 for _ in range(n + 1)]\\n        dp[0] = 0\\n        ps = []\\n\\n        for i in range(1,n + 1):\\n            if pow(i, 2) > n:\\n                break\\n            ps.append(i ** 2)\\n\\n        for i in range(n + 1):\\n            for j in ps:\\n                if i + j <= n:\\n                    dp[i + j] = min(dp[i] + 1, dp[i + j])\\n                else:\\n                    break\\n\\n        return dp[n]\\n```\\n# How it works\\nSo in the DP Array (Dynamic Programming Array) the rest except for the first one will be every big, why?, well because, you need to find the smallest value right? but if it samll like 0 and there is something bigger like x, it will need to be like this min(0,x) well 0 would be smaller and the answer will be 0. the for loop is basically finding all the perfect square what PS stands for, so I did it to make it faster, not anything else, and also the second for loop is calcualting, so we will find lots of possible results using Dynamic Programming and then, compare them. well thats it, you final answer will be at the end.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        dp = [20000 for _ in range(n + 1)]\\n        dp[0] = 0\\n        ps = []\\n\\n        for i in range(1,n + 1):\\n            if pow(i, 2) > n:\\n                break\\n            ps.append(i ** 2)\\n\\n        for i in range(n + 1):\\n            for j in ps:\\n                if i + j <= n:\\n                    dp[i + j] = min(dp[i] + 1, dp[i + j])\\n                else:\\n                    break\\n\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221641,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n        int mini = INT_MAX;\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n        return dp[i][sum] = mini;\\n    }\\n    int numSquares(int n) {\\n        vector<int> arr;\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n        int mini = INT_MAX;\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n        return dp[i][sum] = mini;\\n    }\\n    int numSquares(int n) {\\n        vector<int> arr;\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840321,
                "title": "c-shortest-path-bfs-explanation",
                "content": "1. We can use shortest path algorithm to reach the nth position.\\n2. store all the valid perfect squares until they are less than equals to 10^4.\\n3. Then apply bfs algorithm to reach the indexes in the shortest possible steps.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        if(n == 10000)\\n            return 1;\\n        vector<int>dp;\\n        vector<int>sd(10001,INT_MAX);\\n        queue<int>q;\\n        for(int i=1;i<101;i++)\\n        {\\n            dp.push_back(i*i);\\n            sd[i*i] = 1;\\n            q.push(i*i);\\n        }\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            for(auto i:dp)\\n            {\\n                int newnode = node + i;\\n                if(newnode <= n && sd[newnode] > sd[node] + 1)\\n                {\\n                    sd[newnode] = sd[node] + 1;\\n                    q.push(newnode);\\n                }\\n            }\\n        }\\n        return sd[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        if(n == 10000)\\n            return 1;\\n        vector<int>dp;\\n        vector<int>sd(10001,INT_MAX);\\n        queue<int>q;\\n        for(int i=1;i<101;i++)\\n        {\\n            dp.push_back(i*i);\\n            sd[i*i] = 1;\\n            q.push(i*i);\\n        }\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            for(auto i:dp)\\n            {\\n                int newnode = node + i;\\n                if(newnode <= n && sd[newnode] > sd[node] + 1)\\n                {\\n                    sd[newnode] = sd[node] + 1;\\n                    q.push(newnode);\\n                }\\n            }\\n        }\\n        return sd[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839419,
                "title": "dp-easy-explained-cpp",
                "content": "# Approach\\nif we create a fixed size vector, \\n        it will generate heap-buffer-overflow,\\n        because leetcode is reusing the vector, \\n        so we need to dynamically change its size to fit different testcases\\n\\n# CPP Code\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        //padding ahead\\n        static vector<int> dp = {0};\\n        \\n        while(dp.size() <= n){\\n            int i = dp.size();\\n            int count = INT_MAX;\\n            for(int j = 1; j*j <= i; ++j){\\n                count = min(count, dp[i-j*j]+1);\\n            }\\n            dp.push_back(count);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        //padding ahead\\n        static vector<int> dp = {0};\\n        \\n        while(dp.size() <= n){\\n            int i = dp.size();\\n            int count = INT_MAX;\\n            for(int j = 1; j*j <= i; ++j){\\n                count = min(count, dp[i-j*j]+1);\\n            }\\n            dp.push_back(count);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838691,
                "title": "java-dynamic-programming-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n\\n        for (int i = 2; i <= n; i++) {\\n            int min = Integer.MAX_VALUE;\\n\\n            for (int j = 1; j * j <= i; j++) {\\n                int remaining = i - j * j;\\n                min = Math.min(dp[remaining], min);\\n            }\\n\\n            dp[i] = min + 1;\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n\\n// TC: O(n * sqrt(n)), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n\\n        for (int i = 2; i <= n; i++) {\\n            int min = Integer.MAX_VALUE;\\n\\n            for (int j = 1; j * j <= i; j++) {\\n                int remaining = i - j * j;\\n                min = Math.min(dp[remaining], min);\\n            }\\n\\n            dp[i] = min + 1;\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n\\n// TC: O(n * sqrt(n)), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838496,
                "title": "java-dp-solutions-bfs-and-dfs-readable-and-commented",
                "content": "```\\n\\nclass Solution {\\n    public int numSquares(int n) {\\n        // Shortest path stuff is generally breadth first search\\n        // Since we go one step at a time, the most efficient one is usually bfs\\n        // BFS is generally about going level by level, one step at a time, so first answer is the quickest\\n        \\n        // We perform the DFS step but one step at a time and for all :) [Refer Down]      \\n        Queue<Integer> queue= new LinkedList<>();\\n        HashSet <Integer> visit= new HashSet<>(); // To remove duplicate values in queue\\n        if (n>0)\\n            queue.add(n);\\n        int count=0;\\n        \\n        while (!queue.isEmpty())\\n        {\\n            count++;\\n            // Level Order Traversal\\n            int size= queue.size();\\n            for (int j=1; j<=size; j++)\\n           {  \\n                int value= queue.poll();\\n                int div= (int)Math.sqrt(value);\\n                \\n                for (int i=1; i<= div; i++)\\n                {   \\n                    if ((value-i*i)==0)\\n                        return count;\\n\\n                    else if(visit.add(value-i*i))\\n                        queue.add(value-i*i);\\n                }\\n           }\\n            \\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n\\n/*\\nDFS Solution:\\n\\npublic int numSquares(int n) \\n    {\\n        Integer dp[]= new Integer[n+1];\\n        return solver(n, dp);        \\n    }\\n    \\n    public int solver(int value, Integer dp[])\\n    {\\n        if (value<=0)\\n            return 0;\\n        \\n        if (dp[value]!=null)\\n            return dp[value];\\n        \\n        int count=0, max=Integer.MAX_VALUE;\\n        int div= (int)Math.sqrt(value);\\n        \\n        for (int i=1; i<= div; i++)\\n        {\\n          count= 1+ solver(value-i*i, dp);\\n          max= Math.min(max, count);\\n        }\\n        \\n        return dp[value]=max;\\n    }\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int numSquares(int n) {\\n        // Shortest path stuff is generally breadth first search\\n        // Since we go one step at a time, the most efficient one is usually bfs\\n        // BFS is generally about going level by level, one step at a time, so first answer is the quickest\\n        \\n        // We perform the DFS step but one step at a time and for all :) [Refer Down]      \\n        Queue<Integer> queue= new LinkedList<>();\\n        HashSet <Integer> visit= new HashSet<>(); // To remove duplicate values in queue\\n        if (n>0)\\n            queue.add(n);\\n        int count=0;\\n        \\n        while (!queue.isEmpty())\\n        {\\n            count++;\\n            // Level Order Traversal\\n            int size= queue.size();\\n            for (int j=1; j<=size; j++)\\n           {  \\n                int value= queue.poll();\\n                int div= (int)Math.sqrt(value);\\n                \\n                for (int i=1; i<= div; i++)\\n                {   \\n                    if ((value-i*i)==0)\\n                        return count;\\n\\n                    else if(visit.add(value-i*i))\\n                        queue.add(value-i*i);\\n                }\\n           }\\n            \\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n\\n/*\\nDFS Solution:\\n\\npublic int numSquares(int n) \\n    {\\n        Integer dp[]= new Integer[n+1];\\n        return solver(n, dp);        \\n    }\\n    \\n    public int solver(int value, Integer dp[])\\n    {\\n        if (value<=0)\\n            return 0;\\n        \\n        if (dp[value]!=null)\\n            return dp[value];\\n        \\n        int count=0, max=Integer.MAX_VALUE;\\n        int div= (int)Math.sqrt(value);\\n        \\n        for (int i=1; i<= div; i++)\\n        {\\n          count= 1+ solver(value-i*i, dp);\\n          max= Math.min(max, count);\\n        }\\n        \\n        return dp[value]=max;\\n    }\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837814,
                "title": "python-4-lines-can-it-be-any-more-concise",
                "content": "```\\n@lru_cache(None)\\ndef dp(n: int) -> int:\\n    return 0 if n == 0 else min(dp(n-(x+1)**2) for x in range(floor(sqrt(n)))) + 1\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        return dp(n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n@lru_cache(None)\\ndef dp(n: int) -> int:\\n    return 0 if n == 0 else min(dp(n-(x+1)**2) for x in range(floor(sqrt(n)))) + 1\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        return dp(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831156,
                "title": "easy-code-in-c-dp-memoization",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int calculate(int i,int n,vector<int>& dp){\\n        if(n==0)\\n            return 0;\\n        if(i*i>n)\\n            return INT_MAX-1;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        return dp[n]=min(1+calculate(i,n-i*i,dp),calculate(i+1,n,dp));\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(n+1,-1);\\n        return calculate(1,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(int i,int n,vector<int>& dp){\\n        if(n==0)\\n            return 0;\\n        if(i*i>n)\\n            return INT_MAX-1;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        return dp[n]=min(1+calculate(i,n-i*i,dp),calculate(i+1,n,dp));\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(n+1,-1);\\n        return calculate(1,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539881,
                "title": "c-recursion-memoization-tabulation-spaceoptimization",
                "content": "# Method - 1 [Recursion]\\n\\n![image](https://assets.leetcode.com/users/images/69f13e6d-b66d-44d9-adef-1c3dd22417a8_1662464954.5946724.png)\\n\\n**T->O(Expo) && S->O(sqrt(n)) [Recursion stack sapce]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int target,int n){\\n\\t\\t\\tif(i*i>n){\\n\\t\\t\\t\\tif(!target) return 0;\\n\\t\\t\\t\\treturn 1e9;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i*i==n) return 1;\\n\\t\\t\\tint pick=1e9;\\n\\t\\t\\tif(target>=i*i) pick=1+f(i,target-i*i,n);\\n\\t\\t\\tint notpick=f(i+1,target,n);\\n\\t\\t\\treturn min(pick,notpick);\\n\\t\\t}\\n\\n\\t\\tint numSquares(int n) {\\n\\t\\t\\treturn f(1,n,n);\\n\\t\\t}\\n\\t};\\n\\n\\n# Method - 2 [Memoziation]\\n![image](https://assets.leetcode.com/users/images/cc0bd746-fc36-49bb-8dc2-137e9c7e2dbf_1662464673.2329597.png)\\n\\n**T->O(sqrt(n) X n) && S->O(sqrt(n) X n) + O(sqrt(n)) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int i,int target,int n,vector<vector<int>>& dp){\\n\\t\\t\\t\\tif(i*i>n){\\n\\t\\t\\t\\t\\tif(!target) return 0;\\n\\t\\t\\t\\t\\treturn 1e9;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(i*i==n) return 1;\\n\\t\\t\\t\\tif(dp[i][target]!=-1) return dp[i][target];\\n\\t\\t\\t\\tint pick=1e9;\\n\\t\\t\\t\\tif(target>=i*i) pick=1+f(i,target-i*i,n,dp);\\n\\t\\t\\t\\tint notpick=f(i+1,target,n,dp);\\n\\t\\t\\t\\treturn dp[i][target]=min(pick,notpick);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint numSquares(int n) {\\n\\t\\t\\t\\tvector<vector<int>> dp(sqrt(n)+1,vector<int>(n+1,-1));\\n\\t\\t\\t\\treturn f(1,n,n,dp);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n# Method - 3 [Tabulation]\\n\\n![image](https://assets.leetcode.com/users/images/9c238ae8-c171-48c7-9437-f9bdcd1d94d1_1662466619.3093004.png)\\n\\n**m=sqrt(n)\\nT->O(mn) && S->O(mn)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numSquares(int n) {\\n\\t\\t\\tvector<int> nums;\\n\\t\\t\\tfor(int i=1;i*i<=n;i++) nums.push_back(i*i);\\n\\t\\t\\tint m=nums.size();\\n\\t\\t\\tvector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n\\t\\t\\tfor(int target=1;target<=n;target++) dp[m][target]=1e9;\\n\\t\\t\\tfor(int i=m-1;i>=0;i--){\\n\\t\\t\\t\\tfor(int target=0;target<=n;target++){\\n\\t\\t\\t\\t\\tint pick=1e9;\\n\\t\\t\\t\\t\\tif(target>=nums[i]) pick=1+dp[i][target-nums[i]];\\n\\t\\t\\t\\t\\tint notpick=dp[i+1][target];\\n\\t\\t\\t\\t\\tdp[i][target]=min(pick,notpick);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0][n];\\n\\t\\t}\\n\\t};\\n\\t\\n# Method - 4 [SpaceOptimization]\\t\\n![image](https://assets.leetcode.com/users/images/83d17d18-14cc-4616-b55e-6baf67b80b1f_1662466813.0273802.png)\\n\\n**T->O(mn) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numSquares(int n) {\\n\\t\\t\\tvector<int> nums;\\n\\t\\t\\tfor(int i=1;i*i<=n;i++) nums.push_back(i*i);\\n\\t\\t\\tint m=nums.size();\\n\\t\\t\\tvector<int> prev(n+1,0),curr(n+1,0);\\n\\t\\t\\tfor(int target=1;target<=n;target++) prev[target]=1e9;\\n\\t\\t\\tfor(int i=m-1;i>=0;i--){\\n\\t\\t\\t\\tfor(int target=0;target<=n;target++){\\n\\t\\t\\t\\t\\tint pick=1e9;\\n\\t\\t\\t\\t\\tif(target>=nums[i]) pick=1+curr[target-nums[i]];\\n\\t\\t\\t\\t\\tint notpick=prev[target];\\n\\t\\t\\t\\t\\tcurr[target]=min(pick,notpick);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev=curr;\\n\\t\\t\\t}\\n\\t\\t\\treturn prev[n];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int target,int n){\\n\\t\\t\\tif(i*i>n){\\n\\t\\t\\t\\tif(!target) return 0;\\n\\t\\t\\t\\treturn 1e9;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2534059,
                "title": "c-91-95-faster-dp-easy-and-short-code",
                "content": "**If you think the solution is helpful, a simple hit of upvote is highly appreciated.**\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        int dp[n+1];\\n        memset(dp,0x3f3f3f,sizeof(dp));\\n        dp[0]=0;\\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j*j<=i;j++)\\n                dp[i]=min(dp[i],dp[i-j*j]+1);\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        int dp[n+1];\\n        memset(dp,0x3f3f3f,sizeof(dp));\\n        dp[0]=0;\\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j*j<=i;j++)\\n                dp[i]=min(dp[i],dp[i-j*j]+1);\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375058,
                "title": "using-easy-01-knapsack",
                "content": "1. form a list of perfectsquares that are less then n.\\n2. now we need to pick minimum number of perfect squares from the list such that their sum is equal to n.\\n\\tproblem based on similar prinicple - https://leetcode.com/problems/coin-change/\\n\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        vector<int> perfectSq;\\n        \\n        for(int i = 1; i*i <= n; ++i){\\n            perfectSq.push_back(i*i);\\n        }\\n        \\n        int m = perfectSq.size();\\n        vector<vector<int>> dp( m+1, vector<int>(n+1, 0));\\n        \\n        dp[0][0] = 0;\\n        for( int i = 1; i <= n; ++i ) dp[0][i] = INT_MAX;\\n        \\n        for(int i = 1; i <= m; ++i){\\n            for(int j = 1; j <= n; ++j){\\n                \\n                if( j < perfectSq[i-1]){\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j] = min( dp[i-1][j], dp[i][ j - perfectSq[i-1] ] + 1);\\n                }\\n                \\n            }\\n        }\\n   \\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        vector<int> perfectSq;\\n        \\n        for(int i = 1; i*i <= n; ++i){\\n            perfectSq.push_back(i*i);\\n        }\\n        \\n        int m = perfectSq.size();\\n        vector<vector<int>> dp( m+1, vector<int>(n+1, 0));\\n        \\n        dp[0][0] = 0;\\n        for( int i = 1; i <= n; ++i ) dp[0][i] = INT_MAX;\\n        \\n        for(int i = 1; i <= m; ++i){\\n            for(int j = 1; j <= n; ++j){\\n                \\n                if( j < perfectSq[i-1]){\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j] = min( dp[i-1][j], dp[i][ j - perfectSq[i-1] ] + 1);\\n                }\\n                \\n            }\\n        }\\n   \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347500,
                "title": "c-bfs",
                "content": "**Runtime: 43 ms\\nMemory Usage: 9 MB**\\n* **Explanation:**\\n\\tWe need to go through every single possible perfect square combination. To do that we can use **Breath-First Search (BFS)**. We will need two things: ***queue*** (to store the current number) and ***\"distance\"*** (to hold the count of how many squares we have used). We go through this BFS until our current number reaches 0 => and we found a perfect squares sequence, also we know this is the most optimal solution since our current number is strictly decreasing and reaching 0 will result in the least amount of perfect squares used.\\n* **Optimization:**\\n\\t\\t1. Since our number n can only consist of perfect squares, we will have to iterate only from ***1 till sqrt(n) since sqrt(n) * sqrt(n) = n*** => our number.\\n\\t\\t2. If we come across the same number as before, we will not need to add such a number to the queue, since we will already go through (or have gone through) that number\\'s perfect squares. We can do this using an array, which is filled with -1, when we come across a unique number, we can set that array element to any number besides -1, this marks it as visited.\\n* **NOTE: Please tell me if my explanation is poorly written or is hard to understand or isn\\'t understandable**\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n \\xA0 \\xA0 \\xA0 \\xA0int visited[n + 1];\\n \\xA0 \\xA0 \\xA0 \\xA0fill_n(visited, n + 1, -1);\\n        queue<int> q;\\n        int ans = 1;\\n        for (int i = 1; i * i <= n; ++i) {\\n            q.push(n - i * i); \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0visited[n - i * i] = 69; // funny internet number\\n        }\\n        while (q.size()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; ++i) {\\n                int curr = q.front();\\n                if (curr == 0) return ans;\\n                q.pop();\\n                for (int j = 1; j * j <= curr; ++j) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (visited[curr - j * j] == -1) {\\n                        q.push(curr - j * j);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0visited[curr - j * j] = 420; // another funny internet number\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        // useless, since we will always reach 0 (the sequence could consist of only 1\\'s => n <= 3)\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n \\xA0 \\xA0 \\xA0 \\xA0int visited[n + 1];\\n \\xA0 \\xA0 \\xA0 \\xA0fill_n(visited, n + 1, -1);\\n        queue<int> q;\\n        int ans = 1;\\n        for (int i = 1; i * i <= n; ++i) {\\n            q.push(n - i * i); \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0visited[n - i * i] = 69; // funny internet number\\n        }\\n        while (q.size()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; ++i) {\\n                int curr = q.front();\\n                if (curr == 0) return ans;\\n                q.pop();\\n                for (int j = 1; j * j <= curr; ++j) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (visited[curr - j * j] == -1) {\\n                        q.push(curr - j * j);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0visited[curr - j * j] = 420; // another funny internet number\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        // useless, since we will always reach 0 (the sequence could consist of only 1\\'s => n <= 3)\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1692932,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1565279,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1572861,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1575503,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1576285,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1570172,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1567242,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1569209,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1692632,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1569437,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1692932,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1565279,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1572861,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1575503,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1576285,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1570172,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1567242,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1569209,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1692632,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1569437,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1784651,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 1703479,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 1693527,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 1692543,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 2012804,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 1574475,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 1573022,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 1571522,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 2038889,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 2019875,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 1989139,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1954581,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1901437,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1891431,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1855421,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1833059,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1824299,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1810630,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1800768,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1757136,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1756216,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1754781,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1742844,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1729922,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1702343,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1698844,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1693086,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1693085,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1692779,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1692749,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            }
        ]
    }
]