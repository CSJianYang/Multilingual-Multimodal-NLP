[
    {
        "title": "Self Crossing",
        "question_content": "You are given an array of integers distance.\nYou start at the point (0, 0) on an X-Y plane, and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.\nReturn true if your path crosses itself or false if it does not.\n&nbsp;\nExample 1:\n\nInput: distance = [2,1,1,2]\nOutput: true\nExplanation: The path crosses itself at the point (0, 1).\n\nExample 2:\n\nInput: distance = [1,2,3,4]\nOutput: false\nExplanation: The path does not cross itself at any point.\n\nExample 3:\n\nInput: distance = [1,1,1,2,1]\nOutput: true\nExplanation: The path crosses itself at the point (0, 0).\n\n&nbsp;\nConstraints:\n\n\t1 <=&nbsp;distance.length <= 105\n\t1 <=&nbsp;distance[i] <= 105",
        "solutions": [
            {
                "id": 79131,
                "title": "java-oms-with-explanation",
                "content": "    // Categorize the self-crossing scenarios, there are 3 of them: \\n    // 1. Fourth line crosses first line and works for fifth line crosses second line and so on...\\n    // 2. Fifth line meets first line and works for the lines after\\n    // 3. Sixth line crosses first line and works for the lines after\\n    public class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            int l = x.length;\\n            if(l <= 3) return false;\\n            \\n            for(int i = 3; i < l; i++){\\n                if(x[i] >= x[i-2] && x[i-1] <= x[i-3]) return true;  //Fourth line crosses first line and onward\\n                if(i >=4)\\n                {\\n                    if(x[i-1] == x[i-3] && x[i] + x[i-4] >= x[i-2]) return true; // Fifth line meets first line and onward\\n                }\\n                if(i >=5)\\n                {\\n                    if(x[i-2] - x[i-4] >= 0 && x[i] >= x[i-2] - x[i-4] && x[i-1] >= x[i-3] - x[i-5] && x[i-1] <= x[i-3]) return true;  // Sixth line crosses first line and onward\\n                }\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            int l = x.length;\\n            if(l <= 3) return false;\\n            \\n            for(int i = 3; i < l; i++){\\n                if(x[i] >= x[i-2] && x[i-1] <= x[i-3]) return true;  //Fourth line crosses first line and onward\\n                if(i >=4)\\n                {\\n                    if(x[i-1] == x[i-3] && x[i] + x[i-4] >= x[i-2]) return true; // Fifth line meets first line and onward\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 79141,
                "title": "another-python",
                "content": "Checking out every six pack.\\n\\n**Solution 1**\\n\\n    def isSelfCrossing(self, x):\\n        return any(d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b)\\n                   for a, b, c, d, e, f in ((x[i:i+6] + [0] * 6)[:6]\\n                                            for i in xrange(len(x))))\\n\\n**Solution 2**\\n\\n    def isSelfCrossing(self, x):\\n        b = c = d = e = 0\\n        for a in x:\\n            if d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b):\\n                return True\\n            b, c, d, e, f = a, b, c, d, e\\n        return False\\n\\n**Explanation**\\n\\n                b                              b\\n       +----------------+             +----------------+\\n       |                |             |                |\\n       |                |             |                | a\\n     c |                |           c |                |\\n       |                | a           |                |    f\\n       +----------->    |             |                | <----+\\n                d       |             |                |      | e\\n                        |             |                       |\\n                                      +-----------------------+\\n                                                   d\\n\\nDraw a line of length `a`. Then draw further lines of lengths `b`, `c`, etc. How does the `a`-line get crossed? From the left by the `d`-line or from the right by the `f`-line, see the above picture. I just encoded the criteria for actually crossing it.\\n\\nTwo details:\\n\\n- In both cases, `d` needs to be at least `b`. In the first case to cross the `a`-line directly, and in the second case to get behind it so that the `f`-line can cross it. So I factored out `d >= b`.\\n- The \"special case\" of the `e`-line stabbing the `a`-line from below is covered because in that case, the `f`-line \"crosses\" it (note that even if there is no actual `f`-line, my code uses `f = 0` and thus still finds that \"crossing\").",
                "solutionTags": [
                    "Python"
                ],
                "code": "Checking out every six pack.\\n\\n**Solution 1**\\n\\n    def isSelfCrossing(self, x):\\n        return any(d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b)\\n                   for a, b, c, d, e, f in ((x[i:i+6] + [0] * 6)[:6]\\n                                            for i in xrange(len(x))))\\n\\n**Solution 2**\\n\\n    def isSelfCrossing(self, x):\\n        b = c = d = e = 0\\n        for a in x:\\n            if d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b):\\n                return True\\n            b, c, d, e, f = a, b, c, d, e\\n        return False\\n\\n**Explanation**\\n\\n                b                              b\\n       +----------------+             +----------------+\\n       |                |             |                |\\n       |                |             |                | a\\n     c |                |           c |                |\\n       |                | a           |                |    f\\n       +----------->    |             |                | <----+\\n                d       |             |                |      | e\\n                        |             |                       |\\n                                      +-----------------------+\\n                                                   d\\n\\nDraw a line of length `a`. Then draw further lines of lengths `b`, `c`, etc. How does the `a`-line get crossed? From the left by the `d`-line or from the right by the `f`-line, see the above picture. I just encoded the criteria for actually crossing it.\\n\\nTwo details:\\n\\n- In both cases, `d` needs to be at least `b`. In the first case to cross the `a`-line directly, and in the second case to get behind it so that the `f`-line can cross it. So I factored out `d >= b`.\\n- The \"special case\" of the `e`-line stabbing the `a`-line from below is covered because in that case, the `f`-line \"crosses\" it (note that even if there is no actual `f`-line, my code uses `f = 0` and thus still finds that \"crossing\").",
                "codeTag": "Python3"
            },
            {
                "id": 79168,
                "title": "simple-java-solution",
                "content": "    public class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            if (x.length <= 3) {\\n                return false;\\n            }\\n            int i = 2;\\n            // keep spiraling outward\\n            while (i < x.length && x[i] > x[i - 2]) {\\n                i++;\\n            }\\n            if (i >= x.length) {\\n                return false;\\n            }\\n            // transition from spiraling outward to spiraling inward\\n            if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                    (i == 3 && x[i] == x[i - 2])) {\\n                x[i - 1] -= x[i - 3];\\n            }\\n            i++;\\n            // keep spiraling inward\\n            while (i < x.length) {\\n                if (x[i] >= x[i - 2]) {\\n                    return true;\\n                }\\n                i++;\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            if (x.length <= 3) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 729133,
                "title": "how-to-explain-to-interviewer-335-self-crossing",
                "content": "#### 1. Clarify\\n1) What if one line hits another line\\'s end/start point? Is that \"crossing\"? - Answer is Yes\\n\\n#### 2. Idea\\nThere are three cases of self crossing as shown below:\\n\\n**In case 1, self-crossing condition is i >= 3 && x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]\\uFF1A**\\n<img src=\"https://assets.leetcode.com/users/images/d1886cb6-443e-4fb2-815a-45fcb17951be_1594409670.779942.png\" width=\"300\">\\n\\n\\n**In case 2, self-crossing condition is i >= 4 && x[i - 1] == x[i - 3] && x[i] + x[i - 4] >= x[i - 2]**\\n<img src=\"https://assets.leetcode.com/users/images/cf0313ef-46e4-4368-996e-f8233bd6b40f_1594409704.3358605.png\" width=\"300\">\\n\\n\\n**In case 3, self-crossing condition is i >= 5 && x[i - 2] >= x[i - 4] && x[i - 5] + x[i - 1] >= x[i - 3] && x[i - 1] <= x[i - 3] && x[i - 4] + x[i] >= x[i - 2]**\\n<img src=\"https://assets.leetcode.com/users/images/09166a56-ec6f-4cf6-b7f9-027d5697f659_1594409703.788015.png\" width=\"300\">\\n\\n\\n\\n#### 3. Write Code\\n```java\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        for(int i = 3; i < x.length; i ++){\\n            if(i >= 3 && x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]) return true;\\n            \\n            if(i >= 4 && x[i - 1] == x[i - 3] && x[i] + x[i - 4] >= x[i - 2]) return true;\\n            \\n            if(i >= 5 && x[i - 2] >= x[i - 4] && x[i - 5] + x[i - 1] >= x[i - 3] && x[i - 1] <= x[i - 3] && x[i - 4] + x[i] >= x[i - 2]) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\n#### 4. Test Cases\\nRun test cases by hand or use the IDE\\n\\n#### 5. Complexity Analysis\\nTime Complexity: O(n)  where n is the length of the array x\\nSpace Compleixty: O(1)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        for(int i = 3; i < x.length; i ++){\\n            if(i >= 3 && x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]) return true;\\n            \\n            if(i >= 4 && x[i - 1] == x[i - 3] && x[i] + x[i - 4] >= x[i - 2]) return true;\\n            \\n            if(i >= 5 && x[i - 2] >= x[i - 4] && x[i - 5] + x[i - 1] >= x[i - 3] && x[i - 1] <= x[i - 3] && x[i - 4] + x[i] >= x[i - 2]) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79133,
                "title": "c-simple-solution",
                "content": "    class Solution\\n    {\\n    public:\\n        bool isSelfCrossing(vector<int>& x)\\n        {\\n            x.insert(x.begin(), 4, 0);\\n    \\n            int len = x.size();\\n            int i = 4;\\n    \\n            // outer spiral\\n            for (; i < len && x[i] > x[i - 2]; i++);\\n    \\n            if (i == len) return false;\\n    \\n            // check border\\n            if (x[i] >= x[i - 2] - x[i - 4])\\n            {\\n                x[i - 1] -= x[i - 3];\\n            }\\n    \\n            // inner spiral\\n            for (i++; i < len && x[i] < x[i - 2]; i++);\\n    \\n            return i != len;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        bool isSelfCrossing(vector<int>& x)\\n        {\\n            x.insert(x.begin(), 4, 0);\\n    \\n            int len = x.size();\\n            int i = 4;\\n    \\n            // outer spiral\\n            for (; i < len && x[i] > x[i - 2]; i++);\\n    \\n            if (i == len) return false;\\n    \\n            // check border\\n            if (x[i] >= x[i - 2] - x[i - 4])\\n            {\\n                x[i - 1] -= x[i - 3];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 79175,
                "title": "the-best-submission-in-c-searching-for-the-crossing-patterns-is-the-key",
                "content": "After drawing a few crossing cases ourselves, we can simply find out there are two basic patterns:\\n\\n - x[i-1]<=x[i-3] && x[i]>=x[i-2] the ending circle line cross the beginning circle line in one circle;\\n - i>=5 && x[i-1]<=x[i-3] && x[i]>=x[i-2]-x[i-4] the second line of the next circle cross the the beginning of the previous circle between two adjacent circles;\\n\\nBut still that is not over yet, how about some special cases? How about the first line of the next circle and the previous circle? Yeah, the beginning line of the next circle can overlap the the first line of the previous circle - another two adjacent circles case: \\n\\n - i>=4 && x[i-1]==x[i-3] && x[i]>=x[i-2]-x[i-4]\\n\\nQuite straightforward. Then we can test our patterns now, however soon we will find out that the second cases  is not strong enough to cover all possible situations - the second line of the next circle crossing the previous circle at the its first line\\n\\n - [3,3,3,2,1,1] is an example here, so x[i-2]>=x[i-4] then must be added to our conditions;\\n - [3,3,4,4,10,4,4,,3,3] is another typical example for x[i-3]<=x[i-1]+x[i-5] condition, which also should be added to make the constrained conditions stronger;\\n\\nAt last, we make it! Bang! End of story with a very terse, clean and efficient code as follows.\\n\\n**Updated: 2016-09-12** For better and easier reasoning, here is the thinking thread.\\nSuppose `i` is the current line, then:\\n\\n- i and i-3 can cross \\n- i and i-4 can cross\\n- i and i-5 can cross \\n\\nno more or no less just exactly the right combination.\\n\\nNow it's time for us to restrict the conditions to make them just happen.\\n\\ni and i-3\\n> i>=i-2 && i-1<=i-3\\n\\ni and i-4\\n>i+i-4>=i-2 && i-1==i-3\\n\\ni and i-5\\n> i+i-4>=i-2 && i-2>=i-4 && i-1+i-5>=i-3 && i-1<=i-3\\n\\n----------\\nIn C\\n\\n```\\nbool isSelfCrossing(int* x, int size)\\n{\\n    for(int i = 3; i < size; i++)\\n    {\\n        if(x[i]>=x[i-2] && x[i-1]<=x[i-3]) return true;\\n        if(i>=4 && x[i-1]==x[i-3] && x[i]+x[i-4]>=x[i-2]) return true;\\n        if(i>=5 && x[i-2]-x[i-4]>=0 && x[i]>=x[i-2]-x[i-4] && x[i-1]>=x[i-3]-x[i-5] && x[i-1]<=x[i-3]) return true;\\n    }\\n    return false;\\n}\\n```\\n\\nIn C++\\n\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n\\tfor(int i = 3; i < x.size(); i++) {\\n\\t\\tif(x[i-1]<=x[i-3] && x[i]>=x[i-2]) return true;\\n\\t\\tif(i>3 && x[i]+x[i-4]>=x[i-2] && x[i-1]==x[i-3]) return true;\\n\\t\\tif(i>4 && x[i-1]+x[i-5]>=x[i-3] && x[i-1]<=x[i-3] && x[i]+x[i-4]>=x[i-2] && x[i-4]<=x[i-2]) return true;\\n\\t}\\n\\treturn false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool isSelfCrossing(int* x, int size)\\n{\\n    for(int i = 3; i < size; i++)\\n    {\\n        if(x[i]>=x[i-2] && x[i-1]<=x[i-3]) return true;\\n        if(i>=4 && x[i-1]==x[i-3] && x[i]+x[i-4]>=x[i-2]) return true;\\n        if(i>=5 && x[i-2]-x[i-4]>=0 && x[i]>=x[i-2]-x[i-4] && x[i-1]>=x[i-3]-x[i-5] && x[i-1]<=x[i-3]) return true;\\n    }\\n    return false;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n\\tfor(int i = 3; i < x.size(); i++) {\\n\\t\\tif(x[i-1]<=x[i-3] && x[i]>=x[i-2]) return true;\\n\\t\\tif(i>3 && x[i]+x[i-4]>=x[i-2] && x[i-1]==x[i-3]) return true;\\n\\t\\tif(i>4 && x[i-1]+x[i-5]>=x[i-3] && x[i-1]<=x[i-3] && x[i]+x[i-4]>=x[i-2] && x[i-4]<=x[i-2]) return true;\\n\\t}\\n\\treturn false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79140,
                "title": "re-post-2-o-n-c-0ms-solutions",
                "content": "The first solution is well described in [KuangYuan's post][1] and the idea is to enumerate all the self-crossing cases. Basically, there are three cases\\nCase1:  self-crossing is formed by the last 4 lines (like a closed rectangle)\\nCase 2: self-crossing is formed by the last 5 lines (still like a closed rectangle with one edge having two moves)\\nCase 3: self-crossing is formed by the last 6 lines (like two overlapped rectangles)\\n\\n    class Solution {\\n    public:\\n        bool isSelfCrossing(vector<int>& x) {\\n            int len = x.size(),i;\\n            for(i=3; i<len;++i)\\n            {\\n                if(x[i]>=x[i-2] && x[i-1] <= x[i-3]) return true; // case 1, the consecutive four lines form a cross\\n                if(i>3 && x[i-1]==x[i-3] && x[i]+x[i-4]>=x[i-2]) return true; // case 2, the consecutive five lines form a cross\\n                if(i>4 && x[i-2]>=x[i-4] && x[i-4]+x[i]>=x[i-2] && x[i-1]<=x[i-3] && x[i-5] + x[i-1]>=x[i-3]) return true;// case 3, the consecutive six lines form a cross\\n            }\\n            return false;\\n        }\\n    };\\n\\nThe second solution is to categorize all the non-self-crossing cases: basically we can only have two valid cases: one is \"grow spiral\" (which means the curve expands like spiral and there is no boundaries in x and y axis) and the other is \"shrink spiral\" (which means the spiral curve becomes smaller and smaller and the boundaries in x and y axis are the last move in that direction). The self-crossing cases can only happen in the \"shrink\" case and it happens only when x[i]>=x[i-2]. The \"grow\" case can become a \"shrink\" case and that only happens when x[i]<=x[i-2]. The  \"shrink\" case can not change to a \"grow\" case.\\nIn the solution, we use a bool grow_spiral to indicate whether the current one is a \"grow spiral\". if before x[i], it is a  \"shrink spiral\", we only need to check if a self-crossing happen (i.e. x[i]>=x[i-2]); if it is a \"grow spiral\", we check if x[i] changes from \"grow\" to \"shrink\" (i.e. x[i]<=x[i-2]), we need to update the boundary x[i-1] (in some cases, it can be x[i-1]-x[i-3]). \\n\\n\\n    class Solution {\\n    public:\\n        bool isSelfCrossing(vector<int>& x) {\\n            int len = x.size(), i;\\n            if(len<=3) return false;\\n            bool grow_spiral;\\n\\n            for(i=3, grow_spiral = x[2]>x[0]; i<len;++i)\\n            {\\n                if(!grow_spiral && x[i]>=x[i-2]) return true;//if it is a \"shrink\" case before x[i] and cross happens\\n                if(grow_spiral && x[i]<=x[i-2])\\n                { // if it is a grow case, and x[i] changes it to shrink\\n                        grow_spiral = false;\\n                        x[i-1] = x[i] + (i>=4?x[i-4]:0)<x[i-2]? x[i-1]:x[i-1]-x[i-3];// update boundary\\n                }\\n            }\\n            return false;\\n        }\\n    };\\n\\nMy special thank goes to  hohomi for pointing out one bug in Solution 2 and I believe I fixed it.\\n\\n\\n  [1]: https://leetcode.com/discuss/88054/java-oms-with-explanation",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isSelfCrossing(vector<int>& x) {\\n            int len = x.size(),i;\\n            for(i=3; i<len;++i)\\n            {\\n                if(x[i]>=x[i-2] && x[i-1] <= x[i-3]) return true; // case 1, the consecutive four lines form a cross\\n                if(i>3 && x[i-1]==x[i-3] && x[i]+x[i-4]>=x[i-2]) return true; // case 2, the consecutive five lines form a cross\\n                if(i>4 && x[i-2]>=x[i-4] && x[i-4]+x[i]>=x[i-2] && x[i-1]<=x[i-3] && x[i-5] + x[i-1]>=x[i-3]) return true;// case 3, the consecutive six lines form a cross\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 79142,
                "title": "java-solution-based-on-spiral-direction-status",
                "content": "I solved this problem based on spiral direction status. Here is the accepted code: \\n\\n \\tpublic static boolean isSelfCrossing(int[] x) {\\n\\t\\tif (x.length < 4)\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tboolean inside = false;\\n\\t\\tfor (int i = 3; i < x.length; i++) {\\n\\t\\t\\tif(inside) {\\n\\t\\t\\t\\tif (x[i] >= x[i - 2])\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tif(x[i-1] > x[i-3])\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tint x5 = i>=5 ? x[i-5] : 0;\\n\\t\\t\\tint x4 = i>=4 ? x[i-4] : 0;\\n\\t\\t\\tif(x[i-1] >= x[i-3] - x5) {\\n\\t\\t\\t\\tif(x[i] >= x[i-2] - x4)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tif(x[i] >= x[i-2])\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tinside=true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\nFor this question, to keep the line not crossed, it can be in following conditions: \\n\\n1. Keep spiraling outside.\\n2. Keep spiraling inside.\\n3. Not crossing during transition from outside spiral into inside spiral. \\n\\nAnd one observation is once it starts to spiral inside, it will never spiral outside.  \\n\\nBased on this observation, we keep one flag: inside which is initialized to false,\\n\\nDuring spiraling outside, and inside, the check is very simple: just check x[i] < x[i-2] for inside spiral. In outside spiral phase, as long as x[i-1] > x[i-3], it's not possible to cross in this step. \\n\\nOnce x[i-1] > x[i-3] condition is broken, we will trigger the transition period: In this period, it has two conditions, \\n\\n1. If this turn back line is towards line x[i-5] (possible cross x[i-5])\\n2. If this turn back line is not towards line x[i-5]. in that case, it will go towards x[i-3] instead. \\n\\nWe need to calculate the max line for x[i] for the two cases.\\n\\nWhen i<4 and i<5 corner case, to avoid many if/else we just prepend two additional steps as if they are moving 0 length. So assign x4 and x5 to 0 respectively.\\n\\nThis solution compare to other solution based on 3 different crossing condition, it's slight better as it will only look back x[i-4] and x[i-4] during transition period (once only). In other two phases, it will only compare two edges.",
                "solutionTags": [],
                "code": "I solved this problem based on spiral direction status. Here is the accepted code: \\n\\n \\tpublic static boolean isSelfCrossing(int[] x) {\\n\\t\\tif (x.length < 4)\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tboolean inside = false;\\n\\t\\tfor (int i = 3; i < x.length; i++) {\\n\\t\\t\\tif(inside) {\\n\\t\\t\\t\\tif (x[i] >= x[i - 2])\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tif(x[i-1] > x[i-3])\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tint x5 = i>=5 ? x[i-5] : 0;\\n\\t\\t\\tint x4 = i>=4 ? x[i-4] : 0;\\n\\t\\t\\tif(x[i-1] >= x[i-3] - x5) {\\n\\t\\t\\t\\tif(x[i] >= x[i-2] - x4)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tif(x[i] >= x[i-2])\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tinside=true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\nFor this question, to keep the line not crossed, it can be in following conditions: \\n\\n1. Keep spiraling outside.\\n2. Keep spiraling inside.\\n3. Not crossing during transition from outside spiral into inside spiral. \\n\\nAnd one observation is once it starts to spiral inside, it will never spiral outside.  \\n\\nBased on this observation, we keep one flag: inside which is initialized to false,\\n\\nDuring spiraling outside, and inside, the check is very simple: just check x[i] < x[i-2] for inside spiral. In outside spiral phase, as long as x[i-1] > x[i-3], it's not possible to cross in this step. \\n\\nOnce x[i-1] > x[i-3] condition is broken, we will trigger the transition period: In this period, it has two conditions, \\n\\n1. If this turn back line is towards line x[i-5] (possible cross x[i-5])\\n2. If this turn back line is not towards line x[i-5]. in that case, it will go towards x[i-3] instead. \\n\\nWe need to calculate the max line for x[i] for the two cases.\\n\\nWhen i<4 and i<5 corner case, to avoid many if/else we just prepend two additional steps as if they are moving 0 length. So assign x4 and x5 to 0 respectively.\\n\\nThis solution compare to other solution based on 3 different crossing condition, it's slight better as it will only look back x[i-4] and x[i-4] during transition period (once only). In other two phases, it will only compare two edges.",
                "codeTag": "Unknown"
            },
            {
                "id": 3089493,
                "title": "c-solution-o-n-time-complexity-pure-maths",
                "content": "# Approach\\n We observe that the point rotates in counter clockwise format.If the no of elements in distance is less than 4 then it cant even complete a full circle so it always returns False.\\nWe apply for loop from 4 to the last line\\n Next it can cross only in two ways :\\n\\n\\n### **When the 4th line meets the 1st line**\\n![WhatsApp Image 7 PM.jpeg](https://assets.leetcode.com/users/images/687c105e-778f-4f3c-989b-2ad109608144_1674462721.4440026.jpeg)\\n\\nIn the image above we notice when the 4th line meets the 1st line..It occurs only when two conditions satisfy:\\n1. The 4th line(i-3) should be longer than 2nd line(i-1)\\n2. The 3rd line(i-2) should be shorter than 1st line(i)\\n\\nSo we return True.\\n\\n### **When the 6th line meets the 1st line**\\n Only when length is longer than 5\\n![WhatsApp Imagjpeg.jpeg](https://assets.leetcode.com/users/images/288d36fd-5ee7-4d45-a25e-42981fc8b156_1674463517.289606.jpeg)\\n\\nIn the image above we notice that the 6th line should cross the 1st line..The conditions for it to occur are:\\n1. The 3rd line(i-2) must be longer than 1st line(i) \\n2. The 2nd line(i-1) must be shorter than 4th line(i-3)\\n3. The sum of 2nd line(i-1) and 6th line(i-5) must be greater than the 4th line(i-3)\\n4. The 1st line(i) and the 5th line(i-4) must be greater than the 3rd line(i-2)\\n\\nSo we return True.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if(distance.size()<4) return false;\\n        distance.insert(distance.begin(),0);\\n        for(int i=3;i<distance.size();i++){\\n            if(distance[i]>=distance[i-2] && distance[i-1]<=distance[i-3]) return true;\\n            if(i>=5){\\n                if(distance[i-1]<=distance[i-3] && distance[i-2]>=distance[i-4]&& distance[i-5]>=distance[i-3]-distance[i-1] && distance[i]>=distance[i-2]-distance[i-4])\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n//UPVOTE IF YOU LIKED THE ANSWER..THANK YOU\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if(distance.size()<4) return false;\\n        distance.insert(distance.begin(),0);\\n        for(int i=3;i<distance.size();i++){\\n            if(distance[i]>=distance[i-2] && distance[i-1]<=distance[i-3]) return true;\\n            if(i>=5){\\n                if(distance[i-1]<=distance[i-3] && distance[i-2]>=distance[i-4]&& distance[i-5]>=distance[i-3]-distance[i-1] && distance[i]>=distance[i-2]-distance[i-4])\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n//UPVOTE IF YOU LIKED THE ANSWER..THANK YOU\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806502,
                "title": "c-code-with-explanation",
                "content": "This problem looks like how to check the crossing line, so the naive way is maintaining the existing lines, and checking if there are any intersections from the current line. Unfortunately, this approach needs O(n^2) query in the worst case.\\n\\nThe key point of the problem is for each line i, we only need to check 2 lines: line i-3 and line i-5. \\n\\nHere is the reason. \\n* Firstly, the vertical line can only intersect with horizon line(except one special case: two vertical line may intersect at (0, 0)). \\n* Then we note that we move to the next position following the fixed pattern: up, left, down, right, and so on, in other words, counterclockwise. Thus, there are 3 possible outputs:\\n\\t1. expansion case (line i has a possible intersection with line i-5):\\n![image](https://assets.leetcode.com/users/images/3f41bb90-af78-4c13-805b-476c30c94255_1646043347.182547.png)\\n\\n\\t2. contraction case (line i has a possible intersection with line i-3):\\n![image](https://assets.leetcode.com/users/images/d73d2868-1ea1-4e4e-aefa-1e805afc9137_1646043438.367299.png)\\n\\t\\n\\t3. expansion+contraction case (line i has a possible intersection with line i-3 and line i-5):\\n![image](https://assets.leetcode.com/users/images/bd58bd95-ba1e-4eff-9654-7f2282866225_1646043494.1786318.png)\\n\\nHere is my code:\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if (distance.size() <= 3) return false; //only can have intersection with more than 4 lines\\n\\n        distance.insert(distance.begin(), 0); //for the edge case: line i intersect with line i-4 at (0, 0)\\n        for (int i = 3; i < distance.size(); i++) {\\n            //check line i-3\\n            if (distance[i - 2] <= distance[i] && distance[i - 1] <= distance[i - 3]) return true;\\n\\n            //check line i-5\\n            if (i >= 5) {\\n                if (distance[i - 1] <= distance[i - 3] && distance[i - 1] >= distance[i - 3] - distance[i - 5] \\n                    && distance[i - 2] >= distance[i - 4] && distance[i - 2] <= distance[i - 4] + distance[i])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if (distance.size() <= 3) return false; //only can have intersection with more than 4 lines\\n\\n        distance.insert(distance.begin(), 0); //for the edge case: line i intersect with line i-4 at (0, 0)\\n        for (int i = 3; i < distance.size(); i++) {\\n            //check line i-3\\n            if (distance[i - 2] <= distance[i] && distance[i - 1] <= distance[i - 3]) return true;\\n\\n            //check line i-5\\n            if (i >= 5) {\\n                if (distance[i - 1] <= distance[i - 3] && distance[i - 1] >= distance[i - 3] - distance[i - 5] \\n                    && distance[i - 2] >= distance[i - 4] && distance[i - 2] <= distance[i - 4] + distance[i])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79192,
                "title": "java-o-n-o-1-0ms-solution-with-explanation",
                "content": "There are only 3 scenarios where it won't cross itself.\\n\\n1. The distances of the moves parallel to each other keeps going up (growing spiral).\\n2. The distances of the moves parallel to each other keeps going down (shrinking spiral).\\n3. The distances of the moves parallel to each other first keeps going up, then keeps going down (shrinking spiral inside of the growing spiral), and never goes up.\\n\\nOur code just needs to check if there're any things violating the above rules.\\n\\nI feel there should be smarter approaches. Please reply as answer or comments. :P\\n\\n    public class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            int a1, a2, a3, a4, a5;\\n            \\n            // if it's increasing\\n            boolean up = false;\\n            \\n            if (x.length < 4) {\\n                return false;\\n            }\\n            \\n            a1 = 0;\\n            a2 = x[0];\\n            a3 = x[1];\\n            a4 = x[2];\\n            \\n            if (a2 < a4) {\\n                up = true;\\n            }\\n            else {\\n                up = false;\\n            }\\n            \\n            for (int i = 3; i < x.length; i++) {\\n                a5 = x[i];\\n                \\n                if (!up && a5 >= a3) {\\n                    return true;\\n                }\\n                else if (up && a5 <= a3) {\\n                    // succeeded in turning into decreasing\\n                    if (a5 + a1 < a3 || (i + 1 < x.length && x[i + 1] + a2 < a4)) {\\n                        up = false;\\n                    }\\n                    // not end yet\\n                    else if (i + 1 < x.length) {\\n                        return true;\\n                    }\\n                }\\n                \\n                a1 = a2;\\n                a2 = a3;\\n                a3 = a4;\\n                a4 = a5;\\n            }\\n            \\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            int a1, a2, a3, a4, a5;\\n            \\n            // if it's increasing\\n            boolean up = false;\\n            \\n            if (x.length < 4) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1223251,
                "title": "a-short-clean-solution-in-c-in-one-pass-o-n-and-o-1-memory",
                "content": "# Idea for the solution\\nThe pattern formed is an outward spiral, followed by an inward spiral. Once the inward spiral has started, we cannot start spiralling out, if it does then it intersects itself.\\n\\nBoth of the spirals obviously don\\'t intersect themselves, so all we need to check is if they intersect each other. The first edge which is part of the inward spiral (smaller than the edge along the same axis N-S or E-W) is called the contracting edge, represented in the code as `pos`.\\n\\n# Spiral Intersection Condition\\nTo check if the spirals intersect, we need to ensure that the size of the spirals (largest edge, last edge of outward spiral and first of inward spiral) don\\'t add up to the space in between them (which is cause by the edge in between the two spirals). Therefore we come up with the and of two conditions, each along one of the axes:\\n\\n```\\nbool cond1 = distance[pos] + distance[pos - 4] >= distance[pos - 2] \\nbool cond2 = distance[pos + 1] + distance[pos - 3] >= distance[pos - 1] \\nreturn cond1 and cond2\\n```\\nHere pos is the index of the contracting edge.\\n# Final Implementation\\n\\nFollowing is the full implementation in C++\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int pos = -1;\\n        int n = distance.size();\\n        for (int i = 2; i < n; i++) {\\n            if (distance[i] >= distance[i - 2] && pos != -1) {\\n                return true; // Tried to expand or static after contracting phase\\n            } else if (distance[i] <= distance[i - 2] && pos == -1) {\\n                pos = i; // The contracting phase starts at this edge\\n            }\\n        }\\n        if (pos == -1) return false;\\n        return ((pos >= 0 ? distance[pos] : 0) + (pos >= 4 ? distance[pos - 4] : 0) >= (pos >= 2 ? distance[pos - 2] : 0)) && \\n            ((pos < n - 1 ? distance[pos + 1] : 0) + (pos >= 3 ? distance[pos - 3] : 0) >= (pos >= 1 ? distance[pos - 1] : 0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "Geometry"
                ],
                "code": "```\\nbool cond1 = distance[pos] + distance[pos - 4] >= distance[pos - 2] \\nbool cond2 = distance[pos + 1] + distance[pos - 3] >= distance[pos - 1] \\nreturn cond1 and cond2\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int pos = -1;\\n        int n = distance.size();\\n        for (int i = 2; i < n; i++) {\\n            if (distance[i] >= distance[i - 2] && pos != -1) {\\n                return true; // Tried to expand or static after contracting phase\\n            } else if (distance[i] <= distance[i - 2] && pos == -1) {\\n                pos = i; // The contracting phase starts at this edge\\n            }\\n        }\\n        if (pos == -1) return false;\\n        return ((pos >= 0 ? distance[pos] : 0) + (pos >= 4 ? distance[pos - 4] : 0) >= (pos >= 2 ? distance[pos - 2] : 0)) && \\n            ((pos < n - 1 ? distance[pos + 1] : 0) + (pos >= 3 ? distance[pos - 3] : 0) >= (pos >= 1 ? distance[pos - 1] : 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153188,
                "title": "c-very-simple-no-complex-logic-not-much-ifelse",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& a) {\\n        int n = a.size();\\n\\tif (n <= 3) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tbool f = true;\\n\\n\\tif (a[2] <= a[0]) {\\n\\t\\tf = false;\\n\\t}\\n\\n\\tfor (int i = 3; i < n; i++) {\\n\\n\\t\\tif (!f) {\\n\\t\\t\\tif (a[i] >= a[i - 2]) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t\\n\\t\\t\\tif (a[i] <= a[i - 2]) {\\n\\t\\t\\t\\tf = false;\\n\\t\\t\\t\\tif (a[i - 2] - a[i - 4] <= a[i]) {\\n\\t\\t\\t\\t\\ta[i - 1] = a[i - 1] - a[i - 3];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\treturn false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& a) {\\n        int n = a.size();\\n\\tif (n <= 3) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tbool f = true;\\n\\n\\tif (a[2] <= a[0]) {\\n\\t\\tf = false;\\n\\t}\\n\\n\\tfor (int i = 3; i < n; i++) {\\n\\n\\t\\tif (!f) {\\n\\t\\t\\tif (a[i] >= a[i - 2]) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t\\n\\t\\t\\tif (a[i] <= a[i - 2]) {\\n\\t\\t\\t\\tf = false;\\n\\t\\t\\t\\tif (a[i - 2] - a[i - 4] <= a[i]) {\\n\\t\\t\\t\\t\\ta[i - 1] = a[i - 1] - a[i - 3];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\treturn false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900931,
                "title": "this-explaination-made-my-life-easy",
                "content": "This video made things clear https://www.youtube.com/watch?v=ajFikcnQV1I \\n\\nTo summerise, problem is broken in 3 cases, \\n![image](https://assets.leetcode.com/users/images/06cb65f8-3b4a-4a87-aa65-c8e52709ed87_1603072520.2768774.png)\\n\\n![image](https://assets.leetcode.com/users/images/3e9bcd87-5b0d-4f55-9caa-486c529c45fc_1603072568.686776.png)\\n\\n![image](https://assets.leetcode.com/users/images/d2c12c8c-1070-4a5a-bb76-593c97487945_1603074025.8367305.png)\\n\\n\\nHere is C++ equivalent,\\n```\\nbool isSelfCrossing(vector<int>& x) {\\n        for(int i = 3; i < x.size(); i++)\\n        {\\n            // x[0] >= x[2], x[3] >= x[1]\\n            if(x[i - 3] >= x[i - 1] && x[i] >= x[i - 2])\\n            {\\n                return true;\\n            }\\n\\n            if(i >= 4)\\n            {\\n                // x[1] == x[3], x[0] + x[4] >= x[2]\\n                if(x[i - 3] == x[i - 1] && (x[i - 4] + x[i]) >= x[i - 2])\\n                {\\n                    return true;\\n                }\\n            }\\n\\n            if(i >= 5)\\n            {\\n                // x[3] >= x[1], x[2] >= x[4], x[0] + x[4] >= x[2], x[1] + x[5] >= x[3]\\n                if(x[i - 2] >= x[i - 4] && x[i - 3] >= x[i - 1] && \\n                   (x[i - 5] + x[i - 1]) >= x[i - 3] && (x[i - 4] + x[i]) >= x[i - 2])\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isSelfCrossing(vector<int>& x) {\\n        for(int i = 3; i < x.size(); i++)\\n        {\\n            // x[0] >= x[2], x[3] >= x[1]\\n            if(x[i - 3] >= x[i - 1] && x[i] >= x[i - 2])\\n            {\\n                return true;\\n            }\\n\\n            if(i >= 4)\\n            {\\n                // x[1] == x[3], x[0] + x[4] >= x[2]\\n                if(x[i - 3] == x[i - 1] && (x[i - 4] + x[i]) >= x[i - 2])\\n                {\\n                    return true;\\n                }\\n            }\\n\\n            if(i >= 5)\\n            {\\n                // x[3] >= x[1], x[2] >= x[4], x[0] + x[4] >= x[2], x[1] + x[5] >= x[3]\\n                if(x[i - 2] >= x[i - 4] && x[i - 3] >= x[i - 1] && \\n                   (x[i - 5] + x[i - 1]) >= x[i - 3] && (x[i - 4] + x[i]) >= x[i - 2])\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 79159,
                "title": "an-ascii-art-explanation-of-this-problem-and-my-c-solution",
                "content": "    //           =   a l l    c a s e s   =\\n    // \\n    //     case 1     case 2: expanding   case 3: collapsing\\n    //                     (global)           (local)\\n    //                  (not crossing)   (may not crossing)\\n    // \\n    //    <------+     +------------+      +---------+\\n    //           |     |            |      |         |\\n    //           |     |  +-----+   |      |  +---+  |\\n    //           |     |  |     |   |      |  |   |  :\\n    //           #     |  |     #   |      |  v   |  :\\n    //                 |  |         |      |      |  \\n    //                 |  +---------+      +------+  \\n    //                 |\\n    //                 +--------->\\n    // \\n    //     case 4: failed expanding                \\n    //      \\n    //      +----+\\n    //      |    |\\n    //      |  <----[2]----^     [2]: second failure\\n    //      |    #         |\\n    //      |             [1]    [1]: first  failure\\n    //      |              |\\n    //      +--------------+\\n    // \\n    //     case 5: failed expanding & then collapsing\\n    // \\n    //      +----+\\n    //      |    |\\n    //      |    |  +------+\\n    //      |    #  | [C]  |     [C]: may be perfectly collapsed\\n    //      |       +--->  |\\n    //      |              |\\n    //      +--------------+\\n    // \\n    //     case 6: failed expanding                \\n    // \\n    //         +---+\\n    //         |   |\\n    //         |   |\\n    //         |   #\\n    //         |\\n    //       <---[2]----+        [2]: second failure\\n    //         |        |\\n    //         |       [1]       [1]: first  failure\\n    //         |        |\\n    //         +--------+\\n    // \\n    //     case 7: failed expanding & then collapsing\\n    // \\n    //         +------+\\n    //         |      |\\n    //         |      #\\n    //         |\\n    //         |  +-----------+\\n    //         |  |  +-----+  |\\n    //         |  |  +-->  | [1] [1]: failure\\n    //         |  |        |  |\\n    //         |  +--------+  |\\n    //         +--------------+\\n    // \\n    //    *notice: case 3 = case 6 + case 7\\n    // \\n    //     case 8: docking!\\n    // \\n    //         +-------+\\n    //         |       |\\n    //         |       #\\n    //         |\\n    //         |       ^\\n    //         |       |\\n    //         +-------+\\n    // \\n    // #: starting point \\n    \\n    // case 3\\n    bool isPerfectCollapsing( int cur, int len, int *data )\\n    {\\n        while ( cur < len ) {\\n            if ( data[cur] < data[cur-2] ) {\\n                ++cur;\\n            } else { return false; }\\n        }\\n        return true;\\n    }\\n    \\n    bool isPerfect( int *data, int len )\\n    {\\n        // case 1\\n        if ( len <= 2 ) { return true; }\\n        // case 8\\n        if ( len >= 5 &&\\n             data[3]==data[1] &&\\n             data[2]<=data[0]+data[4] )\\n        {\\n            return false;\\n        }\\n    \\n        int cur = 2;\\n        while ( cur < len && data[cur] > data[cur-2] ) {\\n            ++cur;\\n        }\\n        if ( cur == len || cur == len-1 ) {\\n            // case 2: perfect expanding\\n            return true;\\n        }\\n    \\n        // collapsed!\\n        if ( cur == 2 || cur == 3 ) {\\n            // case 3\\n            return isPerfectCollapsing( ++cur, len, data );\\n        }\\n    \\n        if ( data[cur]+data[cur-4] >= data[cur-2] ) {                    // case 4/5\\n            if ( ++cur < len ) {\\n                if ( data[cur]+data[cur-4] >= data[cur-2] ) {            // case 4\\n                    return false;\\n                } else { return isPerfectCollapsing(++cur, len, data); } // case 5\\n            } else { return true; }\\n        } else { return isPerfectCollapsing(++cur, len, data); }         // case 6/7\\n    }\\n    \\n    bool isSelfCrossing( int *x, int xSize ) {\\n        return !isPerfect( x, xSize );\\n    }",
                "solutionTags": [],
                "code": "    //           =   a l l    c a s e s   =\\n    // \\n    //     case 1     case 2: expanding   case 3: collapsing\\n    //                     (global)           (local)\\n    //                  (not crossing)   (may not crossing)\\n    // \\n    //    <------+     +------------+      +---------+\\n    //           |     |            |      |         |\\n    //           |     |  +-----+   |      |  +---+  |\\n    //           |     |  |     |   |      |  |   |  :\\n    //           #     |  |     #   |      |  v   |  :\\n    //                 |  |         |      |      |  \\n    //                 |  +---------+      +------+  \\n    //                 |\\n    //                 +--------->\\n    // \\n    //     case 4: failed expanding                \\n    //      \\n    //      +----+\\n    //      |    |\\n    //      |  <----[2]----^     [2]: second failure\\n    //      |    #         |\\n    //      |             [1]    [1]: first  failure\\n    //      |              |\\n    //      +--------------+\\n    // \\n    //     case 5: failed expanding & then collapsing\\n    // \\n    //      +----+\\n    //      |    |\\n    //      |    |  +------+\\n    //      |    #  | [C]  |     [C]: may be perfectly collapsed\\n    //      |       +--->  |\\n    //      |              |\\n    //      +--------------+\\n    // \\n    //     case 6: failed expanding                \\n    // \\n    //         +---+\\n    //         |   |\\n    //         |   |\\n    //         |   #\\n    //         |\\n    //       <---[2]----+        [2]: second failure\\n    //         |        |\\n    //         |       [1]       [1]: first  failure\\n    //         |        |\\n    //         +--------+\\n    // \\n    //     case 7: failed expanding & then collapsing\\n    // \\n    //         +------+\\n    //         |      |\\n    //         |      #\\n    //         |\\n    //         |  +-----------+\\n    //         |  |  +-----+  |\\n    //         |  |  +-->  | [1] [1]: failure\\n    //         |  |        |  |\\n    //         |  +--------+  |\\n    //         +--------------+\\n    // \\n    //    *notice: case 3 = case 6 + case 7\\n    // \\n    //     case 8: docking!\\n    // \\n    //         +-------+\\n    //         |       |\\n    //         |       #\\n    //         |\\n    //         |       ^\\n    //         |       |\\n    //         +-------+\\n    // \\n    // #: starting point \\n    \\n    // case 3\\n    bool isPerfectCollapsing( int cur, int len, int *data )\\n    {\\n        while ( cur < len ) {\\n            if ( data[cur] < data[cur-2] ) {\\n                ++cur;\\n            } else { return false; }\\n        }\\n        return true;\\n    }\\n    \\n    bool isPerfect( int *data, int len )\\n    {\\n        // case 1\\n        if ( len <= 2 ) { return true; }\\n        // case 8\\n        if ( len >= 5 &&\\n             data[3]==data[1] &&\\n             data[2]<=data[0]+data[4] )\\n        {\\n            return false;\\n        }\\n    \\n        int cur = 2;\\n        while ( cur < len && data[cur] > data[cur-2] ) {\\n            ++cur;\\n        }\\n        if ( cur == len || cur == len-1 ) {\\n            // case 2: perfect expanding\\n            return true;\\n        }\\n    \\n        // collapsed!\\n        if ( cur == 2 || cur == 3 ) {\\n            // case 3\\n            return isPerfectCollapsing( ++cur, len, data );\\n        }\\n    \\n        if ( data[cur]+data[cur-4] >= data[cur-2] ) {                    // case 4/5\\n            if ( ++cur < len ) {\\n                if ( data[cur]+data[cur-4] >= data[cur-2] ) {            // case 4\\n                    return false;\\n                } else { return isPerfectCollapsing(++cur, len, data); } // case 5\\n            } else { return true; }\\n        } else { return isPerfectCollapsing(++cur, len, data); }         // case 6/7\\n    }\\n    \\n    bool isSelfCrossing( int *x, int xSize ) {\\n        return !isPerfect( x, xSize );\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3244854,
                "title": "335-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe algorithm checks three possible cases for each line of the path, starting from the 3rd line. If any of the cases is true, the function returns True, meaning the path crosses itself. If none of the cases is true after looping through all the lines, the function returns False, meaning the path does not cross itself.\\n\\nThe three cases are:\\n\\n1. The current line crosses the line 3 steps before it.\\n2. The current line crosses the line 4 steps before it.\\n3. The current line crosses the line 5 steps before it.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isSelfCrossing(self, x: List[int]) -> bool:\\n    # If there are less than 4 values in the array, the path can\\'t cross itself\\n    if len(x) <= 3:\\n      return False\\n\\n    # Loop through the array starting from the 3rd index\\n    for i in range(3, len(x)):\\n      # Case 1: current line crosses the line 3 steps before it\\n      #           _______\\n      #         |      |\\n      #         |      |\\n      # ________|______| <-- current line\\n      #         |          |\\n      #         |          |\\n      #         |__________| <-- line 3 steps before\\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\\n        return True\\n      \\n      # Case 2: current line crosses the line 4 steps before it\\n      #         _____\\n      #        |      |\\n      #        |      |\\n      #        |      |________\\n      #        |               |\\n      #        |               |\\n      #        |_______________| <-- current line\\n      #              line 4 steps before\\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\\n        return True\\n      \\n      # Case 3: current line crosses the line 5 steps before it\\n      #         ______\\n      #        |      |\\n      #        |      |\\n      #        |______| <-- line 5 steps before\\n      #               |\\n      #               |\\n      #         ______|_______\\n      #        |              |\\n      #        |              |\\n      #        |______________| <-- current line\\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\\n        return True\\n\\n    # If no crossing has been found, the path does not cross itself\\n    return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n  def isSelfCrossing(self, x: List[int]) -> bool:\\n    # If there are less than 4 values in the array, the path can\\'t cross itself\\n    if len(x) <= 3:\\n      return False\\n\\n    # Loop through the array starting from the 3rd index\\n    for i in range(3, len(x)):\\n      # Case 1: current line crosses the line 3 steps before it\\n      #           _______\\n      #         |      |\\n      #         |      |\\n      # ________|______| <-- current line\\n      #         |          |\\n      #         |          |\\n      #         |__________| <-- line 3 steps before\\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\\n        return True\\n      \\n      # Case 2: current line crosses the line 4 steps before it\\n      #         _____\\n      #        |      |\\n      #        |      |\\n      #        |      |________\\n      #        |               |\\n      #        |               |\\n      #        |_______________| <-- current line\\n      #              line 4 steps before\\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\\n        return True\\n      \\n      # Case 3: current line crosses the line 5 steps before it\\n      #         ______\\n      #        |      |\\n      #        |      |\\n      #        |______| <-- line 5 steps before\\n      #               |\\n      #               |\\n      #         ______|_______\\n      #        |              |\\n      #        |              |\\n      #        |______________| <-- current line\\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\\n        return True\\n\\n    # If no crossing has been found, the path does not cross itself\\n    return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262213,
                "title": "simplest-java-solution-with-text-explaintation",
                "content": "situation1:fourth line cross first line;like a rectangle\\nsituation2:fifth line meet first line;like a rectangle\\nsituation3:sixth line cross first line;like a capital letter L{\\n\\tx[i] represents the sixth line;\\n\\tx[i-2]must bigger than x[i-4], or it won\\'t cross or become situation 1,2;\\n\\tx[i-1]must smaller than x[i-3], or  it won\\'t cross or become situation 1,2;\\n\\tx[i-1]+x[i-5]must bigger than or equal to x[i-3],x[i]+x[i-4]must bigger than or equal to x[i-2] or it won\\'t cross or become situation 1,2;\\n}\\n\\n```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if(x.length<4)return false;\\n        for(int i=3;i<x.length;i++){\\n            if(x[i]>=x[i-2]&&x[i-1]<=x[i-3])return true;\\n            if(x.length>4&&i>3&&x[i-1]==x[i-3]&&(x[i]+x[i-4])>=x[i-2])return true;\\n            if(x.length>5&&i>4&&x[i-2]>x[i-4]&&x[i-1]<x[i-3]&&\\n               (x[i-5]+x[i-1])>=x[i-3]&&(x[i]+x[i-4])>=x[i-2])return true;  \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if(x.length<4)return false;\\n        for(int i=3;i<x.length;i++){\\n            if(x[i]>=x[i-2]&&x[i-1]<=x[i-3])return true;\\n            if(x.length>4&&i>3&&x[i-1]==x[i-3]&&(x[i]+x[i-4])>=x[i-2])return true;\\n            if(x.length>5&&i>4&&x[i-2]>x[i-4]&&x[i-1]<x[i-3]&&\\n               (x[i-5]+x[i-1])>=x[i-3]&&(x[i]+x[i-4])>=x[i-2])return true;  \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79184,
                "title": "my-java-solution",
                "content": "This problem reminds me of an old snake game where snake eats its own tail..\\n<p>It pretty clear that once x[i]<=x[i-2] the snake will become 'trapped' and eventually will eat itself. From there on we need to find conditions of when this happens. The easiest one is x[i]>=x[i-2]. The other 2 are a little tricker:<p>\\nFirst one  is when snake catches it's tail at 0 degree angle. For example [1,1,2,1,1] <p>\\nSecond one when it catches it's tail at 90 degree angle. For example  [1,1,2,2,1,1]\\n\\n\\n\\n    public boolean isSelfCrossing(int[] x) {\\n    \\tboolean snakeTrapped = false;\\n    \\tfor (int i=2;i<x.length;i++){\\n    \\t\\tif (snakeTrapped){\\n    \\t\\t     if (x[i]>=x[i-2])\\n    \\t\\t\\t    return true;\\n    \\t\\t\\t else if (i>=4 && x[i-1]==x[i-3] && x[i-4]+x[i]>=x[i-2])\\n    \\t\\t\\t     return true;\\n    \\t\\t\\t else if (i>=5 && x[i-3]-x[i-1]-x[i-5]<=0 && x[i-3]>x[i-5] && x[i]+x[i-4]>=x[i-2])\\n    \\t\\t\\t     return true;\\n    \\t\\t}\\n    \\t\\telse if (x[i]<=x[i-2])\\n    \\t\\t\\tsnakeTrapped = true;\\n    \\t}\\n    \\treturn false;\\n    }",
                "solutionTags": [],
                "code": "This problem reminds me of an old snake game where snake eats its own tail..\\n<p>It pretty clear that once x[i]<=x[i-2] the snake will become 'trapped' and eventually will eat itself. From there on we need to find conditions of when this happens. The easiest one is x[i]>=x[i-2]. The other 2 are a little tricker:<p>\\nFirst one  is when snake catches it's tail at 0 degree angle. For example [1,1,2,1,1] <p>\\nSecond one when it catches it's tail at 90 degree angle. For example  [1,1,2,2,1,1]\\n\\n\\n\\n    public boolean isSelfCrossing(int[] x) {\\n    \\tboolean snakeTrapped = false;\\n    \\tfor (int i=2;i<x.length;i++){\\n    \\t\\tif (snakeTrapped){\\n    \\t\\t     if (x[i]>=x[i-2])\\n    \\t\\t\\t    return true;\\n    \\t\\t\\t else if (i>=4 && x[i-1]==x[i-3] && x[i-4]+x[i]>=x[i-2])\\n    \\t\\t\\t     return true;\\n    \\t\\t\\t else if (i>=5 && x[i-3]-x[i-1]-x[i-5]<=0 && x[i-3]>x[i-5] && x[i]+x[i-4]>=x[i-2])\\n    \\t\\t\\t     return true;\\n    \\t\\t}\\n    \\t\\telse if (x[i]<=x[i-2])\\n    \\t\\t\\tsnakeTrapped = true;\\n    \\t}\\n    \\treturn false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 79185,
                "title": "a-simple-python-solution-with-explanation",
                "content": "This is based on dong.wang.1694's [second solution][1] with a little modification. \\n\\nThe basic idea is like this:\\n1) When expanding, we never collide. \\n\\n2) When shrinking, we collide when we go back too far. For example, if two steps ago, we went upward for 8, this time we can't go down for more than 7 or it is a collision.\\n\\n3) The tricky part is when transitioning from expanding to shrinking, we may get an early collision!!\\n\\n\\n    class Solution(object):\\n        def isSelfCrossing(self, x):\\n\\n            n = len(x)\\n            x.append(0.5)        # let x[-1] = 0.5\\n            if n < 4: return False\\n            grow = x[2] > x[0]\\n                \\n            for i in range(3,n):\\n                if not grow and x[i] >= x[i-2]: return True\\n                if grow and x[i] <= x[i-2]:\\n                    grow = False\\n                    if x[i] + x[i-4] >= x[i-2]:\\n                        x[i-1] -= x[i-3]\\n            return False\\n\\nGraph\\n    \\n                                              +------------+\\n        +---------+                           |            |\\n        |         |                           |            |\\n        |         |                           |            |\\n        |         |                           |            |\\n        |       i-4  <----+                   |            |\\n    i-2 |         |       |                   |            +\\n        |         |       |                   |\\n        |                 |i                  |\\n        |                 |                   |         <---------------+\\n        |                 |                   |                         |\\n        +---------+-------+                   |                         |\\n                  ^                           |                         |\\n                  |                           +-------------------------+\\n                  |\\n    \\n    \\n        x[i] + x[i-4] >= x[i-2]                  x[i] + x[i-4] < x[i-2]\\n        Then, possible early collision,          nothing has to be changed\\n        pretend we have started from\\n        the plus sign point\\n\\nwhen x[3] == x\\\\[1], we have to deal with a very special case. So we pretend we have started from a point 0.5 to the left of the origin making this case identical to what we have discussed above. \\n\\n            1\\n      +------------+\\n      |            |\\n      |            |\\n      |            |0\\n      |            |\\n      |            |\\n    2 |            |\\n      |            +\\n      |\\n      |\\n      |            ^\\n      |            |\\n      |            |\\n      +------------+\\n            3\\n\\n\\n  [1]: https://leetcode.com/discuss/88196/re-post-2-o-n-c-0ms-solutions\\n  [2]: https://leetcode.com/discuss/88075/java-o-n-logical-solution",
                "solutionTags": [
                    "Python"
                ],
                "code": "This is based on dong.wang.1694's [second solution][1] with a little modification. \\n\\nThe basic idea is like this:\\n1) When expanding, we never collide. \\n\\n2) When shrinking, we collide when we go back too far. For example, if two steps ago, we went upward for 8, this time we can't go down for more than 7 or it is a collision.\\n\\n3) The tricky part is when transitioning from expanding to shrinking, we may get an early collision!!\\n\\n\\n    class Solution(object):\\n        def isSelfCrossing(self, x):\\n\\n            n = len(x)\\n            x.append(0.5)        # let x[-1] = 0.5\\n            if n < 4: return False\\n            grow = x[2] > x[0]\\n                \\n            for i in range(3,n):\\n                if not grow and x[i] >= x[i-2]: return True\\n                if grow and x[i] <= x[i-2]:\\n                    grow = False\\n                    if x[i] + x[i-4] >= x[i-2]:\\n                        x[i-1] -= x[i-3]\\n            return False\\n\\nGraph\\n    \\n                                              +------------+\\n        +---------+                           |            |\\n        |         |                           |            |\\n        |         |                           |            |\\n        |         |                           |            |\\n        |       i-4  <----+                   |            |\\n    i-2 |         |       |                   |            +\\n        |         |       |                   |\\n        |                 |i                  |\\n        |                 |                   |         <---------------+\\n        |                 |                   |                         |\\n        +---------+-------+                   |                         |\\n                  ^                           |                         |\\n                  |                           +-------------------------+\\n                  |\\n    \\n    \\n        x[i] + x[i-4] >= x[i-2]                  x[i] + x[i-4] < x[i-2]\\n        Then, possible early collision,          nothing has to be changed\\n        pretend we have started from\\n        the plus sign point\\n\\nwhen x[3] == x\\\\[1], we have to deal with a very special case. So we pretend we have started from a point 0.5 to the left of the origin making this case identical to what we have discussed above. \\n\\n            1\\n      +------------+\\n      |            |\\n      |            |\\n      |            |0\\n      |            |\\n      |            |\\n    2 |            |\\n      |            +\\n      |\\n      |\\n      |            ^\\n      |            |\\n      |            |\\n      +------------+\\n            3\\n\\n\\n  [1]: https://leetcode.com/discuss/88196/re-post-2-o-n-c-0ms-solutions\\n  [2]: https://leetcode.com/discuss/88075/java-o-n-logical-solution",
                "codeTag": "Java"
            },
            {
                "id": 79160,
                "title": "5-lines-cpp-code-with-clear-logic",
                "content": "Basic observations:\\n1. No crossing is produced when the path keeps going either 'inward' or 'outward'.\\n2. A path without crossing is either one of the two above cases or a combination of both (an outward path transit into an inward path).\\n\\n    class Solution {\\n    public:\\n       bool isSelfCrossing(std::vector<int>& x) {\\n          // started 'outside', walk until 'inside' a rectangle\\n          int i; for(i=2; i<x.size()&&x[i]>x[i-2]; i++);\\n          // out->in transition step\\n          if( i>2 && x[i] >= x[i-2]-(i==3?0:x[i-4]) ) x[i-1] -= x[i-3];\\n          // we are inside a rectangle now, check for crossing\\n          for(i++; i<x.size()&&x[i]<x[i-2]; i++);\\n          // crossing detected if end is not reached\\n          return i<x.size();\\n       }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n       bool isSelfCrossing(std::vector<int>& x) {\\n          // started 'outside', walk until 'inside' a rectangle\\n          int i; for(i=2; i<x.size()&&x[i]>x[i-2]; i++);\\n          // out->in transition step\\n          if( i>2 && x[i] >= x[i-2]-(i==3?0:x[i-4]) ) x[i-1] -= x[i-3];\\n          // we are inside a rectangle now, check for crossing\\n          for(i++; i<x.size()&&x[i]<x[i-2]; i++);\\n          // crossing detected if end is not reached\\n          return i<x.size();\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 3490803,
                "title": "easiest-javascript-solution-with-more-optimization",
                "content": "```\\nPlease Give An Up-Vote If This Solution Helps You !!!\\n```\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code implements a solution to check whether a given set of points (represented as an array) form a self-crossing polygon or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the code is to traverse the points array and check if any line segments intersect with any previous line segments. The code starts by checking if the number of points is greater than 3, which is the minimum required to form a self-crossing polygon. If the number of points is less than or equal to 3, the code returns false indicating that no self-crossing is possible.\\n\\nThe code then traverses the points array and checks if the points are spiraling outward or inward. It maintains an index \\'i\\' which is initialized to 2, and then moves forward until the points are no longer spiraling outward. If the points are no longer spiraling outward, the code checks if they are spiraling inward. If they are, it checks if the current line segment intersects with any of the previous line segments. If it does, the code returns true indicating that a self-crossing has occurred. Otherwise, it continues to traverse the points array until the end and returns false indicating that no self-crossing has occurred.\\n\\n\\n# Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The code traverses the entire points array once, which takes `O(n)` time where n is the number of points in the array.\\n\\n- The code checks if the points are spiraling outward, which can take up to n-2 iterations in the worst case. Therefore, the time complexity of this operation is `O(n)`.\\n\\n- The code then checks if the points are spiraling inward, which can take up to n-4 iterations in the worst case. Therefore, the time complexity of this operation is also `O(n)`.\\n\\n- Finally, the code checks if the current line segment intersects with any of the previous line segments, which takes constant time.\\n\\nTherefore, the overall time complexity of the code is `O(n)`.\\n\\n# Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a single variable \\'i\\' to maintain the index of the current point, which takes constant space.\\n\\nTherefore, the space complexity of the code is `O(1)`.\\n\\n# Mind It\\nTherefore, both the time and space complexity of the code are constant with respect to the number of points.\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar isSelfCrossing = function(x) {\\n    if (x.length <= 3) {\\n            return false;\\n        }\\n        let i = 2;\\n        // keep spiraling outward\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        // transition from spiraling outward to spiraling inward\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        // keep spiraling inward\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nPlease Give An Up-Vote If This Solution Helps You !!!\\n```\n```\\n/**\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar isSelfCrossing = function(x) {\\n    if (x.length <= 3) {\\n            return false;\\n        }\\n        let i = 2;\\n        // keep spiraling outward\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        // transition from spiraling outward to spiraling inward\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        // keep spiraling inward\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1982519,
                "title": "python-o-n-o-1-method-time-beats-90",
                "content": "The basic idea is:\\n**To not touch itself, a spiral can only grow larger then grow smaller, but cannot grow smaller and then go larger.** Or, whenever a distance[i] <= distance[i - 2], all following distance[i] must < distance[i - 2] or the spiral will meet itself. This criterion is kinda like the pandora\\'s box so I will use this as a indicator.\\nBeside the basic requirement, there are two special cases at the first step after opening the pandora\\'s box which is even stricter, I will not talk too much in detail cuz they are kinda trivial but you can draw them and easily see why they are special.\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance) <= 3:\\n            return False\\n        i = 2\\n        pandora = float(\\'inf\\')\\n        while i < len(distance):\\n            if pandora == float(\\'inf\\') and distance[i] <= distance[i - 2]:#the pandora\\'s box is opened\\n                pandora = i\\n                i += 1\\n                continue\\n            if pandora != float(\\'inf\\'):\\n                if distance[i] >= distance[i - 2]:#general requirement\\n                    return True\\n                if pandora == 3 and i == 4:#special case type1\\n                    if distance[i - 1] == distance[i - 3]:\\n                        if distance[i] >= distance[i - 2] - distance[i - 4]:\\n                            return True\\n                if pandora >= 4 and i == pandora + 1:#special case type2\\n                    if distance[i - 1] >= distance[i - 3] - distance[i - 5]:\\n                        if distance[i] >= distance[i - 2] - distance[i - 4]:\\n                            return True \\n            i += 1\\n        return False",
                "solutionTags": [],
                "code": "The basic idea is:\\n**To not touch itself, a spiral can only grow larger then grow smaller, but cannot grow smaller and then go larger.** Or, whenever a distance[i] <= distance[i - 2], all following distance[i] must < distance[i - 2] or the spiral will meet itself. This criterion is kinda like the pandora\\'s box so I will use this as a indicator.\\nBeside the basic requirement, there are two special cases at the first step after opening the pandora\\'s box which is even stricter, I will not talk too much in detail cuz they are kinda trivial but you can draw them and easily see why they are special.\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance) <= 3:\\n            return False\\n        i = 2\\n        pandora = float(\\'inf\\')\\n        while i < len(distance):\\n            if pandora == float(\\'inf\\') and distance[i] <= distance[i - 2]:#the pandora\\'s box is opened\\n                pandora = i\\n                i += 1\\n                continue\\n            if pandora != float(\\'inf\\'):\\n                if distance[i] >= distance[i - 2]:#general requirement\\n                    return True\\n                if pandora == 3 and i == 4:#special case type1\\n                    if distance[i - 1] == distance[i - 3]:\\n                        if distance[i] >= distance[i - 2] - distance[i - 4]:\\n                            return True\\n                if pandora >= 4 and i == pandora + 1:#special case type2\\n                    if distance[i - 1] >= distance[i - 3] - distance[i - 5]:\\n                        if distance[i] >= distance[i - 2] - distance[i - 4]:\\n                            return True \\n            i += 1\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 993157,
                "title": "python-93-5-very-concise-and-understandable-solution-10-lines-of-code",
                "content": "```\\n\\n\\n# Written by : Dhruv_Vavliya\\n\\n# just think about 4,5,6 --length arrays \\ndef self_crossing(x):\\n    for i in range(3,len(x)):\\n\\n        if x[i-3]>=x[i-1] and x[i]>=x[i-2]:\\n            return True\\n        \\n        if i>=4:\\n            if x[i-3] == x[i-1] and x[i-2]<=(x[i-4]+x[i]):\\n                return True\\n\\n        if i>=5:\\n            if x[i-2]>=x[i-4] and x[i-3]>=x[i-1] and (x[i-5]+x[i-1])>=x[i-3] and (x[i-4]+x[i])>=x[i-2]:\\n                return True\\n\\n    return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n\\n# Written by : Dhruv_Vavliya\\n\\n# just think about 4,5,6 --length arrays \\ndef self_crossing(x):\\n    for i in range(3,len(x)):\\n\\n        if x[i-3]>=x[i-1] and x[i]>=x[i-2]:\\n            return True\\n        \\n        if i>=4:\\n            if x[i-3] == x[i-1] and x[i-2]<=(x[i-4]+x[i]):\\n                return True\\n\\n        if i>=5:\\n            if x[i-2]>=x[i-4] and x[i-3]>=x[i-1] and (x[i-5]+x[i-1])>=x[i-3] and (x[i-4]+x[i])>=x[i-2]:\\n                return True\\n\\n    return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 647656,
                "title": "c-diagrams-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        \\n        if (x.size() >= 5 && x[3] == x[1] && x[0]+x[4] >= x[2]) {\\n            /*\\n             Crossing in a loop:\\n                 2\\n             3 \\u250C\\u2500\\u2500\\u2500\\u2500\\u2510\\n               \\u2514\\u2500\\u2550\\u2550>\\u25181\\n               4  0  (overlapped)\\n            */\\n            return true;\\n        }\\n        \\n        for (int i = 3; i < x.size(); i++) {\\n            if (x[i] >= x[i-2] && x[i-1] <= x[i-3]) {\\n                /*\\n                 Case 1:\\n                    i-2\\n                 i-1\\u250C\\u2500\\u2510\\n                    \\u2514\\u2500\\u253C\\u2500>i\\n                     i-3\\n                */\\n                return true;\\n            } else if (i >= 5 && (x[i-4] <= x[i-2] && x[i] + x[i-4] >= x[i-2])\\n                    && (x[i-1] <= x[i-3] && x[i-1] + x[i-5] >= x[i-3])) {\\n                 /*\\n                  Case 2:\\n                    i-4\\n                    \\u250C\\u2500\\u2500\\u2510 \\n                    \\u2502i<\\u253C\\u2500\\u2510\\n                 i-3\\u2502 i-5\\u2502i-1\\n                    \\u2514\\u2500\\u2500\\u2500\\u2500\\u2518\\n                      i-2\\n                */\\n                 return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        \\n        if (x.size() >= 5 && x[3] == x[1] && x[0]+x[4] >= x[2]) {\\n            /*\\n             Crossing in a loop:\\n                 2\\n             3 \\u250C\\u2500\\u2500\\u2500\\u2500\\u2510\\n               \\u2514\\u2500\\u2550\\u2550>\\u25181\\n               4  0  (overlapped)\\n            */\\n            return true;\\n        }\\n        \\n        for (int i = 3; i < x.size(); i++) {\\n            if (x[i] >= x[i-2] && x[i-1] <= x[i-3]) {\\n                /*\\n                 Case 1:\\n                    i-2\\n                 i-1\\u250C\\u2500\\u2510\\n                    \\u2514\\u2500\\u253C\\u2500>i\\n                     i-3\\n                */\\n                return true;\\n            } else if (i >= 5 && (x[i-4] <= x[i-2] && x[i] + x[i-4] >= x[i-2])\\n                    && (x[i-1] <= x[i-3] && x[i-1] + x[i-5] >= x[i-3])) {\\n                 /*\\n                  Case 2:\\n                    i-4\\n                    \\u250C\\u2500\\u2500\\u2510 \\n                    \\u2502i<\\u253C\\u2500\\u2510\\n                 i-3\\u2502 i-5\\u2502i-1\\n                    \\u2514\\u2500\\u2500\\u2500\\u2500\\u2518\\n                      i-2\\n                */\\n                 return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533866,
                "title": "python-24ms-covers-corner-cases",
                "content": "Note the results from Leetcode offical console:\\n```\\nx = [0] # False\\nx = [0,0] # False\\nx = [0,0,0] # False\\nx = [0,0,0,0] # True\\n```\\n\\nMy solution:\\n```\\nclass Solution:\\n  def isSelfCrossing(self, x: List[int]) -> bool:\\n    \"\"\"     N\\n            ^\\n            |\\n      W <--- ---> E\\n            |\\n            v\\n            S\\n\\n    Self-Crossing Scenarios:\\n\\n              Case 1                  Case 2                  Case 3               \\n                b                       b                       b                  \\n       +----------------+      +----------------+      +----------------+          \\n       |                |      |                |      |                |          \\n       |                |      |                |      |                |          \\n     c |                | a  c |                | a  c |                | a        \\n       |                |      |                |      |                |    f     \\n       +--------------->|      |                |      |                | <----+   \\n                d       |      |                ^ e    |                |      | e \\n                               |                |      |                       |   \\n                               +----------------+      +-----------------------+   \\n                                        d                       d                  \\n    \"\"\"\\n    a, b, c, d, e, f = [-1] * 6\\n    for z in x:\\n      f, e, d, c, b, a = e, d, c, b, a, z\\n      if d >= 0 and (c <= a) and (d >= b):\\n        return True\\n      if e >= 0 and (c > a) and (d == b) and (e >= c - a):\\n        return True\\n      if f >= 0 and (c > a) and (d > b) and (e >= c - a and e <= c) and (f >= d - b):\\n        return True\\n    return False\\n```",
                "solutionTags": [],
                "code": "```\\nx = [0] # False\\nx = [0,0] # False\\nx = [0,0,0] # False\\nx = [0,0,0,0] # True\\n```\n```\\nclass Solution:\\n  def isSelfCrossing(self, x: List[int]) -> bool:\\n    \"\"\"     N\\n            ^\\n            |\\n      W <--- ---> E\\n            |\\n            v\\n            S\\n\\n    Self-Crossing Scenarios:\\n\\n              Case 1                  Case 2                  Case 3               \\n                b                       b                       b                  \\n       +----------------+      +----------------+      +----------------+          \\n       |                |      |                |      |                |          \\n       |                |      |                |      |                |          \\n     c |                | a  c |                | a  c |                | a        \\n       |                |      |                |      |                |    f     \\n       +--------------->|      |                |      |                | <----+   \\n                d       |      |                ^ e    |                |      | e \\n                               |                |      |                       |   \\n                               +----------------+      +-----------------------+   \\n                                        d                       d                  \\n    \"\"\"\\n    a, b, c, d, e, f = [-1] * 6\\n    for z in x:\\n      f, e, d, c, b, a = e, d, c, b, a, z\\n      if d >= 0 and (c <= a) and (d >= b):\\n        return True\\n      if e >= 0 and (c > a) and (d == b) and (e >= c - a):\\n        return True\\n      if f >= 0 and (c > a) and (d > b) and (e >= c - a and e <= c) and (f >= d - b):\\n        return True\\n    return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470000,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func isSelfCrossing(_ x: [Int]) -> Bool {\\n        var n = x.count\\n        if n <= 3 {\\n            return false\\n        }\\n        for i in 3..<n {\\n            if x[i] >= x[i-2] && x[i-1] <= x[i-3] {\\n                return true\\n            }\\n            if i >= 4 && x[i-1] == x[i-3] && x[i] + x[i-4] >= x[i-2] {\\n                return true\\n            }\\n            if i >= 5 && x[i-2] >= x[i-4] && x[i-3] >= x[i-1] && x[i] + x[i-4] >= x[i-2] && x[i-1] + x[i-5] >= x[i-3] {\\n                return true\\n            }\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isSelfCrossing(_ x: [Int]) -> Bool {\\n        var n = x.count\\n        if n <= 3 {\\n            return false\\n        }\\n        for i in 3..<n {\\n            if x[i] >= x[i-2] && x[i-1] <= x[i-3] {\\n                return true\\n            }\\n            if i >= 4 && x[i-1] == x[i-3] && x[i] + x[i-4] >= x[i-2] {\\n                return true\\n            }\\n            if i >= 5 && x[i-2] >= x[i-4] && x[i-3] >= x[i-1] && x[i] + x[i-4] >= x[i-2] && x[i-1] + x[i-5] >= x[i-3] {\\n                return true\\n            }\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503602,
                "title": "alternative-one-pass-solution-proofs",
                "content": "Let curve C be formed as in the problem, by joining segments s(i) of length d(i).\\n\\nThe intuition here is that a non-self-intersecting curve built this way is made of two spirals, first spiraling out with growing d(i), and then spiraling in, with decreasing d(i) (of course one of those spirals may be empty).\\n\\n**Theorem 1**:  Suppose C is not self-intersecting. Then either d(i+2)>d(i) for all i, or there exists I such that d(i+2)>d(i) for all i<I, d(I+2)<=d(I) and  d(i+2)<d(i) for all i>I. \\n \\n**Theorem 2**: If d(i+2)>d(i) for all i then C is not-self intersecting.\\nSuppose, on the other hand, there exists I such that d(i+2)>d(i)  for all i<I, d(I+2)<=d(I) and\\n  d(i+2)<d(i) for all i>I. Then, either (after possibly padding the path with 0-length segments so \\n  that both s(I-2) and s(I+3) exist) segments s(I-2) and s(I+3) intersect, or C is not self-intersecting.\\n  \\n  **Corollary**: If C is self-intersecting, then either exists  i such that  s(i) intersects s(i+3) or exists  i such that s(i) intersects s(i+5).\\n  \\n  Code from Theorems:\\n  \\n  \\n\\n  \\n\\t   for i in range(len(distance)-2):\\n\\t\\t\\t\\tif distance[i+2]<=distance[i]:\\n\\t\\t\\t\\t\\tI=i\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False \\n\\t\\tfor i in range(I+1, len(distance)-2):\\n\\t\\t\\tif distance[i+2]>=distance[i]:\\n\\t\\t\\t\\treturn True \\n\\t\\t\\t\\n    ls=[0]*6\\n\\tfor j in range(-2, 4):\\n\\t\\tif len(distance)-1>=I+j>=0:\\n\\t\\t\\tls[j+2]=distance[I+j]        \\n\\treturn ls[0]+ls[4]>=ls[2] and ls[1]+ls[5]>=ls[3]\\n\\n\\nYou can find \"code from Corollary\" in most of the solutions.\\n\\n#### Proofs:\\n\\n\\n**Proof sketch of Theorem 1**: Suppose C is not self-intersecting.  Consider the smallest I such that d(I+2)<=d(I) (if there is no such I we are done). Then, possibly after rotation we have the picture like this:\\n\\n>              |   \\n>          s(I)|        |\\n>              |_______ | s(I+2)\\n>                s(I+1)\\n\\n Thus if C is not self intersecting,  d(I+3)<d(I+1). By induction,  d(i+2)<d(i) for all i>I.\\n \\n**Proof sketch of Theorem 2**:  Consider the initial part of C, consisting of the first I+2\\n segments s(0),..., s(I+1). This part \"spirals out\" and is not self-intersecting. More strongly,\\n for any segment in this part, all previous segments lie to one side of that segment.\\n (If the segment is running up, the previous ones are to the left, if its running left the previous ones are below etc. This can be proved by induction on the segment number, see Bonus Lemma 1 below.) Thus the segment can never intersect any of the previous ones, and indeed that part of C is not self intersecting.\\n   \\n  If this is all of C (i.e. if d(i+2)>d(i) for all i), then the whole c is non-self intersecting.\\n   \\n   If not, then consider the \"end\" part of C consisting of the segments s(I+1),..., s(n), which \"spiral in\". By our assumption, it has d(i+2)<d(i), but  if we retrace that part backwards, as s(n), s(n-1), ... s(I+1),  will have d(i+2)>d(i) and will be like the initial part, except turning right instead of left. Thus this part of C is also not self-intersecting and has the \"segments after s(j) are to one side of s(j)\" property as well.\\n\\nThus we have a picture like so:\\n  \\n>           s(I-1) \\n>           _______              s(I+3)\\n>          |   ____|s(I-2)       _______\\n>      s(I)|   s(I-3)     s(I+4)|       |\\n>          |____________________________| s(I+2)\\n>                  s(I+1)\\n      \\n with initial part of C inside the box made by part of s(I), s(I-1), s(I-2) and s(I-3) and the \"end\" part of C inside the box made by part of s(I+1), s(I-2), s(I+3) and s(I+4). If these boxes don\\'t intersect, then C is not self intersecting. But these boxes intersect precisely when  s(I-2) intersects s(I+3).\\n    \\n**Proof of corollary**: We prove the contrapositive. Since s(i+3) intersects s(i) precisely when d(i+2)<=d(i) and d(i+3)>=d(i),\\n    if this does not happen, then either d(i+2)>d(i) always, or as soon as d(I+2)<=d(I) for the first time we have d(i+2)<d(i) for all i>I. Thus, in either case, we are in the situation of Theorem 2.  But then by that Theorem, if s(I-2) does not intersect s(I+3) the curve is not self-intersecting. The corollary follows.\\n      \\n    \\n----\\n\\n**Bonus**:\\n\\n**Lemma 1**: Suppose  d(i+2)>d(i) for all i<I. Then for any segment s(i) with i<I:\\n\\n0) if s(i) is going up (i.e. i%4==0), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly to the left of that segment \\n(i.e. the x-coordinates of all points are less than those of the points of s(i)).\\n\\n1) if s(i) is going left (i.e. i%4==1), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly below that segment \\n(i.e. the y-coordinates of all points are less than those of the points of s(i)).\\n\\n2) if s(i) is going down (i.e. i%4==2), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly to the left of that segment \\n(i.e. the x-coordinates of all points are bigger than those of the points of s(i)).\\n\\n3) if s(i) is going right (i.e. i%4==3), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly above that segment \\n(i.e. the y-coordinates of all points are greater than those of the points of s(i)).\\n\\n\\n\\n\\nProof:\\n\\n0) Consider  i=4k. \\nWhen k=0 there is nothing to prove. We proceed by induction on k. \\nTh segment s(4k) has x-coordinate x(k)=-d(2)+d(4)-d(6)+...+d(4k), which is \\nequal to x(k-1)+(-d(4k-2)+d(4k)). Since d(4k)> d(4k-2) by assumption, x(k)>x(k-1).\\nThen by induction hypothesis, all the segments up to s(4k-5) have x-coordinates below \\nx(k-1), so below x(k) as well. Thus we only need to worry about\\n s(4k-5), s(4k-4), s(4k-3) and s(4k-2). But all of these are (non-strictly) \\n to the left of s(4k-4), and so all their points have x-coordinates <=x(k-1)<x(k)\\n as well. This completes the proof.\\n \\n The proofs for all other cases are analogous (they are all \"rotated versions\" of each other.)\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Let curve C be formed as in the problem, by joining segments s(i) of length d(i).\\n\\nThe intuition here is that a non-self-intersecting curve built this way is made of two spirals, first spiraling out with growing d(i), and then spiraling in, with decreasing d(i) (of course one of those spirals may be empty).\\n\\n**Theorem 1**:  Suppose C is not self-intersecting. Then either d(i+2)>d(i) for all i, or there exists I such that d(i+2)>d(i) for all i<I, d(I+2)<=d(I) and  d(i+2)<d(i) for all i>I. \\n \\n**Theorem 2**: If d(i+2)>d(i) for all i then C is not-self intersecting.\\nSuppose, on the other hand, there exists I such that d(i+2)>d(i)  for all i<I, d(I+2)<=d(I) and\\n  d(i+2)<d(i) for all i>I. Then, either (after possibly padding the path with 0-length segments so \\n  that both s(I-2) and s(I+3) exist) segments s(I-2) and s(I+3) intersect, or C is not self-intersecting.\\n  \\n  **Corollary**: If C is self-intersecting, then either exists  i such that  s(i) intersects s(i+3) or exists  i such that s(i) intersects s(i+5).\\n  \\n  Code from Theorems:\\n  \\n  \\n\\n  \\n\\t   for i in range(len(distance)-2):\\n\\t\\t\\t\\tif distance[i+2]<=distance[i]:\\n\\t\\t\\t\\t\\tI=i\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False \\n\\t\\tfor i in range(I+1, len(distance)-2):\\n\\t\\t\\tif distance[i+2]>=distance[i]:\\n\\t\\t\\t\\treturn True \\n\\t\\t\\t\\n    ls=[0]*6\\n\\tfor j in range(-2, 4):\\n\\t\\tif len(distance)-1>=I+j>=0:\\n\\t\\t\\tls[j+2]=distance[I+j]        \\n\\treturn ls[0]+ls[4]>=ls[2] and ls[1]+ls[5]>=ls[3]\\n\\n\\nYou can find \"code from Corollary\" in most of the solutions.\\n\\n#### Proofs:\\n\\n\\n**Proof sketch of Theorem 1**: Suppose C is not self-intersecting.  Consider the smallest I such that d(I+2)<=d(I) (if there is no such I we are done). Then, possibly after rotation we have the picture like this:\\n\\n>              |   \\n>          s(I)|        |\\n>              |_______ | s(I+2)\\n>                s(I+1)\\n\\n Thus if C is not self intersecting,  d(I+3)<d(I+1). By induction,  d(i+2)<d(i) for all i>I.\\n \\n**Proof sketch of Theorem 2**:  Consider the initial part of C, consisting of the first I+2\\n segments s(0),..., s(I+1). This part \"spirals out\" and is not self-intersecting. More strongly,\\n for any segment in this part, all previous segments lie to one side of that segment.\\n (If the segment is running up, the previous ones are to the left, if its running left the previous ones are below etc. This can be proved by induction on the segment number, see Bonus Lemma 1 below.) Thus the segment can never intersect any of the previous ones, and indeed that part of C is not self intersecting.\\n   \\n  If this is all of C (i.e. if d(i+2)>d(i) for all i), then the whole c is non-self intersecting.\\n   \\n   If not, then consider the \"end\" part of C consisting of the segments s(I+1),..., s(n), which \"spiral in\". By our assumption, it has d(i+2)<d(i), but  if we retrace that part backwards, as s(n), s(n-1), ... s(I+1),  will have d(i+2)>d(i) and will be like the initial part, except turning right instead of left. Thus this part of C is also not self-intersecting and has the \"segments after s(j) are to one side of s(j)\" property as well.\\n\\nThus we have a picture like so:\\n  \\n>           s(I-1) \\n>           _______              s(I+3)\\n>          |   ____|s(I-2)       _______\\n>      s(I)|   s(I-3)     s(I+4)|       |\\n>          |____________________________| s(I+2)\\n>                  s(I+1)\\n      \\n with initial part of C inside the box made by part of s(I), s(I-1), s(I-2) and s(I-3) and the \"end\" part of C inside the box made by part of s(I+1), s(I-2), s(I+3) and s(I+4). If these boxes don\\'t intersect, then C is not self intersecting. But these boxes intersect precisely when  s(I-2) intersects s(I+3).\\n    \\n**Proof of corollary**: We prove the contrapositive. Since s(i+3) intersects s(i) precisely when d(i+2)<=d(i) and d(i+3)>=d(i),\\n    if this does not happen, then either d(i+2)>d(i) always, or as soon as d(I+2)<=d(I) for the first time we have d(i+2)<d(i) for all i>I. Thus, in either case, we are in the situation of Theorem 2.  But then by that Theorem, if s(I-2) does not intersect s(I+3) the curve is not self-intersecting. The corollary follows.\\n      \\n    \\n----\\n\\n**Bonus**:\\n\\n**Lemma 1**: Suppose  d(i+2)>d(i) for all i<I. Then for any segment s(i) with i<I:\\n\\n0) if s(i) is going up (i.e. i%4==0), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly to the left of that segment \\n(i.e. the x-coordinates of all points are less than those of the points of s(i)).\\n\\n1) if s(i) is going left (i.e. i%4==1), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly below that segment \\n(i.e. the y-coordinates of all points are less than those of the points of s(i)).\\n\\n2) if s(i) is going down (i.e. i%4==2), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly to the left of that segment \\n(i.e. the x-coordinates of all points are bigger than those of the points of s(i)).\\n\\n3) if s(i) is going right (i.e. i%4==3), then the part of the curve up to s(i)\\n(i.e. s(0), s(1), ... s(i-2)) lies strictly above that segment \\n(i.e. the y-coordinates of all points are greater than those of the points of s(i)).\\n\\n\\n\\n\\nProof:\\n\\n0) Consider  i=4k. \\nWhen k=0 there is nothing to prove. We proceed by induction on k. \\nTh segment s(4k) has x-coordinate x(k)=-d(2)+d(4)-d(6)+...+d(4k), which is \\nequal to x(k-1)+(-d(4k-2)+d(4k)). Since d(4k)> d(4k-2) by assumption, x(k)>x(k-1).\\nThen by induction hypothesis, all the segments up to s(4k-5) have x-coordinates below \\nx(k-1), so below x(k) as well. Thus we only need to worry about\\n s(4k-5), s(4k-4), s(4k-3) and s(4k-2). But all of these are (non-strictly) \\n to the left of s(4k-4), and so all their points have x-coordinates <=x(k-1)<x(k)\\n as well. This completes the proof.\\n \\n The proofs for all other cases are analogous (they are all \"rotated versions\" of each other.)\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1018879,
                "title": "java-arm-leg-and-swirl",
                "content": "A self-crossing state is determined by the current state and a few successive preceding states. The popular 3-scenario solution  checks the current state and different combinations of these preceding states (https://leetcode.com/problems/self-crossing/discuss/79131/Java-Oms-with-explanation).\\n\\nThe following solution uses a helper method to deal with \"array index out of bound\" issue. Meanwhile, it approaches the problem from a two-case perspective: 1) conditions that current segment crosses its second predecessor (term[i - 2]) and 2) conditions that the current one crosses its fourth predecessor (term[i - 4]). By resummarizing and reorganizing checking conditions, this solution attempts to make the code more general and conciser.\\n\\n```\\npublic boolean isSelfCrossing(int[] x) {\\n  boolean arm = false;\\n  boolean leg = false;\\n  \\n  for (int i = 2; i < x.length; ++i) {\\n    int a = f(x, i - 2) - f(x, i - 4);\\n\\tint b = f(x, i - 2);\\n\\t\\n\\tif (arm && x[i] >= b)          return true;  // cross [i - 2]\\n\\tif (leg && x[i] >= a && a > 0) return true;  // cross [i - 4]\\n\\t\\n\\tif (x[i] < a)       arm = true;\\n\\telse if (x[i] <= b) leg = true;\\n  }\\n  return false;\\n}\\n\\nprivate int f(int[] x, int index) {\\n  return (index < 0) ? 0 : x[index];\\n}\\n```\\n\\n**Notes:** \\n1. In each step of iteration, we only compare the current `x[i]` with `a` and `b`, where `b` is the length of its second predeccessor (`x[i - 2]`), and `a` is the difference between its second predecessor and fourth predecessor, that is`x[i - 2] - x[i - 4]`. \\n2. the first two statements within the for-loop block define `a` and `b`.\\n3. the last two statements check whether the current state goes into `arm` state or `leg` state.\\n4. the middle two statments check that once in `arm` or `leg` state, whether the current segment cross its predecessors.\\n5. the main purpose of this solution is to simplify complicated compound conditions in each `if()` statements.\\n6. `a`, `b`, `arm` and `leg` are not good identifiers. To make complicated concepts intuitive, `a` and `arm` represents \\'the shorter segment\\', `b` and `leg` represents \\'the longer ones\\'.\\n7. the condition `(a > 0)` in `if (leg && x[i] >= a && a > 0)` precludes the ***inward swirls***, it only checks the ***outward swirl***.\\n```\\n   // Asterisk(*) is the starting position of the paths\\n      ___ ___ ___                     ___ ___\\n     |    ___    |                   |       |   |\\n\\t |       |   |                   |       *   |\\n\\t |___ ___|   *                   |___ ___ ___|\\n   // inward swirl                   outward swirl\\n```\\n**Observations beyond the code:**\\n1. an `inward swirl` path can only hit its `inner walls`; an `outward swirl` can hit its `outer walls`\\n2. an `inward swirl` cannot change to `outward swirl` before crossing itself\\n3. an `outward swirl` can change to an `inward swirl` under some conditions\\n4. an `inward swirl` can only have `arm` state, and never `leg` state\\n5. an `outward swirl` can only have one step of `leg` state, its next step is either crossing its `outer walls` or change to the `arm` state\\n6. hitting or crossing the starting point is defined as crossing `outer walls`\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isSelfCrossing(int[] x) {\\n  boolean arm = false;\\n  boolean leg = false;\\n  \\n  for (int i = 2; i < x.length; ++i) {\\n    int a = f(x, i - 2) - f(x, i - 4);\\n\\tint b = f(x, i - 2);\\n\\t\\n\\tif (arm && x[i] >= b)          return true;  // cross [i - 2]\\n\\tif (leg && x[i] >= a && a > 0) return true;  // cross [i - 4]\\n\\t\\n\\tif (x[i] < a)       arm = true;\\n\\telse if (x[i] <= b) leg = true;\\n  }\\n  return false;\\n}\\n\\nprivate int f(int[] x, int index) {\\n  return (index < 0) ? 0 : x[index];\\n}\\n```\n```\\n   // Asterisk(*) is the starting position of the paths\\n      ___ ___ ___                     ___ ___\\n     |    ___    |                   |       |   |\\n\\t |       |   |                   |       *   |\\n\\t |___ ___|   *                   |___ ___ ___|\\n   // inward swirl                   outward swirl\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 708886,
                "title": "cannot-find-symbol-arrayutils-in-java",
                "content": "I would like to add a zero in front of the input array `x` by using ArrayUtils:\\n```\\nx = ArrayUtils.add(x, 0, 0);\\n```\\nHowever,  Leetcode gave an error saying: `cannot find symbol ArrayUtils`. Can anyone advise?",
                "solutionTags": [],
                "code": "```\\nx = ArrayUtils.add(x, 0, 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 504464,
                "title": "c-double-100-surpass-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if (x.size() < 5) {\\n            return x.size() >= 4 && x[0] >= x[2] and x[3] >= x[1];\\n        }\\n        if ((x[3] < x[1] && x[4] >= x[2]) || (x[3] == x[1] && x[0] + x[4] >= x[2])) {\\n            return true;\\n        }\\n        for (int i = 5; i < x.size(); i++) {\\n            if (x[i - 1] >= x[i - 3]) {\\n                continue;\\n            }\\n            if (x[i - 2] <= x[i - 4]) {\\n                if (x[i] < x[i - 2]) {\\n                    continue;\\n                } else {\\n                    return true;\\n                }\\n            }\\n            if (x[i - 1] + x[i - 5] >= x[i - 3] && x[i] + x[i - 4] >= x[i - 2]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if (x.size() < 5) {\\n            return x.size() >= 4 && x[0] >= x[2] and x[3] >= x[1];\\n        }\\n        if ((x[3] < x[1] && x[4] >= x[2]) || (x[3] == x[1] && x[0] + x[4] >= x[2])) {\\n            return true;\\n        }\\n        for (int i = 5; i < x.size(); i++) {\\n            if (x[i - 1] >= x[i - 3]) {\\n                continue;\\n            }\\n            if (x[i - 2] <= x[i - 4]) {\\n                if (x[i] < x[i - 2]) {\\n                    continue;\\n                } else {\\n                    return true;\\n                }\\n            }\\n            if (x[i - 1] + x[i - 5] >= x[i - 3] && x[i] + x[i - 4] >= x[i - 2]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349110,
                "title": "python-check-every-6-lines",
                "content": "For each line, just check its next 6 lines. If not crossed, then skip it and do the same \"6-line check\" on the next line. Because if a line doesn\\'t get crossed in 6 steps, then even if it get crossed later, some other line must get crossed before it.\\n\\n```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        n=len(x)\\n        def helper(i):\\n            steps=[x[k+i] if k+i<n else 0 for k in range(6)]\\n            if steps[3]<steps[1]:\\n                return False\\n            if steps[2]<=steps[0]:\\n                return True\\n            if steps[3]>=steps[1] and steps[4]>=(steps[2]-steps[0]) and steps[4]<=steps[2] and steps[5]>=(steps[3]-steps[1]):\\n                return True\\n            return False\\n        return any(helper(i) for i in range(n-3))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        n=len(x)\\n        def helper(i):\\n            steps=[x[k+i] if k+i<n else 0 for k in range(6)]\\n            if steps[3]<steps[1]:\\n                return False\\n            if steps[2]<=steps[0]:\\n                return True\\n            if steps[3]>=steps[1] and steps[4]>=(steps[2]-steps[0]) and steps[4]<=steps[2] and steps[5]>=(steps[3]-steps[1]):\\n                return True\\n            return False\\n        return any(helper(i) for i in range(n-3))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79134,
                "title": "java-simple-solution",
                "content": "```\\npublic class Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if(x.length < 4)    return false;\\n        int i = 0, base = 0;\\n        while(i+4 <= x.length){\\n            if(x[i] - x[i+2] >= 0 && x[i+1] - x[i+3] <= base)  return true;\\n            else if(x[i+1] - x[i+3] > base)     base = 0;\\n            else    base = x[i];\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if(x.length < 4)    return false;\\n        int i = 0, base = 0;\\n        while(i+4 <= x.length){\\n            if(x[i] - x[i+2] >= 0 && x[i+1] - x[i+3] <= base)  return true;\\n            else if(x[i+1] - x[i+3] > base)     base = 0;\\n            else    base = x[i];\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79135,
                "title": "c-simple-single-pass-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if(x.size() < 4) return false;\\n        bool bInc = x[2] > x[0];\\n        for(int i = 3; i < x.size(); i++){\\n            if(bInc){\\n                //increasing spiral\\n                if(x[i] <= x[i - 2]){\\n                    bInc = false;\\n                    //handle border\\n                    if(x[i] >= x[i - 2] - (i < 4 ? 0 : x[i-4]) )\\n                        x[i-1] -= x[i-3];\\n                }\\n            }\\n            else{\\n                //decreasing spiral\\n                if(x[i] >= x[i-2]) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if(x.size() < 4) return false;\\n        bool bInc = x[2] > x[0];\\n        for(int i = 3; i < x.size(); i++){\\n            if(bInc){\\n                //increasing spiral\\n                if(x[i] <= x[i - 2]){\\n                    bInc = false;\\n                    //handle border\\n                    if(x[i] >= x[i - 2] - (i < 4 ? 0 : x[i-4]) )\\n                        x[i-1] -= x[i-3];\\n                }\\n            }\\n            else{\\n                //decreasing spiral\\n                if(x[i] >= x[i-2]) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79152,
                "title": "very-clear-c",
                "content": "The key is to determine whether the circles are growing bigger or smaller. If it keeps growing bigger, then return false and if it keeps growing smaller, then return false. The only case when return true is when it converts from growing bigger to growing smaller, which is x[i] <= x[i-2]. Then whether it self-cross depends on x[i+1].\\n\\n```\\nbool isSelfCrossing(vector<int>& x){\\n\\n\\tif (x.size() < 4) return false;\\n\\n\\tint n = x.size();\\n\\n\\tbool larger = x[2] > x[0];\\n\\tfor (int i = 3; i < n;){\\n\\t\\tif (!larger){\\n\\t\\t\\tif (x[i] >= x[i - 2]) return true;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (x[i] <= x[i - 2]){\\n\\t\\t\\t\\tlarger = false;\\n\\t\\t\\t\\tif (x[i] == x[i - 2]) {\\n\\t\\t\\t\\t\\tx[i - 1] = x[i - 1] - x[i - 3];\\n\\t\\t\\t\\t}else if ( i-4>=0 && x[i] >= x[i-2] - x[i - 4]){\\n\\t\\t\\t\\t\\tx[i - 1] = x[i - 1] - x[i - 3];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t++i;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isSelfCrossing(vector<int>& x){\\n\\n\\tif (x.size() < 4) return false;\\n\\n\\tint n = x.size();\\n\\n\\tbool larger = x[2] > x[0];\\n\\tfor (int i = 3; i < n;){\\n\\t\\tif (!larger){\\n\\t\\t\\tif (x[i] >= x[i - 2]) return true;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (x[i] <= x[i - 2]){\\n\\t\\t\\t\\tlarger = false;\\n\\t\\t\\t\\tif (x[i] == x[i - 2]) {\\n\\t\\t\\t\\t\\tx[i - 1] = x[i - 1] - x[i - 3];\\n\\t\\t\\t\\t}else if ( i-4>=0 && x[i] >= x[i-2] - x[i - 4]){\\n\\t\\t\\t\\t\\tx[i - 1] = x[i - 1] - x[i - 3];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t++i;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 79170,
                "title": "easy-to-understand-0ms-c-solution-without-obscure-tricks",
                "content": "Consider the last three vertical segments of the path: let's assume that the pattern of them is \\u2191, \\u2193, \\u2191(the other pattern(\\u2193, \\u2191, \\u2193) is just the same if we put the path upside down), now we're going to check whether next horizontal segment will intersect with any segments on the path, then we got 2 possible situations in which the current horizontal segment have no chance of intersecting with other segments except for the last three vertical ones, that is to say we just need to keep the last three ones and check them one by one when we deal with the current horizontal segment. As for the vertical situation, all the conclusions are similar.\\n\\nMy C++ code:\\n\\n    class Solution {\\n        struct Seg {\\n            int start[2], end[2];\\n            Seg(int a[], int b[]) {\\n                start[0] = a[0];\\n                start[1] = a[1];\\n                end[0] = b[0];\\n                end[1] = b[1];\\n            }\\n            bool Intersect(Seg &other) {\\n                if (this->start[0] == this->end[0]) return other.Intersect(*this);\\n                int left = this->start[0], right = this->end[0];\\n                if (left > right) swap(left, right);\\n                int up = other.start[1], down = other.end[1];\\n                if (up < down) swap(up, down);\\n                return this->start[1] >= down && this->start[1] <= up &&\\n                       other.start[0] >= left && other.start[0] <= right;\\n            }\\n        };\\n    public:\\n        bool isSelfCrossing(vector<int>& x) {\\n            deque<Seg> segs[2];\\n            int cur[2] = {0, 0};\\n            int direction = 0;\\n            int move[4][2] = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n            for (int step: x) {\\n                int next[2];\\n                next[0] = cur[0] + step * move[direction][0];\\n                next[1] = cur[1] + step * move[direction][1];\\n                if (next[0] == next[1] && next[1] == 0) return true;\\n                Seg seg(cur, next);\\n                if (segs[1-(direction%2)].size() >= 2 && seg.Intersect(segs[1-(direction%2)][0])) return true;\\n                if (segs[1-(direction%2)].size() >= 3 && seg.Intersect(segs[1-(direction%2)][1])) return true;\\n                segs[direction%2].push_back(seg);\\n                if (segs[direction%2].size() > 3) segs[direction%2].pop_front();\\n                direction = (direction + 1) % 4;\\n                cur[0] = next[0];\\n                cur[1] = next[1];\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        struct Seg {\\n            int start[2], end[2];\\n            Seg(int a[], int b[]) {\\n                start[0] = a[0];\\n                start[1] = a[1];\\n                end[0] = b[0];\\n                end[1] = b[1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3231786,
                "title": "explained-c-o-n-time-and-o-1-space-beats-99-on-time-and-memory-spiral-approach",
                "content": "# Intuition\\nYou have to realize that this is spiral movement. There can be two kinds of spiral movement. One in which the spiral can keep growing outward. Each move is larger than the previous and we spiral outward. The other is inward sprial.\\n\\nOutward spiral can go transition to invard spiral if one of the moves is not large enough. Inward spiral can never become an outward spiral.\\n\\n# Approach\\n\\nAfter first 3 moves, you have to see if this is going to start as an outward spiral or inward spiral. Handle outward spiral first. Break out of the movement loop if we transition to inward spiral. Then handle inward spiral.\\n\\nAt all times, we keep track of our walls on left, up, right and down side. We need to check against these walls based on the kind of spiral we are in.\\n\\nWhen we transition from outward to inward spiral we need to carefully adjust one of the walls (see code).\\n\\nWe need to handle an edge case of visiting (0, 0) **on** the 5th move since this walls approach doesn\\'t handle that.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n#include <assert.h>\\n\\nstatic const int xMove[4] = {0, -1, 0, 1};\\nstatic const int yMove[4] = {1, 0, -1, 0};\\n\\nvoid move(int& x, int& y, int dis, int& cur) {\\n    x += xMove[cur] * dis;\\n    y += yMove[cur] * dis;\\n    cur = (cur+1)%4;\\n    return;\\n}\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int x = 0, y = 0, cur = 0, i = 0, n = distance.size();\\n        if (n <= 3) return false;\\n\\n        int limits[4]; // right, up, left, down\\n        limits[cur] = 0;\\n        move(x, y, distance[i++], cur); // moved up.\\n        limits[cur] = y;\\n        move(x, y, distance[i++], cur); // moved left.\\n        limits[cur] = x;\\n        move(x, y, distance[i++], cur); // moved down.\\n        limits[cur] = y;\\n        if (y < 0) {\\n            // Outward spiral. We can\\'t hit limits here.\\n            while (i < n) {\\n                move(x, y, distance[i++], cur);\\n                // Did we move past our limit?\\n                bool inward = false;\\n                switch (cur) {\\n                    case 0: // moved right.\\n                        inward = x <= limits[cur];\\n                        limits[cur] = x;\\n                        break;\\n                    case 1: // moved up.\\n                        inward = y <= limits[cur];\\n                        limits[cur] = y;\\n                        break;\\n                    case 2: // moved left.\\n                        inward = x >= limits[cur];\\n                        limits[cur] = x;\\n                        break;\\n                    case 3: // moved down.\\n                        inward = y >= limits[cur];\\n                        limits[cur] = y;\\n                        break;\\n                    default:\\n                        assert(false);\\n                }\\n                if (inward) {\\n                    // Correct the limits.\\n                    if (i > 4) {\\n                        switch (cur) {\\n                            case 0: // moved right.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = y + distance[i-2] - distance[i-4];\\n                                break;\\n                            case 1: // moved up.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = x - distance[i-2] + distance[i-4];\\n                                break;\\n                            case 2: // moved left.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = y - distance[i-2] + distance[i-4];\\n                                break;\\n                            case 3: // moved down.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = x + distance[i-2] - distance[i-4];\\n                                break;\\n                            default:\\n                                assert(false);\\n                        }\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        // Inward spiral.\\n        while (i < n) {\\n            move(x, y, distance[i++], cur);\\n            // Did we move past our limit?\\n            bool crossed = false;\\n            switch (cur) {\\n                case 0: // moved right.\\n                    crossed = x >= limits[cur];\\n                    limits[cur] = x;\\n                    break;\\n                case 1: // moved up.\\n                    crossed = y >= limits[cur];\\n                    limits[cur] = y;\\n                    break;\\n                case 2: // moved left.\\n                    crossed = x <= limits[cur];\\n                    limits[cur] = x;\\n                    break;\\n                case 3: // moved down.\\n                    crossed = y <= limits[cur];\\n                    limits[cur] = y;\\n                    break;\\n                default:\\n                    assert(false);\\n            }\\n            if (crossed) return true;\\n            if (x == 0 && y == 0) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <assert.h>\\n\\nstatic const int xMove[4] = {0, -1, 0, 1};\\nstatic const int yMove[4] = {1, 0, -1, 0};\\n\\nvoid move(int& x, int& y, int dis, int& cur) {\\n    x += xMove[cur] * dis;\\n    y += yMove[cur] * dis;\\n    cur = (cur+1)%4;\\n    return;\\n}\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int x = 0, y = 0, cur = 0, i = 0, n = distance.size();\\n        if (n <= 3) return false;\\n\\n        int limits[4]; // right, up, left, down\\n        limits[cur] = 0;\\n        move(x, y, distance[i++], cur); // moved up.\\n        limits[cur] = y;\\n        move(x, y, distance[i++], cur); // moved left.\\n        limits[cur] = x;\\n        move(x, y, distance[i++], cur); // moved down.\\n        limits[cur] = y;\\n        if (y < 0) {\\n            // Outward spiral. We can\\'t hit limits here.\\n            while (i < n) {\\n                move(x, y, distance[i++], cur);\\n                // Did we move past our limit?\\n                bool inward = false;\\n                switch (cur) {\\n                    case 0: // moved right.\\n                        inward = x <= limits[cur];\\n                        limits[cur] = x;\\n                        break;\\n                    case 1: // moved up.\\n                        inward = y <= limits[cur];\\n                        limits[cur] = y;\\n                        break;\\n                    case 2: // moved left.\\n                        inward = x >= limits[cur];\\n                        limits[cur] = x;\\n                        break;\\n                    case 3: // moved down.\\n                        inward = y >= limits[cur];\\n                        limits[cur] = y;\\n                        break;\\n                    default:\\n                        assert(false);\\n                }\\n                if (inward) {\\n                    // Correct the limits.\\n                    if (i > 4) {\\n                        switch (cur) {\\n                            case 0: // moved right.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = y + distance[i-2] - distance[i-4];\\n                                break;\\n                            case 1: // moved up.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = x - distance[i-2] + distance[i-4];\\n                                break;\\n                            case 2: // moved left.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = y - distance[i-2] + distance[i-4];\\n                                break;\\n                            case 3: // moved down.\\n                                if (distance[i-1] + distance[i-5] >= distance[i-3])\\n                                    limits[(cur+1)%4] = x + distance[i-2] - distance[i-4];\\n                                break;\\n                            default:\\n                                assert(false);\\n                        }\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        // Inward spiral.\\n        while (i < n) {\\n            move(x, y, distance[i++], cur);\\n            // Did we move past our limit?\\n            bool crossed = false;\\n            switch (cur) {\\n                case 0: // moved right.\\n                    crossed = x >= limits[cur];\\n                    limits[cur] = x;\\n                    break;\\n                case 1: // moved up.\\n                    crossed = y >= limits[cur];\\n                    limits[cur] = y;\\n                    break;\\n                case 2: // moved left.\\n                    crossed = x <= limits[cur];\\n                    limits[cur] = x;\\n                    break;\\n                case 3: // moved down.\\n                    crossed = y <= limits[cur];\\n                    limits[cur] = y;\\n                    break;\\n                default:\\n                    assert(false);\\n            }\\n            if (crossed) return true;\\n            if (x == 0 && y == 0) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2960837,
                "title": "python-95-no-math-just-space-for-time-make-it-an-easy-problem",
                "content": "# Intuition\\r\\nSince the problem scale is not very large, why not exchange space for time?\\r\\n\\r\\n# Approach\\r\\nkeep track of every single points we pass throught\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n$$O(nm)$$\\r\\n\\r\\n- Space complexity:\\r\\n$$O(nm)$$\\r\\n\\r\\n# Code\\r\\n```\\r\\nfrom operator import sub\\r\\nMOVE = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\r\\nclass Solution:\\r\\n    def isSelfCrossing(self, distance):\\r\\n        return self.space_4_time(distance)\\r\\n\\r\\n    def space_4_time(self, distance):\\r\\n        if all(map(sub, distance[1:], distance[:-1])): return False  # spiral out\\r\\n\\r\\n        pos, visit = (0, 0), set([(0, 0)])\\r\\n\\r\\n        for idx, length in enumerate(distance):\\r\\n            dx, dy = MOVE[idx % 4]  # 0n1w2s3e\\r\\n            for _ in range(length):\\r\\n                pos = (pos[0] + dx, pos[1] + dy)\\r\\n                if pos in visit: return True\\r\\n                visit.add(pos)\\r\\n        return False\\r\\n\\r\\n    def math(self, x):\\r\\n        \\'\\'\\' it\\'s not about coordinates, it\\'s only about previous six line\\'s length \\'\\'\\'\\r\\n        L = len(x)\\r\\n        if L < 4: return False\\r\\n\\r\\n        l1, l2, l3, l4, l5, l6 = x[2], x[1], x[0], 0, 0, 0\\r\\n        for i in range(3, L):\\r\\n            l1, l2, l3, l4, l5, l6 = x[i], l1, l2, l3, l4, l5  # rotation to get equivalent six line\\r\\n\\r\\n            if l4 >= l2 and l1 >= l3: return True  # 4 lines, shape like: \\'4\\'\\r\\n            if l4 == l2 and (l1 + l5) >= l3: return True  # 5 lines, shape like: \\'O\\'\\r\\n            if (l6 + l2) >= l4 >= l2 and (l5 + l1) >= l3 >= l5: return True  # 6 lines, shape like \\'L\\'\\r\\n        return False\\r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\r\\nfrom operator import sub\\r\\nMOVE = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\r\\nclass Solution:\\r\\n    def isSelfCrossing(self, distance):\\r\\n        return self.space_4_time(distance)\\r\\n\\r\\n    def space_4_time(self, distance):\\r\\n        if all(map(sub, distance[1:], distance[:-1])): return False  # spiral out\\r\\n\\r\\n        pos, visit = (0, 0), set([(0, 0)])\\r\\n\\r\\n        for idx, length in enumerate(distance):\\r\\n            dx, dy = MOVE[idx % 4]  # 0n1w2s3e\\r\\n            for _ in range(length):\\r\\n                pos = (pos[0] + dx, pos[1] + dy)\\r\\n                if pos in visit: return True\\r\\n                visit.add(pos)\\r\\n        return False\\r\\n\\r\\n    def math(self, x):\\r\\n        \\'\\'\\' it\\'s not about coordinates, it\\'s only about previous six line\\'s length \\'\\'\\'\\r\\n        L = len(x)\\r\\n        if L < 4: return False\\r\\n\\r\\n        l1, l2, l3, l4, l5, l6 = x[2], x[1], x[0], 0, 0, 0\\r\\n        for i in range(3, L):\\r\\n            l1, l2, l3, l4, l5, l6 = x[i], l1, l2, l3, l4, l5  # rotation to get equivalent six line\\r\\n\\r\\n            if l4 >= l2 and l1 >= l3: return True  # 4 lines, shape like: \\'4\\'\\r\\n            if l4 == l2 and (l1 + l5) >= l3: return True  # 5 lines, shape like: \\'O\\'\\r\\n            if (l6 + l2) >= l4 >= l2 and (l5 + l1) >= l3 >= l5: return True  # 6 lines, shape like \\'L\\'\\r\\n        return False\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517599,
                "title": "python-three-cases",
                "content": "This is an implementation of a solution provided [here](https://leetcode.com/problems/self-crossing/discuss/79141/Another-python...).\\n\\n**Solution**:\\nBelow are three configurations such that a series of lines will cross itself. The orentiation doesn\\'t of lines does not matter. Thus, check if a series of lines match one of the three configurations. If yes, return True. Else, continue to the next line.\\n\\n```\\n    Case 1                  Case 2                  Case 2\\n                c                       d                       e\\n       +----------------+      +----------------+      +----------------+\\n       |                |      |                |      |                |\\n       |                |      |                |      |                |\\n     b |                | d  c |                | e  d |                | f\\n       |                |      |                |      |                |    a\\n       +--------------->|      |                |      |                | <----+\\n                a       |      |                ^ a    |                |      | b\\n                               |                |      |                       |\\n                               +----------------+      +-----------------------+\\n                                        b                       c\\n```\\n\\n**Complexity**:\\n    Time: O(n)\\n    Space: O(1)\\n\\t\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: list[int]) -> bool:\\n\\n        # Initialize the latest 6 lines to 0\\n        a = b = c = d = e = f = 0\\n\\n        for n in distance:\\n            f, e, d, c, b, a = e, d, c, b, a, n\\n\\n            # Case 1: 4 lines configuration that can cross iself\\n            if d > 0 and c <= a and b <= d:\\n                return True\\n\\n            # Case 2: 5 lines configuration that can cross iself\\n            if e > 0 and b == d and c <= a + e:\\n                return True\\n\\n            # Case 3: 6 lines configuration that can cross iself\\n            if (\\n                f > 0\\n                and c >= a\\n                and c >= e\\n                and c <= a + e\\n                and d >= b\\n                and d >= f\\n                and d <= b + f\\n            ):\\n                return True\\n                \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n    Case 1                  Case 2                  Case 2\\n                c                       d                       e\\n       +----------------+      +----------------+      +----------------+\\n       |                |      |                |      |                |\\n       |                |      |                |      |                |\\n     b |                | d  c |                | e  d |                | f\\n       |                |      |                |      |                |    a\\n       +--------------->|      |                |      |                | <----+\\n                a       |      |                ^ a    |                |      | b\\n                               |                |      |                       |\\n                               +----------------+      +-----------------------+\\n                                        b                       c\\n```\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: list[int]) -> bool:\\n\\n        # Initialize the latest 6 lines to 0\\n        a = b = c = d = e = f = 0\\n\\n        for n in distance:\\n            f, e, d, c, b, a = e, d, c, b, a, n\\n\\n            # Case 1: 4 lines configuration that can cross iself\\n            if d > 0 and c <= a and b <= d:\\n                return True\\n\\n            # Case 2: 5 lines configuration that can cross iself\\n            if e > 0 and b == d and c <= a + e:\\n                return True\\n\\n            # Case 3: 6 lines configuration that can cross iself\\n            if (\\n                f > 0\\n                and c >= a\\n                and c >= e\\n                and c <= a + e\\n                and d >= b\\n                and d >= f\\n                and d <= b + f\\n            ):\\n                return True\\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152629,
                "title": "no-memory-o-n-3",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance)<4:\\n            return False\\n        for d in range(3,len(distance)):\\n            if (distance[d-1]-distance[d-3]<1 and distance[d]>=distance[d-2]) or (d>3 and distance[d-1]-distance[d-3]==0 and distance[d]+distance[d-4]>=distance[d-2]) or (d>4 and distance[d-1]+distance[d-5]>=distance[d-3] and distance[d-1]<=distance[d-3] and distance[d]+distance[d-4]>=distance[d-2] and distance[d-2]>=distance[d-4]):\\n                return True\\n        return False\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance)<4:\\n            return False\\n        for d in range(3,len(distance)):\\n            if (distance[d-1]-distance[d-3]<1 and distance[d]>=distance[d-2]) or (d>3 and distance[d-1]-distance[d-3]==0 and distance[d]+distance[d-4]>=distance[d-2]) or (d>4 and distance[d-1]+distance[d-5]>=distance[d-3] and distance[d-1]<=distance[d-3] and distance[d]+distance[d-4]>=distance[d-2] and distance[d-2]>=distance[d-4]):\\n                return True\\n        return False\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1959315,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n    class Solution {\\n\\n    public boolean isSelfCrossing(int[] x) {\\n\\tboolean arm = false;\\n\\tboolean leg = false;\\n    for (int i = 2; i < x.length; ++i) {\\n    int a = f(x, i - 2) - f(x, i - 4);\\n\\tint b = f(x, i - 2);\\n\\t\\n\\tif (arm && x[i] >= b)          return true;  // cross [i - 2]\\n\\tif (leg && x[i] >= a && a > 0) return true;  // cross [i - 4]\\n\\t\\n\\tif (x[i] < a)       arm = true;\\n\\telse if (x[i] <= b) leg = true;\\n\\t}\\n\\treturn false;\\n\\t}\\n\\tprivate int f(int[] x, int index) {\\n\\treturn (index < 0) ? 0 : x[index];\\n\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean isSelfCrossing(int[] x) {\\n\\tboolean arm = false;\\n\\tboolean leg = false;\\n    for (int i = 2; i < x.length; ++i) {\\n    int a = f(x, i - 2) - f(x, i - 4);\\n\\tint b = f(x, i - 2);\\n\\t\\n\\tif (arm && x[i] >= b)          return true;  // cross [i - 2]\\n\\tif (leg && x[i] >= a && a > 0) return true;  // cross [i - 4]\\n\\t\\n\\tif (x[i] < a)       arm = true;\\n\\telse if (x[i] <= b) leg = true;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1566430,
                "title": "16ms-18mb-o-n-solution-with-explanations",
                "content": "This problem drove me crazy, so much time spent on it :) The solution could be more generic but It works in linear time... The idea is to start by incrementing `i` until the path stops to expand. Then, there is three cases :\\n* 1)  `i` is less than `4`. Then we just have to verify the the distances are decreasing. For example :\\n\\n```text\\n__ __ __\\n|      |\\n       |\\n\\t   *\\n\\t   \\nwhere * is the origin\\n```\\nHere, the distance stops to increase at `i = 2`. The only possibility that there is a self-crossing therefore is that `distance[i - 2] < distance[i]`\\n* 2) I added a special case for the loop path cases if `i == 4`...\\n* 3) To understand the last case, see following image. This is a bit tricky and not so elegant, I have to admit  :\\n![image](https://user-images.githubusercontent.com/36661586/140738703-18ab1c6f-c874-467f-a04d-620143b0bf1e.png)\\nHere, the distances stop to increase at `i = 10`. Then we check that the next segment does not cross the \"first spiral\". If so, we are back with the same logic as the first case and check that the distances are decreasing..\\n\\nI know the code could be better, but I hope it may be helpful :)\\n```\\nclass Solution {\\n    \\npublic:\\n    \\n    bool isSelfCrossing(vector<int>& distance) {\\n    \\n        int n = distance.size(); \\n        \\n        // no chance that there is a self crossing if less than 3 segments\\n        if(n < 2) return false;\\n        \\n        // increment i as long as distance increases (spiral)\\n        int i = 2;\\n        while(i < n && distance[i] >= distance[i - 2]) i++;\\n        \\n        // since distance is no more increasing, it has to decrease\\n        if(i < 4) {\\n            \\n            while(i < n && distance[i] < distance[i - 2]) i++;\\n            \\n            if(i != n) return true;\\n            \\n        } else {\\n            \\n            // in case of loop path that returns to (0, 0)\\n            if(n == 4) {\\n                \\n                if(distance[i - 1] == distance[i - 3] && distance[i - 2] == distance[i - 4]) return true;\\n                \\n            } else {\\n            \\n                if(i < n - 1) i++;\\n\\n                if(i < n && distance[i - 2] - distance[i - 4] <= distance[i]) {\\n                    \\n                    if(i >= 5) {\\n                        \\n                        if(distance[i - 3] - distance[i - 1] <= distance[i - 5]) {\\n                            return true;\\n                        }\\n                        \\n                    } else {\\n                        return true;\\n                    }\\n                }\\n\\n                // same logic, distances have to decrease\\n                while(i < n && distance[i] < distance[i - 2]) i++;\\n                if(i != n)  \\n                    return true;                 \\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```text\\n__ __ __\\n|      |\\n       |\\n\\t   *\\n\\t   \\nwhere * is the origin\\n```\n```\\nclass Solution {\\n    \\npublic:\\n    \\n    bool isSelfCrossing(vector<int>& distance) {\\n    \\n        int n = distance.size(); \\n        \\n        // no chance that there is a self crossing if less than 3 segments\\n        if(n < 2) return false;\\n        \\n        // increment i as long as distance increases (spiral)\\n        int i = 2;\\n        while(i < n && distance[i] >= distance[i - 2]) i++;\\n        \\n        // since distance is no more increasing, it has to decrease\\n        if(i < 4) {\\n            \\n            while(i < n && distance[i] < distance[i - 2]) i++;\\n            \\n            if(i != n) return true;\\n            \\n        } else {\\n            \\n            // in case of loop path that returns to (0, 0)\\n            if(n == 4) {\\n                \\n                if(distance[i - 1] == distance[i - 3] && distance[i - 2] == distance[i - 4]) return true;\\n                \\n            } else {\\n            \\n                if(i < n - 1) i++;\\n\\n                if(i < n && distance[i - 2] - distance[i - 4] <= distance[i]) {\\n                    \\n                    if(i >= 5) {\\n                        \\n                        if(distance[i - 3] - distance[i - 1] <= distance[i - 5]) {\\n                            return true;\\n                        }\\n                        \\n                    } else {\\n                        return true;\\n                    }\\n                }\\n\\n                // same logic, distances have to decrease\\n                while(i < n && distance[i] < distance[i - 2]) i++;\\n                if(i != n)  \\n                    return true;                 \\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1236841,
                "title": "worked-but-couldn-t-pass-the-time-limit-exceeded",
                "content": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        directions = [\\'up\\', \\'left\\', \\'down\\', \\'right\\']\\n        dirIndex = 0\\n        points = [[0,0]]\\n        count = 0\\n        for i in range(len(distance)):\\n            newPoint_x = points[len(points)-1][0]\\n            newPoint_y = points[len(points)-1][1]\\n            for j in range(distance[i]):\\n                if i % 4 == 0:\\n                    count += 1\\n                if directions[dirIndex] == \\'up\\':\\n                    newPoint_x += 1\\n                elif directions[dirIndex] == \\'left\\':\\n                    newPoint_y -= 1\\n                elif directions[dirIndex] == \\'down\\':\\n                    newPoint_x -= 1\\n                elif directions[dirIndex] == \\'right\\':\\n                    newPoint_y += 1\\n                newPoint = [newPoint_x, newPoint_y]\\n                for point in points:\\n                    if newPoint == point:\\n                        return True\\n                points.append(newPoint)\\n            if i != 0 and i % 3 == 0:\\n                points = points[count-1:]\\n                count = 0\\n            dirIndex += 1\\n            if dirIndex == len(directions):\\n                dirIndex = 0\\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        directions = [\\'up\\', \\'left\\', \\'down\\', \\'right\\']\\n        dirIndex = 0\\n        points = [[0,0]]\\n        count = 0\\n        for i in range(len(distance)):\\n            newPoint_x = points[len(points)-1][0]\\n            newPoint_y = points[len(points)-1][1]\\n            for j in range(distance[i]):\\n                if i % 4 == 0:\\n                    count += 1\\n                if directions[dirIndex] == \\'up\\':\\n                    newPoint_x += 1\\n                elif directions[dirIndex] == \\'left\\':\\n                    newPoint_y -= 1\\n                elif directions[dirIndex] == \\'down\\':\\n                    newPoint_x -= 1\\n                elif directions[dirIndex] == \\'right\\':\\n                    newPoint_y += 1\\n                newPoint = [newPoint_x, newPoint_y]\\n                for point in points:\\n                    if newPoint == point:\\n                        return True\\n                points.append(newPoint)\\n            if i != 0 and i % 3 == 0:\\n                points = points[count-1:]\\n                count = 0\\n            dirIndex += 1\\n            if dirIndex == len(directions):\\n                dirIndex = 0\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062118,
                "title": "c-breaking-down-the-loops-into-expanding-and-contracting-modes",
                "content": "We have two modes to keep track of. Initially, we are in the expanding mode and we stay in this mode as long as the previous move in the same axis is shorter than the current mode.\\nThe other is the contracting mode. When changing modes, one thing is important to note: If the current move is shorter than the difference of the two previous moves in the same axis, the upper limit in the perpendicular axis is the length of the last move, otherwise it is the difference of the previous moves.\\n\\nCase 1:\\n```txt\\n_________ \\n|        |\\n|\\n|           |\\n|___________| \\n^           ^\\nThe range between the arrows is the limit\\n```\\n\\nCase 2:\\n```txt\\n_________ \\n|        |\\n|        |  |\\n|           |\\n|___________| \\n         ^  ^\\nThe range between the arrows is the limit\\n```\\n\\nIn the contracting mode, the length of the current move has to be strictly less than the previous move in the same axis to not self intersect.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x)\\n    {\\n        array prev = {0, 0};\\n        array diff = {0, 0};\\n        auto i = x.begin();\\n        for (; i != x.end(); ++i)\\n        {\\n            if (*i < diff[0])\\n            {\\n                prev[0] = prev[1];\\n                prev[1] = *i++;\\n                break;\\n            }\\n            else if (*i <= prev[0])\\n            {\\n                prev[0] = diff[1];\\n                prev[1] = *i++;\\n                break;\\n            }\\n            else\\n            {\\n                diff[0] = diff[1];\\n                diff[1] = *i - prev[0];\\n                prev[0] = prev[1];\\n                prev[1] = *i;\\n            }\\n        }\\n        \\n        for (; i != x.end(); ++i)\\n        {\\n            if (*i >= prev[0])\\n                return true;\\n            else\\n            {\\n                prev[0] = prev[1];\\n                prev[1] = *i;                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```txt\\n_________ \\n|        |\\n|\\n|           |\\n|___________| \\n^           ^\\nThe range between the arrows is the limit\\n```\n```txt\\n_________ \\n|        |\\n|        |  |\\n|           |\\n|___________| \\n         ^  ^\\nThe range between the arrows is the limit\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x)\\n    {\\n        array prev = {0, 0};\\n        array diff = {0, 0};\\n        auto i = x.begin();\\n        for (; i != x.end(); ++i)\\n        {\\n            if (*i < diff[0])\\n            {\\n                prev[0] = prev[1];\\n                prev[1] = *i++;\\n                break;\\n            }\\n            else if (*i <= prev[0])\\n            {\\n                prev[0] = diff[1];\\n                prev[1] = *i++;\\n                break;\\n            }\\n            else\\n            {\\n                diff[0] = diff[1];\\n                diff[1] = *i - prev[0];\\n                prev[0] = prev[1];\\n                prev[1] = *i;\\n            }\\n        }\\n        \\n        for (; i != x.end(); ++i)\\n        {\\n            if (*i >= prev[0])\\n                return true;\\n            else\\n            {\\n                prev[0] = prev[1];\\n                prev[1] = *i;                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965541,
                "title": "python3-with-explanation-clear-naming",
                "content": "Keep at most previous 5 edges will be able to decide the state of collision of the currect node.\\ncorner case: same direction, collide with (0,0); which can only happen during the fifth step\\nwhen deal with two cross lines, need to handle \"equal senarios\" carefully\\n```\\nclass Solution:\\n    \\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        # corner cases [2,1,1,2], was missed in the first attempt\\n        # perpendicular lines crossing, didn\\'t handle equal cases well initially\\n        length = len(x)\\n        self.i = 0 # west east\\n        self.j = 0 # north south\\n        if length < 4:\\n            return False\\n        self.edge_list = []\\n        self.max_count_edge = 5\\n        for index in range(0, length):\\n            [new_i, new_j] = self.getNewPoint(index, x[index])\\n            if self.checkConflict([self.i, self.j], [new_i, new_j]):\\n                return True\\n            self.move(new_i, new_j)\\n        return False\\n    def checkConflict(self, start, end):\\n        length = len(self.edge_list)\\n        if length < 3:\\n            return False\\n        if length == 4:\\n            edge_to_check = self.edge_list[0]\\n            if start[0] == 0 and end[1] >= edge_to_check[0][0] and end[1] <= edge_to_check[0][1]:\\n                return True\\n        for i in [length - 3, length - 5]:\\n            if i < 0:\\n                break\\n            edge_to_check = self.edge_list[i]\\n            if self.checkEdgeConflict([start, end], edge_to_check):\\n                return True\\n        return False\\n    def checkEdgeConflict(self, cur_edge, edge_to_check):\\n        # cur_edge[0][0] and cur_edge[1][0] vs edge_to_check[0][0]\\n        flag_x_inbetween = (not ((cur_edge[0][0]>edge_to_check[0][0]) == (cur_edge[1][0]>edge_to_check[1][0]))) or (cur_edge[0][0]==edge_to_check[0][0]) or (cur_edge[1][0]==edge_to_check[1][0])\\n        flag_y_inbetween = (not ((cur_edge[0][1]>edge_to_check[0][1]) == (cur_edge[1][1]>edge_to_check[1][1]))) or (cur_edge[0][1]==edge_to_check[0][1]) or (cur_edge[1][1]==edge_to_check[1][1])\\n        return flag_x_inbetween and flag_y_inbetween\\n    def getNewPoint(self, index, step) :\\n        new_i = self.i\\n        new_j = self.j\\n        if index%4 == 0:\\n            new_j = self.j + step\\n        if index%4 == 1:\\n            new_i = self.i - step\\n        if index%4 == 2:\\n            new_j = self.j - step\\n        if index%4 == 3:\\n            new_i = self.i + step\\n        return [new_i, new_j]\\n    def move(self, new_i, new_j) :\\n        self.addEdge([self.i, self.j], [new_i, new_j])\\n        self.i = new_i\\n        self.j = new_j\\n    def addEdge(self, start, end):\\n        self.edge_list.append([start, end])\\n        if len(self.edge_list) > self.max_count_edge:\\n            self.edge_list.pop(0)\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        # corner cases [2,1,1,2], was missed in the first attempt\\n        # perpendicular lines crossing, didn\\'t handle equal cases well initially\\n        length = len(x)\\n        self.i = 0 # west east\\n        self.j = 0 # north south\\n        if length < 4:\\n            return False\\n        self.edge_list = []\\n        self.max_count_edge = 5\\n        for index in range(0, length):\\n            [new_i, new_j] = self.getNewPoint(index, x[index])\\n            if self.checkConflict([self.i, self.j], [new_i, new_j]):\\n                return True\\n            self.move(new_i, new_j)\\n        return False\\n    def checkConflict(self, start, end):\\n        length = len(self.edge_list)\\n        if length < 3:\\n            return False\\n        if length == 4:\\n            edge_to_check = self.edge_list[0]\\n            if start[0] == 0 and end[1] >= edge_to_check[0][0] and end[1] <= edge_to_check[0][1]:\\n                return True\\n        for i in [length - 3, length - 5]:\\n            if i < 0:\\n                break\\n            edge_to_check = self.edge_list[i]\\n            if self.checkEdgeConflict([start, end], edge_to_check):\\n                return True\\n        return False\\n    def checkEdgeConflict(self, cur_edge, edge_to_check):\\n        # cur_edge[0][0] and cur_edge[1][0] vs edge_to_check[0][0]\\n        flag_x_inbetween = (not ((cur_edge[0][0]>edge_to_check[0][0]) == (cur_edge[1][0]>edge_to_check[1][0]))) or (cur_edge[0][0]==edge_to_check[0][0]) or (cur_edge[1][0]==edge_to_check[1][0])\\n        flag_y_inbetween = (not ((cur_edge[0][1]>edge_to_check[0][1]) == (cur_edge[1][1]>edge_to_check[1][1]))) or (cur_edge[0][1]==edge_to_check[0][1]) or (cur_edge[1][1]==edge_to_check[1][1])\\n        return flag_x_inbetween and flag_y_inbetween\\n    def getNewPoint(self, index, step) :\\n        new_i = self.i\\n        new_j = self.j\\n        if index%4 == 0:\\n            new_j = self.j + step\\n        if index%4 == 1:\\n            new_i = self.i - step\\n        if index%4 == 2:\\n            new_j = self.j - step\\n        if index%4 == 3:\\n            new_i = self.i + step\\n        return [new_i, new_j]\\n    def move(self, new_i, new_j) :\\n        self.addEdge([self.i, self.j], [new_i, new_j])\\n        self.i = new_i\\n        self.j = new_j\\n    def addEdge(self, start, end):\\n        self.edge_list.append([start, end])\\n        if len(self.edge_list) > self.max_count_edge:\\n            self.edge_list.pop(0)\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 892944,
                "title": "very-clear-and-short-python-solution",
                "content": "Only spiral expanding and spiral contracting pattern could maintain this spiral line not self crossing, and the state transition relation is \\n```\\n`spiral expanding` -> `spiral contracting`->`self crossing`\\n   |^|______|               |^|______| \\n   \\n```\\nwe only need to remember past 4 moves and denote the origin at start as 4 zero moves to avoid discussing nasty special cases\\n\\n```python\\nclass Solution:\\n    def isSelfCrossing(self, arr: List[int]) -> bool:\\n        q = deque([0,0,0,0])\\n        contract = False\\n        for x in arr:\\n            if contract:\\n                if x >= q[-2]:\\n                    return True\\n            else:\\n                if x <= q[-2]:\\n                    if x >= q[-2] - q[-4]:\\n                        q[-1] -= q[-3]\\n                    contract = True\\n            q.append(x)\\n            if len(q) > 4:\\n                q.popleft()\\n        return False\\n```\\n\\nwe can futher optimize the implementation without queue operations\\n\\n```python\\nclass Solution:\\n    def isSelfCrossing(self, arr: List[int]) -> bool:\\n        contract = False\\n        n = len(arr)\\n        arr.extend([0,0,0,0])\\n        for i, x in enumerate(arr):\\n            if i == n:\\n                break\\n            if contract:\\n                if x >= arr[i-2]:\\n                    return True\\n            else:\\n                if x <= arr[i-2]:\\n                    if x >= arr[i-2] - arr[i-4]:\\n                        arr[i-1] -= arr[i-3]\\n                    contract = True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n`spiral expanding` -> `spiral contracting`->`self crossing`\\n   |^|______|               |^|______| \\n   \\n```\n```python\\nclass Solution:\\n    def isSelfCrossing(self, arr: List[int]) -> bool:\\n        q = deque([0,0,0,0])\\n        contract = False\\n        for x in arr:\\n            if contract:\\n                if x >= q[-2]:\\n                    return True\\n            else:\\n                if x <= q[-2]:\\n                    if x >= q[-2] - q[-4]:\\n                        q[-1] -= q[-3]\\n                    contract = True\\n            q.append(x)\\n            if len(q) > 4:\\n                q.popleft()\\n        return False\\n```\n```python\\nclass Solution:\\n    def isSelfCrossing(self, arr: List[int]) -> bool:\\n        contract = False\\n        n = len(arr)\\n        arr.extend([0,0,0,0])\\n        for i, x in enumerate(arr):\\n            if i == n:\\n                break\\n            if contract:\\n                if x >= arr[i-2]:\\n                    return True\\n            else:\\n                if x <= arr[i-2]:\\n                    if x >= arr[i-2] - arr[i-4]:\\n                        arr[i-1] -= arr[i-3]\\n                    contract = True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888803,
                "title": "cpp-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        \\n        if(x.size() < 4)\\n            return false;\\n        \\n        for(int i = 3; i < x.size(); i++) {\\n            if(x[i] >= x[i-2] and x[i-1] <= x[i-3])\\n                return true;\\n            if(i >= 4) {\\n                if(x[i-1] == x[i-3] and x[i] >= x[i-2]-x[i-4])\\n                    return true;\\n            }\\n            if(i >= 5) {\\n                if(x[i-2]-x[i-4] >= 0 and x[i] >= x[i-2]-x[i-4] and\\n                   x[i-1] >= x[i-3]-x[i-5] and x[i-1] <= x[i-3]) \\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        \\n        if(x.size() < 4)\\n            return false;\\n        \\n        for(int i = 3; i < x.size(); i++) {\\n            if(x[i] >= x[i-2] and x[i-1] <= x[i-3])\\n                return true;\\n            if(i >= 4) {\\n                if(x[i-1] == x[i-3] and x[i] >= x[i-2]-x[i-4])\\n                    return true;\\n            }\\n            if(i >= 5) {\\n                if(x[i-2]-x[i-4] >= 0 and x[i] >= x[i-2]-x[i-4] and\\n                   x[i-1] >= x[i-3]-x[i-5] and x[i-1] <= x[i-3]) \\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726245,
                "title": "python-top-80-speed-o-n-time-o-1-space-dimensionless-coordinates",
                "content": "**Python - Top 80% Speed - O(n) time, O(1) space - Dimensionless Coordinates**\\n\\nThe code below uses Dimensionless Coordinates (p,q) to detect collisions with walls. The solution is fairly efficient/valid, but the conversions between Coordinate Systems can be tedious.\\n\\n```\\ndef point_intersection(qa0,qb0,pc0,walls):\\n    for qa,qb,pc in walls[1:]:\\n        if pc0==pc:\\n            if qa<=qa0<=qb or qa<=qb0<=qb:\\n                return True\\n    return False\\nposInf = float(\\'inf\\')\\nclass Solution:\\n    def isSelfCrossing(self, A: List[int]) -> bool:\\n        if len(A)<4:\\n            return False\\n        i,j = 0,0\\n        di,dj = 0,1\\n        iwalls, jwalls = [ [posInf]*3 for _ in range(3)], [ [posInf]*3 for _ in range(3)]\\n        for x in A:\\n            i0,j0 = i,j\\n            i += di*x\\n            j += dj*x\\n            #\\n            if di: # di: p,q = i,j\\n                q,p1,p2 = j, min(i0,i),max(i0,i)\\n                walls = iwalls[1:]\\n            else: # dj: p,q = j,i\\n                q,p1,p2 = i, min(j0,j),max(j0,j)\\n                walls = jwalls[1:]\\n            # Wall Collision Detector\\n            for qa,qb,pc in walls:\\n                if qa<=q<=qb and p1<=pc<=p2:\\n                    return True\\n            # Point Collision Detector\\n            parallels = iwalls if dj else jwalls\\n            if point_intersection(p1,p2,q, parallels ):\\n                return True\\n            # Build New Walls ( dj movements span horizontal walls (iwalls) )\\n            if dj:\\n                iwalls = [ [p1,p2,q], *iwalls[:-1] ]\\n            else:\\n                jwalls = [ [p1,p2,q], *jwalls[:-1] ]\\n            di,dj = -dj,di\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef point_intersection(qa0,qb0,pc0,walls):\\n    for qa,qb,pc in walls[1:]:\\n        if pc0==pc:\\n            if qa<=qa0<=qb or qa<=qb0<=qb:\\n                return True\\n    return False\\nposInf = float(\\'inf\\')\\nclass Solution:\\n    def isSelfCrossing(self, A: List[int]) -> bool:\\n        if len(A)<4:\\n            return False\\n        i,j = 0,0\\n        di,dj = 0,1\\n        iwalls, jwalls = [ [posInf]*3 for _ in range(3)], [ [posInf]*3 for _ in range(3)]\\n        for x in A:\\n            i0,j0 = i,j\\n            i += di*x\\n            j += dj*x\\n            #\\n            if di: # di: p,q = i,j\\n                q,p1,p2 = j, min(i0,i),max(i0,i)\\n                walls = iwalls[1:]\\n            else: # dj: p,q = j,i\\n                q,p1,p2 = i, min(j0,j),max(j0,j)\\n                walls = jwalls[1:]\\n            # Wall Collision Detector\\n            for qa,qb,pc in walls:\\n                if qa<=q<=qb and p1<=pc<=p2:\\n                    return True\\n            # Point Collision Detector\\n            parallels = iwalls if dj else jwalls\\n            if point_intersection(p1,p2,q, parallels ):\\n                return True\\n            # Build New Walls ( dj movements span horizontal walls (iwalls) )\\n            if dj:\\n                iwalls = [ [p1,p2,q], *iwalls[:-1] ]\\n            else:\\n                jwalls = [ [p1,p2,q], *jwalls[:-1] ]\\n            di,dj = -dj,di\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 682848,
                "title": "java-1ms-12-some-explanation",
                "content": "I had to learn how two points intersect in order to do this solution, i have followed the intersection formula here https://www.g e e k s for g e e k s.org/check-if-two-given-line-segments-intersect/ and here https://www.***.org/orientation-3-ordered-points/. \\nThis video helped a little as well https://www.youtube.com/watch?v=wCR48FqkI4w&feature=emb_title\\n\\nOnce you know how to find the intersection of the two lines, the logic is easy to figure. \\n\\nScenarios I thought about\\n1.Intersection as per the example\\n\\u250C\\u2500\\u2500\\u2500\\u2510\\n \\u2502              \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500>\\n                \\u2502\\n\\n2. Collenear\\n\\u250C\\u2500\\u2500\\u2500\\u2510----|\\n \\u2502              \\u2502        |\\n\\u2514\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500|\\n\\n3. No intersection\\n   --------------|\\n\\u250C\\u2500\\u2500\\u2500\\u2510        |\\n \\u2502               \\u2502         |\\n\\u2514\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500|\\n    \\n\\n```\\nclass Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            int max = 6;\\n\\n            LinkedList<Point> points = new LinkedList<>();\\n            Point prev = new Point(0, 0);\\n            points.add(prev);\\n\\n            for (int i = 0; i < x.length; i++) {\\n                Point curr;\\n                if (i % 4 == 0) {\\n                    curr = new Point(prev.x - x[i], prev.y);\\n                } else if (i % 4 == 1) {\\n                    curr = new Point(prev.x, prev.y - x[i]);\\n                } else if (i % 4 == 2) {\\n                    curr = new Point(prev.x + x[i], prev.y);\\n                } else {\\n                    curr = new Point(prev.x, prev.y + x[i]);\\n                }\\n\\n                if (points.size() > 3) {//first first three points you need not calculate the intersection, needs 4 or more points for calculating intersection\\n                    for (int j = 0; j < 3; j++) {\\n                        if (isIntersect(points.get(j), points.get(j + 1), prev, curr)) {\\n                            return true;\\n                        }\\n                    }\\n\\n                    if (points.size() == max) {\\n                        points.removeFirst();//trying to maintain constant space O(1) by removing old points\\n                    }\\n                }\\n                points.add(curr);\\n                prev = curr;\\n            }\\n            return false;\\n        }\\n\\n\\t//see links above for the formulas\\n        public boolean isIntersect(Point p1, Point q1, Point p2, Point q2) {\\n            if(p2==q1)return false;\\n            int o1 = ori(p1, q1, p2);\\n            int o2 = ori(p1, q1, q2);\\n            int o3 = ori(p2, q2, p1);\\n            int o4 = ori(p2, q2, q1);\\n\\n            if (o1 != o2 && o3 != o4) {\\n                return true;\\n            }\\n\\n            //p1,p2,q1\\n            if (o1 == 0 && onseg(p1, p2, q1)) return true; // If O1 is 0 that means the 3 points are on the same line already, onSeg is trying to see if q1 is in between p1 and p2. If so, it is colleniar\\n            if (o2 == 0 && onseg(p1, q2, q1)) return true;\\n            if (o3 == 0 && onseg(p2, p1, q2)) return true;\\n            if (o4 == 0 && onseg(p2, q1, q2)) return true;\\n\\n            return false;\\n        }\\n\\n        public boolean onseg(Point p, Point q, Point r) {\\n            if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&\\n                    q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y))\\n                return true;\\n\\n            return false;\\n        }\\n\\n        public int ori(Point a, Point b, Point c) {\\n            int val = (b.y - a.y) * (c.x - b.x) - (c.y - b.y) * (b.x - a.x);\\n            if (val == 0) {\\n                return 0;\\n            }\\n            return val < 0 ? 1 : 2;\\n        }\\n\\n        class Point {\\n            int x;\\n            int y;\\n\\n            public Point(int x, int y) {\\n                this.x = x;\\n                this.y = y;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            int max = 6;\\n\\n            LinkedList<Point> points = new LinkedList<>();\\n            Point prev = new Point(0, 0);\\n            points.add(prev);\\n\\n            for (int i = 0; i < x.length; i++) {\\n                Point curr;\\n                if (i % 4 == 0) {\\n                    curr = new Point(prev.x - x[i], prev.y);\\n                } else if (i % 4 == 1) {\\n                    curr = new Point(prev.x, prev.y - x[i]);\\n                } else if (i % 4 == 2) {\\n                    curr = new Point(prev.x + x[i], prev.y);\\n                } else {\\n                    curr = new Point(prev.x, prev.y + x[i]);\\n                }\\n\\n                if (points.size() > 3) {//first first three points you need not calculate the intersection, needs 4 or more points for calculating intersection\\n                    for (int j = 0; j < 3; j++) {\\n                        if (isIntersect(points.get(j), points.get(j + 1), prev, curr)) {\\n                            return true;\\n                        }\\n                    }\\n\\n                    if (points.size() == max) {\\n                        points.removeFirst();//trying to maintain constant space O(1) by removing old points\\n                    }\\n                }\\n                points.add(curr);\\n                prev = curr;\\n            }\\n            return false;\\n        }\\n\\n\\t//see links above for the formulas\\n        public boolean isIntersect(Point p1, Point q1, Point p2, Point q2) {\\n            if(p2==q1)return false;\\n            int o1 = ori(p1, q1, p2);\\n            int o2 = ori(p1, q1, q2);\\n            int o3 = ori(p2, q2, p1);\\n            int o4 = ori(p2, q2, q1);\\n\\n            if (o1 != o2 && o3 != o4) {\\n                return true;\\n            }\\n\\n            //p1,p2,q1\\n            if (o1 == 0 && onseg(p1, p2, q1)) return true; // If O1 is 0 that means the 3 points are on the same line already, onSeg is trying to see if q1 is in between p1 and p2. If so, it is colleniar\\n            if (o2 == 0 && onseg(p1, q2, q1)) return true;\\n            if (o3 == 0 && onseg(p2, p1, q2)) return true;\\n            if (o4 == 0 && onseg(p2, q1, q2)) return true;\\n\\n            return false;\\n        }\\n\\n        public boolean onseg(Point p, Point q, Point r) {\\n            if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&\\n                    q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y))\\n                return true;\\n\\n            return false;\\n        }\\n\\n        public int ori(Point a, Point b, Point c) {\\n            int val = (b.y - a.y) * (c.x - b.x) - (c.y - b.y) * (b.x - a.x);\\n            if (val == 0) {\\n                return 0;\\n            }\\n            return val < 0 ? 1 : 2;\\n        }\\n\\n        class Point {\\n            int x;\\n            int y;\\n\\n            public Point(int x, int y) {\\n                this.x = x;\\n                this.y = y;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583129,
                "title": "python-with-detailed-explanation",
                "content": "Please refer to the detailed explanation in the video below.\\nhttps://www.youtube.com/watch?v=ajFikcnQV1I\\n\\n```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        \\n        if not x  or len(x) <= 3:\\n            return False\\n        \\n        n = len(x)\\n        \\n        for i in range(3, n):\\n            # X(0) >= X(2)  X(3) >= X(1)\\n            \\n            if x[i-3] >= x[i-1] and x[i] >= x[i-2]:\\n                return True\\n            \\n            # X(1) == X(3)  X(0) + X(4) >= X(2)\\n            if i >= 4 and x[i-3] == x[i-1] and (x[i-4] + x[i] >= x[i-2]):\\n                return True\\n            \\n            # X(3) >= X(1) X(2) >= X(4) X(0) + X(4) >=X(2)    X(1) + X(5) >= X(3)\\n            if i >= 5 and x[i-2] >= x[i-4] and x[i-3] >= x[i-1] and (x[i-5] + x[i-1] >= x[i-3]) and (x[i-4] + x[i] >= x[i-2]):\\n                return True\\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        \\n        if not x  or len(x) <= 3:\\n            return False\\n        \\n        n = len(x)\\n        \\n        for i in range(3, n):\\n            # X(0) >= X(2)  X(3) >= X(1)\\n            \\n            if x[i-3] >= x[i-1] and x[i] >= x[i-2]:\\n                return True\\n            \\n            # X(1) == X(3)  X(0) + X(4) >= X(2)\\n            if i >= 4 and x[i-3] == x[i-1] and (x[i-4] + x[i] >= x[i-2]):\\n                return True\\n            \\n            # X(3) >= X(1) X(2) >= X(4) X(0) + X(4) >=X(2)    X(1) + X(5) >= X(3)\\n            if i >= 5 and x[i-2] >= x[i-4] and x[i-3] >= x[i-1] and (x[i-5] + x[i-1] >= x[i-3]) and (x[i-4] + x[i] >= x[i-2]):\\n                return True\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535684,
                "title": "python-solution-with-explanation",
                "content": "After drawing some examples,\\n![image](https://assets.leetcode.com/users/jslu0418/image_1583883320.png)\\nWe notice that, at any step, we at most need to know previous 5 steps\\' points to know if the move made by current step is valid or not.\\n\\nSuppose we are at (-2) now at Figure(a), we either walk to a point that is below (-6) and above (-3) (case a)\\nor walk into the vertical range defined by [(-6),(-5)] inclusively (case b), or we reach a point above (-5) (case c)\\n\\nIn case (a), next time after we turn left and walk towards west a little bit, we can only turn left and walk to south, which there is only one line contraint defined by (-3) and (-2). After that we will never face the complicated case as Figure (a).\\n\\nIn case (b), similarly, we turn left again, but in this scenario, our horizontal valid space is less than case (a), we can feel free to move (-3) to its right making it has same x-coord as (-6), then we can still use (-3) and (-2) to define the constraint for next step. Same as case(b), we will step into ease cases since now.\\n\\nCase (c) put us into a same situation as we start at point (-2).\\n\\nTherefore, when we at (-2), we could determine the case of the next step by how long we walk from (-2) to (-1), and in each case, we could calculate that in the next step, when we are at (-1), how far we can move at most without crashing the wall in front of us.\\n\\nOn we are in the simple case as Figure(d) -> Figure(f), actually we only need to keep 3 previous points to solve the problem.\\n\\nSorry the code is too messy while I want to use the index for directions to deal with different cases.\\n\\n```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(x)<4:\\n            return False\\n        drt=[(0,1), (-1, 0), (0, -1), (1, 0)]\\n        idx=0\\n        ## Initialize first 3 points\\n        q=[(0,0),]\\n        i=0\\n        while i<2:\\n            q.append(self.move(q[-1],drt[idx],x[i]))\\n            i+=1\\n            oldidx=idx\\n            idx=(idx+1)%4\\n        limit=float(\\'inf\\')\\n        ranges=[(q[-2][(idx+1)%2],q[-3][(idx+1)%2], q[-2][idx%2]),]\\n        ## Start with the 4th point, we will calculate its next step\\'s valid value.\\n        while i<len(x):\\n            ## invalid move\\n            if x[i]>=limit:\\n                return True\\n            cur=self.move(q[-1], drt[idx], x[i])\\n            ran=0\\n            for r in range(len(ranges)):\\n                if ((-1)**((oldidx/2)+1))*cur[(idx+1)%2]>((-1)**((oldidx/2)+1))*ranges[r][0] and ((-1)**((oldidx/2)+1))*cur[(idx+1)%2]<=((-1)**((oldidx/2)+1))*ranges[r][1]:\\n                    limit=(ranges[r][2]-cur[(idx)%2])*((-1)**((idx/2)+1))\\n                    break\\n                ran=r+1\\n            q.append(cur)\\n            i+=1\\n            oldidx=idx\\n            idx=(idx+1)%4\\n            if ran==len(ranges):\\n                limit=float(\\'inf\\')\\n                if len(q)>=5:\\n                    ranges=[(q[-2][(idx+1)%2],q[-5][(idx+1)%2]+(-1)**(oldidx/2), q[-2][idx%2]), (q[-5][(idx+1)%2]+(-1)**((oldidx/2)),q[-4][(idx+1)%2], q[-5][idx%2])]\\n                else:\\n                    ranges=[(q[-2][(idx+1)%2],q[-4][(idx+1)%2]+(-1)**(oldidx/2), q[-2][idx%2]), (q[-4][(idx+1)%2]+(-1)**((oldidx/2)),q[-4][(idx+1)%2], q[-4][idx%2])]\\n            else:\\n                ## If it goes to a way there is a wall in front, reduce the cases to only one\\n                if ran==len(ranges)-1 and ran>0 and len(q)>=5:\\n                    if idx%2==0:\\n                        q[-3]=(q[-3][(idx)%2],q[-5][(idx+1)%2])\\n                    else:\\n                        q[-3]=(q[-5][(idx+1)%2],q[-3][idx%2])\\n                    ranges=[(q[-2][(idx+1)%2], q[-3][(idx+1)%2], q[-2][(idx)%2]),]\\n                else:\\n                    ranges=[(q[-2][(idx+1)%2], q[-3][(idx+1)%2], q[-2][(idx)%2]),]\\n            if len(q)>5:\\n                q=q[-5:]\\n        return False\\n\\n    def move(self, cur, drt, val):\\n        return cur[0]+drt[0]*val, cur[1]+drt[1]*val\\n\\t\\t```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(x)<4:\\n            return False\\n        drt=[(0,1), (-1, 0), (0, -1), (1, 0)]\\n        idx=0\\n        ## Initialize first 3 points\\n        q=[(0,0),]\\n        i=0\\n        while i<2:\\n            q.append(self.move(q[-1],drt[idx],x[i]))\\n            i+=1\\n            oldidx=idx\\n            idx=(idx+1)%4\\n        limit=float(\\'inf\\')\\n        ranges=[(q[-2][(idx+1)%2],q[-3][(idx+1)%2], q[-2][idx%2]),]\\n        ## Start with the 4th point, we will calculate its next step\\'s valid value.\\n        while i<len(x):\\n            ## invalid move\\n            if x[i]>=limit:\\n                return True\\n            cur=self.move(q[-1], drt[idx], x[i])\\n            ran=0\\n            for r in range(len(ranges)):\\n                if ((-1)**((oldidx/2)+1))*cur[(idx+1)%2]>((-1)**((oldidx/2)+1))*ranges[r][0] and ((-1)**((oldidx/2)+1))*cur[(idx+1)%2]<=((-1)**((oldidx/2)+1))*ranges[r][1]:\\n                    limit=(ranges[r][2]-cur[(idx)%2])*((-1)**((idx/2)+1))\\n                    break\\n                ran=r+1\\n            q.append(cur)\\n            i+=1\\n            oldidx=idx\\n            idx=(idx+1)%4\\n            if ran==len(ranges):\\n                limit=float(\\'inf\\')\\n                if len(q)>=5:\\n                    ranges=[(q[-2][(idx+1)%2],q[-5][(idx+1)%2]+(-1)**(oldidx/2), q[-2][idx%2]), (q[-5][(idx+1)%2]+(-1)**((oldidx/2)),q[-4][(idx+1)%2], q[-5][idx%2])]\\n                else:\\n                    ranges=[(q[-2][(idx+1)%2],q[-4][(idx+1)%2]+(-1)**(oldidx/2), q[-2][idx%2]), (q[-4][(idx+1)%2]+(-1)**((oldidx/2)),q[-4][(idx+1)%2], q[-4][idx%2])]\\n            else:\\n                ## If it goes to a way there is a wall in front, reduce the cases to only one\\n                if ran==len(ranges)-1 and ran>0 and len(q)>=5:\\n                    if idx%2==0:\\n                        q[-3]=(q[-3][(idx)%2],q[-5][(idx+1)%2])\\n                    else:\\n                        q[-3]=(q[-5][(idx+1)%2],q[-3][idx%2])\\n                    ranges=[(q[-2][(idx+1)%2], q[-3][(idx+1)%2], q[-2][(idx)%2]),]\\n                else:\\n                    ranges=[(q[-2][(idx+1)%2], q[-3][(idx+1)%2], q[-2][(idx)%2]),]\\n            if len(q)>5:\\n                q=q[-5:]\\n        return False\\n\\n    def move(self, cur, drt, val):\\n        return cur[0]+drt[0]*val, cur[1]+drt[1]*val\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 528276,
                "title": "c-solution",
                "content": "````c\\nenum state {\\n    inwrap,\\n    mid,\\n    outwrap\\n};\\nbool isSelfCrossing(int* x, int xSize){\\n    int dir[4] = {0};\\n    int p = 0;\\n    #define ADD(n) \\\\\\n    do {\\\\\\n        dir[p] = n;\\\\\\n        p = (p+1) % 4;\\\\\\n    } while(0)\\n    #define GET(n) (dir[(p+4-n) % 4])\\n    enum state s = outwrap;\\n    for (int i = 0; i < xSize; i++) {\\n        switch(s) {\\n            case outwrap:\\n                if (x[i] > GET(2)) {\\n                    s = outwrap;\\n                } else if (x[i] < GET(2) - GET(4)) {\\n                    s = inwrap;\\n                } else {\\n                    s = mid;\\n                }\\n                break;\\n            case mid:\\n                if (x[i] < GET(2) - GET(4)) {\\n                    s = inwrap;\\n                } else {\\n                    return true;\\n                }\\n                break;\\n            case inwrap:\\n                if (x[i] >= GET(2)) {\\n                    return true;\\n                }\\n                break;\\n            default:\\n                break;\\n        }\\n        ADD(x[i]);\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "````c\\nenum state {\\n    inwrap,\\n    mid,\\n    outwrap\\n};\\nbool isSelfCrossing(int* x, int xSize){\\n    int dir[4] = {0};\\n    int p = 0;\\n    #define ADD(n) \\\\\\n    do {\\\\\\n        dir[p] = n;\\\\\\n        p = (p+1) % 4;\\\\\\n    } while(0)\\n    #define GET(n) (dir[(p+4-n) % 4])\\n    enum state s = outwrap;\\n    for (int i = 0; i < xSize; i++) {\\n        switch(s) {\\n            case outwrap:\\n                if (x[i] > GET(2)) {\\n                    s = outwrap;\\n                } else if (x[i] < GET(2) - GET(4)) {\\n                    s = inwrap;\\n                } else {\\n                    s = mid;\\n                }\\n                break;\\n            case mid:\\n                if (x[i] < GET(2) - GET(4)) {\\n                    s = inwrap;\\n                } else {\\n                    return true;\\n                }\\n                break;\\n            case inwrap:\\n                if (x[i] >= GET(2)) {\\n                    return true;\\n                }\\n                break;\\n            default:\\n                break;\\n        }\\n        ADD(x[i]);\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275873,
                "title": "java-solution-check-if-each-line-intersects-the-previous-5-lines",
                "content": "The short solutions people are posting can be difficult to come up with.\\nThis solution might be more verbose / clear.\\n* When drawing a horizontal line, check if it intersects any of the 3 previous vertical lines.\\n* When drawing a vertical line, check if it intersects any of the 3 previous horizontal lines.\\n* intersects() only works for the case where 1 line is horizontal and the other line is vertical\\n\\n```\\nclass Line {\\n    public int x1,y1,x2,y2;\\n    public Line (int x1, int y1, int x2, int y2) {\\n        this.x1=x1;\\n        this.y1=y1;\\n        this.x2=x2;\\n        this.y2=y2;\\n    }\\n    public boolean isHor() {\\n        return y1==y2;\\n    }\\n    public boolean isVer() {\\n        return x1==x2;\\n    }\\n    public String tos() {\\n        return \"(\"+x1+\",\"+y1+\")-(\"+x2+\",\"+y2+\")\";\\n    }\\n}\\n\\nclass Solution {\\n    private boolean intersects(Line l1, Line l2) {\\n        if (!l1.isVer()) {\\n            return intersects(l2, l1);\\n        }\\n        \\n        // l1 is vertical, l2 is horizontal\\n        int yMin = Math.min(l1.y1, l1.y2);\\n        int yMax = Math.max(l1.y1, l1.y2);\\n        if (l2.y1 < yMin || l2.y1 > yMax)\\n            return false;\\n        \\n        int xMin = Math.min(l2.x1, l2.x2);\\n        int xMax = Math.max(l2.x1, l2.x2);\\n        if (l1.x1 < xMin || l1.x1 > xMax)\\n            return false;\\n        \\n        // System.out.println(l1.tos() +\" hits \"+l2.tos());\\n        return true;\\n    }\\n    \\n    public boolean isSelfCrossing(int[] moves) {\\n        int[] dx={0,-1,0,1};\\n        int[] dy={-1,0,1,0};\\n        int dir=0;\\n        int atX=0,atY=0;\\n        \\n        ArrayList<Line> q = new ArrayList<Line>();\\n        q.add(new Line(0,0,0,0)); // Edge case [1,1,2,1,1] (requires long explanation)\\n        \\n        for (int v : moves) {\\n            Line newLine = new Line(atX,atY,atX+dx[dir]*v,atY+dy[dir]*v);\\n            //System.out.println(\"draw \"+newLine.tos());\\n            for (int i = q.size() - 3; i >= 0; i -= 2)\\n                if (intersects(newLine, q.get(i)))\\n                    return true;\\n            \\n            q.add(newLine);\\n            if (q.size()>5)\\n                q.remove(0);\\n            atX=newLine.x2;\\n            atY=newLine.y2;\\n            dir = (dir+1)%4;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Line {\\n    public int x1,y1,x2,y2;\\n    public Line (int x1, int y1, int x2, int y2) {\\n        this.x1=x1;\\n        this.y1=y1;\\n        this.x2=x2;\\n        this.y2=y2;\\n    }\\n    public boolean isHor() {\\n        return y1==y2;\\n    }\\n    public boolean isVer() {\\n        return x1==x2;\\n    }\\n    public String tos() {\\n        return \"(\"+x1+\",\"+y1+\")-(\"+x2+\",\"+y2+\")\";\\n    }\\n}\\n\\nclass Solution {\\n    private boolean intersects(Line l1, Line l2) {\\n        if (!l1.isVer()) {\\n            return intersects(l2, l1);\\n        }\\n        \\n        // l1 is vertical, l2 is horizontal\\n        int yMin = Math.min(l1.y1, l1.y2);\\n        int yMax = Math.max(l1.y1, l1.y2);\\n        if (l2.y1 < yMin || l2.y1 > yMax)\\n            return false;\\n        \\n        int xMin = Math.min(l2.x1, l2.x2);\\n        int xMax = Math.max(l2.x1, l2.x2);\\n        if (l1.x1 < xMin || l1.x1 > xMax)\\n            return false;\\n        \\n        // System.out.println(l1.tos() +\" hits \"+l2.tos());\\n        return true;\\n    }\\n    \\n    public boolean isSelfCrossing(int[] moves) {\\n        int[] dx={0,-1,0,1};\\n        int[] dy={-1,0,1,0};\\n        int dir=0;\\n        int atX=0,atY=0;\\n        \\n        ArrayList<Line> q = new ArrayList<Line>();\\n        q.add(new Line(0,0,0,0)); // Edge case [1,1,2,1,1] (requires long explanation)\\n        \\n        for (int v : moves) {\\n            Line newLine = new Line(atX,atY,atX+dx[dir]*v,atY+dy[dir]*v);\\n            //System.out.println(\"draw \"+newLine.tos());\\n            for (int i = q.size() - 3; i >= 0; i -= 2)\\n                if (intersects(newLine, q.get(i)))\\n                    return true;\\n            \\n            q.add(newLine);\\n            if (q.size()>5)\\n                q.remove(0);\\n            atX=newLine.x2;\\n            atY=newLine.y2;\\n            dir = (dir+1)%4;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134499,
                "title": "easy-understand-python3-solution",
                "content": "First, we do not need to consider the fact that this edge is larger than the opposite edge, like `[1,2,3,4,5]`. So `if x[i] > x[i-2]:pass`. And `if len(x) < 4:return False`. Three sides cannot intersect.\\n\\nHere we consider two situations when the `x[i]<=x[i-2]`\\uFF1A\\n1.There is no intermediate edge between this edge and the opposite edge. Like\\n```\\n[3,3,2,x]\\n```\\nThen the `x[i+1] < x[i-1]` should be established otherwise the two sides intersect.\\n2.There is an intermediate edge between this edge and the opposite edge.Like\\n```\\n[2,3,4,5,a,b]\\n```\\nIf `a>(4-2)` then `b < (5-3)` should be established otherwise the two sides intersect.\\nif `a<(4-2)` then `b < 5` should be established otherwise the two sides intersect.\\nSo I can get the solution. I append two zero to `x` for preventing the `IndexError`\\nSolution:\\n```\\nclass Solution:\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(x) < 4:\\n            return False\\n        x.append(0)\\n        x.append(0)\\n        for i in range(2,len(x)-2):\\n            if x[i] <= x[i-2]:\\n                tmp = x[i-2] - x[i-4]\\n                if tmp > 0:\\n                    if x[i]>=tmp:\\n                        if x[i+1] != 0 and x[i+1] >= x[i-1]-x[i-3]:\\n                            return True\\n                    else:\\n                        if x[i+1] >= x[i-1]:\\n                            return True\\n                else:\\n                    if x[i+1] >= x[i-1]:\\n                        return True\\n        return False\\n```\\n",
                "solutionTags": [],
                "code": "```\\n[3,3,2,x]\\n```\n```\\n[2,3,4,5,a,b]\\n```\n```\\nclass Solution:\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(x) < 4:\\n            return False\\n        x.append(0)\\n        x.append(0)\\n        for i in range(2,len(x)-2):\\n            if x[i] <= x[i-2]:\\n                tmp = x[i-2] - x[i-4]\\n                if tmp > 0:\\n                    if x[i]>=tmp:\\n                        if x[i+1] != 0 and x[i+1] >= x[i-1]-x[i-3]:\\n                            return True\\n                    else:\\n                        if x[i+1] >= x[i-1]:\\n                            return True\\n                else:\\n                    if x[i+1] >= x[i-1]:\\n                        return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111767,
                "title": "concise-c-solution-with-graph-and-text-explaination",
                "content": "Inspired by @munsteur 's [solution](https://discuss.leetcode.com/topic/39428/simple-java-solution).\\n```\\nclass Solution{\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if(x.size() < 4){\\n            return false;\\n        }        \\n        // Check outward spiral\\n        size_t i = 2, lastIdx = x.size() - 1;\\n        while(x[i] > x[i-2]){\\n            if(i == lastIdx) return false;\\n            i++;\\n        }\\n        \\n        // Transit to inward spiral\\n        // Three cases:\\n        // 1. x[i] is longer than x[i-2] - x[i - 4], and of course shorter than x[x-2], so next line x[i + 1] may cross with x[i - 4], unless it's shorter than x[i-1] - x[i - 3]. \\n        // 2. A very special case, i == 3, and x[3] == x[1], so x[4] may touch x[0], unless it's shorter than x[2] - x[0];\\n        // 3. normal cases, we just need ensure x[i] < x[i-2] in following steps;\\n        // To handle case 1) and 2), we can make x[i - 1] = x[i - 1] - x[i - 3], so we can proceed with same condition check logic as case 3).\\n        if((i == 3 && x[3] == x[1]) || (x[i] >= x[i-2] - x[i-4])){\\n            x[i-1] -= x[i-3];\\n        }\\n        \\n        // Check inward spiral\\n        while(++i <= lastIdx && x[i] < x[i-2]);\\n        return i <= lastIdx;\\n    }\\n};\\n```\\nBelow are 3 pictures to explain the 3 inward spiral transition cases:\\nCase 1.\\n![case 1](https://image.ibb.co/kGrJrm/case1.png)\\n\\nCase2.\\n![case 2](https://image.ibb.co/dPbhj6/case2.png)\\n\\nCase 3.\\n![case 3](https://image.ibb.co/mz6nHR/case3.png)",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if(x.size() < 4){\\n            return false;\\n        }        \\n        // Check outward spiral\\n        size_t i = 2, lastIdx = x.size() - 1;\\n        while(x[i] > x[i-2]){\\n            if(i == lastIdx) return false;\\n            i++;\\n        }\\n        \\n        // Transit to inward spiral\\n        // Three cases:\\n        // 1. x[i] is longer than x[i-2] - x[i - 4], and of course shorter than x[x-2], so next line x[i + 1] may cross with x[i - 4], unless it's shorter than x[i-1] - x[i - 3]. \\n        // 2. A very special case, i == 3, and x[3] == x[1], so x[4] may touch x[0], unless it's shorter than x[2] - x[0];\\n        // 3. normal cases, we just need ensure x[i] < x[i-2] in following steps;\\n        // To handle case 1) and 2), we can make x[i - 1] = x[i - 1] - x[i - 3], so we can proceed with same condition check logic as case 3).\\n        if((i == 3 && x[3] == x[1]) || (x[i] >= x[i-2] - x[i-4])){\\n            x[i-1] -= x[i-3];\\n        }\\n        \\n        // Check inward spiral\\n        while(++i <= lastIdx && x[i] < x[i-2]);\\n        return i <= lastIdx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79137,
                "title": "python-solution-and-tips",
                "content": "Draw lines and number those lines. You will find the pattern soon.\\n\\nThe `i-th` can only cross `i-3th`, `i-4th` or `i-5th` on the first crossing.\\n```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(x) < 4:\\n            return False\\n        for i in range(3, len(x)):\\n            if x[i] >= x[i-2] and x[i-1] <= x[i-3]:\\n                return True\\n            if i >= 4 and x[i-1] == x[i-3] and x[i] + x[i-4] >= x[i-2]:\\n                return True\\n            if i >= 5 and x[i-1] <= x[i-3] and x[i-3] <= x[i-1] + x[i-5] and x[i] + x[i-4] >= x[i-2] and x[i-4] <= x[i-2]:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(x) < 4:\\n            return False\\n        for i in range(3, len(x)):\\n            if x[i] >= x[i-2] and x[i-1] <= x[i-3]:\\n                return True\\n            if i >= 4 and x[i-1] == x[i-3] and x[i] + x[i-4] >= x[i-2]:\\n                return True\\n            if i >= 5 and x[i-1] <= x[i-3] and x[i-3] <= x[i-1] + x[i-5] and x[i] + x[i-4] >= x[i-2] and x[i-4] <= x[i-2]:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79173,
                "title": "sharing-my-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool isSelfCrossing(vector<int>& x) {\\n            int i, n = x.size();\\n            for(i=0; i<n; i++)\\n            {\\n                if(i>=3 && x[i]>=x[i-2] && x[i-1]<=x[i-3])\\n                    return true;\\n                    \\n                if(i>=4 && x[i-1]==x[i-3] && x[i]+x[i-4]>=x[i-2])\\n                    return true;\\n                    \\n                if(i>=5 && x[i]+x[i-4]>=x[i-2] && x[i-1]+x[i-5]>=x[i-3] && x[i-2]>=x[i-4] && x[i-3]>=x[i-1])\\n                    return true;\\n            }\\n            \\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isSelfCrossing(vector<int>& x) {\\n            int i, n = x.size();\\n            for(i=0; i<n; i++)\\n            {\\n                if(i>=3 && x[i]>=x[i-2] && x[i-1]<=x[i-3])\\n                    return true;\\n                    \\n                if(i>=4 && x[i-1]==x[i-3] && x[i]+x[i-4]>=x[i-2])\\n                    return true;\\n                    \\n                if(i>=5 && x[i]+x[i-4]>=x[i-2] && x[i-1]+x[i-5]>=x[i-3] && x[i-2]>=x[i-4] && x[i-3]>=x[i-1])\\n                    return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 79183,
                "title": "java-one-pass-solution-0ms",
                "content": "No direction attributes are used. Redundant code but easy to understand.\\n\\n    public boolean isSelfCrossing(int[] x) {\\n        \\n        // Check for initial four values manually.\\n        if(x.length < 4){\\n            for(int el : x){\\n                if(el == 0)return true;\\n            }\\n            return false;\\n        }\\n        \\n    \\n        for(int i = 3 ; i < x.length ; i++) {\\n            int cur = x[i];\\n            if(cur == 0)return true;\\n            //At any point of time, i-1 has to be less than i-3 in order to intersect. Draw few figures to realize this.\\n            if( x[i-1] <= x[i-3]){\\n                // Basic case. Straight forward intersection.\\n                if(cur >= x[i-2] ){\\n                    return true;\\n                }\\n                //Special case.\\n                if(i>=5){\\n                    // if i-2 edge is less than i-4 th edge then it cannot intersect no matter what if i < i-2 th edge.\\n                    if(x[i-2] < x[i-4])continue;\\n                    // the intersecting case.\\n                    if( (x[i] + x[i-4] >= x[i-2]) && ( x[i-1] + x[i-5] >= x[i-3] ) ) return true;\\n                }\\n            }\\n            // equals case\\n            if(i>=4)if(x[i-1] == x[i-3] && cur+ x[i-4] == x[i-2]) return true;\\n            \\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "No direction attributes are used. Redundant code but easy to understand.\\n\\n    public boolean isSelfCrossing(int[] x) {\\n        \\n        // Check for initial four values manually.\\n        if(x.length < 4){\\n            for(int el : x){\\n                if(el == 0)return true;\\n            }\\n            return false;\\n        }\\n        \\n    \\n        for(int i = 3 ; i < x.length ; i++) {\\n            int cur = x[i];\\n            if(cur == 0)return true;\\n            //At any point of time, i-1 has to be less than i-3 in order to intersect. Draw few figures to realize this.\\n            if( x[i-1] <= x[i-3]){\\n                // Basic case. Straight forward intersection.\\n                if(cur >= x[i-2] ){\\n                    return true;\\n                }\\n                //Special case.\\n                if(i>=5){\\n                    // if i-2 edge is less than i-4 th edge then it cannot intersect no matter what if i < i-2 th edge.\\n                    if(x[i-2] < x[i-4])continue;\\n                    // the intersecting case.\\n                    if( (x[i] + x[i-4] >= x[i-2]) && ( x[i-1] + x[i-5] >= x[i-3] ) ) return true;\\n                }\\n            }\\n            // equals case\\n            if(i>=4)if(x[i-1] == x[i-3] && cur+ x[i-4] == x[i-2]) return true;\\n            \\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4081177,
                "title": "expressive-solution",
                "content": "Very bad drawing but how i approached this question\\n![image.png](https://assets.leetcode.com/users/images/86c57f11-e9d4-4133-9272-523a39b05d47_1695484128.517365.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        \"\"\"\\n        1st way to cross NWSE , East meets north, E and W must be same length\\n        and N>=S\\n        2nd way NWSEN , North overlaps with north , E==W and S<= N1+N2\\n        3rd way NWSENW , West overlaps with first North, W1<\\n        \"\"\"\\n        if(len(distance)<=3):\\n            return False\\n        for i in range(3,len(distance)):\\n            if(distance[i]>=distance[i-2] and distance[i-3]>=distance[i-1]):\\n                return True\\n            if(i>=4 and distance[i-1]==distance[i-3] and distance[i-2]<=distance[i]+distance[i-4]):\\n                return True\\n            if(i>=5 and distance[i-4]<distance[i-2] and distance[i]+distance[i-4]>=distance[i-2] and distance[i-1]+distance[i-5]>=distance[i-3] and distance[i-1]<=distance[i-3]):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        \"\"\"\\n        1st way to cross NWSE , East meets north, E and W must be same length\\n        and N>=S\\n        2nd way NWSEN , North overlaps with north , E==W and S<= N1+N2\\n        3rd way NWSENW , West overlaps with first North, W1<\\n        \"\"\"\\n        if(len(distance)<=3):\\n            return False\\n        for i in range(3,len(distance)):\\n            if(distance[i]>=distance[i-2] and distance[i-3]>=distance[i-1]):\\n                return True\\n            if(i>=4 and distance[i-1]==distance[i-3] and distance[i-2]<=distance[i]+distance[i-4]):\\n                return True\\n            if(i>=5 and distance[i-4]<distance[i-2] and distance[i]+distance[i-4]>=distance[i-2] and distance[i-1]+distance[i-5]>=distance[i-3] and distance[i-1]<=distance[i-3]):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942830,
                "title": "o-n-time-o-1-memory-solution-with-proof-of-working",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly we can see that the figure can be spiral goes outside spining or inside spining.\\n\\nAlso it can try to change its spining direction once...once,but few times.\\n\\nWhat means few?\\nIt means that it goes outside several times,then few times it is in the \"changing\" condition and then always inside.\\n\\n![\\u043C\\u043E\\u0440\\u0434\\u0430.png](https://assets.leetcode.com/users/images/4d7766c6-79c4-407e-bd69-13a5c4375d67_1692648667.6833699.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly we will make a rule which shows is there on the k step crossing with something before or it is not.\\n\\nSo,let\\'s start with spiral spining only outside and once it crosses itself.\\nWe will cann elements from the tail,for example 5th element means k-5th element from the start.\\n\\n![\\u043C\\u043E\\u0440\\u0434\\u0430.png](https://assets.leetcode.com/users/images/901fd96f-0161-4dc4-b180-20b15250c159_1692649112.3803544.png)\\nObviously if 3th>=1th and 0th>=2th then we have an intersection points.\\n\\nSo,what about outside spining?\\nYou will laugh,but rule stays the same!\\nDo not believe to me? Check it yourself then.\\n![\\u043C\\u043E\\u0440\\u0434\\u0430.png](https://assets.leetcode.com/users/images/579df074-b07d-4b3b-a063-eed8da592aa7_1692649267.804402.png)\\n\\nSo,that was great,but what about changing direction?\\nObviously to detect this condition we need to make sure that\\n2th<=0th+4th else we have nothing to speak about.\\n![\\u043C\\u043E\\u0440\\u0434\\u0430.png](https://assets.leetcode.com/users/images/0553544d-a80f-439d-bc2e-78405b8307f4_1692649587.6485841.png)\\n\\nBut what if yes,how can we be sure that 0th goes exactly through 5th?\\nOf course by adding few rules\\n1th<=3th and 1th>=3th-5th\\nIt will prove that 0th lies between 4th and 6th\\n![\\u043C\\u043E\\u0440\\u0434\\u0430.png](https://assets.leetcode.com/users/images/f886a756-cc0f-4b3b-b3e4-b6e05e3927b6_1692649768.4962103.png)\\n\\nBut we need 3th-5th>0 else we do not have a gap between 6th and 2th to make it all possible...Then it is the another rule.\\n\\nBut what if k=4?Then we can not see 5th...\\nOk,we will deal with that by saying 5th=0\\nBut it means our rule now has 3th>=1th and 3th<=1th.Let\\'s rewrite it like 3th=1th.\\n\\nNow we have checked all the cases which are possible!\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\nSo,have we missed something?\\nOf course we have.\\nSpiral can be changing its direction only several times and after finaly changing it from undetermined to another than it was before it will NEVER be able to go into any another condition.\\nLet\\'s make the second solution with this useful fact.\\n\\nFirstly we will check the rule of the spiral spining (does not matter in what direction)\\nThen we will detect the period of its cahnging and after just relax and only check the spiral spining.\\nAs you remember,the rules for outside and inside spining is the same,that is why we do not need to watch each case exactly.\\n![\\u043C\\u043E\\u0440\\u0434\\u0430.png](https://assets.leetcode.com/users/images/29ed2232-edf5-4a84-bd6c-55a714c022ee_1692652010.8186808.png)\\n\\nOk,what is the rule of starting the changing process?\\nIt is 2th>=4 and 2th>=0th.\\nIf that happens in the first part where we check the spining,we just start the second part of our algorithm with checking the changing condition.\\nAnd when this rule stops holding,we say that it is spining again and never will be something another.\\n\\nIf in any part of our algorithm we have reached the end,we just say that we have meet no intersection points.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nbool isSelfCrossing(int* distance, int distanceSize){\\n    if (distanceSize<4) {return false;}\\n    //case 3\\n    if (\\n        (distance[3]>=distance[3-2])&&\\n        (distance[3-3]>=distance[3-1])\\n    ) {return true;}\\n    \\n    if (distanceSize<5) {return false;}\\n    //case 4\\n    if (\\n        (distance[4-2]<=distance[4]+distance[4-4])&&\\n        (distance[4-3]>=distance[4-1])&&\\n        (distance[4-3]==distance[4-1])\\n    ) {return true;}\\n\\n    if (distanceSize<6) {return false;}\\n    //case 5+\\n    for (int g=5;g<distanceSize;g++) {\\n        \\n        if (\\n            (distance[g]>=distance[g-2])&&\\n            (distance[g-3]>=distance[g-1])\\n        ) {return true;}\\n\\n        if (\\n            (distance[g-2]<=distance[g]+distance[g-4])&&\\n            (distance[g-3]>=distance[g-1])&&\\n            (distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0)\\n        ) {return true;}\\n        \\n        /*\\n        Rule itself if you wish,start g from 3 up to distancesize\\n        if (\\n            (\\n                (distance[g]>=distance[g-2])&&\\n                (distance[g-3]>=distance[g-1])\\n            )||(\\n                (g>=4)&&\\n                (distance[g-2]<=distance[g]+distance[g-4])&&\\n                (distance[g-3]>=distance[g-1])&&(\\n                    ((g==4)&&(distance[g-3]==distance[g-1]))||\\n                    ((g>=5)&&(distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0))\\n                )\\n            )\\n        ) {return true;}\\n        */\\n    }\\n    return false;\\n}\\n\\n\\n\\n//and now the another solution with those 3 parts\\n\\n\\n\\nbool isSelfCrossing(int* distance, int distanceSize){\\n    if (distanceSize<4) {return false;}\\n    int g=4;\\n    bool cond=true;\\n    \\n    if (\\n        (distance[3]>=distance[3-2])&&\\n        (distance[3-3]>=distance[3-1])\\n    ) {return true;}\\n    \\n    if (distanceSize==4) {return false;}\\n\\n    while (cond==true) {\\n        if (\\n            (distance[g]>=distance[g-2])&&\\n            (distance[g-3]>=distance[g-1])\\n        ) {return true;}\\n        if (\\n            (distance[g-2]>=distance[g-4])&&\\n            (distance[g-2]>=distance[g])\\n        ) {\\n            cond=false;\\n            if (\\n                (distance[g-2]<=distance[g]+distance[g-4])&&\\n                (distance[g-3]>=distance[g-1])&&(\\n                    ((g==4)&&(distance[g-3]==distance[g-1]))||\\n                    ((g>=5)&&(distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0))\\n                )\\n            ) {return true;}\\n        }\\n        g++;\\n        if (g==distanceSize) {return false;}\\n    }\\n    \\n    while (cond==false) {\\n        if (\\n            (distance[g-2]<=distance[g]+distance[g-4])&&\\n            (distance[g-3]>=distance[g-1])&&\\n            (distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0)            \\n        ) {\\n            return true;\\n        }\\n        if (\\n            (distance[g-2]<distance[g-4])||\\n            (distance[g-2]>distance[g])\\n        ) {\\n            cond=true;\\n            if (\\n                (distance[g]>=distance[g-2])&&\\n                (distance[g-3]>=distance[g-1])\\n            ) {return true;}\\n        }\\n        g++;\\n        if (g==distanceSize) {return false;}\\n    }\\n    while (true) {\\n        if (\\n            (distance[g]>=distance[g-2])&&\\n            (distance[g-3]>=distance[g-1])\\n        ) {return true;}\\n        g++;\\n        if (g==distanceSize) {return false;}\\n    }\\n    return false;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isSelfCrossing(int* distance, int distanceSize){\\n    if (distanceSize<4) {return false;}\\n    //case 3\\n    if (\\n        (distance[3]>=distance[3-2])&&\\n        (distance[3-3]>=distance[3-1])\\n    ) {return true;}\\n    \\n    if (distanceSize<5) {return false;}\\n    //case 4\\n    if (\\n        (distance[4-2]<=distance[4]+distance[4-4])&&\\n        (distance[4-3]>=distance[4-1])&&\\n        (distance[4-3]==distance[4-1])\\n    ) {return true;}\\n\\n    if (distanceSize<6) {return false;}\\n    //case 5+\\n    for (int g=5;g<distanceSize;g++) {\\n        \\n        if (\\n            (distance[g]>=distance[g-2])&&\\n            (distance[g-3]>=distance[g-1])\\n        ) {return true;}\\n\\n        if (\\n            (distance[g-2]<=distance[g]+distance[g-4])&&\\n            (distance[g-3]>=distance[g-1])&&\\n            (distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0)\\n        ) {return true;}\\n        \\n        /*\\n        Rule itself if you wish,start g from 3 up to distancesize\\n        if (\\n            (\\n                (distance[g]>=distance[g-2])&&\\n                (distance[g-3]>=distance[g-1])\\n            )||(\\n                (g>=4)&&\\n                (distance[g-2]<=distance[g]+distance[g-4])&&\\n                (distance[g-3]>=distance[g-1])&&(\\n                    ((g==4)&&(distance[g-3]==distance[g-1]))||\\n                    ((g>=5)&&(distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0))\\n                )\\n            )\\n        ) {return true;}\\n        */\\n    }\\n    return false;\\n}\\n\\n\\n\\n//and now the another solution with those 3 parts\\n\\n\\n\\nbool isSelfCrossing(int* distance, int distanceSize){\\n    if (distanceSize<4) {return false;}\\n    int g=4;\\n    bool cond=true;\\n    \\n    if (\\n        (distance[3]>=distance[3-2])&&\\n        (distance[3-3]>=distance[3-1])\\n    ) {return true;}\\n    \\n    if (distanceSize==4) {return false;}\\n\\n    while (cond==true) {\\n        if (\\n            (distance[g]>=distance[g-2])&&\\n            (distance[g-3]>=distance[g-1])\\n        ) {return true;}\\n        if (\\n            (distance[g-2]>=distance[g-4])&&\\n            (distance[g-2]>=distance[g])\\n        ) {\\n            cond=false;\\n            if (\\n                (distance[g-2]<=distance[g]+distance[g-4])&&\\n                (distance[g-3]>=distance[g-1])&&(\\n                    ((g==4)&&(distance[g-3]==distance[g-1]))||\\n                    ((g>=5)&&(distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0))\\n                )\\n            ) {return true;}\\n        }\\n        g++;\\n        if (g==distanceSize) {return false;}\\n    }\\n    \\n    while (cond==false) {\\n        if (\\n            (distance[g-2]<=distance[g]+distance[g-4])&&\\n            (distance[g-3]>=distance[g-1])&&\\n            (distance[g-1]>=distance[g-3]-distance[g-5])&&(distance[g-3]-distance[g-5]>0)            \\n        ) {\\n            return true;\\n        }\\n        if (\\n            (distance[g-2]<distance[g-4])||\\n            (distance[g-2]>distance[g])\\n        ) {\\n            cond=true;\\n            if (\\n                (distance[g]>=distance[g-2])&&\\n                (distance[g-3]>=distance[g-1])\\n            ) {return true;}\\n        }\\n        g++;\\n        if (g==distanceSize) {return false;}\\n    }\\n    while (true) {\\n        if (\\n            (distance[g]>=distance[g-2])&&\\n            (distance[g-3]>=distance[g-1])\\n        ) {return true;}\\n        g++;\\n        if (g==distanceSize) {return false;}\\n    }\\n    return false;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936031,
                "title": "easy-lineartime-solution-java-kotlin-hyder-nabi",
                "content": "\\n# Java\\n```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] distance) {\\n        if(distance.length<=3)return false;\\n        for(int i=3;i<distance.length;i++){\\n            if(distance[i-1]<=distance[i-3] && distance[i]>=distance[i-2])return true;\\n            if(i>=4 && distance[i-1] == distance[i-3] && distance[i]+distance[i-4] >= distance [i-2])return true;\\n            if (i>=5 && distance[i-5]+distance[i-1] >= distance[i-3] && distance[i-2] <= distance[i]+distance[i-4] && distance[i-2] >= distance[i-4] && distance[i-1]<=distance[i-3])return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n# Kotlin\\n```\\nclass Solution {\\n    fun isSelfCrossing(distance: IntArray): Boolean {\\n        if(distance.size<=3)return false\\n        for(i in 3..distance.size-1){\\n            if(distance[i-1]<=distance[i-3] && distance[i]>=distance[i-2])return true\\n            if(i>=4 && distance[i-1] == distance[i-3] && distance[i]+distance[i-4] >= distance [i-2])return true\\n            if (i>=5 && distance[i-5]+distance[i-1] >= distance[i-3] && distance[i-2] <= distance[i]+distance[i-4] && distance[i-2] >= distance[i-4] && distance[i-1]<=distance[i-3])return true\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] distance) {\\n        if(distance.length<=3)return false;\\n        for(int i=3;i<distance.length;i++){\\n            if(distance[i-1]<=distance[i-3] && distance[i]>=distance[i-2])return true;\\n            if(i>=4 && distance[i-1] == distance[i-3] && distance[i]+distance[i-4] >= distance [i-2])return true;\\n            if (i>=5 && distance[i-5]+distance[i-1] >= distance[i-3] && distance[i-2] <= distance[i]+distance[i-4] && distance[i-2] >= distance[i-4] && distance[i-1]<=distance[i-3])return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun isSelfCrossing(distance: IntArray): Boolean {\\n        if(distance.size<=3)return false\\n        for(i in 3..distance.size-1){\\n            if(distance[i-1]<=distance[i-3] && distance[i]>=distance[i-2])return true\\n            if(i>=4 && distance[i-1] == distance[i-3] && distance[i]+distance[i-4] >= distance [i-2])return true\\n            if (i>=5 && distance[i-5]+distance[i-1] >= distance[i-3] && distance[i-2] <= distance[i]+distance[i-4] && distance[i-2] >= distance[i-4] && distance[i-1]<=distance[i-3])return true\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930467,
                "title": "swift-easy-solution-100-beat-time-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func isSelfCrossing(_ distance: [Int]) -> Bool {\\n       \\n       if distance.count  <= 3 { return false }\\n\\n        var newArr = Array(1...(distance.count-1))\\n        newArr.append(1)\\n        \\n        if newArr == distance {\\n            return false\\n        }\\n        \\n      \\n        \\n        var arr = [(Int,Int)]()\\n        var x = 0\\n        var y = 0\\n        arr.append((x,y))\\n        var i = 0\\n        \\n        while i < distance.count {\\n            \\n            for j in 0..<distance[i] {\\n                \\n                if (i % 4) == 0 { // N\\n                    y += 1\\n                    \\n                }else if (i % 4) == 1 { // W\\n                    x -= 1\\n                    \\n                }else if (i % 4) == 2 { // S\\n                    y -= 1\\n                    \\n                }else { // E\\n                    x += 1\\n                }\\n                \\n                if arr.contains(where: {$0.0 == x && $0.1 == y}) {\\n                    return true\\n                }\\n                \\n                arr.append((x,y))\\n            }\\n            \\n            i += 1\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isSelfCrossing(_ distance: [Int]) -> Bool {\\n       \\n       if distance.count  <= 3 { return false }\\n\\n        var newArr = Array(1...(distance.count-1))\\n        newArr.append(1)\\n        \\n        if newArr == distance {\\n            return false\\n        }\\n        \\n      \\n        \\n        var arr = [(Int,Int)]()\\n        var x = 0\\n        var y = 0\\n        arr.append((x,y))\\n        var i = 0\\n        \\n        while i < distance.count {\\n            \\n            for j in 0..<distance[i] {\\n                \\n                if (i % 4) == 0 { // N\\n                    y += 1\\n                    \\n                }else if (i % 4) == 1 { // W\\n                    x -= 1\\n                    \\n                }else if (i % 4) == 2 { // S\\n                    y -= 1\\n                    \\n                }else { // E\\n                    x += 1\\n                }\\n                \\n                if arr.contains(where: {$0.0 == x && $0.1 == y}) {\\n                    return true\\n                }\\n                \\n                arr.append((x,y))\\n            }\\n            \\n            i += 1\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929788,
                "title": "guru",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] distance) {\\n      \\n        if (distance.length < 4) {\\n            return false; // A path with less than 4 distances can\\'t cross itself.\\n        }\\n        \\n        for (int i = 3; i < distance.length; i++) {\\n            if (distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) {\\n                // Case 1: Fourth segment crosses the first segment.\\n                return true;\\n            }\\n            \\n            if (i >= 4 && distance[i - 1] == distance[i - 3] && distance[i] + distance[i - 4] >= distance[i - 2]) {\\n                // Case 2: Fifth segment crosses the first segment.\\n                return true;\\n            }\\n            \\n            if (i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i - 1] <= distance[i - 3] &&\\n                distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) {\\n                // Case 3: Sixth segment crosses the first segment.\\n                return true;\\n            }\\n        }\\n        \\n        return false; // No self-crossing path found.\\n    }\\n  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] distance) {\\n      \\n        if (distance.length < 4) {\\n            return false; // A path with less than 4 distances can\\'t cross itself.\\n        }\\n        \\n        for (int i = 3; i < distance.length; i++) {\\n            if (distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) {\\n                // Case 1: Fourth segment crosses the first segment.\\n                return true;\\n            }\\n            \\n            if (i >= 4 && distance[i - 1] == distance[i - 3] && distance[i] + distance[i - 4] >= distance[i - 2]) {\\n                // Case 2: Fifth segment crosses the first segment.\\n                return true;\\n            }\\n            \\n            if (i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i - 1] <= distance[i - 3] &&\\n                distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) {\\n                // Case 3: Sixth segment crosses the first segment.\\n                return true;\\n            }\\n        }\\n        \\n        return false; // No self-crossing path found.\\n    }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881186,
                "title": "key-idea-explained-linear-algebra-python",
                "content": "```\\n\"\"\"\\nThere are 3 possible cuts:\\n\\n1. Converge cut (every 4 segments)\\n            b \\n   +----------------+ \\n   |                | \\n   |                | \\n c |                | a \\n   |                |      \\n   +--------------->|      \\n            d       |    \\n\\n2. Rectangular cut (every 5 segments)\\n           b          \\n  +----------------+  \\n  |                |  \\n  |                |  \\nc |                | a\\n  |                |  \\n  |                |  \\n  |                ^ e\\n  |                |  \\n  +----------------+  \\n           d          \\n\\n3. Diverge cut (every 6 segments)\\n           b                 \\n  +----------------+         \\n  |                |         \\n  |                |         \\nc |                | a       \\n  |                |    f    \\n  |                | <----+  \\n  |                |      | e\\n  |                       |  \\n  +-----------------------+  \\n           d                 \\n\\n```\\nSo basically we need to keep track of past 6 segments and check for all three cases\\n\\nChecking for cuts is not too hard because we all segments are either vertical or horizontal\\n\\nBut I wanted to figure out a generalised way to check if two segments intersect using linear algebra so I am doing more calculations than I need to. \\n\\n**Time: O(n)\\nSpace: O(1)**\\n```\\ndef isSelfCrossing(self, distance: List[int]) -> bool:\\n    n = len(distance)\\n    if n < 4: return False\\n\\n    direction = [[0, 1], [-1, 0], [0, -1], [1, 0]]\\n    def move(x, y, i):\\n        dis = distance[i]\\n        dx, dy = direction[i%4]\\n        return [x + dx*dis, y + dy*dis]\\n\\n    def subtract(p1, p2):\\n        return [p2[i] - p1[i] for i in range(len(p1))]\\n\\n    # check if a p3 is b.w p1 and p2\\n    def check_point_on_segment(p1, p2, p3):\\n        n = len(p1)\\n        r12 = subtract(p1, p2)\\n        r13 = subtract(p1, p3)\\n        \\n        mu = None\\n        for i in range(n):\\n            if r12[i] != 0:\\n                mu = r13[i]/r12[i]\\n                break\\n        return (p1 == p3) or (0<=mu<=1 and all([p1[i] + mu*r12[i] == p3[i] for i in range(n)]))\\n    \\n    # check if segments [p1, p2] and [p3, p4] intersect\\n    def check_segment_intersect(p1, p2, p3, p4):\\n        n = len(p1)\\n        r12 = subtract(p1, p2)\\n        r13 = subtract(p1, p3)\\n        r34 = subtract(p3, p4)\\n        denom = (r34[0]*r12[1] - r12[0]*r34[1])\\n        # the two segments are parallel\\n        if denom == 0:\\n            return check_point_on_segment(p1, p2, p3) or check_point_on_segment(p1, p2, p4)\\n        # the two segments are not parallel\\n        mu = (r34[0]*r13[1] - r13[0]*r34[1])/denom\\n        return 0<=mu<=1 and check_point_on_segment(p3, p4, [p1[i] + mu*r12[i] for i in range(n)])\\n        \\n    x = y = 0\\n    que = deque([[0, 0]])\\n    for i in range(n):\\n        x, y = move(x, y, i)\\n        que.append([x, y])\\n        if len(que) >= 5 and check_segment_intersect(que[0], que[1], que[3], que[4]):\\n            return True\\n        if len(que) >= 6 and check_segment_intersect(que[0], que[1], que[4], que[5]):\\n            return True\\n        if len(que) == 7:\\n            if check_segment_intersect(que[0], que[1], que[5], que[6]):\\n                return True\\n            que.popleft()\\n    \\n    return False\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\n\"\"\"\\nThere are 3 possible cuts:\\n\\n1. Converge cut (every 4 segments)\\n            b \\n   +----------------+ \\n   |                | \\n   |                | \\n c |                | a \\n   |                |      \\n   +--------------->|      \\n            d       |    \\n\\n2. Rectangular cut (every 5 segments)\\n           b          \\n  +----------------+  \\n  |                |  \\n  |                |  \\nc |                | a\\n  |                |  \\n  |                |  \\n  |                ^ e\\n  |                |  \\n  +----------------+  \\n           d          \\n\\n3. Diverge cut (every 6 segments)\\n           b                 \\n  +----------------+         \\n  |                |         \\n  |                |         \\nc |                | a       \\n  |                |    f    \\n  |                | <----+  \\n  |                |      | e\\n  |                       |  \\n  +-----------------------+  \\n           d                 \\n\\n```\n```\\ndef isSelfCrossing(self, distance: List[int]) -> bool:\\n    n = len(distance)\\n    if n < 4: return False\\n\\n    direction = [[0, 1], [-1, 0], [0, -1], [1, 0]]\\n    def move(x, y, i):\\n        dis = distance[i]\\n        dx, dy = direction[i%4]\\n        return [x + dx*dis, y + dy*dis]\\n\\n    def subtract(p1, p2):\\n        return [p2[i] - p1[i] for i in range(len(p1))]\\n\\n    # check if a p3 is b.w p1 and p2\\n    def check_point_on_segment(p1, p2, p3):\\n        n = len(p1)\\n        r12 = subtract(p1, p2)\\n        r13 = subtract(p1, p3)\\n        \\n        mu = None\\n        for i in range(n):\\n            if r12[i] != 0:\\n                mu = r13[i]/r12[i]\\n                break\\n        return (p1 == p3) or (0<=mu<=1 and all([p1[i] + mu*r12[i] == p3[i] for i in range(n)]))\\n    \\n    # check if segments [p1, p2] and [p3, p4] intersect\\n    def check_segment_intersect(p1, p2, p3, p4):\\n        n = len(p1)\\n        r12 = subtract(p1, p2)\\n        r13 = subtract(p1, p3)\\n        r34 = subtract(p3, p4)\\n        denom = (r34[0]*r12[1] - r12[0]*r34[1])\\n        # the two segments are parallel\\n        if denom == 0:\\n            return check_point_on_segment(p1, p2, p3) or check_point_on_segment(p1, p2, p4)\\n        # the two segments are not parallel\\n        mu = (r34[0]*r13[1] - r13[0]*r34[1])/denom\\n        return 0<=mu<=1 and check_point_on_segment(p3, p4, [p1[i] + mu*r12[i] for i in range(n)])\\n        \\n    x = y = 0\\n    que = deque([[0, 0]])\\n    for i in range(n):\\n        x, y = move(x, y, i)\\n        que.append([x, y])\\n        if len(que) >= 5 and check_segment_intersect(que[0], que[1], que[3], que[4]):\\n            return True\\n        if len(que) >= 6 and check_segment_intersect(que[0], que[1], que[4], que[5]):\\n            return True\\n        if len(que) == 7:\\n            if check_segment_intersect(que[0], que[1], que[5], que[6]):\\n                return True\\n            que.popleft()\\n    \\n    return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3835978,
                "title": "python-solution-3-ways-to-self-cross",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nSimulating the process would take up too much memory and time. We need a geometrical solution\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nLogically break down the possibilities of self cross: it could cross from the left, bottom, or the right. Also, checking beyond 6 previous steps is unnecessary, for any self cross with paths before that would have detected earlier\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(n)$$\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(1)$$\\r\\n# Code\\r\\n```\\r\\nfrom typing import List\\r\\n\\r\\n\\r\\nclass Solution:\\r\\n    \\'\\'\\'\\r\\n    Two points to note: \\r\\n    1. The Cartesian coordinate system is symmetric wih 90 degree rotations\\r\\n    2. To cross a previous path with a future step, one can cross from left, right or from below\\r\\n    \\'\\'\\'\\r\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\r\\n        b = c = d = e = f = 0\\r\\n        for a in distance:\\r\\n            # cross from left\\r\\n            if d > 0 and d >= b and a >= c:\\r\\n                return True\\r\\n            # cross from below\\r\\n            if e > 0 and c <= a + e and b == d:\\r\\n                return True\\r\\n            # cross from the right\\r\\n            if f > 0 and b <= d <= b + f and e <= c <= a + e:\\r\\n                return True\\r\\n            b, c, d, e, f = a, b, c, d, e \\r\\n        return False\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nfrom typing import List\\r\\n\\r\\n\\r\\nclass Solution:\\r\\n    \\'\\'\\'\\r\\n    Two points to note: \\r\\n    1. The Cartesian coordinate system is symmetric wih 90 degree rotations\\r\\n    2. To cross a previous path with a future step, one can cross from left, right or from below\\r\\n    \\'\\'\\'\\r\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\r\\n        b = c = d = e = f = 0\\r\\n        for a in distance:\\r\\n            # cross from left\\r\\n            if d > 0 and d >= b and a >= c:\\r\\n                return True\\r\\n            # cross from below\\r\\n            if e > 0 and c <= a + e and b == d:\\r\\n                return True\\r\\n            # cross from the right\\r\\n            if f > 0 and b <= d <= b + f and e <= c <= a + e:\\r\\n                return True\\r\\n            b, c, d, e, f = a, b, c, d, e \\r\\n        return False\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819803,
                "title": "c-o-n-solution-time-95-53-space-91-06",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        // We can prove that:\\n        // Suppose 0, 1, ..., i-1 is not self-crossing,\\n        // if i doesn\\'t intersect with i-3 and i-5, \\n        // then i doesn\\'t intersect with any segment before i.\\n        // This is because the directions are always changing\\n        // in a sprial: N->W->S->E->N...\\n        int n = distance.size();\\n        for (int i = 3; i < n; ++i) {\\n            int x0 = distance[i];\\n            int x1 = distance[i-1];\\n            int x2 = distance[i-2];\\n            int x3 = distance[i-3];\\n            // i intersects with i-3\\n            if (x0 >= x2 && x1 <= x3) {\\n                return true;\\n            }\\n            // i intersects with i-5\\n            if (i >= 4) {\\n                int d1 = x2 - distance[i-4];\\n                int d2 = x3 - x1;\\n                // when i = 4, consider x[i-5] = 0,\\n                // to detect the corner case that segment 4\\n                // crosses point (0, 0)\\n                int x5 = 0;\\n                if (i >= 5) {\\n                    x5 = distance[i-5];\\n                }\\n                if (d1 >= 0 && d1 <= x0 && d2 >= 0 && d2 <= x5) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        // We can prove that:\\n        // Suppose 0, 1, ..., i-1 is not self-crossing,\\n        // if i doesn\\'t intersect with i-3 and i-5, \\n        // then i doesn\\'t intersect with any segment before i.\\n        // This is because the directions are always changing\\n        // in a sprial: N->W->S->E->N...\\n        int n = distance.size();\\n        for (int i = 3; i < n; ++i) {\\n            int x0 = distance[i];\\n            int x1 = distance[i-1];\\n            int x2 = distance[i-2];\\n            int x3 = distance[i-3];\\n            // i intersects with i-3\\n            if (x0 >= x2 && x1 <= x3) {\\n                return true;\\n            }\\n            // i intersects with i-5\\n            if (i >= 4) {\\n                int d1 = x2 - distance[i-4];\\n                int d2 = x3 - x1;\\n                // when i = 4, consider x[i-5] = 0,\\n                // to detect the corner case that segment 4\\n                // crosses point (0, 0)\\n                int x5 = 0;\\n                if (i >= 5) {\\n                    x5 = distance[i-5];\\n                }\\n                if (d1 >= 0 && d1 <= x0 && d2 >= 0 && d2 <= x5) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778354,
                "title": "c-brute-force",
                "content": "The dirty way: compute coordinates, add points to a list, check intersection between each 2 segments (*the `Intersect` method can be written shorter than that, I know; there\\'s much room for optimization overall*).\\n\\nAnyway, to avoid TLE we can figure out there\\'s a certain limit when comparing segments, as there\\'s no need to look back more than 5 segments. If a intersection occurs based on the provided rules, it will happen within this limited number of moves or it won\\'t happen at all; and this opens the way for a totally different and much more performant approach...\\n\\nPlease upvote below if you reached reading this far :) thank you!\\n\\n# Code\\n```\\npublic class Solution\\n{\\n\\n    bool Intersect(int Ax1, int Ay1, int Ax2, int Ay2, int Bx1, int By1, int Bx2, int By2)\\n    {\\n        bool isAVertical = Ax1 == Ax2;\\n        bool isBVertical = Bx1 == Bx2;\\n\\n        if (Ax1 > Ax2) { var aux = Ax1; Ax1 = Ax2; Ax2 = aux; }\\n        if (Ay1 > Ay2) { var aux = Ay1; Ay1 = Ay2; Ay2 = aux; }\\n        if (Bx1 > Bx2) { var aux = Bx1; Bx1 = Bx2; Bx2 = aux; }\\n        if (By1 > By2) { var aux = By1; By1 = By2; By2 = aux; }\\n\\n        if (isAVertical)\\n        {\\n            if (isBVertical)\\n                return Ax1 == Bx1 && Ay1 <= By2 && Ay2 >= By1;\\n            return Ay1 <= By1 && By1 <= Ay2 && Bx1 <= Ax1 && Ax1 <= Bx2;\\n        }\\n        else\\n        {\\n            if (!isBVertical)\\n                return Ay1 == By1 && Ax1 <= Bx2 && Ax2 >= Bx1;\\n            return By1 <= Ay1 && Ay1 <= By2 && Ax1 <= Bx1 && Bx1 <= Ax2;\\n        }\\n    }\\n\\n    public bool IsSelfCrossing(int[] distance)\\n    {\\n        List<(int x, int y)> l = new();\\n\\n        // 0 - N, 1 - W, 2 - S, 3 - E\\n        int direction = -1;\\n\\n        (int x, int y) lastP = new(0, 0);\\n        l.Add(lastP);\\n\\n        for (int i = 0; i < distance.Length; i++)\\n        {\\n            var d = distance[i];\\n            direction = ++direction % 4;\\n\\n            var newX = lastP.x;\\n            var newY = lastP.y;\\n            switch (direction)\\n            {\\n                case 0: newY += d; break;\\n                case 1: newX -= d; break;\\n                case 2: newY -= d; break;\\n                case 3: newX += d; break;\\n            }\\n            (int x, int y) newPoint = new(newX, newY);\\n\\n            // useless to check before\\n            if (l.Count >= 4)\\n                for (int j = Math.Max(1, l.Count - 5); j < l.Count - 2; j++)\\n                    if (Intersect(l[j - 1].x, l[j - 1].y, l[j].x, l[j].y, l[l.Count - 1].x, l[l.Count - 1].y, newPoint.x, newPoint.y))\\n                        return true;\\n\\n            l.Add(newPoint);\\n            lastP = newPoint;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n\\n    bool Intersect(int Ax1, int Ay1, int Ax2, int Ay2, int Bx1, int By1, int Bx2, int By2)\\n    {\\n        bool isAVertical = Ax1 == Ax2;\\n        bool isBVertical = Bx1 == Bx2;\\n\\n        if (Ax1 > Ax2) { var aux = Ax1; Ax1 = Ax2; Ax2 = aux; }\\n        if (Ay1 > Ay2) { var aux = Ay1; Ay1 = Ay2; Ay2 = aux; }\\n        if (Bx1 > Bx2) { var aux = Bx1; Bx1 = Bx2; Bx2 = aux; }\\n        if (By1 > By2) { var aux = By1; By1 = By2; By2 = aux; }\\n\\n        if (isAVertical)\\n        {\\n            if (isBVertical)\\n                return Ax1 == Bx1 && Ay1 <= By2 && Ay2 >= By1;\\n            return Ay1 <= By1 && By1 <= Ay2 && Bx1 <= Ax1 && Ax1 <= Bx2;\\n        }\\n        else\\n        {\\n            if (!isBVertical)\\n                return Ay1 == By1 && Ax1 <= Bx2 && Ax2 >= Bx1;\\n            return By1 <= Ay1 && Ay1 <= By2 && Ax1 <= Bx1 && Bx1 <= Ax2;\\n        }\\n    }\\n\\n    public bool IsSelfCrossing(int[] distance)\\n    {\\n        List<(int x, int y)> l = new();\\n\\n        // 0 - N, 1 - W, 2 - S, 3 - E\\n        int direction = -1;\\n\\n        (int x, int y) lastP = new(0, 0);\\n        l.Add(lastP);\\n\\n        for (int i = 0; i < distance.Length; i++)\\n        {\\n            var d = distance[i];\\n            direction = ++direction % 4;\\n\\n            var newX = lastP.x;\\n            var newY = lastP.y;\\n            switch (direction)\\n            {\\n                case 0: newY += d; break;\\n                case 1: newX -= d; break;\\n                case 2: newY -= d; break;\\n                case 3: newX += d; break;\\n            }\\n            (int x, int y) newPoint = new(newX, newY);\\n\\n            // useless to check before\\n            if (l.Count >= 4)\\n                for (int j = Math.Max(1, l.Count - 5); j < l.Count - 2; j++)\\n                    if (Intersect(l[j - 1].x, l[j - 1].y, l[j].x, l[j].y, l[l.Count - 1].x, l[l.Count - 1].y, newPoint.x, newPoint.y))\\n                        return true;\\n\\n            l.Add(newPoint);\\n            lastP = newPoint;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770599,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def isSelfCrossing(distance: Array[Int]): Boolean =\\n      if (distance.length <= 3) false\\n      else (3 until distance.length).exists(e =>\\n          distance(e - 2) <= distance(e) && distance(e - 1) <= distance(e - 3) ||\\n          e >= 4 && distance(e - 1) == distance(e - 3) && distance(e - 2) <= distance(e) + distance(e - 4) ||\\n          e >= 5 && distance(e - 4) <= distance(e - 2) && distance(e - 2) <= distance(e) + distance(e - 4) && distance(e - 1) <= distance(e - 3) && distance(e - 3) <= distance(e - 1) + distance(e - 5))\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def isSelfCrossing(distance: Array[Int]): Boolean =\\n      if (distance.length <= 3) false\\n      else (3 until distance.length).exists(e =>\\n          distance(e - 2) <= distance(e) && distance(e - 1) <= distance(e - 3) ||\\n          e >= 4 && distance(e - 1) == distance(e - 3) && distance(e - 2) <= distance(e) + distance(e - 4) ||\\n          e >= 5 && distance(e - 4) <= distance(e - 2) && distance(e - 2) <= distance(e) + distance(e - 4) && distance(e - 1) <= distance(e - 3) && distance(e - 3) <= distance(e - 1) + distance(e - 5))\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3751044,
                "title": "java-solution-explained",
                "content": "# Intuiton -\\nThe given code is a method `isSelfCrossing` that takes an integer array `x` as input and determines if the array represents a self-crossing shape or not. The intuition behind the code is to iterate through the array starting from the fourth element and check for various conditions that indicate a self-crossing shape.\\n\\n# Approach -\\n1. If the length of the array is less than or equal to 3, it is not possible to form a self-crossing shape, so the method returns `false`.\\n2. The loop starts from the fourth element of the array and iterates until the end.\\n3. Within each iteration, the code checks three different conditions to determine if a self-crossing shape is encountered.\\n4. If any of the conditions are satisfied, the method returns `true` indicating a self-crossing shape is present.\\n5. If none of the conditions are met after iterating through the entire array, the method returns `false`.\\n\\n# Complexity - \\n- Time Complexity: The code iterates through the given array once, starting from the fourth element. Therefore, the time complexity is O(n), where n is the length of the array.\\n- Space Complexity: The code uses a constant amount of extra space for variables and does not depend on the input size. Hence, the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean isSelfCrossing(int[] x) {\\n    if (x.length <= 3)\\n      return false;\\n\\n    for (int i = 3; i < x.length; ++i) {\\n      if (x[i - 2] <= x[i] && x[i - 1] <= x[i - 3])\\n        return true;\\n      if (i >= 4 && x[i - 1] == x[i - 3] && x[i - 2] <= x[i] + x[i - 4])\\n        return true;\\n      if (i >= 5 && x[i - 4] <= x[i - 2] && x[i - 2] <= x[i] + x[i - 4] && x[i - 1] <= x[i - 3] &&\\n          x[i - 3] <= x[i - 1] + x[i - 5])\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n  public boolean isSelfCrossing(int[] x) {\\n    if (x.length <= 3)\\n      return false;\\n\\n    for (int i = 3; i < x.length; ++i) {\\n      if (x[i - 2] <= x[i] && x[i - 1] <= x[i - 3])\\n        return true;\\n      if (i >= 4 && x[i - 1] == x[i - 3] && x[i - 2] <= x[i] + x[i - 4])\\n        return true;\\n      if (i >= 5 && x[i - 4] <= x[i - 2] && x[i - 2] <= x[i] + x[i - 4] && x[i - 1] <= x[i - 3] &&\\n          x[i - 3] <= x[i - 1] + x[i - 5])\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704549,
                "title": "spiral-and-same-coordinates-check",
                "content": "# Approach\\nFirst spiral check.\\nSecond each move make new point {0,0}, {0,1}...\\nLast check if we have two points with same coordinates.\\nBut I think there is a case that will not go through this solution.\\nIdk.\\n\\n# Code\\n```\\n        public class Solution\\n        {\\n            public bool IsSelfCrossing(int[] distance)\\n            {\\n                int[][] points = new int[1][];\\n                points[0] = new int[2] { 0, 0 };\\n                int currentx = 0;\\n                int currenty = 0;\\n                int direction = 0;\\n                for (int i = 0; i < distance.Length - 1; i++)\\n                {\\n                    if (i == distance.Length - 2)\\n                    {\\n                        return false;\\n                    }\\n                    if (distance[i+1] - distance[i] >= 1)\\n                    {\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                foreach (var item in distance)\\n                {\\n                    direction++;\\n                    switch (direction)\\n                    {\\n                        case 1:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx;\\n                                points[points.Length - 1][1] = currenty + 1;\\n                                currenty += 1;\\n                            }\\n                            break;\\n                        case 2:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx - 1;\\n                                points[points.Length - 1][1] = currenty;\\n                                currentx -= 1;\\n                            }\\n                            break;\\n                        case 3:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx;\\n                                points[points.Length - 1][1] = currenty - 1;\\n                                currenty -= 1;\\n                            }\\n                            break;\\n                        case 4:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx + 1;\\n                                points[points.Length - 1][1] = currenty;\\n                                currentx += 1;\\n                            }\\n                            direction = 0;\\n                            break;\\n                    }\\n                }\\n                for (int i = 0; i < points.Length; i++)\\n                {\\n                    for (int j = i + 1; j < points.Length; j++)\\n                    {\\n                        if (points[i][0] == points[j][0] && points[i][1] == points[j][1])\\n                        {\\n                            return true;\\n                        }\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n        public class Solution\\n        {\\n            public bool IsSelfCrossing(int[] distance)\\n            {\\n                int[][] points = new int[1][];\\n                points[0] = new int[2] { 0, 0 };\\n                int currentx = 0;\\n                int currenty = 0;\\n                int direction = 0;\\n                for (int i = 0; i < distance.Length - 1; i++)\\n                {\\n                    if (i == distance.Length - 2)\\n                    {\\n                        return false;\\n                    }\\n                    if (distance[i+1] - distance[i] >= 1)\\n                    {\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                foreach (var item in distance)\\n                {\\n                    direction++;\\n                    switch (direction)\\n                    {\\n                        case 1:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx;\\n                                points[points.Length - 1][1] = currenty + 1;\\n                                currenty += 1;\\n                            }\\n                            break;\\n                        case 2:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx - 1;\\n                                points[points.Length - 1][1] = currenty;\\n                                currentx -= 1;\\n                            }\\n                            break;\\n                        case 3:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx;\\n                                points[points.Length - 1][1] = currenty - 1;\\n                                currenty -= 1;\\n                            }\\n                            break;\\n                        case 4:\\n                            for (int i = 1; i <= item; i++)\\n                            {\\n                                Array.Resize(ref points, points.Length + 1);\\n                                points[points.Length - 1] = new int[2];\\n                                points[points.Length - 1][0] = currentx + 1;\\n                                points[points.Length - 1][1] = currenty;\\n                                currentx += 1;\\n                            }\\n                            direction = 0;\\n                            break;\\n                    }\\n                }\\n                for (int i = 0; i < points.Length; i++)\\n                {\\n                    for (int j = i + 1; j < points.Length; j++)\\n                    {\\n                        if (points[i][0] == points[j][0] && points[i][1] == points[j][1])\\n                        {\\n                            return true;\\n                        }\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580993,
                "title": "bad",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance) <= 3:\\n            return False\\n        \\n        for i in range(3, len(distance)):\\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\\n                return True\\n            \\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\\n                return True\\n            \\n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i-1] <= distance[i-3] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] + distance[i-5] >= distance[i-3]:\\n                return True\\n        \\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance) <= 3:\\n            return False\\n        \\n        for i in range(3, len(distance)):\\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\\n                return True\\n            \\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\\n                return True\\n            \\n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i-1] <= distance[i-3] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] + distance[i-5] >= distance[i-3]:\\n                return True\\n        \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538232,
                "title": "best-100ms-efficiency-java-script-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar isSelfCrossing = function(x) {\\n    if (x.length <= 3) {\\n            return false;\\n        }\\n        let i = 2;\\n        // keep spiraling outward\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        // transition from spiraling outward to spiraling inward\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        // keep spiraling inward\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar isSelfCrossing = function(x) {\\n    if (x.length <= 3) {\\n            return false;\\n        }\\n        let i = 2;\\n        // keep spiraling outward\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        // transition from spiraling outward to spiraling inward\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        // keep spiraling inward\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480990,
                "title": "optional-expansion-phase-followed-by-optional-shrinking-phase",
                "content": "# Intuition\\nSo as not to cross, the spiral needs to either keep expanding, or keep shrinking, or start with an expansion phase and switch over once to the shrinking phase.\\n\\n# Code\\n```\\n#include <vector>\\n\\nenum class State\\n{\\n    BEGIN,\\n    EXPANDING,\\n    FIRST_SHRINK,\\n    SHRINKING,\\n};\\n\\nclass Solution\\n{\\npublic:\\n    bool isSelfCrossing(std::vector<int> &distance)\\n    {\\n        State state = State::BEGIN;\\n        for (int i = 2; i < distance.size(); i++)\\n        {\\n            int p = distance[i - 2];\\n            int c = distance[i];\\n            if (c > p)\\n            {\\n                if (state == State::SHRINKING || state == State::FIRST_SHRINK)\\n                {\\n                    return true;\\n                }\\n                state = State::EXPANDING;\\n            }\\n            else if (state == State::SHRINKING)\\n            {\\n                if (c == p) {\\n                    return true;\\n                }\\n                state = State::SHRINKING;\\n            }\\n            else if (state == State::EXPANDING)\\n            {\\n                if (c >= distance[i - 2] - (i >= 4 ? distance[i - 4] : 0))\\n                {\\n                    distance[i - 1] -= distance[i - 3];\\n                }\\n                state = State::FIRST_SHRINK;\\n            }\\n            else if (state == State::BEGIN)\\n            {\\n                state = State::FIRST_SHRINK;\\n            }\\n            else\\n            {\\n                if (c == p) {\\n                    return true;\\n                }\\n                state = State::SHRINKING;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n\\nenum class State\\n{\\n    BEGIN,\\n    EXPANDING,\\n    FIRST_SHRINK,\\n    SHRINKING,\\n};\\n\\nclass Solution\\n{\\npublic:\\n    bool isSelfCrossing(std::vector<int> &distance)\\n    {\\n        State state = State::BEGIN;\\n        for (int i = 2; i < distance.size(); i++)\\n        {\\n            int p = distance[i - 2];\\n            int c = distance[i];\\n            if (c > p)\\n            {\\n                if (state == State::SHRINKING || state == State::FIRST_SHRINK)\\n                {\\n                    return true;\\n                }\\n                state = State::EXPANDING;\\n            }\\n            else if (state == State::SHRINKING)\\n            {\\n                if (c == p) {\\n                    return true;\\n                }\\n                state = State::SHRINKING;\\n            }\\n            else if (state == State::EXPANDING)\\n            {\\n                if (c >= distance[i - 2] - (i >= 4 ? distance[i - 4] : 0))\\n                {\\n                    distance[i - 1] -= distance[i - 3];\\n                }\\n                state = State::FIRST_SHRINK;\\n            }\\n            else if (state == State::BEGIN)\\n            {\\n                state = State::FIRST_SHRINK;\\n            }\\n            else\\n            {\\n                if (c == p) {\\n                    return true;\\n                }\\n                state = State::SHRINKING;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3370250,
                "title": "java-100-easy-solution-0sec",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic boolean isSelfCrossing(int[] x) {\\nboolean arm = false;\\nboolean leg = false;\\nfor (int i = 2; i < x.length; ++i) {\\nint a = f(x, i - 2) - f(x, i - 4);\\nint b = f(x, i - 2);\\n\\nif (arm && x[i] >= b)          return true;  // cross [i - 2]\\nif (leg && x[i] >= a && a > 0) return true;  // cross [i - 4]\\n\\nif (x[i] < a)       arm = true;\\nelse if (x[i] <= b) leg = true;\\n}\\nreturn false;\\n}\\nprivate int f(int[] x, int index) {\\nreturn (index < 0) ? 0 : x[index];\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\npublic boolean isSelfCrossing(int[] x) {\\nboolean arm = false;\\nboolean leg = false;\\nfor (int i = 2; i < x.length; ++i) {\\nint a = f(x, i - 2) - f(x, i - 4);\\nint b = f(x, i - 2);\\n\\nif (arm && x[i] >= b)          return true;  // cross [i - 2]\\nif (leg && x[i] >= a && a > 0) return true;  // cross [i - 4]\\n\\nif (x[i] < a)       arm = true;\\nelse if (x[i] <= b) leg = true;\\n}\\nreturn false;\\n}\\nprivate int f(int[] x, int index) {\\nreturn (index < 0) ? 0 : x[index];\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350069,
                "title": "c-path-crossing",
                "content": "# Intuition\\nTo determine if the path crosses itself, we need to keep track of the coordinates we visit during the movement. We can do this by maintaining two sets - one for the x-coordinates and one for the y-coordinates.\\n# Approach\\nWe will initialize our current coordinates to `(0, 0)` and then move in a counter-clockwise direction using the given `distance` array. During each move, we will check if the new coordinates we reach already exist in our sets. If they do, it means the path has crossed itself, and we return `true`. If not, we add the new coordinates to our sets and continue with the next move.\\n# Complexity\\n- Time complexity:\\n `O(n)` where `n` is the length of the `distance` array since we traverse the array once.\\n\\n\\n- Space complexity:\\n`O(n)` where `n` is the length of the `distance` array, as we may have to store all the visited coordinates.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int len = distance.size();\\n        if (len < 4) {\\n            return false;\\n        }\\n        for (int i = 3; i < len; i++) {\\n            if (distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) {\\n                return true;\\n            }\\n            if (i >= 4 && distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] == distance[i - 3]) {\\n                return true;\\n            }\\n            if (i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i - 4] + distance[i] >= distance[i - 2] && distance[i - 3] >= distance[i - 1] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Geometry",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int len = distance.size();\\n        if (len < 4) {\\n            return false;\\n        }\\n        for (int i = 3; i < len; i++) {\\n            if (distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) {\\n                return true;\\n            }\\n            if (i >= 4 && distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] == distance[i - 3]) {\\n                return true;\\n            }\\n            if (i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i - 4] + distance[i] >= distance[i - 2] && distance[i - 3] >= distance[i - 1] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323479,
                "title": "solution",
                "content": "```C++ []\\nstatic const auto _ = []{ return ios_base::sync_with_stdio(false), 0; }();\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance)\\n    {\\n        int r[7]{};\\n        int i = 0;\\n        for (; i < distance.size(); ++i)\\n        {\\n            __builtin_memmove(&r[1], &r[0], sizeof(int) * 6);\\n            int dx = distance[i] - r[2];\\n            r[0] = dx;\\n            if (dx <= r[4])\\n            {\\n                if (dx >= -r[6])\\n                    r[3] = -r[5];\\n                ++i;\\n                break;\\n            }\\n        }\\n        for (; i < distance.size(); ++i)\\n        {\\n            __builtin_memmove(&r[1], &r[0], sizeof(int) * 6);\\n            int dx = distance[i] - r[2];\\n            if (dx >= r[4])\\n                return true;\\n            r[0] = dx;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        b = c = d = e = 0\\n        x = distance\\n        for a in x:\\n            if d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b):\\n                return True\\n            b, c, d, e, f = a, b, c, d, e\\n        return False\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if (x.length <= 3) {\\n            return false;\\n        }\\n        int i = 2;\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nstatic const auto _ = []{ return ios_base::sync_with_stdio(false), 0; }();\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance)\\n    {\\n        int r[7]{};\\n        int i = 0;\\n        for (; i < distance.size(); ++i)\\n        {\\n            __builtin_memmove(&r[1], &r[0], sizeof(int) * 6);\\n            int dx = distance[i] - r[2];\\n            r[0] = dx;\\n            if (dx <= r[4])\\n            {\\n                if (dx >= -r[6])\\n                    r[3] = -r[5];\\n                ++i;\\n                break;\\n            }\\n        }\\n        for (; i < distance.size(); ++i)\\n        {\\n            __builtin_memmove(&r[1], &r[0], sizeof(int) * 6);\\n            int dx = distance[i] - r[2];\\n            if (dx >= r[4])\\n                return true;\\n            r[0] = dx;\\n        }\\n        return false;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        b = c = d = e = 0\\n        x = distance\\n        for a in x:\\n            if d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b):\\n                return True\\n            b, c, d, e, f = a, b, c, d, e\\n        return False\\n```\n```Java []\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if (x.length <= 3) {\\n            return false;\\n        }\\n        int i = 2;\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313838,
                "title": "spatial-reasoning-explained-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen we consider what a crossing is, it is the moment when we have a planar cross on both the horizontal and vertical axis of their number lines within the last 6 total steps. For this, you need to record 5 current steps and the one you are taking. This will let you know whether or not your current step will incur a crossing as you do. To make this easier to maintain overtime, we can use a deque and the appendleft and pop processes to maintain updates. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake a deque of 5 zeros to represent the last 5 steps in the past \\nThen, for each step in distance \\n- The first even axis offset we will consider is if steps[2] >= steps[0] > 0. This would imply that steps at 2, which is back towards steps at 0, has crossed it on that axis of values \\n- The odd axis will have three parts to it\\n    -  the first of which is if the current step is greater than or equal to the step taken two moves ago \\n    - The second part of the odd axis is if the current step has undone any of the advantage incurred by the prior step at steps 1 less the advance made at steps 3, and that that difference was positive\\n    - The third part is actually an even offset axis, and concerns steps at 2, 4, and 0. If 4 was able to undo the movement of 2 against 0, this is also necessary to be a satisfactory odd offset \\n    - all tgether, the odd offset is determined if the first part is true or both parts two and three are true \\n- If we have an even offset and an odd offset, we have a crossing as we have necessarily crossed both x and y axis of concern \\n- At the end of the check, add the current step to the front of the deque and pop off the last item so it does not grow. \\n\\nIf we never return in the loop we never will, return False   \\n\\nWe do not need more than 5 entries, since whenever we update to a new situation after 6 movements, we have completed three of each axis comparisons. The next one necessarily takes into account the prior moves, and as such is not based on the current location but the changes in location. This is why the odd offset needs to also involve the other prior axis far enough back. \\n\\n# Complexity\\n- Time complexity: O(N) as we take all the steps eventually \\n\\n- Space complexity: O(1) as we only need a deque of size 5 \\n\\n# Code\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        # make a deque of correct size \\n        steps = collections.deque([0, 0, 0, 0, 0])\\n        # for each step we could take \\n        for step in distance : \\n            # if we have an offset cross on the current even axis \\n            even_offset_1 = (steps[2] >= steps[0] > 0)\\n            # if we have either an instance where we have an offset cross on the odd axis most recent\\n            odd_offset_1 = (step >= steps[1])\\n            # or if now have a cross on the odd axis based on prior being positive \\n            odd_offset_2 = (step >= steps[1] - steps[3] >= 0)\\n            # and we had an even crossing offset priorly \\n            even_offset_2 = steps[4] >= steps[2] - steps[0]\\n            # if either odd_offset_1 or even_offset_2 and odd_offset_2 then we had a cross on the odd axis\\n            odd_offset = odd_offset_1 or (even_offset_2 and odd_offset_2)\\n            # if we have a cross on both the even and odd axis, then we have a cross \\n            if even_offset_1 and odd_offset : \\n                return True \\n            # push the current step to the front \\n            steps.appendleft(step)\\n            # remove the last step as you do \\n            steps.pop()\\n        # never crossed never will \\n        return False \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        # make a deque of correct size \\n        steps = collections.deque([0, 0, 0, 0, 0])\\n        # for each step we could take \\n        for step in distance : \\n            # if we have an offset cross on the current even axis \\n            even_offset_1 = (steps[2] >= steps[0] > 0)\\n            # if we have either an instance where we have an offset cross on the odd axis most recent\\n            odd_offset_1 = (step >= steps[1])\\n            # or if now have a cross on the odd axis based on prior being positive \\n            odd_offset_2 = (step >= steps[1] - steps[3] >= 0)\\n            # and we had an even crossing offset priorly \\n            even_offset_2 = steps[4] >= steps[2] - steps[0]\\n            # if either odd_offset_1 or even_offset_2 and odd_offset_2 then we had a cross on the odd axis\\n            odd_offset = odd_offset_1 or (even_offset_2 and odd_offset_2)\\n            # if we have a cross on both the even and odd axis, then we have a cross \\n            if even_offset_1 and odd_offset : \\n                return True \\n            # push the current step to the front \\n            steps.appendleft(step)\\n            # remove the last step as you do \\n            steps.pop()\\n        # never crossed never will \\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142346,
                "title": "c-solution-runtime-23-ms-beats-85-94",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int n = distance.size();\\n        if(n < 4) return false;\\n        for(int i = 3; i < n; i++){\\n            if(distance[i] >= distance[i-2] && distance[i-1] <= distance[i-3]) return true;\\n            if(i >= 4 && distance[i-1] == distance[i-3] && distance[i] + distance[i-4] >= distance[i-2]) return true;\\n            if(i >= 5 && distance[i-2] >= distance[i-4] && distance[i-1] <= distance[i-3] && distance[i] + distance[i-4] >= distance[i-2] && distance[i-1] + distance[i-5] >= distance[i-3]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int n = distance.size();\\n        if(n < 4) return false;\\n        for(int i = 3; i < n; i++){\\n            if(distance[i] >= distance[i-2] && distance[i-1] <= distance[i-3]) return true;\\n            if(i >= 4 && distance[i-1] == distance[i-3] && distance[i] + distance[i-4] >= distance[i-2]) return true;\\n            if(i >= 5 && distance[i-2] >= distance[i-4] && distance[i-1] <= distance[i-3] && distance[i] + distance[i-4] >= distance[i-2] && distance[i-1] + distance[i-5] >= distance[i-3]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109581,
                "title": "cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int n =distance.size();\\n        if(n<4) return false;\\n        distance.insert(distance.begin(),0);\\n       for(int i=3;i<n+1;i++)\\n       {\\n           if(distance[i]>=distance[i-2] && distance[i-1]<=distance[i-3]) \\n           return true;\\n           \\n           if(i>=5){\\n                if(distance[i-1]<=distance[i-3] && distance[i-2]>=distance[i-4]&& distance[i-5]>=distance[i-3]-distance[i-1] && distance[i]>=distance[i-2]-distance[i-4])\\n                return true;\\n           }\\n          \\n       }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        int n =distance.size();\\n        if(n<4) return false;\\n        distance.insert(distance.begin(),0);\\n       for(int i=3;i<n+1;i++)\\n       {\\n           if(distance[i]>=distance[i-2] && distance[i-1]<=distance[i-3]) \\n           return true;\\n           \\n           if(i>=5){\\n                if(distance[i-1]<=distance[i-3] && distance[i-2]>=distance[i-4]&& distance[i-5]>=distance[i-3]-distance[i-1] && distance[i]>=distance[i-2]-distance[i-4])\\n                return true;\\n           }\\n          \\n       }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993831,
                "title": "best-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution to this problem involves checking if the path of the person will cross itself. One way to do this is to check if the path intersects any previous lines that it has traced.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken in the provided code is to iterate through the list of distances and check for specific conditions that would indicate a self-crossing. These conditions include:\\n\\n- The current distance is greater than or equal to the second to last distance and the previous distance is less than or equal to the third to last distance\\n- The current distance is greater than or equal to the second to last distance, the previous distance is equal to the third to last distance, and the fourth to last distance plus the current distance is greater than or equal to the second to last distance\\n- The current distance is greater than or equal to the second to last distance, the previous distance is less than or equal to the third to last distance, the second to last distance is greater than or equal to the fourth to last distance, and the previous distance plus the fifth to last distance is greater than or equal to the third to last distance\\n\\nIf any of these conditions are met, the function returns True. If the loop completes and none of these conditions are met, the function returns False.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance) < 4:\\n            return False\\n        for i in range(3, len(distance)):\\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\\n                return True\\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\\n                return True\\n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] <= distance[i-3] and distance[i-1] + distance[i-5] >= distance[i-3]:\\n                return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        if len(distance) < 4:\\n            return False\\n        for i in range(3, len(distance)):\\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\\n                return True\\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\\n                return True\\n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] <= distance[i-3] and distance[i-1] + distance[i-5] >= distance[i-3]:\\n                return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967081,
                "title": "scala-concise-functional-solution-using-sliding-window",
                "content": "# Intuition\\nSee https://leetcode.com/problems/self-crossing/solutions/79141/another-python/.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nobject Solution {\\n  def isSelfCrossing(distance: Array[Int]): Boolean =\\n    distance.padTo(6, 0).sliding(6).exists { case Array(a, b, c, d, e, f) =>      \\n      d >= b && b > 0 && (a >= c || (a >= c - e && c - e >= 0 && f >= d - b))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def isSelfCrossing(distance: Array[Int]): Boolean =\\n    distance.padTo(6, 0).sliding(6).exists { case Array(a, b, c, d, e, f) =>      \\n      d >= b && b > 0 && (a >= c || (a >= c - e && c - e >= 0 && f >= d - b))\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2939683,
                "title": "simple-c-solution",
                "content": "```\\nbool isSelfCrossing(int* distance, int distanceSize){\\n\\nfor(int i=3;i<distanceSize;i++)\\n{\\nif(distance[i]>=distance[i-2] && distance[i-1]<=distance[i-3])\\n{\\n    return true;\\n}\\nif(i>=4 && distance[i-1]==distance[i-3] && distance[i]+distance[i-4]>=distance[i-2])\\n{\\n    return true;\\n}\\nif(i>=5 && distance[i-2]-distance[i-4]>=0 && distance[i]>=distance[i-2]-distance[i-4] && distance[i-1]>=distance[i-3]-distance[i-5] && distance[i-1]<=distance[i-3])\\n{\\n    return true;\\n}\\n}\\nreturn false;\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nbool isSelfCrossing(int* distance, int distanceSize){\\n\\nfor(int i=3;i<distanceSize;i++)\\n{\\nif(distance[i]>=distance[i-2] && distance[i-1]<=distance[i-3])\\n{\\n    return true;\\n}\\nif(i>=4 && distance[i-1]==distance[i-3] && distance[i]+distance[i-4]>=distance[i-2])\\n{\\n    return true;\\n}\\nif(i>=5 && distance[i-2]-distance[i-4]>=0 && distance[i]>=distance[i-2]-distance[i-4] && distance[i-1]>=distance[i-3]-distance[i-5] && distance[i-1]<=distance[i-3])\\n{\\n    return true;\\n}\\n}\\nreturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2936939,
                "title": "supplement-to-kuangyuan-s-0ms-solution-with-proof-of-correctness",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution is the same as @KuangYuan\\'s 0ms solution. It is the best solution I have seen so far. However, the original answer does not contain a proof to its correctness, which I did here.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] distance) {\\n        if (distance.length <= 3) {\\n            return false;\\n        }\\n        for (int i = 3; i < distance.length; i++) {\\n            if (distance[i] >= distance[i - 2] && distance[i - 3] >= distance[i - 1]) {\\n                return true;\\n            }\\n            if (i >= 4 && distance[i - 1] == distance[i - 3] && distance[i - 2] <= distance[i] + distance[i - 4]) {\\n                return true;\\n            }\\n            if (i >= 5 && distance[i - 3] >= distance[i - 1] && distance[i - 1] >= distance[i - 3] - distance[i - 5]\\n                    && distance[i - 2] >= distance[i - 4]\\n                    && distance[i - 2] <= distance[i - 4] + distance[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n# Proof of Correctness\\nWe use seg[i] to represents the i-th segment, and prove that when we check if seg[i+1] crosses any previous segments, we only need to check seg[i-2] and seg[i-4].\\n\\nFor vertical segments, seg[i].x is the x coordinate. seg[i].y1/y2 is the smaller/larger y coordinate. For horizontal segments, we use seg[i].y and seg[i].x1/x2 respectively.\\n\\nWLOG, assume we are looking at segment i, which goes to the north. And segments 0 to i does not have cross or end meets. Now we consider conditions that could make seg[i+1] cross any previous segment, and prove that for seg[i+1], we only need to check seg[i-2] and seg[i-4] for crossing.\\n\\nBecause seg[i-1] goes to the east, and seg[i-3] goes to the west, we know seg[i-2].x < seg[i].x, and seg[i-2].x < seg[i-4].x. So there are just two cases regarding seg[i-4] and seg[i].\\n\\nCase 1: seg[i].x < seg[i-4].x ( seg[i] is between seg[i-4] and seg[i-2] ):\\nIn this case, we prove that any vertical segment seg[i-2j], j>1 will not overlap with the rectangle formed by seg[i-2],seg[i-1], seg[i], and seg[i+1]. We prove by contradiction. If there is some seg[i-2j] overlaps with the rectangle, look at the largest such j and let i-2j =k. We know seg[k] must go north because there\\'s no self crossing before i, and the only opening of the rectangle (seg[i+1]) is at the north. And because seg[k] is the largest k going out of the rectangle, later segments cannot go back into the rectangle. Use induction we could easily show that without self-crossing, for all i > k we have seg[i].x < seg[k].x. This is contradict to the fact that seg[k].x < seg[i].x < seg[i-4].x, where k < i-4, and complete the proof that there is no vertical segment cross with seg[i+1] between seg[i-2] and seg[i]. As such, seg[i+1] can only cross seg[i-2] when it goes to west.\\n\\nCase 2: seg[i].x > seg[i-4].x:\\nIn this case, we discuss the situation in two subcases.\\n\\nFirst, if seg[i-4].x1 <= seg[i].x2, there will be no vertical edges between seg[i-4] and seg[i] that can potentially cross seg[i+1]. Second, if seg[i-4].x1 > seg[i].x2, there will be no vertical edges between seg[i-2] and seg[i] that can potentially cross seg[i+1]. The process is the same as above (contradiction and induction). So in this case, seg[i+1] can only cross seg[i-4] or seg[i-2].\\n\\nThis shows that in all cases, seg[i+1] can only cross with seg[i-2] and seg[i-4], and complete the cross proof. The proof for end meet is obvious so I will skip here.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] distance) {\\n        if (distance.length <= 3) {\\n            return false;\\n        }\\n        for (int i = 3; i < distance.length; i++) {\\n            if (distance[i] >= distance[i - 2] && distance[i - 3] >= distance[i - 1]) {\\n                return true;\\n            }\\n            if (i >= 4 && distance[i - 1] == distance[i - 3] && distance[i - 2] <= distance[i] + distance[i - 4]) {\\n                return true;\\n            }\\n            if (i >= 5 && distance[i - 3] >= distance[i - 1] && distance[i - 1] >= distance[i - 3] - distance[i - 5]\\n                    && distance[i - 2] >= distance[i - 4]\\n                    && distance[i - 2] <= distance[i - 4] + distance[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928748,
                "title": "don-t-do-this",
                "content": "```\\n#include <vector>\\n#include <iostream>\\n\\n// #define DEBUG\\n\\nusing namespace std;\\n\\nstatic inline void print_xys(int* xs, int* ys) {\\n    for (int i = 0; i < 7; i++) {\\n        cout << \"xy[\" << i << \"] = \" << xs[i] << \", \" << ys[i] << \"\\\\n\";\\n    }\\n    cout << \"\\\\n\";\\n}\\n\\nstatic inline void update_xys(int* xs, int* ys, vector<int>& moves, int move) {\\n    assert(move < moves.size());\\n    for (int i = 0; i < 6; i++) {\\n        xs[i] = xs[i+1];\\n        ys[i] = ys[i+1];\\n    }\\n    xs[6] = (move % 2 == 0) ? xs[5] : ((move % 4 == 1) ? xs[5] - moves[move] : xs[5] + moves[move]);\\n    ys[6] = (move % 2 == 1) ? ys[5] : ((move % 4 == 0) ? ys[5] + moves[move] : ys[5] - moves[move]);\\n}\\n\\nstatic inline bool is_self_crossing(vector<int>& moves) {\\n    // Store the past 5 x\\'s and y\\'s including the current one at\\n    // xs[4], ys[4] (and the transitions from x[i], y[i] to x[i+1], y[i+1])\\n    // corresponds to move[j] where in the beginning j = 0, but then it will\\n    // be shifted by one each time\\n    int xs[7];\\n    int ys[7];\\n    // Before any move\\n    xs[0] = 0;\\n    ys[0] = 0;\\n\\n    if (moves.size() <= 3) return false;\\n    assert(moves.size() >= 4);\\n    // Move 1\\n    xs[1] = xs[0];\\n    ys[1] = ys[0] + moves[0];\\n    // Move 2\\n    xs[2] = xs[1] - moves[1];\\n    ys[2] = ys[1];\\n    // Move 3\\n    xs[3] = xs[2];\\n    ys[3] = ys[2] - moves[2];\\n    // Move 4\\n    xs[4] = xs[3] + moves[3];\\n    ys[4] = ys[3];\\n    \\n    assert(xs[0] == xs[1] && xs[1] > xs[2] && xs[2] == xs[3] && xs[3] < xs[4]);\\n    // assert(ys[0] < ys[1] && ys[1] == ys[2] && ys[2] > ys[3] && ys[3] == ys[4]);\\n\\n    // In four moves you can only end by touching crossing the first line\\n    bool crossed_1st_line = 0 <= ys[4] && 0 <= xs[4];\\n    if (moves.size() == 4 || crossed_1st_line) return crossed_1st_line;\\n\\n    assert(moves.size() >= 5);\\n    xs[5] = xs[4];\\n    ys[5] = ys[4] + moves[4];\\n\\n    // In five moves you can only end by touching teh 2nd line from the bottom\\n    // or crosssing the second line\\n    bool touched_1st_line_tip_or_crossed_2nd = (xs[5] == 0 && ys[5] >= 0) || (xs[5] < 0 && ys[5] > ys[1]);\\n    if (moves.size() == 5 || touched_1st_line_tip_or_crossed_2nd) return touched_1st_line_tip_or_crossed_2nd;\\n    \\n    assert(moves.size() >= 6);\\n    xs[6] = xs[5] - moves[5];\\n    ys[6] = ys[5];\\n    // In six moves you can only end by touching the first line or the third\\n    bool touched_1st_line_or_crossed_3rd = (xs[0] <= xs[5] && xs[6] <= xs[0] && ys[0] <= ys[6] && ys[6] <= ys[1]) || (xs[6] <= xs[2] && ys[6] <= ys[2]);\\n    if (moves.size() == 6 || touched_1st_line_or_crossed_3rd) return touched_1st_line_or_crossed_3rd;\\n    // At this point, depending on whether we are above or below zero, we have to change our update\\n    // based on whether we coming into the rectangle we just drew or outside/around it (hitting a wall)\\n    // We can always tell those last two horizontal segments (image we went down) and we know also if we are\\n    // outside or inside from our relative position so we can tell if we are crossing one of them. Because of that\\n    // quirk, we start to use the last part of the xys\\n    assert(moves.size() >= 7);\\n    for (int move = 6; move < moves.size(); move++) {\\n        update_xys(xs, ys, moves, move);\\n        #ifdef DEBUG\\n        print_xys(xs, ys);\\n        #endif\\n        // as is our last direction of movement, while bs is perpendicular\\n        int *as = xs, *bs = ys;                  // Default Left/Right Move\\n        if (move % 2 == 0) { as = ys; bs = xs; } // Up/Down Move\\n        int front_start = min(bs[0], bs[1]), front_end = max(bs[0], bs[1]);\\n        int back_start = min(bs[2], bs[3]), back_end = max(bs[2], bs[3]);\\n        bool crossed_front = (as[5] <= as[0] && as[6] >= as[0]) || (as[6] >= as[0] && as[6] <= as[0]);\\n        bool crossed_back = (as[5] <= as[2] && as[6] >= as[2]) || (as[5] >= as[2] && as[6] <= as[2]);\\n\\n        // If you crossed the front wall or back wall then we crossed (front wall only possible if you\\'re outside)\\n        if (front_start <= bs[6] && bs[6] <= front_end && crossed_front) return true;\\n        if (back_start <= bs[6] && bs[6] <= back_end && crossed_back) return true;\\n    }\\n    \\n    return false;\\n}\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& moves) { return is_self_crossing(moves); }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <iostream>\\n\\n// #define DEBUG\\n\\nusing namespace std;\\n\\nstatic inline void print_xys(int* xs, int* ys) {\\n    for (int i = 0; i < 7; i++) {\\n        cout << \"xy[\" << i << \"] = \" << xs[i] << \", \" << ys[i] << \"\\\\n\";\\n    }\\n    cout << \"\\\\n\";\\n}\\n\\nstatic inline void update_xys(int* xs, int* ys, vector<int>& moves, int move) {\\n    assert(move < moves.size());\\n    for (int i = 0; i < 6; i++) {\\n        xs[i] = xs[i+1];\\n        ys[i] = ys[i+1];\\n    }\\n    xs[6] = (move % 2 == 0) ? xs[5] : ((move % 4 == 1) ? xs[5] - moves[move] : xs[5] + moves[move]);\\n    ys[6] = (move % 2 == 1) ? ys[5] : ((move % 4 == 0) ? ys[5] + moves[move] : ys[5] - moves[move]);\\n}\\n\\nstatic inline bool is_self_crossing(vector<int>& moves) {\\n    // Store the past 5 x\\'s and y\\'s including the current one at\\n    // xs[4], ys[4] (and the transitions from x[i], y[i] to x[i+1], y[i+1])\\n    // corresponds to move[j] where in the beginning j = 0, but then it will\\n    // be shifted by one each time\\n    int xs[7];\\n    int ys[7];\\n    // Before any move\\n    xs[0] = 0;\\n    ys[0] = 0;\\n\\n    if (moves.size() <= 3) return false;\\n    assert(moves.size() >= 4);\\n    // Move 1\\n    xs[1] = xs[0];\\n    ys[1] = ys[0] + moves[0];\\n    // Move 2\\n    xs[2] = xs[1] - moves[1];\\n    ys[2] = ys[1];\\n    // Move 3\\n    xs[3] = xs[2];\\n    ys[3] = ys[2] - moves[2];\\n    // Move 4\\n    xs[4] = xs[3] + moves[3];\\n    ys[4] = ys[3];\\n    \\n    assert(xs[0] == xs[1] && xs[1] > xs[2] && xs[2] == xs[3] && xs[3] < xs[4]);\\n    // assert(ys[0] < ys[1] && ys[1] == ys[2] && ys[2] > ys[3] && ys[3] == ys[4]);\\n\\n    // In four moves you can only end by touching crossing the first line\\n    bool crossed_1st_line = 0 <= ys[4] && 0 <= xs[4];\\n    if (moves.size() == 4 || crossed_1st_line) return crossed_1st_line;\\n\\n    assert(moves.size() >= 5);\\n    xs[5] = xs[4];\\n    ys[5] = ys[4] + moves[4];\\n\\n    // In five moves you can only end by touching teh 2nd line from the bottom\\n    // or crosssing the second line\\n    bool touched_1st_line_tip_or_crossed_2nd = (xs[5] == 0 && ys[5] >= 0) || (xs[5] < 0 && ys[5] > ys[1]);\\n    if (moves.size() == 5 || touched_1st_line_tip_or_crossed_2nd) return touched_1st_line_tip_or_crossed_2nd;\\n    \\n    assert(moves.size() >= 6);\\n    xs[6] = xs[5] - moves[5];\\n    ys[6] = ys[5];\\n    // In six moves you can only end by touching the first line or the third\\n    bool touched_1st_line_or_crossed_3rd = (xs[0] <= xs[5] && xs[6] <= xs[0] && ys[0] <= ys[6] && ys[6] <= ys[1]) || (xs[6] <= xs[2] && ys[6] <= ys[2]);\\n    if (moves.size() == 6 || touched_1st_line_or_crossed_3rd) return touched_1st_line_or_crossed_3rd;\\n    // At this point, depending on whether we are above or below zero, we have to change our update\\n    // based on whether we coming into the rectangle we just drew or outside/around it (hitting a wall)\\n    // We can always tell those last two horizontal segments (image we went down) and we know also if we are\\n    // outside or inside from our relative position so we can tell if we are crossing one of them. Because of that\\n    // quirk, we start to use the last part of the xys\\n    assert(moves.size() >= 7);\\n    for (int move = 6; move < moves.size(); move++) {\\n        update_xys(xs, ys, moves, move);\\n        #ifdef DEBUG\\n        print_xys(xs, ys);\\n        #endif\\n        // as is our last direction of movement, while bs is perpendicular\\n        int *as = xs, *bs = ys;                  // Default Left/Right Move\\n        if (move % 2 == 0) { as = ys; bs = xs; } // Up/Down Move\\n        int front_start = min(bs[0], bs[1]), front_end = max(bs[0], bs[1]);\\n        int back_start = min(bs[2], bs[3]), back_end = max(bs[2], bs[3]);\\n        bool crossed_front = (as[5] <= as[0] && as[6] >= as[0]) || (as[6] >= as[0] && as[6] <= as[0]);\\n        bool crossed_back = (as[5] <= as[2] && as[6] >= as[2]) || (as[5] >= as[2] && as[6] <= as[2]);\\n\\n        // If you crossed the front wall or back wall then we crossed (front wall only possible if you\\'re outside)\\n        if (front_start <= bs[6] && bs[6] <= front_end && crossed_front) return true;\\n        if (back_start <= bs[6] && bs[6] <= back_end && crossed_back) return true;\\n    }\\n    \\n    return false;\\n}\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& moves) { return is_self_crossing(moves); }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2834715,
                "title": "just-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn is_self_crossing(distance: Vec<i32>) -> bool {\\n        let mut b = 0;\\n        let mut c = 0;\\n        let mut d = 0;\\n        let mut e = 0;\\n        let mut f = 0;\\n        for a in distance.iter() {\\n            if (d >= b && b > 0) && (*a >= c || ((*a >= c - e) && c - e >= 0) && (f >= d - b)) {\\n                return true;\\n            }\\n            f = e;\\n            e = d;\\n            d = c;\\n            c = b;\\n            b = *a;\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_self_crossing(distance: Vec<i32>) -> bool {\\n        let mut b = 0;\\n        let mut c = 0;\\n        let mut d = 0;\\n        let mut e = 0;\\n        let mut f = 0;\\n        for a in distance.iter() {\\n            if (d >= b && b > 0) && (*a >= c || ((*a >= c - e) && c - e >= 0) && (f >= d - b)) {\\n                return true;\\n            }\\n            f = e;\\n            e = d;\\n            d = c;\\n            c = b;\\n            b = *a;\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2824421,
                "title": "swift-136-ms",
                "content": "```\\nclass Solution {\\n    func isSelfCrossing(_ distance: [Int]) -> Bool {\\n        let n = distance.count\\n        guard n > 3 else { return false }\\n        var i = 2\\n        while i < n - 1 {\\n            if distance[i] <= distance[i - 2] { break }\\n            i += 1\\n        }\\n        if i == n - 1 { return false }\\n        let minusPrev = (i >= 4 ? distance[i - 4] : 0) >= distance[i - 2] - distance[i]\\n        let limit = distance[i - 1] - (i > 2 && minusPrev ? distance[i - 3] : 0)\\n        if distance[i + 1] >= limit { return true }\\n        i += 2\\n        while i < n {\\n            if distance[i] >= distance[i - 2] { return true }\\n            i += 1\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isSelfCrossing(_ distance: [Int]) -> Bool {\\n        let n = distance.count\\n        guard n > 3 else { return false }\\n        var i = 2\\n        while i < n - 1 {\\n            if distance[i] <= distance[i - 2] { break }\\n            i += 1\\n        }\\n        if i == n - 1 { return false }\\n        let minusPrev = (i >= 4 ? distance[i - 4] : 0) >= distance[i - 2] - distance[i]\\n        let limit = distance[i - 1] - (i > 2 && minusPrev ? distance[i - 3] : 0)\\n        if distance[i + 1] >= limit { return true }\\n        i += 2\\n        while i < n {\\n            if distance[i] >= distance[i - 2] { return true }\\n            i += 1\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666372,
                "title": "i-m-not-even-programmer-just-learn",
                "content": "I can`t write some great algorithms like other, but I break through with simple abstraction and geometry)))))\\nNot even Last\\n\\n```\\nclass Solution {\\n    enum Direction{\\n        NORTH, WEST, SOUTH, EAST;\\n    }\\n    public boolean isSelfCrossing(int[] distance) {\\n        int mostLeftLine = 0;\\n        int mostRightLine = 0;\\n        int highestLine = 0;\\n        int lowestLine = 0;\\n        LinkedList<Point> pointsList = new LinkedList<>();\\n        Point p = new Point(0, 0);\\n        pointsList.add(p);\\n        LinkedList<LineV> verticalLines = new LinkedList<>();\\n        LinkedList<LineH> horisontalLines = new LinkedList<>();\\n\\n        Direction d = Direction.NORTH;\\n        for (int el :distance){\\n            \\n            switch (d){\\n                case NORTH:\\n                    pointsList.add(p = new Point(p.X, p.Y+el));\\n                    d = Direction.WEST;\\n                    break;\\n                case WEST:\\n                    pointsList.add(p = new Point(p.X-el, p.Y));\\n                    d = Direction.SOUTH;\\n                    break;\\n                case SOUTH:\\n                    pointsList.add(p = new Point(p.X, p.Y-el));\\n                    d = Direction.EAST;\\n                    break;\\n                case EAST:\\n                    pointsList.add(p = new Point(p.X+el, p.Y));\\n                    d = Direction.NORTH;\\n                    break;\\n            }\\n        }\\n\\n        boolean isVertial = true;\\n        while(pointsList.size()>1){\\n            if (isVertial){\\n                LineV v = new LineV(pointsList.removeFirst(), pointsList.getFirst());\\n                if (horisontalLines.size()>1){\\n                    if(v.X > mostRightLine){\\n                        mostRightLine = v.X;\\n                        verticalLines.add(v);\\n                        isVertial = !isVertial;\\n                        continue;\\n                    }\\n                    if(v.X < mostLeftLine){\\n                        mostLeftLine = v.X;\\n                        verticalLines.add(v);\\n                        isVertial = !isVertial;\\n                        continue;\\n                    }\\n                    for(LineH h : horisontalLines){\\n                        if (v.isCrossing(h))\\n                            return true;\\n                    }    \\n                }\\n                verticalLines.add(v);\\n                isVertial = !isVertial;\\n            }\\n            else{\\n                LineH h = new LineH(pointsList.removeFirst(), pointsList.getFirst());\\n                if (h.Y > highestLine){\\n                    highestLine = h.Y;\\n                    horisontalLines.add(h);\\n                    isVertial = !isVertial;\\n                    continue;\\n                }\\n                if (h.Y < lowestLine){\\n                    lowestLine = h.Y;\\n                    horisontalLines.add(h);\\n                    isVertial = !isVertial;\\n                    continue;\\n                }\\n                if (verticalLines.size()>1){\\n                   for(LineV v : verticalLines){\\n                        if (h.isCrossing(v))\\n                            return true;\\n                    } \\n                }\\n                horisontalLines.add(h);\\n                isVertial = !isVertial;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\nclass LineV{\\n    int minY;\\n    int maxY;\\n    int X;\\n    Point start;\\n    Point end;\\n    \\n    LineV(Point s, Point e){\\n        X=s.X;\\n        start = s;\\n        end = e;\\n        minY = Math.min(s.Y, e.Y);\\n        maxY = Math.max(s.Y, e.Y);\\n    }\\n    boolean isCrossing(LineH horisontalLine){\\n        if (end.Y == 0 && X == 0)\\n            return true;\\n        if (horisontalLine.end.Y == start.Y)\\n            return false;\\n        if (X<=horisontalLine.maxX && X>=horisontalLine.minX && horisontalLine.Y <=maxY && horisontalLine.Y>=minY)\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n}\\nclass LineH{\\n    int minX;\\n    int maxX;\\n    int Y;\\n    Point start;\\n    Point end;\\n    \\n    LineH(Point s, Point e){\\n        Y = s.Y;\\n        start = s;\\n        end = e;\\n        minX = Math.min(s.X, e.X);\\n        maxX = Math.max(s.X, e.X);\\n    }\\n    boolean isCrossing(LineV vertialLine){\\n        if (vertialLine.end.Y == start.Y)\\n            return false;\\n        if (Y>=vertialLine.minY && Y<=vertialLine.maxY && minX <= vertialLine.X && maxX >= vertialLine.X)\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n}\\nclass Point{\\n    int X;\\n    int Y;\\n    \\n    public Point(int x, int y){\\n        X=x;\\n        Y=y;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    enum Direction{\\n        NORTH, WEST, SOUTH, EAST;\\n    }\\n    public boolean isSelfCrossing(int[] distance) {\\n        int mostLeftLine = 0;\\n        int mostRightLine = 0;\\n        int highestLine = 0;\\n        int lowestLine = 0;\\n        LinkedList<Point> pointsList = new LinkedList<>();\\n        Point p = new Point(0, 0);\\n        pointsList.add(p);\\n        LinkedList<LineV> verticalLines = new LinkedList<>();\\n        LinkedList<LineH> horisontalLines = new LinkedList<>();\\n\\n        Direction d = Direction.NORTH;\\n        for (int el :distance){\\n            \\n            switch (d){\\n                case NORTH:\\n                    pointsList.add(p = new Point(p.X, p.Y+el));\\n                    d = Direction.WEST;\\n                    break;\\n                case WEST:\\n                    pointsList.add(p = new Point(p.X-el, p.Y));\\n                    d = Direction.SOUTH;\\n                    break;\\n                case SOUTH:\\n                    pointsList.add(p = new Point(p.X, p.Y-el));\\n                    d = Direction.EAST;\\n                    break;\\n                case EAST:\\n                    pointsList.add(p = new Point(p.X+el, p.Y));\\n                    d = Direction.NORTH;\\n                    break;\\n            }\\n        }\\n\\n        boolean isVertial = true;\\n        while(pointsList.size()>1){\\n            if (isVertial){\\n                LineV v = new LineV(pointsList.removeFirst(), pointsList.getFirst());\\n                if (horisontalLines.size()>1){\\n                    if(v.X > mostRightLine){\\n                        mostRightLine = v.X;\\n                        verticalLines.add(v);\\n                        isVertial = !isVertial;\\n                        continue;\\n                    }\\n                    if(v.X < mostLeftLine){\\n                        mostLeftLine = v.X;\\n                        verticalLines.add(v);\\n                        isVertial = !isVertial;\\n                        continue;\\n                    }\\n                    for(LineH h : horisontalLines){\\n                        if (v.isCrossing(h))\\n                            return true;\\n                    }    \\n                }\\n                verticalLines.add(v);\\n                isVertial = !isVertial;\\n            }\\n            else{\\n                LineH h = new LineH(pointsList.removeFirst(), pointsList.getFirst());\\n                if (h.Y > highestLine){\\n                    highestLine = h.Y;\\n                    horisontalLines.add(h);\\n                    isVertial = !isVertial;\\n                    continue;\\n                }\\n                if (h.Y < lowestLine){\\n                    lowestLine = h.Y;\\n                    horisontalLines.add(h);\\n                    isVertial = !isVertial;\\n                    continue;\\n                }\\n                if (verticalLines.size()>1){\\n                   for(LineV v : verticalLines){\\n                        if (h.isCrossing(v))\\n                            return true;\\n                    } \\n                }\\n                horisontalLines.add(h);\\n                isVertial = !isVertial;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\nclass LineV{\\n    int minY;\\n    int maxY;\\n    int X;\\n    Point start;\\n    Point end;\\n    \\n    LineV(Point s, Point e){\\n        X=s.X;\\n        start = s;\\n        end = e;\\n        minY = Math.min(s.Y, e.Y);\\n        maxY = Math.max(s.Y, e.Y);\\n    }\\n    boolean isCrossing(LineH horisontalLine){\\n        if (end.Y == 0 && X == 0)\\n            return true;\\n        if (horisontalLine.end.Y == start.Y)\\n            return false;\\n        if (X<=horisontalLine.maxX && X>=horisontalLine.minX && horisontalLine.Y <=maxY && horisontalLine.Y>=minY)\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n}\\nclass LineH{\\n    int minX;\\n    int maxX;\\n    int Y;\\n    Point start;\\n    Point end;\\n    \\n    LineH(Point s, Point e){\\n        Y = s.Y;\\n        start = s;\\n        end = e;\\n        minX = Math.min(s.X, e.X);\\n        maxX = Math.max(s.X, e.X);\\n    }\\n    boolean isCrossing(LineV vertialLine){\\n        if (vertialLine.end.Y == start.Y)\\n            return false;\\n        if (Y>=vertialLine.minY && Y<=vertialLine.maxY && minX <= vertialLine.X && maxX >= vertialLine.X)\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n}\\nclass Point{\\n    int X;\\n    int Y;\\n    \\n    public Point(int x, int y){\\n        X=x;\\n        Y=y;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650215,
                "title": "c-searching-in-stl-deque-last-4edges-except-immediate-last-and-very-last-point",
                "content": "```\\n#define mp make_pair\\nclass Solution {\\nprivate:\\n    bool isCross(deque<pair<int, pair<int, int>>> &xpath, int x, int ymin, int ymax){\\n        //cout<<x<<\":\"<<ymin << \",\" << ymax<<endl;\\n        if(xpath.size()<=1) return false;\\n        for (auto it = xpath.cbegin();it!=xpath.cend()-1;it++) {\\n            //cout<<*it.first<<\",[\"<<*it.second.first << \",\" << *it.second.second<<\"]\"<<endl;\\n            if ((*it).first > ymax)\\n                continue;\\n            if (ymin > (*it).first)\\n                continue;\\n            if((*it).second.first <= x && x <= (*it).second.second)\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        deque<pair<int, pair<int, int>>> xpath,ypath;\\n        //<x-position<y_low,y_high>> | xpath= vertical lines | ypath=horizontal lines\\n        int x=0,y=0;\\n        for(int i=0; i<distance.size(); i++){\\n            switch(i%4){\\n                case 0:{\\n                    if(isCross(xpath,x,y,y+distance[i])) return true;\\n                    ypath.push_back(mp(x, mp(y, y + distance[i])));\\n                    y += distance[i];\\n                    break;\\n                }\\n                case 1:{\\n                    if(isCross(ypath,y,x-distance[i],x)) return true;\\n                    xpath.push_back(mp(y, mp(x - distance[i], x)));\\n                    x -= distance[i];\\n                    break;\\n                }\\n                case 2:{\\n                    if(isCross(xpath,x,y-distance[i],y)) return true;\\n                    ypath.push_back(mp(x, mp(y - distance[i], y)));\\n                    y -= distance[i];\\n                    break;\\n                }\\n                default:{\\n                    if(isCross(ypath,y,x,x+distance[i])) return true;\\n                    xpath.push_back(mp(y, mp(x, x + distance[i])));\\n                    x += distance[i];\\n                    break;\\n                }\\n            }\\n            while(xpath.size()>3) xpath.erase(xpath.begin());\\n            while(ypath.size()>3) ypath.erase(ypath.begin());\\n        }\\n        if(distance.size()%2!=0){\\n            if (isCross(ypath,y,x,x))\\n                return true;\\n        } else {\\n            if (isCross(xpath,x,y,y))\\n                return true;\\n        }\\n        //cout<<\"x-paths\"<<endl; for(auto i:xpath) cout<<i.first<<\":\"<<i.second.first<<\",\"<<i.second.second<<endl;\\n        //cout<<\"y-paths\"<<endl; for(auto i:ypath) cout<<i.first<<\":\"<<i.second.first<<\",\"<<i.second.second<<endl;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\n#define mp make_pair\\nclass Solution {\\nprivate:\\n    bool isCross(deque<pair<int, pair<int, int>>> &xpath, int x, int ymin, int ymax){\\n        //cout<<x<<\":\"<<ymin << \",\" << ymax<<endl;\\n        if(xpath.size()<=1) return false;\\n        for (auto it = xpath.cbegin();it!=xpath.cend()-1;it++) {\\n            //cout<<*it.first<<\",[\"<<*it.second.first << \",\" << *it.second.second<<\"]\"<<endl;\\n            if ((*it).first > ymax)\\n                continue;\\n            if (ymin > (*it).first)\\n                continue;\\n            if((*it).second.first <= x && x <= (*it).second.second)\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        deque<pair<int, pair<int, int>>> xpath,ypath;\\n        //<x-position<y_low,y_high>> | xpath= vertical lines | ypath=horizontal lines\\n        int x=0,y=0;\\n        for(int i=0; i<distance.size(); i++){\\n            switch(i%4){\\n                case 0:{\\n                    if(isCross(xpath,x,y,y+distance[i])) return true;\\n                    ypath.push_back(mp(x, mp(y, y + distance[i])));\\n                    y += distance[i];\\n                    break;\\n                }\\n                case 1:{\\n                    if(isCross(ypath,y,x-distance[i],x)) return true;\\n                    xpath.push_back(mp(y, mp(x - distance[i], x)));\\n                    x -= distance[i];\\n                    break;\\n                }\\n                case 2:{\\n                    if(isCross(xpath,x,y-distance[i],y)) return true;\\n                    ypath.push_back(mp(x, mp(y - distance[i], y)));\\n                    y -= distance[i];\\n                    break;\\n                }\\n                default:{\\n                    if(isCross(ypath,y,x,x+distance[i])) return true;\\n                    xpath.push_back(mp(y, mp(x, x + distance[i])));\\n                    x += distance[i];\\n                    break;\\n                }\\n            }\\n            while(xpath.size()>3) xpath.erase(xpath.begin());\\n            while(ypath.size()>3) ypath.erase(ypath.begin());\\n        }\\n        if(distance.size()%2!=0){\\n            if (isCross(ypath,y,x,x))\\n                return true;\\n        } else {\\n            if (isCross(xpath,x,y,y))\\n                return true;\\n        }\\n        //cout<<\"x-paths\"<<endl; for(auto i:xpath) cout<<i.first<<\":\"<<i.second.first<<\",\"<<i.second.second<<endl;\\n        //cout<<\"y-paths\"<<endl; for(auto i:ypath) cout<<i.first<<\":\"<<i.second.first<<\",\"<<i.second.second<<endl;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2496230,
                "title": "c-simple-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    if a line segment is horizontal, we push (a, b, x, 0) to visited,\\n    representing the line from (a,b) to (a+x,b).\\n    \\n    if a line segment is vertical, we push (c, d, 0, y) to visited,\\n    representing the line from (c,d) to (c,d+y).\\n    \\n    we make sure that x and y are positive regardless of the direction of the line segment\\n    */\\n    \\n    /*\\n    A horizontal line segment (a,b,x,0) intersects a vertical line segment (c,d,0,y) if \\n              (c,d+y)\\n                ^\\n                |\\n                |    \\n    (a,b) --------------> (a+x,b)\\n                |\\n                |\\n               (c,d)\\n    \\n    (1) a <= c <= a+x\\n    (2) d <= b <= d+y\\n    */\\n\\n    /*\\n    A horizontal line segment (a,b,x,0) intersects another horizontal line segment \\n    (c,d,t,0) if \\n    \\n    (1) b==d; and either one of (2a), (2b), (2c) and (2d) are satisfied\\n    (2a) a <= c <= a+x\\n    (2b) c <= a <= c+t\\n    (2c) a <= c <= c+t <= a+x\\n    (2d) c <= a <= a+x <= c+t\\n    */\\n    \\n    /*\\n    A vertical line segment (a,b,0,y) intersects another vertical line segment \\n    (c,d,0,t) if \\n    \\n    (1) a==c; and either one of (2a), (2b), (2c) and (2d) are satisfied\\n    (2a) b <= d <= b+y\\n    (2b) d <= b <= d+t\\n    (2c) b <= d <= d+t <= b+y\\n    (2d) d <= b <= b+y <= d+t\\n    */\\n    \\n    std::vector<std::vector<int>> visited;\\n    \\n    int x=0, y=0; //current position (x,y)\\n    \\n    void print(std::vector<int> v){\\n        for (int x: v){\\n            std::cout<<x<<\", \";\\n        }\\n        std::cout<<\"\\\\n\";\\n    }\\n    \\n    bool isSelfCrossing(vector<int>& distance) {\\n        int len = distance.size();\\n        std::vector<int> curr, temp;\\n        \\n        if (len<=3) return false;\\n        \\n        for (int i=0; i<len; i++){\\n            if (i%4==0){\\n                visited.push_back(std::vector<int>{x, y, 0, distance[i]});\\n                y += distance[i];\\n            \\n            }else if (i%4==1){\\n                visited.push_back(std::vector<int>{x-distance[i], y, distance[i], 0});\\n                x -= distance[i];\\n                \\n            }else if (i%4==2){\\n                visited.push_back(std::vector<int>{x, y-distance[i], 0, distance[i]});\\n                y -= distance[i];\\n            \\n            }else if (i%4==3){\\n                visited.push_back(std::vector<int>{x, y, distance[i], 0});\\n                x += distance[i];\\n            }\\n             \\n            curr = visited.back();\\n            \\n            if (i>=3){\\n                //check if the current line segment intersects visited[i-3]\\n                temp = visited[i-3];\\n                //(1) curr is horizontal\\n                if (curr[3]==0){\\n                    if (curr[0]<=temp[0] && temp[0]<=curr[0]+curr[2] \\n                        && temp[1]<=curr[1] && curr[1]<=temp[1]+temp[3])\\n                        return true;\\n                }\\n                //(2) curr is vertical\\n                if (curr[2]==0){\\n                    if (curr[1]<=temp[1] && temp[1]<=curr[1]+curr[3]\\n                        && temp[0]<=curr[0] && curr[0]<=temp[0]+temp[2])\\n                        return true;\\n                }\\n            }\\n            \\n            if (i>=4){\\n                //check if the current line segment intersects visited[i-4]\\n                temp = visited[i-4];\\n                //(1) curr is horizontal\\n                if (curr[3]==0){\\n                    if (curr[1]==temp[1] && curr[0]<=temp[0] && temp[0]<=curr[0]+curr[2])\\n                        return true;\\n                    if (curr[1]==temp[1] && temp[0]<=curr[0] && curr[0]<=temp[0]+temp[2])\\n                        return true;\\n                    \\n                    if (curr[1]==temp[1] && curr[0]<=temp[0] \\n                        && temp[0]+temp[2]<=curr[0]+curr[2])\\n                        return true;\\n                    \\n                    if (curr[1]==temp[1] && temp[0]<=curr[0]\\n                        && curr[0]+curr[2]<=temp[0]+temp[2])\\n                        return true;\\n                }\\n                //(2) curr is vertical\\n                if (curr[2]==0){\\n                    if (curr[0]==temp[0] && curr[1]<=temp[1] && temp[1]<=curr[1]+curr[3])\\n                        return true;\\n                    \\n                    if (curr[0]==temp[0] && temp[1]<=curr[1] && curr[1]<=temp[1]+temp[3])\\n                        return true;\\n                    \\n                    if (curr[0]==temp[0] && curr[1]<=temp[1]\\n                        && temp[1]+temp[3]<=curr[1]+curr[3])\\n                        return true;\\n                    \\n                    if (curr[0]==temp[0] && temp[1]<=curr[1]\\n                        && curr[1]+curr[3]<=temp[1]+temp[3])\\n                        return true;\\n                }\\n            }\\n            \\n            if (i>=5){\\n                //check if the current line segment intersects visited[i-5]\\n                temp = visited[i-5];\\n                //(1) curr is horizontal\\n                if (curr[3]==0){\\n                    if (curr[0]<=temp[0] && temp[0]<=curr[0]+curr[2] \\n                        && temp[1]<=curr[1] && curr[1]<=temp[1]+temp[3])\\n                        return true;\\n                }\\n                //(2) curr is vertical\\n                if (curr[2]==0){\\n                    if (curr[1]<=temp[1] && temp[1]<=curr[1]+curr[3]\\n                        && temp[0]<=curr[0] && curr[0]<=temp[0]+temp[2])\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    if a line segment is horizontal, we push (a, b, x, 0) to visited,\\n    representing the line from (a,b) to (a+x,b).\\n    \\n    if a line segment is vertical, we push (c, d, 0, y) to visited,\\n    representing the line from (c,d) to (c,d+y).\\n    \\n    we make sure that x and y are positive regardless of the direction of the line segment\\n    */\\n    \\n    /*\\n    A horizontal line segment (a,b,x,0) intersects a vertical line segment (c,d,0,y) if \\n              (c,d+y)\\n                ^\\n                |\\n                |    \\n    (a,b) --------------> (a+x,b)\\n                |\\n                |\\n               (c,d)\\n    \\n    (1) a <= c <= a+x\\n    (2) d <= b <= d+y\\n    */\\n\\n    /*\\n    A horizontal line segment (a,b,x,0) intersects another horizontal line segment \\n    (c,d,t,0) if \\n    \\n    (1) b==d; and either one of (2a), (2b), (2c) and (2d) are satisfied\\n    (2a) a <= c <= a+x\\n    (2b) c <= a <= c+t\\n    (2c) a <= c <= c+t <= a+x\\n    (2d) c <= a <= a+x <= c+t\\n    */\\n    \\n    /*\\n    A vertical line segment (a,b,0,y) intersects another vertical line segment \\n    (c,d,0,t) if \\n    \\n    (1) a==c; and either one of (2a), (2b), (2c) and (2d) are satisfied\\n    (2a) b <= d <= b+y\\n    (2b) d <= b <= d+t\\n    (2c) b <= d <= d+t <= b+y\\n    (2d) d <= b <= b+y <= d+t\\n    */\\n    \\n    std::vector<std::vector<int>> visited;\\n    \\n    int x=0, y=0; //current position (x,y)\\n    \\n    void print(std::vector<int> v){\\n        for (int x: v){\\n            std::cout<<x<<\", \";\\n        }\\n        std::cout<<\"\\\\n\";\\n    }\\n    \\n    bool isSelfCrossing(vector<int>& distance) {\\n        int len = distance.size();\\n        std::vector<int> curr, temp;\\n        \\n        if (len<=3) return false;\\n        \\n        for (int i=0; i<len; i++){\\n            if (i%4==0){\\n                visited.push_back(std::vector<int>{x, y, 0, distance[i]});\\n                y += distance[i];\\n            \\n            }else if (i%4==1){\\n                visited.push_back(std::vector<int>{x-distance[i], y, distance[i], 0});\\n                x -= distance[i];\\n                \\n            }else if (i%4==2){\\n                visited.push_back(std::vector<int>{x, y-distance[i], 0, distance[i]});\\n                y -= distance[i];\\n            \\n            }else if (i%4==3){\\n                visited.push_back(std::vector<int>{x, y, distance[i], 0});\\n                x += distance[i];\\n            }\\n             \\n            curr = visited.back();\\n            \\n            if (i>=3){\\n                //check if the current line segment intersects visited[i-3]\\n                temp = visited[i-3];\\n                //(1) curr is horizontal\\n                if (curr[3]==0){\\n                    if (curr[0]<=temp[0] && temp[0]<=curr[0]+curr[2] \\n                        && temp[1]<=curr[1] && curr[1]<=temp[1]+temp[3])\\n                        return true;\\n                }\\n                //(2) curr is vertical\\n                if (curr[2]==0){\\n                    if (curr[1]<=temp[1] && temp[1]<=curr[1]+curr[3]\\n                        && temp[0]<=curr[0] && curr[0]<=temp[0]+temp[2])\\n                        return true;\\n                }\\n            }\\n            \\n            if (i>=4){\\n                //check if the current line segment intersects visited[i-4]\\n                temp = visited[i-4];\\n                //(1) curr is horizontal\\n                if (curr[3]==0){\\n                    if (curr[1]==temp[1] && curr[0]<=temp[0] && temp[0]<=curr[0]+curr[2])\\n                        return true;\\n                    if (curr[1]==temp[1] && temp[0]<=curr[0] && curr[0]<=temp[0]+temp[2])\\n                        return true;\\n                    \\n                    if (curr[1]==temp[1] && curr[0]<=temp[0] \\n                        && temp[0]+temp[2]<=curr[0]+curr[2])\\n                        return true;\\n                    \\n                    if (curr[1]==temp[1] && temp[0]<=curr[0]\\n                        && curr[0]+curr[2]<=temp[0]+temp[2])\\n                        return true;\\n                }\\n                //(2) curr is vertical\\n                if (curr[2]==0){\\n                    if (curr[0]==temp[0] && curr[1]<=temp[1] && temp[1]<=curr[1]+curr[3])\\n                        return true;\\n                    \\n                    if (curr[0]==temp[0] && temp[1]<=curr[1] && curr[1]<=temp[1]+temp[3])\\n                        return true;\\n                    \\n                    if (curr[0]==temp[0] && curr[1]<=temp[1]\\n                        && temp[1]+temp[3]<=curr[1]+curr[3])\\n                        return true;\\n                    \\n                    if (curr[0]==temp[0] && temp[1]<=curr[1]\\n                        && curr[1]+curr[3]<=temp[1]+temp[3])\\n                        return true;\\n                }\\n            }\\n            \\n            if (i>=5){\\n                //check if the current line segment intersects visited[i-5]\\n                temp = visited[i-5];\\n                //(1) curr is horizontal\\n                if (curr[3]==0){\\n                    if (curr[0]<=temp[0] && temp[0]<=curr[0]+curr[2] \\n                        && temp[1]<=curr[1] && curr[1]<=temp[1]+temp[3])\\n                        return true;\\n                }\\n                //(2) curr is vertical\\n                if (curr[2]==0){\\n                    if (curr[1]<=temp[1] && temp[1]<=curr[1]+curr[3]\\n                        && temp[0]<=curr[0] && curr[0]<=temp[0]+temp[2])\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2454062,
                "title": "ruby-solution",
                "content": "Thanks to [@KuangYuan](https://leetcode.com/KuangYuan/) for sharing [the approach](https://leetcode.com/problems/self-crossing/discuss/79131/Java-Oms-with-explanation).\\n\\n```\\n# @param {Integer[]} distance\\n# @return {Boolean}\\ndef is_self_crossing(distance)\\n  return false if distance.size < 4\\n\\n  return true if check_four_element(*distance[-4...])\\n\\n  return false if distance.size == 4\\n\\n  return true if check_five_element(*distance[-5...])\\n\\n  distance.each_cons(6) do |long_pair|\\n    if check_six_element(*long_pair)\\n      return true \\n    end\\n  end\\n\\n  false\\nend\\n\\ndef check_four_element(x1, x2, x3, x4)\\n  x1 >= x3 && x4 >= x2\\nend\\n\\ndef check_five_element(x1, x2, x3, x4, x5)\\n  (x1 + x5) >= x3 && x4 == x2 || check_four_element(x1, x2, x3, x4)\\nend\\n\\ndef check_six_element(x1, x2, x3, x4, x5, x6 )\\n  ((x1 + x5) >= x3 && x3 >= x5 && (x6 + x2) >= x4 && x4 >= x2) || check_five_element(x1, x2, x3, x4, x5)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} distance\\n# @return {Boolean}\\ndef is_self_crossing(distance)\\n  return false if distance.size < 4\\n\\n  return true if check_four_element(*distance[-4...])\\n\\n  return false if distance.size == 4\\n\\n  return true if check_five_element(*distance[-5...])\\n\\n  distance.each_cons(6) do |long_pair|\\n    if check_six_element(*long_pair)\\n      return true \\n    end\\n  end\\n\\n  false\\nend\\n\\ndef check_four_element(x1, x2, x3, x4)\\n  x1 >= x3 && x4 >= x2\\nend\\n\\ndef check_five_element(x1, x2, x3, x4, x5)\\n  (x1 + x5) >= x3 && x4 == x2 || check_four_element(x1, x2, x3, x4)\\nend\\n\\ndef check_six_element(x1, x2, x3, x4, x5, x6 )\\n  ((x1 + x5) >= x3 && x3 >= x5 && (x6 + x2) >= x4 && x4 >= x2) || check_five_element(x1, x2, x3, x4, x5)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2261111,
                "title": "time-memory-o-n-simple-typescript-solution",
                "content": "I referred to [this answer post by StefanPochmann](https://leetcode.com/problems/self-crossing/discuss/79141/Another-python...). The figure below is also from the post. I am posting this because I could not find Typescript code on the discussion thread and I thought the Python code on the original post is a little difficult to understand for the people who are not familiar with Python (like me).\\n\\n### Idea\\n\\nThere are two cases (Case 1 and Case 2) for self-crossing. We only need to check if any of these cases appears in any consecutive 6 line drawings. \\nSince the lines are drawn in anti-clockwise and the cases can be defined by relative length and positions of lines, we do not need to consider the absolute coordinates nor orientation of the lines while checking this; we can just assume `a` starts at (0, 0) and moves towards North.\\n\\n```\\nCase 1                         Case 2\\n            b                              b\\n   +----------------+             +----------------+\\n   |                |             |                |\\n   |                |             |                | a\\n c |                |           c |                |\\n   |                | a           |                |    f\\n   +----------->    |             |                | <----+\\n            d       |             |                |      | e\\n                    |             |                       |\\n                                  +-----------------------+\\n                                               d\\n```\\n\\n### Complexity\\n\\nTime: `O(n)`\\nSpace: `O(1)`\\n\\nwhere `n=distance.length`\\n\\n```typescript\\nfunction isSelfCrossing(distance: number[]): boolean {\\n    // omit the line at i=distance.length because it is always self-crossing.\\n    for (let i=0; i<distance.length-1; i+=1) {\\n        const a = distance[i]\\n        const b = distance[i+1] ?? 0\\n        const c = distance[i+2] ?? 0\\n        const d = distance[i+3] ?? 0\\n        const e = distance[i+4] ?? 0\\n        const f = distance[i+5] ?? 0\\n\\t\\t// Case 1\\n        if (c <= a && b <= d) {\\n            return true\\n        }\\n\\t\\t// Case 2\\n        if (a < c && c <= a + e && e <= c && b <= d && d <= b + f) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nCase 1                         Case 2\\n            b                              b\\n   +----------------+             +----------------+\\n   |                |             |                |\\n   |                |             |                | a\\n c |                |           c |                |\\n   |                | a           |                |    f\\n   +----------->    |             |                | <----+\\n            d       |             |                |      | e\\n                    |             |                       |\\n                                  +-----------------------+\\n                                               d\\n```\n```typescript\\nfunction isSelfCrossing(distance: number[]): boolean {\\n    // omit the line at i=distance.length because it is always self-crossing.\\n    for (let i=0; i<distance.length-1; i+=1) {\\n        const a = distance[i]\\n        const b = distance[i+1] ?? 0\\n        const c = distance[i+2] ?? 0\\n        const d = distance[i+3] ?? 0\\n        const e = distance[i+4] ?? 0\\n        const f = distance[i+5] ?? 0\\n\\t\\t// Case 1\\n        if (c <= a && b <= d) {\\n            return true\\n        }\\n\\t\\t// Case 2\\n        if (a < c && c <= a + e && e <= c && b <= d && d <= b + f) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2249979,
                "title": "simple-api",
                "content": "```\\nclass Solution:\\n    def isSelfCrossing(self, x):\\n        n = len(x)\\n        if n < 4: return False\\n        for i in range(3, n):\\n            if x[i] >= x[i-2] and x[i-1] <= x[i-3]: return True\\n            if i >= 4 and x[i-1]==x[i-3] and x[i]+x[i-4]>=x[i-2]: return True\\n            if i >= 5 and 0<=x[i-2]-x[i-4]<=x[i] and 0<=x[i-3]-x[i-1]<=x[i-5]: return True\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, x):\\n        n = len(x)\\n        if n < 4: return False\\n        for i in range(3, n):\\n            if x[i] >= x[i-2] and x[i-1] <= x[i-3]: return True\\n            if i >= 4 and x[i-1]==x[i-3] and x[i]+x[i-4]>=x[i-2]: return True\\n            if i >= 5 and 0<=x[i-2]-x[i-4]<=x[i] and 0<=x[i-3]-x[i-1]<=x[i-5]: return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246654,
                "title": "c-time-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& d) {\\n        int n = d.size();\\n        if (n <3) return false;\\n        int i;\\n        if (d[0] <= d[2] && d[1]<=0) return true;\\n\\n        for (i=3; i<min(n,4); i++)\\n         if (d[i-2] <= d[i] && d[i-1]<=d[i-3]) return true;\\n\\n        if (n>=5)\\n        {\\n            i = 4;\\n            if (d[i-2] <= d[i] && d[i-1]<=d[i-3]) return true;\\n                \\n            if (d[i - 1] <= d[i - 3] && d[i - 1] >= d[i - 3]  &&\\n                d[i - 2] >= d[i - 4] && d[i - 2] <= d[i - 4] + d[i]) return true;\\n        }\\n        for (i=5; i<n; i++)\\n        {\\n            if (d[i-2] <= d[i] && d[i-1]<=d[i-3]) return true;\\n                \\n            if (d[i - 1] <= d[i - 3] && d[i - 1] >= d[i - 3] - d[i - 5] &&\\n                d[i - 2] >= d[i - 4] && d[i - 2] <= d[i - 4] + d[i]) return true;\\n        }\\n       return false;\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& d) {\\n        int n = d.size();\\n        if (n <3) return false;\\n        int i;\\n        if (d[0] <= d[2] && d[1]<=0) return true;\\n\\n        for (i=3; i<min(n,4); i++)\\n         if (d[i-2] <= d[i] && d[i-1]<=d[i-3]) return true;\\n\\n        if (n>=5)\\n        {\\n            i = 4;\\n            if (d[i-2] <= d[i] && d[i-1]<=d[i-3]) return true;\\n                \\n            if (d[i - 1] <= d[i - 3] && d[i - 1] >= d[i - 3]  &&\\n                d[i - 2] >= d[i - 4] && d[i - 2] <= d[i - 4] + d[i]) return true;\\n        }\\n        for (i=5; i<n; i++)\\n        {\\n            if (d[i-2] <= d[i] && d[i-1]<=d[i-3]) return true;\\n                \\n            if (d[i - 1] <= d[i - 3] && d[i - 1] >= d[i - 3] - d[i - 5] &&\\n                d[i - 2] >= d[i - 4] && d[i - 2] <= d[i - 4] + d[i]) return true;\\n        }\\n       return false;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950384,
                "title": "python-very-simple-code-to-understand-self-crossing-problem",
                "content": "Here is the solution for self crossing:\\n \\n        x = distance\\n        for i in range(3,len(x)):  # must have length to intersect\\n            if x[i-3]>=x[i-1] and x[i]>=x[i-2]:  # length of 3rd should be greater than 1st \\n\\t\\t\\t\\t\\treturn True\\n\\n            if i>=4:\\n                if x[i-3] == x[i-1] and x[i-2]<=(x[i-4]+x[i]):\\n                    return True\\n\\n            if i>=5:\\n                if x[i-2]>=x[i-4] and x[i-3]>=x[i-1] and (x[i-5]+x[i-1])>=x[i-3] and (x[i-4]+x[i])>=x[i-2]:\\n                    return True\\n\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "Here is the solution for self crossing:\\n \\n        x = distance\\n        for i in range(3,len(x)):  # must have length to intersect\\n            if x[i-3]>=x[i-1] and x[i]>=x[i-2]:  # length of 3rd should be greater than 1st \\n\\t\\t\\t\\t\\treturn True\\n\\n            if i>=4:\\n                if x[i-3] == x[i-1] and x[i-2]<=(x[i-4]+x[i]):\\n                    return True\\n\\n            if i>=5:\\n                if x[i-2]>=x[i-4] and x[i-3]>=x[i-1] and (x[i-5]+x[i-1])>=x[i-3] and (x[i-4]+x[i])>=x[i-2]:\\n                    return True\\n\\n        return False",
                "codeTag": "Unknown"
            },
            {
                "id": 1912766,
                "title": "python-explained-with-picture",
                "content": "Three cases: (Picture attached at bottom)\\n1.  i crosses i+3\\n2.  i crosses i+4 (actually \"encountering\")\\n3.  i crosses i+5\\n\\nTo be honest, I don\\'t know what\\'s the point of this topic.\\nIt\\'s hard to take all the cases into consideration, in fact, I submitted three wrong answers and used the test cases to modify my code. Not benefiting from this problem.\\n\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        for i in range(len(distance)-2):\\n            # i cross i + 3\\n            if distance[i] >= distance[i+2] and i + 3 < len(distance) and distance[i+3] >= distance[i+1]:\\n                return True\\n            # i encounter i + 4\\n            elif i + 4 < len(distance) and distance[i+1] == distance[i+3] and distance[i] + distance[i+4] == distance[i+2]:\\n                return True\\n            # i cross i + 5\\n            elif i + 5 < len(distance) and 0 <= distance[i+3] - distance[i+1] <= distance[i+5] <= distance[i+3] and 0 <= distance[i+2] - distance[i] <= distance[i+4] <= distance[i+2]:\\n                return True\\n        return False\\n```\\n![image](https://assets.leetcode.com/users/images/0b73046e-b642-4da3-81c2-95728905df10_1649054587.614495.jpeg)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        for i in range(len(distance)-2):\\n            # i cross i + 3\\n            if distance[i] >= distance[i+2] and i + 3 < len(distance) and distance[i+3] >= distance[i+1]:\\n                return True\\n            # i encounter i + 4\\n            elif i + 4 < len(distance) and distance[i+1] == distance[i+3] and distance[i] + distance[i+4] == distance[i+2]:\\n                return True\\n            # i cross i + 5\\n            elif i + 5 < len(distance) and 0 <= distance[i+3] - distance[i+1] <= distance[i+5] <= distance[i+3] and 0 <= distance[i+2] - distance[i] <= distance[i+4] <= distance[i+2]:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817146,
                "title": "python-3-rules-to-solve-them-tests-all",
                "content": "```\\nclass Solution:\\n    def isSelfCrossing(self, d: List[int]) -> bool:        \\n        for i in range(3, len(d)):\\n            if d[i-3] >= d[i-1] and d[i] >= d[i-2]:  return True \\n            \\n            if i > 3:\\n                if d[i-3] == d[i-1] and d[i] + d[i-4] >= d[i-2]:  return True \\n            \\n            if i > 4:\\n                if d[i] + d[i-4] >= d[i-2] and d[i-3] >= d[i-1] and d[i-5] + d[i-1] >= d[i-3] and d[i-2] >  d[i-4] and d[i-3] > d[i-1]:  return True \\n                \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, d: List[int]) -> bool:        \\n        for i in range(3, len(d)):\\n            if d[i-3] >= d[i-1] and d[i] >= d[i-2]:  return True \\n            \\n            if i > 3:\\n                if d[i-3] == d[i-1] and d[i] + d[i-4] >= d[i-2]:  return True \\n            \\n            if i > 4:\\n                if d[i] + d[i-4] >= d[i-2] and d[i-3] >= d[i-1] and d[i-5] + d[i-1] >= d[i-3] and d[i-2] >  d[i-4] and d[i-3] > d[i-1]:  return True \\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416714,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if(distance.size()<=3) return false;\\n        distance.insert(distance.begin(), 0);\\n        int x1, x2, y1, y2;\\n        for(int i=3; i<distance.size(); i++)\\n        {\\n            //check line -3\\n            x1=distance[i-2], y1=distance[i-1], y2=distance[i-1]-distance[i-3];\\n            if(y2<=0 && x1<=distance[i]) return true;\\n            if(i>=5) // check line -5\\n            {\\n                x2=distance[i-2]-distance[i-4];\\n                y1=y2+distance[i-5];\\n                if(y2<=0 && y1>=0 && x2<=distance[i] && x2>=0) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if(distance.size()<=3) return false;\\n        distance.insert(distance.begin(), 0);\\n        int x1, x2, y1, y2;\\n        for(int i=3; i<distance.size(); i++)\\n        {\\n            //check line -3\\n            x1=distance[i-2], y1=distance[i-1], y2=distance[i-1]-distance[i-3];\\n            if(y2<=0 && x1<=distance[i]) return true;\\n            if(i>=5) // check line -5\\n            {\\n                x2=distance[i-2]-distance[i-4];\\n                y1=y2+distance[i-5];\\n                if(y2<=0 && y1>=0 && x2<=distance[i] && x2>=0) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306737,
                "title": "golang-faster-than-100-memory-less-than-100",
                "content": "```go\\nfunc isSelfCrossing(distance []int) bool {\\n\\tdistance = append([]int{0, 0, 0, 0}, distance...)\\n\\tn := len(distance)\\n\\ti := 4\\n\\tfor i < n && distance[i] > distance[i-2] {\\n\\t\\ti++\\n\\t}\\n\\tif i == n {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif distance[i] >= distance[i-2]-distance[i-4] {\\n\\t\\tdistance[i-1] -= distance[i-3]\\n\\t}\\n\\ti = i + 1\\n\\tfor i < n && distance[i] < distance[i-2] {\\n\\t\\ti++\\n\\t}\\n\\treturn i != n\\n\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc isSelfCrossing(distance []int) bool {\\n\\tdistance = append([]int{0, 0, 0, 0}, distance...)\\n\\tn := len(distance)\\n\\ti := 4\\n\\tfor i < n && distance[i] > distance[i-2] {\\n\\t\\ti++\\n\\t}\\n\\tif i == n {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif distance[i] >= distance[i-2]-distance[i-4] {\\n\\t\\tdistance[i-1] -= distance[i-3]\\n\\t}\\n\\ti = i + 1\\n\\tfor i < n && distance[i] < distance[i-2] {\\n\\t\\ti++\\n\\t}\\n\\treturn i != n\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1227441,
                "title": "why-does-the-question-not-specify-that-touching-counts-as-crossing",
                "content": "Or that a line can cross over a line parallel to itself? Is this really a cross != intersect thing?\\n\\nDecent question but it\\'s frustrating for someone who spent a longggg time cobbling together an ugly implementation.",
                "solutionTags": [],
                "code": "Or that a line can cross over a line parallel to itself? Is this really a cross != intersect thing?\\n\\nDecent question but it\\'s frustrating for someone who spent a longggg time cobbling together an ugly implementation.",
                "codeTag": "Unknown"
            },
            {
                "id": 1209866,
                "title": "c-one-pass-set",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if(distance.size()<4)\\n            return false;\\n        set <pair<int,int>> s;\\n        int pos_x=0,pos_y=0;\\n        pair<int,int> p;\\n        p.first=0;\\n        p.second=0;\\n        s.insert(p);\\n        for(int i=0;i<distance.size();i++)\\n        {\\n            if(i%4==0)\\n            {\\n                for(int j=pos_y+1;j<=pos_y+distance[i];j++)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = pos_x;\\n                    pt.second=j;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_y = pos_y + distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n            else if(i%4==1)\\n            {\\n                for(int j=pos_x-1;j>=pos_x-distance[i];j--)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = j;\\n                    pt.second=pos_y;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_x = pos_x - distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n            else if(i%4==2)\\n            {\\n                for(int j=pos_y-1;j>=pos_y-distance[i];j--)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = pos_x;\\n                    pt.second=j;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_y = pos_y - distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n            else if(i%4==3)\\n            {\\n                for(int j=pos_x+1;j<=pos_x+distance[i];j++)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = j;\\n                    pt.second=pos_y;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_x = pos_x + distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\nstatic const int _ = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& distance) {\\n        if(distance.size()<4)\\n            return false;\\n        set <pair<int,int>> s;\\n        int pos_x=0,pos_y=0;\\n        pair<int,int> p;\\n        p.first=0;\\n        p.second=0;\\n        s.insert(p);\\n        for(int i=0;i<distance.size();i++)\\n        {\\n            if(i%4==0)\\n            {\\n                for(int j=pos_y+1;j<=pos_y+distance[i];j++)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = pos_x;\\n                    pt.second=j;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_y = pos_y + distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n            else if(i%4==1)\\n            {\\n                for(int j=pos_x-1;j>=pos_x-distance[i];j--)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = j;\\n                    pt.second=pos_y;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_x = pos_x - distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n            else if(i%4==2)\\n            {\\n                for(int j=pos_y-1;j>=pos_y-distance[i];j--)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = pos_x;\\n                    pt.second=j;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_y = pos_y - distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n            else if(i%4==3)\\n            {\\n                for(int j=pos_x+1;j<=pos_x+distance[i];j++)\\n                {\\n                    pair<int,int> pt;\\n                    pt.first = j;\\n                    pt.second=pos_y;\\n                    if(s.find(pt)==s.end())\\n                    {\\n                        s.insert(pt);\\n                    }\\n                    else\\n                    {\\n                        return true;\\n                    }\\n                }\\n                pos_x = pos_x + distance[i];\\n                cout<<pos_x<<\"  \"<<pos_y<<endl;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\nstatic const int _ = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1177976,
                "title": "readable-python-solution",
                "content": "Other solutions include a well reasoned explanation as to why an intersection must ocurr within the last 6 lines leading to the intersection. This solution uses that fact:\\n\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        def intersects(*args):\\n            def range_intersection(r1, r2):\\n                return range(max(r1.start, r2.start), min(r1.stop, r2.stop))\\n            l1, l2 = sorted(args, key=lambda line: len(line[0])) # Vertical line first\\n\\n            return range_intersection(l1[0], l2[0]) and range_intersection(l1[1], l2[1])\\n\\n        N = (0, -1)\\n        W = (-1, 0)\\n        S = (0, 1)\\n        E = (1, 0)\\n        dirs = itertools.cycle([N,W,S,E])\\n        pos = (0, 0)\\n        lines = []\\n\\n        for dx, dy in ((dist*dir[0], dist*dir[1]) for dist, dir in zip(distance, dirs)):\\n            x_line = [pos[0], pos[0] + dx]\\n            y_line = [pos[1], pos[1] + dy]\\n            current_line = (\\n                    range(min(x_line), max(x_line) + 1),\\n                    range(min(y_line), max(y_line) + 1),\\n                )\\n\\n            if any(intersects(current_line, line) for line in lines[-5:-1]):\\n                return True\\n            lines.append(current_line)\\n            pos = pos[0] + dx, pos[1] + dy\\n\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        def intersects(*args):\\n            def range_intersection(r1, r2):\\n                return range(max(r1.start, r2.start), min(r1.stop, r2.stop))\\n            l1, l2 = sorted(args, key=lambda line: len(line[0])) # Vertical line first\\n\\n            return range_intersection(l1[0], l2[0]) and range_intersection(l1[1], l2[1])\\n\\n        N = (0, -1)\\n        W = (-1, 0)\\n        S = (0, 1)\\n        E = (1, 0)\\n        dirs = itertools.cycle([N,W,S,E])\\n        pos = (0, 0)\\n        lines = []\\n\\n        for dx, dy in ((dist*dir[0], dist*dir[1]) for dist, dir in zip(distance, dirs)):\\n            x_line = [pos[0], pos[0] + dx]\\n            y_line = [pos[1], pos[1] + dy]\\n            current_line = (\\n                    range(min(x_line), max(x_line) + 1),\\n                    range(min(y_line), max(y_line) + 1),\\n                )\\n\\n            if any(intersects(current_line, line) for line in lines[-5:-1]):\\n                return True\\n            lines.append(current_line)\\n            pos = pos[0] + dx, pos[1] + dy\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156017,
                "title": "python-using-dict-and-tuples",
                "content": "Seems like a relativly straight forward solution so I wanted to share.\\n\\n\\'\\'\\'\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:    \\n        path = {}\\n        current_position = [0,0]\\n        path[tuple(current_position)] = True\\n        \\n        # Visualize the path as squares on a checker board\\n        # Add the coordinates of each square visted as a tuple to a hashtable(dict)\\n        for index, steps in enumerate(distance):\\n            \\n            # Mod index to determine the cardinal direction\\n            # step through the squares adding the coordinates along the way.\\n            if ((index + 1) % 4 == 1):\\n                for step in range(steps):\\n                    current_position[1]+= 1\\n                    # Check if square has already been added to path\\n                    # If it has then you have crossed\\n                    if path.get(tuple(current_position)) == True:\\n                        return True\\n                    path[tuple(current_position)] = True\\n            if ((index + 1) % 4 == 2):\\n                for step in range(steps):\\n                    current_position[0]-= 1\\n                    if path.get(tuple(current_position)) == True:\\n                        return True\\n                    path[tuple(current_position)] = True\\n            if ((index + 1) % 4 == 3):\\n                for step in range(steps):\\n                    current_position[1]-= 1\\n                    if path.get(tuple(current_position)) == True:\\n                        return True\\n                    path[tuple(current_position)] = True\\n            if ((index + 1) % 4 == 0):\\n                for step in range(steps):\\n                    current_position[0]+= 1\\n                    if path.get(tuple(current_position)) == True:\\n                        return True\\n                    path[tuple(current_position)] = True\\n        \\n        return False\\n        \\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:    \\n        path = {}",
                "codeTag": "Java"
            },
            {
                "id": 1149356,
                "title": "python-brute-force-it-works",
                "content": "I couldn\\'t figure out what tricks can be applied and, therefore, decided to do it in brute force, which finally pass. Hooray!\\n\\nThe idea is simple. When we draw a vertical line, there are two possible cases of crossover (1) we hit another horizontal line (2) we hit another vertical line. The scenario 2 just means we had two line segments overlap. The two crossover cases for horizontal lines can be easily deducted using the above idea. \\n\\nHere is the code\\n\\n```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        horizontal = []  # (y, left, right, idx)\\n        vertical = []  # (x, top, down, idx)\\n\\n        cur_x, cur_y = 0, 0\\n        direction = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\n\\n        # special binary search\\n        def binary_search(arr, low, high):\\n            # search lower bound\\n            l = 0\\n            r = len(arr)\\n            while l < r:\\n                m = (l + r) // 2\\n                if arr[m][0] < low:\\n                    l = m + 1\\n                else:\\n                    r = m\\n            lower = r\\n\\n            # search upper bound\\n            l = 0\\n            r = len(arr)\\n            while l < r:\\n                m = (l + r) // 2\\n                if arr[m][0] > high:\\n                    r = m\\n                else:\\n                    l = m + 1\\n            return lower, r\\n\\n        for i in range(len(distance)):\\n            phase = i % 4\\n            dx, dy = direction[phase]\\n            next_x, next_y = cur_x + dx * distance[i], cur_y + dy * distance[i]\\n\\n            if phase & 1:\\n                # check intersection with vertical lines\\n                start_idx, end_idx = binary_search(vertical, min(cur_x, next_x), max(cur_x, next_x))\\n\\n                # case 1: touch perpendicular lines\\n                for j in range(start_idx, end_idx):  # O(n)\\n                    if vertical[j][3] != i - 1 and vertical[j][1] <= cur_y <= vertical[j][2]:\\n                        return True\\n\\n                # case 2: touch vertical lines\\n                start_idx, end_idx = binary_search(horizontal, cur_y, cur_y + 0.5)\\n                for j in range(start_idx, end_idx):  # O(n)\\n                    if horizontal[j][1] <= cur_x <= horizontal[j][2] or horizontal[j][1] <= next_x <= horizontal[j][2]:\\n                        return True\\n\\n                # insert current line into horizontal  O(log n )\\n                e = [cur_y, min(cur_x, next_x), max(cur_x, next_x), i]\\n                horizontal.insert(bisect_left(horizontal, e), e)\\n            else:\\n                # check intersection with horizontal lines\\n                start_idx, end_idx = binary_search(horizontal, min(cur_y, next_y), max(cur_y, next_y))\\n                # case 1: touch perpendicular lines\\n                for j in range(start_idx, end_idx):\\n                    if horizontal[j][3] != i - 1 and horizontal[j][1] <= cur_x <= horizontal[j][2]:\\n                        return True\\n\\n                # case 2: touch verticle lines\\n                start_idx, end_idx = binary_search(vertical, cur_x, cur_x + 0.5)\\n                for j in range(start_idx, end_idx):  # O(n)\\n                    if vertical[j][1] <= cur_y <= vertical[j][2] or vertical[j][1] <= next_y <= vertical[j][2]:\\n                        return True\\n\\n                # insert current line into vertical\\n                e = [cur_x, min(cur_y, next_y), max(cur_y, next_y), i]\\n                vertical.insert(bisect_left(vertical, e), e)\\n\\n            cur_x = next_x\\n            cur_y = next_y\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, distance: List[int]) -> bool:\\n        horizontal = []  # (y, left, right, idx)\\n        vertical = []  # (x, top, down, idx)\\n\\n        cur_x, cur_y = 0, 0\\n        direction = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\n\\n        # special binary search\\n        def binary_search(arr, low, high):\\n            # search lower bound\\n            l = 0\\n            r = len(arr)\\n            while l < r:\\n                m = (l + r) // 2\\n                if arr[m][0] < low:\\n                    l = m + 1\\n                else:\\n                    r = m\\n            lower = r\\n\\n            # search upper bound\\n            l = 0\\n            r = len(arr)\\n            while l < r:\\n                m = (l + r) // 2\\n                if arr[m][0] > high:\\n                    r = m\\n                else:\\n                    l = m + 1\\n            return lower, r\\n\\n        for i in range(len(distance)):\\n            phase = i % 4\\n            dx, dy = direction[phase]\\n            next_x, next_y = cur_x + dx * distance[i], cur_y + dy * distance[i]\\n\\n            if phase & 1:\\n                # check intersection with vertical lines\\n                start_idx, end_idx = binary_search(vertical, min(cur_x, next_x), max(cur_x, next_x))\\n\\n                # case 1: touch perpendicular lines\\n                for j in range(start_idx, end_idx):  # O(n)\\n                    if vertical[j][3] != i - 1 and vertical[j][1] <= cur_y <= vertical[j][2]:\\n                        return True\\n\\n                # case 2: touch vertical lines\\n                start_idx, end_idx = binary_search(horizontal, cur_y, cur_y + 0.5)\\n                for j in range(start_idx, end_idx):  # O(n)\\n                    if horizontal[j][1] <= cur_x <= horizontal[j][2] or horizontal[j][1] <= next_x <= horizontal[j][2]:\\n                        return True\\n\\n                # insert current line into horizontal  O(log n )\\n                e = [cur_y, min(cur_x, next_x), max(cur_x, next_x), i]\\n                horizontal.insert(bisect_left(horizontal, e), e)\\n            else:\\n                # check intersection with horizontal lines\\n                start_idx, end_idx = binary_search(horizontal, min(cur_y, next_y), max(cur_y, next_y))\\n                # case 1: touch perpendicular lines\\n                for j in range(start_idx, end_idx):\\n                    if horizontal[j][3] != i - 1 and horizontal[j][1] <= cur_x <= horizontal[j][2]:\\n                        return True\\n\\n                # case 2: touch verticle lines\\n                start_idx, end_idx = binary_search(vertical, cur_x, cur_x + 0.5)\\n                for j in range(start_idx, end_idx):  # O(n)\\n                    if vertical[j][1] <= cur_y <= vertical[j][2] or vertical[j][1] <= next_y <= vertical[j][2]:\\n                        return True\\n\\n                # insert current line into vertical\\n                e = [cur_x, min(cur_y, next_y), max(cur_y, next_y), i]\\n                vertical.insert(bisect_left(vertical, e), e)\\n\\n            cur_x = next_x\\n            cur_y = next_y\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088170,
                "title": "c-intersect-line-solutions",
                "content": "```\\nstruct pt {\\n\\tint x, y;\\n};\\nint area (pt a, pt b, pt c) {\\n\\treturn (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\\n}\\n \\n bool intersect_1 (int a, int b, int c, int d) {\\n\\tif (a > b)  swap (a, b);\\n\\tif (c > d)  swap (c, d);\\n\\treturn max(a,c) <= min(b,d);\\n}\\n \\nbool intersect (pt a, pt b, pt c, pt d) {\\n\\treturn intersect_1 (a.x, b.x, c.x, d.x)\\n\\t\\t&& intersect_1 (a.y, b.y, c.y, d.y)\\n\\t\\t&& area(a,b,c) * area(a,b,d) <= 0\\n\\t\\t&& area(c,d,a) * area(c,d,b) <= 0;\\n}\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(const vector<int>& x) {\\n\\tvector<pt> points;\\n\\tpt p({0,0});\\n\\tpoints.push_back(p);\\n\\t\\n\\tint offsetX = 0;\\n\\tint offsetY = 0;\\n\\tchar wise = 0;\\n\\tfor(int i = 0;i < x.size();i++)\\n\\t{\\n\\t\\tpt p;\\n\\t\\tp.x = offsetX +(i%2 ? (wise == 0 || wise ==3 ? 1 : -1)*x[i] : 0);\\n\\t\\tp.y = offsetY + (i % 2 ? 0  : (wise == 0 || wise ==3 ? 1 : -1)*x[i]);\\n\\t\\toffsetX = p.x;\\n\\t\\toffsetY = p.y;\\n\\t\\tpoints.push_back(p);\\n\\t\\twise++;\\n\\t\\tif(wise == 4) wise = 0;\\n\\t}\\n\\tif(points.size() < 5) return false;\\n\\tfor(int i = 0; i < points.size()-4;i++)\\n\\t{\\n\\t\\tfor(auto j = i+3 ;j < points.size()-1;j++)\\n\\t\\t{\\n\\t\\tif (intersect(points[i],points[i+1],points[j],points[j+1])) return true;\\t\\n\\t\\t}\\n\\t}\\n       return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct pt {\\n\\tint x, y;\\n};\\nint area (pt a, pt b, pt c) {\\n\\treturn (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\\n}\\n \\n bool intersect_1 (int a, int b, int c, int d) {\\n\\tif (a > b)  swap (a, b);\\n\\tif (c > d)  swap (c, d);\\n\\treturn max(a,c) <= min(b,d);\\n}\\n \\nbool intersect (pt a, pt b, pt c, pt d) {\\n\\treturn intersect_1 (a.x, b.x, c.x, d.x)\\n\\t\\t&& intersect_1 (a.y, b.y, c.y, d.y)\\n\\t\\t&& area(a,b,c) * area(a,b,d) <= 0\\n\\t\\t&& area(c,d,a) * area(c,d,b) <= 0;\\n}\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(const vector<int>& x) {\\n\\tvector<pt> points;\\n\\tpt p({0,0});\\n\\tpoints.push_back(p);\\n\\t\\n\\tint offsetX = 0;\\n\\tint offsetY = 0;\\n\\tchar wise = 0;\\n\\tfor(int i = 0;i < x.size();i++)\\n\\t{\\n\\t\\tpt p;\\n\\t\\tp.x = offsetX +(i%2 ? (wise == 0 || wise ==3 ? 1 : -1)*x[i] : 0);\\n\\t\\tp.y = offsetY + (i % 2 ? 0  : (wise == 0 || wise ==3 ? 1 : -1)*x[i]);\\n\\t\\toffsetX = p.x;\\n\\t\\toffsetY = p.y;\\n\\t\\tpoints.push_back(p);\\n\\t\\twise++;\\n\\t\\tif(wise == 4) wise = 0;\\n\\t}\\n\\tif(points.size() < 5) return false;\\n\\tfor(int i = 0; i < points.size()-4;i++)\\n\\t{\\n\\t\\tfor(auto j = i+3 ;j < points.size()-1;j++)\\n\\t\\t{\\n\\t\\tif (intersect(points[i],points[i+1],points[j],points[j+1])) return true;\\t\\n\\t\\t}\\n\\t}\\n       return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082000,
                "title": "has-anyone-ever-considered-what-will-happen-if-the-element-in-array-could-be-0-or-negative",
                "content": "Found it will be interesting if the pre condition changed.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1039547,
                "title": "python3-check-against-last-o-1-segments",
                "content": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        dirs = {0:(0,+1), 1:(-1,0), 2:(0,-1), 3:(+1,0)}\\n        def move(y, z, i):\\n            dy, dz = dirs[i % 4]\\n            ny, nz = y + dy * x[i], z + dz * x[i]\\n            return y, z, ny, nz        \\n        def add(seg):\\n            cache.append(seg)\\n            return seg[2], seg[3]\\n        def crosses(a, b):\\n            if a[1] == a[3] and b[1] != b[3]:\\n                return min(b[1], b[3]) <= a[1] <= max(b[1], b[3]) and \\\\\\n                       min(a[0], a[2]) <= b[0] <= max(a[0], a[2])\\n            else:\\n                return (a[2], a[3]) in ((b[0], b[1]), (b[2], b[3]))\\n        cache = deque()        \\n        y, z = 0, 0\\n        for i in range(len(x)):\\n            seg = move(y, z, i)\\n            for j in range(len(cache)-1):\\n                if crosses(seg, cache[j]) or crosses(cache[j], seg):\\n                    return True\\n            y, z = add(seg)\\n            if len(cache) > 5:\\n                cache.popleft()\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        dirs = {0:(0,+1), 1:(-1,0), 2:(0,-1), 3:(+1,0)}\\n        def move(y, z, i):\\n            dy, dz = dirs[i % 4]\\n            ny, nz = y + dy * x[i], z + dz * x[i]\\n            return y, z, ny, nz        \\n        def add(seg):\\n            cache.append(seg)\\n            return seg[2], seg[3]\\n        def crosses(a, b):\\n            if a[1] == a[3] and b[1] != b[3]:\\n                return min(b[1], b[3]) <= a[1] <= max(b[1], b[3]) and \\\\\\n                       min(a[0], a[2]) <= b[0] <= max(a[0], a[2])\\n            else:\\n                return (a[2], a[3]) in ((b[0], b[1]), (b[2], b[3]))\\n        cache = deque()        \\n        y, z = 0, 0\\n        for i in range(len(x)):\\n            seg = move(y, z, i)\\n            for j in range(len(cache)-1):\\n                if crosses(seg, cache[j]) or crosses(cache[j], seg):\\n                    return True\\n            y, z = add(seg)\\n            if len(cache) > 5:\\n                cache.popleft()\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033787,
                "title": "c-check-whether-the-current-segment-intersects-the-last-8-segments",
                "content": "```\\n    struct PLine {\\n        PLine(int x1, int y1, int x2, int y2): x1(x1), y1(y1), x2(x2), y2(y2) {}\\n        PLine(): x1(0), y1(0), x2(0), y2(0){}\\n        int x1, y1, x2, y2;\\n    };\\n    \\n    void printPt(const PLine& pt) {\\n        printf(\"{(%d,%d),(%d,%d)}\", pt.x1, pt.y1, pt.x2, pt.y2); \\n    }\\n    \\n    bool isBetween(int x, int a, int b) {\\n        return x >= min(a, b) && x <= max(a, b);\\n    }\\n    \\n    bool intersects(const PLine& l1, const PLine& l2) {\\n        if (l1.x1 == l1.x2 && l2.x1 == l2.x2) {\\n            return l1.x1 == l2.x1 && (isBetween(l1.y1, l2.y1, l2.y2) || isBetween(l1.y2, l2.y1, l2.y2));\\n        } else if (l1.y1 == l1.y2 && l2.y1 == l2.y2) {\\n            return l1.y1 == l2.y1 && (isBetween(l1.x1, l2.x1, l2.x2) || isBetween(l1.x2, l2.x1, l2.x2)); \\n        }\\n        \\n        int x_i;\\n        int y_i;\\n        \\n        if (l1.x1 == l1.x2) {\\n            if ((l2.y1 >= min(l1.y1, l1.y2) && l2.y1 <= max(l1.y1, l1.y2)) && \\n                (l1.x1 >= min(l2.x1, l2.x2) && l1.x1 <= max(l2.x1, l2.x2))) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        } else {\\n            return intersects(l2, l1); \\n        }\\n    }\\n    bool isSelfCrossing(vector<int>& x) {\\n        vector<PLine> seen(8); \\n        \\n\\n        int num = 0;\\n        int curr = 0;\\n        array<int, 5> dirs{0, 1, 0, -1, 0};\\n        int dir = 0;\\n        PLine p;\\n        PLine lastPt;\\n        for (int i = 0; i < x.size(); ++i) {\\n            p.x1 = p.x2;\\n            p.y1 = p.y2;\\n            p.x2 += dirs[dir] * x[i];\\n            p.y2 += dirs[dir + 1] * x[i];\\n            dir = (dir + 1) % 4;\\n            for (int z = 0; z < num; ++z) {\\n                if (intersects(p, seen[z])) {\\n                    return true;\\n                }\\n            }\\n            \\n            if (i != 0) {\\n                seen[curr] = lastPt;\\n                curr = (curr + 1) % 8;\\n                num = min(8, num + 1); \\n            }\\n            lastPt = p;\\n        }\\n        return false;\\n        \\n    }\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\n    struct PLine {\\n        PLine(int x1, int y1, int x2, int y2): x1(x1), y1(y1), x2(x2), y2(y2) {}\\n        PLine(): x1(0), y1(0), x2(0), y2(0){}\\n        int x1, y1, x2, y2;\\n    };\\n    \\n    void printPt(const PLine& pt) {\\n        printf(\"{(%d,%d),(%d,%d)}\", pt.x1, pt.y1, pt.x2, pt.y2); \\n    }\\n    \\n    bool isBetween(int x, int a, int b) {\\n        return x >= min(a, b) && x <= max(a, b);\\n    }\\n    \\n    bool intersects(const PLine& l1, const PLine& l2) {\\n        if (l1.x1 == l1.x2 && l2.x1 == l2.x2) {\\n            return l1.x1 == l2.x1 && (isBetween(l1.y1, l2.y1, l2.y2) || isBetween(l1.y2, l2.y1, l2.y2));\\n        } else if (l1.y1 == l1.y2 && l2.y1 == l2.y2) {\\n            return l1.y1 == l2.y1 && (isBetween(l1.x1, l2.x1, l2.x2) || isBetween(l1.x2, l2.x1, l2.x2)); \\n        }\\n        \\n        int x_i;\\n        int y_i;\\n        \\n        if (l1.x1 == l1.x2) {\\n            if ((l2.y1 >= min(l1.y1, l1.y2) && l2.y1 <= max(l1.y1, l1.y2)) && \\n                (l1.x1 >= min(l2.x1, l2.x2) && l1.x1 <= max(l2.x1, l2.x2))) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        } else {\\n            return intersects(l2, l1); \\n        }\\n    }\\n    bool isSelfCrossing(vector<int>& x) {\\n        vector<PLine> seen(8); \\n        \\n\\n        int num = 0;\\n        int curr = 0;\\n        array<int, 5> dirs{0, 1, 0, -1, 0};\\n        int dir = 0;\\n        PLine p;\\n        PLine lastPt;\\n        for (int i = 0; i < x.size(); ++i) {\\n            p.x1 = p.x2;\\n            p.y1 = p.y2;\\n            p.x2 += dirs[dir] * x[i];\\n            p.y2 += dirs[dir + 1] * x[i];\\n            dir = (dir + 1) % 4;\\n            for (int z = 0; z < num; ++z) {\\n                if (intersects(p, seen[z])) {\\n                    return true;\\n                }\\n            }\\n            \\n            if (i != 0) {\\n                seen[curr] = lastPt;\\n                curr = (curr + 1) % 8;\\n                num = min(8, num + 1); \\n            }\\n            lastPt = p;\\n        }\\n        return false;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 994851,
                "title": "java-3-scenarios",
                "content": "```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        for(int i=0; i<x.length; i++){\\n            if(i>=3 && x[i-1]<=x[i-3] && x[i]>=x[i-2])\\n                return true;\\n            if(i>3 && x[i-1]==x[i-3] && x[i-4]+x[i]>=x[i-2])\\n                return true;\\n            if(i>4 && x[i-2]>=x[i-4] && x[i]+x[i-4]>=x[i-2] && x[i-1] <= x[i-3] && x[i-1]+x[i-5]>=x[i-3])\\n                return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        for(int i=0; i<x.length; i++){\\n            if(i>=3 && x[i-1]<=x[i-3] && x[i]>=x[i-2])\\n                return true;\\n            if(i>3 && x[i-1]==x[i-3] && x[i-4]+x[i]>=x[i-2])\\n                return true;\\n            if(i>4 && x[i-2]>=x[i-4] && x[i]+x[i-4]>=x[i-2] && x[i-1] <= x[i-3] && x[i-1]+x[i-5]>=x[i-3])\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 989934,
                "title": "five-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        for (int i = 3; i < x.size(); i++)\\n            if (x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]\\n               ||(i >= 5 && x[i-2] - x[i] <= x[i-4] && x[i-2] >= x[i-4] && x[i-3] - x[i-1] <= x[i-5] && x[i-1] <= x[i-3])\\n               ||(i >= 4 && x[i] + x[i - 4] == x[i - 2] && x[i - 1] == x[i - 3])) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        for (int i = 3; i < x.size(); i++)\\n            if (x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]\\n               ||(i >= 5 && x[i-2] - x[i] <= x[i-4] && x[i-2] >= x[i-4] && x[i-3] - x[i-1] <= x[i-5] && x[i-1] <= x[i-3])\\n               ||(i >= 4 && x[i] + x[i - 4] == x[i - 2] && x[i - 1] == x[i - 3])) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951164,
                "title": "simply-maintain-last-8-segments",
                "content": "\\n```\\nclass Solution:\\n    def isSelfCrossing(self, arr: List[int]) -> bool:\\n        \\n        \\n        # Idea is to maintain last 8 segments. if current segment intersects any of last 8 segments return True! \\n        # WHy ? You can check by drawing different shapes. \\n        \\n        \\n        last_eigth = []\\n        \\n        def check (last_eight, dir, first, second, per_cord):\\n            for i in range (0, len(last_eight)-1):\\n                opo_dir = ((last_eight[i][0] == \\'X\\' and dir == \\'Y\\') or \\n                            (last_eight[i][0] == \\'Y\\' and dir == \\'X\\'))\\n                                \\n                if (opo_dir and  \\n                    last_eight[i][1] <= per_cord <= last_eight[i][2] and\\n                    first <= last_eight[i][3] <= second):\\n                    return True\\n                \\n                if (not opo_dir and last_eight[i][3] == per_cord and \\n                   \\n                   (( first <= last_eight[i][1] <= second) or \\n                    (last_eight[i][1] <= first <= last_eight[i][2]))\\n                   \\n                   ):\\n                    return True\\n                \\n                \\n            return False\\n            \\n        \\n        dir = 0 \\n        x, y = 0,0\\n        for change in arr:\\n            if dir == 0: \\n                if check (last_eigth, \\'Y\\', y, y+change, x): return True \\n                last_eigth.append((\\'Y\\', y, y+change, x))\\n                x, y = x, y+change\\n            if dir == 1:\\n                if check (last_eigth, \\'X\\', x-change, x, y): return True \\n                last_eigth.append((\\'X\\', x-change, x, y))\\n                x, y = x - change, y\\n            if dir == 2:\\n                if check (last_eigth, \\'Y\\', y-change, y, x): return True \\n                last_eigth.append((\\'Y\\', y-change, y, x))\\n                x, y = x, y-change\\n            if dir == 3:\\n                if check (last_eigth, \\'X\\', x, x+change, y): return True \\n                last_eigth.append((\\'X\\', x, x+change, y))\\n                x, y = x + change, y\\n            \\n            if len(last_eigth)> 8: last_eigth.pop(0)\\n            \\n                \\n            dir += 1\\n            dir %= 4 \\n            \\n        return False",
                "solutionTags": [],
                "code": "\\n```\\nclass Solution:\\n    def isSelfCrossing(self, arr: List[int]) -> bool:\\n        \\n        \\n        # Idea is to maintain last 8 segments. if current segment intersects any of last 8 segments return True! \\n        # WHy ? You can check by drawing different shapes. \\n        \\n        \\n        last_eigth = []\\n        \\n        def check (last_eight, dir, first, second, per_cord):\\n            for i in range (0, len(last_eight)-1):\\n                opo_dir = ((last_eight[i][0] == \\'X\\' and dir == \\'Y\\') or \\n                            (last_eight[i][0] == \\'Y\\' and dir == \\'X\\'))\\n                                \\n                if (opo_dir and  \\n                    last_eight[i][1] <= per_cord <= last_eight[i][2] and\\n                    first <= last_eight[i][3] <= second):\\n                    return True\\n                \\n                if (not opo_dir and last_eight[i][3] == per_cord and \\n                   \\n                   (( first <= last_eight[i][1] <= second) or \\n                    (last_eight[i][1] <= first <= last_eight[i][2]))\\n                   \\n                   ):\\n                    return True\\n                \\n                \\n            return False\\n            \\n        \\n        dir = 0 \\n        x, y = 0,0\\n        for change in arr:\\n            if dir == 0: \\n                if check (last_eigth, \\'Y\\', y, y+change, x): return True \\n                last_eigth.append((\\'Y\\', y, y+change, x))\\n                x, y = x, y+change\\n            if dir == 1:\\n                if check (last_eigth, \\'X\\', x-change, x, y): return True \\n                last_eigth.append((\\'X\\', x-change, x, y))\\n                x, y = x - change, y\\n            if dir == 2:\\n                if check (last_eigth, \\'Y\\', y-change, y, x): return True \\n                last_eigth.append((\\'Y\\', y-change, y, x))\\n                x, y = x, y-change\\n            if dir == 3:\\n                if check (last_eigth, \\'X\\', x, x+change, y): return True \\n                last_eigth.append((\\'X\\', x, x+change, y))\\n                x, y = x + change, y\\n            \\n            if len(last_eigth)> 8: last_eigth.pop(0)\\n            \\n                \\n            dir += 1\\n            dir %= 4 \\n            \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 921812,
                "title": "python-o-n-time-and-constant-space-expressive-and-easily-understandable",
                "content": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        def isBetween(x, a, b):\\n            return a <= x and x <= b\\n    \\n        def doIntersectSameOrientation(a, b):\\n            if a == None or b == None:\\n                return False\\n\\n            orient = int(a[0][0] == a[1][0])\\n            \\n            if a[0][(orient + 1) % 2] != b[0][(orient + 1) % 2]:\\n                    return False\\n                \\n            return (isBetween(a[0][orient], b[0][orient], b[1][orient]) or isBetween(a[1][orient], b[0][orient], b[1][orient])) or (a[0][orient] < b[0][orient] and b[1][orient] < a[1][orient])\\n\\n        def doIntersectOppositeOrientation(a, b):\\n            if a == None or b == None:\\n                return False\\n            \\n            v = None\\n            h = None\\n\\n            # identify horizontal and vertical segment\\n            if a[0][1] == a[1][1]:\\n                h = a\\n                v = b\\n            else:\\n                h = b\\n                v = a\\n\\n            if h[0][0] > h[1][0]:\\n                h = (h[1], h[0])\\n    \\n            if v[0][1] > v[1][1]:\\n                v = (v[1], v[0])\\n            \\n            if v[0][0] < h[0][0] or v[0][0] > h[1][0]:\\n                return False\\n            \\n\\t\\t\\tif isBetween(h[0][1], v[0][1], v[1][1]):\\n                return True\\n            \\n            return False\\n        #  [top, left, bottom, right]\\n        borders = [None, None, None, None]\\n        \\n        head = (0, 0)\\n        #  [up, left, down, right]\\n        directions = ((0, 1), (-1, 0), (0, -1), (1, 0))\\n        last_movement = None\\n        for move, magnitude in enumerate(x):\\n            direction_code = move % 4\\n            direction = directions[direction_code]\\n            new_head = (head[0] + magnitude * direction[0], head[1] + magnitude * direction[1])\\n            movement = (head, new_head)\\n            bordersWithSameOrientation = []\\n\\n            if direction_code in [1, 3]:\\n                bordersWithSameOrientation = [0, 2]\\n            else:\\n                bordersWithSameOrientation = [1, 3]\\n\\n            for border in range(4):\\n                crossing = False\\n                if border in bordersWithSameOrientation:\\n                    crossing = doIntersectSameOrientation(movement, borders[border])\\n                else:\\n                    crossing = doIntersectOppositeOrientation(movement, borders[border])\\n                \\n                if crossing:\\n                    return True\\n            \\n            borders[(move + 2) % 4] = last_movement\\n            head = new_head\\n            last_movement = movement\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        def isBetween(x, a, b):\\n            return a <= x and x <= b\\n    \\n        def doIntersectSameOrientation(a, b):\\n            if a == None or b == None:\\n                return False\\n\\n            orient = int(a[0][0] == a[1][0])\\n            \\n            if a[0][(orient + 1) % 2] != b[0][(orient + 1) % 2]:\\n                    return False\\n                \\n            return (isBetween(a[0][orient], b[0][orient], b[1][orient]) or isBetween(a[1][orient], b[0][orient], b[1][orient])) or (a[0][orient] < b[0][orient] and b[1][orient] < a[1][orient])\\n\\n        def doIntersectOppositeOrientation(a, b):\\n            if a == None or b == None:\\n                return False\\n            \\n            v = None\\n            h = None\\n\\n            # identify horizontal and vertical segment\\n            if a[0][1] == a[1][1]:\\n                h = a\\n                v = b\\n            else:\\n                h = b\\n                v = a\\n\\n            if h[0][0] > h[1][0]:\\n                h = (h[1], h[0])\\n    \\n            if v[0][1] > v[1][1]:\\n                v = (v[1], v[0])\\n            \\n            if v[0][0] < h[0][0] or v[0][0] > h[1][0]:\\n                return False\\n            \\n\\t\\t\\tif isBetween(h[0][1], v[0][1], v[1][1]):\\n                return True\\n            \\n            return False\\n        #  [top, left, bottom, right]\\n        borders = [None, None, None, None]\\n        \\n        head = (0, 0)\\n        #  [up, left, down, right]\\n        directions = ((0, 1), (-1, 0), (0, -1), (1, 0))\\n        last_movement = None\\n        for move, magnitude in enumerate(x):\\n            direction_code = move % 4\\n            direction = directions[direction_code]\\n            new_head = (head[0] + magnitude * direction[0], head[1] + magnitude * direction[1])\\n            movement = (head, new_head)\\n            bordersWithSameOrientation = []\\n\\n            if direction_code in [1, 3]:\\n                bordersWithSameOrientation = [0, 2]\\n            else:\\n                bordersWithSameOrientation = [1, 3]\\n\\n            for border in range(4):\\n                crossing = False\\n                if border in bordersWithSameOrientation:\\n                    crossing = doIntersectSameOrientation(movement, borders[border])\\n                else:\\n                    crossing = doIntersectOppositeOrientation(movement, borders[border])\\n                \\n                if crossing:\\n                    return True\\n            \\n            borders[(move + 2) % 4] = last_movement\\n            head = new_head\\n            last_movement = movement\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906557,
                "title": "a-python-method-using-dic-set-tedious-but-work",
                "content": "\\'\\'\\'\\n\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        row, col = defaultdict(set), defaultdict(set)\\n        direction = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\n        \\n        start, step = (0, 0), 0\\n        for move in x:\\n            end = (start[0] + move*direction[step%4][0], start[1] + move*direction[step%4][1])           \\n            cross = 0\\n            if end[0] == start[0]:\\n                rang = set(range(min(end[1], start[1]), max(end[1], start[1])+1))\\n                if end[0] in col and end[1] in col[end[0]]: return True\\n                col[end[0]] |= rang \\n                for line in row:\\n                    if line != start[1] and line in rang and end[0] in row[line]: return True\\n            else:\\n                rang = set(range(min(end[0], start[0]), max(end[0], start[0])+1))\\n                if end[1]in row and end[0] in row[end[1]]: return True\\n                row[end[1]] |= rang\\n                for line in col:\\n                    if line != start[0] and line in rang and end[1] in col[line]: return True\\n            step, start = step + 1, end\\n            \\n        return False",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        row, col = defaultdict(set), defaultdict(set)\\n        direction = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\n        \\n        start, step = (0, 0), 0\\n        for move in x:\\n            end = (start[0] + move*direction[step%4][0], start[1] + move*direction[step%4][1])           \\n            cross = 0\\n            if end[0] == start[0]:\\n                rang = set(range(min(end[1], start[1]), max(end[1], start[1])+1))\\n                if end[0] in col and end[1] in col[end[0]]: return True\\n                col[end[0]] |= rang \\n                for line in row:\\n                    if line != start[1] and line in rang and end[0] in row[line]: return True\\n            else:\\n                rang = set(range(min(end[0], start[0]), max(end[0], start[0])+1))\\n                if end[1]in row and end[0] in row[end[1]]: return True\\n                row[end[1]] |= rang\\n                for line in col:\\n                    if line != start[0] and line in rang and end[1] in col[line]: return True\\n            step, start = step + 1, end\\n            \\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 879727,
                "title": "easy-c-solution-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        int n = x.size();\\n        if(n < 4)return false;\\n        for(int i = 3; i < n; i++){\\n            if(x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]) return true;\\n            if(i >= 4){\\n                if(x[i - 1] == x[i - 3] && x[i] + x[i - 4] >= x[i - 2])return true;\\n            }\\n            if(i >= 5){\\n                if(x[i - 2] >= x[i - 4] && x[i - 3] >= x[i - 1] && x[i - 1] >= x[i - 3] - x[i - 5] && x[i] >= x[i - 2] - x[i - 4])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        int n = x.size();\\n        if(n < 4)return false;\\n        for(int i = 3; i < n; i++){\\n            if(x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]) return true;\\n            if(i >= 4){\\n                if(x[i - 1] == x[i - 3] && x[i] + x[i - 4] >= x[i - 2])return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 831328,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def extend(self, x):\\n        if len(x) < 3: return len(x)\\n        for i in range(2, len(x)):\\n            if x[i] > x[i - 2]: continue\\n            return i\\n        return len(x)\\n        \\n    def shrink(self, x):\\n        if len(x) < 4: return False\\n        for i in range(3, len(x)):\\n            if x[i] < x[i - 2]: continue\\n            return True\\n        return False\\n            \\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        r1 = self.extend(x)\\n        if r1 == len(x): return False\\n        t = x[r1 - 2]\\n        if r1 - 4 >= 0: t -= x[r1 - 4]\\n        tm = x[r1 - 1]\\n        if x[r1] >= t and r1 - 3 >= 0: tm -= x[r1 - 3]\\n        return self.shrink([x[r1 - 2]] + [tm] + x[r1:])\\n```\\n```\\nRuntime: 32 ms, faster than 79.63% of Python3 online submissions.\\nMemory Usage: 13.9 MB, less than 32.72% of Python3 online submissions.\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def extend(self, x):\\n        if len(x) < 3: return len(x)\\n        for i in range(2, len(x)):\\n            if x[i] > x[i - 2]: continue\\n            return i\\n        return len(x)\\n        \\n    def shrink(self, x):\\n        if len(x) < 4: return False\\n        for i in range(3, len(x)):\\n            if x[i] < x[i - 2]: continue\\n            return True\\n        return False\\n            \\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        r1 = self.extend(x)\\n        if r1 == len(x): return False\\n        t = x[r1 - 2]\\n        if r1 - 4 >= 0: t -= x[r1 - 4]\\n        tm = x[r1 - 1]\\n        if x[r1] >= t and r1 - 3 >= 0: tm -= x[r1 - 3]\\n        return self.shrink([x[r1 - 2]] + [tm] + x[r1:])\\n```\n```\\nRuntime: 32 ms, faster than 79.63% of Python3 online submissions.\\nMemory Usage: 13.9 MB, less than 32.72% of Python3 online submissions.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746248,
                "title": "javascript-simple-solution",
                "content": "```\\nvar isSelfCrossing = function(x) {\\n    if (x.length <= 3) {\\n            return false;\\n        }\\n        let i = 2;\\n        // keep spiraling outward\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        // transition from spiraling outward to spiraling inward\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        // keep spiraling inward\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSelfCrossing = function(x) {\\n    if (x.length <= 3) {\\n            return false;\\n        }\\n        let i = 2;\\n        // keep spiraling outward\\n        while (i < x.length && x[i] > x[i - 2]) {\\n            i++;\\n        }\\n        if (i >= x.length) {\\n            return false;\\n        }\\n        // transition from spiraling outward to spiraling inward\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                (i == 3 && x[i] == x[i - 2])) {\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        // keep spiraling inward\\n        while (i < x.length) {\\n            if (x[i] >= x[i - 2]) {\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 712894,
                "title": "my-personal-notes-with-illustration-bilingual",
                "content": "I think this is a tedious question. I cannot come up with any solution, and this one is from Huifeng Guan, who made a video carefully explained how this solution works. If you are familiar with Mandarin, I recommend you can directly [watch the video](https://www.youtube.com/watch?v=W7MyjXDE5xg).\\n\\u6211\\u81EA\\u5DF1\\u8BA4\\u4E3A\\u8FD9\\u662F\\u4E00\\u4E2A\\u5F88\\u65E0\\u804A\\u7684\\u95EE\\u9898\\u3002\\u8FD9\\u4E2A\\u7B54\\u6848\\u6765\\u81EA\\u4E00\\u4F4DYouTuber\\u3002\\u5982\\u679C\\u4F60\\u719F\\u6089\\u666E\\u901A\\u8BDD\\uFF0C\\u53EF\\u4EE5\\u76F4\\u63A5\\u53C2\\u770B\\u4ED6\\u7684\\u89C6\\u9891\\u8BB2\\u89E3\\u3002\\n\\nIf not, you may also refer to my notes which I think summarised well.  \\n\\u5982\\u679C\\u4F60\\u4E0D\\u4F1A\\u666E\\u901A\\u8BDD\\uFF0C\\u4E5F\\u53EF\\u4EE5\\u53C2\\u770B\\u6211\\u7684\\u7B14\\u8BB0\\uFF08\\u6211\\u89C9\\u5F97\\u81EA\\u5DF1\\u505A\\u7684\\u5F88\\u68D2\\uFF09\\n\\nThere are three possible cases for the line-growing.\\n\\u7EBF\\u6761\\u589E\\u957F\\u53EF\\u80FD\\u6709\\u4E09\\u79CD\\u65B9\\u5F0F\\uFF1A\\n\\n* Expand: becoming larger and larger \\u8D8A\\u6765\\u8D8A\\u5927\\n* Shrink: becoming smaller and smaller \\u8D8A\\u6765\\u8D8A\\u5C0F\\n* Expand and then shrink \\u5148\\u53D8\\u5927\\uFF0C\\u518D\\u53D8\\u5C0F\\n\\nThe third one consists of two sub-cases.\\n\\u7B2C\\u4E09\\u79CD\\u4ECD\\u7136\\u6709\\u4E24\\u79CD\\u5B50\\u65B9\\u5F0F\\n\\nThe illustration has adequately addressed all, and it is much more efficient and expressive than my English writing. \\n\\u6211\\u89C9\\u5F97\\u6211\\u7684\\u63D2\\u56FE\\u6BD4\\u6211\\u7684\\u4E8C\\u6D41\\u5B50\\u82F1\\u8BED\\u6709\\u8BF4\\u670D\\u529B\\u591A\\u4E86\\u3002\\n\\n![image](https://assets.leetcode.com/users/images/da6bd1fc-975d-4f0c-afe7-2fdccc5ed2a4_1593514496.2712069.png)\\n![image](https://assets.leetcode.com/users/images/f0ad1127-be28-4ef6-83ef-1552437884c2_1593514508.2953768.png)\\n\\n**Appendix.**\\nThis is my code based on this solution:\\n```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if(x == null || x.length <= 3) {\\n            return false;\\n        }\\n        \\n        int[] edges = new int[x.length + 4];\\n        edges[0] = edges[1] = edges[2] = edges[3] = 0;\\n        for(int i = 0; i < x.length; i++) {\\n            edges[i + 4] = x[i];\\n        }\\n        \\n        int i = 4;\\n        int n = edges.length;\\n        \\n        while(i < n && edges[i] > edges[i - 2]){\\n            i++;\\n        }\\n        \\n        if(i == n){\\n            return false;\\n        }\\n        \\n        if(edges[i] >= edges[i-2] - edges[i-4]){\\n            edges[i-1] = edges[i-1] - edges[i-3];\\n        }\\n        \\n        i++;\\n        \\n        while(i < n && edges[i] < edges[i - 2]) {\\n            i++;\\n        }\\n        \\n        if(i == n){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if(x == null || x.length <= 3) {\\n            return false;\\n        }\\n        \\n        int[] edges = new int[x.length + 4];\\n        edges[0] = edges[1] = edges[2] = edges[3] = 0;\\n        for(int i = 0; i < x.length; i++) {\\n            edges[i + 4] = x[i];\\n        }\\n        \\n        int i = 4;\\n        int n = edges.length;\\n        \\n        while(i < n && edges[i] > edges[i - 2]){\\n            i++;\\n        }\\n        \\n        if(i == n){\\n            return false;\\n        }\\n        \\n        if(edges[i] >= edges[i-2] - edges[i-4]){\\n            edges[i-1] = edges[i-1] - edges[i-3];\\n        }\\n        \\n        i++;\\n        \\n        while(i < n && edges[i] < edges[i - 2]) {\\n            i++;\\n        }\\n        \\n        if(i == n){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710582,
                "title": "python3-complex-number-solution-self-crossing",
                "content": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        def intersect(p1, p2, p3, p4):\\n            v1 = p2 - p1\\n            if v1.real == 0:\\n                return p1.imag <= p3.imag <= p2.imag and p3.real <= p1.real <= p4.real\\n            return p3.imag <= p1.imag <= p4.imag and p1.real <= p3.real <= p2.real\\n        \\n        def overlap(p1, p2, p3, p4):\\n            v1 = p2 - p1\\n            if v1.real == 0:\\n                return min(p2.imag, p4.imag) >= max(p1.imag, p3.imag) and p1.real == p3.real\\n            return min(p2.real, p4.real) >= max(p1.real, p3.real) and p1.imag == p3.imag\\n                \\n        uv = complex(0, 1)\\n        p = complex(0, 0)\\n        segments = deque()\\n        for s in x:\\n            segments.append(sorted([p, (np := p + uv * s)], key=lambda x:(x.real, x.imag)))\\n            if len(segments) > 5 and intersect(*segments[-1], *segments[-6]):\\n                    return True\\n            if len(segments) > 4 and overlap(*segments[-1], *segments[-5]):\\n                    return True\\n            if len(segments) > 3 and intersect(*segments[-1], *segments[-4]):\\n                    return True\\n            if len(segments) == 6:\\n                segments.popleft()\\n            p = np\\n            uv *= complex(0, 1)\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        def intersect(p1, p2, p3, p4):\\n            v1 = p2 - p1\\n            if v1.real == 0:\\n                return p1.imag <= p3.imag <= p2.imag and p3.real <= p1.real <= p4.real\\n            return p3.imag <= p1.imag <= p4.imag and p1.real <= p3.real <= p2.real\\n        \\n        def overlap(p1, p2, p3, p4):\\n            v1 = p2 - p1\\n            if v1.real == 0:\\n                return min(p2.imag, p4.imag) >= max(p1.imag, p3.imag) and p1.real == p3.real\\n            return min(p2.real, p4.real) >= max(p1.real, p3.real) and p1.imag == p3.imag\\n                \\n        uv = complex(0, 1)\\n        p = complex(0, 0)\\n        segments = deque()\\n        for s in x:\\n            segments.append(sorted([p, (np := p + uv * s)], key=lambda x:(x.real, x.imag)))\\n            if len(segments) > 5 and intersect(*segments[-1], *segments[-6]):\\n                    return True\\n            if len(segments) > 4 and overlap(*segments[-1], *segments[-5]):\\n                    return True\\n            if len(segments) > 3 and intersect(*segments[-1], *segments[-4]):\\n                    return True\\n            if len(segments) == 6:\\n                segments.popleft()\\n            p = np\\n            uv *= complex(0, 1)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651583,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n     bool isSelfCrossing(vector<int>& x) {\\n        size_t i=2;\\n        int a=0;\\n        if (x.size()<4) return 0;\\n        while(x[i]>x[i-2]){\\n            if(++i==x.size()-1) return 0;   \\n        }\\n        if (++i>4){\\n            if (x[i-1]>=(x[i-3]-x[i-5])) a=x[i-4];   \\n        }\\n        if (i>3){\\n            if (x[i-1]==x[i-3]&&(x[i-4]+x[i])>=x[i-2]) return 1;  \\n        } \\n        if (x[i]>=(x[i-2]-a)) return 1;\\n        while (++i<x.size()){\\n            if(x[i]>=x[i-2]) return 1;   \\n        }\\n        return 0;\\n     }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     bool isSelfCrossing(vector<int>& x) {\\n        size_t i=2;\\n        int a=0;\\n        if (x.size()<4) return 0;\\n        while(x[i]>x[i-2]){\\n            if(++i==x.size()-1) return 0;   \\n        }\\n        if (++i>4){\\n            if (x[i-1]>=(x[i-3]-x[i-5])) a=x[i-4];   \\n        }\\n        if (i>3){\\n            if (x[i-1]==x[i-3]&&(x[i-4]+x[i])>=x[i-2]) return 1;  \\n        } \\n        if (x[i]>=(x[i-2]-a)) return 1;\\n        while (++i<x.size()){\\n            if(x[i]>=x[i-2]) return 1;   \\n        }\\n        return 0;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616427,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n     bool isSelfCrossing(vector<int>& x) {\\n    size_t i=2;\\n    int a=0;\\n    if (x.size()<4) return 0;\\n    while(x[i]>x[i-2])\\n        if(++i==x.size()-1) return 0;\\n        if (++i>4) \\n              if (x[i-1]>=(x[i-3]-x[i-5])) a=x[i-4];\\n        if (i>3) \\n              if (x[i-1]==x[i-3]&&(x[i-4]+x[i])>=x[i-2]) return 1;\\n        if (x[i]>=(x[i-2]-a)) return 1;\\n      while (++i<x.size())\\n          if(x[i]>=x[i-2]) return 1;\\n    return 0;\\n     }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     bool isSelfCrossing(vector<int>& x) {\\n    size_t i=2;\\n    int a=0;\\n    if (x.size()<4) return 0;\\n    while(x[i]>x[i-2])\\n        if(++i==x.size()-1) return 0;\\n        if (++i>4) \\n              if (x[i-1]>=(x[i-3]-x[i-5])) a=x[i-4];\\n        if (i>3) \\n              if (x[i-1]==x[i-3]&&(x[i-4]+x[i])>=x[i-2]) return 1;\\n        if (x[i]>=(x[i-2]-a)) return 1;\\n      while (++i<x.size())\\n          if(x[i]>=x[i-2]) return 1;\\n    return 0;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557119,
                "title": "c-solution-0ms-run-time-o-n-2-at-worst",
                "content": "Starts at data index 2. As long as each value is larger than the value two steps earlier, there will never be any crossing. When there is a value smaller than two steps prior though, everything change. From now on, as soon as a value is larger than the one two steps earlier, there is a crossing. (The three lines of code between the loops checks for the two special cases in the transistion: that the first value after leaving the loop hits the line created by the value five steps prior, either from the side or by hitting it from straight behind.)\\n```\\n bool isSelfCrossing(vector<int>& x) {\\n  size_t i=2;int a=0;if(x.size()<4)return 0;\\n  while(x[i]>x[i-2])if(++i==x.size()-1)return 0;\\n  if(++i>4)if(x[i-1]>=(x[i-3]-x[i-5]))a=x[i-4];\\n  if(i>3)if(x[i-1]==x[i-3]&&(x[i-4]+x[i])>=x[i-2])return 1;\\n  if(x[i]>=(x[i-2]-a))return 1;\\n  while(++i<x.size())if(x[i]>=x[i-2])return 1;\\n  return 0;\\n }\\n```",
                "solutionTags": [],
                "code": "```\\n bool isSelfCrossing(vector<int>& x) {\\n  size_t i=2;int a=0;if(x.size()<4)return 0;\\n  while(x[i]>x[i-2])if(++i==x.size()-1)return 0;\\n  if(++i>4)if(x[i-1]>=(x[i-3]-x[i-5]))a=x[i-4];\\n  if(i>3)if(x[i-1]==x[i-3]&&(x[i-4]+x[i])>=x[i-2])return 1;\\n  if(x[i]>=(x[i-2]-a))return 1;\\n  while(++i<x.size())if(x[i]>=x[i-2])return 1;\\n  return 0;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 534229,
                "title": "python3-solution-and-only-one-line-line-3",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.isSelfCrossing = lambda x, position=(0, 0), way=[(0, 0)], num=0: (self.isSelfCrossing(x=x, position=(position[0], position[1] + x[num]), way=way + [(position[0], position[1] + i) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 0 else (self.isSelfCrossing(x=x, position=(position[0] - x[num], position[1]), way=way + [(position[0] - i, position[1]) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 1 else (self.isSelfCrossing(x=x, position=(position[0], position[1] - x[num]), way=way + [(position[0], position[1] - i) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 2 else (self.isSelfCrossing(x=x, position=(position[0] + x[num], position[1]), way=way + [(position[0] + i, position[1]) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 3 else -1)))) if num < len(x) else (True if True in [True if way.count(i) >= 2 else False for i in way] else False)\\n\\n\\na = Solution()\\nprint(a.isSelfCrossing([2, 1, 1, 2]))\\nprint(a.isSelfCrossing([1, 2, 3, 4]))\\nprint(a.isSelfCrossing([1, 1, 1, 1]))\\nprint(a.isSelfCrossing([2, 2, 3, 3, 2, 3]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.isSelfCrossing = lambda x, position=(0, 0), way=[(0, 0)], num=0: (self.isSelfCrossing(x=x, position=(position[0], position[1] + x[num]), way=way + [(position[0], position[1] + i) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 0 else (self.isSelfCrossing(x=x, position=(position[0] - x[num], position[1]), way=way + [(position[0] - i, position[1]) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 1 else (self.isSelfCrossing(x=x, position=(position[0], position[1] - x[num]), way=way + [(position[0], position[1] - i) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 2 else (self.isSelfCrossing(x=x, position=(position[0] + x[num], position[1]), way=way + [(position[0] + i, position[1]) for i in range(x[num] + 1)[1:]], num=num+1) if num % 4 == 3 else -1)))) if num < len(x) else (True if True in [True if way.count(i) >= 2 else False for i in way] else False)\\n\\n\\na = Solution()\\nprint(a.isSelfCrossing([2, 1, 1, 2]))\\nprint(a.isSelfCrossing([1, 2, 3, 4]))\\nprint(a.isSelfCrossing([1, 1, 1, 1]))\\nprint(a.isSelfCrossing([2, 2, 3, 3, 2, 3]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521098,
                "title": "inward-and-outward",
                "content": "```\\npublic boolean isSelfCrossing(int[] x) {\\n        int i = 2;\\n        int l = x.length;\\n        if (l <= 3) return false;\\n        while (i < l && x[i] > x[i - 2]){\\n            i++;\\n        }\\n        if(i >= l) return false;\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4] )\\n             || (i == 3 && x[i] == x[i - 2])){\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        while(i < l){\\n            if (x[i] >= x[i - 2]) return true;\\n            i++;\\n        }\\n        return false;            \\n    }\\n```\\nref: https://leetcode.com/problems/self-crossing/discuss/79168/Simple-Java-Solution",
                "solutionTags": [],
                "code": "```\\npublic boolean isSelfCrossing(int[] x) {\\n        int i = 2;\\n        int l = x.length;\\n        if (l <= 3) return false;\\n        while (i < l && x[i] > x[i - 2]){\\n            i++;\\n        }\\n        if(i >= l) return false;\\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4] )\\n             || (i == 3 && x[i] == x[i - 2])){\\n            x[i - 1] -= x[i - 3];\\n        }\\n        i++;\\n        while(i < l){\\n            if (x[i] >= x[i - 2]) return true;\\n            i++;\\n        }\\n        return false;            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519892,
                "title": "python-solution-with-that-checks-whether-the-last-segment-intersect-some-of-the-last-10-segments",
                "content": "I think this solution is easier to understand and still the same complexity.\\n```\\nfrom typing import *\\nfrom collections import deque\\n\\ndef onLine(x1, y1, x2, y2, x3, y3):\\n    return (x2 <= max(x1, x3) and x2 >= min(x1, x3) and\\n            y2 <= max(y1, y3) and y2 >= min(y1, y3))\\n\\ndef orientation(x1, y1, x2, y2, x3, y3):\\n    val = (y2 - y1) * (x3 - x2) - (x2 - x1) * (y3 - y2)\\n    if val > 0: return 1\\n    elif val < 0: return 2\\n    else: return 0\\n\\ndef intersect(seg1, seg2):\\n    x11, y11, x12, y12 = seg1\\n    x21, y21, x22, y22 = seg2\\n    o1 = orientation(x11, y11, x12, y12, x21, y21)\\n    o2 = orientation(x11, y11, x12, y12, x22, y22)\\n    o3 = orientation(x21, y21, x22, y22, x11, y11)\\n    o4 = orientation(x21, y21, x22, y22, x12, y12)\\n    if o1 != o2 and o3 != o4:\\n        return True\\n    # p1 , q1 and p2 are colinear and p2 lies on segment p1q1 \\n    if o1 == 0 and onLine(x11, y11, x21, y21, x12, y12): \\n        return True\\n    # p1 , q1 and q2 are colinear and q2 lies on segment p1q1 \\n    if o2 == 0 and onLine(x11, y11, x22, y22, x12, y12): \\n        return True\\n    # p2 , q2 and p1 are colinear and p1 lies on segment p2q2 \\n    if o3 == 0 and onLine(x21, y21, x11, y11, x22, y22): \\n        return True\\n    # p2 , q2 and q1 are colinear and q1 lies on segment p2q2 \\n    if o4 == 0 and onLine(x21, y21, x12, y12, x22, y22): \\n        return True\\n    # If none of the cases \\n    return False\\n\\ndef solve(A):\\n    last10 = deque()\\n    dir = 0\\n    curx, cury = 0, 0\\n    for i in A:\\n        if dir == 0:\\n            newx, newy = curx, cury + i\\n        elif dir == 1:\\n            newx, newy = curx - i, cury\\n        elif dir == 2:\\n            newx, newy = curx, cury - i\\n        else:\\n            newx, newy = curx + i, cury\\n        dir = (dir + 1) % 4\\n        curSeg = (curx, cury, newx, newy)\\n        for segIdx, seg in enumerate(last10):\\n            if segIdx == len(last10) - 1:\\n                break\\n            if intersect(curSeg, seg):\\n                print(curSeg, seg)\\n                return True\\n        last10.append(curSeg)\\n        if len(last10) > 10:\\n            last10.popleft()\\n        curx, cury = newx, newy\\n    return False\\n\\nclass Solution:\\n    def isSelfCrossing(self, A: List[int]) -> bool:\\n        return solve(A)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import *\\nfrom collections import deque\\n\\ndef onLine(x1, y1, x2, y2, x3, y3):\\n    return (x2 <= max(x1, x3) and x2 >= min(x1, x3) and\\n            y2 <= max(y1, y3) and y2 >= min(y1, y3))\\n\\ndef orientation(x1, y1, x2, y2, x3, y3):\\n    val = (y2 - y1) * (x3 - x2) - (x2 - x1) * (y3 - y2)\\n    if val > 0: return 1\\n    elif val < 0: return 2\\n    else: return 0\\n\\ndef intersect(seg1, seg2):\\n    x11, y11, x12, y12 = seg1\\n    x21, y21, x22, y22 = seg2\\n    o1 = orientation(x11, y11, x12, y12, x21, y21)\\n    o2 = orientation(x11, y11, x12, y12, x22, y22)\\n    o3 = orientation(x21, y21, x22, y22, x11, y11)\\n    o4 = orientation(x21, y21, x22, y22, x12, y12)\\n    if o1 != o2 and o3 != o4:\\n        return True\\n    # p1 , q1 and p2 are colinear and p2 lies on segment p1q1 \\n    if o1 == 0 and onLine(x11, y11, x21, y21, x12, y12): \\n        return True\\n    # p1 , q1 and q2 are colinear and q2 lies on segment p1q1 \\n    if o2 == 0 and onLine(x11, y11, x22, y22, x12, y12): \\n        return True\\n    # p2 , q2 and p1 are colinear and p1 lies on segment p2q2 \\n    if o3 == 0 and onLine(x21, y21, x11, y11, x22, y22): \\n        return True\\n    # p2 , q2 and q1 are colinear and q1 lies on segment p2q2 \\n    if o4 == 0 and onLine(x21, y21, x12, y12, x22, y22): \\n        return True\\n    # If none of the cases \\n    return False\\n\\ndef solve(A):\\n    last10 = deque()\\n    dir = 0\\n    curx, cury = 0, 0\\n    for i in A:\\n        if dir == 0:\\n            newx, newy = curx, cury + i\\n        elif dir == 1:\\n            newx, newy = curx - i, cury\\n        elif dir == 2:\\n            newx, newy = curx, cury - i\\n        else:\\n            newx, newy = curx + i, cury\\n        dir = (dir + 1) % 4\\n        curSeg = (curx, cury, newx, newy)\\n        for segIdx, seg in enumerate(last10):\\n            if segIdx == len(last10) - 1:\\n                break\\n            if intersect(curSeg, seg):\\n                print(curSeg, seg)\\n                return True\\n        last10.append(curSeg)\\n        if len(last10) > 10:\\n            last10.popleft()\\n        curx, cury = newx, newy\\n    return False\\n\\nclass Solution:\\n    def isSelfCrossing(self, A: List[int]) -> bool:\\n        return solve(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513866,
                "title": "easy-idea-of-the-problem",
                "content": "Suppose you keep adding edges, e1,e2,e3,...ek. If ek intersected the curve, then it intersects one of the last 8 edges which is e(k-1),e(k-2),...e(k-8). So, you need to keep track of only last 8 edges (O(1) memory). \\n\\nWhy this is true? It seems intuitive try drawing some curves, and you will see that it covers itself as a shell either outwards or inwards and thus previous edges will get unreacheable.",
                "solutionTags": [],
                "code": "Suppose you keep adding edges, e1,e2,e3,...ek. If ek intersected the curve, then it intersects one of the last 8 edges which is e(k-1),e(k-2),...e(k-8). So, you need to keep track of only last 8 edges (O(1) memory). \\n\\nWhy this is true? It seems intuitive try drawing some curves, and you will see that it covers itself as a shell either outwards or inwards and thus previous edges will get unreacheable.",
                "codeTag": "Unknown"
            },
            {
                "id": 505882,
                "title": "another-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Point\\n    {\\n        Point() = default;\\n        Point(int x, int y)\\n        : x(x), y(y) {}\\n        \\n        Point operator+(const Point& other)\\n        {\\n            return Point(x + other.x, y + other.y);\\n        }\\n        \\n        Point operator*(int other)\\n        {\\n            return Point(x * other, y * other);\\n        }\\n        \\n        int x = 0;\\n        int y = 0;\\n    };\\n    \\n    struct Line\\n    {\\n        Line() = default;\\n        Line(const Point& p1, const Point& p2)\\n        : valid(true), p1(p1), p2(p2) {}\\n                \\n        bool valid = false;\\n        Point p1;\\n        Point p2;\\n    };\\n            \\n    bool isIntersecting(const Line& line1, const Line& line2)\\n    {\\n        // Use separating axes theorem to detect intersection.\\n        // Since lines can only be horizontal or vertical they\\n        // can be treated as AABBs.\\n        \\n        Point line2p1, line2p2;\\n        if (line2.p1.x < line2.p2.x) {\\n            line2p1 = line2.p1;\\n            line2p2 = line2.p2;\\n        } else {\\n            line2p1 = line2.p2;\\n            line2p2 = line2.p1;\\n        }\\n        \\n        if (((line1.p1.x < line2p1.x) && (line1.p2.x < line2p1.x)) ||\\n            ((line1.p1.x > line2p2.x) && (line1.p2.x > line2p2.x))) {\\n            return false;\\n        }\\n        \\n        if (line2.p1.y < line2.p2.y) {\\n            line2p1 = line2.p1;\\n            line2p2 = line2.p2;\\n        } else {\\n            line2p1 = line2.p2;\\n            line2p2 = line2.p1;\\n        }\\n        \\n        if (((line1.p1.y < line2p1.y) && (line1.p2.y < line2p1.y)) ||\\n            ((line1.p1.y > line2p2.y) && (line1.p2.y > line2p2.y))) {\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n                    \\n    bool isSelfCrossing(vector<int>& x) {\\n        Point dirVec[4] = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n        Line bounds[4][2]; // Whenever we move we can only collide with max 2 lines\\n        \\n        Point cur(0, 0);\\n        int dir = 0;\\n        \\n        int prevDir = 0;\\n        Line prevCurLine;\\n        \\n        Line zeroLine(Point(0,0), Point(0,0));\\n        \\n        for (auto len : x) {\\n            Point next = cur + dirVec[dir] * len;\\n            Line curLine(cur, next);\\n            \\n            for (int i = 0; i < 2; ++i) {\\n                if (bounds[dir][i].valid && isIntersecting(bounds[dir][i], curLine)) {\\n                    return true;\\n                }\\n            }            \\n            \\n            if (prevCurLine.valid) {\\n                if (isIntersecting(zeroLine, curLine)) {\\n                    // We need to explicitly check for (0, 0) collision\\n                    // since there\\'s no previous line leading to that point.\\n                    return true;\\n                }\\n                \\n                // Tricky part is that we should update\\n                // our bounds with a delay of 1 step. Just draw it\\n                // on a piece of paper to see why.\\n                switch (prevDir) {\\n                case 0: // up\\n                        bounds[1][0] = prevCurLine;\\n                        bounds[3][0] = prevCurLine;\\n                        break;\\n                case 1: // left\\n                        bounds[0][0] = prevCurLine;\\n                        bounds[2][0] = prevCurLine;\\n                        break;\\n                case 2: // down\\n                        bounds[1][1] = prevCurLine;\\n                        bounds[3][1] = prevCurLine;\\n                        break;\\n                case 3: // right            \\n                        bounds[0][1] = prevCurLine;\\n                        bounds[2][1] = prevCurLine;\\n                        break;\\n                }\\n            }\\n            \\n            prevCurLine = curLine;\\n            prevDir = dir;\\n            \\n            dir = (dir + 1) % 4;\\n            cur = next;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Point\\n    {\\n        Point() = default;\\n        Point(int x, int y)\\n        : x(x), y(y) {}\\n        \\n        Point operator+(const Point& other)\\n        {\\n            return Point(x + other.x, y + other.y);\\n        }\\n        \\n        Point operator*(int other)\\n        {\\n            return Point(x * other, y * other);\\n        }\\n        \\n        int x = 0;\\n        int y = 0;\\n    };\\n    \\n    struct Line\\n    {\\n        Line() = default;\\n        Line(const Point& p1, const Point& p2)\\n        : valid(true), p1(p1), p2(p2) {}\\n                \\n        bool valid = false;\\n        Point p1;\\n        Point p2;\\n    };\\n            \\n    bool isIntersecting(const Line& line1, const Line& line2)\\n    {\\n        // Use separating axes theorem to detect intersection.\\n        // Since lines can only be horizontal or vertical they\\n        // can be treated as AABBs.\\n        \\n        Point line2p1, line2p2;\\n        if (line2.p1.x < line2.p2.x) {\\n            line2p1 = line2.p1;\\n            line2p2 = line2.p2;\\n        } else {\\n            line2p1 = line2.p2;\\n            line2p2 = line2.p1;\\n        }\\n        \\n        if (((line1.p1.x < line2p1.x) && (line1.p2.x < line2p1.x)) ||\\n            ((line1.p1.x > line2p2.x) && (line1.p2.x > line2p2.x))) {\\n            return false;\\n        }\\n        \\n        if (line2.p1.y < line2.p2.y) {\\n            line2p1 = line2.p1;\\n            line2p2 = line2.p2;\\n        } else {\\n            line2p1 = line2.p2;\\n            line2p2 = line2.p1;\\n        }\\n        \\n        if (((line1.p1.y < line2p1.y) && (line1.p2.y < line2p1.y)) ||\\n            ((line1.p1.y > line2p2.y) && (line1.p2.y > line2p2.y))) {\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n                    \\n    bool isSelfCrossing(vector<int>& x) {\\n        Point dirVec[4] = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n        Line bounds[4][2]; // Whenever we move we can only collide with max 2 lines\\n        \\n        Point cur(0, 0);\\n        int dir = 0;\\n        \\n        int prevDir = 0;\\n        Line prevCurLine;\\n        \\n        Line zeroLine(Point(0,0), Point(0,0));\\n        \\n        for (auto len : x) {\\n            Point next = cur + dirVec[dir] * len;\\n            Line curLine(cur, next);\\n            \\n            for (int i = 0; i < 2; ++i) {\\n                if (bounds[dir][i].valid && isIntersecting(bounds[dir][i], curLine)) {\\n                    return true;\\n                }\\n            }            \\n            \\n            if (prevCurLine.valid) {\\n                if (isIntersecting(zeroLine, curLine)) {\\n                    // We need to explicitly check for (0, 0) collision\\n                    // since there\\'s no previous line leading to that point.\\n                    return true;\\n                }\\n                \\n                // Tricky part is that we should update\\n                // our bounds with a delay of 1 step. Just draw it\\n                // on a piece of paper to see why.\\n                switch (prevDir) {\\n                case 0: // up\\n                        bounds[1][0] = prevCurLine;\\n                        bounds[3][0] = prevCurLine;\\n                        break;\\n                case 1: // left\\n                        bounds[0][0] = prevCurLine;\\n                        bounds[2][0] = prevCurLine;\\n                        break;\\n                case 2: // down\\n                        bounds[1][1] = prevCurLine;\\n                        bounds[3][1] = prevCurLine;\\n                        break;\\n                case 3: // right            \\n                        bounds[0][1] = prevCurLine;\\n                        bounds[2][1] = prevCurLine;\\n                        break;\\n                }\\n            }\\n            \\n            prevCurLine = curLine;\\n            prevDir = dir;\\n            \\n            dir = (dir + 1) % 4;\\n            cur = next;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418080,
                "title": "java-solution-faster-then-100-and-uses-less-memory-then-100",
                "content": "\\n\\nclass Solution {\\n    \\n\\tpublic boolean isSelfCrossing(int[] x) {\\n\\t\\tif (x.length < 4) return false;\\n\\n\\t\\tfor(int i =3 ; i < x.length ; i++){\\n\\t\\t\\tif(x[i-1] <= x[i-3] && x[i] >= x[i-2])\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif( i > 4 && x[i] >= x[i-2] - x[i-4] && x[i-1] >= x[i-3]-x[i-5] && x[i-1] <= x[i-3]  && x[i-2] >= x[i-4])\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif(i > 3 && x[i-1] == x[i-3] && x[i] >= x[i-2]-x[i-4])\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n}\\n\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\tpublic boolean isSelfCrossing(int[] x) {\\n\\t\\tif (x.length < 4) return false;\\n\\n\\t\\tfor(int i =3 ; i < x.length ; i++){\\n\\t\\t\\tif(x[i-1] <= x[i-3] && x[i] >= x[i-2])\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif( i > 4 && x[i] >= x[i-2] - x[i-4] && x[i-1] >= x[i-3]-x[i-5] && x[i-1] <= x[i-3]  && x[i-2] >= x[i-4])\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif(i > 3 && x[i-1] == x[i-3] && x[i] >= x[i-2]-x[i-4])\\n\\t\\t\\t\\treturn true;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 388029,
                "title": "python3-dp",
                "content": "```\\n\\n\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        m=len(x)\\n        if m<4:\\n            return False\\n        bo=False\\n        def dfs(i):\\n            nonlocal bo,x,m\\n            if bo:\\n                return \\n            if i+3>=m:\\n                return \\n            if x[i]>=x[i+2] and x[i+3]>=x[i+1]:\\n                bo=True\\n                return\\n            elif x[i+3]<x[i+1]:\\n                dfs(i+1)\\n                return\\n            else: \\n                # 0<2 and 3>=1\\n                if i+4>m-1:\\n                    return\\n                if x[i+1]==x[i+3]:\\n                    if x[i+2]-x[i]<=x[i+4]:\\n                        bo=True\\n                    else:\\n                        dfs(i+1)\\n                        return \\n                else:\\n                    if x[i+2]-x[i]>x[i+4]:\\n                        dfs(i+1)\\n                    elif x[i+4]>x[2]:\\n                        dfs(i+1)\\n                    else:\\n                        if i+5>m-1:\\n                            return\\n                        if x[i+5]>=x[i+3]-x[i+1]:\\n                            bo=True\\n                        else:\\n                            dfs(i+1)\\n        dfs(0)\\n        return bo\\n",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        m=len(x)\\n        if m<4:\\n            return False\\n        bo=False\\n        def dfs(i):\\n            nonlocal bo,x,m\\n            if bo:\\n                return \\n            if i+3>=m:\\n                return \\n            if x[i]>=x[i+2] and x[i+3]>=x[i+1]:\\n                bo=True\\n                return\\n            elif x[i+3]<x[i+1]:\\n                dfs(i+1)\\n                return\\n            else: \\n                # 0<2 and 3>=1\\n                if i+4>m-1:\\n                    return\\n                if x[i+1]==x[i+3]:\\n                    if x[i+2]-x[i]<=x[i+4]:\\n                        bo=True\\n                    else:\\n                        dfs(i+1)\\n                        return \\n                else:\\n                    if x[i+2]-x[i]>x[i+4]:\\n                        dfs(i+1)\\n                    elif x[i+4]>x[2]:\\n                        dfs(i+1)\\n                    else:\\n                        if i+5>m-1:\\n                            return\\n                        if x[i+5]>=x[i+3]-x[i+1]:\\n                            bo=True\\n                        else:\\n                            dfs(i+1)\\n        dfs(0)\\n        return bo\\n",
                "codeTag": "Java"
            },
            {
                "id": 386087,
                "title": "python-simple-case-easy-to-read",
                "content": "Catch the three different shapes\\n```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if len(x) < 4:\\n            return False\\n       \\n        for pos in range(3, len(x)):\\n            if x[pos - 1] <= x[pos - 3] and x[pos] >= x[pos - 2]:  # general case\\n                return True\\n            if pos >= 4 and x[pos - 1] == x[pos - 3] and x[pos] + x[pos - 4] == x[pos - 2]:  # connected rectangle\\n                return True\\n            # connected L-shape\\n            if pos >= 5 and x[pos-1] <= x[pos-3] and x[pos-3] <= x[pos-1] + x[pos-5] and x[pos] + x[pos-4] >= x[pos-2] and x[pos-4] <= x[pos-2]:\\n                return True\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if len(x) < 4:\\n            return False\\n       \\n        for pos in range(3, len(x)):\\n            if x[pos - 1] <= x[pos - 3] and x[pos] >= x[pos - 2]:  # general case\\n                return True\\n            if pos >= 4 and x[pos - 1] == x[pos - 3] and x[pos] + x[pos - 4] == x[pos - 2]:  # connected rectangle\\n                return True\\n            # connected L-shape\\n            if pos >= 5 and x[pos-1] <= x[pos-3] and x[pos-3] <= x[pos-1] + x[pos-5] and x[pos] + x[pos-4] >= x[pos-2] and x[pos-4] <= x[pos-2]:\\n                return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343852,
                "title": "lol-java-implementation-as-a-fsm",
                "content": "I ended up enumerating the 7 possible states we could be in, and used the next number in the array to drive to the next state.  Kinda ridiculous.\\n\\n```\\nclass Solution {\\n    private class Point {\\n        public int x;\\n        public int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        public int segmentLength(Point other) {\\n            return other.x == this.x ? Math.abs(other.y - this.y) :\\n                                       Math.abs(other.x - this.x);\\n        }\\n        private Point copyAndAdjustPoint(int i, int amount) {\\n            Point copy = new Point(this.x, this.y);\\n            switch(i % 4) {\\n                case 0:\\n                    copy.y += amount;\\n                    break;\\n                case 1:\\n                    copy.x -= amount;\\n                    break;\\n                case 2:\\n                    copy.y -= amount;\\n                    break;\\n                case 3:\\n                    copy.x += amount;\\n                    break;\\n            }\\n            return copy;\\n        }\\n    }\\n\\n    public boolean isSelfCrossing(int[] x) {\\n        LinkedList<Point> points = new LinkedList<Point>();\\n        int state = 0;\\n        Point curPoint = new Point(0,0);\\n        points.add(curPoint);\\n        \\n        for(int i = 0; i < x.length; i++) {\\n            curPoint = curPoint.copyAndAdjustPoint(i, x[i]);\\n            points.add(curPoint);\\n            switch(state) {\\n                case 0:\\n                    state = 1;\\n                    break;\\n                case 1:\\n                    state = 2;\\n                    break;\\n                case 2:\\n                    if(points.get(3).segmentLength(points.get(2)) > points.get(1).segmentLength(points.get(0))) {\\n                        state = 4;\\n                    } else {\\n                        state = 3;\\n                    }\\n                    break;\\n                case 3:\\n                    if(points.get(4).segmentLength(points.get(3)) >= points.get(2).segmentLength(points.get(1))) {\\n                        return true;\\n                    } else {\\n                        points.removeFirst();\\n                        state = 3;\\n                    }\\n                    break;\\n                case 4:\\n                    if(points.get(4).segmentLength(points.get(3)) < points.get(2).segmentLength(points.get(1))) {\\n                        points.removeFirst();\\n                        state = 3;\\n                    } else {\\n                        state = 5;\\n                    }\\n                    break;\\n                case 5:\\n                    int l1 = points.get(5).segmentLength(points.get(4));\\n                    int l2 = points.get(3).segmentLength(points.get(2));\\n                    int l3 = points.get(1).segmentLength(points.get(0));\\n                    if(l1 + l3 < l2) {\\n                        points.removeFirst();\\n                        points.removeFirst();\\n                        state = 3;\\n                    } else if(l1 + l3 > l2) {\\n                        if(l1 > l2) {\\n                            points.removeFirst();\\n                        } else {\\n                            state = 6;\\n                        }\\n                    }\\n                    break;\\n                case 6:\\n                    l1 = points.get(6).segmentLength(points.get(5));\\n                    l2 = points.get(4).segmentLength(points.get(3));\\n                    l3 = points.get(2).segmentLength(points.get(1));\\n                    if(l1 + l3 >= l2) {\\n                        return true;\\n                    } else {\\n                        points.removeFirst();\\n                        points.removeFirst();\\n                        points.removeFirst();\\n                        state = 3;\\n                    }\\n                    break;\\n            }\\n            Point start = points.peekFirst();\\n            Point end = points.peekLast();\\n            if(start.x == end.x && start.y == end.y) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private class Point {\\n        public int x;\\n        public int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        public int segmentLength(Point other) {\\n            return other.x == this.x ? Math.abs(other.y - this.y) :\\n                                       Math.abs(other.x - this.x);\\n        }\\n        private Point copyAndAdjustPoint(int i, int amount) {\\n            Point copy = new Point(this.x, this.y);\\n            switch(i % 4) {\\n                case 0:\\n                    copy.y += amount;\\n                    break;\\n                case 1:\\n                    copy.x -= amount;\\n                    break;\\n                case 2:\\n                    copy.y -= amount;\\n                    break;\\n                case 3:\\n                    copy.x += amount;\\n                    break;\\n            }\\n            return copy;\\n        }\\n    }\\n\\n    public boolean isSelfCrossing(int[] x) {\\n        LinkedList<Point> points = new LinkedList<Point>();\\n        int state = 0;\\n        Point curPoint = new Point(0,0);\\n        points.add(curPoint);\\n        \\n        for(int i = 0; i < x.length; i++) {\\n            curPoint = curPoint.copyAndAdjustPoint(i, x[i]);\\n            points.add(curPoint);\\n            switch(state) {\\n                case 0:\\n                    state = 1;\\n                    break;\\n                case 1:\\n                    state = 2;\\n                    break;\\n                case 2:\\n                    if(points.get(3).segmentLength(points.get(2)) > points.get(1).segmentLength(points.get(0))) {\\n                        state = 4;\\n                    } else {\\n                        state = 3;\\n                    }\\n                    break;\\n                case 3:\\n                    if(points.get(4).segmentLength(points.get(3)) >= points.get(2).segmentLength(points.get(1))) {\\n                        return true;\\n                    } else {\\n                        points.removeFirst();\\n                        state = 3;\\n                    }\\n                    break;\\n                case 4:\\n                    if(points.get(4).segmentLength(points.get(3)) < points.get(2).segmentLength(points.get(1))) {\\n                        points.removeFirst();\\n                        state = 3;\\n                    } else {\\n                        state = 5;\\n                    }\\n                    break;\\n                case 5:\\n                    int l1 = points.get(5).segmentLength(points.get(4));\\n                    int l2 = points.get(3).segmentLength(points.get(2));\\n                    int l3 = points.get(1).segmentLength(points.get(0));\\n                    if(l1 + l3 < l2) {\\n                        points.removeFirst();\\n                        points.removeFirst();\\n                        state = 3;\\n                    } else if(l1 + l3 > l2) {\\n                        if(l1 > l2) {\\n                            points.removeFirst();\\n                        } else {\\n                            state = 6;\\n                        }\\n                    }\\n                    break;\\n                case 6:\\n                    l1 = points.get(6).segmentLength(points.get(5));\\n                    l2 = points.get(4).segmentLength(points.get(3));\\n                    l3 = points.get(2).segmentLength(points.get(1));\\n                    if(l1 + l3 >= l2) {\\n                        return true;\\n                    } else {\\n                        points.removeFirst();\\n                        points.removeFirst();\\n                        points.removeFirst();\\n                        state = 3;\\n                    }\\n                    break;\\n            }\\n            Point start = points.peekFirst();\\n            Point end = points.peekLast();\\n            if(start.x == end.x && start.y == end.y) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311307,
                "title": "golang-with-thought-process",
                "content": "There are many self crossing scenarios. However, there are only three general categories without self crossing, namely, spiral in, spiral out, spiral out ---> spiral in. \\n\\nI use a boolean variable spiralIn to indicate if it becomes the spiral-in case. Once it becomes the spiral-in case it is very easy to test for self crossing: the only way to avoid self crossing is to keep reducing the lenghth of the parrellel edges. \\n\\nThe tricky part is when it changes from spiral-out to spiral-in, sometimes we need to adjust x[i - 1] (but not always)\\n\\nAlso, I tested for 0s in the array. If there is a 0, it must be self crossing.\\n\\n```\\nfunc isSelfCrossing(x []int) bool {\\n    if len(x) < 4 {\\n        return false\\n    }    \\n\\n    for _, d := range x[1 :] {\\n        if d == 0 {\\n            return true\\n        }\\n    }\\n    if x[3] >= x[1] && x[2] <= x[0] {\\n        return true\\n    }\\n\\t\\n    spiralIn := x[3] < x[1]\\n    for i := 4; i < len(x); i ++ {\\n        if spiralIn {\\n            if x[i] >= x[i - 2] {\\n                return true\\n            }\\n        } else {\\n            if x[i] <= x[i - 2] {\\n                spiralIn = true\\n                if x[i] + x[i - 4] >= x[i - 2] {  //this is the condition when one needs to adjust the length of x[i - 1]\\n                    x[i - 1] = x[i - 1] - x[i - 3]\\n                }\\n            }\\n        }\\n    }\\n\\n    for _, d := range x[1 :] {\\n        if d == 0 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isSelfCrossing(x []int) bool {\\n    if len(x) < 4 {\\n        return false\\n    }    \\n\\n    for _, d := range x[1 :] {\\n        if d == 0 {\\n            return true\\n        }\\n    }\\n    if x[3] >= x[1] && x[2] <= x[0] {\\n        return true\\n    }\\n\\t\\n    spiralIn := x[3] < x[1]\\n    for i := 4; i < len(x); i ++ {\\n        if spiralIn {\\n            if x[i] >= x[i - 2] {\\n                return true\\n            }\\n        } else {\\n            if x[i] <= x[i - 2] {\\n                spiralIn = true\\n                if x[i] + x[i - 4] >= x[i - 2] {  //this is the condition when one needs to adjust the length of x[i - 1]\\n                    x[i - 1] = x[i - 1] - x[i - 3]\\n                }\\n            }\\n        }\\n    }\\n\\n    for _, d := range x[1 :] {\\n        if d == 0 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 278190,
                "title": "java-o-1-o-n-solution-of-simulation",
                "content": "Need a proper proof for the algorithm, specifically, why we only need to track last 6 points. 6 is a number I come up with by intuition.\\n\\n```\\nclass Solution {\\n    int[] p = new int[2];\\n    int[] tr = new int[12]; // track last 6 points \\n    int nmove = 0;\\n    int tracked = 0;\\n    \\n    public boolean isSelfCrossing(int[] x) {\\n        track(p);\\n        \\n        for (int i = 0; i < x.length; i++) {\\n            if (move(x[i])) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n    // 0: up\\n    // 1: left\\n    // 2: down\\n    // 3: right\\n    boolean move(int d) {\\n        nmove = nmove % 4;\\n                \\n        if (nmove == 0) { // up\\n            if (crossUp(d)) {\\n                return true;\\n            }\\n            p[1] += d;\\n            \\n        } else if (nmove == 1) { // left\\n            if (crossLeft(d)) {\\n                return true;\\n            }\\n            p[0] -= d;\\n            \\n        } else if (nmove == 2) { // down\\n            if (crossDown(d)) {\\n                return true;\\n            }\\n            p[1] -= d;            \\n            \\n        } else { // right\\n            if (crossRight(d)) {\\n                return true;\\n            }\\n            p[0] += d;            \\n        }\\n        \\n        nmove++;\\n        track(p);\\n        return false;\\n    }\\n    \\n    boolean crossUp(int d) {\\n        if (tracked < 5) {\\n            return false;\\n        }\\n        if (tracked == 5) {\\n            if (p[0] == tr[0]) {\\n                return p[1] + d >= tr[1];\\n            } else {\\n                return crossH(d, tr[2], tr[3], tr[4]);\\n            }\\n        }\\n        return crossH(d, tr[0], tr[1], tr[2]) ||\\n               crossH(d, tr[4], tr[5], tr[6]);\\n    }\\n    \\n    boolean crossLeft(int d) {\\n        if (tracked < 6) {\\n            return false;            \\n        }\\n        return crossV(-d, tr[1], tr[2], tr[3]) ||\\n               crossV(-d, tr[5], tr[6], tr[7]);\\n    }\\n    \\n    boolean crossDown(int d) {\\n        if (tracked < 6) {\\n            return false;\\n        }\\n        return crossH(-d, tr[0], tr[1], tr[2]) || \\n               crossH(-d, tr[4], tr[5], tr[6]);\\n    }\\n    \\n    boolean crossRight(int d) {        \\n        if (tracked == 4) {\\n            return crossV(d, tr[1], tr[2], tr[3]);\\n        }\\n        return crossV(d, tr[1], tr[2], tr[3]) ||\\n               crossV(d, tr[5], tr[6], tr[7]);\\n    }\\n\\n    // check if the move will cross the horizontal line segment \\n    // represented as x1, y1, x2\\n    boolean crossH(int d, int x1, int y1, int x2) {\\n        int xmin = Math.min(x1, x2);        \\n        int xmax = Math.max(x1, x2);\\n         // out of the span of the segment; it can never touch it;        \\n        if (p[0] < xmin || p[0] > xmax) {\\n            return false;\\n        }\\n        // cross after move\\n        if ((p[1]-y1) * (p[1]+d-y1) > 0) { \\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n\\n    boolean crossV(int d, int y1, int x1, int y2) {\\n        int ymin = Math.min(y1, y2);\\n        int ymax = Math.max(y1, y2);\\n        if (p[1] < ymin || p[1] > ymax) {\\n            return false;\\n        }\\n        if ((p[0]-x1) * (p[0]+d-x1) > 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    // push the point to the end of `tr`\\n    void track(int[] p) {\\n        if (tracked >= 6) {\\n            for (int i = 0; i < 10; i++) {\\n                tr[i] = tr[i+2];            \\n            }            \\n            tr[10] = p[0];\\n            tr[11] = p[1];\\n        } else {\\n            tr[tracked*2] = p[0];\\n            tr[tracked*2+1] = p[1];\\n        }\\n        tracked++;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] p = new int[2];\\n    int[] tr = new int[12]; // track last 6 points \\n    int nmove = 0;\\n    int tracked = 0;\\n    \\n    public boolean isSelfCrossing(int[] x) {\\n        track(p);\\n        \\n        for (int i = 0; i < x.length; i++) {\\n            if (move(x[i])) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n    // 0: up\\n    // 1: left\\n    // 2: down\\n    // 3: right\\n    boolean move(int d) {\\n        nmove = nmove % 4;\\n                \\n        if (nmove == 0) { // up\\n            if (crossUp(d)) {\\n                return true;\\n            }\\n            p[1] += d;\\n            \\n        } else if (nmove == 1) { // left\\n            if (crossLeft(d)) {\\n                return true;\\n            }\\n            p[0] -= d;\\n            \\n        } else if (nmove == 2) { // down\\n            if (crossDown(d)) {\\n                return true;\\n            }\\n            p[1] -= d;            \\n            \\n        } else { // right\\n            if (crossRight(d)) {\\n                return true;\\n            }\\n            p[0] += d;            \\n        }\\n        \\n        nmove++;\\n        track(p);\\n        return false;\\n    }\\n    \\n    boolean crossUp(int d) {\\n        if (tracked < 5) {\\n            return false;\\n        }\\n        if (tracked == 5) {\\n            if (p[0] == tr[0]) {\\n                return p[1] + d >= tr[1];\\n            } else {\\n                return crossH(d, tr[2], tr[3], tr[4]);\\n            }\\n        }\\n        return crossH(d, tr[0], tr[1], tr[2]) ||\\n               crossH(d, tr[4], tr[5], tr[6]);\\n    }\\n    \\n    boolean crossLeft(int d) {\\n        if (tracked < 6) {\\n            return false;            \\n        }\\n        return crossV(-d, tr[1], tr[2], tr[3]) ||\\n               crossV(-d, tr[5], tr[6], tr[7]);\\n    }\\n    \\n    boolean crossDown(int d) {\\n        if (tracked < 6) {\\n            return false;\\n        }\\n        return crossH(-d, tr[0], tr[1], tr[2]) || \\n               crossH(-d, tr[4], tr[5], tr[6]);\\n    }\\n    \\n    boolean crossRight(int d) {        \\n        if (tracked == 4) {\\n            return crossV(d, tr[1], tr[2], tr[3]);\\n        }\\n        return crossV(d, tr[1], tr[2], tr[3]) ||\\n               crossV(d, tr[5], tr[6], tr[7]);\\n    }\\n\\n    // check if the move will cross the horizontal line segment \\n    // represented as x1, y1, x2\\n    boolean crossH(int d, int x1, int y1, int x2) {\\n        int xmin = Math.min(x1, x2);        \\n        int xmax = Math.max(x1, x2);\\n         // out of the span of the segment; it can never touch it;        \\n        if (p[0] < xmin || p[0] > xmax) {\\n            return false;\\n        }\\n        // cross after move\\n        if ((p[1]-y1) * (p[1]+d-y1) > 0) { \\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n\\n    boolean crossV(int d, int y1, int x1, int y2) {\\n        int ymin = Math.min(y1, y2);\\n        int ymax = Math.max(y1, y2);\\n        if (p[1] < ymin || p[1] > ymax) {\\n            return false;\\n        }\\n        if ((p[0]-x1) * (p[0]+d-x1) > 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    // push the point to the end of `tr`\\n    void track(int[] p) {\\n        if (tracked >= 6) {\\n            for (int i = 0; i < 10; i++) {\\n                tr[i] = tr[i+2];            \\n            }            \\n            tr[10] = p[0];\\n            tr[11] = p[1];\\n        } else {\\n            tr[tracked*2] = p[0];\\n            tr[tracked*2+1] = p[1];\\n        }\\n        tracked++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 198282,
                "title": "c-solution-with-diagram",
                "content": "Although, not as short as some of the other answers here...\\n\\n```\\nclass Solution {\\npublic:\\n    struct State {\\n        int lh;\\n        int tw;\\n        int rh;\\n        int bw;\\n    };\\n\\n    bool isSelfCrossing(vector<int>& x) {\\n        //               tw                                    tw\\n        // .    *-----------------*              .    *-----------------*\\n        // .    |                 | rh           .    |                 |\\n        // .    |                 |              .    |                 |\\n        // 5    |        cx *-----* ry           5    |                 |\\n        // 4 lh |              bw         OR     4 lh |                 | rh\\n        // 3    |                                3    |                 |\\n        // 2    |                                2    |                 |\\n        // 1    *----->* nx                      1    *----->* nx       |\\n        //    (1,1)                                 (1,1)               * ry\\n        //                                                                bw=1\\n        //      12345...                              12345...\\n        //\\n        // All lengths are inclusive of the endpoints.\\n\\n        if (x.size() < 3) {\\n            return false;\\n        }\\n\\n        State s = {x[2] + 1, x[1] + 1, x[0] + 1, 1};\\n\\n        for (size_t i = 3; i < x.size(); i++) {\\n            const int nx = 1 + x[i];\\n            const int cx = s.tw - s.bw + 1;\\n            const int ry = s.lh - s.rh + 1;\\n\\n            if ((nx >= s.tw) && (ry <= 1)) {\\n                return true;\\n            }\\n\\n            // Rotate clockwise.\\n            State t;\\n            t.lh = nx;\\n            if (nx <= s.tw) {\\n                if (nx < cx) {\\n                    t.tw = s.lh;\\n                }\\n                else {\\n                    t.tw = ry;\\n                }\\n                t.rh = nx;\\n                t.bw = 1;\\n            }\\n            else {\\n                t.tw = s.lh;\\n                t.rh = s.tw;\\n                t.bw = s.rh;\\n            }\\n            s = t;\\n\\n            // cout << \"lh = \" << s.lh << \"; tw = \" << s.tw << \"; rh = \" << s.rh << \"; bw = \" << s.bw << endl;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct State {\\n        int lh;\\n        int tw;\\n        int rh;\\n        int bw;\\n    };\\n\\n    bool isSelfCrossing(vector<int>& x) {\\n        //               tw                                    tw\\n        // .    *-----------------*              .    *-----------------*\\n        // .    |                 | rh           .    |                 |\\n        // .    |                 |              .    |                 |\\n        // 5    |        cx *-----* ry           5    |                 |\\n        // 4 lh |              bw         OR     4 lh |                 | rh\\n        // 3    |                                3    |                 |\\n        // 2    |                                2    |                 |\\n        // 1    *----->* nx                      1    *----->* nx       |\\n        //    (1,1)                                 (1,1)               * ry\\n        //                                                                bw=1\\n        //      12345...                              12345...\\n        //\\n        // All lengths are inclusive of the endpoints.\\n\\n        if (x.size() < 3) {\\n            return false;\\n        }\\n\\n        State s = {x[2] + 1, x[1] + 1, x[0] + 1, 1};\\n\\n        for (size_t i = 3; i < x.size(); i++) {\\n            const int nx = 1 + x[i];\\n            const int cx = s.tw - s.bw + 1;\\n            const int ry = s.lh - s.rh + 1;\\n\\n            if ((nx >= s.tw) && (ry <= 1)) {\\n                return true;\\n            }\\n\\n            // Rotate clockwise.\\n            State t;\\n            t.lh = nx;\\n            if (nx <= s.tw) {\\n                if (nx < cx) {\\n                    t.tw = s.lh;\\n                }\\n                else {\\n                    t.tw = ry;\\n                }\\n                t.rh = nx;\\n                t.bw = 1;\\n            }\\n            else {\\n                t.tw = s.lh;\\n                t.rh = s.tw;\\n                t.bw = s.rh;\\n            }\\n            s = t;\\n\\n            // cout << \"lh = \" << s.lh << \"; tw = \" << s.tw << \"; rh = \" << s.rh << \"; bw = \" << s.bw << endl;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 193400,
                "title": "py3-think-of-it-like-a-matrix-and-you-are-traversing-it-will-be-simple",
                "content": "```\\nclass Solution:\\n    def isSelfCrossing(self, paths):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        directions = [(-1,0), (0, -1), (1, 0), (0, 1)]\\n        \\n        visited = set([(0,0)])\\n        position = (0, 0)\\n        for inx, path in enumerate(paths):\\n            position_x, position_y = position\\n            for i in range(path):\\n                position_x += directions[inx % 4][0]\\n                position_y += directions[inx % 4][1]\\n                if (position_x, position_y) not in visited: \\n                    visited.add((position_x, position_y))\\n                else:\\n                    return True\\n            position = (position_x, position_y)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSelfCrossing(self, paths):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        directions = [(-1,0), (0, -1), (1, 0), (0, 1)]\\n        \\n        visited = set([(0,0)])\\n        position = (0, 0)\\n        for inx, path in enumerate(paths):\\n            position_x, position_y = position\\n            for i in range(path):\\n                position_x += directions[inx % 4][0]\\n                position_y += directions[inx % 4][1]\\n                if (position_x, position_y) not in visited: \\n                    visited.add((position_x, position_y))\\n                else:\\n                    return True\\n            position = (position_x, position_y)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138854,
                "title": "c-recursion-solution",
                "content": "Getting idea from discussion, rewrite in recursion style.\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if (x.size() < 4) return false;\\n        return helper(x[0], x[1], x[2], x[3], x, 3);\\n    }\\n    \\n    bool helper(int a, int b, int c, int d, vector<int>& x, int cur) {\\n        if (cur == x.size()) return false;\\n        if (a >= c && d >= b) return true;\\n        if (cur + 1 < x.size() && b == d && c - a <= x[cur+1]) return true;\\n        if (cur + 2 < x.size() && d >= b && c >= x[cur+1] &&  x[cur+1] >= c - a && x[cur+2] >= d - b) return true;\\n        return helper(b, c, d, x[cur+1], x, cur+1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if (x.size() < 4) return false;\\n        return helper(x[0], x[1], x[2], x[3], x, 3);\\n    }\\n    \\n    bool helper(int a, int b, int c, int d, vector<int>& x, int cur) {\\n        if (cur == x.size()) return false;\\n        if (a >= c && d >= b) return true;\\n        if (cur + 1 < x.size() && b == d && c - a <= x[cur+1]) return true;\\n        if (cur + 2 < x.size() && d >= b && c >= x[cur+1] &&  x[cur+1] >= c - a && x[cur+2] >= d - b) return true;\\n        return helper(b, c, d, x[cur+1], x, cur+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115984,
                "title": "readable-44ms-o-n-time-and-o-1-space-python-solution",
                "content": "We retain at most the last 5 line segments and check current run -3 and -5'th line segments (which are orthogonal) to the current segment for intersection and the current run -4'th line segment for co-incidence. The logic here being, if the path is self crossing (given the square spiral nature of the motion) the crossing should be realized by the current segment and at most the current run -5'th segment at the earliest.\n```\nclass Segment(object):\n    def __init__(self, x0, y0, x1, y1):\n        self.x0 = min(x0, x1)\n        self.y0 = min(y0, y1)\n        self.x1 = max(x0, x1)\n        self.y1 = max(y0, y1)\n\n\n    def isIntersecting(self, segment2:'Segment'):\n        delta_x = self.x1 - self.x0\n        delta_y = self.y1 - self.y0\n\n        delta_x_2 = segment2.x1 - segment2.x0\n        delta_y_2 = segment2.y1 - segment2.y0\n\n        if delta_x*delta_x_2 + delta_y*delta_y_2 == 0:\n            #orthogonality satisfied\n            if delta_x != 0 and delta_y_2 != 0:\n                if self.x0 <= segment2.x0 <= self.x1 and segment2.y0 <= self.y0 <= segment2.y1:\n                    return True\n            if delta_y != 0 and delta_x_2 != 0:\n                if self.y0 <= segment2.y0 <= self.y1 and segment2.x0 <= self.x0 <= segment2.x1:\n                    return True\n        else:\n            #Co-incidence perhaps?\n            if delta_x == 0:\n                if (self.y0 <= segment2.y0 <= self.y1 or self.y0 <= segment2.y1 <= self.y1) and self.x0 == segment2.x0:\n                    return True\n            elif delta_y == 0:\n                if (self.x0 <= segment2.x0 <= self.x1 or self.x0 <= segment2.x1 <= self.x1) and self.y0 == segment2.y0:\n                    return True\n        return False\n\nclass Solution:\n    def isSelfCrossing(self, x):\n        \"\"\"\n        :type x: List[int]\n        :rtype: bool\n        \"\"\"\n        cur_x = 0\n        cur_y = 0\n        l = len(x)\n        q = {}\n\n\n        if l >= 4:\n            if l==4:\n                if x[0] >= x[2] and x[3] >= x[1]:\n                    return True\n            else:\n                for m in range(0, l):\n                    rolling_index = m % 4\n                    if rolling_index == 0:\n                        # Checking for cross-over at North movement\n                        seg = Segment(cur_x, cur_y, cur_x, cur_y+x[m])\n                        cur_y += x[m]\n                    elif rolling_index == 1:\n                        # Checking for crossing at West movement\n                        seg = Segment(cur_x, cur_y, cur_x - x[m], cur_y)\n                        cur_x -= x[m]\n                    elif rolling_index == 2:\n                        # Checking for crossing at South movement\n                        seg = Segment(cur_x, cur_y, cur_x, cur_y - x[m])\n                        cur_y -= x[m]\n                    else:\n                        # Checking for crossing at East movement\n                        seg = Segment(cur_x, cur_y, cur_x + x[m], cur_y)\n                        cur_x += x[m]\n\n                    if m - 5 in q:\n                        if q[m - 5].isIntersecting(seg):\n                            return True\n                    if m - 4 in q:\n                        if q[m - 4].isIntersecting(seg):\n                            return True\n                    if m - 3 in q:\n                        if q[m - 3].isIntersecting(seg):\n                            return True\n                    q[m] = seg\n                    if m >= 5:\n                        del q[m-5]\n        return False\n```",
                "solutionTags": [],
                "code": "```\nclass Segment(object):\n    def __init__(self, x0, y0, x1, y1):\n        self.x0 = min(x0, x1)\n        self.y0 = min(y0, y1)\n        self.x1 = max(x0, x1)\n        self.y1 = max(y0, y1)\n\n\n    def isIntersecting(self, segment2:'Segment'):\n        delta_x = self.x1 - self.x0\n        delta_y = self.y1 - self.y0\n\n        delta_x_2 = segment2.x1 - segment2.x0\n        delta_y_2 = segment2.y1 - segment2.y0\n\n        if delta_x*delta_x_2 + delta_y*delta_y_2 == 0:\n            #orthogonality satisfied\n            if delta_x != 0 and delta_y_2 != 0:\n                if self.x0 <= segment2.x0 <= self.x1 and segment2.y0 <= self.y0 <= segment2.y1:\n                    return True\n            if delta_y != 0 and delta_x_2 != 0:\n                if self.y0 <= segment2.y0 <= self.y1 and segment2.x0 <= self.x0 <= segment2.x1:\n                    return True\n        else:\n            #Co-incidence perhaps?\n            if delta_x == 0:\n                if (self.y0 <= segment2.y0 <= self.y1 or self.y0 <= segment2.y1 <= self.y1) and self.x0 == segment2.x0:\n                    return True\n            elif delta_y == 0:\n                if (self.x0 <= segment2.x0 <= self.x1 or self.x0 <= segment2.x1 <= self.x1) and self.y0 == segment2.y0:\n                    return True\n        return False\n\nclass Solution:\n    def isSelfCrossing(self, x):\n        \"\"\"\n        :type x: List[int]\n        :rtype: bool\n        \"\"\"\n        cur_x = 0\n        cur_y = 0\n        l = len(x)\n        q = {}\n\n\n        if l >= 4:\n            if l==4:\n                if x[0] >= x[2] and x[3] >= x[1]:\n                    return True\n            else:\n                for m in range(0, l):\n                    rolling_index = m % 4\n                    if rolling_index == 0:\n                        # Checking for cross-over at North movement\n                        seg = Segment(cur_x, cur_y, cur_x, cur_y+x[m])\n                        cur_y += x[m]\n                    elif rolling_index == 1:\n                        # Checking for crossing at West movement\n                        seg = Segment(cur_x, cur_y, cur_x - x[m], cur_y)\n                        cur_x -= x[m]\n                    elif rolling_index == 2:\n                        # Checking for crossing at South movement\n                        seg = Segment(cur_x, cur_y, cur_x, cur_y - x[m])\n                        cur_y -= x[m]\n                    else:\n                        # Checking for crossing at East movement\n                        seg = Segment(cur_x, cur_y, cur_x + x[m], cur_y)\n                        cur_x += x[m]\n\n                    if m - 5 in q:\n                        if q[m - 5].isIntersecting(seg):\n                            return True\n                    if m - 4 in q:\n                        if q[m - 4].isIntersecting(seg):\n                            return True\n                    if m - 3 in q:\n                        if q[m - 3].isIntersecting(seg):\n                            return True\n                    q[m] = seg\n                    if m >= 5:\n                        del q[m-5]\n        return False\n```",
                "codeTag": "Java"
            },
            {
                "id": 111766,
                "title": "swift-solution-check-inside-or-outside-the-spiral",
                "content": "When route is inside spiral , just check distance in this direction. If it's outsite the spiral need to check whether change the status flag.\\n\\n```\\nfunc isSelfCrossing(_ x: [Int]) -> Bool {\\n        if x.count < 4 { return false }\\n        var isOuter = x[2] > x[0]\\n        var previous = [Int]()\\n        for i in 0..<4 {\\n            previous.append(x[i])\\n        }\\n        previous[3] = 0\\n        for i in 3..<x.count {\\n            if isOuter == false {\\n                if x[i] >= previous[(i - 2) % 4] { \\n                    return true \\n                }\\n                previous[i % 4] = x[i]\\n            } else {\\n                if x[i] > previous[(i - 2) % 4] {\\n                    previous[i % 4] = x[i]\\n                    continue \\n                } else {\\n                    isOuter = false\\n                  // should update the previous path length, because now, the route is inside the spiral \\n                    if previous[(i - 1) % 4] > previous[(i - 3) % 4] && ( x[i] >= previous[(i - 2) % 4] - previous[i % 4]\\n                                                                         && x[i] <= previous[(i - 2) % 4]) {\\n                        previous[(i - 1) % 4] -= previous[(i - 3) % 4]\\n                    }\\n                }\\n            }\\n            previous[i % 4] = x[i]\\n        }\\n        return false\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isSelfCrossing(_ x: [Int]) -> Bool {\\n        if x.count < 4 { return false }\\n        var isOuter = x[2] > x[0]\\n        var previous = [Int]()\\n        for i in 0..<4 {\\n            previous.append(x[i])\\n        }\\n        previous[3] = 0\\n        for i in 3..<x.count {\\n            if isOuter == false {\\n                if x[i] >= previous[(i - 2) % 4] { \\n                    return true \\n                }\\n                previous[i % 4] = x[i]\\n            } else {\\n                if x[i] > previous[(i - 2) % 4] {\\n                    previous[i % 4] = x[i]\\n                    continue \\n                } else {\\n                    isOuter = false\\n                  // should update the previous path length, because now, the route is inside the spiral \\n                    if previous[(i - 1) % 4] > previous[(i - 3) % 4] && ( x[i] >= previous[(i - 2) % 4] - previous[i % 4]\\n                                                                         && x[i] <= previous[(i - 2) % 4]) {\\n                        previous[(i - 1) % 4] -= previous[(i - 3) % 4]\\n                    }\\n                }\\n            }\\n            previous[i % 4] = x[i]\\n        }\\n        return false\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 79132,
                "title": "python-solution",
                "content": "**Algorithm**\\nIf there are less than 4 elements, then there is no chance to cross, return False.\\nWe then compare the second and fourth edges (l1 and l3).\\n**If l1 < l3 (grow outwards)**\\nFor each edge i starting from index 0, if each x[i] < x[i+2], we keep adding i until n-2 is reached. However, if in the middle of it, we find x[i] >= x[i+2], we need to consider a special case where x[i+2] + x[i-2] >= x[i] and x[i+3] + x[i-1] >= x[i+1]. \\nIf this case does not happen, we simply start recursion from current i, which will address the case of first growing outwards, then growing inwards.\\n**If l1 > l3 (grow inwards)**\\nFor each edge i starting from index 1, if x[i] > x[i+2], we keep increase i until n-2 is reached. If anything else happens, we break. So if last i < n-2, we say there is crossing, otherwise, there is no crossing.\\n**If l1 == l3 (boundary case)**\\nThere are three cases.\\nIf x[i] >= x[i+2], then there is crossing.\\nIf x[i] < x[i+2], we need to increase i by 2, then consider:\\n1)\\ti+2 is greater than n-1; no crossing\\n2)\\tx[i+2] + x[i-2] >= x[i]; crossing\\n\\n**Code**\\n```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(x)\\n        if n < 4:\\n            return False\\n        \\n        if x[1] < x[3]:\\n            i = 0\\n            while i < n-2:\\n                if x[i] < x[i+2]:\\n                    i += 1\\n                else:\\n                    if x[i+2] + x[i-2] >= x[i] and x[i+3] + x[i-1] >= x[i+1]:\\n                        break\\n                    return self.isSelfCrossing(x[i::])\\n        elif x[1] > x[3]:\\n            i = 1\\n            while i < n-2:\\n                if x[i] > x[i+2]:\\n                    i += 1\\n                else:\\n                    break\\n        else:\\n            i = 0\\n            while i < n-2:\\n                if x[i] >= x[i+2]:\\n                    break\\n                else:\\n                    i += 2\\n                    if i + 2 > n-1:\\n                        return False\\n                    if x[i+2] + x[i-2] >= x[i]:\\n                        break\\n        if i >= n-2:\\n            return False\\n        else:\\n            return True \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(x)\\n        if n < 4:\\n            return False\\n        \\n        if x[1] < x[3]:\\n            i = 0\\n            while i < n-2:\\n                if x[i] < x[i+2]:\\n                    i += 1\\n                else:\\n                    if x[i+2] + x[i-2] >= x[i] and x[i+3] + x[i-1] >= x[i+1]:\\n                        break\\n                    return self.isSelfCrossing(x[i::])\\n        elif x[1] > x[3]:\\n            i = 1\\n            while i < n-2:\\n                if x[i] > x[i+2]:\\n                    i += 1\\n                else:\\n                    break\\n        else:\\n            i = 0\\n            while i < n-2:\\n                if x[i] >= x[i+2]:\\n                    break\\n                else:\\n                    i += 2\\n                    if i + 2 > n-1:\\n                        return False\\n                    if x[i+2] + x[i-2] >= x[i]:\\n                        break\\n        if i >= n-2:\\n            return False\\n        else:\\n            return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 79138,
                "title": "a-slow-but-easy-to-understand-solution",
                "content": "follow the path and save the seen integral points. if seen again then it's self crossing.\\n\\n```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        seen={(0,0)}\\n        a,b=0,0\\n        ds=[[0,1],[-1,0],[0,-1],[1,0]]\\n        for i in xrange(len(x)):\\n            da,db=ds[i%4]\\n            for _ in xrange(x[i]):\\n                a,b=a+da,b+db\\n                if (a,b) in seen:\\n                    return True\\n                seen.add((a,b))\\n        return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSelfCrossing(self, x):\\n        \"\"\"\\n        :type x: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        seen={(0,0)}\\n        a,b=0,0\\n        ds=[[0,1],[-1,0],[0,-1],[1,0]]\\n        for i in xrange(len(x)):\\n            da,db=ds[i%4]\\n            for _ in xrange(x[i]):\\n                a,b=a+da,b+db\\n                if (a,b) in seen:\\n                    return True\\n                seen.add((a,b))\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79139,
                "title": "c-simple-solution",
                "content": "```\\nbool isSelfCrossing(int* x, int xSize)\\n{\\n    int i = 2, j = 0;\\n    \\n    while(i < xSize && x[i] > x[j])\\n    {\\n        i++;\\n        j++;\\n    }\\n    \\n    j = i + 1;\\n    \\n    if(j >= xSize) return false;\\n    \\n    if(x[i] < x[i - 2] - (i > 3 ? x[i - 4] : 0) ? x[j] < x[i - 1]\\n         : x[j] < x[i - 1] - (i > 2 ? x[i - 3] : 0))\\n    {\\n        j++;\\n        \\n        while(j < xSize && x[i] > x[j])\\n        {\\n            i++;\\n            j++;\\n        }\\n        \\n        return j < xSize;\\n    }\\n    \\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isSelfCrossing(int* x, int xSize)\\n{\\n    int i = 2, j = 0;\\n    \\n    while(i < xSize && x[i] > x[j])\\n    {\\n        i++;\\n        j++;\\n    }\\n    \\n    j = i + 1;\\n    \\n    if(j >= xSize) return false;\\n    \\n    if(x[i] < x[i - 2] - (i > 3 ? x[i - 4] : 0) ? x[j] < x[i - 1]\\n         : x[j] < x[i - 1] - (i > 2 ? x[i - 3] : 0))\\n    {\\n        j++;\\n        \\n        while(j < xSize && x[i] > x[j])\\n        {\\n            i++;\\n            j++;\\n        }\\n        \\n        return j < xSize;\\n    }\\n    \\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 79143,
                "title": "ambiguous-definition-of-self-crossing",
                "content": "If case `[1,2,2,2,1]` is considered as self-crossing, why case `[2,0,3,0]` is not?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 79144,
                "title": "java-solution",
                "content": "```\\n\\npublic class Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if (x.length < 4) return false;\\n        boolean mode = x[2] > x[0];\\n        for (int i = 3; i < x.length; i++) {\\n            if (!mode && x[i] >= x[i - 2]) return true;\\n            else if (mode && x[i] <= x[i - 2]) {\\n                int l = (i >= 4) ? x[i - 4] : 0;\\n                if (x[i] + l >= x[i - 2])\\n                    x[i - 1] -= x[i - 3];\\n                mode = false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if (x.length < 4) return false;\\n        boolean mode = x[2] > x[0];\\n        for (int i = 3; i < x.length; i++) {\\n            if (!mode && x[i] >= x[i - 2]) return true;\\n            else if (mode && x[i] <= x[i - 2]) {\\n                int l = (i >= 4) ? x[i - 4] : 0;\\n                if (x[i] + l >= x[i - 2])\\n                    x[i - 1] -= x[i - 3];\\n                mode = false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79145,
                "title": "python-solution",
                "content": "Not the best solution, there are [better](https://discuss.leetcode.com/topic/38014/java-oms-with-explanation) :P \\n```\\nclass Solution(object):\\n    def isBetween(self, t, a, b):\\n        return (a <= t and t <= b) or (b <= t and t <= a)\\n        \\n    def isSelfCrossing(self, x):\\n        dir, d = [1,-1,-1,1], 0\\n        prev, prevDist = collections.deque([0 for i in range(3)]), 0\\n        for dist in x:\\n            coord = prev[1] + prevDist\\n            prevDist = dist*dir[d%4]\\n            prev.appendleft(coord)\\n            d += 1\\n            if len(prev) < 7:\\n                continue\\n            # Check for intersection\\n            if self.isBetween(coord, prev[2], prev[4]) and self.isBetween(prev[3], prev[1], prev[1]+prevDist):\\n                return True\\n            if self.isBetween(coord, prev[4], prev[6]) and self.isBetween(prev[5], prev[1], prev[1]+prevDist):\\n                return True\\n            prev.pop()\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isBetween(self, t, a, b):\\n        return (a <= t and t <= b) or (b <= t and t <= a)\\n        \\n    def isSelfCrossing(self, x):\\n        dir, d = [1,-1,-1,1], 0\\n        prev, prevDist = collections.deque([0 for i in range(3)]), 0\\n        for dist in x:\\n            coord = prev[1] + prevDist\\n            prevDist = dist*dir[d%4]\\n            prev.appendleft(coord)\\n            d += 1\\n            if len(prev) < 7:\\n                continue\\n            # Check for intersection\\n            if self.isBetween(coord, prev[2], prev[4]) and self.isBetween(prev[3], prev[1], prev[1]+prevDist):\\n                return True\\n            if self.isBetween(coord, prev[4], prev[6]) and self.isBetween(prev[5], prev[1], prev[1]+prevDist):\\n                return True\\n            prev.pop()\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79147,
                "title": "my-plain-java-solution-slow-but-very-easy-to-understand",
                "content": "```\\npublic boolean isSelfCrossing(int[] x) {\\n    \\t        List<int[]> all = new ArrayList<int[]> ();\\n    \\t        \\n    \\t        int[] prev = {0, 0};\\n    \\t        for (int i = 0; i < x.length; i++) {\\n    \\t        \\tint mod = i % 4;\\n    \\t        \\tint[] line = new int[4];\\n    \\t        \\tline[0] = prev[0];\\n    \\t        \\tline[1] = prev[1];\\n    \\t        \\tswitch( mod) {\\n    \\t        \\tcase 0:\\n    \\t        \\t\\tprev[1] -= x[i];\\n    \\t        \\t\\tbreak;\\n    \\t        \\tcase 1: \\n    \\t        \\t\\tprev[0] -= x[i];\\n    \\t        \\t\\tbreak;\\n    \\t        \\tcase 2:\\n    \\t        \\t\\tprev[1] += x[i];\\n    \\t        \\t\\tbreak;\\n    \\t        \\tcase 3: \\n    \\t        \\t\\tprev[0] += x[i];\\n    \\t        \\t\\tbreak;    \\t        \\t\\n    \\t        \\t}\\n    \\t        \\t\\n    \\t        \\tline[2] = prev[0];\\n    \\t        \\tline[3] = prev[1];\\n    \\t        \\t\\n    \\t        \\tif (i > 2) {\\n    \\t        \\t\\tfor (int j = all.size() -3;  j >= 0; j -= 1) {\\n    \\t        \\t\\t\\tif (isCrossing(line, all.get(j))) return true;\\n    \\t        \\t\\t}\\n    \\t        \\t}\\n    \\t        \\tall.add(line);\\n    \\t        }\\n    \\t        \\n    \\t        return false;\\n    \\t    }\\n    \\t    \\n    \\t    boolean isCrossing(int[] line1, int[] line2) {\\n    \\t    \\tint[] v = (line1[0] == line1[2]) ? line1 : line2;\\n    \\t    \\tint[] h = (v == line1) ? line2 : line1;\\n    \\t    \\t\\n    \\t    \\treturn ((v[0] >= h[0] && v[0] <= h[2]) || (v[0] >= h[2] && v[0] <= h[0])) && ((h[1] >= v[1] && h[1] <= v[3]) || (h[1] >= v[3] && h[1] <= v[1]));\\n    \\t    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isSelfCrossing(int[] x) {\\n    \\t        List<int[]> all = new ArrayList<int[]> ();\\n    \\t        \\n    \\t        int[] prev = {0, 0};\\n    \\t        for (int i = 0; i < x.length; i++) {\\n    \\t        \\tint mod = i % 4;\\n    \\t        \\tint[] line = new int[4];\\n    \\t        \\tline[0] = prev[0];\\n    \\t        \\tline[1] = prev[1];\\n    \\t        \\tswitch( mod) {\\n    \\t        \\tcase 0:\\n    \\t        \\t\\tprev[1] -= x[i];\\n    \\t        \\t\\tbreak;\\n    \\t        \\tcase 1: \\n    \\t        \\t\\tprev[0] -= x[i];\\n    \\t        \\t\\tbreak;\\n    \\t        \\tcase 2:\\n    \\t        \\t\\tprev[1] += x[i];\\n    \\t        \\t\\tbreak;\\n    \\t        \\tcase 3: \\n    \\t        \\t\\tprev[0] += x[i];\\n    \\t        \\t\\tbreak;    \\t        \\t\\n    \\t        \\t}\\n    \\t        \\t\\n    \\t        \\tline[2] = prev[0];\\n    \\t        \\tline[3] = prev[1];\\n    \\t        \\t\\n    \\t        \\tif (i > 2) {\\n    \\t        \\t\\tfor (int j = all.size() -3;  j >= 0; j -= 1) {\\n    \\t        \\t\\t\\tif (isCrossing(line, all.get(j))) return true;\\n    \\t        \\t\\t}\\n    \\t        \\t}\\n    \\t        \\tall.add(line);\\n    \\t        }\\n    \\t        \\n    \\t        return false;\\n    \\t    }\\n    \\t    \\n    \\t    boolean isCrossing(int[] line1, int[] line2) {\\n    \\t    \\tint[] v = (line1[0] == line1[2]) ? line1 : line2;\\n    \\t    \\tint[] h = (v == line1) ? line2 : line1;\\n    \\t    \\t\\n    \\t    \\treturn ((v[0] >= h[0] && v[0] <= h[2]) || (v[0] >= h[2] && v[0] <= h[0])) && ((h[1] >= v[1] && h[1] <= v[3]) || (h[1] >= v[3] && h[1] <= v[1]));\\n    \\t    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 79148,
                "title": "javascript-closure-usage",
                "content": "Instead store every visited point, I store the line in closure:\\n\\n```js\\n\\nvar isSelfCrossing = function(x) {\\n    var cached = new Array(x.length);\\n    var diff_list = [[0, -1], [-1, 0], [0, 1], [1, 0]]\\n    \\n    function gen_func(start, end){\\n        var maxX = Math.max(start[0], end[0])\\n        var minX = Math.min(start[0], end[0])\\n        var maxY = Math.max(start[1], end[1])\\n        var minY = Math.min(start[1], end[1])\\n        return function(pos1, pos2){\\n            for(var x=Math.min(pos1[0], pos2[0]); x <=Math.max(pos1[0], pos2[0]); x++){\\n                for(var y=Math.min(pos1[1], pos2[1]); y<= Math.max(pos1[1], pos2[1]); y++ ){\\n                    if(x == pos1[0] && y == pos1[1]) {continue;}\\n                    if (x >= minX && x <= maxX && y >= minY &&  y <= maxY){\\n                        return true\\n                    }\\n                }\\n            }\\n            \\n            return false\\n        }\\n    }\\n    var start = [0, 0]\\n    for(var i=0; i<x.length; i++){\\n        var diff = diff_list[i%4];\\n        var end = [start[0]+x[i]*diff[0], start[1]+x[i]*diff[1]]\\n        for(var indexf=0;indexf<i; indexf++){\\n            if(cached[indexf](start, end)){\\n                return true\\n            }\\n        }\\n        cached[i] = gen_func(start,end)\\n        start = end\\n    }\\n    return false\\n    \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```js\\n\\nvar isSelfCrossing = function(x) {\\n    var cached = new Array(x.length);\\n    var diff_list = [[0, -1], [-1, 0], [0, 1], [1, 0]]\\n    \\n    function gen_func(start, end){\\n        var maxX = Math.max(start[0], end[0])\\n        var minX = Math.min(start[0], end[0])\\n        var maxY = Math.max(start[1], end[1])\\n        var minY = Math.min(start[1], end[1])\\n        return function(pos1, pos2){\\n            for(var x=Math.min(pos1[0], pos2[0]); x <=Math.max(pos1[0], pos2[0]); x++){\\n                for(var y=Math.min(pos1[1], pos2[1]); y<= Math.max(pos1[1], pos2[1]); y++ ){\\n                    if(x == pos1[0] && y == pos1[1]) {continue;}\\n                    if (x >= minX && x <= maxX && y >= minY &&  y <= maxY){\\n                        return true\\n                    }\\n                }\\n            }\\n            \\n            return false\\n        }\\n    }\\n    var start = [0, 0]\\n    for(var i=0; i<x.length; i++){\\n        var diff = diff_list[i%4];\\n        var end = [start[0]+x[i]*diff[0], start[1]+x[i]*diff[1]]\\n        for(var indexf=0;indexf<i; indexf++){\\n            if(cached[indexf](start, end)){\\n                return true\\n            }\\n        }\\n        cached[i] = gen_func(start,end)\\n        start = end\\n    }\\n    return false\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 79149,
                "title": "longest-c-solution-0ms-with-test-case",
                "content": "```\\n#include <iostream>\\n#include <cstring>\\n#include <cstdint>\\n#include <limits>\\n#include <vector>\\n#include <algorithm>\\n\\n#ifdef RUN_TEST\\n#   define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file\\n#   include \"catch.hpp\"\\n#else\\n#   define NDEBUG   // remove assert() call\\n#endif\\n#include <cassert>\\n\\n\\n// https://leetcode.com/problems/self-crossing/\\n\\n\\nusing namespace std;\\n\\n\\nenum Direction {\\n    UP = 0,\\n    LEFT = 1,\\n    DOWN = 2,\\n    RIGHT = 3\\n};\\n\\nstruct Pos {\\n    int x = 0;\\n    int y = 0;\\n};\\n\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(const vector<int>& x) {\\n        int xlen = x.size();\\n        int box[4];\\n        bool outter = true;\\n        Pos cur;\\n        Pos prev;\\n\\n        for (int i = 0; i < xlen ; i++) {\\n            int dir = i % 4;\\n\\n            prev = cur;\\n            if (dir == UP) {\\n                cur.y += x[i];\\n            } else if (dir == LEFT) {\\n                cur.x -= x[i];\\n            } else if (dir == DOWN) {\\n                cur.y -= x[i];\\n            } else {    // dir == RIGHT\\n                cur.x += x[i];\\n            }\\n\\n            if (i == 0) {\\n                ;\\n            } else if (i == 1) {\\n                ;\\n            } else if (i == 2) {\\n                if (cur.y >= 0) {\\n                    // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                    // \\u2502   \\u2502\\n                    //     \\u2502\\n                    outter = false;\\n                }\\n            } else if (i == 3) {\\n                if (outter) {\\n                    if (cur.x > 0) {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2502   \\u2502\\n                        // \\u2502\\n                        // \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\n                        box[LEFT] = prev.x;\\n                        box[RIGHT] = 0;\\n                        box[DOWN] = 0;\\n                        box[UP] = x[0];\\n                    } else if (cur.x == 0) {\\n                        outter = false;\\n                        box[LEFT] = prev.x;\\n                        box[RIGHT] = cur.x;\\n                        box[DOWN] = cur.y;\\n                        box[UP] = 0;\\n                    } else {    // cur.x < 0\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2502   \\u2502\\n                        // \\u2502\\n                        // \\u2514\\u2500\\u2500\\n                        outter = false;\\n                        box[LEFT] = prev.x;\\n                        box[RIGHT] = cur.x;\\n                        box[DOWN] = cur.y;\\n                        box[UP] = x[0];\\n                    }\\n                } else {    // inner\\n                    if (cur.x >= 0) {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2514\\u2500\\u2500\\u2500\\u2502\\u2500\\n                        //     \\u2502\\n                        return true;\\n                    } else {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2514\\u2500  \\u2502\\n                        //     \\u2502\\n                        box[RIGHT] = cur.x;\\n                        box[LEFT] = prev.x;\\n                        box[DOWN] = cur.y;\\n                        box[UP] = x[0];\\n                    }\\n                }\\n            } else {\\n                if (outter) {\\n                    if (dir == UP) {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2502   \\u2502 \\u2551\\n                        // \\u2502     \\u2551\\n                        // \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u255c\\n                        if (cur.y > box[UP]) {\\n                            box[DOWN] = prev.y;\\n                        } else {\\n                            outter = false;\\n                            if (cur.y >= box[DOWN]) {\\n                                box[LEFT] = box[RIGHT];\\n                            }\\n                            box[UP] = cur.y;\\n                            box[RIGHT] = cur.x;\\n                            box[DOWN] = prev.y;\\n                        }\\n                    } else if (dir == LEFT) {\\n                        if (cur.x < box[LEFT]) {\\n                            box[RIGHT] = prev.x;\\n                        } else {\\n                            outter = false;\\n                            if (cur.x <= box[RIGHT]) {\\n                                box[DOWN] = box[UP];\\n                            }\\n                            box[LEFT] = cur.x;\\n                            box[UP] = cur.y;\\n                            box[RIGHT] = prev.x;\\n                        }\\n                    } else if (dir == DOWN) {\\n                        if (cur.y < box[DOWN]) {\\n                            box[UP] = prev.y;\\n                        } else {\\n                            outter = false;\\n                            if (cur.y <= box[UP]) {\\n                                box[RIGHT] = box[LEFT];\\n                            }\\n                            box[DOWN] = cur.y;\\n                            box[LEFT] = cur.x;\\n                            box[UP] = prev.y;\\n                        }\\n                    } else {    // dir == RIGHT\\n                        if (cur.x > box[RIGHT]) {\\n                            box[LEFT] = prev.x;\\n                        } else {\\n                            outter = false;\\n                            if (cur.x >= box[LEFT]) {\\n                                box[UP] = box[DOWN];\\n                            }\\n                            box[LEFT] = prev.x;\\n                            box[DOWN] = cur.y;\\n                            box[RIGHT] = cur.x;\\n                        }\\n                    }\\n                } else {    // inner\\n                    if (dir == UP) {\\n                        if (cur.y >= box[UP]) {\\n                            return true;\\n                        } else {\\n                            box[UP] = cur.y;\\n                        }\\n                    } else if (dir == LEFT) {\\n                        if (cur.x <= box[LEFT]) {\\n                            return true;\\n                        } else {\\n                            box[LEFT] = cur.x;\\n                        }\\n                    } else if (dir == DOWN) {\\n                        if (cur.y <= box[DOWN]) {\\n                            return true;\\n                        } else {\\n                            box[DOWN] = cur.y;\\n                        }\\n                    } else {    // dir == RIGHT\\n                        if (cur.x >= box[RIGHT]) {\\n                            return true;\\n                        } else {\\n                            box[RIGHT] = cur.x;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n\\n#ifdef RUN_TEST\\nTEST_CASE(\"335. Self Crossing\") {\\n    Solution s;\\n\\n    CHECK(s.isSelfCrossing({ 1, 1, 1, 1 }) == true);\\n    CHECK(s.isSelfCrossing({ 1, 2, 3, 4, 5 }) == false);\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 1, 1 }) == true);\\n\\n    CHECK(s.isSelfCrossing({}) == false);\\n    CHECK(s.isSelfCrossing({ 1 }) == false);\\n    CHECK(s.isSelfCrossing({ 2, 1 }) == false);\\n    CHECK(s.isSelfCrossing({ 2, 1, 1 }) == false);\\n\\n    CHECK(s.isSelfCrossing({ 2, 2, 1, 2 }) == true);\\n    CHECK(s.isSelfCrossing({ 2, 2, 1, 1 }) == false);\\n\\n    CHECK(s.isSelfCrossing({ 6, 6, 5, 5, 4, 4, 3, 3, 2, 2 }) == false);\\n    CHECK(s.isSelfCrossing({ 6, 6, 5, 5, 4, 4, 3, 3, 2, 3 }) == true);\\n\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 2, 3, 3, 4, 4, 5, 5 }) == false);\\n\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 8, 8, 4, 4, 3, 3, 2, 2, 1, 1 }) == false);\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 8, 8, 4, 7, 5 }) == true);\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 8, 8, 7, 6 }) == true);\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <iostream>\\n#include <cstring>\\n#include <cstdint>\\n#include <limits>\\n#include <vector>\\n#include <algorithm>\\n\\n#ifdef RUN_TEST\\n#   define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file\\n#   include \"catch.hpp\"\\n#else\\n#   define NDEBUG   // remove assert() call\\n#endif\\n#include <cassert>\\n\\n\\n// https://leetcode.com/problems/self-crossing/\\n\\n\\nusing namespace std;\\n\\n\\nenum Direction {\\n    UP = 0,\\n    LEFT = 1,\\n    DOWN = 2,\\n    RIGHT = 3\\n};\\n\\nstruct Pos {\\n    int x = 0;\\n    int y = 0;\\n};\\n\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(const vector<int>& x) {\\n        int xlen = x.size();\\n        int box[4];\\n        bool outter = true;\\n        Pos cur;\\n        Pos prev;\\n\\n        for (int i = 0; i < xlen ; i++) {\\n            int dir = i % 4;\\n\\n            prev = cur;\\n            if (dir == UP) {\\n                cur.y += x[i];\\n            } else if (dir == LEFT) {\\n                cur.x -= x[i];\\n            } else if (dir == DOWN) {\\n                cur.y -= x[i];\\n            } else {    // dir == RIGHT\\n                cur.x += x[i];\\n            }\\n\\n            if (i == 0) {\\n                ;\\n            } else if (i == 1) {\\n                ;\\n            } else if (i == 2) {\\n                if (cur.y >= 0) {\\n                    // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                    // \\u2502   \\u2502\\n                    //     \\u2502\\n                    outter = false;\\n                }\\n            } else if (i == 3) {\\n                if (outter) {\\n                    if (cur.x > 0) {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2502   \\u2502\\n                        // \\u2502\\n                        // \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\n                        box[LEFT] = prev.x;\\n                        box[RIGHT] = 0;\\n                        box[DOWN] = 0;\\n                        box[UP] = x[0];\\n                    } else if (cur.x == 0) {\\n                        outter = false;\\n                        box[LEFT] = prev.x;\\n                        box[RIGHT] = cur.x;\\n                        box[DOWN] = cur.y;\\n                        box[UP] = 0;\\n                    } else {    // cur.x < 0\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2502   \\u2502\\n                        // \\u2502\\n                        // \\u2514\\u2500\\u2500\\n                        outter = false;\\n                        box[LEFT] = prev.x;\\n                        box[RIGHT] = cur.x;\\n                        box[DOWN] = cur.y;\\n                        box[UP] = x[0];\\n                    }\\n                } else {    // inner\\n                    if (cur.x >= 0) {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2514\\u2500\\u2500\\u2500\\u2502\\u2500\\n                        //     \\u2502\\n                        return true;\\n                    } else {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2514\\u2500  \\u2502\\n                        //     \\u2502\\n                        box[RIGHT] = cur.x;\\n                        box[LEFT] = prev.x;\\n                        box[DOWN] = cur.y;\\n                        box[UP] = x[0];\\n                    }\\n                }\\n            } else {\\n                if (outter) {\\n                    if (dir == UP) {\\n                        // \\u250c\\u2500\\u2500\\u2500\\u2510\\n                        // \\u2502   \\u2502 \\u2551\\n                        // \\u2502     \\u2551\\n                        // \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u255c\\n                        if (cur.y > box[UP]) {\\n                            box[DOWN] = prev.y;\\n                        } else {\\n                            outter = false;\\n                            if (cur.y >= box[DOWN]) {\\n                                box[LEFT] = box[RIGHT];\\n                            }\\n                            box[UP] = cur.y;\\n                            box[RIGHT] = cur.x;\\n                            box[DOWN] = prev.y;\\n                        }\\n                    } else if (dir == LEFT) {\\n                        if (cur.x < box[LEFT]) {\\n                            box[RIGHT] = prev.x;\\n                        } else {\\n                            outter = false;\\n                            if (cur.x <= box[RIGHT]) {\\n                                box[DOWN] = box[UP];\\n                            }\\n                            box[LEFT] = cur.x;\\n                            box[UP] = cur.y;\\n                            box[RIGHT] = prev.x;\\n                        }\\n                    } else if (dir == DOWN) {\\n                        if (cur.y < box[DOWN]) {\\n                            box[UP] = prev.y;\\n                        } else {\\n                            outter = false;\\n                            if (cur.y <= box[UP]) {\\n                                box[RIGHT] = box[LEFT];\\n                            }\\n                            box[DOWN] = cur.y;\\n                            box[LEFT] = cur.x;\\n                            box[UP] = prev.y;\\n                        }\\n                    } else {    // dir == RIGHT\\n                        if (cur.x > box[RIGHT]) {\\n                            box[LEFT] = prev.x;\\n                        } else {\\n                            outter = false;\\n                            if (cur.x >= box[LEFT]) {\\n                                box[UP] = box[DOWN];\\n                            }\\n                            box[LEFT] = prev.x;\\n                            box[DOWN] = cur.y;\\n                            box[RIGHT] = cur.x;\\n                        }\\n                    }\\n                } else {    // inner\\n                    if (dir == UP) {\\n                        if (cur.y >= box[UP]) {\\n                            return true;\\n                        } else {\\n                            box[UP] = cur.y;\\n                        }\\n                    } else if (dir == LEFT) {\\n                        if (cur.x <= box[LEFT]) {\\n                            return true;\\n                        } else {\\n                            box[LEFT] = cur.x;\\n                        }\\n                    } else if (dir == DOWN) {\\n                        if (cur.y <= box[DOWN]) {\\n                            return true;\\n                        } else {\\n                            box[DOWN] = cur.y;\\n                        }\\n                    } else {    // dir == RIGHT\\n                        if (cur.x >= box[RIGHT]) {\\n                            return true;\\n                        } else {\\n                            box[RIGHT] = cur.x;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n\\n#ifdef RUN_TEST\\nTEST_CASE(\"335. Self Crossing\") {\\n    Solution s;\\n\\n    CHECK(s.isSelfCrossing({ 1, 1, 1, 1 }) == true);\\n    CHECK(s.isSelfCrossing({ 1, 2, 3, 4, 5 }) == false);\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 1, 1 }) == true);\\n\\n    CHECK(s.isSelfCrossing({}) == false);\\n    CHECK(s.isSelfCrossing({ 1 }) == false);\\n    CHECK(s.isSelfCrossing({ 2, 1 }) == false);\\n    CHECK(s.isSelfCrossing({ 2, 1, 1 }) == false);\\n\\n    CHECK(s.isSelfCrossing({ 2, 2, 1, 2 }) == true);\\n    CHECK(s.isSelfCrossing({ 2, 2, 1, 1 }) == false);\\n\\n    CHECK(s.isSelfCrossing({ 6, 6, 5, 5, 4, 4, 3, 3, 2, 2 }) == false);\\n    CHECK(s.isSelfCrossing({ 6, 6, 5, 5, 4, 4, 3, 3, 2, 3 }) == true);\\n\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 2, 3, 3, 4, 4, 5, 5 }) == false);\\n\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 8, 8, 4, 4, 3, 3, 2, 2, 1, 1 }) == false);\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 8, 8, 4, 7, 5 }) == true);\\n    CHECK(s.isSelfCrossing({ 1, 1, 2, 8, 8, 7, 6 }) == true);\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 79150,
                "title": "simple-c-0ms-soln-w-explanation",
                "content": "````\\n// There can be an inward spiral OR an outward spiral which may or may not be followed by an inward spiral\\n// So the sequence with either be all decreasing OR increasing and then decreasing (only one hill)\\n            \\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if (x.size() <= 3) return false;\\n        int i=2;\\n        \\n        // Check if it starts in desending order\\n        if (x[2] < x[0]){\\n            // Confirm rest all are in decending order as well\\n            for(i=3; i < x.size(); i++){\\n                if (x[i] >= x[i-2]) return true;\\n            }\\n            // If not then there is a overlap\\n            return false;\\n        }\\n        \\n        // Look for the place/hill (if any) where it becomes non-asending\\n        while(++i < x.size()) if (x[i] <= x[i-2]) break;\\n        \\n        // If not found, then there is no overlap\\n        if (i >= x.size()) return false;\\n\\n\\n        // Else make sure the following two conditions are not met, at that point\\n        // <---------------^\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |  ------------>|\\n        // |     ^\\n        // |     |\\n        // v---->|\\n        if (i-4 >= 0 && (x[i-4] + x[i] >= x[i-2]) && (x[i+1] >= x[i-1] - x[i-3])) return true;\\n\\n\\n\\n        // <---------------^\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |               \\n        // |     \\n        // v--------------->\\n        if (i-3 == 0 && x[i] == x[i-2] && (x[i-1] == x[i-3] || (i+1 < x.size() && x[i+1] + x[i-3] >= x[i-1]))) return true;\\n        \\n        // Confirm rest are in decending order, another hill => overlap\\n        while(++i < x.size()) if (x[i] >= x[i-2]) return true;\\n        return false;\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "````\\n// There can be an inward spiral OR an outward spiral which may or may not be followed by an inward spiral\\n// So the sequence with either be all decreasing OR increasing and then decreasing (only one hill)\\n            \\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        if (x.size() <= 3) return false;\\n        int i=2;\\n        \\n        // Check if it starts in desending order\\n        if (x[2] < x[0]){\\n            // Confirm rest all are in decending order as well\\n            for(i=3; i < x.size(); i++){\\n                if (x[i] >= x[i-2]) return true;\\n            }\\n            // If not then there is a overlap\\n            return false;\\n        }\\n        \\n        // Look for the place/hill (if any) where it becomes non-asending\\n        while(++i < x.size()) if (x[i] <= x[i-2]) break;\\n        \\n        // If not found, then there is no overlap\\n        if (i >= x.size()) return false;\\n\\n\\n        // Else make sure the following two conditions are not met, at that point\\n        // <---------------^\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |  ------------>|\\n        // |     ^\\n        // |     |\\n        // v---->|\\n        if (i-4 >= 0 && (x[i-4] + x[i] >= x[i-2]) && (x[i+1] >= x[i-1] - x[i-3])) return true;\\n\\n\\n\\n        // <---------------^\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |               |\\n        // |               \\n        // |     \\n        // v--------------->\\n        if (i-3 == 0 && x[i] == x[i-2] && (x[i-1] == x[i-3] || (i+1 < x.size() && x[i+1] + x[i-3] >= x[i-1]))) return true;\\n        \\n        // Confirm rest are in decending order, another hill => overlap\\n        while(++i < x.size()) if (x[i] >= x[i-2]) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79153,
                "title": "c-code-0ms-one-pass-algorithm-with-o-1-extra-space",
                "content": "thx for @district10 \\n```\\nthere is only 3 cases of self crossing\\n//  1) 4 lines\\n//         #       \\n//       <---[2]----+        [2]: second failure\\n//         |        |\\n//         |       [1]       [1]: first  failure\\n//         |        |\\n//         +--------+\\n//  2) 5 lines;\\n//         +-------+\\n//         |       |\\n//         |       #\\n//         |\\n//         |       ^\\n//         |       |\\n//         +-------+\\n//  2) 6 lines\\n//      +----+\\n//      |    |\\n//      |  <----[2]----^     [2]: second failure\\n//      |    #         |\\n//      |             [1]    [1]: first  failure\\n//      |              |\\n//      +--------------+\\n\\nbool isSelfCrossing(int* x, int xSize) {\\n    for (int i=3; i<xSize; ++i) {\\n        if (/*(i>=3) && */(x[i]>=x[i-2]) && (x[i-1]<=x[i-3])) return true;   // 4 lines\\n        else if ((i>=4) && (x[i-1]==x[i-3]) && ((x[i]+x[i-4])>=x[i-2])) return true; // 5 lines\\n        else if ((i>=5) && (x[i-2]>x[i-4]) && (x[i-3]>x[i-5]) && (x[i]+x[i-4]>=x[i-2]) && (x[i-1]<=x[i-3])&&(x[i-1]+x[i-5]>=x[i-3])) return true;  // 6 lines\\n    }\\n    return false;\\n}```",
                "solutionTags": [],
                "code": "```\\nthere is only 3 cases of self crossing\\n//  1) 4 lines\\n//         #       \\n//       <---[2]----+        [2]: second failure\\n//         |        |\\n//         |       [1]       [1]: first  failure\\n//         |        |\\n//         +--------+\\n//  2) 5 lines;\\n//         +-------+\\n//         |       |\\n//         |       #\\n//         |\\n//         |       ^\\n//         |       |\\n//         +-------+\\n//  2) 6 lines\\n//      +----+\\n//      |    |\\n//      |  <----[2]----^     [2]: second failure\\n//      |    #         |\\n//      |             [1]    [1]: first  failure\\n//      |              |\\n//      +--------------+\\n\\nbool isSelfCrossing(int* x, int xSize) {\\n    for (int i=3; i<xSize; ++i) {\\n        if (/*(i>=3) && */(x[i]>=x[i-2]) && (x[i-1]<=x[i-3])) return true;   // 4 lines\\n        else if ((i>=4) && (x[i-1]==x[i-3]) && ((x[i]+x[i-4])>=x[i-2])) return true; // 5 lines\\n        else if ((i>=5) && (x[i-2]>x[i-4]) && (x[i-3]>x[i-5]) && (x[i]+x[i-4]>=x[i-2]) && (x[i-1]<=x[i-3])&&(x[i-1]+x[i-5]>=x[i-3])) return true;  // 6 lines\\n    }\\n    return false;\\n}```",
                "codeTag": "Unknown"
            },
            {
                "id": 79154,
                "title": "straight-forward-dumb-simulation-solution-0ms-o-1-space",
                "content": "Test cases are too small, so I did a pure simulation implementation and still got 0 ms result. Not as brilliant as the pattern finding solution but still it works.\\n\\nLet's consider each movement, since the movements always happen in counter-clockwise sequence, so we can only look at one direction and apply accordingly to other directions.\\n\\nIf we want to move upwards (NORTH), we will be able to cross either the previous \"SOUTH\" line drawn by the last eastward movement or the previous \"NORTH\" border line drawn by the last westward movement. All we need to do is to determine the potential crossing line before each move. In order words, we can expand the following pseudo code into the final solution.\\n\\nfor x in X[1 .. n]\\n  move point\\n  if point hit potential line: return true\\n  update potential line for the next move\\n\\nImplementation in C++ (quite long):\\n\\n```\\nenum dir_t\\n{\\n    NORTH = 0,\\n    WEST = 1,\\n    SOUTH = 2,\\n    EAST = 3\\n};\\n\\ndir_t next_dir(dir_t d)\\n{\\n    switch(d)\\n    {\\n        case NORTH: return WEST;\\n        case WEST : return SOUTH;\\n        case SOUTH: return EAST;\\n        case EAST : return NORTH;\\n    }\\n    \\n    return NORTH;\\n}\\n\\nstruct point_t\\n{\\n    int x;\\n    int y;\\n    \\n    point_t() : x(0), y(0) {}\\n    point_t(int a, int b) : x(a), y(b) {}\\n    \\n    bool operator <= (const point_t& p) const\\n    {\\n        return this->x < p.x || (this->x == p.x && this->y <= p.y);\\n    }\\n    \\n};\\n\\nostream& operator << (ostream& os, const point_t& p)\\n{\\n    return os << \"[\" << p.x << \",\" << p.y << \"]\";\\n}\\n\\ntypedef pair<point_t, point_t> line_t;\\n\\nostream& operator << (ostream& os, const line_t& l)\\n{\\n    if(l.first <= l.second)\\n        return os << \"{\" << l.first << \",\" << l.second << \"}\";\\n    else\\n        return os << \"{INV}\";\\n}\\n\\nbool is_line_valid(line_t& l)\\n{\\n    return l.first <= l.second;\\n}\\n\\nvoid make_line_invalid(line_t& l)\\n{\\n    l.first.x = 0; l.first.y = 0;\\n    l.second.x = -1; l.second.y = -1;\\n}\\n\\ntypedef vector<line_t> border_t;\\n\\npoint_t move_point(point_t& s, dir_t d, int l)\\n{\\n    point_t p(s);\\n    switch(d)\\n    {\\n        case NORTH: p.y += l; return p;\\n        case WEST : p.x -= l; return p;\\n        case SOUTH: p.y -= l; return p;\\n        case EAST : p.x += l; return p;\\n    }\\n    \\n    return p;\\n}\\n\\nbool can_hit(point_t& e, dir_t d, border_t& border)\\n{\\n    if(is_line_valid(border[d]))\\n    {\\n        switch(d)\\n        {\\n            case NORTH: return e.x >= border[NORTH].first.x && e.x <= border[NORTH].second.x && e.y >= border[NORTH].first.y;\\n            case WEST : return e.y >= border[WEST ].first.y && e.y <= border[WEST ].second.y && e.x <= border[WEST ].first.x;\\n            case SOUTH: return e.x >= border[SOUTH].first.x && e.x <= border[SOUTH].second.x && e.y <= border[SOUTH].first.y;\\n            case EAST : return e.y >= border[EAST ].first.y && e.y <= border[EAST ].second.y && e.x >= border[EAST ].first.x;\\n        }\\n    }\\n    \\n    return false;\\n}\\n\\nvoid update_border(point_t& s, point_t& e, dir_t d, border_t& border)\\n{\\n    dir_t nd = next_dir(d);\\n    \\n    switch(nd)\\n    {\\n        case NORTH:\\n        {\\n            if(is_line_valid(border[SOUTH]) && e.y < border[SOUTH].first.y)\\n            {\\n                if(e.x >= border[SOUTH].first.x && e.x <= border[SOUTH].second.x)\\n                    border[NORTH] = border[SOUTH];\\n            }\\n            \\n            border[SOUTH].first = s;\\n            border[SOUTH].second = e;\\n            break;\\n        }\\n        case WEST:\\n        {\\n            if(is_line_valid(border[EAST]) && e.x > border[EAST].first.x)\\n            {\\n                if(e.y >= border[EAST].first.y && e.y <= border[EAST].second.y)\\n                    border[WEST] = border[EAST];\\n            }\\n            \\n            border[EAST].first = s;\\n            border[EAST].second = e;\\n            break;\\n        }\\n        case SOUTH:\\n        {\\n            if(is_line_valid(border[NORTH]) && e.y > border[NORTH].first.y)\\n            {\\n                if(e.x >= border[NORTH].first.x && e.x <= border[NORTH].second.x)\\n                    border[SOUTH] = border[NORTH];\\n            }\\n            \\n            border[NORTH].first = e;\\n            border[NORTH].second = s;\\n            break;\\n        }\\n        case EAST:\\n        {\\n            if(is_line_valid(border[WEST]) && e.x < border[WEST].first.x)\\n            {\\n                if(e.y >= border[WEST].first.y && e.y <= border[WEST].second.y)\\n                    border[EAST] = border[WEST];\\n            }\\n            \\n            border[WEST].first = e;\\n            border[WEST].second = s;\\n            break;\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        int i, N = x.size();\\n        \\n        dir_t d = NORTH;\\n        point_t s(0,0);\\n        border_t border(4);\\n        \\n        for(i = 0; i < 4; ++i) make_line_invalid(border[i]);\\n        \\n        border[SOUTH].first = s;\\n        border[SOUTH].second = s;\\n        \\n        for(i = 0; i < N; ++i)\\n        {\\n            point_t e = move_point(s, d, x[i]);\\n            \\n            if(can_hit(e, d, border)) return true;\\n            \\n            update_border(s, e, d, border);\\n            \\n            // cout << \"e: \" << e << endl;\\n            \\n            // cout << \"N: \" << border[NORTH] << endl;\\n            // cout << \"W: \" << border[WEST ] << endl;\\n            // cout << \"S: \" << border[SOUTH] << endl;\\n            // cout << \"E: \" << border[EAST ] << endl;\\n            // cout << endl;\\n            \\n            s = e;\\n            d = next_dir(d);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nenum dir_t\\n{\\n    NORTH = 0,\\n    WEST = 1,\\n    SOUTH = 2,\\n    EAST = 3\\n};\\n\\ndir_t next_dir(dir_t d)\\n{\\n    switch(d)\\n    {\\n        case NORTH: return WEST;\\n        case WEST : return SOUTH;\\n        case SOUTH: return EAST;\\n        case EAST : return NORTH;\\n    }\\n    \\n    return NORTH;\\n}\\n\\nstruct point_t\\n{\\n    int x;\\n    int y;\\n    \\n    point_t() : x(0), y(0) {}\\n    point_t(int a, int b) : x(a), y(b) {}\\n    \\n    bool operator <= (const point_t& p) const\\n    {\\n        return this->x < p.x || (this->x == p.x && this->y <= p.y);\\n    }\\n    \\n};\\n\\nostream& operator << (ostream& os, const point_t& p)\\n{\\n    return os << \"[\" << p.x << \",\" << p.y << \"]\";\\n}\\n\\ntypedef pair<point_t, point_t> line_t;\\n\\nostream& operator << (ostream& os, const line_t& l)\\n{\\n    if(l.first <= l.second)\\n        return os << \"{\" << l.first << \",\" << l.second << \"}\";\\n    else\\n        return os << \"{INV}\";\\n}\\n\\nbool is_line_valid(line_t& l)\\n{\\n    return l.first <= l.second;\\n}\\n\\nvoid make_line_invalid(line_t& l)\\n{\\n    l.first.x = 0; l.first.y = 0;\\n    l.second.x = -1; l.second.y = -1;\\n}\\n\\ntypedef vector<line_t> border_t;\\n\\npoint_t move_point(point_t& s, dir_t d, int l)\\n{\\n    point_t p(s);\\n    switch(d)\\n    {\\n        case NORTH: p.y += l; return p;\\n        case WEST : p.x -= l; return p;\\n        case SOUTH: p.y -= l; return p;\\n        case EAST : p.x += l; return p;\\n    }\\n    \\n    return p;\\n}\\n\\nbool can_hit(point_t& e, dir_t d, border_t& border)\\n{\\n    if(is_line_valid(border[d]))\\n    {\\n        switch(d)\\n        {\\n            case NORTH: return e.x >= border[NORTH].first.x && e.x <= border[NORTH].second.x && e.y >= border[NORTH].first.y;\\n            case WEST : return e.y >= border[WEST ].first.y && e.y <= border[WEST ].second.y && e.x <= border[WEST ].first.x;\\n            case SOUTH: return e.x >= border[SOUTH].first.x && e.x <= border[SOUTH].second.x && e.y <= border[SOUTH].first.y;\\n            case EAST : return e.y >= border[EAST ].first.y && e.y <= border[EAST ].second.y && e.x >= border[EAST ].first.x;\\n        }\\n    }\\n    \\n    return false;\\n}\\n\\nvoid update_border(point_t& s, point_t& e, dir_t d, border_t& border)\\n{\\n    dir_t nd = next_dir(d);\\n    \\n    switch(nd)\\n    {\\n        case NORTH:\\n        {\\n            if(is_line_valid(border[SOUTH]) && e.y < border[SOUTH].first.y)\\n            {\\n                if(e.x >= border[SOUTH].first.x && e.x <= border[SOUTH].second.x)\\n                    border[NORTH] = border[SOUTH];\\n            }\\n            \\n            border[SOUTH].first = s;\\n            border[SOUTH].second = e;\\n            break;\\n        }\\n        case WEST:\\n        {\\n            if(is_line_valid(border[EAST]) && e.x > border[EAST].first.x)\\n            {\\n                if(e.y >= border[EAST].first.y && e.y <= border[EAST].second.y)\\n                    border[WEST] = border[EAST];\\n            }\\n            \\n            border[EAST].first = s;\\n            border[EAST].second = e;\\n            break;\\n        }\\n        case SOUTH:\\n        {\\n            if(is_line_valid(border[NORTH]) && e.y > border[NORTH].first.y)\\n            {\\n                if(e.x >= border[NORTH].first.x && e.x <= border[NORTH].second.x)\\n                    border[SOUTH] = border[NORTH];\\n            }\\n            \\n            border[NORTH].first = e;\\n            border[NORTH].second = s;\\n            break;\\n        }\\n        case EAST:\\n        {\\n            if(is_line_valid(border[WEST]) && e.x < border[WEST].first.x)\\n            {\\n                if(e.y >= border[WEST].first.y && e.y <= border[WEST].second.y)\\n                    border[EAST] = border[WEST];\\n            }\\n            \\n            border[WEST].first = e;\\n            border[WEST].second = s;\\n            break;\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n        int i, N = x.size();\\n        \\n        dir_t d = NORTH;\\n        point_t s(0,0);\\n        border_t border(4);\\n        \\n        for(i = 0; i < 4; ++i) make_line_invalid(border[i]);\\n        \\n        border[SOUTH].first = s;\\n        border[SOUTH].second = s;\\n        \\n        for(i = 0; i < N; ++i)\\n        {\\n            point_t e = move_point(s, d, x[i]);\\n            \\n            if(can_hit(e, d, border)) return true;\\n            \\n            update_border(s, e, d, border);\\n            \\n            // cout << \"e: \" << e << endl;\\n            \\n            // cout << \"N: \" << border[NORTH] << endl;\\n            // cout << \"W: \" << border[WEST ] << endl;\\n            // cout << \"S: \" << border[SOUTH] << endl;\\n            // cout << \"E: \" << border[EAST ] << endl;\\n            // cout << endl;\\n            \\n            s = e;\\n            d = next_dir(d);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 79151,
                "title": "java-solution-easy-2d-euclidean-map-solution",
                "content": "The idea is to use a Hashset of 2d Point (x,y) and insert each traversed point into the Set, once an already traversed point is reached, return true (cycle), otherwise return false.\\n\\npublic class SelfCrossing {\\n\\n\\t\\n\\t public static boolean isSelfCrossing(int[] x) {\\n\\t\\t if (x == null || x.length < 4) {\\n\\t\\t\\t return false;\\n\\t\\t }\\n\\t        \\n\\t\\t int direction = 1; // start North\\n\\t\\t int moves = 0;\\n\\t\\t int cX = 0;\\n\\t\\t int cY = 0;\\n\\t\\t Set<Point2D> pointSets = new HashSet<>();\\n\\t\\t pointSets.add(new Point2D(0,0)); // origin\\n\\t\\t Point2D p = null;\\n\\n\\t\\t for (int i = 0; i < x.length; i++) {\\n\\t\\t\\tmoves = x[i];\\n\\t\\t\\twhile (moves > 0) {\\n\\t\\t\\t\\tif (direction == 1) {\\n\\t\\t\\t\\t\\tcY++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (direction == 2) {\\n\\t\\t\\t\\t\\tcX--;\\n\\t\\t\\t\\t}\\t\\t\\n\\t\\t\\t\\telse if (direction == 3) {\\n\\t\\t\\t\\t\\tcY--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (direction == 4) {\\n\\t\\t\\t\\t\\tcX++;\\n\\t\\t\\t\\t}\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tp = new Point2D(cX, cY);\\n\\t\\t\\t\\tif (pointSets.contains(p)) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpointSets.add(p);\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\n\\t\\t\\t\\tmoves--;\\n\\t\\t\\t}\\n\\t\\t\\tif (direction == 4) {\\n\\t\\t\\t\\tdirection = 0;\\n\\t\\t\\t}\\t\\n\\t\\t\\tdirection++;\\n\\t\\t }\\t \\t   \\n\\t\\t return false;\\n\\t }\\n}\\n\\nclass Point2D {\\n\\tint x;\\n\\tint y;\\n\\tpublic Point2D(int x, int y) {\\n\\t\\tsuper();\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\t}\\n\\t@Override\\n\\tpublic int hashCode() {\\n\\t\\tfinal int prime = 31;\\n\\t\\tint result = 1;\\n\\t\\tresult = prime * result + x;\\n\\t\\tresult = prime * result + y;\\n\\t\\treturn result;\\n\\t}\\n\\t@Override\\n\\tpublic boolean equals(Object obj) {\\n\\t\\tif (this == obj)\\n\\t\\t\\treturn true;\\n\\t\\tif (obj == null)\\n\\t\\t\\treturn false;\\n\\t\\tif (getClass() != obj.getClass())\\n\\t\\t\\treturn false;\\n\\t\\tPoint2D other = (Point2D) obj;\\n\\t\\tif (x != other.x)\\n\\t\\t\\treturn false;\\n\\t\\tif (y != other.y)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n}",
                "solutionTags": [],
                "code": "The idea is to use a Hashset of 2d Point (x,y) and insert each traversed point into the Set, once an already traversed point is reached, return true (cycle), otherwise return false.\\n\\npublic class SelfCrossing {\\n\\n\\t\\n\\t public static boolean isSelfCrossing(int[] x) {\\n\\t\\t if (x == null || x.length < 4) {\\n\\t\\t\\t return false;\\n\\t\\t }\\n\\t        \\n\\t\\t int direction = 1; // start North\\n\\t\\t int moves = 0;\\n\\t\\t int cX = 0;\\n\\t\\t int cY = 0;\\n\\t\\t Set<Point2D> pointSets = new HashSet<>();\\n\\t\\t pointSets.add(new Point2D(0,0)); // origin\\n\\t\\t Point2D p = null;\\n\\n\\t\\t for (int i = 0; i < x.length; i++) {\\n\\t\\t\\tmoves = x[i];\\n\\t\\t\\twhile (moves > 0) {\\n\\t\\t\\t\\tif (direction == 1) {\\n\\t\\t\\t\\t\\tcY++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (direction == 2) {\\n\\t\\t\\t\\t\\tcX--;\\n\\t\\t\\t\\t}\\t\\t\\n\\t\\t\\t\\telse if (direction == 3) {\\n\\t\\t\\t\\t\\tcY--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (direction == 4) {\\n\\t\\t\\t\\t\\tcX++;\\n\\t\\t\\t\\t}\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tp = new Point2D(cX, cY);\\n\\t\\t\\t\\tif (pointSets.contains(p)) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpointSets.add(p);\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\n\\t\\t\\t\\tmoves--;\\n\\t\\t\\t}\\n\\t\\t\\tif (direction == 4) {\\n\\t\\t\\t\\tdirection = 0;\\n\\t\\t\\t}\\t\\n\\t\\t\\tdirection++;\\n\\t\\t }\\t \\t   \\n\\t\\t return false;\\n\\t }\\n}\\n\\nclass Point2D {\\n\\tint x;\\n\\tint y;\\n\\tpublic Point2D(int x, int y) {\\n\\t\\tsuper();\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\t}\\n\\t@Override\\n\\tpublic int hashCode() {\\n\\t\\tfinal int prime = 31;\\n\\t\\tint result = 1;\\n\\t\\tresult = prime * result + x;\\n\\t\\tresult = prime * result + y;\\n\\t\\treturn result;\\n\\t}\\n\\t@Override\\n\\tpublic boolean equals(Object obj) {\\n\\t\\tif (this == obj)\\n\\t\\t\\treturn true;\\n\\t\\tif (obj == null)\\n\\t\\t\\treturn false;\\n\\t\\tif (getClass() != obj.getClass())\\n\\t\\t\\treturn false;\\n\\t\\tPoint2D other = (Point2D) obj;\\n\\t\\tif (x != other.x)\\n\\t\\t\\treturn false;\\n\\t\\tif (y != other.y)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n}",
                "codeTag": "Java"
            },
            {
                "id": 79155,
                "title": "java-solution-long-and-easy-to-understand",
                "content": "Identify two possible modes: 1. Area is expanding, and 2. Area is shrinking. We need to identify the current mode.\\n\\nFor shrinking mode, let current index be i, then if x[i] < x[i-2], x[i] is safe. \\nFor expanding mode, it is more complicated. For index i, there are 3 possible situations:\\n\\u3000\\u3000\\u3000\\u30001. x[i] > x[i-2]: still expanding mode, safe\\n\\u3000\\u3000\\u3000\\u30002. x[i] < x[i-2] - x[i-4]: switch to shrink mode, but safe\\n\\u3000\\u3000\\u3000\\u30003. x[i] >= x[i-2] - x[i-4]: switch to shrink mode, but possibly not safe, we need further determine, see the code and draw a figure.\\n\\n```public class Solution {\\n    public boolean isSelfCrossingExpand(int[] x, int start){\\n        for (int i=start;i<x.length;i++){\\n            if (x[i] > x[i-2]){\\n                continue;\\n            } else {\\n                // becomes shrink mode\\n                int bar = (i>=4) ? x[i-4] : 0;                 // handle corner case here.\\n                if (x[i] <= x[i-2] && x[i] >= (x[i-2] - bar)){\\n                    if ( i+1 == x.length){\\n                        return false;\\n                    }\\n                    if (x[i+1] >= (x[i-1] - x[i-3])){\\n                        return true;\\n                    }\\n                    return isSelfCrossingShrink(x,i+2);\\n                } else {\\n                    return isSelfCrossingShrink(x,i+1);\\n                }\\n            }        \\n        }\\n        return false;\\n    }\\n\\n    public boolean isSelfCrossingShrink(int[] x, int start){\\n        for (int i=start; i<x.length;i++){\\n            if (x[i] >= x[i-2])\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean isSelfCrossing(int[] x) {\\n        if (x.length<=3) return false;\\n\\n        if (x[2] <= x[0]) return isSelfCrossingShrink(x,3);        \\n        return isSelfCrossingExpand(x,3);\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isSelfCrossingExpand(int[] x, int start){\\n        for (int i=start;i<x.length;i++){\\n            if (x[i] > x[i-2]){\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 79156,
                "title": "simple-recursion-java",
                "content": "```\\npublic class Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if (x == null || x.length <= 3) {\\n            return false;\\n        }\\n        return _first(x, 0);\\n    }\\n    \\n    private boolean _first(int[] x, int index) {\\n        return index >= x.length - 3 ? false : _second(x, index + 1, x[index]);\\n    }\\n    \\n    private boolean _second(int[] x, int index, int first) {\\n        return index >= x.length - 2 ? false : _third(x, index + 1, first, x[index]);\\n    }\\n    \\n    private boolean _third(int[] x, int index, int first, int second) {\\n        if (index >= x.length - 1) {\\n            return false;\\n        }\\n        if (x[index] <= first) {\\n            return _decrease(x, index + 1, second, x[index]);\\n        } else {\\n            return _fourth(x, index + 1, first, second, x[index]);\\n        }\\n    }\\n    \\n    private boolean _fourth(int[] x, int index, int first, int second, int third) {\\n        if (index >= x.length) {\\n            return false;\\n        }\\n        if (x[index] < second) {\\n            return _decrease(x, index + 1, third, x[index]);\\n        } else if (x[index] == second) {\\n            return _decrease(x, index + 1, third - first, x[index]);\\n        } else {\\n            return _fifth(x, index + 1, first, second, third, x[index]);\\n        }\\n    }\\n    \\n    private boolean _fifth(int[] x, int index, int first, int second, int third, int fourth) {\\n        if (index >= x.length) {\\n            return false;\\n        }\\n        if (x[index] < third - first) {\\n            return _decrease(x, index + 1, fourth, x[index]);\\n        } else if (x[index] <= third) {\\n            return _decrease(x, index + 1, fourth - second, x[index]);\\n        } else {\\n            return _fifth(x, index + 1, second, third, fourth, x[index]);\\n        }\\n    }\\n    \\n    private boolean _decrease(int[] x, int index, int prevprev, int prev) {\\n        if (index >= x.length) {\\n            return false;\\n        }\\n        if (x[index] >= prevprev) {\\n            return true;\\n        }\\n        return _decrease(x, index + 1, prev, x[index]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean isSelfCrossing(int[] x) {\\n        if (x == null || x.length <= 3) {\\n            return false;\\n        }\\n        return _first(x, 0);\\n    }\\n    \\n    private boolean _first(int[] x, int index) {\\n        return index >= x.length - 3 ? false : _second(x, index + 1, x[index]);\\n    }\\n    \\n    private boolean _second(int[] x, int index, int first) {\\n        return index >= x.length - 2 ? false : _third(x, index + 1, first, x[index]);\\n    }\\n    \\n    private boolean _third(int[] x, int index, int first, int second) {\\n        if (index >= x.length - 1) {\\n            return false;\\n        }\\n        if (x[index] <= first) {\\n            return _decrease(x, index + 1, second, x[index]);\\n        } else {\\n            return _fourth(x, index + 1, first, second, x[index]);\\n        }\\n    }\\n    \\n    private boolean _fourth(int[] x, int index, int first, int second, int third) {\\n        if (index >= x.length) {\\n            return false;\\n        }\\n        if (x[index] < second) {\\n            return _decrease(x, index + 1, third, x[index]);\\n        } else if (x[index] == second) {\\n            return _decrease(x, index + 1, third - first, x[index]);\\n        } else {\\n            return _fifth(x, index + 1, first, second, third, x[index]);\\n        }\\n    }\\n    \\n    private boolean _fifth(int[] x, int index, int first, int second, int third, int fourth) {\\n        if (index >= x.length) {\\n            return false;\\n        }\\n        if (x[index] < third - first) {\\n            return _decrease(x, index + 1, fourth, x[index]);\\n        } else if (x[index] <= third) {\\n            return _decrease(x, index + 1, fourth - second, x[index]);\\n        } else {\\n            return _fifth(x, index + 1, second, third, fourth, x[index]);\\n        }\\n    }\\n    \\n    private boolean _decrease(int[] x, int index, int prevprev, int prev) {\\n        if (index >= x.length) {\\n            return false;\\n        }\\n        if (x[index] >= prevprev) {\\n            return true;\\n        }\\n        return _decrease(x, index + 1, prev, x[index]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1841091,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1776395,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1571599,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1571601,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2048068,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2033583,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1876347,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1759615,
                "content": [
                    {
                        "username": "SMYL",
                        "content": "How cruel of you to make the brute force solution able to past 29/30 testcases?!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It\\'s always like that, they only put the brutish tests in the end. "
                    },
                    {
                        "username": "WorldHello",
                        "content": "WARNING: If you see the solution to this problem, you can never unsee it for rest of your life!"
                    },
                    {
                        "username": "lcq_dev",
                        "content": "I feel this looks like a math problem instead of an algorithm problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't understand why leetcoders are so adamant about the fact that anything that involves math is not an algorithm.\nIt's an algorithm for which I could imagine many more relevant use cases in actual projects than most \"algorithmically correct\" problems (palindromes, I'm looking at you)\nIt involves no notion of geometry other than knowing your left, right, top and bottom.\nIt involves no notion of arithmetic more advanced than a modulo operation.\nIt would be a pretty lousy problem if given in a math class. I don;t see why it's a bad algo problem tho, figuring out the logic and the tests feels like something more relvant to actual coding than most problems I have solved here. I could definitely imagine having to work through similar logic when coding a little game for example (if you want a needlessly fancy way to know when you lose your game of snake, well, that's pretty much exactly what you need)"
                    },
                    {
                        "username": "mo10",
                        "content": "I was thinking an idea with arbitrary input for a long time, but nothing came out. Is that possible to develop a linear time and constant space solution if input can be negative??"
                    },
                    {
                        "username": "CuteTN",
                        "content": "The 29th testcase is brilliant \\uD83E\\uDEE0"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "You have to understand that these question, although seem hard at first, isn\\'t impossible. So there must be a trick/ repeating pattern considering it\\'s a math question and brute force is unacceptable.\\n\\nSo start figuring out in how many ways the lines will self cross, and you will be surprise to know, due to the spiral nature of movement, there are basically only 3 ways.\\n\\nIdentify them and code it out!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I actually really struggled but really enjoyed solving this one. My solution is a bit lenghtier (read dirtier) than what I saw posted in the solution tab, but at least it is crystal clear to me and quite satisfying!\nTbh tho, I would never have been able to solve this in interview conditions (took me much longer, and I probably couldn;t have figured out every step under pressure). \nLeetcode needs a new \"super hard\" category, cause that one really hits different than other hard ones"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            }
        ]
    }
]