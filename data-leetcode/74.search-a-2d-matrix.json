[
    {
        "title": "Search a 2D Matrix",
        "question_content": "You are given an m x n integer matrix matrix with the following two properties:\n\n\tEach row is sorted in non-decreasing order.\n\tThe first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.\n&nbsp;\nExample 1:\n\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\n\nExample 2:\n\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false\n\n&nbsp;\nConstraints:\n\n\tm == matrix.length\n\tn == matrix[i].length\n\t1 <= m, n <= 100\n\t-104 <= matrix[i][j], target <= 104",
        "solutions": [
            {
                "id": 26220,
                "title": "don-t-treat-it-as-a-2d-matrix-just-treat-it-as-a-sorted-list",
                "content": "Use binary search. \\n\\nn * m matrix convert to an array => matrix[x][y] => a[x * m + y]\\n\\nan array convert to n * m matrix => a[x] =>matrix[x / m][x % m];\\n\\n    class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int> > &matrix, int target) {\\n            int n = matrix.size();\\n            int m = matrix[0].size();\\n            int l = 0, r = m * n - 1;\\n            while (l != r){\\n                int mid = (l + r - 1) >> 1;\\n                if (matrix[mid / m][mid % m] < target)\\n                    l = mid + 1;\\n                else \\n                    r = mid;\\n            }\\n            return matrix[r / m][r % m] == target;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int> > &matrix, int target) {\\n            int n = matrix.size();\\n            int m = matrix[0].size();\\n            int l = 0, r = m * n - 1;\\n            while (l != r){\\n                int mid = (l + r - 1) >> 1;\\n                if (matrix[mid / m][mid % m] < target)\\n                    l = mid + 1;\\n                else \\n                    r = mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1895837,
                "title": "c-binary-search-tree-explained-with-img",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nIf closely analyze the given matrix, we can notice one interesting property (\\u256D\\u0CB0_\\u2022\\u0301): elements on the left are always smaller than the current element, and elements on the bottom are always greater. It reminds us of the Binary Search Tree, doesn\\'t it (\\u0E4F\\u0E47\\u0A9F\\u0AC4\\u25DF\\u0E4F\\u0E47 )? Just look at this matrix from this angle  and everything will become clear to you (our target, say, is 11):\\n\\n![image](https://assets.leetcode.com/users/images/f29529fe-2398-4919-a154-60f210d92d11_1648601421.8099654.jpeg)\\nWoooooow!!! \\u0669(\\u02CA\\u15DC\\u02CB*)\\u0648\\n\\nTime: **O(n)** - in the case we have just one row\\nSpace: **O(1)** - nothing stored\\n\\nRuntime: 3 ms, faster than **88.01%** of C++ online submissions for Search a 2D Matrix.\\nMemory Usage: 9.6 MB, less than **52.00%** of C++ online submissions for Search a 2D Matrix.\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size(),\\n\\t\\t\\tcols = matrix[0].size(),\\n            row = 0, col = cols - 1;\\n\\t\\t\\t\\n        while (row < rows && col > -1) {\\n            int cur = matrix[row][col];\\n            if (cur == target) return true;\\n            if (target > cur) row++;\\n            else col--;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size(),\\n\\t\\t\\tcols = matrix[0].size(),\\n            row = 0, col = cols - 1;\\n\\t\\t\\t\\n        while (row < rows && col > -1) {\\n            int cur = matrix[row][col];\\n            if (cur == target) return true;\\n            if (target > cur) row++;\\n            else col--;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26219,
                "title": "binary-search-on-an-ordered-matrix",
                "content": "\\t/**\\n\\t *  Do binary search in this \"ordered\" matrix\\n\\t */\\n\\tpublic boolean searchMatrix(int[][] matrix, int target) {\\n\\t\\t\\n\\t\\tint row_num = matrix.length;\\n\\t\\tint col_num = matrix[0].length;\\n\\t\\t\\n\\t\\tint begin = 0, end = row_num * col_num - 1;\\n\\t\\t\\n\\t\\twhile(begin <= end){\\n\\t\\t\\tint mid = (begin + end) / 2;\\n\\t\\t\\tint mid_value = matrix[mid/col_num][mid%col_num];\\n\\t\\t\\t\\n\\t\\t\\tif( mid_value == target){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\n\\t\\t\\t}else if(mid_value < target){\\n\\t\\t\\t\\t//Should move a bit further, otherwise dead loop.\\n\\t\\t\\t\\tbegin = mid+1;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tend = mid-1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [
                    "Matrix",
                    "Binary Tree"
                ],
                "code": "\\t/**\\n\\t *  Do binary search in this \"ordered\" matrix\\n\\t */\\n\\tpublic boolean searchMatrix(int[][] matrix, int target) {\\n\\t\\t\\n\\t\\tint row_num = matrix.length;\\n\\t\\tint col_num = matrix[0].length;\\n\\t\\t\\n\\t\\tint begin = 0, end = row_num * col_num - 1;\\n\\t\\t\\n\\t\\twhile(begin <= end){\\n\\t\\t\\tint mid = (begin + end) / 2;\\n\\t\\t\\tint mid_value = matrix[mid/col_num][mid%col_num];\\n\\t\\t\\t\\n\\t\\t\\tif( mid_value == target){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\n\\t\\t\\t}else if(mid_value < target){\\n\\t\\t\\t\\t//Should move a bit further, otherwise dead loop.\\n\\t\\t\\t\\tbegin = mid+1;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tend = mid-1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 26201,
                "title": "a-python-binary-search-solution-o-logn",
                "content": "It is basically an advanced version of the binary search\\n\\n    class Solution:\\n        # @param matrix, a list of lists of integers\\n        # @param target, an integer\\n        # @return a boolean\\n        # 8:21\\n        def searchMatrix(self, matrix, target):\\n            if not matrix or target is None:\\n                return False\\n    \\n            rows, cols = len(matrix), len(matrix[0])\\n            low, high = 0, rows * cols - 1\\n            \\n            while low <= high:\\n                mid = (low + high) / 2\\n                num = matrix[mid / cols][mid % cols]\\n    \\n                if num == target:\\n                    return True\\n                elif num < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            \\n            return False",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "It is basically an advanced version of the binary search\\n\\n    class Solution:\\n        # @param matrix, a list of lists of integers\\n        # @param target, an integer\\n        # @return a boolean\\n        # 8:21\\n        def searchMatrix(self, matrix, target):\\n            if not matrix or target is None:\\n                return False\\n    \\n            rows, cols = len(matrix), len(matrix[0])\\n            low, high = 0, rows * cols - 1\\n            \\n            while low <= high:\\n                mid = (low + high) / 2\\n                num = matrix[mid / cols][mid % cols]\\n    \\n                if num == target:\\n                    return True\\n                elif num < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            \\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 1895847,
                "title": "c-algorithm-binary-search-brute-force",
                "content": "# 74. Search a 2D Matrix\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Initution is to use matrix as an array and apply Binary Search on it as the array is sorted ,\\n   althouugh we can find target just by iterating (bruteforce).\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**APPROACH 1 BRUTE FORCE**\\n* **Iterate** each **row** and **column** in **search of target**.\\n* If **found return true** or return false.\\n\\n\\n**Complexity Analysis**\\n\\n* **Time Complexity: O(m*n)**\\n\\n* **Space Complexity: O(1)**\\n\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\t\\t// running a forloop till size of matrix\\n        for(int i  = 0; i<matrix.size(); ++i)\\n        {\\n\\t\\t// nested for for ietrating each row element\\n            for(int j = 0; j<matrix[0].size(); ++j)\\n            {\\n\\t\\t\\t\\t// if found return true\\n                if(matrix[i][j] == target)\\n                    return true;\\n            }\\n        }\\n\\t\\t// after traversal if not found\\n\\t\\t// return false\\n        return false;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```\\n\\n**APPROACH 2 BINARY SEARCH**\\n\\n* The problem statement states that the **values of the last col of the ith row is greater than the first col of (i+1)th row**. Also, **each row is sorted.**\\n* This means that, if **we linearly arrange the elements of each row**, we will have a **sorted array**. So we **can now perform a binary search over it.**\\n* How will the **matrix behave like an array without actually creating an auxiliary array?**\\n* It could be achieved by the following formula :\\n* A n * m matrix converted into an array: **matrix[x][y] : a[x * m + y]**\\n* An array can be converted into n * m matrix: **a[x] : matrix[x / m][x % m]**\\n\\n**Solution Steps**\\n\\n* **Operate the matrix as an array using the above formula**\\n* **Perform a binary search** for the target element over the matrix\\n\\n**Complexity Analysis**\\n\\n**Time Complexity**: O(log(m*n)) =**O(log(m) + log(n))**\\n\\n**Space Complexity**: **O(1)**\\n``` ```\\n\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n\\t\\t// if matrix have 0 rows or 0 colums\\n        if(n == 0 || m == 0)\\n            return false;\\n        \\n\\t\\t// treating matrix as array just taking care of endices\\n\\t\\t// [0..n*m]\\n        int start = 0, end = m*n - 1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end - start) / 2;\\n\\t\\t\\t// a[x] : matrix[x / m][x % m] formulae\\n            int ind = matrix[mid/m][mid%m];\\n            if (target == ind)\\n                return true;\\n\\t\\t\\t// left half\\n            else if(target < ind)\\n                end = mid - 1;\\n            else\\n\\t\\t\\t// right half\\n                start = mid + 1;       \\n        }\\n        return false;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```\\n**Another appraoch**\\n* **Traverse using while loop** till **i is less than n and j is greater than equal to zero.**\\n* if **mat[i][j] == 0 return true;**\\n* if **greater than it means** the **element exists in another row** therefore **increment i.**\\n* **if less than decrement j** because this **means element exist in that row only.**\\n* at end if **not found return false.**\\n\\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int i = 0;\\n        int j = matrix[0].size() - 1;\\n        \\n        while(i < n && j >= 0)\\n        {\\n            if(matrix[i][j] == target)\\n                return true;\\n            if(target < matrix[i][j] )\\n                --j;\\n            else\\n                ++i;\\n        }\\n        return false;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Initution is to use matrix as an array and apply Binary Search on it as the array is sorted ,\\n   althouugh we can find target just by iterating (bruteforce).\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n```\\n\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\t\\t// running a forloop till size of matrix\\n        for(int i  = 0; i<matrix.size(); ++i)\\n        {\\n\\t\\t// nested for for ietrating each row element\\n            for(int j = 0; j<matrix[0].size(); ++j)\\n            {\\n\\t\\t\\t\\t// if found return true\\n                if(matrix[i][j] == target)\\n                    return true;\\n            }\\n        }\\n\\t\\t// after traversal if not found\\n\\t\\t// return false\\n        return false;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```\n``` ```\n```\\n\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n\\t\\t// if matrix have 0 rows or 0 colums\\n        if(n == 0 || m == 0)\\n            return false;\\n        \\n\\t\\t// treating matrix as array just taking care of endices\\n\\t\\t// [0..n*m]\\n        int start = 0, end = m*n - 1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end - start) / 2;\\n\\t\\t\\t// a[x] : matrix[x / m][x % m] formulae\\n            int ind = matrix[mid/m][mid%m];\\n            if (target == ind)\\n                return true;\\n\\t\\t\\t// left half\\n            else if(target < ind)\\n                end = mid - 1;\\n            else\\n\\t\\t\\t// right half\\n                start = mid + 1;       \\n        }\\n        return false;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int i = 0;\\n        int j = matrix[0].size() - 1;\\n        \\n        while(i < n && j >= 0)\\n        {\\n            if(matrix[i][j] == target)\\n                return true;\\n            if(target < matrix[i][j] )\\n                --j;\\n            else\\n                ++i;\\n        }\\n        return false;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896821,
                "title": "python-simple-binary-search-explained",
                "content": "What we have in this problem is matrix, which is sorted and what we use to find element in sorted structure? Correct, this is binary search. Imagine, that we have matrix\\n\\n`10  11 12 13`\\n`14 15 16 17`\\n`18 19 20 21`\\n\\nLet us flatten this matrix, so now we have `10 11 12 13 14 15 16 17 18 19 20 21` and do binary search in this list. However if you do it, we will have `O(mn)` complexity, so we will use **virtual** flatten: we do not do it for all matrix, but only for elements we need:  if we need element number `i` from our flattened list, it coresponds to element `matrix[i//m][i%m]` in our matrix.\\n\\n**Complexity**: time complexity is `O(log mn)`, space complexity is `O(1)`.\\n\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        if not matrix or not matrix[0]: return False\\n        m, n = len(matrix[0]), len(matrix)\\n        beg, end = 0, m*n - 1\\n        while beg < end:\\n            mid = (beg + end)//2\\n            if matrix[mid//m][mid%m] < target:\\n                beg = mid + 1\\n            else:\\n                end = mid\\n        return matrix[beg//m][beg%m] == target\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        if not matrix or not matrix[0]: return False\\n        m, n = len(matrix[0]), len(matrix)\\n        beg, end = 0, m*n - 1\\n        while beg < end:\\n            mid = (beg + end)//2\\n            if matrix[mid//m][mid%m] < target:\\n                beg = mid + 1\\n            else:\\n                end = mid\\n        return matrix[beg//m][beg%m] == target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26292,
                "title": "java-clear-solution",
                "content": "  The basic idea is from right corner, if the current number greater than target col - 1 in same row, else if the current number less than target, row + 1 in same column, finally if they are same, we find it, and return return.\\n\\n      public boolean searchMatrix(int[][] matrix, int target) {\\n                int i = 0, j = matrix[0].length - 1;\\n                while (i < matrix.length && j >= 0) {\\n                        if (matrix[i][j] == target) {\\n                            return true;\\n                        } else if (matrix[i][j] > target) {\\n                            j--;\\n                        } else {\\n                            i++;\\n                        }\\n                    }\\n                \\n                return false;\\n            }",
                "solutionTags": [
                    "Java"
                ],
                "code": "  The basic idea is from right corner, if the current number greater than target col - 1 in same row, else if the current number less than target, row + 1 in same column, finally if they are same, we find it, and return return.\\n\\n      public boolean searchMatrix(int[][] matrix, int target) {\\n                int i = 0, j = matrix[0].length - 1;\\n                while (i < matrix.length && j >= 0) {\\n                        if (matrix[i][j] == target) {\\n                            return true;\\n                        } else if (matrix[i][j] > target) {\\n                            j--;\\n                        } else {\\n                            i++;\\n                        }\\n                    }\\n                \\n                return false;\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 26226,
                "title": "c-12ms-o-log-mn-no-library-functions-treat-matrix-as-an-array",
                "content": "    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        // treat the matrix as an array, just taking care of indices\\n        // [0..n*m]\\n        // (row, col) -> row*n + col\\n        // i -> [i/n][i%n]\\n        if(matrix.empty() || matrix[0].empty())\\n        {\\n            return false;\\n        }\\n        int m = matrix.size(), n = matrix[0].size();\\n        int start = 0, end = m*n - 1;\\n        while(start <= end)\\n        {\\n            int mid = start + (end - start)/2;\\n            int e = matrix[mid/n][mid%n];\\n            if(target < e)\\n            {\\n                end = mid - 1;\\n            }\\n            else if(target > e)\\n            {\\n                start = mid + 1;\\n            }\\n            else\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        // treat the matrix as an array, just taking care of indices\\n        // [0..n*m]\\n        // (row, col) -> row*n + col\\n        // i -> [i/n][i%n]\\n        if(matrix.empty() || matrix[0].empty())\\n        {\\n            return false;\\n        }\\n        int m = matrix.size(), n = matrix[0].size();\\n        int start = 0, end = m*n - 1;\\n        while(start <= end)\\n        {\\n            int mid = start + (end - start)/2;\\n            int e = matrix[mid/n][mid%n];\\n            if(target < e)\\n            {\\n                end = mid - 1;\\n            }\\n            else if(target > e)\\n            {\\n                start = mid + 1;\\n            }\\n            else\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3874071,
                "title": "100-binary-search-video-simple-solution",
                "content": "# Problem Understanding\\nThe task is to find a target integer in a 2D matrix with the following properties: \\n1. Each row is sorted in non-decreasing order.\\n2. The first integer of each row is greater than the last integer of the previous row.\\n\\nThe challenge is to determine if the target integer exists within the matrix.\\n\\n# Approach\\nGiven the problem, it may be tempting to perform a linear search through the entire matrix, but this would result in a time complexity of $$O(m \\\\times n)$$, which is not acceptable given the problem\\'s constraint of $$O(\\\\log(m \\\\times n))$$.\\n\\nInstead, we can leverage the fact that the matrix is sorted both row-wise and column-wise, and apply a binary search to find the target.\\n\\n# Live Coding & Explenation\\nhttps://youtu.be/ePF8QegEy-8\\n\\n## Treating the Matrix as a 1-Dimensional Array\\nTo apply binary search, we need a one-dimensional array. We can treat our 2-D matrix as a one-dimensional array because of the matrix\\'s sorted property. The first integer of each row is greater than the last integer of the previous row, so we can think of the rows as being appended one after the other to form a single sorted array.\\n\\n## Binary Search\\nBinary search is a search algorithm that finds the position of a target value within a sorted array. It compares the target value to the middle element of the array. If they are not equal, the half in which the target cannot lie is eliminated, and the search continues on the remaining half until it is successful or the remaining half is empty.\\n\\n## Initialization\\nBefore we start the binary search, we need to initialize two pointers:\\n\\n1. `left` - This represents the start of the array. We set this to 0 (the index of the first element).\\n2. `right` - This represents the end of the array. We set this to `m * n - 1` (the index of the last element), where `m` and `n` are the number of rows and columns in the matrix, respectively.\\n\\n## Iterative Binary Search\\nWe perform a binary search iteratively within a while loop until `left` exceeds `right`. In each iteration, we calculate the midpoint between `left` and `right`.\\n\\nTo get the row and column of the midpoint in the matrix, we use the `divmod` function with `mid` and `n`. The `divmod` function takes two numbers and returns a pair of numbers (a tuple) consisting of their quotient and remainder.\\n\\nWe then compare the value at the midpoint with the target:\\n\\n1. If the midpoint value is equal to the target, we have found the target in the matrix, and we return `True`.\\n2. If the midpoint value is less than the target, this means the target must be in the right half of the array. So, we adjust `left` to be `mid + 1`.\\n3. If the midpoint value is greater than the target, this means the target must be in the left half of the array. So, we adjust `right` to be `mid - 1`.\\n\\nIf we exit the while loop, that means we did not find the target in the matrix, so we return `False`.\\n\\n# Complexity\\n## Time Complexity\\nThe time complexity is $$O(\\\\log(m \\\\times n))$$, since we\\'re effectively performing a binary search over the $$m \\\\times n$$ elements of the matrix.\\n\\n## Space Complexity\\nThe space complexity is $$O(1)$$ because we only use a constant amount of space to store our variables (`left`, `right`, `mid`, `mid_value`), regardless of the size of the input matrix.\\n\\n# Performance\\nThe performance of this solution is optimal given the problem constraints. Since the matrix is sorted and the problem requires us to find an element, binary search is the best possible approach.\\n\\nCertainly, here\\'s the table sorted by runtime (ms) and then by memory usage (MB):\\n\\n| Programming Language | Runtime (ms) | Beats (%) | Memory (MB) | Beats (%) |\\n|---|---|---|---|---|\\n| Rust | 0 | 100 | 2.2 | 28.37 |\\n| Java | 0 | 100 | 41.6 | 9.3 |\\n| C++ | 3 | 82.89 | 9.5 | 19.73 |\\n| Go | 3 | 58.16 | 2.7 | 98.33 |\\n| JavaScript | 48 | 92.89 | 42.3 | 28.19 |\\n| Python3 | 49 | 90.75 | 16.8 | 64.57 |\\n| C# | 82 | 99.1 | 40.9 | 35.48 |\\n\\n![perf-74.png](https://assets.leetcode.com/users/images/e5390578-f682-482d-8b85-1af215ef54bc_1691368418.9404237.png)\\n\\n\\n# Code\\n```Python []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix:\\n            return False\\n        m, n = len(matrix), len(matrix[0])\\n        left, right = 0, m * n - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            mid_row, mid_col = divmod(mid, n)\\n\\n            if matrix[mid_row][mid_col] == target:\\n                return True\\n            elif matrix[mid_row][mid_col] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return False\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int left = 0, right = m * n - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int mid_val = matrix[mid / n][mid % n];\\n\\n            if (mid_val == target)\\n                return true;\\n            else if (mid_val < target)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return false;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int left = 0, right = m * n - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int mid_val = matrix[mid / n][mid % n];\\n\\n            if (mid_val == target)\\n                return true;\\n            else if (mid_val < target)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function(matrix, target) {\\n    let m = matrix.length;\\n    let n = matrix[0].length;\\n    let left = 0, right = m * n - 1;\\n\\n    while (left <= right) {\\n        let mid = Math.floor((left + right) / 2);\\n        let mid_val = matrix[Math.floor(mid / n)][mid % n];\\n\\n        if (mid_val === target)\\n            return true;\\n        else if (mid_val < target)\\n            left = mid + 1;\\n        else\\n            right = mid - 1;\\n    }\\n    return false;\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public bool SearchMatrix(int[][] matrix, int target) {\\n        int m = matrix.Length;\\n        int n = matrix[0].Length;\\n        int left = 0, right = m * n - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int mid_val = matrix[mid / n][mid % n];\\n\\n            if (mid_val == target)\\n                return true;\\n            else if (mid_val < target)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` Go []\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n    m := len(matrix)\\n    n := len(matrix[0])\\n    left, right := 0, m*n-1\\n\\n    for left <= right {\\n        mid := left + (right-left)/2\\n        mid_val := matrix[mid/n][mid%n]\\n\\n        if mid_val == target {\\n            return true\\n        } else if mid_val < target {\\n            left = mid + 1\\n        } else {\\n            right = mid - 1\\n        }\\n    }\\n    return false\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let rows = matrix.len() as i32;\\n        let cols = matrix[0].len() as i32;\\n\\n        let mut start = 0;\\n        let mut end = rows * cols - 1;\\n\\n        while start <= end {\\n            let mid = start + (end - start) / 2;\\n            let mid_value = matrix[(mid / cols) as usize][(mid % cols) as usize];\\n\\n            if mid_value == target {\\n                return true;\\n            } else if mid_value < target {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n\\n        false\\n    }\\n}\\n```\\n\\n# Live Coding + Explenation in Go\\nhttps://youtu.be/edGrFBOtnc4\\n\\nI hope you find this solution helpful in understanding how to solve the \"Search a 2D Matrix\" problem. If you have any further questions or need additional clarifications, please don\\'t hesitate to ask. If you understood the solution and found it beneficial, please consider giving it an upvote. Happy coding, and may your coding journey be filled with success and satisfaction! \\uD83D\\uDE80\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```Python []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix:\\n            return False\\n        m, n = len(matrix), len(matrix[0])\\n        left, right = 0, m * n - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            mid_row, mid_col = divmod(mid, n)\\n\\n            if matrix[mid_row][mid_col] == target:\\n                return True\\n            elif matrix[mid_row][mid_col] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return False\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int left = 0, right = m * n - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int mid_val = matrix[mid / n][mid % n];\\n\\n            if (mid_val == target)\\n                return true;\\n            else if (mid_val < target)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return false;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int left = 0, right = m * n - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int mid_val = matrix[mid / n][mid % n];\\n\\n            if (mid_val == target)\\n                return true;\\n            else if (mid_val < target)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return false;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function(matrix, target) {\\n    let m = matrix.length;\\n    let n = matrix[0].length;\\n    let left = 0, right = m * n - 1;\\n\\n    while (left <= right) {\\n        let mid = Math.floor((left + right) / 2);\\n        let mid_val = matrix[Math.floor(mid / n)][mid % n];\\n\\n        if (mid_val === target)\\n            return true;\\n        else if (mid_val < target)\\n            left = mid + 1;\\n        else\\n            right = mid - 1;\\n    }\\n    return false;\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public bool SearchMatrix(int[][] matrix, int target) {\\n        int m = matrix.Length;\\n        int n = matrix[0].Length;\\n        int left = 0, right = m * n - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int mid_val = matrix[mid / n][mid % n];\\n\\n            if (mid_val == target)\\n                return true;\\n            else if (mid_val < target)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return false;\\n    }\\n}\\n```\n``` Go []\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n    m := len(matrix)\\n    n := len(matrix[0])\\n    left, right := 0, m*n-1\\n\\n    for left <= right {\\n        mid := left + (right-left)/2\\n        mid_val := matrix[mid/n][mid%n]\\n\\n        if mid_val == target {\\n            return true\\n        } else if mid_val < target {\\n            left = mid + 1\\n        } else {\\n            right = mid - 1\\n        }\\n    }\\n    return false\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let rows = matrix.len() as i32;\\n        let cols = matrix[0].len() as i32;\\n\\n        let mut start = 0;\\n        let mut end = rows * cols - 1;\\n\\n        while start <= end {\\n            let mid = start + (end - start) / 2;\\n            let mid_value = matrix[(mid / cols) as usize][(mid % cols) as usize];\\n\\n            if mid_value == target {\\n                return true;\\n            } else if mid_value < target {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n\\n        false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896422,
                "title": "java-0ms-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n      int i = 0, j = matrix[0].length - 1;\\n      while(i < matrix.length && j >= 0) {\\n        if(matrix[i][j] == target)\\n          return true;\\n        else if(matrix[i][j] > target)\\n          j --;\\n        else if(matrix[i][j] < target)\\n          i ++;\\n      }\\n      return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Matrix",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n      int i = 0, j = matrix[0].length - 1;\\n      while(i < matrix.length && j >= 0) {\\n        if(matrix[i][j] == target)\\n          return true;\\n        else if(matrix[i][j] > target)\\n          j --;\\n        else if(matrix[i][j] < target)\\n          i ++;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1895915,
                "title": "python-3-short-and-readable-solutions",
                "content": "### Introduction\\n\\nThis post presents 3 of the most common solutions to this problem, written in a concise but readable manner. If you want the most optimised solution, please refer to solution 3.\\n\\n---\\n\\n### Solution 1: Brute Force\\n\\nIgnoring the sorted property of `matrix`, the problem boils down to \"Is `target` in `matrix`?\". Hence, we just need to loop through `matrix` to find `target`.\\n\\n```python\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        return any(target in row for row in matrix)\\n```\\n\\n**TC: O(mn)**, where `m` is the number of rows and `n` is the number of columns in `matrix`.\\n**SC: O(1)**.\\n\\n---\\n\\n### Solution 2: 1D Brute Force\\n\\nThis solution is the same as last solution, except that taking the sorted property of `matrix` into account, the solution searches for the appropriate row first, before finding `target` in that row.\\n\\n```python\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for row in matrix:\\n            if row[-1] >= target:\\n                return target in row\\n        return False\\n```\\n\\n**TC: O(m+n)**, since the nested `target in row` check is only performed once in an otherwise linear search.\\n**SC: O(1)**.\\n\\n---\\n\\n### Solution 3: Binary Search\\n\\nThe most common and efficient solution there is, due to the sorted property of `matrix`. There are many ways to do it - treating `matrix` as a 1D array seems to be the most common.\\n\\nI\\'d like to present a concise solution using [Python\\'s bisect library](https://docs.python.org/3/library/bisect.html) that involves binary searching for the row first, then for the column. Note that if a suitable row is indeed found, `target <= matrix[row][-1]` is guaranteed, and thus the output of the `bisect_left` function is guaranteed to be within `[0, len(matrix[0])-1]` (credits to [@dibery](https://leetcode.com/dibery/)).\\n\\n```python\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        r = bisect_left(matrix, target, key=lambda row: row[-1])  # or key=itemgetter(-1)\\n        return r < len(matrix) and matrix[r][bisect_left(matrix[r], target)] == target\\n```\\n\\nAn alternative approach is to binary search across `matrix` in its entirety, as you would a 1D array.\\n\\n```python\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n = len(matrix[0])\\n        def get(idx: int) -> int:\\n            r, c = divmod(idx, n)\\n            return matrix[r][c]\\n        return get(bisect_left(range(len(matrix)*n-1), target, key=get)) == target\\n```\\n\\n**TC: O(logm+logn) = O(log(mn))**.\\n**SC: O(1)**.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        return any(target in row for row in matrix)\\n```\n```python\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for row in matrix:\\n            if row[-1] >= target:\\n                return target in row\\n        return False\\n```\n```python\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        r = bisect_left(matrix, target, key=lambda row: row[-1])  # or key=itemgetter(-1)\\n        return r < len(matrix) and matrix[r][bisect_left(matrix[r], target)] == target\\n```\n```python\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n = len(matrix[0])\\n        def get(idx: int) -> int:\\n            r, c = divmod(idx, n)\\n            return matrix[r][c]\\n        return get(bisect_left(range(len(matrix)*n-1), target, key=get)) == target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897152,
                "title": "c-binary-search-solution-100-time-40-space",
                "content": "Alright: all the elements are sorted and we need to try and find a specific element, right? That is a no-brainer: we need to go with a binary search approach.\\n\\nProvided neither the matrix or the rows are empty, since a nice problem like this needs to get burdened by pointless requirements that boil down to the chore of writing an extra line to remove silly edge cases <_<\\n\\nNow, the relatively tricky part here is that we do not have all of them in a single flat container, but in a matrix. We will actually then want to do 2 binary searches: one to find the row to be searched, one to search it directly.\\n\\nTo do so, I declared 4 variables:\\n* `row`, meant to store which row will be searched, once we found one;\\n* `l`, `r` will store the extremes of our search, initialised to `0` and `m.size() - 1`, respectively;\\n* `mid` will store the on going average of `l` and `r`.\\n\\nFirst round of binary search:\\n* we go on until `l < r` [note that the first one has to be a strict comparison, unlike for the second search];\\n* at each iteration we will compute `mid` as `(l + r) / 2`;\\n* we will then compare and find that if `t` is bigger than the last element of the row we are checking (`m[mid].back() < t`), it is time to raise `l` up to `mid + 1` and loop again;\\n* specularly, if `t` is smaller than the first element of the row we are checking (`m[mid][0] > t`), it is time to lower `r` down to `mid - 1` and loop again;\\n* finally, if neithere condition is correct, we it means that `m[mid][0] <= t && m[mid].back() >= t`, which implies we are already checking the right row, so we just assign `l = mid` and `break` out of the loop.\\n\\nBe as it is, once we are done iterating, we will store the value of the correct row to search in `row`, reset `l` and `r` and move on with a similar logic to parse this time on a more traditional way if the element is in the row or not: a match will have us return `true`.\\n\\nIf we exit the loop without any joy, we return `false`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>> &m, int t) {\\n        // pointless edge case we still have to consider\\n\\t\\tif (!m.size() || !m[0].size()) return false;\\n        // support variables\\n\\t\\tint row, l = 0, r = m.size() - 1, mid;\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            // moving l up if needed\\n            if (m[mid].back() < t) l = mid + 1;\\n            // moving r down if needed\\n            else if (m[mid][0] > t) r = mid - 1;\\n            // we found our row!\\n            else {\\n                l = mid;\\n                break;\\n            };\\n        }\\n        // storing the value of the new found row\\n        row = l;\\n        // resetting l and r to run a binary search on the rows\\n        l = 0;\\n        r = m[0].size() - 1;\\n        while (l <= r) {\\n            mid = (l + r) / 2;\\n            // moving l up if needed\\n            if (m[row][mid] < t) l = mid + 1;\\n            // moving r down if needed\\n            else if (m[row][mid] > t) r = mid - 1;\\n            // we found our value!\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>> &m, int t) {\\n        // pointless edge case we still have to consider\\n\\t\\tif (!m.size() || !m[0].size()) return false;\\n        // support variables\\n\\t\\tint row, l = 0, r = m.size() - 1, mid;\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            // moving l up if needed\\n            if (m[mid].back() < t) l = mid + 1;\\n            // moving r down if needed\\n            else if (m[mid][0] > t) r = mid - 1;\\n            // we found our row!\\n            else {\\n                l = mid;\\n                break;\\n            };\\n        }\\n        // storing the value of the new found row\\n        row = l;\\n        // resetting l and r to run a binary search on the rows\\n        l = 0;\\n        r = m[0].size() - 1;\\n        while (l <= r) {\\n            mid = (l + r) / 2;\\n            // moving l up if needed\\n            if (m[row][mid] < t) l = mid + 1;\\n            // moving r down if needed\\n            else if (m[row][mid] > t) r = mid - 1;\\n            // we found our value!\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26248,
                "title": "6-12-lines-o-log-m-log-n-myself-library",
                "content": "I have two solutions, one without and one with using the library. Both have runtime O(log(m) + log(n)), or in other words, O(log(mn)).\\n\\n---\\n**Solution 1: *One Binary Search*** (48 ms, 12 lines)\\n\\nHere I treat the matrix like a single big list of length m*n and use a simple binary search. I only have to convert the list indexes to matrix indexes on the fly.\\n\\n    def searchMatrix(self, matrix, target):\\n        n = len(matrix[0])\\n        lo, hi = 0, len(matrix) * n\\n        while lo < hi:\\n            mid = (lo + hi) / 2\\n            x = matrix[mid/n][mid%n]\\n            if x < target:\\n                lo = mid + 1\\n            elif x > target:\\n                hi = mid\\n            else:\\n                return True\\n        return False\\n\\n---\\n**Solution 2: *Using the library*** (48 ms, 6 lines)\\n\\nIf there were a library function doing the 2D search, it would be boring, but there isn't. So it's still a little challenge to figure out how to use the 1D functions that *are* there. Here I use `bisect` to (approximately) find the candidate row and then `bisect_left` to find the candidate cell in that row.\\n\\n    def searchMatrix(self, matrix, target):\\n        i = bisect.bisect(matrix, [target])\\n        if i < len(matrix) and matrix[i][0] == target:\\n            return True\\n        row = matrix[i-1]\\n        j = bisect.bisect_left(row, target)\\n        return j < len(row) and row[j] == target",
                "solutionTags": [
                    "Python"
                ],
                "code": "I have two solutions, one without and one with using the library. Both have runtime O(log(m) + log(n)), or in other words, O(log(mn)).\\n\\n---\\n**Solution 1: *One Binary Search*** (48 ms, 12 lines)\\n\\nHere I treat the matrix like a single big list of length m*n and use a simple binary search. I only have to convert the list indexes to matrix indexes on the fly.\\n\\n    def searchMatrix(self, matrix, target):\\n        n = len(matrix[0])\\n        lo, hi = 0, len(matrix) * n\\n        while lo < hi:\\n            mid = (lo + hi) / 2\\n            x = matrix[mid/n][mid%n]\\n            if x < target:\\n                lo = mid + 1\\n            elif x > target:\\n                hi = mid\\n            else:\\n                return True\\n        return False\\n\\n---\\n**Solution 2: *Using the library*** (48 ms, 6 lines)\\n\\nIf there were a library function doing the 2D search, it would be boring, but there isn't. So it's still a little challenge to figure out how to use the 1D functions that *are* there. Here I use `bisect` to (approximately) find the candidate row and then `bisect_left` to find the candidate cell in that row.\\n\\n    def searchMatrix(self, matrix, target):\\n        i = bisect.bisect(matrix, [target])\\n        if i < len(matrix) and matrix[i][0] == target:\\n            return True\\n        row = matrix[i-1]\\n        j = bisect.bisect_left(row, target)\\n        return j < len(row) and row[j] == target",
                "codeTag": "Python3"
            },
            {
                "id": 26279,
                "title": "java-o-logm-logn-solution",
                "content": "```\\n//O(log(m*n))\\n    public boolean searchMatrix(int[][] matrix, int target){\\n        if(matrix.length == 0) return false;\\n        int top = 0;\\n        int down = matrix.length - 1;\\n        int col = matrix[0].length - 1;\\n        while(top <= down){\\n            int mid = (top + down) / 2;\\n            //it takes O(logM) to find the row that has target\\n            if(matrix[mid][0] <= target && matrix[mid][col] >= target){\\n                return searchRow(matrix,mid,target); //O(logN)\\n            }\\n            if(matrix[mid][col] < target){\\n                top = mid + 1;\\n            }\\n            if(matrix[mid][0] > target){\\n                down = mid -1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean searchRow(int[][] matrix, int rowIndex, int target){\\n        int left = 0;\\n        int right = matrix[rowIndex].length - 1;\\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            if(matrix[rowIndex][mid] < target){\\n                left = mid + 1;\\n            }else if(matrix[rowIndex][mid] > target){\\n                right = mid - 1;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n//O(log(m*n))\\n    public boolean searchMatrix(int[][] matrix, int target){\\n        if(matrix.length == 0) return false;\\n        int top = 0;\\n        int down = matrix.length - 1;\\n        int col = matrix[0].length - 1;\\n        while(top <= down){\\n            int mid = (top + down) / 2;\\n            //it takes O(logM) to find the row that has target\\n            if(matrix[mid][0] <= target && matrix[mid][col] >= target){\\n                return searchRow(matrix,mid,target); //O(logN)\\n            }\\n            if(matrix[mid][col] < target){\\n                top = mid + 1;\\n            }\\n            if(matrix[mid][0] > target){\\n                down = mid -1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean searchRow(int[][] matrix, int rowIndex, int target){\\n        int left = 0;\\n        int right = matrix[rowIndex].length - 1;\\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            if(matrix[rowIndex][mid] < target){\\n                left = mid + 1;\\n            }else if(matrix[rowIndex][mid] > target){\\n                right = mid - 1;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133252,
                "title": "simple-javascript-solution",
                "content": "Search from top right corner\\nTime complexity O(m + n)\\n```js\\nfunction searchMatrix(matrix, target) {\\n  if (!matrix.length || !matrix[0].length) return false;\\n\\n  let row = 0;\\n  let col = matrix[0].length - 1;\\n\\n  while (col >= 0 && row <= matrix.length - 1) {\\n    if (matrix[row][col] === target) return true;\\n    else if (matrix[row][col] > target) col--;\\n    else if (matrix[row][col] < target) row++;\\n  }\\n\\n  return false;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction searchMatrix(matrix, target) {\\n  if (!matrix.length || !matrix[0].length) return false;\\n\\n  let row = 0;\\n  let col = matrix[0].length - 1;\\n\\n  while (col >= 0 && row <= matrix.length - 1) {\\n    if (matrix[row][col] === target) return true;\\n    else if (matrix[row][col] > target) col--;\\n    else if (matrix[row][col] < target) row++;\\n  }\\n\\n  return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3321240,
                "title": "binary-search-logic-easy",
                "content": "\\n# Binary Search Approach---->O(LogN) \\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> \\n      row,col=len(matrix),len(matrix[0])\\n        left,right=0,row*col-1\\n        while left<=right:\\n            mid=(left+right)//2\\n            num=matrix[mid//col][mid%col]\\n            if num==target:\\n                return True\\n            if num>target:\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return False\\n```\\n# Binary Search Approach---->O(N+LogN)\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        list1=[]\\n        for row in matrix:\\n            if row[-1]>=target:\\n                list1=row\\n                break\\n        left,right=0,len(list1)-1\\n        while left<=right:\\n            mid=(right+left)//2\\n            if list1[mid]==target:\\n                return True\\n            elif list1[mid]>target:\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return False\\n    //please upvote me it would encourage me alot\\n                \\n```\\n# 3 Lines Of Code ---->O(N^2)\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for row in matrix:\\n            if row[-1] >= target:\\n                return target in row\\n\\n# please upvote me it would encourage me alot\\n```\\n# please upvote me it would encourage me alot\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> \\n      row,col=len(matrix),len(matrix[0])\\n        left,right=0,row*col-1\\n        while left<=right:\\n            mid=(left+right)//2\\n            num=matrix[mid//col][mid%col]\\n            if num==target:\\n                return True\\n            if num>target:\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return False\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        list1=[]\\n        for row in matrix:\\n            if row[-1]>=target:\\n                list1=row\\n                break\\n        left,right=0,len(list1)-1\\n        while left<=right:\\n            mid=(right+left)//2\\n            if list1[mid]==target:\\n                return True\\n            elif list1[mid]>target:\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return False\\n    //please upvote me it would encourage me alot\\n                \\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for row in matrix:\\n            if row[-1] >= target:\\n                return target in row\\n\\n# please upvote me it would encourage me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511703,
                "title": "java-tc-o-log-r-c-sc-o-1-optimized-binary-search-solution",
                "content": "```java\\n/**\\n * Optimized binary search solution\\n *\\n * Time Complexity: O(log(R * C))\\n *\\n * Space Complexity: O(1)\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n\\n        int cols = matrix[0].length;\\n        int start = 0;\\n        int end = matrix.length * cols - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            int r = mid / cols;\\n            int c = mid % cols;\\n            if (target == matrix[r][c]) {\\n                return true;\\n            }\\n            if (target < matrix[r][c]) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Search a 2D Matrix question on LeetCode:\\n- [240. Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/discuss/1513112/Java-or-TC:-O(R+C)-or-SC:-O(1)-or-Optimal-solution-using-Elimination-Strategy)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Optimized binary search solution\\n *\\n * Time Complexity: O(log(R * C))\\n *\\n * Space Complexity: O(1)\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n\\n        int cols = matrix[0].length;\\n        int start = 0;\\n        int end = matrix.length * cols - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            int r = mid / cols;\\n            int c = mid % cols;\\n            if (target == matrix[r][c]) {\\n                return true;\\n            }\\n            if (target < matrix[r][c]) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26215,
                "title": "an-easy-solution-in-java",
                "content": "    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n        int row = 0;\\n        int col = matrix[0].length - 1;\\n        while (row < matrix.length && col >= 0) {\\n            if (matrix[row][col] == target) {\\n                return true;\\n            } else if (matrix[row][col] < target) {\\n                row++;\\n            } else {\\n                col--;\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n        int row = 0;\\n        int col = matrix[0].length - 1;\\n        while (row < matrix.length && col >= 0) {\\n            if (matrix[row][col] == target) {\\n                return true;\\n            } else if (matrix[row][col] < target) {\\n                row++;\\n            } else {\\n                col--;\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 351404,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if len(matrix) == 0:\\n            return False\\n        \\n        row, col = 0, len(matrix[0]) - 1\\n        \\n        while row < len(matrix) and col >= 0:\\n            if matrix[row][col] == target: return True\\n            elif matrix[row][col] < target: row += 1\\n            elif matrix[row][col] > target: col -= 1\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if len(matrix) == 0:\\n            return False\\n        \\n        row, col = 0, len(matrix[0]) - 1\\n        \\n        while row < len(matrix) and col >= 0:\\n            if matrix[row][col] == target: return True\\n            elif matrix[row][col] < target: row += 1\\n            elif matrix[row][col] > target: col -= 1\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425649,
                "title": "4-solutions-brute-force-o-mn-to-optimal-o-log-mn",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\n\\n//** Brute force - O(mn)**\\nvar searchMatrix = function(matrix, target) {\\n    for(let i = 0; i < matrix.length; i++) {\\n        for(let j = 0; j < matrix[0].length; j++) {\\n            if(matrix[i][j] === target) return true\\n        }\\n    }\\n    return false\\n };\\n\\n\\n// **Binary search in each row - O(mlog n)**\\nvar searchMatrix = function(matrix, target) {\\n    for(let i = 0; i < matrix.length; i++) {\\n        let start = 0, end = matrix[0].length - 1\\n\\n        while(start <= end) {\\n            let mid = Math.floor((start + end) / 2)\\n            if(matrix[i][mid] === target) return true\\n            \\n            if(matrix[i][mid] > target) end = mid - 1\\n            else start = mid + 1\\n        }\\n    }\\n    return false\\n}\\n\\n// ** Diagonal search from top right - O(m + n)**\\nvar searchMatrix = function(matrix, target) {\\n    let j = matrix[0].length - 1, i = 0\\n    \\n    while(j >= 0 && i < matrix.length) {\\n        if(matrix[i][j] === target) return true\\n        \\n        if(matrix[i][j] > target) j--\\n        else i++\\n    }\\n    return false\\n}\\n\\n//** Binary search complete matrix - O(log mn)**\\nvar searchMatrix = function(matrix, target) {\\n  let start = 0, end = (matrix.length * matrix[0].length) - 1\\n    \\n    while(start <= end) {\\n        let mid = Math.floor((start + end) / 2)\\n        let midNum = \\n            matrix[Math.floor(mid / matrix[0].length)][mid % matrix[0].length]\\n        \\n        if(midNum === target) return true    \\n        else if(midNum < target) start = mid + 1\\n        else end = mid - 1\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\n\\n//** Brute force - O(mn)**\\nvar searchMatrix = function(matrix, target) {\\n    for(let i = 0; i < matrix.length; i++) {\\n        for(let j = 0; j < matrix[0].length; j++) {\\n            if(matrix[i][j] === target) return true\\n        }\\n    }\\n    return false\\n };\\n\\n\\n// **Binary search in each row - O(mlog n)**\\nvar searchMatrix = function(matrix, target) {\\n    for(let i = 0; i < matrix.length; i++) {\\n        let start = 0, end = matrix[0].length - 1\\n\\n        while(start <= end) {\\n            let mid = Math.floor((start + end) / 2)\\n            if(matrix[i][mid] === target) return true\\n            \\n            if(matrix[i][mid] > target) end = mid - 1\\n            else start = mid + 1\\n        }\\n    }\\n    return false\\n}\\n\\n// ** Diagonal search from top right - O(m + n)**\\nvar searchMatrix = function(matrix, target) {\\n    let j = matrix[0].length - 1, i = 0\\n    \\n    while(j >= 0 && i < matrix.length) {\\n        if(matrix[i][j] === target) return true\\n        \\n        if(matrix[i][j] > target) j--\\n        else i++\\n    }\\n    return false\\n}\\n\\n//** Binary search complete matrix - O(log mn)**\\nvar searchMatrix = function(matrix, target) {\\n  let start = 0, end = (matrix.length * matrix[0].length) - 1\\n    \\n    while(start <= end) {\\n        let mid = Math.floor((start + end) / 2)\\n        let midNum = \\n            matrix[Math.floor(mid / matrix[0].length)][mid % matrix[0].length]\\n        \\n        if(midNum === target) return true    \\n        else if(midNum < target) start = mid + 1\\n        else end = mid - 1\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2407624,
                "title": "very-easy-0-ms-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution (Binary Search Approach):**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Search a 2D Matrix.\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        // Base condition...\\n        // If it\\'s a null matrix, return false....\\n        if(matrix==null || matrix.length==0 || matrix[0].length==0) \\n            return false;\\n        int row = matrix.length;        // Number of Rows of the matrix...\\n        int col = matrix[0].length;     // Number of Columns of the matrix...\\n        // Initialize beg index of the considered 1D matrix (i.e: 0)...\\n        int beg = 0;\\n        // Set end index of the considered 1D matrix (i.e:(row*col)-1)...\\n        int end = row * col - 1;\\n        // Now apply binary search & Run a while loop...\\n        while(beg <= end ){\\n            // Get the middle index as (beg + end) / 2...\\n            int mid = beg + (end - beg)/2;\\n            // Set the element at middle index using matrix[mid / col][mid % col]...\\n            int idx = matrix[mid / col][mid % col];\\n            // If the element present at the middle index is equal to the target integer, return true...\\n            if(idx == target)\\n                return true;\\n            // If the middle index is greater than the target, update the end index to mid - 1...\\n            if(idx > target){\\n                end = mid-1;\\n            }\\n            // If the middle index element is lesser than the target, update the low index to middle+1...\\n            else{\\n                beg = mid + 1;\\n            }\\n        }\\n        return false;       // As we didn\\'t get the target, we can directly return false...\\n    }\\n}\\n```\\n\\n# **C++ Solution (Linear Approach):**\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Search a 2D Matrix.\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        // Create two variable r = 0, c = matrix[0].size() - 1 as index of row and column....\\n        int r = 0;\\n        int c = matrix[0].size()-1;\\n        // Run a while loop and traverse all the elements until row is equal to the size of the matrix...\\n        while(r < matrix.size() && c >= 0) {\\n            // If the element is equal to the target, return true...\\n            if(target == matrix[r][c])\\n                return true;\\n            // Check if the current element is greater than target...\\n            else if(matrix[r][c] > target)\\n                c--;\\n            // If the current element is less than target...\\n            else \\n                r++;\\n        }\\n        return false;       // As we didn\\'t get the target, we can directly return false...\\n    }\\n};\\n```\\n\\n# **Python Solution (Binary Search Approach):**\\nRuntime: 35 ms, faster than 77.61% of Python online submissions for Search a 2D Matrix.\\n```\\nclass Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        # Base condition...\\n        if not matrix:\\n            return False\\n        row = len(matrix)       # Number of Rows of the matrix...\\n        col = len(matrix[0])    # Number of Columns of the matrix...\\n        # Initialize beg index of the considered 1D matrix (i.e: 0)...\\n        beg = 0\\n        # Set end index of the considered 1D matrix (i.e: row*col)...\\n        end = row*col\\n        # Now apply binary search & Run a while loop...\\n        while beg < end:\\n            # Get the middle index as (beg + (end - beg)) // 2...\\n            mid = beg + (end - beg) // 2\\n            # Set the element at middle index using matrix[mid / col][mid % col].\\n            idx = matrix[mid / col][mid % col];\\n            # If the element present at the middle index is equal to the target integer, return true...\\n            if idx == target:\\n                return True\\n            # If the middle index element is lesser than the target...\\n            if idx < target:\\n                beg = mid + 1\\n            # If the middle index is greater than the target...\\n            else:\\n                end = mid\\n        return False        # As we didn\\'t get the target, we can directly return false...\\n```\\n                    \\n# **JavaScript Solution (Linear Approach):**\\n```\\nvar searchMatrix = function(matrix, target) {\\n    // Create two variable r = 0, c = matrix[0].size() - 1 as index of row and column....\\n    let r = 0;\\n    let c = matrix[0].length-1;\\n    // Run a while loop and traverse all the elements until row is equal to the size of the matrix...\\n    while(r < matrix.length && c >= 0) {\\n        // If the element is equal to the target, return true...\\n        if(target == matrix[r][c])\\n            return true;\\n        // Check if the current element is greater than target...\\n        else if(matrix[r][c] > target)\\n            c--;\\n        // If the current element is less than target...\\n        else \\n            r++;\\n    }\\n    return false;       // As we didn\\'t get the target, we can directly return false...\\n};\\n```\\n\\n# **C Language (Linear Approach):**\\nRuntime: 5 ms, faster than 67.65% of C online submissions for Search a 2D Matrix.\\nYou can also solve this problem using binary search approach to get 0 ms runtime.\\n```\\nbool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\\n    // Create two variable r = 0, c = matrixColSize - 1 as index of row and column....\\n    int r = 0;\\n    int c = *matrixColSize - 1;\\n    // Run a while loop and traverse all the elements until row is equal to the size of the matrix...\\n    while(r < matrixSize && c >= 0) {\\n        // If the element is equal to the target, return true...\\n        if(target == matrix[r][c])\\n            return true;\\n        // Check if the current element is greater than target...\\n        else if(matrix[r][c] > target)\\n            c--;\\n        // If the current element is less than target...\\n        else \\n            r++;\\n    }\\n    return false;       // As we didn\\'t get the target, we can directly return false...\\n}\\n```\\n\\n# **Python3 Solution (Binary Search Approach):**\\nRuntime: 47 ms, faster than 91.95% of Python3 online submissions for Search a 2D Matrix.\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        # Base condition...\\n        if not matrix:\\n            return False\\n        row = len(matrix)       # Number of Rows of the matrix...\\n        col = len(matrix[0])    # Number of Columns of the matrix...\\n        # Initialize beg index of the considered 1D matrix (i.e: 0)...\\n        beg = 0\\n        # Set end index of the considered 1D matrix (i.e: row*col)...\\n        end = row*col\\n        # Now apply binary search & Run a while loop...\\n        while beg < end:\\n            # Get the middle index as (beg + (end - beg)) // 2...\\n            mid = beg + (end - beg) // 2\\n            # Set the element at middle index using matrix[mid / col][mid % col].\\n            idx = matrix[mid // col][mid % col];\\n            # If the element present at the middle index is equal to the target integer, return true...\\n            if idx == target:\\n                return True\\n            # If the middle index element is lesser than the target...\\n            if idx < target:\\n                beg = mid + 1\\n            # If the middle index is greater than the target...\\n            else:\\n                end = mid\\n        return False        # As we didn\\'t get the target, we can directly return false...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        // Base condition...\\n        // If it\\'s a null matrix, return false....\\n        if(matrix==null || matrix.length==0 || matrix[0].length==0) \\n            return false;\\n        int row = matrix.length;        // Number of Rows of the matrix...\\n        int col = matrix[0].length;     // Number of Columns of the matrix...\\n        // Initialize beg index of the considered 1D matrix (i.e: 0)...\\n        int beg = 0;\\n        // Set end index of the considered 1D matrix (i.e:(row*col)-1)...\\n        int end = row * col - 1;\\n        // Now apply binary search & Run a while loop...\\n        while(beg <= end ){\\n            // Get the middle index as (beg + end) / 2...\\n            int mid = beg + (end - beg)/2;\\n            // Set the element at middle index using matrix[mid / col][mid % col]...\\n            int idx = matrix[mid / col][mid % col];\\n            // If the element present at the middle index is equal to the target integer, return true...\\n            if(idx == target)\\n                return true;\\n            // If the middle index is greater than the target, update the end index to mid - 1...\\n            if(idx > target){\\n                end = mid-1;\\n            }\\n            // If the middle index element is lesser than the target, update the low index to middle+1...\\n            else{\\n                beg = mid + 1;\\n            }\\n        }\\n        return false;       // As we didn\\'t get the target, we can directly return false...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        // Create two variable r = 0, c = matrix[0].size() - 1 as index of row and column....\\n        int r = 0;\\n        int c = matrix[0].size()-1;\\n        // Run a while loop and traverse all the elements until row is equal to the size of the matrix...\\n        while(r < matrix.size() && c >= 0) {\\n            // If the element is equal to the target, return true...\\n            if(target == matrix[r][c])\\n                return true;\\n            // Check if the current element is greater than target...\\n            else if(matrix[r][c] > target)\\n                c--;\\n            // If the current element is less than target...\\n            else \\n                r++;\\n        }\\n        return false;       // As we didn\\'t get the target, we can directly return false...\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        # Base condition...\\n        if not matrix:\\n            return False\\n        row = len(matrix)       # Number of Rows of the matrix...\\n        col = len(matrix[0])    # Number of Columns of the matrix...\\n        # Initialize beg index of the considered 1D matrix (i.e: 0)...\\n        beg = 0\\n        # Set end index of the considered 1D matrix (i.e: row*col)...\\n        end = row*col\\n        # Now apply binary search & Run a while loop...\\n        while beg < end:\\n            # Get the middle index as (beg + (end - beg)) // 2...\\n            mid = beg + (end - beg) // 2\\n            # Set the element at middle index using matrix[mid / col][mid % col].\\n            idx = matrix[mid / col][mid % col];\\n            # If the element present at the middle index is equal to the target integer, return true...\\n            if idx == target:\\n                return True\\n            # If the middle index element is lesser than the target...\\n            if idx < target:\\n                beg = mid + 1\\n            # If the middle index is greater than the target...\\n            else:\\n                end = mid\\n        return False        # As we didn\\'t get the target, we can directly return false...\\n```\n```\\nvar searchMatrix = function(matrix, target) {\\n    // Create two variable r = 0, c = matrix[0].size() - 1 as index of row and column....\\n    let r = 0;\\n    let c = matrix[0].length-1;\\n    // Run a while loop and traverse all the elements until row is equal to the size of the matrix...\\n    while(r < matrix.length && c >= 0) {\\n        // If the element is equal to the target, return true...\\n        if(target == matrix[r][c])\\n            return true;\\n        // Check if the current element is greater than target...\\n        else if(matrix[r][c] > target)\\n            c--;\\n        // If the current element is less than target...\\n        else \\n            r++;\\n    }\\n    return false;       // As we didn\\'t get the target, we can directly return false...\\n};\\n```\n```\\nbool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\\n    // Create two variable r = 0, c = matrixColSize - 1 as index of row and column....\\n    int r = 0;\\n    int c = *matrixColSize - 1;\\n    // Run a while loop and traverse all the elements until row is equal to the size of the matrix...\\n    while(r < matrixSize && c >= 0) {\\n        // If the element is equal to the target, return true...\\n        if(target == matrix[r][c])\\n            return true;\\n        // Check if the current element is greater than target...\\n        else if(matrix[r][c] > target)\\n            c--;\\n        // If the current element is less than target...\\n        else \\n            r++;\\n    }\\n    return false;       // As we didn\\'t get the target, we can directly return false...\\n}\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        # Base condition...\\n        if not matrix:\\n            return False\\n        row = len(matrix)       # Number of Rows of the matrix...\\n        col = len(matrix[0])    # Number of Columns of the matrix...\\n        # Initialize beg index of the considered 1D matrix (i.e: 0)...\\n        beg = 0\\n        # Set end index of the considered 1D matrix (i.e: row*col)...\\n        end = row*col\\n        # Now apply binary search & Run a while loop...\\n        while beg < end:\\n            # Get the middle index as (beg + (end - beg)) // 2...\\n            mid = beg + (end - beg) // 2\\n            # Set the element at middle index using matrix[mid / col][mid % col].\\n            idx = matrix[mid // col][mid % col];\\n            # If the element present at the middle index is equal to the target integer, return true...\\n            if idx == target:\\n                return True\\n            # If the middle index element is lesser than the target...\\n            if idx < target:\\n                beg = mid + 1\\n            # If the middle index is greater than the target...\\n            else:\\n                end = mid\\n        return False        # As we didn\\'t get the target, we can directly return false...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081093,
                "title": "java-6-different-ways-of-doing-this",
                "content": "Some of these are syntactic sugar of course. Look at the method names for more description. If my TC and SC are wrong, please do let me know, will update it. Thanks\\n\\nNote: TC stands for Time Complexity, SC stands for Space Complexity.\\n\\n```java\\n    // TC: O(log(mn)), SC: O(1)\\n    public boolean searchMatrix_BinarySearch(int[][] matrix, int target) {\\n        if (matrix.length == 0) return false;\\n        int rows = matrix.length, cols = matrix[0].length;\\n\\n        int lo = 0, hi = rows * cols - 1;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int num = matrix[mid / cols][mid % cols];\\n            if (num == target) return true;\\n            else if (num < target) lo = mid + 1;\\n            else hi = mid - 1;\\n        }\\n        return false;\\n    }\\n\\n    // TC: O(mn + log(mn)), SC: O(mn)\\n    public boolean searchMatrix_ConstructAnArray(int[][] matrix, int target) {\\n        List<Integer> res = new ArrayList<>();\\n        int rows = matrix.length, cols = matrix[0].length;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) res.add(matrix[i][j]);\\n        }\\n        return Collections.binarySearch(res, target) >= 0;\\n    }\\n\\n    // TC: O(m+n), SC: O(1)\\n    public boolean searchMatrix_BottomLeft(int[][] matrix, int target) {\\n        int rows = matrix.length, cols = matrix[0].length, i = rows - 1, j = 0;\\n        while (i >= 0 && i < rows && j >= 0 && j < cols) {\\n            int num = matrix[i][j];\\n            if (num == target) return true;\\n            if (num < target) j++;\\n            else i--;\\n        }\\n        return false;\\n    }\\n\\n    // TC: O(m+n), SC: O(1)\\n    public boolean searchMatrix_TopRight(int[][] matrix, int target) {\\n        int rows = matrix.length, cols = matrix[0].length, i = 0, j = cols - 1;\\n        while (i >= 0 && i < rows && j >= 0 && j < cols) {\\n            int num = matrix[i][j];\\n            if (num == target) return true;\\n            if (num < target) i++;\\n            else j--;\\n        }\\n        return false;\\n    }\\n\\n    // TC: O(mn), SC: O(1)\\n    public boolean searchMatrix_BruteForce(int[][] matrix, int target) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == target) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // TC: O(mn), SC: O(1)\\n    public boolean searchMatrix_BruteForce_EnhancedForLoop(int[][] matrix, int target) {\\n        for (int[] rows : matrix) {\\n            for (int num : rows) {\\n                if (num == target) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\n    // TC: O(log(mn)), SC: O(1)\\n    public boolean searchMatrix_BinarySearch(int[][] matrix, int target) {\\n        if (matrix.length == 0) return false;\\n        int rows = matrix.length, cols = matrix[0].length;\\n\\n        int lo = 0, hi = rows * cols - 1;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int num = matrix[mid / cols][mid % cols];\\n            if (num == target) return true;\\n            else if (num < target) lo = mid + 1;\\n            else hi = mid - 1;\\n        }\\n        return false;\\n    }\\n\\n    // TC: O(mn + log(mn)), SC: O(mn)\\n    public boolean searchMatrix_ConstructAnArray(int[][] matrix, int target) {\\n        List<Integer> res = new ArrayList<>();\\n        int rows = matrix.length, cols = matrix[0].length;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) res.add(matrix[i][j]);\\n        }\\n        return Collections.binarySearch(res, target) >= 0;\\n    }\\n\\n    // TC: O(m+n), SC: O(1)\\n    public boolean searchMatrix_BottomLeft(int[][] matrix, int target) {\\n        int rows = matrix.length, cols = matrix[0].length, i = rows - 1, j = 0;\\n        while (i >= 0 && i < rows && j >= 0 && j < cols) {\\n            int num = matrix[i][j];\\n            if (num == target) return true;\\n            if (num < target) j++;\\n            else i--;\\n        }\\n        return false;\\n    }\\n\\n    // TC: O(m+n), SC: O(1)\\n    public boolean searchMatrix_TopRight(int[][] matrix, int target) {\\n        int rows = matrix.length, cols = matrix[0].length, i = 0, j = cols - 1;\\n        while (i >= 0 && i < rows && j >= 0 && j < cols) {\\n            int num = matrix[i][j];\\n            if (num == target) return true;\\n            if (num < target) i++;\\n            else j--;\\n        }\\n        return false;\\n    }\\n\\n    // TC: O(mn), SC: O(1)\\n    public boolean searchMatrix_BruteForce(int[][] matrix, int target) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == target) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // TC: O(mn), SC: O(1)\\n    public boolean searchMatrix_BruteForce_EnhancedForLoop(int[][] matrix, int target) {\\n        for (int[] rows : matrix) {\\n            for (int num : rows) {\\n                if (num == target) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 896950,
                "title": "c-super-simple-efficient-solution-o-m-logn-faster-than-99",
                "content": "```\\nclass Solution {\\npublic:\\n    bool binarySearch(vector<int>& vec, int target) {\\n        int l = 0, r = vec.size();\\n        while (l <= r)\\n        {\\n            int mid = (l + r) / 2;\\n            if (vec[mid] == target)\\n                return true;\\n            else if (vec[mid] < target)\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        return false;\\n    }\\n    \\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if ((matrix.size() == 0) || (matrix[0].size() == 0)) return false;\\n        int row = 0;\\n        while ((row < matrix.size()) && (matrix[row].back() < target))\\n            row++;\\n        \\n        if (row >= matrix.size()) return false;\\n        \\n        return binarySearch(matrix[row], target);\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool binarySearch(vector<int>& vec, int target) {\\n        int l = 0, r = vec.size();\\n        while (l <= r)\\n        {\\n            int mid = (l + r) / 2;\\n            if (vec[mid] == target)\\n                return true;\\n            else if (vec[mid] < target)\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        return false;\\n    }\\n    \\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if ((matrix.size() == 0) || (matrix[0].size() == 0)) return false;\\n        int row = 0;\\n        while ((row < matrix.size()) && (matrix[row].back() < target))\\n            row++;\\n        \\n        if (row >= matrix.size()) return false;\\n        \\n        return binarySearch(matrix[row], target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874326,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing binary search twice. (At the bottom of this arcile, I put a new solution with single binary search as a bonus code)\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n# Subscribe to my channel from here. I have 241 videos as of August 7th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nhttps://youtu.be/_PJYgUOctQw\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Initialize `top` to 0 and `bot` to the length of the matrix minus 1.\\n\\n2. Use a binary search algorithm to find a row where the target could potentially exist. Repeat the following steps while `top` is less than or equal to `bot`:\\n   a. Calculate the middle index `mid` as the average of `top` and `bot`.\\n   b. Check if the value at `matrix[mid][0]` is less than the `target` and the value at `matrix[mid][-1]` (last element in the row) is greater than the `target`. If this condition is met, it means the target could potentially exist in this row. Break the loop.\\n   c. If the value at `matrix[mid][0]` is greater than the `target`, update `bot` to be `mid - 1` to search in the upper half.\\n   d. Otherwise, update `top` to be `mid + 1` to search in the lower half.\\n\\n3. After exiting the above loop, the variable `row` will hold the index of the row where the target could potentially exist.\\n\\n4. Initialize `left` to 0 and `right` to the length of the row minus 1.\\n\\n5. Use another binary search algorithm to search for the target within the selected row. Repeat the following steps while `left` is less than or equal to `right`:\\n   a. Calculate the middle index `mid` as the average of `left` and `right`.\\n   b. Check if the value at `matrix[row][mid]` is equal to the `target`. If it is, return `True` as the target is found.\\n   c. If the value at `matrix[row][mid]` is greater than the `target`, update `right` to be `mid - 1` to search in the left half.\\n   d. Otherwise, update `left` to be `mid + 1` to search in the right half.\\n\\n6. If the second binary search loop completes without finding the target, return `False` as the target is not in the matrix.\\n\\nThis algorithm efficiently searches for the `target` in a sorted matrix using binary search in both rows and columns.\\n\\n# Complexity\\n- Time complexity: O(log(m) + log(n))\\n\\n- Space complexity: O(1)\\n\\n```python []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        \\n        top = 0\\n        bot = len(matrix) - 1\\n\\n        while top <= bot:\\n            mid = (top + bot) // 2\\n\\n            if matrix[mid][0] < target and matrix[mid][-1] > target:\\n                break\\n            elif matrix[mid][0] > target:\\n                bot = mid - 1\\n            else:\\n                top = mid + 1\\n        \\n        row = (top + bot) // 2\\n\\n        left = 0\\n        right = len(matrix[row]) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if matrix[row][mid] == target:\\n                return True\\n            elif matrix[row][mid] > target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        \\n        return False\\n```\\n```javascript []\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function(matrix, target) {\\n    let [rows, cols] = [matrix.length, matrix[0].length];\\n    let [top, bot] = [0, rows-1];\\n    \\n    while(top <= bot){\\n        let row = Math.floor((top +  bot) / 2);\\n        if(target > matrix[row][cols-1]) {\\n            top = row + 1;\\n        } else if(target < matrix[row][0]) {\\n            bot = row - 1; \\n        } else {\\n            break;\\n        }\\n    }\\n    \\n    if(!(top <= bot)) {\\n        return false;\\n    }\\n    \\n    let row = Math.floor((top + bot) / 2);\\n    let [left, right] = [0, cols - 1];\\n\\n    while(left <= right){\\n        let mid = Math.floor((left + right) / 2);\\n\\n        if(target > matrix[row][mid]) {\\n            left = mid + 1;\\n        } else if(target < matrix[row][mid]) {\\n            right = mid - 1;\\n        } else if(target == matrix[row][mid]) {\\n            return true;\\n        }\\n    }\\n\\n    return false;    \\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int top = 0;\\n        int bot = matrix.length - 1;\\n\\n        while (top <= bot) {\\n            int mid = (top + bot) / 2;\\n\\n            if (matrix[mid][0] < target && matrix[mid][matrix[mid].length - 1] > target) {\\n                break;\\n            } else if (matrix[mid][0] > target) {\\n                bot = mid - 1;\\n            } else {\\n                top = mid + 1;\\n            }\\n        }\\n\\n        int row = (top + bot) / 2;\\n\\n        int left = 0;\\n        int right = matrix[row].length - 1;\\n\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n\\n            if (matrix[row][mid] == target) {\\n                return true;\\n            } else if (matrix[row][mid] > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int top = 0;\\n        int bot = matrix.size() - 1;\\n\\n        while (top <= bot) {\\n            int mid = (top + bot) / 2;\\n\\n            if (matrix[mid][0] < target && matrix[mid][matrix[mid].size() - 1] > target) {\\n                break;\\n            } else if (matrix[mid][0] > target) {\\n                bot = mid - 1;\\n            } else {\\n                top = mid + 1;\\n            }\\n        }\\n\\n        int row = (top + bot) / 2;\\n\\n        int left = 0;\\n        int right = matrix[row].size() - 1;\\n\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n\\n            if (matrix[row][mid] == target) {\\n                return true;\\n            } else if (matrix[row][mid] > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n};\\n```\\n\\nThese are bonus codes. If you want to solve this question with single binary search, please use these. I created the video around Feb 2023 and I solved this question with single binary search on Aug 7th 2023.\\n\\nI added a main concept for these solution and step by step algorithm in the top fixed comment in the video. Please check the video and don\\'t forget to subscribe!\\n\\n```python []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:        \\n        rows, cols = len(matrix), len(matrix[0])\\n        left, right = 0, rows * cols - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            row, col = mid // cols, mid % cols\\n            guess = matrix[row][col]\\n\\n            if guess == target:\\n                return True\\n            elif guess < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return False\\n```\\n```javascript []\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function(matrix, target) {\\n    const [rows, cols] = [matrix.length, matrix[0].length];\\n    let [left, right] = [0, rows * cols - 1];\\n\\n    while (left <= right) {\\n        const mid = (left + right) >> 1;\\n        const [row, col] = [Math.floor(mid / cols), mid % cols];\\n        const guess = matrix[row][col];\\n\\n        const isTarget = guess === target;\\n        if (isTarget) return true;\\n\\n        const isTargetGreater = guess < target;\\n        if (isTargetGreater) left = mid + 1;\\n\\n        const isTargetLess = target < guess;\\n        if (isTargetLess) right = mid - 1;\\n    }\\n\\n    return false;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        int left = 0;\\n        int right = rows * cols - 1;\\n\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            int row = mid / cols;\\n            int col = mid % cols;\\n            int guess = matrix[row][col];\\n\\n            if (guess == target) {\\n                return true;\\n            } else if (guess < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n        int left = 0;\\n        int right = rows * cols - 1;\\n\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            int row = mid / cols;\\n            int col = mid % cols;\\n            int guess = matrix[row][col];\\n\\n            if (guess == target) {\\n                return true;\\n            } else if (guess < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        \\n        top = 0\\n        bot = len(matrix) - 1\\n\\n        while top <= bot:\\n            mid = (top + bot) // 2\\n\\n            if matrix[mid][0] < target and matrix[mid][-1] > target:\\n                break\\n            elif matrix[mid][0] > target:\\n                bot = mid - 1\\n            else:\\n                top = mid + 1\\n        \\n        row = (top + bot) // 2\\n\\n        left = 0\\n        right = len(matrix[row]) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if matrix[row][mid] == target:\\n                return True\\n            elif matrix[row][mid] > target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        \\n        return False\\n```\n```javascript []\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function(matrix, target) {\\n    let [rows, cols] = [matrix.length, matrix[0].length];\\n    let [top, bot] = [0, rows-1];\\n    \\n    while(top <= bot){\\n        let row = Math.floor((top +  bot) / 2);\\n        if(target > matrix[row][cols-1]) {\\n            top = row + 1;\\n        } else if(target < matrix[row][0]) {\\n            bot = row - 1; \\n        } else {\\n            break;\\n        }\\n    }\\n    \\n    if(!(top <= bot)) {\\n        return false;\\n    }\\n    \\n    let row = Math.floor((top + bot) / 2);\\n    let [left, right] = [0, cols - 1];\\n\\n    while(left <= right){\\n        let mid = Math.floor((left + right) / 2);\\n\\n        if(target > matrix[row][mid]) {\\n            left = mid + 1;\\n        } else if(target < matrix[row][mid]) {\\n            right = mid - 1;\\n        } else if(target == matrix[row][mid]) {\\n            return true;\\n        }\\n    }\\n\\n    return false;    \\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int top = 0;\\n        int bot = matrix.length - 1;\\n\\n        while (top <= bot) {\\n            int mid = (top + bot) / 2;\\n\\n            if (matrix[mid][0] < target && matrix[mid][matrix[mid].length - 1] > target) {\\n                break;\\n            } else if (matrix[mid][0] > target) {\\n                bot = mid - 1;\\n            } else {\\n                top = mid + 1;\\n            }\\n        }\\n\\n        int row = (top + bot) / 2;\\n\\n        int left = 0;\\n        int right = matrix[row].length - 1;\\n\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n\\n            if (matrix[row][mid] == target) {\\n                return true;\\n            } else if (matrix[row][mid] > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int top = 0;\\n        int bot = matrix.size() - 1;\\n\\n        while (top <= bot) {\\n            int mid = (top + bot) / 2;\\n\\n            if (matrix[mid][0] < target && matrix[mid][matrix[mid].size() - 1] > target) {\\n                break;\\n            } else if (matrix[mid][0] > target) {\\n                bot = mid - 1;\\n            } else {\\n                top = mid + 1;\\n            }\\n        }\\n\\n        int row = (top + bot) / 2;\\n\\n        int left = 0;\\n        int right = matrix[row].size() - 1;\\n\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n\\n            if (matrix[row][mid] == target) {\\n                return true;\\n            } else if (matrix[row][mid] > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:        \\n        rows, cols = len(matrix), len(matrix[0])\\n        left, right = 0, rows * cols - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            row, col = mid // cols, mid % cols\\n            guess = matrix[row][col]\\n\\n            if guess == target:\\n                return True\\n            elif guess < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return False\\n```\n```javascript []\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function(matrix, target) {\\n    const [rows, cols] = [matrix.length, matrix[0].length];\\n    let [left, right] = [0, rows * cols - 1];\\n\\n    while (left <= right) {\\n        const mid = (left + right) >> 1;\\n        const [row, col] = [Math.floor(mid / cols), mid % cols];\\n        const guess = matrix[row][col];\\n\\n        const isTarget = guess === target;\\n        if (isTarget) return true;\\n\\n        const isTargetGreater = guess < target;\\n        if (isTargetGreater) left = mid + 1;\\n\\n        const isTargetLess = target < guess;\\n        if (isTargetLess) right = mid - 1;\\n    }\\n\\n    return false;    \\n};\\n```\n```java []\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        int left = 0;\\n        int right = rows * cols - 1;\\n\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            int row = mid / cols;\\n            int col = mid % cols;\\n            int guess = matrix[row][col];\\n\\n            if (guess == target) {\\n                return true;\\n            } else if (guess < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n        int left = 0;\\n        int right = rows * cols - 1;\\n\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            int row = mid / cols;\\n            int col = mid % cols;\\n            int guess = matrix[row][col];\\n\\n            if (guess == target) {\\n                return true;\\n            } else if (guess < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557000,
                "title": "74-search-a-2d-matrix-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if(matrix.length == 0) {\\n            return false;\\n        } \\n        int rows = matrix.length;\\n        int columns = matrix[0].length;\\n            \\n        int low = 0;\\n        int high = (rows * columns - 1);\\n            \\n        while(low <= high) {\\n            int mid = (low + (high - low) / 2);\\n            int value = matrix[mid / columns][mid % columns];\\n                \\n            if (value == target) {\\n                return true;\\n            } else if (value < target) {\\n                low = mid + 1; \\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if(matrix.length == 0) {\\n            return false;\\n        } \\n        int rows = matrix.length;\\n        int columns = matrix[0].length;\\n            \\n        int low = 0;\\n        int high = (rows * columns - 1);\\n            \\n        while(low <= high) {\\n            int mid = (low + (high - low) / 2);\\n            int value = matrix[mid / columns][mid % columns];\\n                \\n            if (value == target) {\\n                return true;\\n            } else if (value < target) {\\n                low = mid + 1; \\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897799,
                "title": "python-3-vanilla-binary-search-explanation",
                "content": "**If you found the official answer not intuitive or hard to understand, this solution might give you some help**  \\n\\n### Explanation\\n- Intuition, since the rows are sorted, columns are sorted as well, thus we can do 2 binary search to locate the exact position of `target`\\n- First, handle special cases. e.g. `[], [[]]`\\n- Second, binary search on rows, to locate row number\\n\\t- If not found, return `False`\\n- Third, once we have row number, binary search on columns \\n\\t- If not found, return `False`, else return `True`\\n- Time Complexity `O(lgm + lgn) == O(lg(mn))`\\n\\n### Implementation\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix: return 0\\n        m, n = len(matrix), len(matrix[0])\\n        if not n: return 0\\n\\t\\t\\n        r, r1, r2 = -1, 0, m-1\\n        while r1 <= r2:\\n            mid = (r1+r2) // 2 \\n            if matrix[mid][0] <= target <= matrix[mid][n-1]: r = mid; break\\n            elif matrix[mid][0] > target: r2 = mid - 1\\n            else: r1 = mid + 1    \\n        if r == -1: return False        \\n        \\n        c1, c2 = 0, n-1\\n        while c1 <= c2:\\n            mid = (c1+c2) // 2 \\n            if matrix[r][mid] == target: return True\\n            elif matrix[r][mid] > target: c2 = mid - 1\\n            else: c1 = mid + 1\\n        return False        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix: return 0\\n        m, n = len(matrix), len(matrix[0])\\n        if not n: return 0\\n\\t\\t\\n        r, r1, r2 = -1, 0, m-1\\n        while r1 <= r2:\\n            mid = (r1+r2) // 2 \\n            if matrix[mid][0] <= target <= matrix[mid][n-1]: r = mid; break\\n            elif matrix[mid][0] > target: r2 = mid - 1\\n            else: r1 = mid + 1    \\n        if r == -1: return False        \\n        \\n        c1, c2 = 0, n-1\\n        while c1 <= c2:\\n            mid = (c1+c2) // 2 \\n            if matrix[r][mid] == target: return True\\n            elif matrix[r][mid] > target: c2 = mid - 1\\n            else: c1 = mid + 1\\n        return False        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 26204,
                "title": "share-my-two-o-logm-logn-solutions",
                "content": " Solution1:\\n\\nTreat the matrix as a sorted list, and use  binary search.\\n\\n    class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int> > &matrix, int target)\\n        {\\n            if(matrix.empty())  return false;\\n            \\n        \\tint height = matrix.size();\\n        \\tint width = matrix[0].size();\\n        \\n        \\tif(matrix[0][0] > target || matrix[height-1][width-1] < target)\\treturn false;\\t\\n        \\n        \\tint head = 0,tail = height*width-1;\\n        \\tint mid,midRow,midCol;\\n    \\n        \\twhile(head <= tail)\\n        \\t{\\n        \\t\\tmid = (head+tail)/2;\\n        \\t\\tmidCol = mid%width;\\n        \\t    midRow = mid/width;\\n        \\t\\tif(matrix[midRow][midCol] < target)\\n        \\t\\t\\thead = mid+1;\\n        \\t\\telse if(matrix[midRow][midCol] > target)\\n        \\t\\t\\ttail = mid-1;\\n        \\t\\telse\\n        \\t\\t\\treturn true;\\n        \\t}\\n        \\treturn false;\\n        }\\n    };\\n\\nSolution2:\\n\\nUse binary search for matrix[i][0] to find the row where target is in, and then use  binary search for matrix[row][j] to find target. This solution is better because it avoids multiplication overflow(height*width) and / and % while it's complexity is the  same as solution1.\\n\\n    class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int> > &matrix,int target)\\n        {\\n            if(matrix.empty())  return false;\\n            \\n        \\tint heigth = matrix.size();\\n        \\tint width = matrix[0].size();\\n        \\t\\n        \\tif(matrix[0][0] > target || matrix[heigth-1][width-1] < target)\\t\\treturn false;\\n        \\n        \\tint head = 0;\\n        \\tint tail = heigth-1;\\n        \\tint mid;\\n        \\twhile(head != tail && matrix[tail][0] > target)\\n        \\t{\\n        \\t\\tmid = (head+tail+1)/2;\\n        \\t\\tif(matrix[mid][0] < target)\\t\\thead = mid;\\n        \\t\\telse if(matrix[mid][0] > target)\\ttail = mid-1;\\t\\n        \\t\\telse \\treturn true;\\n        \\t}\\n        \\tint row = tail;\\n        \\thead = 0,tail = width-1;\\n        \\twhile(head <= tail)\\n        \\t{\\n        \\t\\tmid = (head+tail)/2;\\n        \\t\\tif(matrix[row][mid] < target)\\n        \\t\\t\\thead = mid + 1;\\n        \\t\\telse if(matrix[row][mid] > target)\\n        \\t\\t\\ttail = mid -1;\\n        \\t\\telse return true;\\n        \\t}\\n        \\treturn false;\\n        }\\n    };",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int> > &matrix, int target)\\n        {\\n            if(matrix.empty())  return false;\\n            \\n        \\tint height = matrix.size();\\n        \\tint width = matrix[0].size();\\n        \\n        \\tif(matrix[0][0] > target || matrix[height-1][width-1] < target)\\treturn false;\\t\\n        \\n        \\tint head = 0,tail = height*width-1;\\n        \\tint mid,midRow,midCol;\\n    \\n        \\twhile(head <= tail)\\n        \\t{\\n        \\t\\tmid = (head+tail)/2;\\n        \\t\\tmidCol = mid%width;\\n        \\t    midRow = mid/width;\\n        \\t\\tif(matrix[midRow][midCol] < target)\\n        \\t\\t\\thead = mid+1;\\n        \\t\\telse if(matrix[midRow][midCol] > target)\\n        \\t\\t\\ttail = mid-1;\\n        \\t\\telse\\n        \\t\\t\\treturn true;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3516362,
                "title": "well-explained-easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we know all the values in the row are sorted and the first value of any row is greater than the last value of the previous row. So we can apply binary search on the entire matrix. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize the start pointer to the first element of the matrix and the end pointer to the last element of the matrix.\\n- Perform binary search by calculating the mid pointer as the average of the start and end pointers.\\n- Convert the mid pointer into its equivalent (i, j) position in the matrix, where i and j are the row and column indices, respectively.\\n```\\n// using this formula\\nint row = mid / n;\\nint col = mid % n;\\n```\\n- If the element at the mid position is equal to the target, return true.\\n- If the element at the mid position is less than the target, update the start pointer to mid + 1.\\n- If the element at the mid position is greater than the target, update the end pointer to mid - 1.\\n- If the target is not found by the end of the binary search, return false.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(m*n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int start=0;\\n        int end=m*n-1;\\n        while(start<=end){\\n            int mid=(start+end)>>1;\\n            int row = mid / n;\\n            int col = mid % n;\\n            if(mat[row][col]==target){\\n                return true;\\n            }else if(mat[row][col]>target){\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n# Your Upvote can be really encouraging\\u2B06\\uFE0F",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\n// using this formula\\nint row = mid / n;\\nint col = mid % n;\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int start=0;\\n        int end=m*n-1;\\n        while(start<=end){\\n            int mid=(start+end)>>1;\\n            int row = mid / n;\\n            int col = mid % n;\\n            if(mat[row][col]==target){\\n                return true;\\n            }else if(mat[row][col]>target){\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896890,
                "title": "c-o-log-n-m-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // T.C --> O(log(n*m))\\n    bool searchMatrix(vector<vector<int>>& a, int x) {\\n        int n=a.size();\\n        if(n==0) return 0;\\n        int m=a[0].size();\\n        int l=0,h=n*m-1;\\n        while(l<=h) {\\n            int mid=(l+h)/2;\\n            int r=mid/m;\\n            int c=mid%m;\\n            if(a[r][c]==x) return 1;\\n            if(a[r][c]>x) h=mid-1;\\n            else l=mid+1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // T.C --> O(log(n*m))\\n    bool searchMatrix(vector<vector<int>>& a, int x) {\\n        int n=a.size();\\n        if(n==0) return 0;\\n        int m=a[0].size();\\n        int l=0,h=n*m-1;\\n        while(l<=h) {\\n            int mid=(l+h)/2;\\n            int r=mid/m;\\n            int c=mid%m;\\n            if(a[r][c]==x) return 1;\\n            if(a[r][c]>x) h=mid-1;\\n            else l=mid+1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896702,
                "title": "python-6-different-solutions",
                "content": "\\u2714 **Solution 1:** Linear Search\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == target: return True\\n        return False\\n```\\n***\\n```Time Complexity: O(M*N)```\\n***\\n\\n\\u2714 **Solution 2:** Staircase search\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        row, col = 0, len(matrix[0]) - 1\\n        while row < len(matrix) and col >= 0:\\n            if matrix[row][col] == target: return True\\n            if target > matrix[row][col]: row += 1\\n            else: col -= 1\\n        return False\\n```\\n***\\n```Time Complexity: O(M+N)```\\n***\\n\\u2714 **Solution 3:** Binary Search Iterative\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        lo, hi = 0, len(matrix) - 1\\n        while lo <= hi:\\n            midRow = (lo + hi) // 2\\n            row = matrix[midRow]\\n            if target < row[0]: hi = midRow - 1\\n            elif target > row[-1]: lo = midRow + 1\\n            else:\\n                l, h = 0, len(row) - 1\\n                while l <= h:\\n                    mid = (l + h) // 2\\n                    if row[mid] == target: return True\\n                    elif target > row[mid]: l = mid + 1\\n                    else: h = mid - 1\\n                return False\\n```\\n***\\n```Time Complexity: O(logM) + O(logN)```\\n***\\n\\u2714 **Solution 4:** Binary Search Recursive\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int):\\n        def searchMatrix(lo, hi, row):\\n            if lo > hi: return False\\n            mid = (lo + hi) // 2\\n            if row is not None:\\n                if matrix[row][mid] == target: return True\\n                if target > matrix[row][mid]: return searchMatrix(mid + 1, hi, row)\\n                return searchMatrix(lo, mid - 1, row)\\n            if target < matrix[mid][0]: return searchMatrix(lo, mid - 1, row)\\n            if target > matrix[mid][-1]: return searchMatrix(mid + 1, hi, row)\\n            return searchMatrix(0, len(matrix[0]) - 1, mid)\\n        return searchMatrix(0, len(matrix)-1, None)\\n```\\n***\\n```Time Complexity: O(logN) + O(logM)```\\n***\\n\\n\\u2714 **Solution 5:** Binary Search iterative by visualizing as a 1D array\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int):\\n        lo, hi = 0, len(matrix) * len(matrix[0]) - 1\\n        \\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            r = mid // len(matrix[0])\\n            c = mid % len(matrix[0])\\n            if matrix[r][c] == target: return True\\n            if target > matrix[r][c]: lo = mid + 1\\n            else: hi = mid - 1\\n        return False\\n```\\n***\\n```Time Complexity: O(log(M*N))```\\n***\\n\\n\\u2714 **Solution 6:** Binary Search Recursive by visualizing as a 1D array\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int):\\n        def search(lo, hi):\\n            if lo > hi: return False\\n            mid = (lo + hi) // 2\\n            curr = matrix[mid // len(matrix[0])][mid % len(matrix[0])]\\n            if target > curr: return search(mid + 1, hi)\\n            if target < curr: return search(lo, mid - 1)\\n            return True\\n        return search(0, len(matrix[0]) * len(matrix) - 1)\\n```\\n***\\n```Time Complexity: O(log(M*N))```\\n***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == target: return True\\n        return False\\n```\n```Time Complexity: O(M*N)```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        row, col = 0, len(matrix[0]) - 1\\n        while row < len(matrix) and col >= 0:\\n            if matrix[row][col] == target: return True\\n            if target > matrix[row][col]: row += 1\\n            else: col -= 1\\n        return False\\n```\n```Time Complexity: O(M+N)```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        lo, hi = 0, len(matrix) - 1\\n        while lo <= hi:\\n            midRow = (lo + hi) // 2\\n            row = matrix[midRow]\\n            if target < row[0]: hi = midRow - 1\\n            elif target > row[-1]: lo = midRow + 1\\n            else:\\n                l, h = 0, len(row) - 1\\n                while l <= h:\\n                    mid = (l + h) // 2\\n                    if row[mid] == target: return True\\n                    elif target > row[mid]: l = mid + 1\\n                    else: h = mid - 1\\n                return False\\n```\n```Time Complexity: O(logM) + O(logN)```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int):\\n        def searchMatrix(lo, hi, row):\\n            if lo > hi: return False\\n            mid = (lo + hi) // 2\\n            if row is not None:\\n                if matrix[row][mid] == target: return True\\n                if target > matrix[row][mid]: return searchMatrix(mid + 1, hi, row)\\n                return searchMatrix(lo, mid - 1, row)\\n            if target < matrix[mid][0]: return searchMatrix(lo, mid - 1, row)\\n            if target > matrix[mid][-1]: return searchMatrix(mid + 1, hi, row)\\n            return searchMatrix(0, len(matrix[0]) - 1, mid)\\n        return searchMatrix(0, len(matrix)-1, None)\\n```\n```Time Complexity: O(logN) + O(logM)```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int):\\n        lo, hi = 0, len(matrix) * len(matrix[0]) - 1\\n        \\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            r = mid // len(matrix[0])\\n            c = mid % len(matrix[0])\\n            if matrix[r][c] == target: return True\\n            if target > matrix[r][c]: lo = mid + 1\\n            else: hi = mid - 1\\n        return False\\n```\n```Time Complexity: O(log(M*N))```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int):\\n        def search(lo, hi):\\n            if lo > hi: return False\\n            mid = (lo + hi) // 2\\n            curr = matrix[mid // len(matrix[0])][mid % len(matrix[0])]\\n            if target > curr: return search(mid + 1, hi)\\n            if target < curr: return search(lo, mid - 1)\\n            return True\\n        return search(0, len(matrix[0]) * len(matrix) - 1)\\n```\n```Time Complexity: O(log(M*N))```",
                "codeTag": "Java"
            },
            {
                "id": 3878068,
                "title": "detailed-easy-to-understand-with-comments-in-each-line",
                "content": "# Intuition\\n```Described in code segments each line by line with comments details```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        // Get the number of rows and columns in the matrix\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        \\n        // Initialize low index to the first row and high index to the last column\\n        int low = 0, high = cols - 1;\\n        \\n        // Loop while low index is within row range and high index is within column range\\n        while (low < rows && high > -1) {\\n            // Extract the value at the current position (low, high) in the matrix\\n            int ans = matrix[low][high];\\n            \\n            // If the current value matches the target value, return true\\n            if (ans == target) {\\n                return true;\\n            }\\n            \\n            // If the target value is greater than the current value, move to the next row\\n            if (target > ans) {\\n                low++;\\n            }\\n            // If the target value is less than or equal to the current value, move to the previous column\\n            else {\\n                high--;\\n            }\\n        }\\n        \\n        // If the loop completes without finding the target value, return false\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```Described in code segments each line by line with comments details```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        // Get the number of rows and columns in the matrix\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        \\n        // Initialize low index to the first row and high index to the last column\\n        int low = 0, high = cols - 1;\\n        \\n        // Loop while low index is within row range and high index is within column range\\n        while (low < rows && high > -1) {\\n            // Extract the value at the current position (low, high) in the matrix\\n            int ans = matrix[low][high];\\n            \\n            // If the current value matches the target value, return true\\n            if (ans == target) {\\n                return true;\\n            }\\n            \\n            // If the target value is greater than the current value, move to the next row\\n            if (target > ans) {\\n                low++;\\n            }\\n            // If the target value is less than or equal to the current value, move to the previous column\\n            else {\\n                high--;\\n            }\\n        }\\n        \\n        // If the loop completes without finding the target value, return false\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918845,
                "title": "100-fastest-swift-solution-time-o-log-nm-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(log(nm)), where n is the number of rows in the matrix, and m is the number of columns in the matrix.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func searchMatrix(_ matrix: [[Int]], _ target: Int) -> Bool {\\n        guard !matrix.isEmpty else { return false }\\n\\n        let m = matrix.count\\n        let n = matrix[0].count\\n\\n        var left = 0\\n        var right = m * n - 1\\n\\n        while left <= right {\\n            let mid = left + (right - left) / 2\\n\\n            let el = matrix[mid / n][mid % n]\\n            guard el != target else { return true }\\n\\n            if el < target {\\n                left = mid + 1\\n            } else {\\n                right = mid - 1\\n            }\\n        }\\n\\n        return false\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(log(nm)), where n is the number of rows in the matrix, and m is the number of columns in the matrix.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func searchMatrix(_ matrix: [[Int]], _ target: Int) -> Bool {\\n        guard !matrix.isEmpty else { return false }\\n\\n        let m = matrix.count\\n        let n = matrix[0].count\\n\\n        var left = 0\\n        var right = m * n - 1\\n\\n        while left <= right {\\n            let mid = left + (right - left) / 2\\n\\n            let el = matrix[mid / n][mid % n]\\n            guard el != target else { return true }\\n\\n            if el < target {\\n                left = mid + 1\\n            } else {\\n                right = mid - 1\\n            }\\n        }\\n\\n        return false\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516367,
                "title": "python3-2-approaches-beats-98",
                "content": "```python3 []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        r, c = 0, len(matrix[0]) - 1\\n\\n        while r < len(matrix) and c >= 0:\\n            if matrix[r][c] < target: r += 1\\n            elif matrix[r][c] > target: c -= 1\\n            else: return True\\n        \\n        return False\\n```\\n```python3 []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        R, C = len(matrix), len(matrix[0])\\n        l, r = 0, R*C-1\\n\\n        while l <= r:\\n            mid = l + (r-l)//2\\n            row, col = mid // C, mid % C\\n            if matrix[row][col] < target:\\n                l = mid + 1\\n            elif matrix[row][col] > target:\\n                r = mid - 1\\n            else:\\n                return True\\n\\n        return False\\n```\\n![Screenshot 2023-07-03 at 00.19.08.png](https://assets.leetcode.com/users/images/e1de02b7-438b-421b-9332-35e8e12c8d22_1688332922.8146224.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        r, c = 0, len(matrix[0]) - 1\\n\\n        while r < len(matrix) and c >= 0:\\n            if matrix[r][c] < target: r += 1\\n            elif matrix[r][c] > target: c -= 1\\n            else: return True\\n        \\n        return False\\n```\n```python3 []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        R, C = len(matrix), len(matrix[0])\\n        l, r = 0, R*C-1\\n\\n        while l <= r:\\n            mid = l + (r-l)//2\\n            row, col = mid // C, mid % C\\n            if matrix[row][col] < target:\\n                l = mid + 1\\n            elif matrix[row][col] > target:\\n                r = mid - 1\\n            else:\\n                return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863617,
                "title": "python-5-different-solutions",
                "content": "\\u2714 **Solution 1:** Linear Search\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == target: return True\\n        return False\\n```\\n***\\n```Time Complexity: O(M*N)```\\n***\\n\\u2714 **Solution 2:** Binary Search Iterative\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        lo, hi = 0, len(matrix) - 1\\n        while lo <= hi:\\n            midRow = (lo + hi) // 2\\n            row = matrix[midRow]\\n            if target < row[0]: hi = midRow - 1\\n            elif target > row[-1]: lo = midRow + 1\\n            else:\\n                l, h = 0, len(row) - 1\\n                while l <= h:\\n                    mid = (l + h) // 2\\n                    if row[mid] == target: return True\\n                    elif target > row[mid]: l = mid + 1\\n                    else: h = mid - 1\\n                return False\\n```\\n***\\n```Time Complexity: O(logM) + O(logN)```\\n***\\n\\u2714 **Solution 3:** Binary Search Recursive\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int):\\n        def searchMatrix(lo, hi, row):\\n            if lo > hi: return False\\n            mid = (lo + hi) // 2\\n            if row is not None:\\n                if matrix[row][mid] == target: return True\\n                if target > matrix[row][mid]: return searchMatrix(mid + 1, hi, row)\\n                return searchMatrix(lo, mid - 1, row)\\n            if target < matrix[mid][0]: return searchMatrix(lo, mid - 1, row)\\n            if target > matrix[mid][-1]: return searchMatrix(mid + 1, hi, row)\\n            return searchMatrix(0, len(matrix[0]) - 1, mid)\\n        return searchMatrix(0, len(matrix)-1, None)\\n```\\n***\\n```Time Complexity: O(logN) + O(logM)```\\n***\\n\\n\\u2714 **Solution 4:** Binary Search iterative by visualizing as a 1D array\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int):\\n        lo, hi = 0, len(matrix) * len(matrix[0]) - 1\\n        \\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            r = mid // len(matrix[0])\\n            c = mid % len(matrix[0])\\n            if matrix[r][c] == target: return True\\n            if target > matrix[r][c]: lo = mid + 1\\n            else: hi = mid - 1\\n        return False\\n```\\n***\\n```Time Complexity: O(log(M*N))```\\n***\\n\\n\\u2714 **Solution 5:** Binary Search Recursive by visualizing as a 1D array\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int):\\n        def search(lo, hi):\\n            if lo > hi: return False\\n            mid = (lo + hi) // 2\\n            curr = matrix[mid // len(matrix[0])][mid % len(matrix[0])]\\n            if target > curr: return search(mid + 1, hi)\\n            if target < curr: return search(lo, mid - 1)\\n            return True\\n        return search(0, len(matrix[0]) * len(matrix) - 1)\\n```\\n***\\n```Time Complexity: O(log(M*N))```\\n***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == target: return True\\n        return False\\n```\n```Time Complexity: O(M*N)```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        lo, hi = 0, len(matrix) - 1\\n        while lo <= hi:\\n            midRow = (lo + hi) // 2\\n            row = matrix[midRow]\\n            if target < row[0]: hi = midRow - 1\\n            elif target > row[-1]: lo = midRow + 1\\n            else:\\n                l, h = 0, len(row) - 1\\n                while l <= h:\\n                    mid = (l + h) // 2\\n                    if row[mid] == target: return True\\n                    elif target > row[mid]: l = mid + 1\\n                    else: h = mid - 1\\n                return False\\n```\n```Time Complexity: O(logM) + O(logN)```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int):\\n        def searchMatrix(lo, hi, row):\\n            if lo > hi: return False\\n            mid = (lo + hi) // 2\\n            if row is not None:\\n                if matrix[row][mid] == target: return True\\n                if target > matrix[row][mid]: return searchMatrix(mid + 1, hi, row)\\n                return searchMatrix(lo, mid - 1, row)\\n            if target < matrix[mid][0]: return searchMatrix(lo, mid - 1, row)\\n            if target > matrix[mid][-1]: return searchMatrix(mid + 1, hi, row)\\n            return searchMatrix(0, len(matrix[0]) - 1, mid)\\n        return searchMatrix(0, len(matrix)-1, None)\\n```\n```Time Complexity: O(logN) + O(logM)```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int):\\n        lo, hi = 0, len(matrix) * len(matrix[0]) - 1\\n        \\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            r = mid // len(matrix[0])\\n            c = mid % len(matrix[0])\\n            if matrix[r][c] == target: return True\\n            if target > matrix[r][c]: lo = mid + 1\\n            else: hi = mid - 1\\n        return False\\n```\n```Time Complexity: O(log(M*N))```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int):\\n        def search(lo, hi):\\n            if lo > hi: return False\\n            mid = (lo + hi) // 2\\n            curr = matrix[mid // len(matrix[0])][mid % len(matrix[0])]\\n            if target > curr: return search(mid + 1, hi)\\n            if target < curr: return search(lo, mid - 1)\\n            return True\\n        return search(0, len(matrix[0]) * len(matrix) - 1)\\n```\n```Time Complexity: O(log(M*N))```",
                "codeTag": "Java"
            },
            {
                "id": 1369420,
                "title": "c-time-o-r-c-my-beautiful-piece-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& a, int target) \\n    {\\n        int i = 0, j = a[0].size() - 1;\\n        while (i < a.size() && j >= 0) {\\n            if (a[i][j] < target)           i++;\\n            else if (a[i][j] > target)      j--;\\n            else                            return true;   \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& a, int target) \\n    {\\n        int i = 0, j = a[0].size() - 1;\\n        while (i < a.size() && j >= 0) {\\n            if (a[i][j] < target)           i++;\\n            else if (a[i][j] > target)      j--;\\n            else                            return true;   \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26461,
                "title": "share-my-o-m-n-solution",
                "content": "I search from right up corner:row=0,col=m-1\\n  \\n\\n 1. if matrix[row][col] is equal target,return true.\\n 2. if matrix[row][col] is less than target, row++;  indicate that this row can't contain target.because this one in this line is the biggest one,counting from 'row'.\\n 3. if matrix[row][col] is greater than target,col--;   indicate that this column can't contain target.because this one in this column is the smallest one,counting from 'col'.\\n\\n\\n----------\\n\\n\\n    class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int> > &matrix, int target) {\\n            if(matrix.empty())return false;\\n            int n=matrix.size(),m=matrix[0].size(),row=0,col=m-1;\\n            while(row<n&&col>=0){\\n                if(matrix[row][col]==target)return true;\\n                else if(matrix[row][col]<target)row++;\\n                else col--;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int> > &matrix, int target) {\\n            if(matrix.empty())return false;\\n            int n=matrix.size(),m=matrix[0].size(),row=0,col=m-1;\\n            while(row<n&&col>=0){\\n                if(matrix[row][col]==target)return true;\\n                else if(matrix[row][col]<target)row++;\\n                else col--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2760040,
                "title": "binary-search-time-complexity-space-complexity-explanation",
                "content": "In case you want to read a more brute-force solution: https://github.com/Arya-Gupta/LeetCode/tree/main/74.%20Search%20a%202D%20Matrix\\nAnother version of this problem: https://leetcode.com/problems/search-a-2d-matrix-ii/\\nSolution: https://leetcode.com/problems/search-a-2d-matrix-ii/discuss/2760056/Binary-Search-Time-Complexity-%2B-Space-Complexity-%2B-Explanation\\n\\nTime Complexity - Time taken to perform binary search on (row * col) elements is O(log(row * col)).\\nSpace Complexity - Space taken is O(1).\\nExplanation - A prerequisite to this problem would be to know how the original binary search works: https://github.com/Arya-Gupta/LeetCode/tree/main/704.%20Binary%20Search\\n\\nIf we consider all the elements in a matrix to be in an array, then that array will be sorted.\\n*Example:*\\n1  3  5  7\\n10 11 16 20\\n23 30 34 60\\n\\nThe above matrix in the form of an array is 1, 3, 5, 7, 10, 11, 16, 20, 23, 30, 34, 60.\\nWe can perform binary search on this sorted array to find the target element in O(log(row * col)).\\nHowever, creating an array from the matrix would take O(row * col) space.\\n\\nThus we treat the given matrix as an array. For any index in our array, we can get its corresponding position of the matrix.\\nThe row number is given by array index / total no of columns, while the column number is given by array index % total no of columns.\\nWe can now perform binary search by treating this matrix as one single array.\\n\\n```\\nclass Solution {\\npublic:    \\n    bool searchMatrix(vector<vector<int>>& matrix, int target){\\n        int row = matrix.size(), col = matrix[0].size(), start = 0, end = row * col - 1, mid, num;\\n        while(start <= end){\\n            mid = start + (end - start) / 2;\\n            num = matrix[mid / col][mid % col];\\n            if(num == target) return true;\\n            else if(target > num) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nKindly upvote if you found the solution helpful :)\\n**For more such explanations of LeetCode problems along with their C++ solutions:**\\nhttps://github.com/Arya-Gupta/LeetCode",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Matrix",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    bool searchMatrix(vector<vector<int>>& matrix, int target){\\n        int row = matrix.size(), col = matrix[0].size(), start = 0, end = row * col - 1, mid, num;\\n        while(start <= end){\\n            mid = start + (end - start) / 2;\\n            num = matrix[mid / col][mid % col];\\n            if(num == target) return true;\\n            else if(target > num) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732180,
                "title": "c-efficient-binary-search-easy-solution",
                "content": "#### If you understand the approach please please upvote!!!\\n***Thanks :)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(!matrix.size()) return false;\\n        int n=matrix.size();//rows no\\n        int m=matrix[0].size();//cols no\\n        int lo=0;\\n        int hi=n*m -1;\\n        while(lo<=hi){\\n            int mid=lo+ (hi-lo)/2;//to control overflow condition\\n            if(matrix[mid/m][mid%m]==target){\\n                return true;\\n            }\\n            if(matrix[mid/m][mid%m]>target){\\n                hi=mid-1;\\n            }else{\\n                lo =mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(!matrix.size()) return false;\\n        int n=matrix.size();//rows no\\n        int m=matrix[0].size();//cols no\\n        int lo=0;\\n        int hi=n*m -1;\\n        while(lo<=hi){\\n            int mid=lo+ (hi-lo)/2;//to control overflow condition\\n            if(matrix[mid/m][mid%m]==target){\\n                return true;\\n            }\\n            if(matrix[mid/m][mid%m]>target){\\n                hi=mid-1;\\n            }else{\\n                lo =mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897996,
                "title": "java-clean-code-binary-search-technique-o-log-m-log-n-time-complexity",
                "content": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        int r1 = 0;\\n        int r2 = matrix.length - 1;\\n        int c1 = 0;\\n        int c2 = matrix[0].length - 1;\\n        \\n        while (r1 < r2) {\\n            int mid = (r1 + r2) / 2;\\n            if (matrix[mid][c2] == target) {\\n                return true;\\n            }\\n            else if (target < matrix[mid][c2]) {\\n                r2 = mid;\\n            }\\n            else {\\n                r1 = mid + 1;\\n            }\\n        }\\n        \\n        while (c1 <= c2) {\\n            int mid = (c1 + c2) / 2;\\n            if (matrix[r2][mid] == target) {\\n                return true;\\n            }\\n            else if (target < matrix[r2][mid]) {\\n                c2 = mid - 1;\\n            }\\n            else {\\n                c1 = mid + 1;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        int r1 = 0;\\n        int r2 = matrix.length - 1;\\n        int c1 = 0;\\n        int c2 = matrix[0].length - 1;\\n        \\n        while (r1 < r2) {\\n            int mid = (r1 + r2) / 2;\\n            if (matrix[mid][c2] == target) {\\n                return true;\\n            }\\n            else if (target < matrix[mid][c2]) {\\n                r2 = mid;\\n            }\\n            else {\\n                r1 = mid + 1;\\n            }\\n        }\\n        \\n        while (c1 <= c2) {\\n            int mid = (c1 + c2) / 2;\\n            if (matrix[r2][mid] == target) {\\n                return true;\\n            }\\n            else if (target < matrix[r2][mid]) {\\n                c2 = mid - 1;\\n            }\\n            else {\\n                c1 = mid + 1;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895889,
                "title": "6-approaches-brute-force-row-search-column-search-one-binary-search-2d-coordinate-axis",
                "content": "[Leetcode](https://leetcode.com/) [74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/).\\n\\n***By Frank Luo***\\n\\nHere are **6** approaches to solve this problem: **Brute Force**, Binary Search(**Row**), Binary Search(**Column**), One Binary Search and $2D$ **Coordinate Axis**.\\n\\n\\n# BF(2 Loops)\\n\\nIt\\'s easy to use $2$ **Loops** to traverse the entire matrix to find the target.\\n\\n```java\\n    // BF\\n    public static boolean searchMatrix_bf(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (matrix[i][j] == target) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\\n\\nNotice that the first integer of each row is greater than the last integer of the previous row.\\n\\nWe can optimize the code before.\\n\\n```java\\n    // BF Opt\\n    public static boolean searchMatrix_bf_opt(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        if (matrix[0][0] > target || matrix[row - 1][col - 1] < target) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < row; i++) {\\n            if (target >= matrix[i][0] && target <= matrix[i][col - 1]) {\\n                for (int j = 0; j < col; j++) {\\n                    if (matrix[i][j] == target) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(m \\\\times n)$\\n- **Space Complexity**: $O(1)$\\n\\n\\n# Find Row First, then Column Binary Search\\n\\nWe can scanning the rows of the matrix, If the $\\\\textit{target}$ is larger than the last element of this row, the target must not be in this row, but only in the lower row of the matrix.\\n\\nIf we find the row which the target may appears, search this row.\\n\\n\\n```java\\n    // Row Scan + Column BinarySearch\\n    public static boolean searchMatrix_bs(int[][] matrix, int target) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        if (matrix[0][0] > target || matrix[row - 1][col - 1] < target) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < row; i++) {\\n            if (target >= matrix[i][0] && target <= matrix[i][col - 1]) {\\n                if (binarySearch(matrix[i], target) != -1) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    public static int binarySearch(int[] arr, int target) {\\n        int start = 0;\\n        int end = arr.length - 1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (arr[mid] > target) {\\n                end = mid - 1;\\n            } else if (arr[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                return mid;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(m + logn)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n# 2 Binary Search: Row and Column\\n\\nUsing the binary search on the elements of the first column of the matrix, find the last element that is not larger than the $\\\\textit{target}$, the $\\\\textit{target}$ may be located in the row. \\n\\nSearch the row where the target was located.\\n\\n```java\\n    public static boolean searchMatrix_two_bs(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        if (matrix[0][0] > target || matrix[row - 1][col - 1] < target) {\\n            return false;\\n        }\\n\\n        int rowIdx = binarySearchColumn(matrix, target);\\n        return binarySearchRow(matrix[rowIdx], target);\\n    }\\n\\n    public static int binarySearchColumn(int[][] arr, int target) {\\n        int left = 0;\\n        int right = arr.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left + 1) / 2;\\n            if (arr[mid][0] <= target) {\\n                left = mid;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n\\n    public static boolean binarySearchRow(int[] arr, int target) {\\n        int left = 0;\\n        int right = arr.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr[mid] > target) {\\n                right = mid - 1;\\n            } else if (arr[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                return true;\\n            }\\n        }\\n\\n        return arr[left] == target;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(logm + logn)$\\n- **Space Complexity**: $O(1)$\\n\\n\\n# One Binary Search\\n\\n**Merge** the current row to the end of the previous row, we can get **an ascending array**, then we just use binary search algorithm to find the target.\\n\\n```java\\n    // 1 Binary Search: from top left to bottom right\\n    public static boolean searchMatrix_one_bs(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        if (matrix[0][0] > target || matrix[row - 1][col - 1] < target) {\\n            return false;\\n        }\\n\\n        int left = 0;\\n        int right = row * col - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (matrix[mid / col][mid % col] == target) {\\n                return true;\\n            } else if (matrix[mid / col][mid % col] > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(log{mn})$\\n- **Space Complexity**: $O(1)$\\n\\n\\n# 2D Coordinate Axis\\n\\nThe $2D$ array increases from left to right and from top to bottom.\\n\\n1. Each column, all the numbers above are all smaller than it.\\n2. Each row, the right of the number are all larger than it.\\n\\nTherefore, the algorithm is as follows:\\n\\n1. From the bottom left corner of the $2D$ array as the origin, take it as a $2D$ **coordinate axis**;\\n2. If the current number is **larger than** the $\\\\textit{target}$, moves up;\\n3. If the current number is **less than** the $\\\\textit{target}$, move right.\\n\\n```java\\n    // 2D Coordinate Axis\\n    public static boolean searchMatrix_2d_axis(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        if (matrix[0][0] > target || matrix[row - 1][col - 1] < target) {\\n            return false;\\n        }\\n\\n        int i = row - 1;\\n        int j = 0;\\n\\n        while (i >= 0 && j < col) {\\n            int num = matrix[i][j];\\n            if (num > target) {\\n                i--;\\n            } else if (num < target) {\\n                j++;\\n            } else if (num == target) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(m + n)$\\n- **Space Complexity**: $O(1)$\\n\\n\\n# Reshape\\n\\nIt\\'s easy to reshape to $1-D$ array in python, then search as a $1-D$ array.\\n\\n```python\\nimport numpy as np\\nclass Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        matrix = np.reshape(matrix, [1, -1])\\n        return target in matrix\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(mn+log{mn})$\\n- **Space Complexity**: $O(mn)$\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```java\\n    // BF\\n    public static boolean searchMatrix_bf(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (matrix[i][j] == target) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\n```java\\n    // BF Opt\\n    public static boolean searchMatrix_bf_opt(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        if (matrix[0][0] > target || matrix[row - 1][col - 1] < target) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < row; i++) {\\n            if (target >= matrix[i][0] && target <= matrix[i][col - 1]) {\\n                for (int j = 0; j < col; j++) {\\n                    if (matrix[i][j] == target) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\n```java\\n    // Row Scan + Column BinarySearch\\n    public static boolean searchMatrix_bs(int[][] matrix, int target) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        if (matrix[0][0] > target || matrix[row - 1][col - 1] < target) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < row; i++) {\\n            if (target >= matrix[i][0] && target <= matrix[i][col - 1]) {\\n                if (binarySearch(matrix[i], target) != -1) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    public static int binarySearch(int[] arr, int target) {\\n        int start = 0;\\n        int end = arr.length - 1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (arr[mid] > target) {\\n                end = mid - 1;\\n            } else if (arr[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                return mid;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n```\n```java\\n    public static boolean searchMatrix_two_bs(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        if (matrix[0][0] > target || matrix[row - 1][col - 1] < target) {\\n            return false;\\n        }\\n\\n        int rowIdx = binarySearchColumn(matrix, target);\\n        return binarySearchRow(matrix[rowIdx], target);\\n    }\\n\\n    public static int binarySearchColumn(int[][] arr, int target) {\\n        int left = 0;\\n        int right = arr.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left + 1) / 2;\\n            if (arr[mid][0] <= target) {\\n                left = mid;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n\\n    public static boolean binarySearchRow(int[] arr, int target) {\\n        int left = 0;\\n        int right = arr.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr[mid] > target) {\\n                right = mid - 1;\\n            } else if (arr[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                return true;\\n            }\\n        }\\n\\n        return arr[left] == target;\\n    }\\n```\n```java\\n    // 1 Binary Search: from top left to bottom right\\n    public static boolean searchMatrix_one_bs(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        if (matrix[0][0] > target || matrix[row - 1][col - 1] < target) {\\n            return false;\\n        }\\n\\n        int left = 0;\\n        int right = row * col - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (matrix[mid / col][mid % col] == target) {\\n                return true;\\n            } else if (matrix[mid / col][mid % col] > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\n```java\\n    // 2D Coordinate Axis\\n    public static boolean searchMatrix_2d_axis(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        if (matrix[0][0] > target || matrix[row - 1][col - 1] < target) {\\n            return false;\\n        }\\n\\n        int i = row - 1;\\n        int j = 0;\\n\\n        while (i >= 0 && j < col) {\\n            int num = matrix[i][j];\\n            if (num > target) {\\n                i--;\\n            } else if (num < target) {\\n                j++;\\n            } else if (num == target) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\n```python\\nimport numpy as np\\nclass Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        matrix = np.reshape(matrix, [1, -1])\\n        return target in matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500429,
                "title": "search-a-2d-matrix-c-o-m-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n\\t\\t// m = total rows\\n\\t\\t// n = total columns\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n\\t\\t// Start from top-right corner \\n        int row = 0, col = n-1;\\n        \\n\\t\\t// Traverse the matrix\\n        while(row < m && col >= 0)\\n        {\\n\\t\\t\\t// If target found\\n            if(matrix[row][col] == target)\\n                return true;\\n            \\n\\t\\t\\t// If target is smaller than current element - decrement col \\n            if(matrix[row][col] > target)\\n                col--;\\n\\t\\t\\t\\t\\n\\t\\t\\t// If target is greater than current element - increment row\\n            else\\n                row++;\\n        }\\n        \\n\\t\\t// Target not found\\n        return false;\\n    }\\n};\\n```\\n**If you like then do upvote\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n\\t\\t// m = total rows\\n\\t\\t// n = total columns\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n\\t\\t// Start from top-right corner \\n        int row = 0, col = n-1;\\n        \\n\\t\\t// Traverse the matrix\\n        while(row < m && col >= 0)\\n        {\\n\\t\\t\\t// If target found\\n            if(matrix[row][col] == target)\\n                return true;\\n            \\n\\t\\t\\t// If target is smaller than current element - decrement col \\n            if(matrix[row][col] > target)\\n                col--;\\n\\t\\t\\t\\t\\n\\t\\t\\t// If target is greater than current element - increment row\\n            else\\n                row++;\\n        }\\n        \\n\\t\\t// Target not found\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244568,
                "title": "easy-java-solution-two-pointer-0ms-faster-than-100-beginner-friendly",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n         int rowPointer = 0;\\n        int colPointer = matrix[0].length-1;\\n        while(rowPointer < matrix.length && colPointer >= 0){\\n            if(matrix[rowPointer][colPointer] == target) return true;\\n            else if(matrix[rowPointer][colPointer] > target) colPointer--;\\n            else rowPointer++;\\n        }\\n        return false;\\n    }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n         int rowPointer = 0;\\n        int colPointer = matrix[0].length-1;\\n        while(rowPointer < matrix.length && colPointer >= 0){\\n            if(matrix[rowPointer][colPointer] == target) return true;\\n            else if(matrix[rowPointer][colPointer] > target) colPointer--;\\n            else rowPointer++;\\n        }\\n        return false;\\n    }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548563,
                "title": "3-solutions-in-c",
                "content": "```\\nUpvote is appreciated.\\n```\\n\\n1. O(m * n) solution in which we are iterating all elements and finding the target.\\n```\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(); // no. of rows\\n        int n = matrix[0].size(); // no. of columns\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(matrix[i][j] == target) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n```\\n\\n\\n2. O(m + n) solution\\nHere the question stated that the elements in each row are sorted and that the first element in the next row was greater than the last element in the previous row. Therefore, the matrix is column wise sorted as well.\\nThis question is same as search in row-wise and column-wise sorted matrix.\\n\\n```\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = 0;\\n        int n = matrix[0].size() - 1;\\n        while(m < matrix.size() && n >= 0)\\n        {\\n            if(matrix[m][n] == target) return true;\\n            if(matrix[m][n] > target) n = n - 1;\\n            else  m = m + 1;\\n        }\\n        return false;\\n    }\\n```\\n\\n3. O(m log n) solution\\nIn this we search the target in each row using binary search.\\n```\\n     bool find(vector<int>& nums, int target) {\\n        int i = 0, j = nums.size() - 1;\\n        while(i <= j)\\n        {\\n            int mid = i + (j - i)/2;\\n            if(nums[mid] == target) return true;\\n            if(nums[mid] > target) j = mid - 1;\\n            else i = mid + 1;\\n        }\\n        return false;\\n    }\\n    \\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i = 0; i < matrix.size(); i++)\\n        {\\n            if(find(matrix[i], target)) return true;\\n        }\\n        return false;\\n    } \\n```",
                "solutionTags": [],
                "code": "```\\nUpvote is appreciated.\\n```\n```\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(); // no. of rows\\n        int n = matrix[0].size(); // no. of columns\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(matrix[i][j] == target) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n```\n```\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = 0;\\n        int n = matrix[0].size() - 1;\\n        while(m < matrix.size() && n >= 0)\\n        {\\n            if(matrix[m][n] == target) return true;\\n            if(matrix[m][n] > target) n = n - 1;\\n            else  m = m + 1;\\n        }\\n        return false;\\n    }\\n```\n```\\n     bool find(vector<int>& nums, int target) {\\n        int i = 0, j = nums.size() - 1;\\n        while(i <= j)\\n        {\\n            int mid = i + (j - i)/2;\\n            if(nums[mid] == target) return true;\\n            if(nums[mid] > target) j = mid - 1;\\n            else i = mid + 1;\\n        }\\n        return false;\\n    }\\n    \\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i = 0; i < matrix.size(); i++)\\n        {\\n            if(find(matrix[i], target)) return true;\\n        }\\n        return false;\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1175274,
                "title": "find-what-s-difficult-in-a-problem-and-think-how-to-get-rid-of-it",
                "content": "When you are dealt with a difficult problem, think about what makes it difficult. In this case, it\\'s the fact that you\\'re dealing with a 2d matrix. However, if you flatten the 2d matrix you get a sorted list! You (should) already know how to do binary search on a flat sorted list. Changing the matrix to a flattened list will take time sadly as that\\'s O(N). However, we don\\'t have to change it to a sorted list. Consider the list\\n```\\n[1, 2, 4]\\n[8, 16, 32]\\n[64, 128, 256]\\n```\\nLet\\'s see what would happen if we supposedly flattened it. We would get \\n```\\n[1, 2, 4, 8, 16, 32, 64, 128, 256].\\n```\\nNow, the 7th position of the flattened list is 128. It\\'s [2, 1] in the 2d matrix. 2 * 3 + 1 = 7. 3 is the horizontal length of the matrix. Is that a coincidence? No. You can think that 2 is how many times you go through full lists, and 1 as how far you get in the last list. From that, 2 * 3 + 1 = 7. So,\\n```\\npiv = (left + right) // 2\\npiv_x, piv_y = piv // n, piv % n\\n```\\nwhere piv is the normal pivot in binary search and piv_x and piv_y is are the x and y coordinates in the 2d matrix.\\n\\nI now present to you a readable, no  library function log(mn) solution that beats 96% in time and 95% in memory:\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        m, n = len(matrix), len(matrix[0])\\n        left, right = 0, m * n - 1\\n        \\n        while left <= right:\\n            piv = (left + right) // 2\\n            piv_x, piv_y = piv // n, piv % n\\n            \\n            if matrix[piv_x][piv_y] == target:\\n                return True\\n            elif matrix[piv_x][piv_y] < target:\\n                left = piv + 1\\n            else:\\n                right = piv - 1\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\n[1, 2, 4]\\n[8, 16, 32]\\n[64, 128, 256]\\n```\n```\\n[1, 2, 4, 8, 16, 32, 64, 128, 256].\\n```\n```\\npiv = (left + right) // 2\\npiv_x, piv_y = piv // n, piv % n\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        m, n = len(matrix), len(matrix[0])\\n        left, right = 0, m * n - 1\\n        \\n        while left <= right:\\n            piv = (left + right) // 2\\n            piv_x, piv_y = piv // n, piv % n\\n            \\n            if matrix[piv_x][piv_y] == target:\\n                return True\\n            elif matrix[piv_x][piv_y] < target:\\n                left = piv + 1\\n            else:\\n                right = piv - 1\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874110,
                "title": "c-o-n-m-linear-search-o-logn-m-binary-search",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Linear Search:**\\n* for each cell: ```mat[i[[j] > mat[i][j-1] and mat[i][j] < mat[i+1][j]```\\n* if ```mat[i[[j] > target```, so target must be left side, so we move leftwards\\n* if ```mat[i[[j] < target```, so target must be down side, so we move downwards\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int n=mat.size(), m=mat[0].size();\\n        \\n        for(int i=0,j=m-1;i<n && j>=0;){\\n            int x=mat[i][j];\\n            if(x==target){\\n                return true;\\n            }else if(x>target){\\n                j--;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Binary Search:**\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int n=mat.size(), m=mat[0].size();\\n        int l=0, r=n*m-1;\\n        \\n        while(l <= r){\\n            int mid = l+(r-l)/2;\\n            int x = mat[mid/m][mid%m];\\n            \\n            if(x > target){\\n                r = mid-1;\\n            }else if(x < target){\\n                l = mid+1;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```mat[i[[j] > mat[i][j-1] and mat[i][j] < mat[i+1][j]```\n```mat[i[[j] > target```\n```mat[i[[j] < target```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int n=mat.size(), m=mat[0].size();\\n        \\n        for(int i=0,j=m-1;i<n && j>=0;){\\n            int x=mat[i][j];\\n            if(x==target){\\n                return true;\\n            }else if(x>target){\\n                j--;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int n=mat.size(), m=mat[0].size();\\n        int l=0, r=n*m-1;\\n        \\n        while(l <= r){\\n            int mid = l+(r-l)/2;\\n            int x = mat[mid/m][mid%m];\\n            \\n            if(x > target){\\n                r = mid-1;\\n            }else if(x < target){\\n                l = mid+1;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455215,
                "title": "100-beats-java-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. we will find the row that contains our target element.\\n2. To that we compare target to last element of each row.\\n3. If target <= last element then we will apply binary-search on that row.\\n4. when we get target element we will return true.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$ O(m logn) $$ where m is number of rows in matrix.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$ O(1) $$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        for(int i = 0; i < matrix.length; i++){\\n            int n = matrix[i].length - 1;\\n            // Finding that row.\\n            if(target <= matrix[i][n]){\\n                // Binary Search\\n                int s = 0;\\n                int e = n;\\n                while(s <= e){\\n                    int mid = s + (e - s)/2;\\n                    if(matrix[i][mid] == target)\\n                        return true;\\n                    else if(matrix[i][mid] < target){\\n                        s = mid + 1;\\n                    }else{\\n                        e = mid - 1;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        for(int i = 0; i < matrix.length; i++){\\n            int n = matrix[i].length - 1;\\n            // Finding that row.\\n            if(target <= matrix[i][n]){\\n                // Binary Search\\n                int s = 0;\\n                int e = n;\\n                while(s <= e){\\n                    int mid = s + (e - s)/2;\\n                    if(matrix[i][mid] == target)\\n                        return true;\\n                    else if(matrix[i][mid] < target){\\n                        s = mid + 1;\\n                    }else{\\n                        e = mid - 1;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194887,
                "title": "python-binary-search-clean-simple-o-log-m-n",
                "content": "\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## O(m+n) Solution :\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows, cols = len(matrix), len(matrix[0])\\n        row = 0\\n        for i in range(rows):\\n            if matrix[i][0] > target:\\n                row = i - 1\\n                break\\n        else:\\n            row = rows - 1\\n            \\n        for j in range(cols):\\n            if matrix[row][j] == target:\\n                return True\\n        return False\\n```\\n## Binary Search :\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        \\n        # Binary Search\\n        row, col = len(matrix), len(matrix[0])\\n        i, j = 0, (row * col) - 1\\n\\n        while i <= j:\\n            mid = (i + j) >> 1\\n            mid_element = matrix[mid // col][mid % col] \\n            if mid_element == target:\\n                return True\\n            elif mid_element < target:\\n                i = mid + 1\\n            else:\\n                j = mid - 1\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows, cols = len(matrix), len(matrix[0])\\n        row = 0\\n        for i in range(rows):\\n            if matrix[i][0] > target:\\n                row = i - 1\\n                break\\n        else:\\n            row = rows - 1\\n            \\n        for j in range(cols):\\n            if matrix[row][j] == target:\\n                return True\\n        return False\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        \\n        # Binary Search\\n        row, col = len(matrix), len(matrix[0])\\n        i, j = 0, (row * col) - 1\\n\\n        while i <= j:\\n            mid = (i + j) >> 1\\n            mid_element = matrix[mid // col][mid % col] \\n            if mid_element == target:\\n                return True\\n            elif mid_element < target:\\n                i = mid + 1\\n            else:\\n                j = mid - 1\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095682,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\nFirst we need to convert this 2D array into 1D array\\nand then we can apply binary search to it for minimum complexity\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(log(row*col))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = row*col - 1;\\n\\n        int mid = (start+end)/2;\\n\\n        while(start<=end){\\n            int element = matrix[mid/col][mid%col];\\n\\n            if(element==target){\\n                return 1;\\n            }\\n\\n            if(element<target){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }\\n            mid = (start+end)/2;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = row*col - 1;\\n\\n        int mid = (start+end)/2;\\n\\n        while(start<=end){\\n            int element = matrix[mid/col][mid%col];\\n\\n            if(element==target){\\n                return 1;\\n            }\\n\\n            if(element<target){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }\\n            mid = (start+end)/2;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059952,
                "title": "python-binary-search-beats-90",
                "content": "```\\nclass Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        nRows =  len(matrix)\\n        nCols = len(matrix[0])\\n        \\n        row = nRows-1\\n        col = 0\\n        \\n        while 0 <= row < nRows and 0 <= col < nCols:\\n            val = matrix[row][col]\\n            if val == target:\\n                return True\\n            elif val < target:\\n                col += 1\\n            else:\\n                row -= 1\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        nRows =  len(matrix)\\n        nCols = len(matrix[0])\\n        \\n        row = nRows-1\\n        col = 0\\n        \\n        while 0 <= row < nRows and 0 <= col < nCols:\\n            val = matrix[row][col]\\n            if val == target:\\n                return True\\n            elif val < target:\\n                col += 1\\n            else:\\n                row -= 1\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26217,
                "title": "10-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size() == 0) return false;\\n        int m = matrix.size(), n = matrix[0].size(), l = 0, r = m * n - 1;\\n        while(l <= r){\\n            int mid = l + (r - l) / 2;\\n            int val = matrix[mid/n][mid%n];\\n            if(val > target) r = mid - 1;\\n            else if(val < target) l = mid + 1;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size() == 0) return false;\\n        int m = matrix.size(), n = matrix[0].size(), l = 0, r = m * n - 1;\\n        while(l <= r){\\n            int mid = l + (r - l) / 2;\\n            int val = matrix[mid/n][mid%n];\\n            if(val > target) r = mid - 1;\\n            else if(val < target) l = mid + 1;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874166,
                "title": "binary-search-in-o-log-m-n",
                "content": "# Intuition\\nImagine playing a game of hide and seek with numbers in a matrix. The numbers are sorted, and each row starts with a number greater than the last number of the previous row. Your goal is to find a particular number, the target. Now, you could check every single spot (or number) in the matrix, but that would take a while, right? What if we could eliminate half of the possible hiding spots at each step? That\\'s the magic of binary search, and that\\'s what we\\'re going to use to solve this problem.\\n\\n# Approach\\nOur Go solution takes the matrix and the target as inputs and uses binary search to check if the target is in the matrix. Here\\'s how it works:\\n\\n1. **Initialize the Search Space**: We start by defining the boundaries of our search space. The `left` boundary is the index of the first element in the matrix, and the `right` boundary is the index of the last element. We calculate this by multiplying the number of rows `m` by the number of columns `n` and subtracting 1, because indices start at 0.\\n\\n2. **Binary Search**: We then enter a loop that continues as long as `left` is less than or equal to `right`. In each iteration, we do the following:\\n   - Calculate the `mid` index as the average of `left` and `right`.\\n   - Retrieve the `midVal` from the matrix. Since we\\'re treating the matrix as a 1D array, we calculate the row and column indices of `mid` in the matrix by performing integer division and modulus operations with `n`.\\n   - If `midVal` equals the target, we\\'ve found our number and return `true`.\\n   - If `midVal` is less than the target, we know the target must be in the right half of our search space, so we move `left` to `mid + 1`.\\n   - If `midVal` is greater than the target, we know the target must be in the left half of our search space, so we move `right` to `mid - 1`.\\n\\n3. **Return the Result**: If we exit the loop without finding the target, we know it\\'s not in the matrix and return `false`.\\n\\n# Complexity\\n- **Time complexity:** $$O(\\\\log(m \\\\times n))$$, because we\\'re performing a binary search over `m * n` elements.\\n- **Space complexity:** $$O(1)$$, because we\\'re using a fixed amount of space to store our variables, regardless of the size of the input matrix.\\n\\nI hope you enjoyed this breakdown! This problem shows how we can apply binary search in a 2D context, which can come in handy in many situations. Happy coding!\\n\\n# Code\\n``` Go []\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n    if len(matrix) == 0 {\\n        return false\\n    }\\n    m, n := len(matrix), len(matrix[0])\\n    left, right := 0, m*n-1\\n\\n    for left <= right {\\n        mid := left + (right-left)/2\\n        mid_row := mid / n\\n        mid_col := mid - mid_row*n\\n\\n        if matrix[mid_row][mid_col] == target {\\n            return true\\n        } else if matrix[mid_row][mid_col] < target {\\n            left = mid + 1\\n        } else {\\n            right = mid - 1\\n        }\\n    }\\n    return false\\n}\\n\\n```\\n``` Python []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix:\\n            return False\\n        m, n = len(matrix), len(matrix[0])\\n        left, right = 0, m * n - 1\\n\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            mid_row = mid // n\\n            mid_col = mid - mid_row * n\\n\\n            if matrix[mid_row][mid_col] == target:\\n                return True\\n            elif matrix[mid_row][mid_col] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return False\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if (matrix.empty()) return false;\\n        int m = matrix.size(), n = matrix[0].size();\\n        int left = 0, right = m * n - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int mid_row = mid / n;\\n            int mid_col = mid - mid_row * n;\\n\\n            if (matrix[mid_row][mid_col] == target) {\\n                return true;\\n            } else if (matrix[mid_row][mid_col] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Go",
                    "Binary Search"
                ],
                "code": "``` Go []\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n    if len(matrix) == 0 {\\n        return false\\n    }\\n    m, n := len(matrix), len(matrix[0])\\n    left, right := 0, m*n-1\\n\\n    for left <= right {\\n        mid := left + (right-left)/2\\n        mid_row := mid / n\\n        mid_col := mid - mid_row*n\\n\\n        if matrix[mid_row][mid_col] == target {\\n            return true\\n        } else if matrix[mid_row][mid_col] < target {\\n            left = mid + 1\\n        } else {\\n            right = mid - 1\\n        }\\n    }\\n    return false\\n}\\n\\n```\n``` Python []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix:\\n            return False\\n        m, n = len(matrix), len(matrix[0])\\n        left, right = 0, m * n - 1\\n\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            mid_row = mid // n\\n            mid_col = mid - mid_row * n\\n\\n            if matrix[mid_row][mid_col] == target:\\n                return True\\n            elif matrix[mid_row][mid_col] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return False\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if (matrix.empty()) return false;\\n        int m = matrix.size(), n = matrix[0].size();\\n        int left = 0, right = m * n - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int mid_row = mid / n;\\n            int mid_col = mid - mid_row * n;\\n\\n            if (matrix[mid_row][mid_col] == target) {\\n                return true;\\n            } else if (matrix[mid_row][mid_col] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166112,
                "title": "best-c-4-solutions-binary-search-linear-search-matrix-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Four Approaches.\\n\\n1. Solved using Matrix. TC :  O(N*M) and SC : O(1). \\n2. Solved using Array + Binary Search. TC :  O(N*log(M)) and SC : O(1).\\n3. Solved using Matrix + Binary Search. TC :  O(N+M) and SC : O(1). \\n4. Solved using Matrix + Binary Search. TC :  O(log(N*M)) and SC : O(1). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N*M), The time complexity of the Below code is O(N*M). Here nested loop creates the\\n    times complexity because we are traversing the whole matrix. Where N is the number of rows in matrix and M\\n    is the number of columns in matrix.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(auto row : matrix){\\n            for(auto col : row){\\n                if(col == target){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogM), The time complexity of the Below code is O(NlogM) since for each row we are\\n    applying binary search for M element. Where N is the number of rows in matrix and M is the number of\\n    columns in matrix.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Array + Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i=0; i<n; i++){\\n            int low = 0;\\n            int high = m-1;\\n            while(low <= high){\\n                int mid = (low + high) >> 1;\\n                if(matrix[i][mid] == target){\\n                    return true;\\n                }\\n                else if(matrix[i][mid] < target){\\n                    low = mid + 1;\\n                }\\n                else{\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N+M), The time complexity of the Below code is O(N+M) since the overall maximum number\\n    of iterations goes to N+M. Where N is the number of rows in matrix and M is the number of columns in matrix.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix + Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int i = 0;\\n        int j = m-1;\\n        while(i < n && j >= 0){\\n            int mid = (i + j) >> 1;\\n            if(matrix[i][j] == target){\\n                return true;\\n            }\\n            else if(matrix[i][j] < target){\\n                i++;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log(N*M)), The time complexity of the Below code is O(log(N*M)) since the overall maximum\\n    number of element in the matrix is N*M. Where N is the number of rows in matrix and M is the number of\\n    columns in matrix.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix + Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int low = 0;\\n        int high = (n*m)-1;\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(matrix[mid/m][mid%m] == target){\\n                return true;\\n            }\\n            else if(matrix[mid/m][mid%m] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N*M), The time complexity of the Below code is O(N*M). Here nested loop creates the\\n    times complexity because we are traversing the whole matrix. Where N is the number of rows in matrix and M\\n    is the number of columns in matrix.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(auto row : matrix){\\n            for(auto col : row){\\n                if(col == target){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogM), The time complexity of the Below code is O(NlogM) since for each row we are\\n    applying binary search for M element. Where N is the number of rows in matrix and M is the number of\\n    columns in matrix.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Array + Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i=0; i<n; i++){\\n            int low = 0;\\n            int high = m-1;\\n            while(low <= high){\\n                int mid = (low + high) >> 1;\\n                if(matrix[i][mid] == target){\\n                    return true;\\n                }\\n                else if(matrix[i][mid] < target){\\n                    low = mid + 1;\\n                }\\n                else{\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N+M), The time complexity of the Below code is O(N+M) since the overall maximum number\\n    of iterations goes to N+M. Where N is the number of rows in matrix and M is the number of columns in matrix.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix + Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int i = 0;\\n        int j = m-1;\\n        while(i < n && j >= 0){\\n            int mid = (i + j) >> 1;\\n            if(matrix[i][j] == target){\\n                return true;\\n            }\\n            else if(matrix[i][j] < target){\\n                i++;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log(N*M)), The time complexity of the Below code is O(log(N*M)) since the overall maximum\\n    number of element in the matrix is N*M. Where N is the number of rows in matrix and M is the number of\\n    columns in matrix.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix + Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int low = 0;\\n        int high = (n*m)-1;\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(matrix[mid/m][mid%m] == target){\\n                return true;\\n            }\\n            else if(matrix[mid/m][mid%m] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994113,
                "title": "o-log-n-complete-solution-0ms",
                "content": "\\n**Step 1 -first find the row, at which is the first element is smaller than  or equal to the target.\\n Step 2 - do binary search using stl or manualy**\\n  time complexity -**2*log(n)**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int findrow(vector<vector<int>>& matrix, int target){\\n        int s = 0;\\n        int e = matrix.size()-1;\\n        int row = -1;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            \\n            if(matrix[mid][0] == target){\\n                row = mid;\\n                break;\\n            }\\n            \\n            else if(matrix[mid][0]<target){\\n                row =mid;\\n                s= mid+1;\\n            }\\n            else{\\n                e = mid -1;\\n            }\\n                \\n        }\\n        return row;\\n    }\\n  \\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        if(matrix[0][0]>target || matrix[matrix.size()-1][matrix[0].size()-1]<target)\\n         return 0;\\n        \\n        int row = findrow(matrix ,target);\\n\\n        return find(matrix[row].begin(),matrix[row].end() ,target)!= matrix[row].end();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findrow(vector<vector<int>>& matrix, int target){\\n        int s = 0;\\n        int e = matrix.size()-1;\\n        int row = -1;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            \\n            if(matrix[mid][0] == target){\\n                row = mid;\\n                break;\\n            }\\n            \\n            else if(matrix[mid][0]<target){\\n                row =mid;\\n                s= mid+1;\\n            }\\n            else{\\n                e = mid -1;\\n            }\\n                \\n        }\\n        return row;\\n    }\\n  \\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        if(matrix[0][0]>target || matrix[matrix.size()-1][matrix[0].size()-1]<target)\\n         return 0;\\n        \\n        int row = findrow(matrix ,target);\\n\\n        return find(matrix[row].begin(),matrix[row].end() ,target)!= matrix[row].end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273445,
                "title": "c-beats-99-binary-search-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Solution : Traversal**\\n**Time complexity: O(N)**\\n**Space complexity: O(1)**\\n\\n**Explanation :**\\n* Initially have a starting index as 0 and ending index as the last index of 1D matrix as (row*col)-1.\\n* Now apply binary search. Run a while loop with the condition start<=end.\\n* Get the middle index as (start+end)/2.\\n* We can get the element at middle index using matrix[mid/col][mid%col].\\n* If the element present at the middle index is greater than the target, then it is obvious that the target element will not exist beyond the middle index. So shrink the search space by updating the ending index to mid-1. \\n* If the middle index element is lesser than the target, shrink the search space by updating the starting index to mid+1.\\n* If the middle index element is equal to the target, return true.\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int> >& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int start = 0;\\n        int end  = row*col-1;\\n        \\n        int mid = start + (end-start)/2;\\n        \\n        while(start<=end) {\\n            \\n            int element = matrix[mid/col][mid%col];\\n            \\n            if(element == target) {\\n                return 1;\\n            }\\n            \\n            if(element < target) {\\n                start = mid+1;\\n            }\\n            else\\n            {\\n                end = mid-1;\\n            }\\n             mid = start + (end-start)/2;    \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int> >& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int start = 0;\\n        int end  = row*col-1;\\n        \\n        int mid = start + (end-start)/2;\\n        \\n        while(start<=end) {\\n            \\n            int element = matrix[mid/col][mid%col];\\n            \\n            if(element == target) {\\n                return 1;\\n            }\\n            \\n            if(element < target) {\\n                start = mid+1;\\n            }\\n            else\\n            {\\n                end = mid-1;\\n            }\\n             mid = start + (end-start)/2;    \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896722,
                "title": "c-solution-using-binary-search-with-full-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- We\\u2019ll solve this using **Binary Search,** as the matrix is sorted according to both column and row.\\n- Let\\u2019s take a matrix as example:\\n\\n```\\nGiven Matrix:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t    0  1  2\\n\\t\\t\\t\\t\\t\\t\\t\\t   ---------------\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t0 | 1  3  5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t1 | 7  9  10\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t2 |12  15 17\\n\\nIf we convert this to a 1D matrix:\\n\\n\\t\\t\\t\\t\\t\\t0  1  2  3  4   5   6   7   8 \\n\\t\\t        \\t--------------------------------------\\n\\t\\t\\t \\t        1  3  5  7  9  10  12  15  17\\n```\\n\\n- Here we can see first 3 no. of linear space are 1st row(or total no. of columns)\\n- Now our task is to map the [row][col] of each matrix with a single integer value, in the above example:\\n\\n```\\n1st row:\\n\\t\\t\\t\\t\\t[0][0] = 0    3*0 + 0 = 0\\n\\t\\t\\t\\t\\t[0][1] = 1    3*0 + 1 = 1\\n\\t\\t\\t\\t\\t[0][2] = 2    3*0 + 2 = 2\\n```\\n\\n- So a **cell value** can be calculated by: \\n**cell value = *Total col * row + col.***\\n- To get the row we\\u2019ll divide the cell value by the total column:\\n**row *= cell value / Total col.***\\n- For columns, we have to take the remainder values when an int is divided by the column value.\\n**col *= cell value % Total col.***\\n- Now simply run Binary search algorithm & search the target.\\n- **Time complexity:** O(logn).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mt, int target) {\\n        int n = mt.size(), m = mt[0].size();\\n        int low = 0, high = m*n-1;\\n        \\n        while(low <= high){\\n            int mid = low+(high-low) / 2;\\n            int row = mid/m;\\n            int col = mid%m;\\n            \\n            if(mt[row][col] == target) return true;\\n            \\n            else if(mt[row][col] >= target) high = mid-1;\\n            \\n            else low = mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nGiven Matrix:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t    0  1  2\\n\\t\\t\\t\\t\\t\\t\\t\\t   ---------------\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t0 | 1  3  5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t1 | 7  9  10\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t2 |12  15 17\\n\\nIf we convert this to a 1D matrix:\\n\\n\\t\\t\\t\\t\\t\\t0  1  2  3  4   5   6   7   8 \\n\\t\\t        \\t--------------------------------------\\n\\t\\t\\t \\t        1  3  5  7  9  10  12  15  17\\n```\n```\\n1st row:\\n\\t\\t\\t\\t\\t[0][0] = 0    3*0 + 0 = 0\\n\\t\\t\\t\\t\\t[0][1] = 1    3*0 + 1 = 1\\n\\t\\t\\t\\t\\t[0][2] = 2    3*0 + 2 = 2\\n```\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mt, int target) {\\n        int n = mt.size(), m = mt[0].size();\\n        int low = 0, high = m*n-1;\\n        \\n        while(low <= high){\\n            int mid = low+(high-low) / 2;\\n            int row = mid/m;\\n            int col = mid%m;\\n            \\n            if(mt[row][col] == target) return true;\\n            \\n            else if(mt[row][col] >= target) high = mid-1;\\n            \\n            else low = mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735474,
                "title": "c-optimized-solution-easy",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int r=0,c=m-1;\\n        while(r<n && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            if(matrix[r][c]>target)\\n                c--;\\n            else\\n                r++;\\n        }\\n        return false;\\n    }\\n};\\n\\nfeel free to ask your doubts :)\\nand pls upvote if it was helpful :)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int r=0,c=m-1;\\n        while(r<n && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 897641,
                "title": "c-simple-solution-o-log-mn",
                "content": "Key problem is finding what the row (i) and column (j) indexes would be.\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        if(matrix.size() == 0) return false;\\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        int t = (m * n) -1;\\n        int low , high;\\n        int i, j;\\n\\n        low = 0;\\n        high = t;\\n\\n        while(low <= high) {\\n            t = (high + low) / 2;\\n            i = t / n; // get the row number.\\n            j = t % n; // get the column number.\\n                        \\n            if(matrix[i][j] == target)\\n                return true;\\n            else if(target < matrix[i][j]) {\\n                high = t-1;\\n            }else{\\n                low = t+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nLiked the solution? Kindly upvote!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        if(matrix.size() == 0) return false;\\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        int t = (m * n) -1;\\n        int low , high;\\n        int i, j;\\n\\n        low = 0;\\n        high = t;\\n\\n        while(low <= high) {\\n            t = (high + low) / 2;\\n            i = t / n; // get the row number.\\n            j = t % n; // get the column number.\\n                        \\n            if(matrix[i][j] == target)\\n                return true;\\n            else if(target < matrix[i][j]) {\\n                high = t-1;\\n            }else{\\n                low = t+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26350,
                "title": "c-12ms-solution-using-binary-search-o-log-m-log-n",
                "content": "    class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            int m = matrix.size(), n = matrix[0].size(), x, y;\\n            int lo = 0, hi = m*n-1, mid;\\n            if (hi == 0) return (matrix[0][0] == target);\\n            while (lo <= hi)\\n            {\\n                mid = lo + (hi-lo)/2;\\n                x = mid / n; y = mid % n;\\n                if (matrix[x][y] == target)\\n                    return true;\\n                else if (matrix[x][y] > target)\\n                    hi = mid-1;\\n                else\\n                    lo = mid+1;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            int m = matrix.size(), n = matrix[0].size(), x, y;\\n            int lo = 0, hi = m*n-1, mid;\\n            if (hi == 0) return (matrix[0][0] == target);\\n            while (lo <= hi)\\n            {\\n                mid = lo + (hi-lo)/2;\\n                x = mid / n; y = mid % n;\\n                if (matrix[x][y] == target)\\n                    return true;\\n                else if (matrix[x][y] > target)\\n                    hi = mid-1;\\n                else\\n                    lo = mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3675364,
                "title": "easiest-method-for-solving-this-problem-using-binary-search-in-python-3-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for i in range(len(matrix)):\\n            a = matrix[i]\\n            h=len(a)-1\\n            l=0\\n            while l<=h:\\n                mid=(h+l)//2\\n                if a[mid]==target:\\n                    return True\\n                elif a[mid]<target:\\n                    l=mid+1\\n                else:\\n                    h=mid-1\\n        return False\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for i in range(len(matrix)):\\n            a = matrix[i]\\n            h=len(a)-1\\n            l=0\\n            while l<=h:\\n                mid=(h+l)//2\\n                if a[mid]==target:\\n                    return True\\n                elif a[mid]<target:\\n                    l=mid+1\\n                else:\\n                    h=mid-1\\n        return False\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662126,
                "title": "find-element-in-matrix-using-binary-search-java-simple-code-tc-o-m-n",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        // Brute force approch\\n        // for(int i = 0; i<matrix.length; i++){\\n        //     for(int j = 0; j < matrix[0].length; j++){\\n        //         if(matrix[i][j] == target){\\n        //             return true;\\n        //         }\\n        //     }\\n        // }\\n\\n        int i = 0 , j = matrix[0].length - 1;\\n        while(i < matrix.length && j >= 0){\\n            if(matrix[i][j] > target){\\n                j--;\\n            }else if(matrix[i][j] < target){\\n                i++;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        // Brute force approch\\n        // for(int i = 0; i<matrix.length; i++){\\n        //     for(int j = 0; j < matrix[0].length; j++){\\n        //         if(matrix[i][j] == target){\\n        //             return true;\\n        //         }\\n        //     }\\n        // }\\n\\n        int i = 0 , j = matrix[0].length - 1;\\n        while(i < matrix.length && j >= 0){\\n            if(matrix[i][j] > target){\\n                j--;\\n            }else if(matrix[i][j] < target){\\n                i++;\\n            }else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016489,
                "title": "simple-binary-search-o-n-java",
                "content": "**Binary Search** \\n\\n* first identify the row of matrix at which target may be present just by camparing last element of every row.\\n* after geeting the row apply binary search on the row \\n\\n**Time Complexity** - O(M) + O(LogN) =**O(M)**     { M- no. of row , N= no. of column}\\n**Space Complexity - O(1)**\\n\\n**Java Code**\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int i=matrix.length;\\n        \\n        int row=0;\\n        \\n\\t\\t//identify the row\\n        for(int k=0;k<i;k++){\\n            if(target<=matrix[k][j-1]){\\n                row=k;\\n                break;\\n            }   \\n        }\\n        i=0; \\n        int j=matrix[0].length-1;\\n       \\n\\t   //apply binary search on that row\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            \\n            if(matrix[row][mid]==target)        return true;\\n          \\n            else if(matrix[row][mid]>target)    j=mid-1;\\n            else i=mid+1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int i=matrix.length;\\n        \\n        int row=0;\\n        \\n\\t\\t//identify the row\\n        for(int k=0;k<i;k++){\\n            if(target<=matrix[k][j-1]){\\n                row=k;\\n                break;\\n            }   \\n        }\\n        i=0; \\n        int j=matrix[0].length-1;\\n       \\n\\t   //apply binary search on that row\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            \\n            if(matrix[row][mid]==target)        return true;\\n          \\n            else if(matrix[row][mid]>target)    j=mid-1;\\n            else i=mid+1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907566,
                "title": "c-4ms-simple-unique-traversal-of-matrix-in-o-m-n-complexity-no-pre-requisites",
                "content": "``` \\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int i=0;\\n        int j=m-1;\\n        \\n        int mid=matrix[i][j];\\n        while(true)\\n        {\\n            if(mid==target)\\n            {\\n                return true;\\n                break;\\n            }\\n            else if(mid>target)\\n            {\\n                j--;\\n                if(j<0)\\n                {\\n                    return false;\\n                    break;\\n                }\\n                \\n                mid=matrix[i][j];\\n            }\\n            else\\n            {\\n                i++;\\n                if(i>n-1)\\n                {\\n                    return false;\\n                    break;\\n                }\\n                \\n                mid=matrix[i][j];\\n            }\\n        }\\n        \\n        return -1;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int i=0;\\n        int j=m-1;\\n        \\n        int mid=matrix[i][j];\\n        while(true)\\n        {\\n            if(mid==target)\\n            {\\n                return true;\\n                break;\\n            }\\n            else if(mid>target)\\n            {\\n                j--;\\n                if(j<0)\\n                {\\n                    return false;\\n                    break;\\n                }\\n                \\n                mid=matrix[i][j];\\n            }\\n            else\\n            {\\n                i++;\\n                if(i>n-1)\\n                {\\n                    return false;\\n                    break;\\n                }\\n                \\n                mid=matrix[i][j];\\n            }\\n        }\\n        \\n        return -1;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897580,
                "title": "javascript-neat-2x-binary-search-time-o-log-n-log-m-space-o-1",
                "content": "```js\\nconst searchMatrix = (matrix, target) => {\\n  const line = binSearch(target, 0, matrix.length, i => matrix[i][0])\\n  const item = binSearch(target, 0, matrix[line].length, i => matrix[line][i])\\n  return matrix[line][item] === target\\n}\\n\\nconst binSearch = (target, lo, hi, fn) => {\\n  while (lo + 1 < hi) {\\n    const mid = Math.floor((lo + hi) / 2)\\n    const value = fn(mid)\\n    if (value === target)\\n      return mid\\n    if (value < target)\\n      lo = mid\\n    else\\n      hi = mid\\n  }\\n  return lo\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```js\\nconst searchMatrix = (matrix, target) => {\\n  const line = binSearch(target, 0, matrix.length, i => matrix[i][0])\\n  const item = binSearch(target, 0, matrix[line].length, i => matrix[line][i])\\n  return matrix[line][item] === target\\n}\\n\\nconst binSearch = (target, lo, hi, fn) => {\\n  while (lo + 1 < hi) {\\n    const mid = Math.floor((lo + hi) / 2)\\n    const value = fn(mid)\\n    if (value === target)\\n      return mid\\n    if (value < target)\\n      lo = mid\\n    else\\n      hi = mid\\n  }\\n  return lo\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1896171,
                "title": "python3-3-lines-o-log-mn",
                "content": "**Explanation:**\\nLook at the matrix as if it is an array of size `m * n`. Now you just have to search the element in a list using simple binary search. \\n**Idea:**\\nUse inbuilt method `bisect_left` for binary search:\\n```\\ndef searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n\\tn, m = len(A), len(A[0])\\n\\tl = bisect_left(range(m * n - 1), target, key= lambda x: A[x // m][x % m])\\n\\treturn A[l // m][l % m] == target\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n\\tn, m = len(A), len(A[0])\\n\\tl = bisect_left(range(m * n - 1), target, key= lambda x: A[x // m][x % m])\\n\\treturn A[l // m][l % m] == target\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1638919,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].length-1;\\n        while(i<matrix.length && j>=0){\\n            if(matrix[i][j] == target)  return true;\\n            else if(matrix[i][j] >= target)   j--;\\n            else    i++;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n```javascript []\\nvar searchMatrix = function(matrix, target) {\\n    let row=0, col=matrix[0].length-1;\\n    while(row<matrix.length && col>=0){\\n        if(matrix[row][col] == target)  return true;\\n        else if(matrix[row][col] >= target) col--;\\n        else row++;\\n    }\\n    return false;\\n};\\n```\\n\\n```python []\\nclass Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        row, col = 0, len(matrix[0])-1\\n        while row < len(matrix) and col >= 0 :\\n            if matrix[row][col] == target :\\n                return True\\n            elif matrix[row][col] >= target :\\n                col -= 1\\n            else :\\n                row += 1\\n        return False\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```java []\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].length-1;\\n        while(i<matrix.length && j>=0){\\n            if(matrix[i][j] == target)  return true;\\n            else if(matrix[i][j] >= target)   j--;\\n            else    i++;\\n        }\\n        return false;\\n    }\\n}\\n```\n```javascript []\\nvar searchMatrix = function(matrix, target) {\\n    let row=0, col=matrix[0].length-1;\\n    while(row<matrix.length && col>=0){\\n        if(matrix[row][col] == target)  return true;\\n        else if(matrix[row][col] >= target) col--;\\n        else row++;\\n    }\\n    return false;\\n};\\n```\n```python []\\nclass Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        row, col = 0, len(matrix[0])-1\\n        while row < len(matrix) and col >= 0 :\\n            if matrix[row][col] == target :\\n                return True\\n            elif matrix[row][col] >= target :\\n                col -= 1\\n            else :\\n                row += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469394,
                "title": "simple-c-solution-using-binary-search-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int i=0;\\n        int j=m-1;\\n        while(i>=0 && i<n && j>=0 && j<m)\\n        {\\n            if(matrix[i][j]==target)\\n                return true;\\n            else if(target<matrix[i][j])\\n                j--;\\n            else \\n                i++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\tPlease consider upvoting.",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int i=0;\\n        int j=m-1;\\n        while(i>=0 && i<n && j>=0 && j<m)\\n        {\\n            if(matrix[i][j]==target)\\n                return true;\\n            else if(target<matrix[i][j])\\n                j--;\\n            else \\n                i++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102862,
                "title": "100-00-faster-and-simple-c-java-solution-with-explanataion",
                "content": "choose either Upper right index or lower left index and start binary Search \\n***Upvote me if you like***\\n```\\n bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].size()-1;\\n        while(j>=0&&i<matrix.size()){\\n            if(target==matrix[i][j]){\\n                return true;\\n            }\\n            if(target<matrix[i][j]){\\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].size()-1;\\n        while(j>=0&&i<matrix.size()){\\n            if(target==matrix[i][j]){\\n                return true;\\n            }\\n            if(target<matrix[i][j]){\\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 896952,
                "title": "python-explained-beats-95-video-code",
                "content": "[](https://www.youtube.com/watch?v=d-s5jvPjTig)\\nhttps://www.youtube.com/watch?v=d-s5jvPjTig\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix or not matrix[0]:\\n            return False\\n        \\n        #finding out row\\n        for x in range(len(matrix)):\\n            \\n            if target == matrix[x][0] or target == matrix[x][-1]:\\n                return True\\n            \\n            elif target > matrix[x][0] and target < matrix[x][-1]:\\n                # look for element in row\\n                l, r = 0, len(matrix[x]) - 1\\n                \\n                while l <= r:\\n                    mid = l + (r - l) // 2\\n                    \\n                    if target == matrix[x][mid]:\\n                        return True\\n                    \\n                    elif target > matrix[x][mid]:\\n                        l = mid + 1\\n                        \\n                    else:\\n                        r = mid - 1\\n                        \\n                return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix or not matrix[0]:\\n            return False\\n        \\n        #finding out row\\n        for x in range(len(matrix)):\\n            \\n            if target == matrix[x][0] or target == matrix[x][-1]:\\n                return True\\n            \\n            elif target > matrix[x][0] and target < matrix[x][-1]:\\n                # look for element in row\\n                l, r = 0, len(matrix[x]) - 1\\n                \\n                while l <= r:\\n                    mid = l + (r - l) // 2\\n                    \\n                    if target == matrix[x][mid]:\\n                        return True\\n                    \\n                    elif target > matrix[x][mid]:\\n                        l = mid + 1\\n                        \\n                    else:\\n                        r = mid - 1\\n                        \\n                return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896762,
                "title": "search-a-2d-matrix-java-c-kotlin-o-logmn",
                "content": "These two conditions  gurantees that if you connect all rows together, it is still sorted.  So this question is just a regular binary search.  Do **NOT** think it as a M row N column 2D matrix, it is just a **1D Sorted list** the lengh is M * N.\\n\\n* Integers in each row are sorted from left to right.\\n* The first integer of each row is greater than the last integer of the previous row.\\n\\nThe only trick is : if you have a number x in (0, M * N -1), how to change from x to row and column number.\\n\\n* row = x / N\\n* column = x % N.\\n\\n**java**\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix.length == 0 || matrix[0].length == 0) return false;\\n        int m = matrix.length, n = matrix[0].length;\\n        if (target < matrix[0][0] || target > matrix[m-1][n-1]) return false;\\n        int l = 0, r = m * n-1;\\n        while (l <= r)\\n        {\\n            int mid = (l + r) / 2;\\n            int x = mid / n;\\n            int y = mid % n;\\n            \\n            if (matrix[x][y] == target)\\n            {\\n                return true;\\n            }\\n            else if (matrix[x][y] < target)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid -1;\\n            }\\n        }\\n        return matrix[l/n][l%n] == target;\\n    }\\n}\\n```\\n\\n**c++**\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if (matrix.size() == 0 || matrix[0].size() == 0) return false;\\n        int m = matrix.size(), n = matrix[0].size();\\n        if (target < matrix[0][0] || target > matrix[m-1][n-1]) return false;\\n        int l = 0, r = m * n -1;\\n        while (l <= r)\\n        {\\n            int mid = (l + r)/2;\\n            int x = mid / n;\\n            int y = mid % n;\\n            if (matrix[x][y] == target)\\n            {\\n                return true;\\n            }\\n            else if (matrix[x][y] > target)\\n            {\\n                r = mid -1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n        }\\n        return matrix[l/n][l%n] == target;\\n    }\\n};\\n```\\n\\n**kotlin**\\n```\\nclass Solution {\\n    fun searchMatrix(matrix: Array<IntArray>, target: Int): Boolean {\\n        if (matrix.size == 0 || matrix[0].size == 0) return false\\n        var m: Int = matrix.size\\n        var n: Int = matrix[0].size\\n        if (target < matrix[0][0] || target > matrix[m-1][n-1]) return false;\\n        var l = 0\\n        var r = m * n -1\\n        while (l <= r) {\\n            var mid = (l + r)/2\\n            val temp = matrix[mid/n][mid%n] - target\\n            when {\\n               (temp < 0) -> l = mid+1\\n               (temp > 0) -> r = mid-1\\n               (temp == 0) -> return true;\\n            }\\n        }\\n        return matrix[l/n][l%n] == target\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Kotlin",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix.length == 0 || matrix[0].length == 0) return false;\\n        int m = matrix.length, n = matrix[0].length;\\n        if (target < matrix[0][0] || target > matrix[m-1][n-1]) return false;\\n        int l = 0, r = m * n-1;\\n        while (l <= r)\\n        {\\n            int mid = (l + r) / 2;\\n            int x = mid / n;\\n            int y = mid % n;\\n            \\n            if (matrix[x][y] == target)\\n            {\\n                return true;\\n            }\\n            else if (matrix[x][y] < target)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid -1;\\n            }\\n        }\\n        return matrix[l/n][l%n] == target;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if (matrix.size() == 0 || matrix[0].size() == 0) return false;\\n        int m = matrix.size(), n = matrix[0].size();\\n        if (target < matrix[0][0] || target > matrix[m-1][n-1]) return false;\\n        int l = 0, r = m * n -1;\\n        while (l <= r)\\n        {\\n            int mid = (l + r)/2;\\n            int x = mid / n;\\n            int y = mid % n;\\n            if (matrix[x][y] == target)\\n            {\\n                return true;\\n            }\\n            else if (matrix[x][y] > target)\\n            {\\n                r = mid -1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n        }\\n        return matrix[l/n][l%n] == target;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun searchMatrix(matrix: Array<IntArray>, target: Int): Boolean {\\n        if (matrix.size == 0 || matrix[0].size == 0) return false\\n        var m: Int = matrix.size\\n        var n: Int = matrix[0].size\\n        if (target < matrix[0][0] || target > matrix[m-1][n-1]) return false;\\n        var l = 0\\n        var r = m * n -1\\n        while (l <= r) {\\n            var mid = (l + r)/2\\n            val temp = matrix[mid/n][mid%n] - target\\n            when {\\n               (temp < 0) -> l = mid+1\\n               (temp > 0) -> r = mid-1\\n               (temp == 0) -> return true;\\n            }\\n        }\\n        return matrix[l/n][l%n] == target\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26430,
                "title": "share-my-o-n-m-solution",
                "content": "  \\n\\n      Solution {  public:\\n        bool searchMatrix(vector<vector<int> > &matrix, int target) {\\n            int n = (int)matrix.size();\\n            int m = (int)matrix[0].size();\\n            --n; --m;\\n            while(n > 0 && matrix[n - 1][m] >= target) --n;\\n            while(m > 0 && matrix[n][m - 1] >= target) --m;\\n            return (matrix[n][m] == target);\\n        }\\n    };\\nI just used that fact, that number in the matrix increases",
                "solutionTags": [],
                "code": "  \\n\\n      Solution {  public:\\n        bool searchMatrix(vector<vector<int> > &matrix, int target) {\\n            int n = (int)matrix.size();\\n            int m = (int)matrix[0].size();\\n            --n; --m;\\n            while(n > 0 && matrix[n - 1][m] >= target) --n;\\n            while(m > 0 && matrix[n][m - 1] >= target) --m;\\n            return (matrix[n][m] == target);\\n        }\\n    };\\nI just used that fact, that number in the matrix increases",
                "codeTag": "Unknown"
            },
            {
                "id": 4093480,
                "title": "simple-java-solutions-runtime-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n       int low1 = 0 , high1 = matrix.length - 1 , mid1 = low1 + (high1 - low1) /2;\\n        while (low1 < high1)\\n        {\\n            if (matrix[mid1][0] == target){\\n                return true;\\n            }else if (matrix[mid1][0] < target ){\\n                if (matrix[mid1][matrix[0].length-1] >= target) break;\\n                low1 = mid1 + 1;\\n            }else {\\n                high1 = mid1 - 1;\\n            }\\n             mid1 = low1 + (high1 - low1) /2;\\n        }\\n\\n        int low2 = 0 , high2 = matrix[0].length - 1;\\n        while (low2 <= high2)\\n        {\\n            int mid2 = low2 + (high2 - low2) /2;\\n            if (matrix[mid1][mid2] == target){\\n                return true;\\n            }else if (matrix[mid1][mid2] < target){\\n                low2 = mid2 + 1;\\n            }else {\\n                high2 = mid2 - 1;\\n            }\\n        }\\n\\n\\n        return false; \\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/6be958b1-4d2d-410a-8450-d84a5d775f2e_1695746044.9742215.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n       int low1 = 0 , high1 = matrix.length - 1 , mid1 = low1 + (high1 - low1) /2;\\n        while (low1 < high1)\\n        {\\n            if (matrix[mid1][0] == target){\\n                return true;\\n            }else if (matrix[mid1][0] < target ){\\n                if (matrix[mid1][matrix[0].length-1] >= target) break;\\n                low1 = mid1 + 1;\\n            }else {\\n                high1 = mid1 - 1;\\n            }\\n             mid1 = low1 + (high1 - low1) /2;\\n        }\\n\\n        int low2 = 0 , high2 = matrix[0].length - 1;\\n        while (low2 <= high2)\\n        {\\n            int mid2 = low2 + (high2 - low2) /2;\\n            if (matrix[mid1][mid2] == target){\\n                return true;\\n            }else if (matrix[mid1][mid2] < target){\\n                low2 = mid2 + 1;\\n            }else {\\n                high2 = mid2 - 1;\\n            }\\n        }\\n\\n\\n        return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875878,
                "title": "c-binary-search-day-7",
                "content": "# Complexity\\n- Time complexity: **O(log(m * n))**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int n = mat.size(), m = mat[0].size();\\n        int i = 0, j = m*n - 1;\\n        while(i<=j){\\n            int mid = (i + j)/2;\\n            int r = mid/m;\\n            int c = mid%m;\\n            if(mat[r][c]==target)return true;\\n            if(mat[r][c]>target){\\n                j = mid - 1;\\n            }\\n            else i = mid + 1;\\n        }\\n        return false;\\n    }\\n};\\n```\\n// **EAT CHIKU (Sapodilla/ Naseberry)**\\n![chiku.jpg](https://assets.leetcode.com/users/images/61986884-ab84-4f6c-9c4c-6b4865c04279_1691399459.6958907.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int n = mat.size(), m = mat[0].size();\\n        int i = 0, j = m*n - 1;\\n        while(i<=j){\\n            int mid = (i + j)/2;\\n            int r = mid/m;\\n            int c = mid%m;\\n            if(mat[r][c]==target)return true;\\n            if(mat[r][c]>target){\\n                j = mid - 1;\\n            }\\n            else i = mid + 1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852428,
                "title": "binary-search-solution",
                "content": "\\n# Approach\\nGet the number of rows (row) and columns (col) in the matrix.\\nSet start to 0, representing the first element in the matrix.\\nSet end to the index of the last element in the matrix, which is (row * col) - 1.\\nUse binary search to find the target element in the matrix.\\nIn each iteration of the binary search:\\nCalculate the mid index as start + (end - start) / 2.\\nGet the element at index (mid / col, mid % col) in the matrix.\\nCompare the element with the target.\\nIf element is equal to the target, return true as the target element is found.\\nIf element is less than the target, update start to mid + 1 to search in the right half.\\nIf element is greater than the target, update end to mid - 1 to search in the left half.\\nContinue the binary search until start becomes greater than end.\\nIf the binary search ends without finding the target element, return false\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log(m * n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int start =0;\\n        int end = row*col-1;\\n        int mid = start+(end-start)/2;\\n\\n        while(start<=end)\\n        {\\n            int element=  matrix[mid/col][mid%col];\\n            if(element == target)\\n            {\\n                return 1;\\n            }\\n            else if(element< target)\\n            {\\n                start=mid+1;\\n            }\\n            else \\n            {\\n                end= mid-1;\\n            }\\n           mid = start+(end-start)/2;\\n        }\\n        return 0 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int start =0;\\n        int end = row*col-1;\\n        int mid = start+(end-start)/2;\\n\\n        while(start<=end)\\n        {\\n            int element=  matrix[mid/col][mid%col];\\n            if(element == target)\\n            {\\n                return 1;\\n            }\\n            else if(element< target)\\n            {\\n                start=mid+1;\\n            }\\n            else \\n            {\\n                end= mid-1;\\n            }\\n           mid = start+(end-start)/2;\\n        }\\n        return 0 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105639,
                "title": "best-o-log-m-n-solution",
                "content": "# Approach 1\\nLinear Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$ \\n\\n- Space complexity:\\n $$O(1)$$ \\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        for (int i = 0; i < r; i++) \\n            for (int j = 0; j < c; j++) \\n                if (matrix[i][j] == target)\\n                    return true;\\n        return false;\\n    }\\n};\\n```\\n\\n# Approach 2\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(m*n))$$ \\n\\n- Space complexity:\\n $$O(1)$$ \\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        int  low = 0, high = r * c - 1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (matrix[mid / c][mid % c] == target)\\n                return true;\\n            else if (matrix[mid / c][mid % c] > target)    \\n                high = mid - 1;\\n            else\\n                low = mid + 1;    \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        for (int i = 0; i < r; i++) \\n            for (int j = 0; j < c; j++) \\n                if (matrix[i][j] == target)\\n                    return true;\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        int  low = 0, high = r * c - 1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (matrix[mid / c][mid % c] == target)\\n                return true;\\n            else if (matrix[mid / c][mid % c] > target)    \\n                high = mid - 1;\\n            else\\n                low = mid + 1;    \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089373,
                "title": "i-didn-t-want-to-write-out-binary-search-function",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(LOG(n * m))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nimpl Solution {\\n    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let what = matrix.binary_search_by(|num| num[0].cmp(&target));\\n        match what {\\n            Ok(_) => true,\\n            Err(0) => false,\\n            Err(index) => matrix[index -1].binary_search(&target).is_ok()\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let what = matrix.binary_search_by(|num| num[0].cmp(&target));\\n        match what {\\n            Ok(_) => true,\\n            Err(0) => false,\\n            Err(index) => matrix[index -1].binary_search(&target).is_ok()\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2950750,
                "title": "easy-c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince rows are sorted, we can traverse through last column to determine in which row are target value will lie.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the target value is smaller than our last column then we will traverse in that row, and if the target value is greater than the current value, we will move to the next row.\\n\\n# Complexity\\n- Time complexity : O(M+N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size();\\n        int columns = matrix[0].size();\\n        int i=0,j=columns-1;\\n        while(i<rows and j>=0)\\n        {\\n            if(matrix[i][j]==target)\\n            return true;\\n            else if(matrix[i][j]>target)\\n            j--;\\n            else\\n            i++;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size();\\n        int columns = matrix[0].size();\\n        int i=0,j=columns-1;\\n        while(i<rows and j>=0)\\n        {\\n            if(matrix[i][j]==target)\\n            return true;\\n            else if(matrix[i][j]>target)\\n            j--;\\n            else\\n            i++;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116485,
                "title": "c-search-a-2d-matrix-5-approaches",
                "content": "### Approach - 1 (Brute Force) : \\n\\nTime complexity : O(n2) \\nSpace : O(1) \\nThis method just involves searching through the matrix col by col and row by row. As it is not a very efficient approach, let\\'s move to next approach. \\n\\n```\\n\\n```\\n\\n### Approach - 2 : \\n\\nTime complexity : O(n) \\nSpace : O(1) \\n\\nThis involves first identiying the row to look and then iterating through the elements of that particular row to find the target.  \\n\\nC++ code : \\n```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\tint n = matrix.size();\\n\\tint m = matrix[0].size();\\n\\n\\tint row = -1;\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tif (matrix[i][0] <= target){\\n\\t\\t\\trow = i;\\n\\t\\t}\\n\\t}\\n\\n\\tif (row == -1) return false;\\n\\n\\tfor (int i = 0; i < m; i++){\\n\\t\\tif (matrix[row][i] == target) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n```\\n\\n\\n### Approach 3 (Binary Search Tree) : \\n\\nObserving, we can see that the the matrix behaves like a binary search tree. Look at the element of last column in first row. On it\\'s left lies a smaller element and on bottom lies a greater element. \\n\\nTime complexity : O(n) \\nSpace : O(1) \\n\\nThough this method doesn\\'t improve our time complexity but this is what an interview might be looking for. It\\'s very important to identify underlying concepts in such questions. \\n\\nC++ code : \\n```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\tint n = matrix.size();\\n\\tint m = matrix[0].size(); \\n\\n\\tint r = 0, c = m - 1;\\n\\n\\twhile (r < n && c >= 0){\\n\\t\\tif (matrix[r][c] == target) return true;\\n\\n\\t\\tif (matrix[r][c] > target) c--;\\n\\t\\telse r++;\\n\\t}\\n\\n\\treturn false;\\n}\\n``` \\n\\n\\n### Approach - 4 (Binary Search) :\\n\\nTime Complexity - O(log(n * m)) \\nSpace - O(1)\\n\\nIn this approach we apply binary search on while matrix. For visualization, number all elements as there increasing linear order. Then, apply the concept of binary search on the whole matrix. \\n\\nC++ code :\\n```\\nbool searchMatrix(vector<vector<int>>& matrix, int target){\\n\\tint n = matrix.size();\\n\\tint m = matrix[0].size(); \\n\\n\\tint lo = 0, hi = n*m - 1;\\n\\n\\twhile (lo <= hi){\\n\\t\\tint mid = lo + (hi - lo)/2;\\n\\t\\tint val = matrix[mid/m][mid%m];\\n\\t\\tif (val == target){\\n\\t\\t\\treturn true;\\n\\t\\t} else if (val < target) {\\n\\t\\t\\tlo = mid + 1;\\n\\t\\t} else {\\n\\t\\t\\thi = mid - 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n```\\n\\n\\n### Approach - 5 :\\n\\nTime Complexity : O(log(n) + log(m)) \\nSpace : O(1) \\n\\nApply binary search on the 0-indexed column to find the row in which the element may lie. And then, apply binary search on the row to find that element. \\n\\n\\nThank you.",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\n```\n```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\tint n = matrix.size();\\n\\tint m = matrix[0].size();\\n\\n\\tint row = -1;\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tif (matrix[i][0] <= target){\\n\\t\\t\\trow = i;\\n\\t\\t}\\n\\t}\\n\\n\\tif (row == -1) return false;\\n\\n\\tfor (int i = 0; i < m; i++){\\n\\t\\tif (matrix[row][i] == target) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n```\n```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\tint n = matrix.size();\\n\\tint m = matrix[0].size(); \\n\\n\\tint r = 0, c = m - 1;\\n\\n\\twhile (r < n && c >= 0){\\n\\t\\tif (matrix[r][c] == target) return true;\\n\\n\\t\\tif (matrix[r][c] > target) c--;\\n\\t\\telse r++;\\n\\t}\\n\\n\\treturn false;\\n}\\n```\n```\\nbool searchMatrix(vector<vector<int>>& matrix, int target){\\n\\tint n = matrix.size();\\n\\tint m = matrix[0].size(); \\n\\n\\tint lo = 0, hi = n*m - 1;\\n\\n\\twhile (lo <= hi){\\n\\t\\tint mid = lo + (hi - lo)/2;\\n\\t\\tint val = matrix[mid/m][mid%m];\\n\\t\\tif (val == target){\\n\\t\\t\\treturn true;\\n\\t\\t} else if (val < target) {\\n\\t\\t\\tlo = mid + 1;\\n\\t\\t} else {\\n\\t\\t\\thi = mid - 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1973353,
                "title": "search-a-2d-matrix",
                "content": "Inside the function we can use 2 approaches....\\n// Approach 1 ---> Time Complexity = O(n+logm)\\n```\\n        int i=0, row=matrix.size()-1;\\n        bool ans=false;\\n        while(i<matrix.size()){\\n            if(matrix[i][0]==target){\\n                ans=true;\\n                row=-1;\\n                break;\\n            }\\n            else if(matrix[i][0]>target){\\n                row=i-1;\\n                break;\\n            }\\n            i++;\\n        }\\n        int l=0, h=matrix[0].size()-1, mid;\\n        while(l<=h && row>=0){\\n            mid=(l+h)/2;\\n            if(matrix[row][mid]==target){\\n                ans=true;\\n                break;\\n            }\\n            else if(matrix[row][mid]<target){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n  ```\\n  \\n  //Approach 2 ---> Time Cpmplexity = O(n+m)\\n  \\n    ```    \\n        int i=0,j=matrix[0].size()-1;\\n        while(j>=0 && i<matrix.size())\\n         {\\n             if(matrix[i][j]==target)\\n                 return true;\\n             else if(matrix[i][j]>target)\\n                 j--;\\n             else if(matrix[i][j]<target)\\n                 i++;\\n         }\\n        return false;\\n\\t\\t\\n\\t\\t```",
                "solutionTags": [
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\n        int i=0, row=matrix.size()-1;\\n        bool ans=false;\\n        while(i<matrix.size()){\\n            if(matrix[i][0]==target){\\n                ans=true;\\n                row=-1;\\n                break;\\n            }\\n            else if(matrix[i][0]>target){\\n                row=i-1;\\n                break;\\n            }\\n            i++;\\n        }\\n        int l=0, h=matrix[0].size()-1, mid;\\n        while(l<=h && row>=0){\\n            mid=(l+h)/2;\\n            if(matrix[row][mid]==target){\\n                ans=true;\\n                break;\\n            }\\n            else if(matrix[row][mid]<target){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n  ```\n```    \\n        int i=0,j=matrix[0].size()-1;\\n        while(j>=0 && i<matrix.size())\\n         {\\n             if(matrix[i][j]==target)\\n                 return true;\\n             else if(matrix[i][j]>target)\\n                 j--;\\n             else if(matrix[i][j]<target)\\n                 i++;\\n         }\\n        return false;\\n\\t\\t\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1796575,
                "title": "javascript-o-log-m-log-n-w-explanation-and-comments",
                "content": "1. find row where first element is smaller than target and last element is bigger than target. if such a row cannot be found, return false.\\n2. run binary search on the row\\n\\nTime Complexity:\\nO(log m + log n)\\nm = amount of rows\\nn = length of rows\\n\\nlog m because we check first and last element of a row log m times.\\n\\nadd log n to it because when we find the row we do binary search on it (only once)\\n\\n\\n```\\nvar searchMatrix = function(matrix, target) {\\n  let lo = 0, hi = matrix.length - 1;\\n  let mid = lo + Math.floor((hi - lo) / 2);\\n  let n = matrix[0].length;\\n  \\n  // find row that could potentially hold target\\n  while (matrix[mid][0] > target || matrix[mid][n - 1] < target) { \\n    mid = lo + Math.floor((hi - lo) / 2);\\n    \\n    if (matrix[mid][0] > target) {\\n      hi = mid - 1;\\n    } else if (matrix[mid][n - 1] < target) {\\n      lo = mid + 1;\\n    } \\n    \\n\\t// if such a row cannot be found return false \\n    if (lo > hi) return false;\\n  }\\n  // run binary search on the row\\n  return binarySearch(matrix[mid], 0, matrix[mid].length, target);\\n}; \\n\\nconst binarySearch = (row, lo, hi, target) => {\\n  if (lo > hi) return false;\\n  \\n  const mid = lo + Math.floor((hi - lo) / 2);\\n  if (row[mid] > target) { return binarySearch(row, lo, mid - 1, target); }\\n  else if (row[mid] < target) { return binarySearch(row, mid + 1, hi, target); }\\n  else return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar searchMatrix = function(matrix, target) {\\n  let lo = 0, hi = matrix.length - 1;\\n  let mid = lo + Math.floor((hi - lo) / 2);\\n  let n = matrix[0].length;\\n  \\n  // find row that could potentially hold target\\n  while (matrix[mid][0] > target || matrix[mid][n - 1] < target) { \\n    mid = lo + Math.floor((hi - lo) / 2);\\n    \\n    if (matrix[mid][0] > target) {\\n      hi = mid - 1;\\n    } else if (matrix[mid][n - 1] < target) {\\n      lo = mid + 1;\\n    } \\n    \\n\\t// if such a row cannot be found return false \\n    if (lo > hi) return false;\\n  }\\n  // run binary search on the row\\n  return binarySearch(matrix[mid], 0, matrix[mid].length, target);\\n}; \\n\\nconst binarySearch = (row, lo, hi, target) => {\\n  if (lo > hi) return false;\\n  \\n  const mid = lo + Math.floor((hi - lo) / 2);\\n  if (row[mid] > target) { return binarySearch(row, lo, mid - 1, target); }\\n  else if (row[mid] < target) { return binarySearch(row, mid + 1, hi, target); }\\n  else return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1670302,
                "title": "go-100-time-and-32-space-tc-o-log-n-m-sc-o-1",
                "content": "```\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n\\tleft, right := 0, len(matrix)*len(matrix[0])\\n\\tfor left < right {\\n\\t\\tmiddle := (left + right) / 2\\n\\t\\ti, j := middle/len(matrix[0]), middle%len(matrix[0])\\n\\n\\t\\tif target < matrix[i][j] {\\n\\t\\t\\tright = middle\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif target > matrix[i][j] {\\n\\t\\t\\tleft = middle + 1\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\treturn true\\n\\t}\\n\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n\\tleft, right := 0, len(matrix)*len(matrix[0])\\n\\tfor left < right {\\n\\t\\tmiddle := (left + right) / 2\\n\\t\\ti, j := middle/len(matrix[0]), middle%len(matrix[0])\\n\\n\\t\\tif target < matrix[i][j] {\\n\\t\\t\\tright = middle\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif target > matrix[i][j] {\\n\\t\\t\\tleft = middle + 1\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\treturn true\\n\\t}\\n\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1273913,
                "title": "o-logn-logm-binary-search-with-explanation-0ms-c-beats-100",
                "content": "**Hint**: There will only be a single row where the element might be present, can you find the relevant row out of M rows in O(logM)?\\n\\n**Solution**: Simply apply binary search on elements of first column, and find the largest element smaller than or equal to target element (this is somewhat similar to lowerBound / upperBound).\\nNow we are sure that element will be present in this row if it exists in matrix, reason for this is that last element of previous row must be smaller than first element of current row.\\nHence we apply simple binary search on elements of this row to find the target.\\n \\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size(), n=matrix[0].size();\\n        int l=0,h=m-1,mid,ans=0;\\n        while(l<=h){\\n            mid=l+(h-l)/2;\\n            if(matrix[mid][0]<=target){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else \\n                h=mid-1;\\n        }\\n        l=0;h=n-1;\\n        while(l<=h){\\n            mid=l+(h-l)/2;\\n            if(matrix[ans][mid]==target)\\n                return true;\\n            else if(matrix[ans][mid]<target)\\n                l=mid+1;\\n            else \\n                h=mid-1;\\n        }\\n        return false;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size(), n=matrix[0].size();\\n        int l=0,h=m-1,mid,ans=0;\\n        while(l<=h){\\n            mid=l+(h-l)/2;\\n            if(matrix[mid][0]<=target){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else \\n                h=mid-1;\\n        }\\n        l=0;h=n-1;\\n        while(l<=h){\\n            mid=l+(h-l)/2;\\n            if(matrix[ans][mid]==target)\\n                return true;\\n            else if(matrix[ans][mid]<target)\\n                l=mid+1;\\n            else \\n                h=mid-1;\\n        }\\n        return false;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896744,
                "title": "c-stair-search-o-n-m-time",
                "content": "**Approach 1**\\nThe brute force approach is to search the entire matrix which will get us to a `O(nm)` solution. \\n\\n**Approach 2**\\nWe are told that in the matrix, each row and each column is sorted. Maybe we should use this constraint to optimize our solution. For each row we could perform a binary search which will get us to a `O(n log m)` solution. We could further improve this approach to get us to a `O(min(n, m) log(max(n, m))` solution.\\n\\n**Approach 3**\\nIn approach 2, we are ignoring the fact that each column is also sorted. This should force us to even more optimize the solution. The algtorithm is as follows:\\n* We start searching from the top right corner of the matrix. \\n* If target is found we return true;;\\n* If target is less than the current value, we move 1 step to the left. (Because, we know the matrix is column-wise sorted, so target cannot be in the current column)\\n* If target is greater than the current value, we move 1 step below. (Because, we know that matrix is row-wise sorted, so target cannot be anywhere in the current row)\\n```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\tif (matrix.size() == 0) {\\n\\t\\treturn false;\\n\\t}\\n\\tint i = 0;\\n\\tint j = matrix[0].size() - 1;\\n\\n\\twhile (i < matrix.size() && j >= 0) {\\n\\t\\tif (matrix[i][j] == target) {\\n\\t\\t\\treturn true;\\n\\t\\t} else if (target < matrix[i][j]) {\\n\\t\\t\\tj--;\\n\\t\\t} else {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```\\nTime complexity - `O(n + m)`\\nSpace complexity - `O(1)`\\n*(Note: n = number of rows; m = number of columns)*",
                "solutionTags": [],
                "code": "```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\tif (matrix.size() == 0) {\\n\\t\\treturn false;\\n\\t}\\n\\tint i = 0;\\n\\tint j = matrix[0].size() - 1;\\n\\n\\twhile (i < matrix.size() && j >= 0) {\\n\\t\\tif (matrix[i][j] == target) {\\n\\t\\t\\treturn true;\\n\\t\\t} else if (target < matrix[i][j]) {\\n\\t\\t\\tj--;\\n\\t\\t} else {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878322,
                "title": "o-log-m-n-simple-binary-search-algorithm",
                "content": "\\n# Approach\\n \\nmatrix = \\n         [[1,3,5,7]\\n         [10,11,16,20]\\n         [23,30,34,60]]\\nif we transform this matix into one dimensional array then the result is sorted array \\n-->[1,3,5,7,10,11,16,20,23,30,34,60]\\nNow we can apply regular classic binary search algo on above array.\\nNumber Of Elements will be equal= M * N\\nHence Time complexity will log(M* N)\\n\\n# Complexity\\n- Time complexity:\\nO(log(M* N))\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(),m=matrix[0].size();\\n         int low=0,high=n*m-1,mid,row,col;\\n         while(low<=high)\\n         {\\n             mid=(low+high)/2;\\n             row=mid/m; // getting the row number\\n             col=mid%m; // getting the column number\\n             if(matrix[row][col]==target) return true;\\n             else if(matrix[row][col]>target) high=mid-1;\\n             else low= mid+1;\\n\\n         }\\n         return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(),m=matrix[0].size();\\n         int low=0,high=n*m-1,mid,row,col;\\n         while(low<=high)\\n         {\\n             mid=(low+high)/2;\\n             row=mid/m; // getting the row number\\n             col=mid%m; // getting the column number\\n             if(matrix[row][col]==target) return true;\\n             else if(matrix[row][col]>target) high=mid-1;\\n             else low= mid+1;\\n\\n         }\\n         return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877332,
                "title": "python-java-elegant-short-2d-binary-search",
                "content": "# Complexity\\n- Time complexity: $$O(\\\\log_{2} (n * m))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```Python []\\nclass Solution:\\n\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n, m = len(matrix), len(matrix[0])\\n        left, right = 0, n * m - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            num = matrix[mid // m][mid % m]\\n\\n            if num == target:\\n                return True\\n\\n            if num < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return False\\n\\n```\\n```Java []\\npublic class Solution {\\n\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int left = 0, right = n * m - 1;\\n\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            int num = matrix[mid / m][mid % m];\\n\\n            if (num == target)\\n                return true;\\n\\n            if (num < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```Python []\\nclass Solution:\\n\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n, m = len(matrix), len(matrix[0])\\n        left, right = 0, n * m - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            num = matrix[mid // m][mid % m]\\n\\n            if num == target:\\n                return True\\n\\n            if num < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return False\\n\\n```\n```Java []\\npublic class Solution {\\n\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int left = 0, right = n * m - 1;\\n\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            int num = matrix[mid / m][mid % m];\\n\\n            if (num == target)\\n                return true;\\n\\n            if (num < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876876,
                "title": "most-optimal-explanation-clean-code-binary-search-c",
                "content": "[You can also check](https://github.com/Glorycs29/Binary_Search)\\n\\n<img src=\"https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif\">\\n\\n# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Similar to basic binary search.\\n- How will the matrix behave like an array without actually creating an auxiliary array?\\n- It could be achieved by the following formula :\\n- A n * m matrix converted into an array: matrix[x][y] : a[x * m + y]\\nAn array can be converted into **n * m matrix: a[x] : matrix[x / m][x % m]**\\n\\n<img src=\"https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif\">\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- No special approach.\\n- Just do what you\\'ve done in Binary Search.\\n\\n<img src=\"https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif\">\\n\\n# Complexity\\n- Time complexity: O(log(n*m)) : It\\'s highly optimized : O(logn) + O(logm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1) : We have stored nothing \\uD83E\\uDD73\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n<img src=\"https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif\">\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int r=mat.size();\\n        int c = mat[0].size();\\n        int low = 0, high = (r*c)-1;\\n\\n        while(low<high){\\n            int mid = (low + high)>>1;\\n            if(mat[mid/c][mid%c] < target) low = mid+1;\\n            else high = mid;\\n        }\\n        return mat[high/c][high%c]==target;\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int r=mat.size();\\n        int c = mat[0].size();\\n        int low = 0, high = (r*c)-1;\\n\\n        while(low<high){\\n            int mid = (low + high)>>1;\\n            if(mat[mid/c][mid%c] < target) low = mid+1;\\n            else high = mid;\\n        }\\n        return mat[high/c][high%c]==target;\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874712,
                "title": "c-bruteforce-to-optimal-must-visit",
                "content": "```\\n// class Solution {\\n// public:\\n//    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n//     // Iterate through each element of the matrix\\n//     for (int i = 0; i < matrix.size(); i++) {\\n//         for (int j = 0; j < matrix[0].size(); j++) {\\n//             // Compare the current element to the target value\\n//             if (matrix[i][j] == target) {\\n//                 return true; // Found the target value\\n//             }\\n//         }\\n//     }\\n//     return false; // Target value not found in the matrix\\n// }\\n// }; //just sunny things baby .....ha! H! h!........ TIME COMPLEXITY = O(N^2)\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n    int row = 0, col = matrix[0].size() - 1; // Start from the top right corner\\n    while (row < matrix.size() && col >= 0) {\\n        if (matrix[row][col] == target) {\\n            return true; // Found the target value\\n        } else if (matrix[row][col] < target) {\\n            row++; // Eliminate the current row\\n        } else {\\n            col--; // Eliminate the current column\\n        }\\n    }\\n    return false; // Target value not found in the matrix\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\n// class Solution {\\n// public:\\n//    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n//     // Iterate through each element of the matrix\\n//     for (int i = 0; i < matrix.size(); i++) {\\n//         for (int j = 0; j < matrix[0].size(); j++) {\\n//             // Compare the current element to the target value\\n//             if (matrix[i][j] == target) {\\n//                 return true; // Found the target value\\n//             }\\n//         }\\n//     }\\n//     return false; // Target value not found in the matrix\\n// }\\n// }; //just sunny things baby .....ha! H! h!........ TIME COMPLEXITY = O(N^2)\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n    int row = 0, col = matrix[0].size() - 1; // Start from the top right corner\\n    while (row < matrix.size() && col >= 0) {\\n        if (matrix[row][col] == target) {\\n            return true; // Found the target value\\n        } else if (matrix[row][col] < target) {\\n            row++; // Eliminate the current row\\n        } else {\\n            col--; // Eliminate the current column\\n        }\\n    }\\n    return false; // Target value not found in the matrix\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874614,
                "title": "python-3-3-lines-binary-search-w-explanation-t-m-98-99",
                "content": "Here\\'s the intuition:\\n1. Use *binary search* to determine  `row` in which  `target` could  be an element.\\n1. Use *binary search* to determine whether `target` is indeed in `row`.\\n1. Address the edge case in which `target` is outside all rows in `matrix`.\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\\n\\n        if target > matrix[-1][-1]: return False    # <-- #3\\n\\n        row = matrix[bisect_left(matrix, \\n                  target, key = lambda x: x[-1])]   # <-- #1\\n\\n        idx = bisect_left(row, target)              # <-- #2\\n\\n        return row[idx] == target\\n```\\n[https://leetcode.com/problems/search-a-2d-matrix/submissions/1014240294/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(log*MN*) and space complexity is *O*(1), in which *MN* ~ `len(matrix)*len(matrix[0])`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\\n\\n        if target > matrix[-1][-1]: return False    # <-- #3\\n\\n        row = matrix[bisect_left(matrix, \\n                  target, key = lambda x: x[-1])]   # <-- #1\\n\\n        idx = bisect_left(row, target)              # <-- #2\\n\\n        return row[idx] == target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820530,
                "title": "best-c-solution-pure-binary-search-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size(), col = matrix[0].size();\\n        int start = 0, end = row*col - 1;\\n        while(start <= end){\\n            int mid = start + (end-start)/2, element = matrix[mid/col][mid%col];\\n            if(element == target)\\n                return true;\\n            else if(element < target)\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size(), col = matrix[0].size();\\n        int start = 0, end = row*col - 1;\\n        while(start <= end){\\n            int mid = start + (end-start)/2, element = matrix[mid/col][mid%col];\\n            if(element == target)\\n                return true;\\n            else if(element < target)\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680652,
                "title": "c-binary-search-easy-to-understand-fast",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    // log(m*n) = log m + log n\\n    // thus first we run binary search on rows to find in which row target lie and then we run binary search for that row as the matrix is sorted in non decreasing order\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int sr=0,er=n-1; // row start and row end index\\n        int rowans=-1;\\n        while (sr<=er) {\\n            int mid=(sr+er)/2;\\n            if (target>=matrix[mid][0] && target<=matrix[mid][m-1])\\n            {\\n                rowans=mid;\\n                break;\\n            }\\n            else if (target<matrix[mid][0]) er=mid-1;\\n            else if (target>matrix[mid][m-1]) sr=mid+1;\\n        }\\n        if (rowans==-1) return false;\\n        int sc=0,ec=m-1; // col start and col end index of rowans\\n        while (sc<=ec) {\\n            int mid=(sc+ec)/2;\\n            if (matrix[rowans][mid]==target) return true;\\n            else if (matrix[rowans][mid]>target) ec=mid-1;\\n            else if (matrix[rowans][mid]<target) sc=mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    // log(m*n) = log m + log n\\n    // thus first we run binary search on rows to find in which row target lie and then we run binary search for that row as the matrix is sorted in non decreasing order\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int sr=0,er=n-1; // row start and row end index\\n        int rowans=-1;\\n        while (sr<=er) {\\n            int mid=(sr+er)/2;\\n            if (target>=matrix[mid][0] && target<=matrix[mid][m-1])\\n            {\\n                rowans=mid;\\n                break;\\n            }\\n            else if (target<matrix[mid][0]) er=mid-1;\\n            else if (target>matrix[mid][m-1]) sr=mid+1;\\n        }\\n        if (rowans==-1) return false;\\n        int sc=0,ec=m-1; // col start and col end index of rowans\\n        while (sc<=ec) {\\n            int mid=(sc+ec)/2;\\n            if (matrix[rowans][mid]==target) return true;\\n            else if (matrix[rowans][mid]>target) ec=mid-1;\\n            else if (matrix[rowans][mid]<target) sc=mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577873,
                "title": "c-two-approaches-two-pointers-and-binary-search",
                "content": "# Approach-1\\n- Use Two pointers\\n- Start either from the bottom left or from top right so that one pointer will be increasing and the other would be decreasing. In this approach I will start from the bottom-left\\n- Compare the current element with the target. If they are euqal, return true\\n- Else if val is greater than target, we go to the previous row\\n- Else if val is less than target, it means that the target must be present in the current row. So, we keep going to the next column\\n- If we reach to row -1 or column greater than n-1, then it means that the target is not present in the given matrix\\n\\n# Complexity\\n- Time complexity: O(m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target)\\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int i=m-1, j=0;\\n\\n        while(i>=0 && j<n)\\n        {\\n            int val = matrix[i][j];\\n\\n            if(val == target)\\n                return true;\\n\\n            (val > target) ? (i--) : (j++);\\n        }\\n\\n        return false;\\n    }\\n};\\n```\\n\\nBut the question mentioned to solve this problem in O(log(mn)). So...\\n\\n# Approach-2\\n- Here we treat the given matrix as a flattened vector and use binary search to find the target\\n- In the flattened list, if an element is at position `ind`, then its equivalent row in the matrix will be `ind/n` and its equivalent columns will be `ind%n`, where `n` is the number of columns.\\n- Now we simply use the binary search algorithm to solve it\\n\\n\\n# Complexity\\n- Time complexity: O(log(mn))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target)\\n    {\\n        // O(log(mn))\\n\\n        int m = matrix.size(), n = matrix[0].size(), start = 0, end = m*n-1;\\n\\n        while(start <= end)\\n        {\\n            int ind = start+((end-start)/2);    // To avoid overflow\\n            int val = matrix[ind/n][ind%n];\\n\\n            if(val == target)\\n                return true;\\n            else if(val > target)\\n                end = ind-1;\\n            else\\n                start = ind+1;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target)\\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int i=m-1, j=0;\\n\\n        while(i>=0 && j<n)\\n        {\\n            int val = matrix[i][j];\\n\\n            if(val == target)\\n                return true;\\n\\n            (val > target) ? (i--) : (j++);\\n        }\\n\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target)\\n    {\\n        // O(log(mn))\\n\\n        int m = matrix.size(), n = matrix[0].size(), start = 0, end = m*n-1;\\n\\n        while(start <= end)\\n        {\\n            int ind = start+((end-start)/2);    // To avoid overflow\\n            int val = matrix[ind/n][ind%n];\\n\\n            if(val == target)\\n                return true;\\n            else if(val > target)\\n                end = ind-1;\\n            else\\n                start = ind+1;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367843,
                "title": "python-solution-w-explain-treat-as-1-d-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved by performing a binary search on the 2D matrix, treating it as a flattened 1D array. This approach takes advantage of the fact that the matrix is sorted row-wise and column-wise.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate the number of rows and columns in the matrix.\\n2. Initialize lower and upper bounds for binary search.\\n3. Perform binary search on the matrix by treating it as a flattened 1D array.\\n    - Calculate the middle index and get its corresponding row and column in the matrix.\\n    - If the target is greater than the value at the middle index, update the lower bound to search the right half.\\n    - If the target is less than the value at the middle index, update the upper bound to search the left half.\\n    - If the target is equal to the value at the middle index, return True.\\n4. If the binary search loop ends without finding the target, return False.\\n\\n# Complexity\\n- Time complexity: $$O(\\\\log(M \\\\times N))$$, where M is the number of rows and N is the number of columns in the matrix. This is because the search space is halved with each iteration of the binary search loop.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$, as the algorithm uses a constant amount of extra space to store variables such as row, column, lower bound, upper bound, and middle index.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        # Get the number of rows and columns in the matrix\\n        rows, cols = len(matrix), len(matrix[0])\\n\\n        # Initialize the lower and upper bounds for binary search\\n        lo, hi = 0, rows * cols - 1\\n\\n        # Perform binary search\\n        while lo <= hi:\\n            # Calculate the middle index and get its row and column in the matrix\\n            mid = (lo + hi) // 2\\n            r, c = divmod(mid, cols)\\n\\n            # If the target is greater than the value at the middle index,\\n            # update the lower bound to search the right half\\n            if target > matrix[r][c]:\\n                lo = mid + 1\\n            # If the target is less than the value at the middle index,\\n            # update the upper bound to search the left half\\n            elif target < matrix[r][c]:\\n                hi = mid - 1\\n            # If the target is equal to the value at the middle index, return True\\n            else:\\n                return True\\n\\n        # If the binary search loop ends without finding the target, return False\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        # Get the number of rows and columns in the matrix\\n        rows, cols = len(matrix), len(matrix[0])\\n\\n        # Initialize the lower and upper bounds for binary search\\n        lo, hi = 0, rows * cols - 1\\n\\n        # Perform binary search\\n        while lo <= hi:\\n            # Calculate the middle index and get its row and column in the matrix\\n            mid = (lo + hi) // 2\\n            r, c = divmod(mid, cols)\\n\\n            # If the target is greater than the value at the middle index,\\n            # update the lower bound to search the right half\\n            if target > matrix[r][c]:\\n                lo = mid + 1\\n            # If the target is less than the value at the middle index,\\n            # update the upper bound to search the left half\\n            elif target < matrix[r][c]:\\n                hi = mid - 1\\n            # If the target is equal to the value at the middle index, return True\\n            else:\\n                return True\\n\\n        # If the binary search loop ends without finding the target, return False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304500,
                "title": "c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing 2d vector as 1d, by formula-  row*highest_col + col\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log m*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int low = 0;\\n        int high = row*col -1;\\n        int mid;\\n        while(low<=high)\\n        {\\n            mid = low + (high-low)/2;\\n            if(matrix[mid/col][mid%col] == target) return true;\\n            else if(matrix[mid/col][mid%col] < target) low = mid+1;\\n            else high = mid - 1;\\n        }\\n        return false;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int low = 0;\\n        int high = row*col -1;\\n        int mid;\\n        while(low<=high)\\n        {\\n            mid = low + (high-low)/2;\\n            if(matrix[mid/col][mid%col] == target) return true;\\n            else if(matrix[mid/col][mid%col] < target) low = mid+1;\\n            else high = mid - 1;\\n        }\\n        return false;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252593,
                "title": "c-2-solutions-binary-search-beats-100-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> Each row is sorted in non-decreasing order.\\nTherefore, Binary Search can be used \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search can only be used on Linearly Arranged Elements \\n> 1. Each row is sorted in non-decreasing order.\\n> 2. The first integer of each row is greater than the last integer of the previous row.\\n\\nThis means if we linearly arrange the elements of the matrix we will have a sorted array and we can perform Binary Search over it. \\n\\nHow to get an array from matrix -:\\n- Can create an additional array and store matrix elements into the array by row-wise traversing the matrix. But, this will increase the space complexity of the code. $$->O(n)$$\\n- How to do this in constant space ? \\n A 2-D array is alos stored in the memory as a 1-D array,\\n1. A n * m matrix converted into an array:\\n`matrix[x][y] : arr[x * m + y]`\\n2. An array can be converted into n * m matrix: \\n`arr[x] : matrix[x / m][x % m]`\\n\\n# Complexity\\n- Time complexity:$$O(log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size() ; \\n        int col = matrix[0].size() ; \\n        int start = 0 ; \\n        int end = (row * col) - 1 ; \\n\\n        while (start <= end)\\n        {\\n            int mid = (start + end) / 2 ;\\n            int element = matrix[mid/col][mid%col] ;\\n\\n            if (element == target)\\n            {\\n                return true ; \\n            }\\n            else if (element > target)\\n            {\\n                end = mid - 1 ;\\n            }\\n            else\\n            {\\n                start = mid + 1 ; \\n            }\\n        }\\n        return false ;\\n    }\\n};\\n```\\n\\n---\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size() ; \\n        int cols = matrix[0].size() ; \\n\\n        for (int i = 0 ; i < rows ; i ++)\\n        {\\n            for (int j = 0 ; j < cols ; j ++)\\n            {\\n                if (matrix[i][j] == target)\\n                {\\n                    return true ; \\n                }\\n            }\\n        }\\n        return false ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/8fd7e52f-35ec-44fa-a372-456ac1db33fb_1677857878.8051448.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size() ; \\n        int col = matrix[0].size() ; \\n        int start = 0 ; \\n        int end = (row * col) - 1 ; \\n\\n        while (start <= end)\\n        {\\n            int mid = (start + end) / 2 ;\\n            int element = matrix[mid/col][mid%col] ;\\n\\n            if (element == target)\\n            {\\n                return true ; \\n            }\\n            else if (element > target)\\n            {\\n                end = mid - 1 ;\\n            }\\n            else\\n            {\\n                start = mid + 1 ; \\n            }\\n        }\\n        return false ;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size() ; \\n        int cols = matrix[0].size() ; \\n\\n        for (int i = 0 ; i < rows ; i ++)\\n        {\\n            for (int j = 0 ; j < cols ; j ++)\\n            {\\n                if (matrix[i][j] == target)\\n                {\\n                    return true ; \\n                }\\n            }\\n        }\\n        return false ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164331,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& arr, int x) {\\n\\n        int n = arr.size();\\n        int m = arr[0].size();\\n        int t = 0, r = m-1;\\n\\n        while(t<n && r>=0)\\n        {\\n            if(arr[t][r]==x)\\n            {\\n                return true;\\n            }\\n            else if(arr[t][r]>x)\\n            {\\n                r--;\\n            }\\n            else\\n            {\\n                t++;\\n            }\\n        }   \\n        return false;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for i in matrix:\\n            if i[-1] >= target:\\n                return target in i\\n        return False\\n```\\n\\n```Java []\\nclass Solution {\\n  public boolean searchMatrix(int[][] matrix, int target) {\\n    if (matrix.length == 0)\\n      return false;\\n\\n    final int m = matrix.length;\\n    final int n = matrix[0].length;\\n    int l = 0;\\n    int r = m * n;\\n\\n    while (l < r) {\\n      final int mid = (l + r) / 2;\\n      final int i = mid / n;\\n      final int j = mid % n;\\n      if (matrix[i][j] == target)\\n        return true;\\n      if (matrix[i][j] < target)\\n        l = mid + 1;\\n      else\\n        r = mid;\\n    }\\n\\n    return false;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& arr, int x) {\\n\\n        int n = arr.size();\\n        int m = arr[0].size();\\n        int t = 0, r = m-1;\\n\\n        while(t<n && r>=0)\\n        {\\n            if(arr[t][r]==x)\\n            {\\n                return true;\\n            }\\n            else if(arr[t][r]>x)\\n            {\\n                r--;\\n            }\\n            else\\n            {\\n                t++;\\n            }\\n        }   \\n        return false;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for i in matrix:\\n            if i[-1] >= target:\\n                return target in i\\n        return False\\n```\n```Java []\\nclass Solution {\\n  public boolean searchMatrix(int[][] matrix, int target) {\\n    if (matrix.length == 0)\\n      return false;\\n\\n    final int m = matrix.length;\\n    final int n = matrix[0].length;\\n    int l = 0;\\n    int r = m * n;\\n\\n    while (l < r) {\\n      final int mid = (l + r) / 2;\\n      final int i = mid / n;\\n      final int j = mid % n;\\n      if (matrix[i][j] == target)\\n        return true;\\n      if (matrix[i][j] < target)\\n        l = mid + 1;\\n      else\\n        r = mid;\\n    }\\n\\n    return false;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094265,
                "title": "c-easy-6-line-code-o-log-n-m-o-1-space",
                "content": "# Approach\\nSINCE,ACCORDING TO QUESTION FROM 0 TO (MxN-1) ALL ELEMENTS ARE SORTED.\\nWE ARE SIMPLY PERFORMING BINARY SEARCH FROM 0 TO MxN-1.\\n\\nEXAMPLE: \\n[[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\\n\\nTHIS MATRIX CAN BE SEEN LIKE [1,3,5,7,10,11,16,20,23,30,34,60]\\nFOR GETTING ROW INDEX = mid/(M);\\nFOR GETTING column INDEX = mid%(M);\\n\\nIST ROUND :: i=0,j=11,mid=5;\\n2ND ROUND :: i=0,j=4,mid=2;\\n3RD ROUND :: mat[2/4][2%4]==mat[0][2]==5.which is greater than X.therefore,i=0,j=1,mid=0;\\n\\n4TH ROUND :: mat[0][0]==1 . i=1,mid=1,j=1.\\n5TH ROUND :: mat[0][1]=3==X .return true.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(log(m*n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int X) {\\n        int M=mat[0].size(),N=mat.size(),i=0,j=M*N-1,mid=i+(j-i)/2;\\n\\t    while(i<=j){if(mat[mid/M][mid%M]==X)return 1;\\n\\t        else if(mat[mid/M][mid%M]<X)i=mid+1;\\n\\t        else j=mid-1;\\n\\t        mid=i+(j-i)/2;}\\n\\treturn 0;}\\n};\\n```\\nPLEASE CONSIDER UPVOTE .\\nTHANK YOU \\nCODE BY :) AMAN MAURYA",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int X) {\\n        int M=mat[0].size(),N=mat.size(),i=0,j=M*N-1,mid=i+(j-i)/2;\\n\\t    while(i<=j){if(mat[mid/M][mid%M]==X)return 1;\\n\\t        else if(mat[mid/M][mid%M]<X)i=mid+1;\\n\\t        else j=mid-1;\\n\\t        mid=i+(j-i)/2;}\\n\\treturn 0;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970823,
                "title": "fastest-java-beats-100-2022-latest-easiest-solution-83-8-less-memory-usage",
                "content": "Here is the code given below-\\nIf you have any doubt, leave a comment, I will definitely clear it \\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m=matrix.length,n=matrix[0].length,i=0,j=n-1,l=0,r=n-1;\\n        while(i<m && j<n){\\n            if(matrix[i][j]<target) i++;\\n            else{\\n                while(l<=r){\\n                    int mid=l+(r-l)/2;\\n                    if(matrix[i][mid]==target) return true;\\n                    else if(matrix[i][mid]<target) l=mid+1;\\n                    else r=mid-1;\\n                }\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m=matrix.length,n=matrix[0].length,i=0,j=n-1,l=0,r=n-1;\\n        while(i<m && j<n){\\n            if(matrix[i][j]<target) i++;\\n            else{\\n                while(l<=r){\\n                    int mid=l+(r-l)/2;\\n                    if(matrix[i][mid]==target) return true;\\n                    else if(matrix[i][mid]<target) l=mid+1;\\n                    else r=mid-1;\\n                }\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679717,
                "title": "python-soln-binary-search-o-log-m-n",
                "content": "```\\nclass Solution:\\n    def searchMatrix(self, mat: List[List[int]], target: int) -> bool:\\n        m,n=len(mat)-1,len(mat[0])-1\\n        i,j=0,0\\n        #find row where the element may exist\\n        while i<=m:\\n            mid=(i+m)//2\\n            if target < mat[mid][0]:\\n                m=mid-1\\n            elif target > mat[mid][-1]:\\n                i=mid+1\\n            else:\\n                break\\n        #find the value in mid-row\\n        row=mid\\n        while j<=n:\\n            mid=(j+n)//2\\n            if target < mat[row][mid]:\\n                n=mid-1\\n            elif target > mat[row][mid]:\\n                j=mid+1\\n            else:\\n                return True\\n        #if you get here that means element is not there\\n        return False\\n```\\n\\n***Upvote if you got help :-)***",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, mat: List[List[int]], target: int) -> bool:\\n        m,n=len(mat)-1,len(mat[0])-1\\n        i,j=0,0\\n        #find row where the element may exist\\n        while i<=m:\\n            mid=(i+m)//2\\n            if target < mat[mid][0]:\\n                m=mid-1\\n            elif target > mat[mid][-1]:\\n                i=mid+1\\n            else:\\n                break\\n        #find the value in mid-row\\n        row=mid\\n        while j<=n:\\n            mid=(j+n)//2\\n            if target < mat[row][mid]:\\n                n=mid-1\\n            elif target > mat[row][mid]:\\n                j=mid+1\\n            else:\\n                return True\\n        #if you get here that means element is not there\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666473,
                "title": "row-wise-binary-search-o-m-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& arr, int t) {\\n        int m = arr.size();\\n        int n = arr[0].size();\\n        for(int row = 0;row<m;row++){\\n            // binary search\\n            int i = 0,j = n-1;\\n            long int mid;\\n            while(i<=j){\\n                mid = i + (j-i)/2;\\n                if(arr[row][mid] == t) return true;\\n                if(arr[row][mid] > t) j = mid - 1;\\n                else i = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& arr, int t) {\\n        int m = arr.size();\\n        int n = arr[0].size();\\n        for(int row = 0;row<m;row++){\\n            // binary search\\n            int i = 0,j = n-1;\\n            long int mid;\\n            while(i<=j){\\n                mid = i + (j-i)/2;\\n                if(arr[row][mid] == t) return true;\\n                if(arr[row][mid] > t) j = mid - 1;\\n                else i = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317443,
                "title": "c-java-python-o-m-n-to-o-log-mn-very-easy-intuitive-approach",
                "content": "\\u2611 Approach 1: We first move down then right:\\n\\ni. **Stepping down linearly** until we find the row in which our `target` may exist.\\nii. After we reached that row, we **move towards the right linearly** until we find `target` or we reach the end if `target` is not present.\\n\\n*Time complexity: O(m + n), where m and n are the number of rows and the number of columns respectively.\\nSpace complexity: O(1)*\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int row = 0, col = 0;\\n        while(row < m and col < n) {\\n            if(target == matrix[row][col]) return true;\\n            if(target > matrix[row][n - 1]) row++;\\n            else col++;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int row = 0, col = 0;\\n        while(row < m && col < n) {\\n            if(target == matrix[row][col]) return true;\\n            if(target > matrix[row][n - 1]) row++;\\n            else col++;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        m, n = len(matrix), len(matrix[0])\\n        row, col = 0, 0\\n        while row < m and col < n:\\n            if target == matrix[row][col]: return True\\n            if target > matrix[row][n - 1]: row += 1\\n            else: col += 1\\n        return False\\n```\\n\\n\\u2611 Approach 2: We follow the same approach as we did earlier but this time we\\'ll take advantage of the fact that the matrix is **row-wise and column-wise sorted**. We can hence, apply **binary search** to **reduce the number of steps**.\\n\\ni. First we try to find the row where our target may lie, say `targetRow`. For this, we will use binary search to find the **last element which is smaller** than `target` in the 1st column.\\nii. After we find `targetRow`, we will again use binary search in `targetRow` to search for `target`.\\n\\n*Time complexity: O(log m + log n) or O(log mn)\\nSpace complexity: O(1)*\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        \\n        // Step 1: Find the row in which target can lie (the last element which is smaller than target in the 1st column)\\n        int start = 0, end = m - 1, targetRow = 0;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(target == matrix[mid][0]) return true;\\n            if(target > matrix[mid][0]) {\\n                targetRow = mid;\\n                start = mid + 1;\\n            } else end = mid - 1;\\n        }\\n        \\n        // Step 2: Search in this row\\n        start = 0, end = n - 1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(target == matrix[targetRow][mid]) return true;\\n            if(target > matrix[targetRow][mid]) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        // If element is not present in the matrix\\n        return false;\\n    }\\n};\\n```\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        \\n        // Step 1: Find the row in which target can lie (the last element which is smaller than target in the 1st column)\\n        int start = 0, end = m - 1, targetRow = 0;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(target == matrix[mid][0]) return true;\\n            if(target > matrix[mid][0]) {\\n                targetRow = mid;\\n                start = mid + 1;\\n            } else end = mid - 1;\\n        }\\n        \\n        // Step 2: Search in this row\\n        start = 0; \\n        end = n - 1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(target == matrix[targetRow][mid]) return true;\\n            if(target > matrix[targetRow][mid]) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        // If element is not present in the matrix\\n        return false;\\n    }\\n}\\n```\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        # Step 1: Find the row in which target can lie (the last element which is smaller than target in the 1st column)\\n        start, end, targetRow = 0, m - 1, 0\\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            if target == matrix[mid][0]: \\n                return True\\n            if target > matrix[mid][0]:\\n                targetRow = mid\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n                \\n        # Step 2: Search in this row\\n        start, end = 0, n - 1\\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            if target == matrix[targetRow][mid]:\\n                return True\\n            if target > matrix[targetRow][mid]:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        \\n        # If element is not present in the matrix\\n        return False\\n```\\n\\n\\uD83D\\uDCAFThanks a lot for reading.\\nAn upvote would be appreciated!  ^_^",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int row = 0, col = 0;\\n        while(row < m and col < n) {\\n            if(target == matrix[row][col]) return true;\\n            if(target > matrix[row][n - 1]) row++;\\n            else col++;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int row = 0, col = 0;\\n        while(row < m && col < n) {\\n            if(target == matrix[row][col]) return true;\\n            if(target > matrix[row][n - 1]) row++;\\n            else col++;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        m, n = len(matrix), len(matrix[0])\\n        row, col = 0, 0\\n        while row < m and col < n:\\n            if target == matrix[row][col]: return True\\n            if target > matrix[row][n - 1]: row += 1\\n            else: col += 1\\n        return False\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        \\n        // Step 1: Find the row in which target can lie (the last element which is smaller than target in the 1st column)\\n        int start = 0, end = m - 1, targetRow = 0;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(target == matrix[mid][0]) return true;\\n            if(target > matrix[mid][0]) {\\n                targetRow = mid;\\n                start = mid + 1;\\n            } else end = mid - 1;\\n        }\\n        \\n        // Step 2: Search in this row\\n        start = 0, end = n - 1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(target == matrix[targetRow][mid]) return true;\\n            if(target > matrix[targetRow][mid]) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        // If element is not present in the matrix\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        \\n        // Step 1: Find the row in which target can lie (the last element which is smaller than target in the 1st column)\\n        int start = 0, end = m - 1, targetRow = 0;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(target == matrix[mid][0]) return true;\\n            if(target > matrix[mid][0]) {\\n                targetRow = mid;\\n                start = mid + 1;\\n            } else end = mid - 1;\\n        }\\n        \\n        // Step 2: Search in this row\\n        start = 0; \\n        end = n - 1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(target == matrix[targetRow][mid]) return true;\\n            if(target > matrix[targetRow][mid]) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        // If element is not present in the matrix\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        # Step 1: Find the row in which target can lie (the last element which is smaller than target in the 1st column)\\n        start, end, targetRow = 0, m - 1, 0\\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            if target == matrix[mid][0]: \\n                return True\\n            if target > matrix[mid][0]:\\n                targetRow = mid\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n                \\n        # Step 2: Search in this row\\n        start, end = 0, n - 1\\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            if target == matrix[targetRow][mid]:\\n                return True\\n            if target > matrix[targetRow][mid]:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        \\n        # If element is not present in the matrix\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197994,
                "title": "java-o-m-n-solution-0ms-100-faster-nice-for-interview",
                "content": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        for(int i = 0; i < m; i++){\\n            if(target > matrix[i][0] && target < matrix[i][n-1]){\\n                for(int j = 1; j < n; j++){\\n                    if(target == matrix[i][j]){\\n                        return true;\\n                    }\\n                }\\n            }\\n            else if(target == matrix[i][0]){\\n                return true;\\n            }\\n            else if(target == matrix[i][n-1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        for(int i = 0; i < m; i++){\\n            if(target > matrix[i][0] && target < matrix[i][n-1]){\\n                for(int j = 1; j < n; j++){\\n                    if(target == matrix[i][j]){\\n                        return true;\\n                    }\\n                }\\n            }\\n            else if(target == matrix[i][0]){\\n                return true;\\n            }\\n            else if(target == matrix[i][n-1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896414,
                "title": "b-s-by-representing-matrix-to-linear-form-explanation-with-image-o-log-row-col",
                "content": "![image](https://assets.leetcode.com/users/images/d02ed7b1-001e-42f3-8a57-eb54daff83e8_1648615940.6509197.jpeg)\\n\\n\\n**Approach:**\\n\\u27A1 Representing matrix in linear form and then applying the binary search to find target.\\n\\u27A1 we first calculate #rows, #columns\\n1. To apply binary search: \\n\\tTake start =0, **end = row*col -1 ;**\\n\\tmid = start +(end-start)/2\\n2.  Important thing to notice is select element to compare with target.\\n\\telement = **matrix [mid/col] [mid%col]**\\n\\tnow simply apply binary Search\\n\\t\\n\\t\\n```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int st =0;\\n        int end= row*col-1;\\n        \\n        \\n        while(st<=end){\\n            int mid= st+ (end-st)/2;\\n            int ele=matrix[mid/col][mid%col];\\n            if(ele==target)\\n                return 1;\\n            if(ele<target)\\n                st=mid+1;\\n            else\\n                end=mid-1;\\n        }\\n        \\n        return 0;\\n    }\\n```\\n\\u2705**Upvote++ if u liked the solution  (\\u25E0\\u203F\\u25E0)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Matrix",
                    "Binary Tree"
                ],
                "code": "```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int st =0;\\n        int end= row*col-1;\\n        \\n        \\n        while(st<=end){\\n            int mid= st+ (end-st)/2;\\n            int ele=matrix[mid/col][mid%col];\\n            if(ele==target)\\n                return 1;\\n            if(ele<target)\\n                st=mid+1;\\n            else\\n                end=mid-1;\\n        }\\n        \\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1895953,
                "title": "c-array-binarysearch-the-rows-array-binarysearch-that-row-or-linq",
                "content": "I hate writing BinarySearches when one exists in C#. The trick is to write a Comparer that works on the last element in the rows. Because the binary search uses the last element in the rows, we have to pass target in as a row, with target as the last (only) element.\\n\\nThen we BinarySearch the correct row.\\n\\nTest cases are probably small and the cost of performing a binary search on the rows, followed by one on the row is slower than linq sequentially selecting the row and then Array.BinarySearch on that row.\\n\\n\\n148 ms of fun; useful in huge matrices.\\n```\\n    public bool SearchMatrix(int[][] matrix, int target) {\\n        \\n        var targetRow = new int[] {target};\\n        int row = Array.BinarySearch(matrix, targetRow, new RowComparer() );\\n        if(row < 0) row = ~row;\\n        \\n        if(row >= matrix.Length) return false;\\n        \\n        return Array.BinarySearch(matrix[row], target) >= 0;\\n    }\\n\\n    public class RowComparer: Comparer<int[]>\\n    {\\n        public override int Compare(int[] a, int[] b)\\n        {\\n            //if(object.ReferenceEquals(a, b)) return 0;\\n            //if(a == null) return -1;\\n            //if(b == null) return 1;\\n\\n            return a[^1].CompareTo(b[^1]);\\n        }\\n    }\\n\\n\\n```\\n\\n\\n\\n\\nUse LINQ to return the correct row to the built-in Array.BinarySearch method.\\n\\n88 ms of fun. Useful with matrices that have few rows that may be long.\\n```\\n\\n    public bool SearchMatrix(int[][] matrix, int target) {\\n\\t\\treturn Array.BinarySearch(matrix.Where(x => x[^1] >= target).FirstOrDefault(new int[0]), target) >= 0;\\n\\t}\\n```\\n\\nLINQ Only, sequential search. 96ms. Usefule for small matrices.\\n\\n```\\n    public bool SearchMatrix2(int[][] matrix, int target) {\\n        return matrix.Where(x => x[^1] >= target).FirstOrDefault(new int[0]).Contains(target);\\n    }\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public bool SearchMatrix(int[][] matrix, int target) {\\n        \\n        var targetRow = new int[] {target};\\n        int row = Array.BinarySearch(matrix, targetRow, new RowComparer() );\\n        if(row < 0) row = ~row;\\n        \\n        if(row >= matrix.Length) return false;\\n        \\n        return Array.BinarySearch(matrix[row], target) >= 0;\\n    }\\n\\n    public class RowComparer: Comparer<int[]>\\n    {\\n        public override int Compare(int[] a, int[] b)\\n        {\\n            //if(object.ReferenceEquals(a, b)) return 0;\\n            //if(a == null) return -1;\\n            //if(b == null) return 1;\\n\\n            return a[^1].CompareTo(b[^1]);\\n        }\\n    }\\n\\n\\n```\n```\\n\\n    public bool SearchMatrix(int[][] matrix, int target) {\\n\\t\\treturn Array.BinarySearch(matrix.Where(x => x[^1] >= target).FirstOrDefault(new int[0]), target) >= 0;\\n\\t}\\n```\n```\\n    public bool SearchMatrix2(int[][] matrix, int target) {\\n        return matrix.Where(x => x[^1] >= target).FirstOrDefault(new int[0]).Contains(target);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895843,
                "title": "c-binary-search-o-logn-easy-understanding",
                "content": "\\n\\nIf you expand all rows into one row \\nThen it will be a one-dimension sorted array. \\nAs a sorted array, we can search it by binary \\nsearch with time complexity O(logN).\\n\\nFor example, the following matrix\\n```\\n| 1, 2, 3, 4 | \\n| 5, 6, 7, 8 | \\n| 9,10,11,12 | \\n|13,14,15,16 | \\n``` \\ncan be see as \\n```\\n|1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16|\\n```\\nThe index of 10 in one dimension sorted array is 9. \\nAnd it\\'s index for matrix is (2,1) = (9/4,  9%4).\\n\\nIn general, When the index M is in one dimension sorted array, \\nthen it\\'s  mapping index in matrix is (M/cols, M%cols) \\n\\n\\nSo, in the following code, we process this matrix \\nas a sorted array and do the binary search. \\n\\n# Source Code \\n\\n```C++\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int cols = matrix[0].size();\\n        int n = matrix.size() * cols;\\n        int L=0, R=n-1;\\n        while(L<=R) {\\n            int M = L+(R-L)/2;\\n            int v = matrix[M/cols][M%cols];\\n            if (target > v) \\n                L = M + 1;\\n            else if (target < v ) \\n                R = M - 1;\\n            else\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\nIf we assume N is the number of all element in the matrix, then\\ntime complexity is O(logN)  and space complexity is O(1).\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n| 1, 2, 3, 4 | \\n| 5, 6, 7, 8 | \\n| 9,10,11,12 | \\n|13,14,15,16 | \\n```\n```\\n|1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16|\\n```\n```C++\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int cols = matrix[0].size();\\n        int n = matrix.size() * cols;\\n        int L=0, R=n-1;\\n        while(L<=R) {\\n            int M = L+(R-L)/2;\\n            int v = matrix[M/cols][M%cols];\\n            if (target > v) \\n                L = M + 1;\\n            else if (target < v ) \\n                R = M - 1;\\n            else\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700423,
                "title": "python-3-two-solutions-40ms-binary-search-linear-search-in-2d-matrix-easy-to-understand",
                "content": "#### I solved using 2 Approaches:-\\n\\n\\n***1 - Without Binary Search, Just Linear Search in 2D Matrix (Takes 40ms) :-***\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for i in range(len(matrix)):\\n            if target == matrix[i][0]:\\n                return True\\n            if target < matrix[i][0]:\\n                for j in range(len(matrix[i-1])):\\n                    if target==matrix[i-1][j]:\\n                        return True\\n            elif target == matrix[i][len(matrix[i])-1]:\\n                return True\\n            elif target <= matrix[i][len(matrix[i])-1]:\\n                for j in range(len(matrix[i])):\\n                    if target==matrix[i][j]:\\n                        return True\\n        return False\\n```\\n\\n.\\n\\n***2 - Using Binary Search while Treating 2D Matrix as one big List (Takes 40ms) :-***\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows, cols = len(matrix), len(matrix[0])\\n        low, high = 0, rows*cols-1\\n        while low <= high:\\n            mid = (low + high) // 2\\n            num = matrix[mid // cols][mid % cols]\\n            if num == target:\\n                return True\\n            elif num < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Matrix",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for i in range(len(matrix)):\\n            if target == matrix[i][0]:\\n                return True\\n            if target < matrix[i][0]:\\n                for j in range(len(matrix[i-1])):\\n                    if target==matrix[i-1][j]:\\n                        return True\\n            elif target == matrix[i][len(matrix[i])-1]:\\n                return True\\n            elif target <= matrix[i][len(matrix[i])-1]:\\n                for j in range(len(matrix[i])):\\n                    if target==matrix[i][j]:\\n                        return True\\n        return False\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows, cols = len(matrix), len(matrix[0])\\n        low, high = 0, rows*cols-1\\n        while low <= high:\\n            mid = (low + high) // 2\\n            num = matrix[mid // cols][mid % cols]\\n            if num == target:\\n                return True\\n            elif num < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538079,
                "title": "java-100-approach-if-cell-value-target-increment-row-if-smaller-decrement-column",
                "content": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        int row = 0;\\n        int column = matrix[0].length -1;\\n        //Approach: Start from the last column of a row\\n        // If target is less than the last element of the row\\n        // It means, row contains the target, so search it by doing column--;\\n        \\n        //If target is greater than the last element of the row\\n        // It means the row doesn\\'t contains the target\\n        // So, increase the row by doing row++\\n        \\n        \\n        while(row < matrix.length && column >= 0){\\n            if(matrix[row][column] == target) return true;\\n            \\n            \\n            //If target is smaller than the last element of row\\n            if(target < matrix[row][column]){\\n                column--;\\n            }else{\\n                row++; // If target is greater than the last element of row;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        int row = 0;\\n        int column = matrix[0].length -1;\\n        //Approach: Start from the last column of a row\\n        // If target is less than the last element of the row\\n        // It means, row contains the target, so search it by doing column--;\\n        \\n        //If target is greater than the last element of the row\\n        // It means the row doesn\\'t contains the target\\n        // So, increase the row by doing row++\\n        \\n        \\n        while(row < matrix.length && column >= 0){\\n            if(matrix[row][column] == target) return true;\\n            \\n            \\n            //If target is smaller than the last element of row\\n            if(target < matrix[row][column]){\\n                column--;\\n            }else{\\n                row++; // If target is greater than the last element of row;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26207,
                "title": "c-solution",
                "content": "Start at the last element in the first row. If target is larger than current element then increase row number, otherwise decrease the column number.\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        if (matrix.size() == 0) return false;\\n        int i=0, j=matrix[0].size()-1;\\n        while (i < matrix.size() && j >= 0) {\\n            if (matrix[i][j] == target) {\\n                return true;\\n            }\\n            else if (matrix[i][j] > target) {\\n                j--;\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        if (matrix.size() == 0) return false;\\n        int i=0, j=matrix[0].size()-1;\\n        while (i < matrix.size() && j >= 0) {\\n            if (matrix[i][j] == target) {\\n                return true;\\n            }\\n            else if (matrix[i][j] > target) {\\n                j--;\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093011,
                "title": "c-beats-100-explained-binary-search",
                "content": "# *PLEASE UPVOTE IF IT HELPED*\\n\\n\\n---\\n\\n# Approach\\n\\n***(Also explained in the code)***\\n\\n1. `row` and `col` store the dimensions of the matrix.\\n1. `low` and `high` are initialized to set up a binary search range spanning the entire matrix.\\n1. The `while` loop performs binary search on the matrix.\\n1. `mid` calculates the index in the flattened matrix.\\n1. `element` extracts the value at the calculated index.\\n1. If `element` matches the `target`, the function returns `true`.\\n1. If `element` is less than the `target`, the `low` bound is adjusted.\\n1. If `element` is greater than the `target`, the `high` bound is adjusted.\\n1. If the loop completes without finding the `target`, the function returns `false`.\\n\\n---\\n\\n\\n\\n# Complexity\\n- **Time complexity:**\\n$$O(log(n+m))$$\\n\\n- **Space complexity:**\\n$$O(1)$$\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int low = 0; // Initialize the lower bound of the search range.\\n        int high = (row * col) - 1; // Initialize the upper bound of the search range.\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2; // Calculate the middle index.\\n            int element = matrix[mid / col][mid % col]; // Extract the element at the middle index.\\n\\n            if (element == target) {\\n                return true; // If the target is found, return true.\\n            } else if (element < target) {\\n                low = mid + 1; // If the element is less than the target, adjust the lower bound.\\n            } else {\\n                high = mid - 1; // If the element is greater than the target, adjust the upper bound.\\n            }\\n        }\\n\\n        return false; // If the target is not found, return false.\\n    }\\n};\\n\\n```\\n# *PLEASE UPVOTE IF IT HELPED*\\n\\n\\n---\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int low = 0; // Initialize the lower bound of the search range.\\n        int high = (row * col) - 1; // Initialize the upper bound of the search range.\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2; // Calculate the middle index.\\n            int element = matrix[mid / col][mid % col]; // Extract the element at the middle index.\\n\\n            if (element == target) {\\n                return true; // If the target is found, return true.\\n            } else if (element < target) {\\n                low = mid + 1; // If the element is less than the target, adjust the lower bound.\\n            } else {\\n                high = mid - 1; // If the element is greater than the target, adjust the upper bound.\\n            }\\n        }\\n\\n        return false; // If the target is not found, return false.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954242,
                "title": "simple-easy-python-solution-using-binary-search-beginner-s-friendly",
                "content": "p# Code\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows,columns=len(matrix),len(matrix[0])\\n        top,bottom=0,rows-1\\n        while top<=bottom:\\n            row=(top+bottom)//2\\n            if target<matrix[row][0]:\\n                bottom=row-1\\n            elif target>matrix[row][-1]:\\n                top=row+1\\n            else:\\n                break\\n        row=(top+bottom)//2\\n        l,r=0,columns-1\\n        while l<=r:\\n            mid=(l+r)//2\\n            if target<matrix[row][mid]:\\n                r=mid-1\\n            elif target>matrix[row][mid]:\\n                l=mid+1\\n            else:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows,columns=len(matrix),len(matrix[0])\\n        top,bottom=0,rows-1\\n        while top<=bottom:\\n            row=(top+bottom)//2\\n            if target<matrix[row][0]:\\n                bottom=row-1\\n            elif target>matrix[row][-1]:\\n                top=row+1\\n            else:\\n                break\\n        row=(top+bottom)//2\\n        l,r=0,columns-1\\n        while l<=r:\\n            mid=(l+r)//2\\n            if target<matrix[row][mid]:\\n                r=mid-1\\n            elif target>matrix[row][mid]:\\n                l=mid+1\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941010,
                "title": "3-lines-of-code-with-explaination",
                "content": "# Article: Searching in a Matrix - C++ Solution Explained\\n\\nSearching for a specific target value in a matrix is a fundamental problem in computer science, often requiring careful consideration of the matrix\\'s properties and the choice of an efficient search algorithm. In this article, we\\'ll delve into a C++ solution that searches for a target value within a matrix. We\\'ll break down the code step by step, discuss its approach, and explore alternative solutions for improved efficiency.\\n\\n## The Problem\\n\\nGiven a 2D matrix with sorted rows and columns, the task is to determine whether a specific target value exists within the matrix.\\n\\n## The Solution\\n\\nThe provided C++ solution employs a simple linear search approach to find the target value within the matrix. It iterates through each element in the matrix, checking if the current element matches the target value. Let\\'s examine the code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for (auto x : matrix) {\\n            for (auto key : x) {\\n                if (key == target) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n## How It Works\\n\\n1. The `searchMatrix` function takes a 2D matrix and a target value as input.\\n\\n2. The solution employs a nested loop structure. The outer loop iterates through each row of the matrix (represented by `x`).\\n\\n3. The inner loop iterates through each element in the current row (represented by `key`).\\n\\n4. For each element, the solution checks if it matches the target value. If a match is found, the function returns `true`, indicating that the target value exists in the matrix.\\n\\n5. If no match is found after iterating through the entire matrix, the function returns `false`.\\n\\n## Complexity Analysis\\n\\nThe solution iterates through each element of the matrix once, performing constant-time operations for each element. Therefore, the time complexity is **O(m * n)**, where **m** is the number of rows and **n** is the number of columns in the matrix. The space complexity is **O(1)**, as the solution only uses a constant amount of extra space for variables.\\n\\n## Alternative Approaches\\n\\nWhile the provided solution is straightforward, it might not be the most efficient approach for matrices with certain properties, such as being sorted along rows and columns. An alternative approach could involve utilizing the matrix\\'s sorted nature to implement a more optimized search algorithm, such as binary search.\\n\\n## Conclusion\\n\\nThe provided C++ solution effectively solves the problem of searching for a target value within a 2D matrix using a linear search approach. By iterating through the matrix and comparing elements with the target value, the solution provides a simple and understandable solution.\\n\\nHowever, it\\'s important to consider the efficiency of the solution, especially for large matrices. Exploring alternative algorithms, such as binary search, can lead to more optimized solutions, emphasizing the importance of selecting appropriate techniques for different problem scenarios.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for (auto x : matrix) {\\n            for (auto key : x) {\\n                if (key == target) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876044,
                "title": "o-log-m-n-solution-beginner-friendly-100-beats-fully-explained",
                "content": "# Approach\\n\\n**Step 1: Understand the Problem:**\\nThe problem provides a 2D matrix with two key properties: each row is sorted in non-decreasing order, and the first integer of each row is greater than the last integer of the previous row. You are required to find whether a given target integer exists in this matrix.\\n\\n**Step 2: Binary Search Approach:**\\nYour solution employs a binary search algorithm to efficiently locate the target in the matrix.\\n\\n**Step 3: Binary Search Implementation:**\\n\\n1. **Initialization:**\\n   - You start by obtaining the dimensions of the matrix: `m` represents the number of rows, and `n` represents the number of columns.\\n   - You set up two pointers, `left` and `right`, to define the search range within the flattened matrix. The search space is from index `0` to `m * n - 1`.\\n\\n2. **Binary Search Loop:**\\n   - You enter a loop that continues as long as the `left` pointer is less than or equal to the `right` pointer. This ensures that the search space is not exhausted.\\n\\n3. **Midpoint Calculation:**\\n   - Inside the loop, you calculate the midpoint index, `mid`, using the formula: `mid = left + (right - left) / 2`. This approach prevents potential integer overflow and gives you the middle index.\\n\\n4. **Mapping to 2D Indices:**\\n   - You determine the `row` and `col` indices in the original 2D matrix that correspond to the `mid` index in the flattened matrix. This is achieved using integer division (`mid / n`) for the row and the remainder (`mid % n`) for the column.\\n\\n5. **Middle Value Comparison:**\\n   - You retrieve the value at the calculated `row` and `col` indices from the original matrix. This value is termed `midValue`.\\n   - You compare `midValue` with the target:\\n     - If they are equal, you have found the target in the matrix, and you return `true`.\\n     - If `midValue` is less than the target, you adjust the `left` pointer to focus on the right half of the search space.\\n     - If `midValue` is greater than the target, you adjust the `right` pointer to focus on the left half of the search space.\\n\\n6. **Repeat Loop:**\\n   - The loop continues, recalculating the midpoint and comparing values until the search space is either exhausted (no more elements to search) or the target is found.\\n\\n7. **Return Result:**\\n   - If the loop exits without finding the target, you return `false` to indicate that the target is not present in the matrix.\\n\\n\\n# Complexity\\n- Time complexity: $$O(log(m * n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n        int left = 0;\\n        int right = m * n - 1; // Total number of elements in the flattened matrix\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2; // Calculate the mid index\\n            \\n            int row = mid / n; // Calculate the row index\\n            int col = mid % n; // Calculate the column index\\n            \\n            int midValue = matrix[row][col]; // Value at the middle index\\n            \\n            if (midValue == target) {\\n                return true;\\n            } else if (midValue < target) {\\n                left = mid + 1; // Search the right half\\n            } else {\\n                right = mid - 1; // Search the left half\\n            }\\n        }\\n        \\n        return false; // Target not found\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n        int left = 0;\\n        int right = m * n - 1; // Total number of elements in the flattened matrix\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2; // Calculate the mid index\\n            \\n            int row = mid / n; // Calculate the row index\\n            int col = mid % n; // Calculate the column index\\n            \\n            int midValue = matrix[row][col]; // Value at the middle index\\n            \\n            if (midValue == target) {\\n                return true;\\n            } else if (midValue < target) {\\n                left = mid + 1; // Search the right half\\n            } else {\\n                right = mid - 1; // Search the left half\\n            }\\n        }\\n        \\n        return false; // Target not found\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875888,
                "title": "easy-c-solution-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log(m*n))\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int r=0, c=n-1;\\n\\n        while(r<m and c>=0){\\n            if(matrix[r][c]==target) return true;\\n            matrix[r][c]>target ? c-- : r++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int r=0, c=n-1;\\n\\n        while(r<m and c>=0){\\n            if(matrix[r][c]==target) return true;\\n            matrix[r][c]>target ? c-- : r++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875283,
                "title": "binary-search-in-o-n-log-m-recursion-optimal-solution",
                "content": "# Approach\\nSimple Binary Search Approach.\\n\\n# Complexity\\n- Time complexity: O(n*log(m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        return search(matrix, target);\\n    }\\nprivate:\\n    bool search(vector<vector<int>>mat, int target) {\\n        int mid = mat.size() / 2; \\n        if (mid == 0) {\\n            for (int num : mat[0]) {\\n                if (num == target) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        } else if (mat[mid][0] > target) {\\n            return search(vector<vector<int>>(mat.begin(), mat.begin() + mid), target);\\n        }  \\n        return search(vector<vector<int>>(mat.begin() + mid, mat.end()), target);\\n    }\\n\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        def search(mat):\\n            mid = len(mat)//2\\n            if mid == 0:\\n                return target in mat[0]\\n            elif mat[mid][0] > target:\\n                return search(mat[:mid])\\n            return search(mat[mid:])\\n        return search(matrix)\\n        \\n```\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n\\n![upvote-man.gif](https://assets.leetcode.com/users/images/a3643ab8-acf4-485e-8934-54d6990e91d2_1691390926.9803555.gif)",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        return search(matrix, target);\\n    }\\nprivate:\\n    bool search(vector<vector<int>>mat, int target) {\\n        int mid = mat.size() / 2; \\n        if (mid == 0) {\\n            for (int num : mat[0]) {\\n                if (num == target) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        } else if (mat[mid][0] > target) {\\n            return search(vector<vector<int>>(mat.begin(), mat.begin() + mid), target);\\n        }  \\n        return search(vector<vector<int>>(mat.begin() + mid, mat.end()), target);\\n    }\\n\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        def search(mat):\\n            mid = len(mat)//2\\n            if mid == 0:\\n                return target in mat[0]\\n            elif mat[mid][0] > target:\\n                return search(mat[:mid])\\n            return search(mat[mid:])\\n        return search(matrix)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874771,
                "title": "video-solution-c-java-explanation-with-drawings",
                "content": "# Intuition, approach, and time complexity dicussed in detail in video solution\\nhttps://youtu.be/PHBBLr1bWao\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rw = matrix.size(), cl = matrix[0].size();\\n  \\n        int left = 0, right = rw * cl-1;\\n        while(left <= right){\\n            int midPos =  left + (right - left)/2;\\n \\n            int r = midPos / cl, c = midPos % cl;\\n     \\n            if(matrix[r][c] == target){\\n                return true;\\n            }else if(matrix[r][c] < target){\\n                left = midPos + 1;\\n            }else{\\n                right = midPos - 1;\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int rw = matrix.length, cl = matrix[0].length;\\n        int left = 0, right = rw * cl-1;\\n        while(left <= right){\\n            int midPos =  left + (right - left)/2;\\n            int r = midPos / cl, c = midPos % cl;\\n            if(matrix[r][c] == target){\\n                return true;\\n            }else if(matrix[r][c] < target){\\n                left = midPos + 1;\\n            }else{\\n                right = midPos - 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rw = matrix.size(), cl = matrix[0].size();\\n  \\n        int left = 0, right = rw * cl-1;\\n        while(left <= right){\\n            int midPos =  left + (right - left)/2;\\n \\n            int r = midPos / cl, c = midPos % cl;\\n     \\n            if(matrix[r][c] == target){\\n                return true;\\n            }else if(matrix[r][c] < target){\\n                left = midPos + 1;\\n            }else{\\n                right = midPos - 1;\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int rw = matrix.length, cl = matrix[0].length;\\n        int left = 0, right = rw * cl-1;\\n        while(left <= right){\\n            int midPos =  left + (right - left)/2;\\n            int r = midPos / cl, c = midPos % cl;\\n            if(matrix[r][c] == target){\\n                return true;\\n            }else if(matrix[r][c] < target){\\n                left = midPos + 1;\\n            }else{\\n                right = midPos - 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874243,
                "title": "c-binary-search-using-lower-bound-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse C++ lower_bound as binary search function.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(\\\\log n+\\\\log m)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& v, int target) {\\n        return lower_bound(v.begin(), v.end(), target) - v.begin();\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        if (n == 1) {\\n            int j=search(matrix[0], target);\\n            if (j==m) return 0;\\n            return matrix[0][j] == target;\\n        }\\n        \\n        vector<int> col0(n);\\n        for (int i = 0; i < n; i++) \\n            col0[i] = matrix[i][0];\\n\\n        int i0 = search(col0, target);\\n        \\n        if (i0 == n) {\\n            int j = search(matrix[i0 - 1], target);\\n            if (j==m) return 0;\\n            return matrix[i0 - 1][j] == target;\\n        }\\n        else if (col0[i0] == target) \\n            return 1;\\n        else if (i0 == 0) \\n            return 0;\\n        else {\\n            int j = search(matrix[i0 - 1], target);\\n            if (j==m) return 0;\\n            return matrix[i0 - 1][j] == target;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& v, int target) {\\n        return lower_bound(v.begin(), v.end(), target) - v.begin();\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        if (n == 1) {\\n            int j=search(matrix[0], target);\\n            if (j==m) return 0;\\n            return matrix[0][j] == target;\\n        }\\n        \\n        vector<int> col0(n);\\n        for (int i = 0; i < n; i++) \\n            col0[i] = matrix[i][0];\\n\\n        int i0 = search(col0, target);\\n        \\n        if (i0 == n) {\\n            int j = search(matrix[i0 - 1], target);\\n            if (j==m) return 0;\\n            return matrix[i0 - 1][j] == target;\\n        }\\n        else if (col0[i0] == target) \\n            return 1;\\n        else if (i0 == 0) \\n            return 0;\\n        else {\\n            int j = search(matrix[i0 - 1], target);\\n            if (j==m) return 0;\\n            return matrix[i0 - 1][j] == target;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793841,
                "title": "java-striver-easy-understanding",
                "content": "#### Efficient Solution\\n**Time Complexity:** O(log(m*n))\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\n\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int rowIdx = searchPotentialRow(matrix, target);\\n        if (rowIdx != -1) return binarySearchOverRow(rowIdx, matrix, target);\\n        else return false;\\n    }\\n\\n    private int searchPotentialRow(int[][] matrix, int target) {\\n        int low = 0;\\n        int high = matrix.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (matrix[mid][0] <= target && target <= matrix[mid][matrix[0].length - 1]) {\\n                return mid;\\n            } else if (matrix[mid][0] < target) low = mid + 1;\\n            else if (matrix[mid][0] > target) high = mid - 1;\\n        }\\n        return -1;\\n    }\\n\\n    private boolean binarySearchOverRow(int rowIdx, int[][] matrix, int target) {\\n        int low = 0;\\n        int high = matrix[rowIdx].length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (matrix[rowIdx][mid] == target) return true;\\n            else if (matrix[rowIdx][mid] > target) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int rowIdx = searchPotentialRow(matrix, target);\\n        if (rowIdx != -1) return binarySearchOverRow(rowIdx, matrix, target);\\n        else return false;\\n    }\\n\\n    private int searchPotentialRow(int[][] matrix, int target) {\\n        int low = 0;\\n        int high = matrix.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (matrix[mid][0] <= target && target <= matrix[mid][matrix[0].length - 1]) {\\n                return mid;\\n            } else if (matrix[mid][0] < target) low = mid + 1;\\n            else if (matrix[mid][0] > target) high = mid - 1;\\n        }\\n        return -1;\\n    }\\n\\n    private boolean binarySearchOverRow(int rowIdx, int[][] matrix, int target) {\\n        int low = 0;\\n        int high = matrix[rowIdx].length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (matrix[rowIdx][mid] == target) return true;\\n            else if (matrix[rowIdx][mid] > target) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504057,
                "title": "simple-java-o-m-n-solution",
                "content": "This is my simle java  O(m+n) solution\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        //check if input data is incorrect\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n\\n        //start from top-right of the matrix\\n        // and go to the left-and-down\\n        // while indexes in bounds of m,n or don\\'t find target\\n        int rowIndex = 0;\\n        int columnIndex = matrix[0].length - 1;\\n        while (columnIndex >= 0 && rowIndex <= matrix.length - 1) {\\n            int currentValue = matrix[rowIndex][columnIndex];\\n            if (currentValue == target) {\\n                return true;\\n            }\\n\\n            if (currentValue < target) {\\n                rowIndex++;\\n            } else {\\n                columnIndex--;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        //check if input data is incorrect\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n\\n        //start from top-right of the matrix\\n        // and go to the left-and-down\\n        // while indexes in bounds of m,n or don\\'t find target\\n        int rowIndex = 0;\\n        int columnIndex = matrix[0].length - 1;\\n        while (columnIndex >= 0 && rowIndex <= matrix.length - 1) {\\n            int currentValue = matrix[rowIndex][columnIndex];\\n            if (currentValue == target) {\\n                return true;\\n            }\\n\\n            if (currentValue < target) {\\n                rowIndex++;\\n            } else {\\n                columnIndex--;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127494,
                "title": "clear-code-python-solution",
                "content": "# Intuition\\nTwo bin searches\\n\\n# Approach\\nAt first, you need to find row\\n\\n# Complexity\\n- Time complexity:\\nO(log(n*m))\\n\\n- Space complexity:\\nO(1) #Not sure)\\n\\n# Code\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        l, r = 0, len(matrix)-1\\n        col = -1\\n        while l <= r:\\n            mid = (l+r)//2\\n            if matrix[mid][0] <= target <= matrix[mid][-1]:\\n                col = mid\\n            if matrix[mid][-1] < target:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        l, r = 0, len(matrix[0])-1\\n        while l <=r:\\n            mid = (l+r)//2\\n            if matrix[col][mid] == target:\\n                return True\\n            if matrix[col][mid] < target:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        l, r = 0, len(matrix)-1\\n        col = -1\\n        while l <= r:\\n            mid = (l+r)//2\\n            if matrix[mid][0] <= target <= matrix[mid][-1]:\\n                col = mid\\n            if matrix[mid][-1] < target:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        l, r = 0, len(matrix[0])-1\\n        while l <=r:\\n            mid = (l+r)//2\\n            if matrix[col][mid] == target:\\n                return True\\n            if matrix[col][mid] < target:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057966,
                "title": "c-beats-100-binary-search-upper-bound-o-log-m-n",
                "content": "# Proof Beats\\n![image.png](https://assets.leetcode.com/users/images/c1be2cbb-8263-427b-ae9e-b84b7e2b514a_1673782005.5087156.png)\\n\\n# Approach\\n- Find by binary search a string that can contain an element.\\n- Check for the presence of an element in the given string.\\n\\n**You can avoid copying the first column, but this way the algorithm is more illustrative.**\\n\\n**Search time complexity:** $ O(log(m) + log(n)) = O(log(m \\\\cdot n)) $\\n\\n# STL / Own implementation\\n```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> start(m);\\n        for (int i = 0; i < m; i++) {\\n            start[i] = matrix[i][0];\\n        }\\n        int row = upper_bound(start.begin(), start.end(), target) - start.begin() - 1;\\n        if (row < 0) { return false; }\\n        return binary_search(matrix[row].begin(), matrix[row].end(), target);\\n    }\\n};\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int upper_bound(vector<int> &v, int target) {\\n        int left = 0, right = v.size();\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (target < v[mid]) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    bool binary_search(vector<int> &v, int target) {\\n        int left = 0, right = v.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (target == v[mid]) {\\n                return true;\\n            } else if (target < v[mid]) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> start(m);\\n        for (int i = 0; i < m; i++) {\\n            start[i] = matrix[i][0];\\n        }\\n        int row = upper_bound(start, target) - 1;\\n        if (row < 0) { return false; }\\n        return binary_search(matrix[row], target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> start(m);\\n        for (int i = 0; i < m; i++) {\\n            start[i] = matrix[i][0];\\n        }\\n        int row = upper_bound(start.begin(), start.end(), target) - start.begin() - 1;\\n        if (row < 0) { return false; }\\n        return binary_search(matrix[row].begin(), matrix[row].end(), target);\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int upper_bound(vector<int> &v, int target) {\\n        int left = 0, right = v.size();\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (target < v[mid]) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    bool binary_search(vector<int> &v, int target) {\\n        int left = 0, right = v.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (target == v[mid]) {\\n                return true;\\n            } else if (target < v[mid]) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> start(m);\\n        for (int i = 0; i < m; i++) {\\n            start[i] = matrix[i][0];\\n        }\\n        int row = upper_bound(start, target) - 1;\\n        if (row < 0) { return false; }\\n        return binary_search(matrix[row], target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010080,
                "title": "chat-gpt-generated-solution-binary-search",
                "content": "# Intuition\\nThis solution uses a binary search approach to determine if the target value is present in the matrix. The algorithm first determines the number of rows and columns in the matrix. It then defines the left and right bounds for the binary search as the first and last elements in the matrix, respectively.\\n\\nThe algorithm then enters a loop where it calculates the midpoint of the left and right bounds. It then determines the row and column indices of the midpoint element using integer division. If the midpoint element is equal to the target, the algorithm returns true. If the target is less than the midpoint element, the right bound is updated to be the midpoint element\\'s column index. If the target is greater than the midpoint element, the left bound is updated to be the midpoint element\\'s column index + 1.\\n\\nThe loop continues until the left bound is greater than the right bound, at which point the algorithm returns false, indicating that the target is not present in the matrix.\\n\\nThe time complexity of this solution is O(log(m * n)), as the binary search reduces the search space by half with each iteration. The space complexity is O(1), as the solution does not use any additional space beyond the input variables.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n# Complexity\\n- Time complexity: $$O(log(m * n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if (matrix.empty() || matrix[0].empty()) return false;\\n        int m = matrix.size(), n = matrix[0].size();\\n        int left = 0, right = m * n - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int row = mid / n, col = mid % n;\\n            if (matrix[row][col] == target) return true;\\n            if (matrix[row][col] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if (matrix.empty() || matrix[0].empty()) return false;\\n        int m = matrix.size(), n = matrix[0].size();\\n        int left = 0, right = m * n - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int row = mid / n, col = mid % n;\\n            if (matrix[row][col] == target) return true;\\n            if (matrix[row][col] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942747,
                "title": "python-bisect-with-key",
                "content": "# Intuition\\n\\nSince Python 3.10, many functions from the `bisect` module support an optional `key` parameter which greatly enhances expressiveness.\\n\\n# Approach\\n\\nThe first parameter of `bisect_left` can be any class with overloaded `__len__` and `__getitem__`. In particular, it can be a `range`. The `key` parameter is further used to translate a one-dimensional index into a two-dimensional one.\\n\\n# Complexity\\n\\n- Time complexity: $$O(\\\\log nm)$$.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n\\n```py\\nclass Solution:\\n    def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\\n        rows, cols = len(matrix), len(matrix[0])\\n        getitem = lambda index: matrix[index // cols][index % cols]\\n        it = bisect.bisect_left(range(rows * cols - 1), target, key=getitem)\\n        return matrix[it // cols][it % cols] == target\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```py\\nclass Solution:\\n    def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\\n        rows, cols = len(matrix), len(matrix[0])\\n        getitem = lambda index: matrix[index // cols][index % cols]\\n        it = bisect.bisect_left(range(rows * cols - 1), target, key=getitem)\\n        return matrix[it // cols][it % cols] == target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904370,
                "title": "kotlin-binary-search-2d",
                "content": "# Complexity\\n- Time complexity:\\nO(log(mn))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun searchMatrix(matrix: Array<IntArray>, target: Int): Boolean {\\n        val row = matrix.size\\n        val col = matrix[0].size\\n        \\n        var i = 0\\n        var j = row*col - 1\\n        \\n        while (i <= j) {\\n            val mid = i + (j - i) / 2\\n            val num = matrix[mid/col][mid%col]\\n            if (num > target) j = mid - 1\\n            else if (num < target) i = mid + 1\\n            else return true\\n        }\\n\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    fun searchMatrix(matrix: Array<IntArray>, target: Int): Boolean {\\n        val row = matrix.size\\n        val col = matrix[0].size\\n        \\n        var i = 0\\n        var j = row*col - 1\\n        \\n        while (i <= j) {\\n            val mid = i + (j - i) / 2\\n            val num = matrix[mid/col][mid%col]\\n            if (num > target) j = mid - 1\\n            else if (num < target) i = mid + 1\\n            else return true\\n        }\\n\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724032,
                "title": "python-binary-search-beginners-solution",
                "content": "# Code\\n```\\n\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n,m = len(matrix),len(matrix[0])\\n        l,h = 0,n-1\\n        idx = -1\\n        while l<=h:\\n            mid = (l+h)//2\\n            if matrix[mid][0]<=target and matrix[mid][m-1]>=target:\\n                idx = mid\\n                break\\n            elif matrix[mid][m-1]>target:\\n                h = mid-1\\n            else:\\n                l = mid+1\\n           \\n        l,h = 0,m-1\\n        while l<=h:\\n            mid= (l+h)//2\\n            if matrix[idx][mid]==target:\\n                return 1\\n            elif matrix[idx][mid]>target:\\n                h = mid-1\\n            else:\\n                l = mid+1\\n        return 0\\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n,m = len(matrix),len(matrix[0])\\n        l,h = 0,n-1\\n        idx = -1\\n        while l<=h:\\n            mid = (l+h)//2\\n            if matrix[mid][0]<=target and matrix[mid][m-1]>=target:\\n                idx = mid\\n                break\\n            elif matrix[mid][m-1]>target:\\n                h = mid-1\\n            else:\\n                l = mid+1\\n           \\n        l,h = 0,m-1\\n        while l<=h:\\n            mid= (l+h)//2\\n            if matrix[idx][mid]==target:\\n                return 1\\n            elif matrix[idx][mid]>target:\\n                h = mid-1\\n            else:\\n                l = mid+1\\n        return 0\\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719704,
                "title": "binary-search-ts-js-solution",
                "content": "# Approach\\nFirst BinarySearch looking for array where **can** be our target. Second is searching for our target in array\\n\\n# Complexity\\n- Time complexity: $$O(logN + logM)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nfunction searchMatrix(matrix: number[][], target: number): boolean {\\n    let l = 0; let r = matrix.length - 1;\\n\\n    while (l <= r) {\\n        const mid = Math.floor((l + r) / 2);\\n        const first = matrix[mid][0];\\n        const last = matrix[mid][matrix[mid].length - 1];\\n        if (target === first || target === last) return true;\\n        if (target > first && target < last) return binarySearch(matrix[mid], target);\\n        if (target < first) r = mid - 1;\\n        else l = mid + 1;\\n    }\\n    return false;\\n};\\n\\nfunction binarySearch(nums: number[], target: number): boolean {\\n  let l = 0;\\n  let r = nums.length - 1;\\n\\n  while (l <= r) {\\n    const mid = Math.floor((l + r) / 2);\\n    if (nums[mid] === target) return true;\\n    if (nums[mid] < target) l = mid + 1;\\n    else r = mid - 1;\\n  }\\n\\n  return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Binary Search"
                ],
                "code": "```\\nfunction searchMatrix(matrix: number[][], target: number): boolean {\\n    let l = 0; let r = matrix.length - 1;\\n\\n    while (l <= r) {\\n        const mid = Math.floor((l + r) / 2);\\n        const first = matrix[mid][0];\\n        const last = matrix[mid][matrix[mid].length - 1];\\n        if (target === first || target === last) return true;\\n        if (target > first && target < last) return binarySearch(matrix[mid], target);\\n        if (target < first) r = mid - 1;\\n        else l = mid + 1;\\n    }\\n    return false;\\n};\\n\\nfunction binarySearch(nums: number[], target: number): boolean {\\n  let l = 0;\\n  let r = nums.length - 1;\\n\\n  while (l <= r) {\\n    const mid = Math.floor((l + r) / 2);\\n    if (nums[mid] === target) return true;\\n    if (nums[mid] < target) l = mid + 1;\\n    else r = mid - 1;\\n  }\\n\\n  return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2472658,
                "title": "search-a-2d-matrix-4-solutions-c-solution",
                "content": "TC: O(n*m)\\nSC: O(1)\\n```\\nbool searchMatrix(vector<vector<int>>& v, int tar)\\n    {\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[0].size();j++)\\n            {\\n                if(v[i][j]==tar)\\n                {\\n                    return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n```\\n\\t\\t\\t\\t\\t****************************************************************\\n\\t\\t\\t\\t\\t\\nTC: O(n+m)\\nSC: O(1)\\n\\n```\\nbool searchMatrix(vector<vector<int>>& v, int tar)\\n    {\\n        int m=v[0].size(),n=v.size();\\n        int i=0,j=m-1;\\n        while(i<n&&j>=0)\\n        {\\n            if(v[i][j]>tar)\\n            {\\n                j--;\\n            }\\n            else if(v[i][j]<tar)\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\n\\t\\t\\t ***********************************************************************\\n\\t\\t\\t\\t\\t\\t\\t\\t\\nTC: O(log (n) * log (m))\\nSC: O(1)\\n\\n```\\nbool fin(vector<vector<int>>& v,int x,int i,int m)\\n    {\\n        int l=0,h=m-1;\\n        while(l<=h)\\n        {\\n            int mid=(h+l)/2;\\n            if(v[i][mid]==x)\\n            {\\n                return 1;\\n            }\\n            if(v[i][mid]>x)\\n            {\\n                h=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return 0;\\n    }\\n    bool searchMatrix(vector<vector<int>>& v, int tar)\\n    {\\n        int n=v.size(),l=0,h=n-1;\\n        int m=v[0].size();\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            if(v[mid][m-1]>=tar&&v[mid][0]<=tar)\\n            {\\n                int x=fin(v,tar,mid,m);\\n                return x;\\n            }\\n            else if(v[mid][m-1]<tar)\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return 0;\\n    }\\n```\\n                               ****************************************************\\nTC: O(log(m*n))\\nSC: O(1)\\n\\n```\\n// v[i][j]=(i*col)+col\\n    bool searchMatrix(vector<vector<int>>& v, int tar) \\n    {\\n        int n=v.size(),m=v[0].size();\\n        int l=0,h=(m*n)-1;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            int x=v[mid/m][mid%m];\\n            if(x==tar)\\n            {\\n                return 1;\\n            }\\n            if(x<tar){\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return 0;\\n    }\\n```\\n",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nbool searchMatrix(vector<vector<int>>& v, int tar)\\n    {\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[0].size();j++)\\n            {\\n                if(v[i][j]==tar)\\n                {\\n                    return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n```\n```\\nbool searchMatrix(vector<vector<int>>& v, int tar)\\n    {\\n        int m=v[0].size(),n=v.size();\\n        int i=0,j=m-1;\\n        while(i<n&&j>=0)\\n        {\\n            if(v[i][j]>tar)\\n            {\\n                j--;\\n            }\\n            else if(v[i][j]<tar)\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\nbool fin(vector<vector<int>>& v,int x,int i,int m)\\n    {\\n        int l=0,h=m-1;\\n        while(l<=h)\\n        {\\n            int mid=(h+l)/2;\\n            if(v[i][mid]==x)\\n            {\\n                return 1;\\n            }\\n            if(v[i][mid]>x)\\n            {\\n                h=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return 0;\\n    }\\n    bool searchMatrix(vector<vector<int>>& v, int tar)\\n    {\\n        int n=v.size(),l=0,h=n-1;\\n        int m=v[0].size();\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            if(v[mid][m-1]>=tar&&v[mid][0]<=tar)\\n            {\\n                int x=fin(v,tar,mid,m);\\n                return x;\\n            }\\n            else if(v[mid][m-1]<tar)\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return 0;\\n    }\\n```\n```\\n// v[i][j]=(i*col)+col\\n    bool searchMatrix(vector<vector<int>>& v, int tar) \\n    {\\n        int n=v.size(),m=v[0].size();\\n        int l=0,h=(m*n)-1;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            int x=v[mid/m][mid%m];\\n            if(x==tar)\\n            {\\n                return 1;\\n            }\\n            if(x<tar){\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2424187,
                "title": "python-c-java-beginner-level-solution-2-diff-approach-100-faster-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q74. Search a 2D Matrix***\\n\\nWrite an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:\\n\\nIntegers in each row are sorted from left to right.\\nThe first integer of each row is greater than the last integer of the previous row.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Java Code** :\\n**Runtime**: 0 ms, faster than 100.00% of Java online submissions for Search a 2D Matrix.\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Node current = root;\\n        while(current != null) {\\n            Node level1stNode = current;\\n            while(current != null) \\n            {\\n                if(current.left != null) \\n                    current.left.next = current.right;\\n                if(current.right != null && current.next != null) \\n                    current.right.next = current.next.left;\\n\\n                current = current.next;\\n            }\\n            current = level1stNode.left;\\n        }\\n        return root;\\n    }\\n}\\n```\\n**Runtime:**  0ms\\n**Memory Usage:**  42.2 MB\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n**Runtime:** 47 ms, faster than 91.95% of Python3 online submissions for Search a 2D Matrix.\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows, cols = len(matrix), len(matrix[0])\\n        low, high = 0, rows*cols-1\\n        while low <= high:\\n            mid = (low + high) // 2\\n            num = matrix[mid // cols][mid % cols]\\n            if num == target:\\n                return True\\n            elif num < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return False\\n```\\n**Runtime:**  47ms\\n**Memory Usage:**  14.7 MB\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n\\n**Approach 1:**\\n**Runtime:** beats 91.64 % of cpp online submissions for Search a 2D Matrix.\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mt, int target) {\\n        int n = mt.size(), m = mt[0].size();\\n        int low = 0, high = m*n-1;\\n        \\n        while(low <= high){\\n            int mid = low+(high-low) / 2;\\n            int row = mid/m;\\n            int col = mid%m;\\n            \\n            if(mt[row][col] == target) return true;\\n            \\n            else if(mt[row][col] >= target) high = mid-1;\\n            \\n            else low = mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Runtime:**  3ms\\n**Memory Usage:**  9.6MB\\n____________________________________________________________________________________________________________________\\n***Approach 2:***\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int i=0,j=m-1;\\n        \\n        int mid=matrix[i][j];\\n        while(true)\\n        {\\n            if(mid==target)\\n            {\\n                return true;\\n                break;\\n            }\\n            else if(mid>target)\\n            {\\n                j--;\\n                if(j<0)\\n                {\\n                    return false;\\n                    break;\\n                }       \\n                mid=matrix[i][j];\\n            }\\n            else\\n            {\\n                i++;\\n                if(i>n-1)\\n                {\\n                    return false;\\n                    break;\\n                }\\n                \\n                mid=matrix[i][j];\\n            }\\n        }\\n        return -1; \\n    }\\n};\\n```\\n**Runtime:**  5ms\\n**Memory Usage:**  9.3MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Node current = root;\\n        while(current != null) {\\n            Node level1stNode = current;\\n            while(current != null) \\n            {\\n                if(current.left != null) \\n                    current.left.next = current.right;\\n                if(current.right != null && current.next != null) \\n                    current.right.next = current.next.left;\\n\\n                current = current.next;\\n            }\\n            current = level1stNode.left;\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows, cols = len(matrix), len(matrix[0])\\n        low, high = 0, rows*cols-1\\n        while low <= high:\\n            mid = (low + high) // 2\\n            num = matrix[mid // cols][mid % cols]\\n            if num == target:\\n                return True\\n            elif num < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return False\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mt, int target) {\\n        int n = mt.size(), m = mt[0].size();\\n        int low = 0, high = m*n-1;\\n        \\n        while(low <= high){\\n            int mid = low+(high-low) / 2;\\n            int row = mid/m;\\n            int col = mid%m;\\n            \\n            if(mt[row][col] == target) return true;\\n            \\n            else if(mt[row][col] >= target) high = mid-1;\\n            \\n            else low = mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int i=0,j=m-1;\\n        \\n        int mid=matrix[i][j];\\n        while(true)\\n        {\\n            if(mid==target)\\n            {\\n                return true;\\n                break;\\n            }\\n            else if(mid>target)\\n            {\\n                j--;\\n                if(j<0)\\n                {\\n                    return false;\\n                    break;\\n                }       \\n                mid=matrix[i][j];\\n            }\\n            else\\n            {\\n                i++;\\n                if(i>n-1)\\n                {\\n                    return false;\\n                    break;\\n                }\\n                \\n                mid=matrix[i][j];\\n            }\\n        }\\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083661,
                "title": "c-binary-search-o-log-mn",
                "content": "Simple Binary Search on Complete Matrix.\\nTo get the Coordinates of any point in the matrix during binary search, we can do the following:\\n```cpp\\nrow = mid/n\\ncol = mid%n\\n```\\nThis works because the column can only have indices between [0,n-1] so taking modulo gives us the column number, And in each row there will be n values so dividing by n gives us the row number.\\n\\nTime Complexity:   O( log(nm) ) \\nSpace Complexity: O( 1 )\\n```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size(),\\n        n=matrix[0].size(),\\n        l=0,r=n*m-1,mid,col,row;\\n        while(l<=r){\\n            mid=l+(r-l)/2;\\n            row=mid/n;\\n            col=mid%n;\\n            if(matrix[row][col]==target){\\n                return true;\\n            }\\n            else if(matrix[row][col]>target){\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```cpp\\nrow = mid/n\\ncol = mid%n\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size(),\\n        n=matrix[0].size(),\\n        l=0,r=n*m-1,mid,col,row;\\n        while(l<=r){\\n            mid=l+(r-l)/2;\\n            row=mid/n;\\n            col=mid%n;\\n            if(matrix[row][col]==target){\\n                return true;\\n            }\\n            else if(matrix[row][col]>target){\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053266,
                "title": "java-0ms-100-faster-easiest-ever",
                "content": "Rather than applying BS in whole array, \\nwe can search in particular row, where Target is most likely to present.\\nhence for every row , we will check if our Target can fit in it,\\n```\\n if(T>=matrix[i][0] && T<=matrix[i][end])\\n```\\ntarget>= smallestInRow && target<=largestInRow\\n<img  height=\"350\" width=\"400\" src=\"https://assets.leetcode.com/users/images/3a68de3c-aede-4de1-8055-7045ac3d7509_1652949778.8485477.jpeg\">\\nthen apply BinarySearch, \\nwe will break out of loop if above confition satisfied, \\ndoesnt matter if target if found or not. \\n```\\n    \\tpublic boolean searchMatrix(int[][] matrix, int T) {\\n\\t      boolean res =false;\\n\\t      int len = matrix.length;\\n\\t       for(int i =0;i<len;++i)\\n\\t       {\\n\\t         int end = matrix[i].length-1;\\n\\t         if(T>=matrix[i][0] && T<=matrix[i][end])\\n\\t         {\\n\\t           //might be present in this row\\n\\t           int low =0;\\n\\t           int high=end;\\n\\t           while(low<=high)\\n\\t           {\\n\\t            int mid = low + (high-low)/2;\\n\\t            int curr = matrix[i][mid];\\n\\t             if(curr==T)\\n\\t             {\\n\\t               res=!res;\\n\\t               break;\\n\\t             }\\n\\t             else if(curr>T)high=mid-1;\\n\\t             else low=mid+1;\\n\\t           }\\n\\t           break;\\n\\t         }\\n\\t         else continue;\\n\\t       }\\n\\t      return res;\\n\\t    }\\n```\\nUpvote if you found this helpful  and learned about an unique approach.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n if(T>=matrix[i][0] && T<=matrix[i][end])\\n```\n```\\n    \\tpublic boolean searchMatrix(int[][] matrix, int T) {\\n\\t      boolean res =false;\\n\\t      int len = matrix.length;\\n\\t       for(int i =0;i<len;++i)\\n\\t       {\\n\\t         int end = matrix[i].length-1;\\n\\t         if(T>=matrix[i][0] && T<=matrix[i][end])\\n\\t         {\\n\\t           //might be present in this row\\n\\t           int low =0;\\n\\t           int high=end;\\n\\t           while(low<=high)\\n\\t           {\\n\\t            int mid = low + (high-low)/2;\\n\\t            int curr = matrix[i][mid];\\n\\t             if(curr==T)\\n\\t             {\\n\\t               res=!res;\\n\\t               break;\\n\\t             }\\n\\t             else if(curr>T)high=mid-1;\\n\\t             else low=mid+1;\\n\\t           }\\n\\t           break;\\n\\t         }\\n\\t         else continue;\\n\\t       }\\n\\t      return res;\\n\\t    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2006595,
                "title": "0-ms-don-t-treat-it-as-matrix-just-think-like-array",
                "content": "This problem is very simple to do if we treat matrix as array.\\nDon\\'t think this is a matrix. Think, It is simple sorted array. And now apply binary search on it.\\n\\n**Algorithm:**\\n```\\n1) Treat matrix as an array.\\n2) apply Binary Search on it.\\n```\\n\\n**Code:**\\n```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) \\n{\\n        int m = matrix.size(), n = matrix[0].size();\\n        int low = 0, high = (m * n) - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            int mid_value = matrix[mid / n][mid % n];\\n\\n            if(target == mid_value)\\n                return true;\\n            else if(target <= mid_value)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n        }\\n        \\n        return false;\\n}\\n```\\n\\n**Time Complexity : O(log(mn))\\nSpace Complexity : O(1)**\\n\\n\\n**If you find it useful please upvote.\\nIf you have any question feel free to ask in comment section.**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n1) Treat matrix as an array.\\n2) apply Binary Search on it.\\n```\n```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) \\n{\\n        int m = matrix.size(), n = matrix[0].size();\\n        int low = 0, high = (m * n) - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            int mid_value = matrix[mid / n][mid % n];\\n\\n            if(target == mid_value)\\n                return true;\\n            else if(target <= mid_value)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n        }\\n        \\n        return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1895859,
                "title": "java-solution-binary-search",
                "content": "```\\npublic boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        int r=matrix.length;\\n        int c=matrix[0].length;\\n        int low=0;\\n        int high=(r*c)-1;\\n        while(low<=high)\\n        {\\n            int mid=(high+low)/2;\\n            int num=matrix[mid/c][mid%c];\\n\\t\\t\\t// binary search\\n            if(num==target) return true;\\n            else if(num<target) low=mid+1;\\n            else high=mid-1;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\npublic boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        int r=matrix.length;\\n        int c=matrix[0].length;\\n        int low=0;\\n        int high=(r*c)-1;\\n        while(low<=high)\\n        {\\n            int mid=(high+low)/2;\\n            int num=matrix[mid/c][mid%c];\\n\\t\\t\\t// binary search\\n            if(num==target) return true;\\n            else if(num<target) low=mid+1;\\n            else high=mid-1;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1895854,
                "title": "explained-easy-solution-binary-search",
                "content": "Approach:\\n\\nNaive approach: Use 2 loops. Check each element in the array with all other elements in the array and check if it has the same value.\\n\\nTime Complexity : O(n^2) Space Complexity: O(1)\\nCode:\\n```\\nfor i in range(len(matrix)):\\n    for j in range(len(matrix[0])):\\n        if matrix[i][j]==target:\\n            return True\\nreturn False\\n```\\nBinary Search approach: Since the matrix is given in sorted order, so we can apply binary search in this problem.\\nFollow the following steps:\\n\\n1. Consider the matrix as a linear array , left be the first element and right be the m.n-1 element.\\n2. calculate the mid element.Position of the mid element in the matrix will be at row (mid//col) and column (mid%col).\\n3. If target is equal to element at calculated index, return true.\\n4. Now shift left and right as normal binary search algorithm, i.e. if target is less than the element at calculated index(element will be in left part) then shift right to mid-1 , else, shift left to mid+1.\\n5. Else, return False if thr target in not found the the matrix.\\n\\nTime Complexity: O(log mn) i.e O(logm + logn)\\nCode:\\n```\\nrow,col=len(matrix),len(matrix[0])\\n\\nright,left=row*col-1,0\\n\\nwhile(left<=right):\\n\\n    # calculate the mid\\n    mid=left+(right-left)//2\\n\\t\\n    #current row and column\\n    curr_row=mid//col\\n    curr_col=mid%col\\n\\t\\n    #if target is equal to the current index return True\\n    if (matrix[curr_row][curr_col])==target:\\n        return True\\n\\n    elif (matrix[curr_row][curr_col])>target:\\n        right=mid-1\\n\\n    else:\\n        left=mid+1\\n    \\nreturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nfor i in range(len(matrix)):\\n    for j in range(len(matrix[0])):\\n        if matrix[i][j]==target:\\n            return True\\nreturn False\\n```\n```\\nrow,col=len(matrix),len(matrix[0])\\n\\nright,left=row*col-1,0\\n\\nwhile(left<=right):\\n\\n    # calculate the mid\\n    mid=left+(right-left)//2\\n\\t\\n    #current row and column\\n    curr_row=mid//col\\n    curr_col=mid%col\\n\\t\\n    #if target is equal to the current index return True\\n    if (matrix[curr_row][curr_col])==target:\\n        return True\\n\\n    elif (matrix[curr_row][curr_col])>target:\\n        right=mid-1\\n\\n    else:\\n        left=mid+1\\n    \\nreturn False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1895851,
                "title": "simple-easy-c-solution",
                "content": "**Binary Search**\\n***Time complexcity O(log(row*******col))***\\n```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) \\n    { \\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int low=0;\\n        int high=(row*col)-1;\\n        \\n        while(low<=high)\\n        {\\n            int mid=(high+low)/2;\\n            int num=matrix[mid/col][mid%col];\\n            if(num==target) return true;\\n            else if(num<target) low=mid+1;\\n            else high=mid-1;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) \\n    { \\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int low=0;\\n        int high=(row*col)-1;\\n        \\n        while(low<=high)\\n        {\\n            int mid=(high+low)/2;\\n            int num=matrix[mid/col][mid%col];\\n            if(num==target) return true;\\n            else if(num<target) low=mid+1;\\n            else high=mid-1;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1775768,
                "title": "easiest-java-code",
                "content": "**Upvote if you like the solution, please! :)**\\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].length-1;\\n  \\n        while(i<matrix.length && j>=0){\\n\\n            if(target==matrix[i][j]){\\n                return true;\\n            }\\n            \\n            else if(target<matrix[i][j]){\\n                j--;\\n            }\\n            \\n            else{\\n                i++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].length-1;\\n  \\n        while(i<matrix.length && j>=0){\\n\\n            if(target==matrix[i][j]){\\n                return true;\\n            }\\n            \\n            else if(target<matrix[i][j]){\\n                j--;\\n            }\\n            \\n            else{\\n                i++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736630,
                "title": "java-simple-binary-search-solution-faster-than-100",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean searchMatrix(int[][] matrix, int target) {\\n\\n\\t\\t\\tfor(int i = 0 ; i < matrix.length ; i++) {\\n\\t\\t\\t\\tint beg = 0;\\n\\t\\t\\t\\tint end = matrix[0].length -1;\\n\\n\\t\\t\\t\\twhile(beg <= end) {\\n\\t\\t\\t\\t\\tint mid = (beg + end) /2;\\n\\n\\t\\t\\t\\t\\tif(matrix[i][mid] == target){\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t} else if(matrix[i][mid] > target) {\\n\\t\\t\\t\\t\\t\\tend = mid -1;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tbeg = mid +1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\n\\'\\'\\'\\n\\nIf this solution anyhow helps you please give it an upvote.\\nOne upvote motivates me to solve one more problem. (I am having only one upvote\\uD83D\\uDE02)\\nThank you \\n\\n",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic boolean searchMatrix(int[][] matrix, int target) {\\n\\n\\t\\t\\tfor(int i = 0 ; i < matrix.length ; i++) {\\n\\t\\t\\t\\tint beg = 0;\\n\\t\\t\\t\\tint end = matrix[0].length -1;\\n\\n\\t\\t\\t\\twhile(beg <= end) {\\n\\t\\t\\t\\t\\tint mid = (beg + end) /2;\\n\\n\\t\\t\\t\\t\\tif(matrix[i][mid] == target){\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1726313,
                "title": "c-very-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/380f6554-3fc5-4898-8168-4e2a7ca75787_1643374170.7758732.png)\\n\\nExplanation:\\nThe most efficient solution I can think of is by fixing a corner element, it can wither be your top right corner or bottom left corner. Since the matrix is always going to be row-wise and column- wise sorted, we just need to traverse through it by giving the appropriate conditions.\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int x) {\\n        int m= matrix.size();\\n        int n= matrix[0].size();\\n        int c=matrix[0][n-1];\\n        int i=0,j=n-1;\\n        while(i<m && j>=0)\\n            \\n        {\\n         if(matrix[i][j]>x)\\n         {\\n             j--;\\n         }\\n            else if(matrix[i][j]<x)\\n            {\\n                i++;\\n            }\\n            else if(matrix[i][j]==x)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int x) {\\n        int m= matrix.size();\\n        int n= matrix[0].size();\\n        int c=matrix[0][n-1];\\n        int i=0,j=n-1;\\n        while(i<m && j>=0)\\n            \\n        {\\n         if(matrix[i][j]>x)\\n         {\\n             j--;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1699366,
                "title": "java-easy-solution-100-faster",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Search a 2D Matrix.\\n\\n\\nSolution 1 : \\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        //Starting from last element of first row (can also start from first element of last row).\\n        int i = 0; \\n        int j = matrix[0].length - 1;\\n        \\n        while (j >= 0 && i < matrix.length) {\\n            if (matrix[i][j] < target) {\\n                i++;\\n            }\\n            else if (matrix[i][j] > target) {\\n                j--;\\n            }\\n            //Found the element, return true.\\n            else {\\n                return true;\\n            }\\n        }\\n        \\n        //Element not found, return false.\\n        return false;\\n    }\\n}\\n```\\n\\nSolution 2 : \\nUsing Binary Search algorithm.\\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        \\n        //Finding total number of elements\\n        int numOfElements = rows * cols;\\n        \\n        int lo = 0;\\n        int hi = numOfElements - 1;\\n        \\n        while (lo <= hi) {\\n            int mid = lo + ((hi - lo) >> 1);\\n            \\n            //Finding it\\'s co-ordinates in matrix.\\n            int rn = mid / cols;\\n            int cn = mid % cols;\\n            \\n            if (matrix[rn][cn] == target) {\\n                return true;\\n            }\\n            else if (matrix[rn][cn] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Matrix",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        //Starting from last element of first row (can also start from first element of last row).\\n        int i = 0; \\n        int j = matrix[0].length - 1;\\n        \\n        while (j >= 0 && i < matrix.length) {\\n            if (matrix[i][j] < target) {\\n                i++;\\n            }\\n            else if (matrix[i][j] > target) {\\n                j--;\\n            }\\n            //Found the element, return true.\\n            else {\\n                return true;\\n            }\\n        }\\n        \\n        //Element not found, return false.\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        \\n        //Finding total number of elements\\n        int numOfElements = rows * cols;\\n        \\n        int lo = 0;\\n        int hi = numOfElements - 1;\\n        \\n        while (lo <= hi) {\\n            int mid = lo + ((hi - lo) >> 1);\\n            \\n            //Finding it\\'s co-ordinates in matrix.\\n            int rn = mid / cols;\\n            int cn = mid % cols;\\n            \\n            if (matrix[rn][cn] == target) {\\n                return true;\\n            }\\n            else if (matrix[rn][cn] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685837,
                "title": "python-solution-4-possible-approaches",
                "content": "## Approach 1:\\n**1. Flatten the matrix into a single array**\\n**2. Use Binary search to find the target**\\n\\n```\\nclass Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        row_len = len(matrix)\\n        column_len = len(matrix[0])\\n        ls = [matrix[i][j] for i in range(row_len) for j in range(column_len)]\\n        left = 0\\n        right = len(ls)-1\\n        while left <= right:\\n            mid = left + (right - left)//2\\n            if target == ls[mid]:\\n                return True\\n            elif target > ls[mid]:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n                \\n        return False\\n```\\n\\n## Approach 2:\\n**1. Use the advantage of the properties of matrix given, to find out the row in which our target could possibly be.**\\n**2.  Once you get the targeted row, implement binary search in that row.**\\n\\n```\\n        position = 0\\n        ls = [] \\n        for i in range(row_len):\\n            if target > matrix[i][column_len-1]:\\n                continue\\n            else:\\n                position = i\\n                break\\n                \\n        ls[:] = matrix[position]  \\n        left = 0\\n        right = len(ls)-1\\n        while left <= right:\\n            mid = left + (right - left)//2\\n            if target == ls[mid]:\\n                return True\\n            elif target > ls[mid]:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n                \\n        return False\\n```\\n\\n## Approach 3: \\n**1. Straight forward brute force approach** (surprisingly very fast :P)\\n\\n```\\n\\t\\tfor i in matrix:\\n            if target in i:\\n                return True\\n        return False\\n```\\n\\n## Approach 4:\\n**1. Start with the first row and last column of the matrix**\\n**2. If the number is less than the target then increase the row index(because greater numbers can be found below, as per the question)**\\n**3. If the number is greater than the target then decrease the column index(as the matrix is sorted in ascending order in the columns also)**\\n\\n```\\n        rows, cols =  len(matrix), len(matrix[0]) \\n        r, c = 0, cols-1\\n        \\n        while 0 <= r < rows and 0 <= c < cols:\\n            \\n            num = matrix[r][c]\\n            if num == target:\\n                return True\\n            elif num < target:\\n                r += 1\\n            else:\\n                c -= 1\\n        \\n        return False\\n```\\n",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        row_len = len(matrix)\\n        column_len = len(matrix[0])\\n        ls = [matrix[i][j] for i in range(row_len) for j in range(column_len)]\\n        left = 0\\n        right = len(ls)-1\\n        while left <= right:\\n            mid = left + (right - left)//2\\n            if target == ls[mid]:\\n                return True\\n            elif target > ls[mid]:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n                \\n        return False\\n```\n```\\n        position = 0\\n        ls = [] \\n        for i in range(row_len):\\n            if target > matrix[i][column_len-1]:\\n                continue\\n            else:\\n                position = i\\n                break\\n                \\n        ls[:] = matrix[position]  \\n        left = 0\\n        right = len(ls)-1\\n        while left <= right:\\n            mid = left + (right - left)//2\\n            if target == ls[mid]:\\n                return True\\n            elif target > ls[mid]:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n                \\n        return False\\n```\n```\\n\\t\\tfor i in matrix:\\n            if target in i:\\n                return True\\n        return False\\n```\n```\\n        rows, cols =  len(matrix), len(matrix[0]) \\n        r, c = 0, cols-1\\n        \\n        while 0 <= r < rows and 0 <= c < cols:\\n            \\n            num = matrix[r][c]\\n            if num == target:\\n                return True\\n            elif num < target:\\n                r += 1\\n            else:\\n                c -= 1\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615497,
                "title": "easy-python-solution",
                "content": "```\\nfor i in matrix:\\n    if i.count(target)>0:\\n\\t\\treturn True\\nreturn False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfor i in matrix:\\n    if i.count(target)>0:\\n\\t\\treturn True\\nreturn False",
                "codeTag": "Unknown"
            },
            {
                "id": 1567570,
                "title": "c-100-better-solution",
                "content": "```\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n        int n=matrix.size(),m=matrix[0].size();\\n       int i=0,j=m-1;\\n        while(i>=0 && i<n && j>=0 && j<m)\\n        {\\n            if(matrix[i][j]==target)\\n                return true;\\n            else if(matrix[i][j]>target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return false;   \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n        int n=matrix.size(),m=matrix[0].size();\\n       int i=0,j=m-1;\\n        while(i>=0 && i<n && j>=0 && j<m)\\n        {\\n            if(matrix[i][j]==target)\\n                return true;\\n            else if(matrix[i][j]>target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return false;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1406540,
                "title": "o-log-m-log-n-solution",
                "content": "# O(log(m)+log(n)) solution\\n**Binary search and find row**\\n**Then binary search and find column**\\n```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m, i=0, j = matrix.size()-1, temp;\\n        while(i<=j){\\n            m = i+ (j-i)/2;\\n            temp = matrix[m][0];\\n            if(temp==target){\\n                return true;\\n            } else if(temp>target){\\n                j = m-1;\\n            } else {\\n                i = m+1;\\n            }\\n        }\\n        if(i>matrix.size() || j<0) return false;\\n        int row = j;\\n        i=0; j = matrix[0].size()-1;\\n        while(i<=j){\\n            m = i+ (j-i)/2;\\n            temp = matrix[row][m];\\n            if(temp==target){\\n                return true;\\n            } else if(temp>target){\\n                j = m-1;\\n            } else {\\n                i = m+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m, i=0, j = matrix.size()-1, temp;\\n        while(i<=j){\\n            m = i+ (j-i)/2;\\n            temp = matrix[m][0];\\n            if(temp==target){\\n                return true;\\n            } else if(temp>target){\\n                j = m-1;\\n            } else {\\n                i = m+1;\\n            }\\n        }\\n        if(i>matrix.size() || j<0) return false;\\n        int row = j;\\n        i=0; j = matrix[0].size()-1;\\n        while(i<=j){\\n            m = i+ (j-i)/2;\\n            temp = matrix[row][m];\\n            if(temp==target){\\n                return true;\\n            } else if(temp>target){\\n                j = m-1;\\n            } else {\\n                i = m+1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324020,
                "title": "very-simple-o-log-n-log-m-solution-binary-search",
                "content": "1. Apply binary search along last column to find the row number where target element is possible.\\n2. Then after knowing the row number apply binary search on that row.\\n\\n     **Time Complexity is O(log(n)+log(m)) and Space Complexity is O(1)**.\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int row = -1;\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high)\\n        {\\n            int  mid = low + (high - low) / 2;\\n            if (matrix[mid][m - 1] == target)\\n            {\\n                row = mid;\\n                break;\\n            }\\n            else if (matrix[mid][m - 1] > target)\\n            {\\n                row = mid;\\n                high = mid - 1;\\n            }\\n            else if (matrix[mid][m - 1] < target)\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        if (row == -1)//if target is greater than all element in the matrix\\n        {\\n            return false;\\n        }\\n        low = 0;\\n        high = m - 1;\\n        while (low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if (target == matrix[row][mid])\\n            {\\n                return true;\\n            }\\n            else if (target < matrix[row][mid])\\n            {\\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int row = -1;\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high)\\n        {\\n            int  mid = low + (high - low) / 2;\\n            if (matrix[mid][m - 1] == target)\\n            {\\n                row = mid;\\n                break;\\n            }\\n            else if (matrix[mid][m - 1] > target)\\n            {\\n                row = mid;\\n                high = mid - 1;\\n            }\\n            else if (matrix[mid][m - 1] < target)\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        if (row == -1)//if target is greater than all element in the matrix\\n        {\\n            return false;\\n        }\\n        low = 0;\\n        high = m - 1;\\n        while (low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if (target == matrix[row][mid])\\n            {\\n                return true;\\n            }\\n            else if (target < matrix[row][mid])\\n            {\\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252838,
                "title": "2d-array-to-1d-array-conversion-c-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    // lets treat 2D ARRAY as a 1D ARRAY \\n    \\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int left=0;    // first element index\\n        int right=row*col-1;    // last element index\\n        while(left<=right){\\n            \\n            int mid=(left+right)/2;   // middle element in array\\n            int r=mid/col;          // to find the row of middle element\\n            int c=mid%col;         // to find col of middle element\\n            int middle=matrix[r][c];\\n            if(middle==target) return 1;\\n            \\n            if(middle>target) right=mid-1;\\n            else left=mid+1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // lets treat 2D ARRAY as a 1D ARRAY \\n    \\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int left=0;    // first element index\\n        int right=row*col-1;    // last element index\\n        while(left<=right){\\n            \\n            int mid=(left+right)/2;   // middle element in array\\n            int r=mid/col;          // to find the row of middle element\\n            int c=mid%col;         // to find col of middle element\\n            int middle=matrix[r][c];\\n            if(middle==target) return 1;\\n            \\n            if(middle>target) right=mid-1;\\n            else left=mid+1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151764,
                "title": "brute-force-better-and-optimised-approach-discussed",
                "content": "Brute Force-\\n\\n->Iterate through the whole matrix using two nested for loops and check if the elements are present\\n->Time Complexity- O(n*m)\\n\\n\\nBetter-\\n-> Use binary search on each vector to find the element\\n-> Time Complexity- O(n*logm)\\n```\\n\\nint check(vector<vector<int>> mat,int target){\\n\\n  int n=mat.size();\\n  int m=mat[0].size();\\n  \\n  int i=0;\\n  int j=m-1;\\n  while(i<n and j>=0){\\n  \\n    if(matrix[i][j]==target){\\n      return 1;\\n    }\\n    \\n    if(matrix[i][j]<target){\\n      i++;\\n    }\\n    else{\\n    j--;\\n    }\\n  }\\n  \\n  return 0;\\n}\\n\\n```\\n\\nOptimised-\\n\\n->Time Complexity- O(log(n*m))\\n```\\nint check(vector<vector<int>> mat,int target){\\n  \\n  int n = mat.size();\\n  int m = mat[0].size();\\n  \\n  int low=0;\\n  int high=(n*m) -1;\\n  \\n  while(low<=high){\\n    int mid=(low+high)/2);\\n\\n    if(matrix[mid/m][mid%m]==target){\\n        return 1;\\n    }\\n    \\n    if(matrix[mid/m][mid%m]<=target){\\n        low=mid+1;\\n    }\\n    else{\\n        high=mid-1;\\n    }\\n    \\n  }\\n  return 0;\\n}  \\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\nint check(vector<vector<int>> mat,int target){\\n\\n  int n=mat.size();\\n  int m=mat[0].size();\\n  \\n  int i=0;\\n  int j=m-1;\\n  while(i<n and j>=0){\\n  \\n    if(matrix[i][j]==target){\\n      return 1;\\n    }\\n    \\n    if(matrix[i][j]<target){\\n      i++;\\n    }\\n    else{\\n    j--;\\n    }\\n  }\\n  \\n  return 0;\\n}\\n\\n```\n```\\nint check(vector<vector<int>> mat,int target){\\n  \\n  int n = mat.size();\\n  int m = mat[0].size();\\n  \\n  int low=0;\\n  int high=(n*m) -1;\\n  \\n  while(low<=high){\\n    int mid=(low+high)/2);\\n\\n    if(matrix[mid/m][mid%m]==target){\\n        return 1;\\n    }\\n    \\n    if(matrix[mid/m][mid%m]<=target){\\n        low=mid+1;\\n    }\\n    else{\\n        high=mid-1;\\n    }\\n    \\n  }\\n  return 0;\\n}  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1101328,
                "title": "easy-to-understand-for-beginners-as-well-4-solutions",
                "content": "Solution 1:\\n```\\nvar searchMatrix = function(matrix, target) {\\n let row = 0,\\n    col = matrix[0].length - 1;\\n  while (row < matrix.length) {\\n    if (matrix[row][col] === target) {\\n      return true;\\n    }\\n    if (matrix[row][col] < target) {\\n      row++;\\n    } else {\\n      col--;\\n      if (col < 0) {\\n        row++;\\n      }\\n    }\\n  }\\n  return false;\\n};\\n```\\nSolution 2: Using Binary Search(takes a bit longer runtime than prev solution)\\n```\\nvar searchMatrix = function(matrix, target) {\\nlet rows = matrix.length,\\n    cols = matrix[0].length,\\n    left = 0,\\n    right = rows * cols - 1;\\n  while (left <= right) {\\n    let midIndex = Math.floor(left + (right - left) / 2);\\n    let midElement = matrix[Math.floor(midIndex / cols)][midIndex % cols]; // matrix[row][col]\\n    if (midElement === target) {\\n      return true;\\n    } else if (target < midElement) {\\n      right = midIndex - 1;\\n    } else {\\n      left = midIndex + 1;\\n    }\\n  }\\n  return false;\\n  }\\n```\\nSolution 3:\\n```\\nvar searchMatrix = function(matrix, target) {\\n    let rowStart=0,rowEnd=matrix.length-1,colStart=0,colEnd=matrix[0].length-1;\\n\\t// setting the boundary limit\\n    while(rowStart<=rowEnd && colStart<=colEnd){\\n\\t/*As elements are in asc order we\\'re checking if the element exists \\n\\tfrom the last colIndex until we reach the first colIndex */\\n        if(target<=matrix[rowStart][colEnd] && colEnd>=0){\\n            if(matrix[rowStart][colEnd]===target){\\n                return true;\\n            }\\n\\t\\t\\t// from last col we\\'re decrementing one by one\\n            colEnd--;\\n        }else{\\n\\t\\t// increment the row by 1 if we didnt find even after we had reached the first col of particular row\\n            rowStart++;\\n\\t\\t\\t// reset the col Index\\n            colEnd=matrix[0].length-1;\\n        }\\n    }\\n    return false;\\n};\\n```\\nSolution 4:\\n```\\nvar searchMatrix = function(matrix, target) {\\n    let colEnd=matrix[0].length-1;\\n    let rowStart=0;let rowEnd=matrix.length-1;\\n    while(rowStart<=rowEnd){\\n        if(matrix[rowStart][colEnd]>=target){\\n            if(matrix[rowStart][colEnd]===target){\\n                return true\\n            }else {\\n                colEnd--;\\n            }\\n        }else{\\n            rowStart++;\\n        }\\n    }\\n    return false;\\n};\\n```\\nRuntime: 68 ms, faster than 97.62% of JavaScript online submissions for Search a 2D Matrix.\\nMemory Usage: 39.1 MB, less than 17.62% of JavaScript online submissions for Search a 2D Matrix.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar searchMatrix = function(matrix, target) {\\n let row = 0,\\n    col = matrix[0].length - 1;\\n  while (row < matrix.length) {\\n    if (matrix[row][col] === target) {\\n      return true;\\n    }\\n    if (matrix[row][col] < target) {\\n      row++;\\n    } else {\\n      col--;\\n      if (col < 0) {\\n        row++;\\n      }\\n    }\\n  }\\n  return false;\\n};\\n```\n```\\nvar searchMatrix = function(matrix, target) {\\nlet rows = matrix.length,\\n    cols = matrix[0].length,\\n    left = 0,\\n    right = rows * cols - 1;\\n  while (left <= right) {\\n    let midIndex = Math.floor(left + (right - left) / 2);\\n    let midElement = matrix[Math.floor(midIndex / cols)][midIndex % cols]; // matrix[row][col]\\n    if (midElement === target) {\\n      return true;\\n    } else if (target < midElement) {\\n      right = midIndex - 1;\\n    } else {\\n      left = midIndex + 1;\\n    }\\n  }\\n  return false;\\n  }\\n```\n```\\nvar searchMatrix = function(matrix, target) {\\n    let rowStart=0,rowEnd=matrix.length-1,colStart=0,colEnd=matrix[0].length-1;\\n\\t// setting the boundary limit\\n    while(rowStart<=rowEnd && colStart<=colEnd){\\n\\t/*As elements are in asc order we\\'re checking if the element exists \\n\\tfrom the last colIndex until we reach the first colIndex */\\n        if(target<=matrix[rowStart][colEnd] && colEnd>=0){\\n            if(matrix[rowStart][colEnd]===target){\\n                return true;\\n            }\\n\\t\\t\\t// from last col we\\'re decrementing one by one\\n            colEnd--;\\n        }else{\\n\\t\\t// increment the row by 1 if we didnt find even after we had reached the first col of particular row\\n            rowStart++;\\n\\t\\t\\t// reset the col Index\\n            colEnd=matrix[0].length-1;\\n        }\\n    }\\n    return false;\\n};\\n```\n```\\nvar searchMatrix = function(matrix, target) {\\n    let colEnd=matrix[0].length-1;\\n    let rowStart=0;let rowEnd=matrix.length-1;\\n    while(rowStart<=rowEnd){\\n        if(matrix[rowStart][colEnd]>=target){\\n            if(matrix[rowStart][colEnd]===target){\\n                return true\\n            }else {\\n                colEnd--;\\n            }\\n        }else{\\n            rowStart++;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 897456,
                "title": "treat-such-a-matrix-as-a-tree",
                "content": "***Solution 1:*** \\nTo solve this problem, we can treat such a matrix as a **tree**. How and why? From the observation, we can see that if we **start from the last element on the first row**, then its left element is always **smaller than** it left, and the element below is always **greater than** its above! From this point of view, each time we search the target, we can either go left or below to find the target quickly! **Here is the clean Java code**:\\n```\\npublic boolean searchMatrix(int[][] matrix, int target) {\\n\\tif (matrix == null || matrix.length == 0) return false;\\n\\tint i = 0, j = matrix[0].length - 1;\\n\\twhile (i >=0 && i <= matrix.length - 1 && j >=0 && j <= matrix[0].length - 1) {\\n\\t\\tif (matrix[i][j] == target) {\\n\\t\\t\\treturn true;\\n\\t\\t} else if (matrix[i][j] < target) {\\n\\t\\t\\ti++;\\n\\t\\t} else {\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n***Solution 2:*** \\nAnother solution is that, by our observation, if we traverse the matrix row by row, this will be a single sorted array. So we can also treate the problem as search the target number within a sorted array! Here is the clean Java code by using the binary search algorithm:\\n```\\npublic boolean searchMatrix(int[][] matrix, int target) {\\n\\tif (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;\\n\\tint row = matrix.length, col = matrix[0].length;\\n\\tint start = 0, end = row * col - 1;\\n\\twhile (start + 1 < end) {\\n\\t\\tint mid = start + (end - start) / 2;\\n\\t\\tif (matrix[mid / col][mid % col] == target) return true;\\n\\t\\telse if (matrix[mid / col][mid % col] < target) {\\n\\t\\t\\tstart = mid;\\n\\t\\t} else {\\n\\t\\t\\tend = mid;\\n\\t\\t}\\n\\t}\\n\\tif (matrix[start / col][start % col] == target) return true;\\n\\tif (matrix[end / col][end % col] == target) return true;\\n\\treturn false;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic boolean searchMatrix(int[][] matrix, int target) {\\n\\tif (matrix == null || matrix.length == 0) return false;\\n\\tint i = 0, j = matrix[0].length - 1;\\n\\twhile (i >=0 && i <= matrix.length - 1 && j >=0 && j <= matrix[0].length - 1) {\\n\\t\\tif (matrix[i][j] == target) {\\n\\t\\t\\treturn true;\\n\\t\\t} else if (matrix[i][j] < target) {\\n\\t\\t\\ti++;\\n\\t\\t} else {\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```\n```\\npublic boolean searchMatrix(int[][] matrix, int target) {\\n\\tif (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;\\n\\tint row = matrix.length, col = matrix[0].length;\\n\\tint start = 0, end = row * col - 1;\\n\\twhile (start + 1 < end) {\\n\\t\\tint mid = start + (end - start) / 2;\\n\\t\\tif (matrix[mid / col][mid % col] == target) return true;\\n\\t\\telse if (matrix[mid / col][mid % col] < target) {\\n\\t\\t\\tstart = mid;\\n\\t\\t} else {\\n\\t\\t\\tend = mid;\\n\\t\\t}\\n\\t}\\n\\tif (matrix[start / col][start % col] == target) return true;\\n\\tif (matrix[end / col][end % col] == target) return true;\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 897335,
                "title": "binary-search-detailed-explanantion-to-find-row-col-index",
                "content": "Now search for something in sorted something should immediately strike binary search, the issue is its a matrix, how do we do binary search on it?\\nFor example [1,2,3,4,\\n                      5,6,7,8] the total number of elements in a matrix are nr * nc-1.\\nso now we know our low =0 , high = nr*nc-1.\\nso lets say we are searching for 8 in above matrix\\nlow = 0, high=7 (2*4-1)\\nmid = 7/2 = 3, now how do we map 3 to the row and column so we can look up the element and decide which direction to move\\nhere is the formula, row=3/4=0, col=3%4 = 3, why you ask?\\nWhen we want to access M[0][3], the way the index is calculated is 0*4+3 = 3. so you are just reversing the calculation , row number is given by 3/4 = 0, and column is the offset in that row so for 3rd element it is 3%4 = 3. This [link](http://icarus.cs.weber.edu/~dab/cs1410/textbook/7.Arrays/row_major.html) helped me understand it.\\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if(matrix.length==0)\\n            return false;    \\n  \\n     int nr = matrix.length;\\n     int nc = matrix[0].length;\\n     int low=0, high = nr*nc-1;\\n     while(low<=high) {\\n         int mid = low + (high-low)/2;\\n         int row = mid/nc;\\n         int col = mid%nc;\\n         if(matrix[row][col]==target)\\n             return true;\\n         else if(target > matrix[row][col])\\n             low=mid+1;\\n         else\\n             high=mid-1;\\n     }\\n     return false;\\n\\n\\n\\n    So simple but O(N^2) -> we are not taking advantage of the sorted\\n    propery of the matrix\\n     for(int i=0;i<matrix.length;i++) {\\n         for(int j=0;j<matrix[i].length;j++) {\\n             if(matrix[i][j]==target)\\n                 return true;\\n         }\\n     }\\n     return false;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if(matrix.length==0)\\n            return false;    \\n  \\n     int nr = matrix.length;\\n     int nc = matrix[0].length;\\n     int low=0, high = nr*nc-1;\\n     while(low<=high) {\\n         int mid = low + (high-low)/2;\\n         int row = mid/nc;\\n         int col = mid%nc;\\n         if(matrix[row][col]==target)\\n             return true;\\n         else if(target > matrix[row][col])\\n             low=mid+1;\\n         else\\n             high=mid-1;\\n     }\\n     return false;\\n\\n\\n\\n    So simple but O(N^2) -> we are not taking advantage of the sorted\\n    propery of the matrix\\n     for(int i=0;i<matrix.length;i++) {\\n         for(int j=0;j<matrix[i].length;j++) {\\n             if(matrix[i][j]==target)\\n                 return true;\\n         }\\n     }\\n     return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896970,
                "title": "python-simplest-only-one-short-line-faster-than-92",
                "content": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        return target in sum(matrix, [])\\n```\\n\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        return target in sum(matrix, [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896945,
                "title": "c-simple-and-clean-short-solution-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if ((matrix.size() == 0) || (matrix[0].size() == 0)) return false;\\n        int row = 0;\\n        while ((row < matrix.size()) && (matrix[row].back() < target))\\n            row++;\\n        \\n        if (row >= matrix.size()) return false;\\n        \\n        // found the right row, loop through it to find target\\n        for (auto a:matrix[row])\\n            if (a == target)\\n                return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if ((matrix.size() == 0) || (matrix[0].size() == 0)) return false;\\n        int row = 0;\\n        while ((row < matrix.size()) && (matrix[row].back() < target))\\n            row++;\\n        \\n        if (row >= matrix.size()) return false;\\n        \\n        // found the right row, loop through it to find target\\n        for (auto a:matrix[row])\\n            if (a == target)\\n                return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26306,
                "title": "safe-binary-search-implementation",
                "content": "    class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            /** first check whether it is in the range **/\\n            int m=matrix.size(), n=matrix[0].size();\\n            if(target<matrix[0][0] || target>matrix[m-1][n-1]) return false;\\n            \\n            int start=-1, end=m*n-1;\\n            while(end-start>1){\\n                int mid=(start+end)/2;\\n                if(matrix[mid/n][mid%n] >= target) end=mid;\\n                else start=mid;\\n            }\\n            \\n            return matrix[end/n][end%n]==target;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            /** first check whether it is in the range **/\\n            int m=matrix.size(), n=matrix[0].size();\\n            if(target<matrix[0][0] || target>matrix[m-1][n-1]) return false;\\n            \\n            int start=-1, end=m*n-1;\\n            while(end-start>1){\\n                int mid=(start+end)/2;\\n                if(matrix[mid/n][mid%n] >= target) end=mid;\\n                else start=mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 26364,
                "title": "concise-c-solution-binary-search",
                "content": "I label the grid from 0 - n * m -1. The numbers are ascending. So Binary Search works in this case.\\n\\n    class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            if (matrix.size() == 0) return false;\\n            int p = 0, q = matrix.size() * matrix[0].size() - 1;\\n            while (p <= q){\\n                int mid = p + (q - p) / 2, x = mid / matrix[0].size(), y = mid % matrix[0].size();\\n                if (matrix[x][y] == target) return true;\\n                if (matrix[x][y] > target) \\n                    q = mid - 1;\\n                else\\n                    p = mid + 1;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            if (matrix.size() == 0) return false;\\n            int p = 0, q = matrix.size() * matrix[0].size() - 1;\\n            while (p <= q){\\n                int mid = p + (q - p) / 2, x = mid / matrix[0].size(), y = mid % matrix[0].size();\\n                if (matrix[x][y] == target) return true;\\n                if (matrix[x][y] > target) \\n                    q = mid - 1;\\n                else\\n                    p = mid + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 26386,
                "title": "my-accepted-java-solution-without-binary-search",
                "content": "public class Solution {\\n\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n       int m = 0;                        //starting with first row\\n        int n = matrix[0].length;  //starting with last column\\n        int col = n-1;\\n        int maxRow = matrix.length-1;\\n        \\n        while(m<=maxRow && col>=0){    //loop till maximum row and till first column \\n        \\n        if(matrix[m][col]==target){\\n            return true;\\n        }\\n\\n        else if(matrix[m][col]>target){\\n            col--; \\n          }\\n\\n        else if(matrix[m][col]<target){\\n             m++; \\n          }\\n      }\\n     return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n       int m = 0;                        //starting with first row\\n        int n = matrix[0].length;  //starting with last column\\n        int col = n-1;\\n        int maxRow = matrix.length-1;\\n        \\n        while(m<=maxRow && col>=0){    //loop till maximum row and till first column \\n        \\n        if(matrix[m][col]==target){\\n            return true;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1804076,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 1733091,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 1723153,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 1573247,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 1751612,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 1566710,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 2003687,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 1829206,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 2003596,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 1725123,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 1804076,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 1733091,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 1723153,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 1573247,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 1751612,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 1566710,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 2003687,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 1829206,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 2003596,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 1725123,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "Its simple binary search, just in a 2d matrix.\\nHere, no. of rows and cols can be found as:\\n`int r = matrix.size();\\nint c = matrix[0].size();`\\nAnd the low and high will be:\\n`int low = 0, high = (r*c)-1;`\\n\\nThe real thing that you\\'ll get stuck in is how to do the comparison between the mid element and the target element. Its simple, you can find the row index by dividing the mid (index of the number) by number of columns, the quotient will be the row index, while the remainder will be the column index. In simple words, it\\'ll be like:\\n`matrix[mid/c][mid%c]`\\n\\nNow, question comes in mind, that why is this so? Why do we get row index as the quotient and col index as the remainder if we divide the index of the number by number of cols?\\nBelow is its explanation:\\nIn a 2D matrix, each element can be uniquely identified by its row index and column index. Let\\'s say we have a matrix of size m x n (m rows and n columns) and we want to find the row and column index of an element at index i in the matrix.\\nTo find the row index, we can divide the index i by the number of columns n. The quotient of this division gives us the row index. This is because every n elements in the matrix belong to the same row. For example, in a matrix of size 3 x 4, the first 4 elements belong to the first row, the next 4 elements belong to the second row, and so on.\\nTo find the column index, we can take the remainder of the same division (i divided by n). This is because the remainder gives us the position of the element within the row. For example, if i is 5 and n is 4, then the row index is i/n = 5/4 = 1 (integer division gives us 1) and the column index is i mod n = 5 mod 4 = 1.\\n\\nIf you like the exlanation, kindly upvote.\\u2764\\uFE0F"
                    },
                    {
                        "username": "AryanP45",
                        "content": "Thanks for the hint"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. I wonder if anyone can come up with this approach in the interview without seeing this question before "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "found it helpful, thank you!!"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "just a simple tip always remember\\nin 2d matrix of m*n\\n no. of rows = mid/n \\nno. of cols= mid%n\\n\\nThank You\\n"
                    },
                    {
                        "username": "dhruva_soni",
                        "content": "Suman Don't mug up buddy little correction to your statement\n\n1)To find the column given an index i, we just take i % n .\n\n2) Given an index i,we can find the row it belongs to by dividing by n , row = i/n ."
                    },
                    {
                        "username": "selvamuthukumar038",
                        "content": "what's the ans for testcase [[1,3]] ... ? from your concept"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "actually no. of rows should be truncate(mid/n), division gives non integer result"
                    },
                    {
                        "username": "knotri",
                        "content": "[@gaurav_chak20](/gaurav_chak20) I guess its for binary search, mid is (left + right)/2, and \"no.\" is not number of, but  index of row and column."
                    },
                    {
                        "username": "gaurav_chak20",
                        "content": "Please explain!! Clarify what is mid and why are you calculating number of rows and cols this way if sizeof operator can be easily used."
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is very bad.\\nQuestion is asked for binary search ,and i write the solution of linear search ... and code accepted... why?? "
                    },
                    {
                        "username": "Davidfaleye360",
                        "content": "Maybe your solution ran in a flash"
                    },
                    {
                        "username": "Impractical",
                        "content": "[@mochiball](/mochiball)  You do know that log(m) +log(n) is equal to log(m*n) right?\\nGiven the base of the log is the same"
                    },
                    {
                        "username": "geeksadesh",
                        "content": "due to low constraints"
                    },
                    {
                        "username": "dtkalla",
                        "content": "I agree -- they should really adjust the constraints to include bigger numbers (e.g., an 10**5 * 10**5 matrix) so only O(n) solutions don\\'t pass."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thienbao12a2](/thienbao12a2) I used two pointers with binary search (O(m) + O(log n)) and got accepted, faster than 100%.\\n\\nNot sure why O(logm+logn) is faster "
                    },
                    {
                        "username": "khateeb_ur_rehman",
                        "content": "[@thienbao12a2](/thienbao12a2) same here"
                    },
                    {
                        "username": "thienbao12a2",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Yea but my m *n solution is accepted as faster than 100% of other users??"
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "maximum row and column is 100 each. For smaller numbers, linear search is faster. Leetcode does not check for your time complexity but your actual speed vs the rest of the population instead, hence your linear search is accepted"
                    },
                    {
                        "username": "sanyam_pandita",
                        "content": "lmao"
                    },
                    {
                        "username": "KateMelnykova",
                        "content": "I think that the testcase where matrix=[] and target=0 is incorrect. [] is not a matrix.\\n\\nMaybe this testcase should be removed? Who should I contact about it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t see why it needs to be deleted. Any pointers used on an empty matrix will be beyond the boundaries of the matrix which is a condition for returning false."
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "It is removed"
                    },
                    {
                        "username": "hfiroz86",
                        "content": "we can consider 2d as 1d and we can simply apply binary search to search the target \\nto get element= s[mid/col][mid%col]\\nwhere mid is calculated mid value\\nmiid/col give row value \\nmid%col give you column value \\nplease do upvotes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s an already solved problem for me"
                    },
                    {
                        "username": "shaw-code",
                        "content": "[@georgezakharov](/georgezakharov) \\uD83D\\uDE02"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this information"
                    },
                    {
                        "username": "pg99285",
                        "content": "I think of approach, I got an approach, I implemented approach, It worked for the sample testcases. Now what the hell is [[1]]. Frustration at its max."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@guptashivam48616](/guptashivam48616) A good set of rules of thumb here."
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "when we use `low < high` usually we want them to converge to one index. \\nto achieve this you have two combination option\\n1.  mid = low + (high-low+1)/2;  // shifting mid to right side\\n    low = mid;\\n    high = mid-1; \\nAdding +1 in mid shifts it to right side of range\\n2. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid;\\nWith `low <= high`\\n1. mid = (high+low)/2;\\n    low = mid+1;\\n    high = mid-1;\\nwith a extra variable `ans` to store current mid value\\n\\nWhen test case is [[1]], low < high does not enter loop, and return false always"
                    },
                    {
                        "username": "Vithesh",
                        "content": "yea same :P i got output for other test case in first try itself and now in stuck in [[1]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use lower_bound done before. Resubmit"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show TLE ..?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n      int row= matrix.size();\\n      int col = matrix[0].size();  \\n\\n      int start =0;\\n      int end = row*col -1;\\n\\n      int mid = start + (end-start)/2;\\n\\n      while(start<=end){\\n        int ele = matrix[mid/col][mid%col];\\n\\n        if(ele == target){\\n              return 1;\\n        }\\n        if(ele < target){\\n              start = mid+1;\\n        }\\n        else{\\n              end = mid -1;\\n        }\\n        int mid = start + (end-start)/2; \\n    }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "TLE is because you are re-declaring the mid variable as ==> int mid = s + (e-s)/2;\\n\\nThis is causing creation of new local variable named mid with above values & your outer Mid isn\\'t updating. Just remove int before mid in last line of while loop"
                    },
                    {
                        "username": "__Ace__",
                        "content": "you are re-declaring mid \\n\\nfirst at line third and then again at bottom  \\njust remove int  so the above code will be :\\n\\n  int start =0;\\n  int end = row*col -1;\\n\\n  int mid = start + (end-start)/2;\\n\\n  while(start<=end){\\n    int ele = matrix[mid/col][mid%col];\\n\\n    if(ele == target){\\n          return 1;\\n    }\\n    if(ele < target){\\n          start = mid+1;\\n    }\\n    else{\\n          end = mid -1;\\n    }\\n    mid = start + (end-start)/2;  ======>>> here is the problem \\n}\\n  return 0;\\n}\\n\\nhope it helps "
                    },
                    {
                        "username": "thevirajkhot",
                        "content": "Did u get the ans why is it showing TLE?\\nI\\'m facing the same problem."
                    },
                    {
                        "username": "mkohar",
                        "content": "Could be for one of the 2 possible reasons:\\n1. Loop is getting stuck in infinite loop -> try giving a hard limit of 50 and test\\n2. Solution is not optimised enough"
                    }
                ]
            },
            {
                "id": 2050872,
                "content": [
                    {
                        "username": "mbed",
                        "content": "Imagine (rather actually draw it out) how a 2D array (m * n matrix) would be placed 'row-wise' into a 1D array - \neach row from a 2D array is placed as successive blocks of rows starting from row 0 to row m - 1 (of the 2D array);\n\n(Note that here the array could be placed 'column-wise' (opportunity to trick someone) into the 1D array and below translation of\nindices may not work as-is; hence how the 2D array is placed into the 1D array is important to know/imagine)\n\nGiven 'row-wise' placement, the 1D array now consists of 'blocks' of m rows and each 'block' contains column (n) number of elements; \n\nTake a 3x4 Matix placed row-wise into a 1D array as an example -\n\n`1D-Index:   | 0 1 2 3 | 4 5 6 7 | 8  9   10 11 |`\n`Elements:   | 1 2 3 4 | 5 6 7 8 | 8 10 11 12 |`\n\nTo find out the 2D Row index from a 1D array index, is equal to telling which row-block does this index belong to;\n\nwhich is = 1D index / # elements in the row-block\nwhich is = 1D index / # columns\n\ne.g.\nif 1D index is 7;\n       2D Row index = 7 / #columns\n\t                = 7 / 4\n\t\t\t\t\t= 1\n\t\t\t\t\t\nNow onto column index,\n\nIf you look at above example, column index is just an offest inside a given row-block.\nWhile this seems less intuitive to derive, the remainder of the division operation we performed above\nto get the row index gives you the offset in that row, which turns out to be the column index.\n\nSo 2D Col Index =  Remainder of (1D-Index / #columns)\n                          =  (1D-index % #columns)\n\n\ne.g.\nif 1D index is 7;\n2D Col index = 7 % 4\n\t                = 3\n\t\t\t\n\t\t\t\nGiving us (for a 1D array index 'i' and an m * n matrix placed row-wise into the 1D array), \n1D to 2D index transformation:\n\n`[i]  =>  [i / n][i % n]`\n\n\nBonus:\nIf the matrix is sorted column-wise,  an so we imagine placing the matrix as 'column-wise' blocks into the 1D array, then,\n1D to 2D index transformation:\n`[i]  =>  [i % m][i / m]`\n\n2D to 1D (row-wise) transformation:\n`[i][j] => [i * n + j]`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Good solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "When I originally did this problem, I did a binary search of the start of each row to locate the row then did a binary search of the row itself to find the target. O(log M + log N). This method works because the start of each row is greater than the end of the previous row.\nThen I noticed that if the TR corner of the matrix was greater than the target then you could eliminate the entire RH column. Similarly, if the TR corner of the matrix is less than the target then you can eliminate the entire top row. So you can just walk down the matrix until you either hit the target or fall off the matrix.\nThis has a O(M + N) run time which is not as good as the binary search method but is useful to know if you want to tackle ``240. Search a 2D Matrix II`` where a binary search to locate the row is not possible.\n"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-a-2d-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "chrisrao",
                        "content": "I think this would be more clear if it said \"ascending order\" rather than \"non-decreasing order\". I spent some time looking at the matrices wondering if there was some trick before deciding to implement a binary search. "
                    },
                    {
                        "username": "shaw-code",
                        "content": "\"Ascending order\" and \"Non decreasing order\" are two different things.\\nAscending order contain only unique elements in sorted order. [1,2,3]\\nNon-decreasing order contain repeated elements in sorted order. [1,1,2,3]\\n\\nSame goes for Descending order and Non-increasing order."
                    },
                    {
                        "username": "viyengar",
                        "content": "Non-decreasing order is a more precise description for the problem. \\nex: [1, 2, 2, 3, 4] is NOT technically ascending order, but is a valid input for a row in the matrix."
                    },
                    {
                        "username": "adrians99",
                        "content": "Useful tests to check extreme cases\\n\\n`matrix = [[1],[3],[5]] target = 3`\\n`matrix = [[1, 3]] target = 3`\\n`matrix = [[1, 3]] target = 2`\\n`matrix = [[1]] target = 1`"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "It would be great if leetcode had a  time and memory complexity analyzer of the code. My solution is log(m * n), but seems that test cases is small enough that linear time algorithm can beat it))."
                    },
                    {
                        "username": "user2049D",
                        "content": "You are right. Sometimes, O(m + n) code is faster than the O(log(m * n)) one !"
                    },
                    {
                        "username": "code_24x7",
                        "content": "Solved it in O(log(m)*log(n)).\n1. First binary search the rows to the get the target row.\n2. Next binary search the target_row to search the element.\n\nHow does it compare to O(log(m*n)), How must i do the math for that. Can someone help?\n\n `class Solution:\n    def get_target_row(self, matrix, target):\n        start = 0\n        end = len(matrix)-1\n        col = len(matrix[0])-1\n        while start <= end:\n            mid = start + (end-start)//2\n            if target >= matrix[mid][0] and target <= matrix[mid][col]:\n                return mid\n            elif target < matrix[mid][0]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return -1\n\n    def binary_search(self, array, target):\n        start = 0\n        end = len(array)\n        while start <= end:\n            mid = start + (end-start)//2\n            if target == array[mid]:\n                return True\n            elif target < array[mid]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return False\n\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        row = len(matrix)\n        col = len(matrix[0])-1\n        target_row = self.get_target_row(matrix, target)\n        if target_row == -1:\n            return False\n        return self.binary_search(matrix[target_row], target)`\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The run time is O(log(m) + log(n)) which is the same as O(log(m*n))."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i try but it fail on \\ngiven test case \\nthis test case from GFG;\\n\\n\\n9            7\\n1 2 2 2 3 5 7 9 10 13 15 15 16 19 19 21 21 23 23 26 26 27 29 29 31 31 33 34 35 35 35 36 36 36 37 38 40 41 44 45 45 48 48 51 52 53 53 57 57 58 59 59 59 61 63 64 65 67 68 69 70 70 70\\n31"
                    },
                    {
                        "username": "therishuraj",
                        "content": "Its an invalid testcase,\\nwill throw an error as \"The first integer of each row is greater than the last integer of the previous row.\"\\nas matrix[2][0] not greater then matrix[1][6];\\nso matrix[2][0] can be taken as 24.\\ncorrect input can be :-\\n9 * 7\\n[[1, 2, 2, 2, 3, 5, 7, 9, 10],[13, 15, 15, 16, 19, 19, 21, 21, 23],[24, 26, 26, 27, 29, 29, 31, 31, 33],[34, 35, 35, 35, 36, 36, 36, 37, 38], [40, 41, 44, 45, 45, 48, 48, 51, 52], [53, 53, 57, 57, 58, 59, 59, 59, 61], [63, 64, 65, 67, 68, 69, 70, 70, 70]]\\ntarget = 31\\nwill give proper result on applying binary search correctly."
                    },
                    {
                        "username": "TimPC",
                        "content": "This test case has long rows and a big jump where the second row  first entry is less than the target. To pass it successfully you have to do binary search on the first row and then skip the second row entirely because the first entry is too large."
                    },
                    {
                        "username": "voidptr",
                        "content": "Hi \\n\\nI am just trying to understand what is the difference between this problem and :\\nhttps://leetcode.com/problems/search-a-2d-matrix-ii/description/\\n\\nI feel they are identical."
                    },
                    {
                        "username": "psionl0",
                        "content": "In problem 240 you can\\'t use a binary search to locate the row so a linear run time is the best that you will get."
                    },
                    {
                        "username": "mochiball",
                        "content": "Different. This one everything is sorted . The other one the rows are sorted and columns are sorted BUT the last value in the row might not be smaller than the first value in the next row   "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "I agree with previous answers, also this problem asking to solve it with O(log(m*n))"
                    },
                    {
                        "username": "mkohar",
                        "content": "No they are not. \\nCondition **\"The first integer of each row is greater than the last integer of the previous row.\"** is true for this (#74) question, but not for the one in link(240)"
                    },
                    {
                        "username": "zephyr8",
                        "content": "[@Random Ptr](/voidptr)  - the problems are not identical.  If we were to write this matrix out as an array - it will be totally sorted. That\\'s not guaranteed for the other problem. "
                    },
                    {
                        "username": "zhangben",
                        "content": "what if change the condition like this:\\nIntegers in each row are sorted from left to right.\\nIntegers in each column are sorted from up to down.\\nhow should we solve this problem?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "you need to realize that its same as what we have now\\n "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "it is the same condition we have in the description"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can this even be solved in Log(m+n) ?"
                    }
                ]
            },
            {
                "id": 2003628,
                "content": [
                    {
                        "username": "mbed",
                        "content": "Imagine (rather actually draw it out) how a 2D array (m * n matrix) would be placed 'row-wise' into a 1D array - \neach row from a 2D array is placed as successive blocks of rows starting from row 0 to row m - 1 (of the 2D array);\n\n(Note that here the array could be placed 'column-wise' (opportunity to trick someone) into the 1D array and below translation of\nindices may not work as-is; hence how the 2D array is placed into the 1D array is important to know/imagine)\n\nGiven 'row-wise' placement, the 1D array now consists of 'blocks' of m rows and each 'block' contains column (n) number of elements; \n\nTake a 3x4 Matix placed row-wise into a 1D array as an example -\n\n`1D-Index:   | 0 1 2 3 | 4 5 6 7 | 8  9   10 11 |`\n`Elements:   | 1 2 3 4 | 5 6 7 8 | 8 10 11 12 |`\n\nTo find out the 2D Row index from a 1D array index, is equal to telling which row-block does this index belong to;\n\nwhich is = 1D index / # elements in the row-block\nwhich is = 1D index / # columns\n\ne.g.\nif 1D index is 7;\n       2D Row index = 7 / #columns\n\t                = 7 / 4\n\t\t\t\t\t= 1\n\t\t\t\t\t\nNow onto column index,\n\nIf you look at above example, column index is just an offest inside a given row-block.\nWhile this seems less intuitive to derive, the remainder of the division operation we performed above\nto get the row index gives you the offset in that row, which turns out to be the column index.\n\nSo 2D Col Index =  Remainder of (1D-Index / #columns)\n                          =  (1D-index % #columns)\n\n\ne.g.\nif 1D index is 7;\n2D Col index = 7 % 4\n\t                = 3\n\t\t\t\n\t\t\t\nGiving us (for a 1D array index 'i' and an m * n matrix placed row-wise into the 1D array), \n1D to 2D index transformation:\n\n`[i]  =>  [i / n][i % n]`\n\n\nBonus:\nIf the matrix is sorted column-wise,  an so we imagine placing the matrix as 'column-wise' blocks into the 1D array, then,\n1D to 2D index transformation:\n`[i]  =>  [i % m][i / m]`\n\n2D to 1D (row-wise) transformation:\n`[i][j] => [i * n + j]`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Good solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "When I originally did this problem, I did a binary search of the start of each row to locate the row then did a binary search of the row itself to find the target. O(log M + log N). This method works because the start of each row is greater than the end of the previous row.\nThen I noticed that if the TR corner of the matrix was greater than the target then you could eliminate the entire RH column. Similarly, if the TR corner of the matrix is less than the target then you can eliminate the entire top row. So you can just walk down the matrix until you either hit the target or fall off the matrix.\nThis has a O(M + N) run time which is not as good as the binary search method but is useful to know if you want to tackle ``240. Search a 2D Matrix II`` where a binary search to locate the row is not possible.\n"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-a-2d-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "chrisrao",
                        "content": "I think this would be more clear if it said \"ascending order\" rather than \"non-decreasing order\". I spent some time looking at the matrices wondering if there was some trick before deciding to implement a binary search. "
                    },
                    {
                        "username": "shaw-code",
                        "content": "\"Ascending order\" and \"Non decreasing order\" are two different things.\\nAscending order contain only unique elements in sorted order. [1,2,3]\\nNon-decreasing order contain repeated elements in sorted order. [1,1,2,3]\\n\\nSame goes for Descending order and Non-increasing order."
                    },
                    {
                        "username": "viyengar",
                        "content": "Non-decreasing order is a more precise description for the problem. \\nex: [1, 2, 2, 3, 4] is NOT technically ascending order, but is a valid input for a row in the matrix."
                    },
                    {
                        "username": "adrians99",
                        "content": "Useful tests to check extreme cases\\n\\n`matrix = [[1],[3],[5]] target = 3`\\n`matrix = [[1, 3]] target = 3`\\n`matrix = [[1, 3]] target = 2`\\n`matrix = [[1]] target = 1`"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "It would be great if leetcode had a  time and memory complexity analyzer of the code. My solution is log(m * n), but seems that test cases is small enough that linear time algorithm can beat it))."
                    },
                    {
                        "username": "user2049D",
                        "content": "You are right. Sometimes, O(m + n) code is faster than the O(log(m * n)) one !"
                    },
                    {
                        "username": "code_24x7",
                        "content": "Solved it in O(log(m)*log(n)).\n1. First binary search the rows to the get the target row.\n2. Next binary search the target_row to search the element.\n\nHow does it compare to O(log(m*n)), How must i do the math for that. Can someone help?\n\n `class Solution:\n    def get_target_row(self, matrix, target):\n        start = 0\n        end = len(matrix)-1\n        col = len(matrix[0])-1\n        while start <= end:\n            mid = start + (end-start)//2\n            if target >= matrix[mid][0] and target <= matrix[mid][col]:\n                return mid\n            elif target < matrix[mid][0]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return -1\n\n    def binary_search(self, array, target):\n        start = 0\n        end = len(array)\n        while start <= end:\n            mid = start + (end-start)//2\n            if target == array[mid]:\n                return True\n            elif target < array[mid]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return False\n\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        row = len(matrix)\n        col = len(matrix[0])-1\n        target_row = self.get_target_row(matrix, target)\n        if target_row == -1:\n            return False\n        return self.binary_search(matrix[target_row], target)`\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The run time is O(log(m) + log(n)) which is the same as O(log(m*n))."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i try but it fail on \\ngiven test case \\nthis test case from GFG;\\n\\n\\n9            7\\n1 2 2 2 3 5 7 9 10 13 15 15 16 19 19 21 21 23 23 26 26 27 29 29 31 31 33 34 35 35 35 36 36 36 37 38 40 41 44 45 45 48 48 51 52 53 53 57 57 58 59 59 59 61 63 64 65 67 68 69 70 70 70\\n31"
                    },
                    {
                        "username": "therishuraj",
                        "content": "Its an invalid testcase,\\nwill throw an error as \"The first integer of each row is greater than the last integer of the previous row.\"\\nas matrix[2][0] not greater then matrix[1][6];\\nso matrix[2][0] can be taken as 24.\\ncorrect input can be :-\\n9 * 7\\n[[1, 2, 2, 2, 3, 5, 7, 9, 10],[13, 15, 15, 16, 19, 19, 21, 21, 23],[24, 26, 26, 27, 29, 29, 31, 31, 33],[34, 35, 35, 35, 36, 36, 36, 37, 38], [40, 41, 44, 45, 45, 48, 48, 51, 52], [53, 53, 57, 57, 58, 59, 59, 59, 61], [63, 64, 65, 67, 68, 69, 70, 70, 70]]\\ntarget = 31\\nwill give proper result on applying binary search correctly."
                    },
                    {
                        "username": "TimPC",
                        "content": "This test case has long rows and a big jump where the second row  first entry is less than the target. To pass it successfully you have to do binary search on the first row and then skip the second row entirely because the first entry is too large."
                    },
                    {
                        "username": "voidptr",
                        "content": "Hi \\n\\nI am just trying to understand what is the difference between this problem and :\\nhttps://leetcode.com/problems/search-a-2d-matrix-ii/description/\\n\\nI feel they are identical."
                    },
                    {
                        "username": "psionl0",
                        "content": "In problem 240 you can\\'t use a binary search to locate the row so a linear run time is the best that you will get."
                    },
                    {
                        "username": "mochiball",
                        "content": "Different. This one everything is sorted . The other one the rows are sorted and columns are sorted BUT the last value in the row might not be smaller than the first value in the next row   "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "I agree with previous answers, also this problem asking to solve it with O(log(m*n))"
                    },
                    {
                        "username": "mkohar",
                        "content": "No they are not. \\nCondition **\"The first integer of each row is greater than the last integer of the previous row.\"** is true for this (#74) question, but not for the one in link(240)"
                    },
                    {
                        "username": "zephyr8",
                        "content": "[@Random Ptr](/voidptr)  - the problems are not identical.  If we were to write this matrix out as an array - it will be totally sorted. That\\'s not guaranteed for the other problem. "
                    },
                    {
                        "username": "zhangben",
                        "content": "what if change the condition like this:\\nIntegers in each row are sorted from left to right.\\nIntegers in each column are sorted from up to down.\\nhow should we solve this problem?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "you need to realize that its same as what we have now\\n "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "it is the same condition we have in the description"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can this even be solved in Log(m+n) ?"
                    }
                ]
            },
            {
                "id": 1648705,
                "content": [
                    {
                        "username": "mbed",
                        "content": "Imagine (rather actually draw it out) how a 2D array (m * n matrix) would be placed 'row-wise' into a 1D array - \neach row from a 2D array is placed as successive blocks of rows starting from row 0 to row m - 1 (of the 2D array);\n\n(Note that here the array could be placed 'column-wise' (opportunity to trick someone) into the 1D array and below translation of\nindices may not work as-is; hence how the 2D array is placed into the 1D array is important to know/imagine)\n\nGiven 'row-wise' placement, the 1D array now consists of 'blocks' of m rows and each 'block' contains column (n) number of elements; \n\nTake a 3x4 Matix placed row-wise into a 1D array as an example -\n\n`1D-Index:   | 0 1 2 3 | 4 5 6 7 | 8  9   10 11 |`\n`Elements:   | 1 2 3 4 | 5 6 7 8 | 8 10 11 12 |`\n\nTo find out the 2D Row index from a 1D array index, is equal to telling which row-block does this index belong to;\n\nwhich is = 1D index / # elements in the row-block\nwhich is = 1D index / # columns\n\ne.g.\nif 1D index is 7;\n       2D Row index = 7 / #columns\n\t                = 7 / 4\n\t\t\t\t\t= 1\n\t\t\t\t\t\nNow onto column index,\n\nIf you look at above example, column index is just an offest inside a given row-block.\nWhile this seems less intuitive to derive, the remainder of the division operation we performed above\nto get the row index gives you the offset in that row, which turns out to be the column index.\n\nSo 2D Col Index =  Remainder of (1D-Index / #columns)\n                          =  (1D-index % #columns)\n\n\ne.g.\nif 1D index is 7;\n2D Col index = 7 % 4\n\t                = 3\n\t\t\t\n\t\t\t\nGiving us (for a 1D array index 'i' and an m * n matrix placed row-wise into the 1D array), \n1D to 2D index transformation:\n\n`[i]  =>  [i / n][i % n]`\n\n\nBonus:\nIf the matrix is sorted column-wise,  an so we imagine placing the matrix as 'column-wise' blocks into the 1D array, then,\n1D to 2D index transformation:\n`[i]  =>  [i % m][i / m]`\n\n2D to 1D (row-wise) transformation:\n`[i][j] => [i * n + j]`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Good solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "When I originally did this problem, I did a binary search of the start of each row to locate the row then did a binary search of the row itself to find the target. O(log M + log N). This method works because the start of each row is greater than the end of the previous row.\nThen I noticed that if the TR corner of the matrix was greater than the target then you could eliminate the entire RH column. Similarly, if the TR corner of the matrix is less than the target then you can eliminate the entire top row. So you can just walk down the matrix until you either hit the target or fall off the matrix.\nThis has a O(M + N) run time which is not as good as the binary search method but is useful to know if you want to tackle ``240. Search a 2D Matrix II`` where a binary search to locate the row is not possible.\n"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-a-2d-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "chrisrao",
                        "content": "I think this would be more clear if it said \"ascending order\" rather than \"non-decreasing order\". I spent some time looking at the matrices wondering if there was some trick before deciding to implement a binary search. "
                    },
                    {
                        "username": "shaw-code",
                        "content": "\"Ascending order\" and \"Non decreasing order\" are two different things.\\nAscending order contain only unique elements in sorted order. [1,2,3]\\nNon-decreasing order contain repeated elements in sorted order. [1,1,2,3]\\n\\nSame goes for Descending order and Non-increasing order."
                    },
                    {
                        "username": "viyengar",
                        "content": "Non-decreasing order is a more precise description for the problem. \\nex: [1, 2, 2, 3, 4] is NOT technically ascending order, but is a valid input for a row in the matrix."
                    },
                    {
                        "username": "adrians99",
                        "content": "Useful tests to check extreme cases\\n\\n`matrix = [[1],[3],[5]] target = 3`\\n`matrix = [[1, 3]] target = 3`\\n`matrix = [[1, 3]] target = 2`\\n`matrix = [[1]] target = 1`"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "It would be great if leetcode had a  time and memory complexity analyzer of the code. My solution is log(m * n), but seems that test cases is small enough that linear time algorithm can beat it))."
                    },
                    {
                        "username": "user2049D",
                        "content": "You are right. Sometimes, O(m + n) code is faster than the O(log(m * n)) one !"
                    },
                    {
                        "username": "code_24x7",
                        "content": "Solved it in O(log(m)*log(n)).\n1. First binary search the rows to the get the target row.\n2. Next binary search the target_row to search the element.\n\nHow does it compare to O(log(m*n)), How must i do the math for that. Can someone help?\n\n `class Solution:\n    def get_target_row(self, matrix, target):\n        start = 0\n        end = len(matrix)-1\n        col = len(matrix[0])-1\n        while start <= end:\n            mid = start + (end-start)//2\n            if target >= matrix[mid][0] and target <= matrix[mid][col]:\n                return mid\n            elif target < matrix[mid][0]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return -1\n\n    def binary_search(self, array, target):\n        start = 0\n        end = len(array)\n        while start <= end:\n            mid = start + (end-start)//2\n            if target == array[mid]:\n                return True\n            elif target < array[mid]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return False\n\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        row = len(matrix)\n        col = len(matrix[0])-1\n        target_row = self.get_target_row(matrix, target)\n        if target_row == -1:\n            return False\n        return self.binary_search(matrix[target_row], target)`\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The run time is O(log(m) + log(n)) which is the same as O(log(m*n))."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i try but it fail on \\ngiven test case \\nthis test case from GFG;\\n\\n\\n9            7\\n1 2 2 2 3 5 7 9 10 13 15 15 16 19 19 21 21 23 23 26 26 27 29 29 31 31 33 34 35 35 35 36 36 36 37 38 40 41 44 45 45 48 48 51 52 53 53 57 57 58 59 59 59 61 63 64 65 67 68 69 70 70 70\\n31"
                    },
                    {
                        "username": "therishuraj",
                        "content": "Its an invalid testcase,\\nwill throw an error as \"The first integer of each row is greater than the last integer of the previous row.\"\\nas matrix[2][0] not greater then matrix[1][6];\\nso matrix[2][0] can be taken as 24.\\ncorrect input can be :-\\n9 * 7\\n[[1, 2, 2, 2, 3, 5, 7, 9, 10],[13, 15, 15, 16, 19, 19, 21, 21, 23],[24, 26, 26, 27, 29, 29, 31, 31, 33],[34, 35, 35, 35, 36, 36, 36, 37, 38], [40, 41, 44, 45, 45, 48, 48, 51, 52], [53, 53, 57, 57, 58, 59, 59, 59, 61], [63, 64, 65, 67, 68, 69, 70, 70, 70]]\\ntarget = 31\\nwill give proper result on applying binary search correctly."
                    },
                    {
                        "username": "TimPC",
                        "content": "This test case has long rows and a big jump where the second row  first entry is less than the target. To pass it successfully you have to do binary search on the first row and then skip the second row entirely because the first entry is too large."
                    },
                    {
                        "username": "voidptr",
                        "content": "Hi \\n\\nI am just trying to understand what is the difference between this problem and :\\nhttps://leetcode.com/problems/search-a-2d-matrix-ii/description/\\n\\nI feel they are identical."
                    },
                    {
                        "username": "psionl0",
                        "content": "In problem 240 you can\\'t use a binary search to locate the row so a linear run time is the best that you will get."
                    },
                    {
                        "username": "mochiball",
                        "content": "Different. This one everything is sorted . The other one the rows are sorted and columns are sorted BUT the last value in the row might not be smaller than the first value in the next row   "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "I agree with previous answers, also this problem asking to solve it with O(log(m*n))"
                    },
                    {
                        "username": "mkohar",
                        "content": "No they are not. \\nCondition **\"The first integer of each row is greater than the last integer of the previous row.\"** is true for this (#74) question, but not for the one in link(240)"
                    },
                    {
                        "username": "zephyr8",
                        "content": "[@Random Ptr](/voidptr)  - the problems are not identical.  If we were to write this matrix out as an array - it will be totally sorted. That\\'s not guaranteed for the other problem. "
                    },
                    {
                        "username": "zhangben",
                        "content": "what if change the condition like this:\\nIntegers in each row are sorted from left to right.\\nIntegers in each column are sorted from up to down.\\nhow should we solve this problem?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "you need to realize that its same as what we have now\\n "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "it is the same condition we have in the description"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can this even be solved in Log(m+n) ?"
                    }
                ]
            },
            {
                "id": 2039631,
                "content": [
                    {
                        "username": "mbed",
                        "content": "Imagine (rather actually draw it out) how a 2D array (m * n matrix) would be placed 'row-wise' into a 1D array - \neach row from a 2D array is placed as successive blocks of rows starting from row 0 to row m - 1 (of the 2D array);\n\n(Note that here the array could be placed 'column-wise' (opportunity to trick someone) into the 1D array and below translation of\nindices may not work as-is; hence how the 2D array is placed into the 1D array is important to know/imagine)\n\nGiven 'row-wise' placement, the 1D array now consists of 'blocks' of m rows and each 'block' contains column (n) number of elements; \n\nTake a 3x4 Matix placed row-wise into a 1D array as an example -\n\n`1D-Index:   | 0 1 2 3 | 4 5 6 7 | 8  9   10 11 |`\n`Elements:   | 1 2 3 4 | 5 6 7 8 | 8 10 11 12 |`\n\nTo find out the 2D Row index from a 1D array index, is equal to telling which row-block does this index belong to;\n\nwhich is = 1D index / # elements in the row-block\nwhich is = 1D index / # columns\n\ne.g.\nif 1D index is 7;\n       2D Row index = 7 / #columns\n\t                = 7 / 4\n\t\t\t\t\t= 1\n\t\t\t\t\t\nNow onto column index,\n\nIf you look at above example, column index is just an offest inside a given row-block.\nWhile this seems less intuitive to derive, the remainder of the division operation we performed above\nto get the row index gives you the offset in that row, which turns out to be the column index.\n\nSo 2D Col Index =  Remainder of (1D-Index / #columns)\n                          =  (1D-index % #columns)\n\n\ne.g.\nif 1D index is 7;\n2D Col index = 7 % 4\n\t                = 3\n\t\t\t\n\t\t\t\nGiving us (for a 1D array index 'i' and an m * n matrix placed row-wise into the 1D array), \n1D to 2D index transformation:\n\n`[i]  =>  [i / n][i % n]`\n\n\nBonus:\nIf the matrix is sorted column-wise,  an so we imagine placing the matrix as 'column-wise' blocks into the 1D array, then,\n1D to 2D index transformation:\n`[i]  =>  [i % m][i / m]`\n\n2D to 1D (row-wise) transformation:\n`[i][j] => [i * n + j]`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Good solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "When I originally did this problem, I did a binary search of the start of each row to locate the row then did a binary search of the row itself to find the target. O(log M + log N). This method works because the start of each row is greater than the end of the previous row.\nThen I noticed that if the TR corner of the matrix was greater than the target then you could eliminate the entire RH column. Similarly, if the TR corner of the matrix is less than the target then you can eliminate the entire top row. So you can just walk down the matrix until you either hit the target or fall off the matrix.\nThis has a O(M + N) run time which is not as good as the binary search method but is useful to know if you want to tackle ``240. Search a 2D Matrix II`` where a binary search to locate the row is not possible.\n"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-a-2d-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "chrisrao",
                        "content": "I think this would be more clear if it said \"ascending order\" rather than \"non-decreasing order\". I spent some time looking at the matrices wondering if there was some trick before deciding to implement a binary search. "
                    },
                    {
                        "username": "shaw-code",
                        "content": "\"Ascending order\" and \"Non decreasing order\" are two different things.\\nAscending order contain only unique elements in sorted order. [1,2,3]\\nNon-decreasing order contain repeated elements in sorted order. [1,1,2,3]\\n\\nSame goes for Descending order and Non-increasing order."
                    },
                    {
                        "username": "viyengar",
                        "content": "Non-decreasing order is a more precise description for the problem. \\nex: [1, 2, 2, 3, 4] is NOT technically ascending order, but is a valid input for a row in the matrix."
                    },
                    {
                        "username": "adrians99",
                        "content": "Useful tests to check extreme cases\\n\\n`matrix = [[1],[3],[5]] target = 3`\\n`matrix = [[1, 3]] target = 3`\\n`matrix = [[1, 3]] target = 2`\\n`matrix = [[1]] target = 1`"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "It would be great if leetcode had a  time and memory complexity analyzer of the code. My solution is log(m * n), but seems that test cases is small enough that linear time algorithm can beat it))."
                    },
                    {
                        "username": "user2049D",
                        "content": "You are right. Sometimes, O(m + n) code is faster than the O(log(m * n)) one !"
                    },
                    {
                        "username": "code_24x7",
                        "content": "Solved it in O(log(m)*log(n)).\n1. First binary search the rows to the get the target row.\n2. Next binary search the target_row to search the element.\n\nHow does it compare to O(log(m*n)), How must i do the math for that. Can someone help?\n\n `class Solution:\n    def get_target_row(self, matrix, target):\n        start = 0\n        end = len(matrix)-1\n        col = len(matrix[0])-1\n        while start <= end:\n            mid = start + (end-start)//2\n            if target >= matrix[mid][0] and target <= matrix[mid][col]:\n                return mid\n            elif target < matrix[mid][0]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return -1\n\n    def binary_search(self, array, target):\n        start = 0\n        end = len(array)\n        while start <= end:\n            mid = start + (end-start)//2\n            if target == array[mid]:\n                return True\n            elif target < array[mid]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return False\n\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        row = len(matrix)\n        col = len(matrix[0])-1\n        target_row = self.get_target_row(matrix, target)\n        if target_row == -1:\n            return False\n        return self.binary_search(matrix[target_row], target)`\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The run time is O(log(m) + log(n)) which is the same as O(log(m*n))."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i try but it fail on \\ngiven test case \\nthis test case from GFG;\\n\\n\\n9            7\\n1 2 2 2 3 5 7 9 10 13 15 15 16 19 19 21 21 23 23 26 26 27 29 29 31 31 33 34 35 35 35 36 36 36 37 38 40 41 44 45 45 48 48 51 52 53 53 57 57 58 59 59 59 61 63 64 65 67 68 69 70 70 70\\n31"
                    },
                    {
                        "username": "therishuraj",
                        "content": "Its an invalid testcase,\\nwill throw an error as \"The first integer of each row is greater than the last integer of the previous row.\"\\nas matrix[2][0] not greater then matrix[1][6];\\nso matrix[2][0] can be taken as 24.\\ncorrect input can be :-\\n9 * 7\\n[[1, 2, 2, 2, 3, 5, 7, 9, 10],[13, 15, 15, 16, 19, 19, 21, 21, 23],[24, 26, 26, 27, 29, 29, 31, 31, 33],[34, 35, 35, 35, 36, 36, 36, 37, 38], [40, 41, 44, 45, 45, 48, 48, 51, 52], [53, 53, 57, 57, 58, 59, 59, 59, 61], [63, 64, 65, 67, 68, 69, 70, 70, 70]]\\ntarget = 31\\nwill give proper result on applying binary search correctly."
                    },
                    {
                        "username": "TimPC",
                        "content": "This test case has long rows and a big jump where the second row  first entry is less than the target. To pass it successfully you have to do binary search on the first row and then skip the second row entirely because the first entry is too large."
                    },
                    {
                        "username": "voidptr",
                        "content": "Hi \\n\\nI am just trying to understand what is the difference between this problem and :\\nhttps://leetcode.com/problems/search-a-2d-matrix-ii/description/\\n\\nI feel they are identical."
                    },
                    {
                        "username": "psionl0",
                        "content": "In problem 240 you can\\'t use a binary search to locate the row so a linear run time is the best that you will get."
                    },
                    {
                        "username": "mochiball",
                        "content": "Different. This one everything is sorted . The other one the rows are sorted and columns are sorted BUT the last value in the row might not be smaller than the first value in the next row   "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "I agree with previous answers, also this problem asking to solve it with O(log(m*n))"
                    },
                    {
                        "username": "mkohar",
                        "content": "No they are not. \\nCondition **\"The first integer of each row is greater than the last integer of the previous row.\"** is true for this (#74) question, but not for the one in link(240)"
                    },
                    {
                        "username": "zephyr8",
                        "content": "[@Random Ptr](/voidptr)  - the problems are not identical.  If we were to write this matrix out as an array - it will be totally sorted. That\\'s not guaranteed for the other problem. "
                    },
                    {
                        "username": "zhangben",
                        "content": "what if change the condition like this:\\nIntegers in each row are sorted from left to right.\\nIntegers in each column are sorted from up to down.\\nhow should we solve this problem?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "you need to realize that its same as what we have now\\n "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "it is the same condition we have in the description"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can this even be solved in Log(m+n) ?"
                    }
                ]
            },
            {
                "id": 2004671,
                "content": [
                    {
                        "username": "mbed",
                        "content": "Imagine (rather actually draw it out) how a 2D array (m * n matrix) would be placed 'row-wise' into a 1D array - \neach row from a 2D array is placed as successive blocks of rows starting from row 0 to row m - 1 (of the 2D array);\n\n(Note that here the array could be placed 'column-wise' (opportunity to trick someone) into the 1D array and below translation of\nindices may not work as-is; hence how the 2D array is placed into the 1D array is important to know/imagine)\n\nGiven 'row-wise' placement, the 1D array now consists of 'blocks' of m rows and each 'block' contains column (n) number of elements; \n\nTake a 3x4 Matix placed row-wise into a 1D array as an example -\n\n`1D-Index:   | 0 1 2 3 | 4 5 6 7 | 8  9   10 11 |`\n`Elements:   | 1 2 3 4 | 5 6 7 8 | 8 10 11 12 |`\n\nTo find out the 2D Row index from a 1D array index, is equal to telling which row-block does this index belong to;\n\nwhich is = 1D index / # elements in the row-block\nwhich is = 1D index / # columns\n\ne.g.\nif 1D index is 7;\n       2D Row index = 7 / #columns\n\t                = 7 / 4\n\t\t\t\t\t= 1\n\t\t\t\t\t\nNow onto column index,\n\nIf you look at above example, column index is just an offest inside a given row-block.\nWhile this seems less intuitive to derive, the remainder of the division operation we performed above\nto get the row index gives you the offset in that row, which turns out to be the column index.\n\nSo 2D Col Index =  Remainder of (1D-Index / #columns)\n                          =  (1D-index % #columns)\n\n\ne.g.\nif 1D index is 7;\n2D Col index = 7 % 4\n\t                = 3\n\t\t\t\n\t\t\t\nGiving us (for a 1D array index 'i' and an m * n matrix placed row-wise into the 1D array), \n1D to 2D index transformation:\n\n`[i]  =>  [i / n][i % n]`\n\n\nBonus:\nIf the matrix is sorted column-wise,  an so we imagine placing the matrix as 'column-wise' blocks into the 1D array, then,\n1D to 2D index transformation:\n`[i]  =>  [i % m][i / m]`\n\n2D to 1D (row-wise) transformation:\n`[i][j] => [i * n + j]`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Good solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "When I originally did this problem, I did a binary search of the start of each row to locate the row then did a binary search of the row itself to find the target. O(log M + log N). This method works because the start of each row is greater than the end of the previous row.\nThen I noticed that if the TR corner of the matrix was greater than the target then you could eliminate the entire RH column. Similarly, if the TR corner of the matrix is less than the target then you can eliminate the entire top row. So you can just walk down the matrix until you either hit the target or fall off the matrix.\nThis has a O(M + N) run time which is not as good as the binary search method but is useful to know if you want to tackle ``240. Search a 2D Matrix II`` where a binary search to locate the row is not possible.\n"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-a-2d-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "chrisrao",
                        "content": "I think this would be more clear if it said \"ascending order\" rather than \"non-decreasing order\". I spent some time looking at the matrices wondering if there was some trick before deciding to implement a binary search. "
                    },
                    {
                        "username": "shaw-code",
                        "content": "\"Ascending order\" and \"Non decreasing order\" are two different things.\\nAscending order contain only unique elements in sorted order. [1,2,3]\\nNon-decreasing order contain repeated elements in sorted order. [1,1,2,3]\\n\\nSame goes for Descending order and Non-increasing order."
                    },
                    {
                        "username": "viyengar",
                        "content": "Non-decreasing order is a more precise description for the problem. \\nex: [1, 2, 2, 3, 4] is NOT technically ascending order, but is a valid input for a row in the matrix."
                    },
                    {
                        "username": "adrians99",
                        "content": "Useful tests to check extreme cases\\n\\n`matrix = [[1],[3],[5]] target = 3`\\n`matrix = [[1, 3]] target = 3`\\n`matrix = [[1, 3]] target = 2`\\n`matrix = [[1]] target = 1`"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "It would be great if leetcode had a  time and memory complexity analyzer of the code. My solution is log(m * n), but seems that test cases is small enough that linear time algorithm can beat it))."
                    },
                    {
                        "username": "user2049D",
                        "content": "You are right. Sometimes, O(m + n) code is faster than the O(log(m * n)) one !"
                    },
                    {
                        "username": "code_24x7",
                        "content": "Solved it in O(log(m)*log(n)).\n1. First binary search the rows to the get the target row.\n2. Next binary search the target_row to search the element.\n\nHow does it compare to O(log(m*n)), How must i do the math for that. Can someone help?\n\n `class Solution:\n    def get_target_row(self, matrix, target):\n        start = 0\n        end = len(matrix)-1\n        col = len(matrix[0])-1\n        while start <= end:\n            mid = start + (end-start)//2\n            if target >= matrix[mid][0] and target <= matrix[mid][col]:\n                return mid\n            elif target < matrix[mid][0]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return -1\n\n    def binary_search(self, array, target):\n        start = 0\n        end = len(array)\n        while start <= end:\n            mid = start + (end-start)//2\n            if target == array[mid]:\n                return True\n            elif target < array[mid]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return False\n\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        row = len(matrix)\n        col = len(matrix[0])-1\n        target_row = self.get_target_row(matrix, target)\n        if target_row == -1:\n            return False\n        return self.binary_search(matrix[target_row], target)`\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The run time is O(log(m) + log(n)) which is the same as O(log(m*n))."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i try but it fail on \\ngiven test case \\nthis test case from GFG;\\n\\n\\n9            7\\n1 2 2 2 3 5 7 9 10 13 15 15 16 19 19 21 21 23 23 26 26 27 29 29 31 31 33 34 35 35 35 36 36 36 37 38 40 41 44 45 45 48 48 51 52 53 53 57 57 58 59 59 59 61 63 64 65 67 68 69 70 70 70\\n31"
                    },
                    {
                        "username": "therishuraj",
                        "content": "Its an invalid testcase,\\nwill throw an error as \"The first integer of each row is greater than the last integer of the previous row.\"\\nas matrix[2][0] not greater then matrix[1][6];\\nso matrix[2][0] can be taken as 24.\\ncorrect input can be :-\\n9 * 7\\n[[1, 2, 2, 2, 3, 5, 7, 9, 10],[13, 15, 15, 16, 19, 19, 21, 21, 23],[24, 26, 26, 27, 29, 29, 31, 31, 33],[34, 35, 35, 35, 36, 36, 36, 37, 38], [40, 41, 44, 45, 45, 48, 48, 51, 52], [53, 53, 57, 57, 58, 59, 59, 59, 61], [63, 64, 65, 67, 68, 69, 70, 70, 70]]\\ntarget = 31\\nwill give proper result on applying binary search correctly."
                    },
                    {
                        "username": "TimPC",
                        "content": "This test case has long rows and a big jump where the second row  first entry is less than the target. To pass it successfully you have to do binary search on the first row and then skip the second row entirely because the first entry is too large."
                    },
                    {
                        "username": "voidptr",
                        "content": "Hi \\n\\nI am just trying to understand what is the difference between this problem and :\\nhttps://leetcode.com/problems/search-a-2d-matrix-ii/description/\\n\\nI feel they are identical."
                    },
                    {
                        "username": "psionl0",
                        "content": "In problem 240 you can\\'t use a binary search to locate the row so a linear run time is the best that you will get."
                    },
                    {
                        "username": "mochiball",
                        "content": "Different. This one everything is sorted . The other one the rows are sorted and columns are sorted BUT the last value in the row might not be smaller than the first value in the next row   "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "I agree with previous answers, also this problem asking to solve it with O(log(m*n))"
                    },
                    {
                        "username": "mkohar",
                        "content": "No they are not. \\nCondition **\"The first integer of each row is greater than the last integer of the previous row.\"** is true for this (#74) question, but not for the one in link(240)"
                    },
                    {
                        "username": "zephyr8",
                        "content": "[@Random Ptr](/voidptr)  - the problems are not identical.  If we were to write this matrix out as an array - it will be totally sorted. That\\'s not guaranteed for the other problem. "
                    },
                    {
                        "username": "zhangben",
                        "content": "what if change the condition like this:\\nIntegers in each row are sorted from left to right.\\nIntegers in each column are sorted from up to down.\\nhow should we solve this problem?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "you need to realize that its same as what we have now\\n "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "it is the same condition we have in the description"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can this even be solved in Log(m+n) ?"
                    }
                ]
            },
            {
                "id": 1930051,
                "content": [
                    {
                        "username": "mbed",
                        "content": "Imagine (rather actually draw it out) how a 2D array (m * n matrix) would be placed 'row-wise' into a 1D array - \neach row from a 2D array is placed as successive blocks of rows starting from row 0 to row m - 1 (of the 2D array);\n\n(Note that here the array could be placed 'column-wise' (opportunity to trick someone) into the 1D array and below translation of\nindices may not work as-is; hence how the 2D array is placed into the 1D array is important to know/imagine)\n\nGiven 'row-wise' placement, the 1D array now consists of 'blocks' of m rows and each 'block' contains column (n) number of elements; \n\nTake a 3x4 Matix placed row-wise into a 1D array as an example -\n\n`1D-Index:   | 0 1 2 3 | 4 5 6 7 | 8  9   10 11 |`\n`Elements:   | 1 2 3 4 | 5 6 7 8 | 8 10 11 12 |`\n\nTo find out the 2D Row index from a 1D array index, is equal to telling which row-block does this index belong to;\n\nwhich is = 1D index / # elements in the row-block\nwhich is = 1D index / # columns\n\ne.g.\nif 1D index is 7;\n       2D Row index = 7 / #columns\n\t                = 7 / 4\n\t\t\t\t\t= 1\n\t\t\t\t\t\nNow onto column index,\n\nIf you look at above example, column index is just an offest inside a given row-block.\nWhile this seems less intuitive to derive, the remainder of the division operation we performed above\nto get the row index gives you the offset in that row, which turns out to be the column index.\n\nSo 2D Col Index =  Remainder of (1D-Index / #columns)\n                          =  (1D-index % #columns)\n\n\ne.g.\nif 1D index is 7;\n2D Col index = 7 % 4\n\t                = 3\n\t\t\t\n\t\t\t\nGiving us (for a 1D array index 'i' and an m * n matrix placed row-wise into the 1D array), \n1D to 2D index transformation:\n\n`[i]  =>  [i / n][i % n]`\n\n\nBonus:\nIf the matrix is sorted column-wise,  an so we imagine placing the matrix as 'column-wise' blocks into the 1D array, then,\n1D to 2D index transformation:\n`[i]  =>  [i % m][i / m]`\n\n2D to 1D (row-wise) transformation:\n`[i][j] => [i * n + j]`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Good solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "When I originally did this problem, I did a binary search of the start of each row to locate the row then did a binary search of the row itself to find the target. O(log M + log N). This method works because the start of each row is greater than the end of the previous row.\nThen I noticed that if the TR corner of the matrix was greater than the target then you could eliminate the entire RH column. Similarly, if the TR corner of the matrix is less than the target then you can eliminate the entire top row. So you can just walk down the matrix until you either hit the target or fall off the matrix.\nThis has a O(M + N) run time which is not as good as the binary search method but is useful to know if you want to tackle ``240. Search a 2D Matrix II`` where a binary search to locate the row is not possible.\n"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-a-2d-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "chrisrao",
                        "content": "I think this would be more clear if it said \"ascending order\" rather than \"non-decreasing order\". I spent some time looking at the matrices wondering if there was some trick before deciding to implement a binary search. "
                    },
                    {
                        "username": "shaw-code",
                        "content": "\"Ascending order\" and \"Non decreasing order\" are two different things.\\nAscending order contain only unique elements in sorted order. [1,2,3]\\nNon-decreasing order contain repeated elements in sorted order. [1,1,2,3]\\n\\nSame goes for Descending order and Non-increasing order."
                    },
                    {
                        "username": "viyengar",
                        "content": "Non-decreasing order is a more precise description for the problem. \\nex: [1, 2, 2, 3, 4] is NOT technically ascending order, but is a valid input for a row in the matrix."
                    },
                    {
                        "username": "adrians99",
                        "content": "Useful tests to check extreme cases\\n\\n`matrix = [[1],[3],[5]] target = 3`\\n`matrix = [[1, 3]] target = 3`\\n`matrix = [[1, 3]] target = 2`\\n`matrix = [[1]] target = 1`"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "It would be great if leetcode had a  time and memory complexity analyzer of the code. My solution is log(m * n), but seems that test cases is small enough that linear time algorithm can beat it))."
                    },
                    {
                        "username": "user2049D",
                        "content": "You are right. Sometimes, O(m + n) code is faster than the O(log(m * n)) one !"
                    },
                    {
                        "username": "code_24x7",
                        "content": "Solved it in O(log(m)*log(n)).\n1. First binary search the rows to the get the target row.\n2. Next binary search the target_row to search the element.\n\nHow does it compare to O(log(m*n)), How must i do the math for that. Can someone help?\n\n `class Solution:\n    def get_target_row(self, matrix, target):\n        start = 0\n        end = len(matrix)-1\n        col = len(matrix[0])-1\n        while start <= end:\n            mid = start + (end-start)//2\n            if target >= matrix[mid][0] and target <= matrix[mid][col]:\n                return mid\n            elif target < matrix[mid][0]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return -1\n\n    def binary_search(self, array, target):\n        start = 0\n        end = len(array)\n        while start <= end:\n            mid = start + (end-start)//2\n            if target == array[mid]:\n                return True\n            elif target < array[mid]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return False\n\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        row = len(matrix)\n        col = len(matrix[0])-1\n        target_row = self.get_target_row(matrix, target)\n        if target_row == -1:\n            return False\n        return self.binary_search(matrix[target_row], target)`\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The run time is O(log(m) + log(n)) which is the same as O(log(m*n))."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i try but it fail on \\ngiven test case \\nthis test case from GFG;\\n\\n\\n9            7\\n1 2 2 2 3 5 7 9 10 13 15 15 16 19 19 21 21 23 23 26 26 27 29 29 31 31 33 34 35 35 35 36 36 36 37 38 40 41 44 45 45 48 48 51 52 53 53 57 57 58 59 59 59 61 63 64 65 67 68 69 70 70 70\\n31"
                    },
                    {
                        "username": "therishuraj",
                        "content": "Its an invalid testcase,\\nwill throw an error as \"The first integer of each row is greater than the last integer of the previous row.\"\\nas matrix[2][0] not greater then matrix[1][6];\\nso matrix[2][0] can be taken as 24.\\ncorrect input can be :-\\n9 * 7\\n[[1, 2, 2, 2, 3, 5, 7, 9, 10],[13, 15, 15, 16, 19, 19, 21, 21, 23],[24, 26, 26, 27, 29, 29, 31, 31, 33],[34, 35, 35, 35, 36, 36, 36, 37, 38], [40, 41, 44, 45, 45, 48, 48, 51, 52], [53, 53, 57, 57, 58, 59, 59, 59, 61], [63, 64, 65, 67, 68, 69, 70, 70, 70]]\\ntarget = 31\\nwill give proper result on applying binary search correctly."
                    },
                    {
                        "username": "TimPC",
                        "content": "This test case has long rows and a big jump where the second row  first entry is less than the target. To pass it successfully you have to do binary search on the first row and then skip the second row entirely because the first entry is too large."
                    },
                    {
                        "username": "voidptr",
                        "content": "Hi \\n\\nI am just trying to understand what is the difference between this problem and :\\nhttps://leetcode.com/problems/search-a-2d-matrix-ii/description/\\n\\nI feel they are identical."
                    },
                    {
                        "username": "psionl0",
                        "content": "In problem 240 you can\\'t use a binary search to locate the row so a linear run time is the best that you will get."
                    },
                    {
                        "username": "mochiball",
                        "content": "Different. This one everything is sorted . The other one the rows are sorted and columns are sorted BUT the last value in the row might not be smaller than the first value in the next row   "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "I agree with previous answers, also this problem asking to solve it with O(log(m*n))"
                    },
                    {
                        "username": "mkohar",
                        "content": "No they are not. \\nCondition **\"The first integer of each row is greater than the last integer of the previous row.\"** is true for this (#74) question, but not for the one in link(240)"
                    },
                    {
                        "username": "zephyr8",
                        "content": "[@Random Ptr](/voidptr)  - the problems are not identical.  If we were to write this matrix out as an array - it will be totally sorted. That\\'s not guaranteed for the other problem. "
                    },
                    {
                        "username": "zhangben",
                        "content": "what if change the condition like this:\\nIntegers in each row are sorted from left to right.\\nIntegers in each column are sorted from up to down.\\nhow should we solve this problem?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "you need to realize that its same as what we have now\\n "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "it is the same condition we have in the description"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can this even be solved in Log(m+n) ?"
                    }
                ]
            },
            {
                "id": 1851245,
                "content": [
                    {
                        "username": "mbed",
                        "content": "Imagine (rather actually draw it out) how a 2D array (m * n matrix) would be placed 'row-wise' into a 1D array - \neach row from a 2D array is placed as successive blocks of rows starting from row 0 to row m - 1 (of the 2D array);\n\n(Note that here the array could be placed 'column-wise' (opportunity to trick someone) into the 1D array and below translation of\nindices may not work as-is; hence how the 2D array is placed into the 1D array is important to know/imagine)\n\nGiven 'row-wise' placement, the 1D array now consists of 'blocks' of m rows and each 'block' contains column (n) number of elements; \n\nTake a 3x4 Matix placed row-wise into a 1D array as an example -\n\n`1D-Index:   | 0 1 2 3 | 4 5 6 7 | 8  9   10 11 |`\n`Elements:   | 1 2 3 4 | 5 6 7 8 | 8 10 11 12 |`\n\nTo find out the 2D Row index from a 1D array index, is equal to telling which row-block does this index belong to;\n\nwhich is = 1D index / # elements in the row-block\nwhich is = 1D index / # columns\n\ne.g.\nif 1D index is 7;\n       2D Row index = 7 / #columns\n\t                = 7 / 4\n\t\t\t\t\t= 1\n\t\t\t\t\t\nNow onto column index,\n\nIf you look at above example, column index is just an offest inside a given row-block.\nWhile this seems less intuitive to derive, the remainder of the division operation we performed above\nto get the row index gives you the offset in that row, which turns out to be the column index.\n\nSo 2D Col Index =  Remainder of (1D-Index / #columns)\n                          =  (1D-index % #columns)\n\n\ne.g.\nif 1D index is 7;\n2D Col index = 7 % 4\n\t                = 3\n\t\t\t\n\t\t\t\nGiving us (for a 1D array index 'i' and an m * n matrix placed row-wise into the 1D array), \n1D to 2D index transformation:\n\n`[i]  =>  [i / n][i % n]`\n\n\nBonus:\nIf the matrix is sorted column-wise,  an so we imagine placing the matrix as 'column-wise' blocks into the 1D array, then,\n1D to 2D index transformation:\n`[i]  =>  [i % m][i / m]`\n\n2D to 1D (row-wise) transformation:\n`[i][j] => [i * n + j]`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Good solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "When I originally did this problem, I did a binary search of the start of each row to locate the row then did a binary search of the row itself to find the target. O(log M + log N). This method works because the start of each row is greater than the end of the previous row.\nThen I noticed that if the TR corner of the matrix was greater than the target then you could eliminate the entire RH column. Similarly, if the TR corner of the matrix is less than the target then you can eliminate the entire top row. So you can just walk down the matrix until you either hit the target or fall off the matrix.\nThis has a O(M + N) run time which is not as good as the binary search method but is useful to know if you want to tackle ``240. Search a 2D Matrix II`` where a binary search to locate the row is not possible.\n"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-a-2d-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "chrisrao",
                        "content": "I think this would be more clear if it said \"ascending order\" rather than \"non-decreasing order\". I spent some time looking at the matrices wondering if there was some trick before deciding to implement a binary search. "
                    },
                    {
                        "username": "shaw-code",
                        "content": "\"Ascending order\" and \"Non decreasing order\" are two different things.\\nAscending order contain only unique elements in sorted order. [1,2,3]\\nNon-decreasing order contain repeated elements in sorted order. [1,1,2,3]\\n\\nSame goes for Descending order and Non-increasing order."
                    },
                    {
                        "username": "viyengar",
                        "content": "Non-decreasing order is a more precise description for the problem. \\nex: [1, 2, 2, 3, 4] is NOT technically ascending order, but is a valid input for a row in the matrix."
                    },
                    {
                        "username": "adrians99",
                        "content": "Useful tests to check extreme cases\\n\\n`matrix = [[1],[3],[5]] target = 3`\\n`matrix = [[1, 3]] target = 3`\\n`matrix = [[1, 3]] target = 2`\\n`matrix = [[1]] target = 1`"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "It would be great if leetcode had a  time and memory complexity analyzer of the code. My solution is log(m * n), but seems that test cases is small enough that linear time algorithm can beat it))."
                    },
                    {
                        "username": "user2049D",
                        "content": "You are right. Sometimes, O(m + n) code is faster than the O(log(m * n)) one !"
                    },
                    {
                        "username": "code_24x7",
                        "content": "Solved it in O(log(m)*log(n)).\n1. First binary search the rows to the get the target row.\n2. Next binary search the target_row to search the element.\n\nHow does it compare to O(log(m*n)), How must i do the math for that. Can someone help?\n\n `class Solution:\n    def get_target_row(self, matrix, target):\n        start = 0\n        end = len(matrix)-1\n        col = len(matrix[0])-1\n        while start <= end:\n            mid = start + (end-start)//2\n            if target >= matrix[mid][0] and target <= matrix[mid][col]:\n                return mid\n            elif target < matrix[mid][0]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return -1\n\n    def binary_search(self, array, target):\n        start = 0\n        end = len(array)\n        while start <= end:\n            mid = start + (end-start)//2\n            if target == array[mid]:\n                return True\n            elif target < array[mid]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return False\n\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        row = len(matrix)\n        col = len(matrix[0])-1\n        target_row = self.get_target_row(matrix, target)\n        if target_row == -1:\n            return False\n        return self.binary_search(matrix[target_row], target)`\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The run time is O(log(m) + log(n)) which is the same as O(log(m*n))."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i try but it fail on \\ngiven test case \\nthis test case from GFG;\\n\\n\\n9            7\\n1 2 2 2 3 5 7 9 10 13 15 15 16 19 19 21 21 23 23 26 26 27 29 29 31 31 33 34 35 35 35 36 36 36 37 38 40 41 44 45 45 48 48 51 52 53 53 57 57 58 59 59 59 61 63 64 65 67 68 69 70 70 70\\n31"
                    },
                    {
                        "username": "therishuraj",
                        "content": "Its an invalid testcase,\\nwill throw an error as \"The first integer of each row is greater than the last integer of the previous row.\"\\nas matrix[2][0] not greater then matrix[1][6];\\nso matrix[2][0] can be taken as 24.\\ncorrect input can be :-\\n9 * 7\\n[[1, 2, 2, 2, 3, 5, 7, 9, 10],[13, 15, 15, 16, 19, 19, 21, 21, 23],[24, 26, 26, 27, 29, 29, 31, 31, 33],[34, 35, 35, 35, 36, 36, 36, 37, 38], [40, 41, 44, 45, 45, 48, 48, 51, 52], [53, 53, 57, 57, 58, 59, 59, 59, 61], [63, 64, 65, 67, 68, 69, 70, 70, 70]]\\ntarget = 31\\nwill give proper result on applying binary search correctly."
                    },
                    {
                        "username": "TimPC",
                        "content": "This test case has long rows and a big jump where the second row  first entry is less than the target. To pass it successfully you have to do binary search on the first row and then skip the second row entirely because the first entry is too large."
                    },
                    {
                        "username": "voidptr",
                        "content": "Hi \\n\\nI am just trying to understand what is the difference between this problem and :\\nhttps://leetcode.com/problems/search-a-2d-matrix-ii/description/\\n\\nI feel they are identical."
                    },
                    {
                        "username": "psionl0",
                        "content": "In problem 240 you can\\'t use a binary search to locate the row so a linear run time is the best that you will get."
                    },
                    {
                        "username": "mochiball",
                        "content": "Different. This one everything is sorted . The other one the rows are sorted and columns are sorted BUT the last value in the row might not be smaller than the first value in the next row   "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "I agree with previous answers, also this problem asking to solve it with O(log(m*n))"
                    },
                    {
                        "username": "mkohar",
                        "content": "No they are not. \\nCondition **\"The first integer of each row is greater than the last integer of the previous row.\"** is true for this (#74) question, but not for the one in link(240)"
                    },
                    {
                        "username": "zephyr8",
                        "content": "[@Random Ptr](/voidptr)  - the problems are not identical.  If we were to write this matrix out as an array - it will be totally sorted. That\\'s not guaranteed for the other problem. "
                    },
                    {
                        "username": "zhangben",
                        "content": "what if change the condition like this:\\nIntegers in each row are sorted from left to right.\\nIntegers in each column are sorted from up to down.\\nhow should we solve this problem?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "you need to realize that its same as what we have now\\n "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "it is the same condition we have in the description"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can this even be solved in Log(m+n) ?"
                    }
                ]
            },
            {
                "id": 1689663,
                "content": [
                    {
                        "username": "mbed",
                        "content": "Imagine (rather actually draw it out) how a 2D array (m * n matrix) would be placed 'row-wise' into a 1D array - \neach row from a 2D array is placed as successive blocks of rows starting from row 0 to row m - 1 (of the 2D array);\n\n(Note that here the array could be placed 'column-wise' (opportunity to trick someone) into the 1D array and below translation of\nindices may not work as-is; hence how the 2D array is placed into the 1D array is important to know/imagine)\n\nGiven 'row-wise' placement, the 1D array now consists of 'blocks' of m rows and each 'block' contains column (n) number of elements; \n\nTake a 3x4 Matix placed row-wise into a 1D array as an example -\n\n`1D-Index:   | 0 1 2 3 | 4 5 6 7 | 8  9   10 11 |`\n`Elements:   | 1 2 3 4 | 5 6 7 8 | 8 10 11 12 |`\n\nTo find out the 2D Row index from a 1D array index, is equal to telling which row-block does this index belong to;\n\nwhich is = 1D index / # elements in the row-block\nwhich is = 1D index / # columns\n\ne.g.\nif 1D index is 7;\n       2D Row index = 7 / #columns\n\t                = 7 / 4\n\t\t\t\t\t= 1\n\t\t\t\t\t\nNow onto column index,\n\nIf you look at above example, column index is just an offest inside a given row-block.\nWhile this seems less intuitive to derive, the remainder of the division operation we performed above\nto get the row index gives you the offset in that row, which turns out to be the column index.\n\nSo 2D Col Index =  Remainder of (1D-Index / #columns)\n                          =  (1D-index % #columns)\n\n\ne.g.\nif 1D index is 7;\n2D Col index = 7 % 4\n\t                = 3\n\t\t\t\n\t\t\t\nGiving us (for a 1D array index 'i' and an m * n matrix placed row-wise into the 1D array), \n1D to 2D index transformation:\n\n`[i]  =>  [i / n][i % n]`\n\n\nBonus:\nIf the matrix is sorted column-wise,  an so we imagine placing the matrix as 'column-wise' blocks into the 1D array, then,\n1D to 2D index transformation:\n`[i]  =>  [i % m][i / m]`\n\n2D to 1D (row-wise) transformation:\n`[i][j] => [i * n + j]`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Good solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "When I originally did this problem, I did a binary search of the start of each row to locate the row then did a binary search of the row itself to find the target. O(log M + log N). This method works because the start of each row is greater than the end of the previous row.\nThen I noticed that if the TR corner of the matrix was greater than the target then you could eliminate the entire RH column. Similarly, if the TR corner of the matrix is less than the target then you can eliminate the entire top row. So you can just walk down the matrix until you either hit the target or fall off the matrix.\nThis has a O(M + N) run time which is not as good as the binary search method but is useful to know if you want to tackle ``240. Search a 2D Matrix II`` where a binary search to locate the row is not possible.\n"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-a-2d-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "chrisrao",
                        "content": "I think this would be more clear if it said \"ascending order\" rather than \"non-decreasing order\". I spent some time looking at the matrices wondering if there was some trick before deciding to implement a binary search. "
                    },
                    {
                        "username": "shaw-code",
                        "content": "\"Ascending order\" and \"Non decreasing order\" are two different things.\\nAscending order contain only unique elements in sorted order. [1,2,3]\\nNon-decreasing order contain repeated elements in sorted order. [1,1,2,3]\\n\\nSame goes for Descending order and Non-increasing order."
                    },
                    {
                        "username": "viyengar",
                        "content": "Non-decreasing order is a more precise description for the problem. \\nex: [1, 2, 2, 3, 4] is NOT technically ascending order, but is a valid input for a row in the matrix."
                    },
                    {
                        "username": "adrians99",
                        "content": "Useful tests to check extreme cases\\n\\n`matrix = [[1],[3],[5]] target = 3`\\n`matrix = [[1, 3]] target = 3`\\n`matrix = [[1, 3]] target = 2`\\n`matrix = [[1]] target = 1`"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "It would be great if leetcode had a  time and memory complexity analyzer of the code. My solution is log(m * n), but seems that test cases is small enough that linear time algorithm can beat it))."
                    },
                    {
                        "username": "user2049D",
                        "content": "You are right. Sometimes, O(m + n) code is faster than the O(log(m * n)) one !"
                    },
                    {
                        "username": "code_24x7",
                        "content": "Solved it in O(log(m)*log(n)).\n1. First binary search the rows to the get the target row.\n2. Next binary search the target_row to search the element.\n\nHow does it compare to O(log(m*n)), How must i do the math for that. Can someone help?\n\n `class Solution:\n    def get_target_row(self, matrix, target):\n        start = 0\n        end = len(matrix)-1\n        col = len(matrix[0])-1\n        while start <= end:\n            mid = start + (end-start)//2\n            if target >= matrix[mid][0] and target <= matrix[mid][col]:\n                return mid\n            elif target < matrix[mid][0]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return -1\n\n    def binary_search(self, array, target):\n        start = 0\n        end = len(array)\n        while start <= end:\n            mid = start + (end-start)//2\n            if target == array[mid]:\n                return True\n            elif target < array[mid]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return False\n\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        row = len(matrix)\n        col = len(matrix[0])-1\n        target_row = self.get_target_row(matrix, target)\n        if target_row == -1:\n            return False\n        return self.binary_search(matrix[target_row], target)`\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The run time is O(log(m) + log(n)) which is the same as O(log(m*n))."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i try but it fail on \\ngiven test case \\nthis test case from GFG;\\n\\n\\n9            7\\n1 2 2 2 3 5 7 9 10 13 15 15 16 19 19 21 21 23 23 26 26 27 29 29 31 31 33 34 35 35 35 36 36 36 37 38 40 41 44 45 45 48 48 51 52 53 53 57 57 58 59 59 59 61 63 64 65 67 68 69 70 70 70\\n31"
                    },
                    {
                        "username": "therishuraj",
                        "content": "Its an invalid testcase,\\nwill throw an error as \"The first integer of each row is greater than the last integer of the previous row.\"\\nas matrix[2][0] not greater then matrix[1][6];\\nso matrix[2][0] can be taken as 24.\\ncorrect input can be :-\\n9 * 7\\n[[1, 2, 2, 2, 3, 5, 7, 9, 10],[13, 15, 15, 16, 19, 19, 21, 21, 23],[24, 26, 26, 27, 29, 29, 31, 31, 33],[34, 35, 35, 35, 36, 36, 36, 37, 38], [40, 41, 44, 45, 45, 48, 48, 51, 52], [53, 53, 57, 57, 58, 59, 59, 59, 61], [63, 64, 65, 67, 68, 69, 70, 70, 70]]\\ntarget = 31\\nwill give proper result on applying binary search correctly."
                    },
                    {
                        "username": "TimPC",
                        "content": "This test case has long rows and a big jump where the second row  first entry is less than the target. To pass it successfully you have to do binary search on the first row and then skip the second row entirely because the first entry is too large."
                    },
                    {
                        "username": "voidptr",
                        "content": "Hi \\n\\nI am just trying to understand what is the difference between this problem and :\\nhttps://leetcode.com/problems/search-a-2d-matrix-ii/description/\\n\\nI feel they are identical."
                    },
                    {
                        "username": "psionl0",
                        "content": "In problem 240 you can\\'t use a binary search to locate the row so a linear run time is the best that you will get."
                    },
                    {
                        "username": "mochiball",
                        "content": "Different. This one everything is sorted . The other one the rows are sorted and columns are sorted BUT the last value in the row might not be smaller than the first value in the next row   "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "I agree with previous answers, also this problem asking to solve it with O(log(m*n))"
                    },
                    {
                        "username": "mkohar",
                        "content": "No they are not. \\nCondition **\"The first integer of each row is greater than the last integer of the previous row.\"** is true for this (#74) question, but not for the one in link(240)"
                    },
                    {
                        "username": "zephyr8",
                        "content": "[@Random Ptr](/voidptr)  - the problems are not identical.  If we were to write this matrix out as an array - it will be totally sorted. That\\'s not guaranteed for the other problem. "
                    },
                    {
                        "username": "zhangben",
                        "content": "what if change the condition like this:\\nIntegers in each row are sorted from left to right.\\nIntegers in each column are sorted from up to down.\\nhow should we solve this problem?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "you need to realize that its same as what we have now\\n "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "it is the same condition we have in the description"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can this even be solved in Log(m+n) ?"
                    }
                ]
            },
            {
                "id": 1571171,
                "content": [
                    {
                        "username": "mbed",
                        "content": "Imagine (rather actually draw it out) how a 2D array (m * n matrix) would be placed 'row-wise' into a 1D array - \neach row from a 2D array is placed as successive blocks of rows starting from row 0 to row m - 1 (of the 2D array);\n\n(Note that here the array could be placed 'column-wise' (opportunity to trick someone) into the 1D array and below translation of\nindices may not work as-is; hence how the 2D array is placed into the 1D array is important to know/imagine)\n\nGiven 'row-wise' placement, the 1D array now consists of 'blocks' of m rows and each 'block' contains column (n) number of elements; \n\nTake a 3x4 Matix placed row-wise into a 1D array as an example -\n\n`1D-Index:   | 0 1 2 3 | 4 5 6 7 | 8  9   10 11 |`\n`Elements:   | 1 2 3 4 | 5 6 7 8 | 8 10 11 12 |`\n\nTo find out the 2D Row index from a 1D array index, is equal to telling which row-block does this index belong to;\n\nwhich is = 1D index / # elements in the row-block\nwhich is = 1D index / # columns\n\ne.g.\nif 1D index is 7;\n       2D Row index = 7 / #columns\n\t                = 7 / 4\n\t\t\t\t\t= 1\n\t\t\t\t\t\nNow onto column index,\n\nIf you look at above example, column index is just an offest inside a given row-block.\nWhile this seems less intuitive to derive, the remainder of the division operation we performed above\nto get the row index gives you the offset in that row, which turns out to be the column index.\n\nSo 2D Col Index =  Remainder of (1D-Index / #columns)\n                          =  (1D-index % #columns)\n\n\ne.g.\nif 1D index is 7;\n2D Col index = 7 % 4\n\t                = 3\n\t\t\t\n\t\t\t\nGiving us (for a 1D array index 'i' and an m * n matrix placed row-wise into the 1D array), \n1D to 2D index transformation:\n\n`[i]  =>  [i / n][i % n]`\n\n\nBonus:\nIf the matrix is sorted column-wise,  an so we imagine placing the matrix as 'column-wise' blocks into the 1D array, then,\n1D to 2D index transformation:\n`[i]  =>  [i % m][i / m]`\n\n2D to 1D (row-wise) transformation:\n`[i][j] => [i * n + j]`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Good solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "When I originally did this problem, I did a binary search of the start of each row to locate the row then did a binary search of the row itself to find the target. O(log M + log N). This method works because the start of each row is greater than the end of the previous row.\nThen I noticed that if the TR corner of the matrix was greater than the target then you could eliminate the entire RH column. Similarly, if the TR corner of the matrix is less than the target then you can eliminate the entire top row. So you can just walk down the matrix until you either hit the target or fall off the matrix.\nThis has a O(M + N) run time which is not as good as the binary search method but is useful to know if you want to tackle ``240. Search a 2D Matrix II`` where a binary search to locate the row is not possible.\n"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-a-2d-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "chrisrao",
                        "content": "I think this would be more clear if it said \"ascending order\" rather than \"non-decreasing order\". I spent some time looking at the matrices wondering if there was some trick before deciding to implement a binary search. "
                    },
                    {
                        "username": "shaw-code",
                        "content": "\"Ascending order\" and \"Non decreasing order\" are two different things.\\nAscending order contain only unique elements in sorted order. [1,2,3]\\nNon-decreasing order contain repeated elements in sorted order. [1,1,2,3]\\n\\nSame goes for Descending order and Non-increasing order."
                    },
                    {
                        "username": "viyengar",
                        "content": "Non-decreasing order is a more precise description for the problem. \\nex: [1, 2, 2, 3, 4] is NOT technically ascending order, but is a valid input for a row in the matrix."
                    },
                    {
                        "username": "adrians99",
                        "content": "Useful tests to check extreme cases\\n\\n`matrix = [[1],[3],[5]] target = 3`\\n`matrix = [[1, 3]] target = 3`\\n`matrix = [[1, 3]] target = 2`\\n`matrix = [[1]] target = 1`"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "It would be great if leetcode had a  time and memory complexity analyzer of the code. My solution is log(m * n), but seems that test cases is small enough that linear time algorithm can beat it))."
                    },
                    {
                        "username": "user2049D",
                        "content": "You are right. Sometimes, O(m + n) code is faster than the O(log(m * n)) one !"
                    },
                    {
                        "username": "code_24x7",
                        "content": "Solved it in O(log(m)*log(n)).\n1. First binary search the rows to the get the target row.\n2. Next binary search the target_row to search the element.\n\nHow does it compare to O(log(m*n)), How must i do the math for that. Can someone help?\n\n `class Solution:\n    def get_target_row(self, matrix, target):\n        start = 0\n        end = len(matrix)-1\n        col = len(matrix[0])-1\n        while start <= end:\n            mid = start + (end-start)//2\n            if target >= matrix[mid][0] and target <= matrix[mid][col]:\n                return mid\n            elif target < matrix[mid][0]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return -1\n\n    def binary_search(self, array, target):\n        start = 0\n        end = len(array)\n        while start <= end:\n            mid = start + (end-start)//2\n            if target == array[mid]:\n                return True\n            elif target < array[mid]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return False\n\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        row = len(matrix)\n        col = len(matrix[0])-1\n        target_row = self.get_target_row(matrix, target)\n        if target_row == -1:\n            return False\n        return self.binary_search(matrix[target_row], target)`\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The run time is O(log(m) + log(n)) which is the same as O(log(m*n))."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i try but it fail on \\ngiven test case \\nthis test case from GFG;\\n\\n\\n9            7\\n1 2 2 2 3 5 7 9 10 13 15 15 16 19 19 21 21 23 23 26 26 27 29 29 31 31 33 34 35 35 35 36 36 36 37 38 40 41 44 45 45 48 48 51 52 53 53 57 57 58 59 59 59 61 63 64 65 67 68 69 70 70 70\\n31"
                    },
                    {
                        "username": "therishuraj",
                        "content": "Its an invalid testcase,\\nwill throw an error as \"The first integer of each row is greater than the last integer of the previous row.\"\\nas matrix[2][0] not greater then matrix[1][6];\\nso matrix[2][0] can be taken as 24.\\ncorrect input can be :-\\n9 * 7\\n[[1, 2, 2, 2, 3, 5, 7, 9, 10],[13, 15, 15, 16, 19, 19, 21, 21, 23],[24, 26, 26, 27, 29, 29, 31, 31, 33],[34, 35, 35, 35, 36, 36, 36, 37, 38], [40, 41, 44, 45, 45, 48, 48, 51, 52], [53, 53, 57, 57, 58, 59, 59, 59, 61], [63, 64, 65, 67, 68, 69, 70, 70, 70]]\\ntarget = 31\\nwill give proper result on applying binary search correctly."
                    },
                    {
                        "username": "TimPC",
                        "content": "This test case has long rows and a big jump where the second row  first entry is less than the target. To pass it successfully you have to do binary search on the first row and then skip the second row entirely because the first entry is too large."
                    },
                    {
                        "username": "voidptr",
                        "content": "Hi \\n\\nI am just trying to understand what is the difference between this problem and :\\nhttps://leetcode.com/problems/search-a-2d-matrix-ii/description/\\n\\nI feel they are identical."
                    },
                    {
                        "username": "psionl0",
                        "content": "In problem 240 you can\\'t use a binary search to locate the row so a linear run time is the best that you will get."
                    },
                    {
                        "username": "mochiball",
                        "content": "Different. This one everything is sorted . The other one the rows are sorted and columns are sorted BUT the last value in the row might not be smaller than the first value in the next row   "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "I agree with previous answers, also this problem asking to solve it with O(log(m*n))"
                    },
                    {
                        "username": "mkohar",
                        "content": "No they are not. \\nCondition **\"The first integer of each row is greater than the last integer of the previous row.\"** is true for this (#74) question, but not for the one in link(240)"
                    },
                    {
                        "username": "zephyr8",
                        "content": "[@Random Ptr](/voidptr)  - the problems are not identical.  If we were to write this matrix out as an array - it will be totally sorted. That\\'s not guaranteed for the other problem. "
                    },
                    {
                        "username": "zhangben",
                        "content": "what if change the condition like this:\\nIntegers in each row are sorted from left to right.\\nIntegers in each column are sorted from up to down.\\nhow should we solve this problem?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "you need to realize that its same as what we have now\\n "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "it is the same condition we have in the description"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can this even be solved in Log(m+n) ?"
                    }
                ]
            },
            {
                "id": 1571172,
                "content": [
                    {
                        "username": "mbed",
                        "content": "Imagine (rather actually draw it out) how a 2D array (m * n matrix) would be placed 'row-wise' into a 1D array - \neach row from a 2D array is placed as successive blocks of rows starting from row 0 to row m - 1 (of the 2D array);\n\n(Note that here the array could be placed 'column-wise' (opportunity to trick someone) into the 1D array and below translation of\nindices may not work as-is; hence how the 2D array is placed into the 1D array is important to know/imagine)\n\nGiven 'row-wise' placement, the 1D array now consists of 'blocks' of m rows and each 'block' contains column (n) number of elements; \n\nTake a 3x4 Matix placed row-wise into a 1D array as an example -\n\n`1D-Index:   | 0 1 2 3 | 4 5 6 7 | 8  9   10 11 |`\n`Elements:   | 1 2 3 4 | 5 6 7 8 | 8 10 11 12 |`\n\nTo find out the 2D Row index from a 1D array index, is equal to telling which row-block does this index belong to;\n\nwhich is = 1D index / # elements in the row-block\nwhich is = 1D index / # columns\n\ne.g.\nif 1D index is 7;\n       2D Row index = 7 / #columns\n\t                = 7 / 4\n\t\t\t\t\t= 1\n\t\t\t\t\t\nNow onto column index,\n\nIf you look at above example, column index is just an offest inside a given row-block.\nWhile this seems less intuitive to derive, the remainder of the division operation we performed above\nto get the row index gives you the offset in that row, which turns out to be the column index.\n\nSo 2D Col Index =  Remainder of (1D-Index / #columns)\n                          =  (1D-index % #columns)\n\n\ne.g.\nif 1D index is 7;\n2D Col index = 7 % 4\n\t                = 3\n\t\t\t\n\t\t\t\nGiving us (for a 1D array index 'i' and an m * n matrix placed row-wise into the 1D array), \n1D to 2D index transformation:\n\n`[i]  =>  [i / n][i % n]`\n\n\nBonus:\nIf the matrix is sorted column-wise,  an so we imagine placing the matrix as 'column-wise' blocks into the 1D array, then,\n1D to 2D index transformation:\n`[i]  =>  [i % m][i / m]`\n\n2D to 1D (row-wise) transformation:\n`[i][j] => [i * n + j]`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Good solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "When I originally did this problem, I did a binary search of the start of each row to locate the row then did a binary search of the row itself to find the target. O(log M + log N). This method works because the start of each row is greater than the end of the previous row.\nThen I noticed that if the TR corner of the matrix was greater than the target then you could eliminate the entire RH column. Similarly, if the TR corner of the matrix is less than the target then you can eliminate the entire top row. So you can just walk down the matrix until you either hit the target or fall off the matrix.\nThis has a O(M + N) run time which is not as good as the binary search method but is useful to know if you want to tackle ``240. Search a 2D Matrix II`` where a binary search to locate the row is not possible.\n"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-a-2d-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "chrisrao",
                        "content": "I think this would be more clear if it said \"ascending order\" rather than \"non-decreasing order\". I spent some time looking at the matrices wondering if there was some trick before deciding to implement a binary search. "
                    },
                    {
                        "username": "shaw-code",
                        "content": "\"Ascending order\" and \"Non decreasing order\" are two different things.\\nAscending order contain only unique elements in sorted order. [1,2,3]\\nNon-decreasing order contain repeated elements in sorted order. [1,1,2,3]\\n\\nSame goes for Descending order and Non-increasing order."
                    },
                    {
                        "username": "viyengar",
                        "content": "Non-decreasing order is a more precise description for the problem. \\nex: [1, 2, 2, 3, 4] is NOT technically ascending order, but is a valid input for a row in the matrix."
                    },
                    {
                        "username": "adrians99",
                        "content": "Useful tests to check extreme cases\\n\\n`matrix = [[1],[3],[5]] target = 3`\\n`matrix = [[1, 3]] target = 3`\\n`matrix = [[1, 3]] target = 2`\\n`matrix = [[1]] target = 1`"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "It would be great if leetcode had a  time and memory complexity analyzer of the code. My solution is log(m * n), but seems that test cases is small enough that linear time algorithm can beat it))."
                    },
                    {
                        "username": "user2049D",
                        "content": "You are right. Sometimes, O(m + n) code is faster than the O(log(m * n)) one !"
                    },
                    {
                        "username": "code_24x7",
                        "content": "Solved it in O(log(m)*log(n)).\n1. First binary search the rows to the get the target row.\n2. Next binary search the target_row to search the element.\n\nHow does it compare to O(log(m*n)), How must i do the math for that. Can someone help?\n\n `class Solution:\n    def get_target_row(self, matrix, target):\n        start = 0\n        end = len(matrix)-1\n        col = len(matrix[0])-1\n        while start <= end:\n            mid = start + (end-start)//2\n            if target >= matrix[mid][0] and target <= matrix[mid][col]:\n                return mid\n            elif target < matrix[mid][0]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return -1\n\n    def binary_search(self, array, target):\n        start = 0\n        end = len(array)\n        while start <= end:\n            mid = start + (end-start)//2\n            if target == array[mid]:\n                return True\n            elif target < array[mid]:\n                end = mid-1\n            else:\n                start = mid + 1\n        return False\n\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        row = len(matrix)\n        col = len(matrix[0])-1\n        target_row = self.get_target_row(matrix, target)\n        if target_row == -1:\n            return False\n        return self.binary_search(matrix[target_row], target)`\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The run time is O(log(m) + log(n)) which is the same as O(log(m*n))."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i try but it fail on \\ngiven test case \\nthis test case from GFG;\\n\\n\\n9            7\\n1 2 2 2 3 5 7 9 10 13 15 15 16 19 19 21 21 23 23 26 26 27 29 29 31 31 33 34 35 35 35 36 36 36 37 38 40 41 44 45 45 48 48 51 52 53 53 57 57 58 59 59 59 61 63 64 65 67 68 69 70 70 70\\n31"
                    },
                    {
                        "username": "therishuraj",
                        "content": "Its an invalid testcase,\\nwill throw an error as \"The first integer of each row is greater than the last integer of the previous row.\"\\nas matrix[2][0] not greater then matrix[1][6];\\nso matrix[2][0] can be taken as 24.\\ncorrect input can be :-\\n9 * 7\\n[[1, 2, 2, 2, 3, 5, 7, 9, 10],[13, 15, 15, 16, 19, 19, 21, 21, 23],[24, 26, 26, 27, 29, 29, 31, 31, 33],[34, 35, 35, 35, 36, 36, 36, 37, 38], [40, 41, 44, 45, 45, 48, 48, 51, 52], [53, 53, 57, 57, 58, 59, 59, 59, 61], [63, 64, 65, 67, 68, 69, 70, 70, 70]]\\ntarget = 31\\nwill give proper result on applying binary search correctly."
                    },
                    {
                        "username": "TimPC",
                        "content": "This test case has long rows and a big jump where the second row  first entry is less than the target. To pass it successfully you have to do binary search on the first row and then skip the second row entirely because the first entry is too large."
                    },
                    {
                        "username": "voidptr",
                        "content": "Hi \\n\\nI am just trying to understand what is the difference between this problem and :\\nhttps://leetcode.com/problems/search-a-2d-matrix-ii/description/\\n\\nI feel they are identical."
                    },
                    {
                        "username": "psionl0",
                        "content": "In problem 240 you can\\'t use a binary search to locate the row so a linear run time is the best that you will get."
                    },
                    {
                        "username": "mochiball",
                        "content": "Different. This one everything is sorted . The other one the rows are sorted and columns are sorted BUT the last value in the row might not be smaller than the first value in the next row   "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "I agree with previous answers, also this problem asking to solve it with O(log(m*n))"
                    },
                    {
                        "username": "mkohar",
                        "content": "No they are not. \\nCondition **\"The first integer of each row is greater than the last integer of the previous row.\"** is true for this (#74) question, but not for the one in link(240)"
                    },
                    {
                        "username": "zephyr8",
                        "content": "[@Random Ptr](/voidptr)  - the problems are not identical.  If we were to write this matrix out as an array - it will be totally sorted. That\\'s not guaranteed for the other problem. "
                    },
                    {
                        "username": "zhangben",
                        "content": "what if change the condition like this:\\nIntegers in each row are sorted from left to right.\\nIntegers in each column are sorted from up to down.\\nhow should we solve this problem?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "you need to realize that its same as what we have now\\n "
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "it is the same condition we have in the description"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can this even be solved in Log(m+n) ?"
                    }
                ]
            },
            {
                "id": 1576982,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Post it in Solutions, please."
                    },
                    {
                        "username": "Shalhzaib_Saleem",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int start=0;\\n        int last=matrix.size()-1;\\n        int mid=start+(last-start)/2;\\n        while(start<last)\\n        {\\n            if(mid==last || mid == start)\\n            {\\n                break;\\n            }\\n            if(mid>target)\\n            {\\n                last=mid;\\n            }\\n            else if(mid<target)\\n            {\\n                start=mid;\\n            }\\n            if(matrix[mid/matrix.size()][mid%matrix.size()]==target)\\n            {\\n                return true;\\n            }\\n            mid=start+(last-start)/2;\\n        }\\n        return false;\\n    }\\n};\\n"
                    },
                    {
                        "username": "toanngo",
                        "content": "I naively did 2 binary search:\nFirst is a binary search vertically on the last column to see which row might contains the target\nSecond is just a normal bsearch on the row to get the final answer"
                    },
                    {
                        "username": "Nameresu",
                        "content": "[@Tom_Dev](/Tom_Dev) \\nAccording to Logarithmic product rule: \\nO(log m + log n) = O(log(m*n))"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This does not meet the requirements of the task. Two binary searches correspond to O(log m + log n). You must write a solution with O(log(m*n)) complexity."
                    },
                    {
                        "username": "koskirillall2008",
                        "content": "this is not medium "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Hi fellow LeetCoders,\\nWhile I was re-attempting this problem in C,\\nI observed this, kind of a weird thing, in the function\\'s formal parameters:\\n`bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target)`\\n\\n**matrixSize** (which denotes the number of rows) is simply an integer, however, **matrixColSize** (which denotes the number of columns in each row), is a pointer to an integer value.\\n\\nWhy is **matrixColSize** a pointer to int, where it could simply have been an integer ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "``*matrixColSize`` is an array of integers that stores the length of each row. Normally a matrix is rectangular meaning that each row has the same length but a matrix can also be non-rectangular (eg Pascal's Triangle).\nIf you know that the matrix is rectangular then you can just regard ``*matrixColSize`` as a constant variable in the same way as ``matrixSize``.\nIf you find that there will be too much typing to use the full names all the time then just declare simple variables such as ``int m = matrixSize, n = *matrixColSize;``. (This might save a small amount of running time since you are not doing indirection all the time)."
                    },
                    {
                        "username": "ankush20386",
                        "content": "can anyone help me out with the time complexity of this particular problem?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            if(matrix[i][0]<=target)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(matrix[i][j]==target){return true;}\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int left=0,right=m*n-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            int mid_value=matrix[mid/n][mid%n];\\n            if(mid_value==target)\\n                return true;\\n            \\n            else if(mid_value<target)\\n                left=mid-1;\\n            \\n            else\\n                right=mid-1;\\n        }\\n        return false;\\n    }\\n}\\n\\nI try this code but it shows TIME LIMIT EXCEEEDED solve the problem"
                    },
                    {
                        "username": "alextom",
                        "content": "This is too easy.  $O(log(m*n))$ can achieved by a binary search on the $m*n$ elements in the matrix.  A more challenging goal is to do it in $O(log(m)+log(n))$, which can be done by searching first to find the row, then to find the item in that row."
                    },
                    {
                        "username": "lakshya_17",
                        "content": "Can someone please tell me what would the time complexity of the following code be:\n`class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        b, l = 0, len(matrix) - 1\n        while b <= l:\n            m = (l + b)//2\n            if target < matrix[m][0]:\n                l = m - 1\n            elif target > matrix[m][-1]:\n                b = m + 1\n            else:\n                beg, last = 0, len(matrix[0]) - 1\n                while beg <= last:\n                    mid = (beg + last)//2\n                    if matrix[m][mid] == target:\n                        return True\n                    elif matrix[m][mid] > target:\n                        last -= 1\n                    else:\n                        beg += 1\n                return False`"
                    },
                    {
                        "username": "Utsarg",
                        "content": "*Spoiler : Solution ahead , just posted for discussion purpose*\n\n**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach)**\n\n\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\n\n\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\n\n\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it's use cases.\n\n\nclass Solution {\npublic:\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int x = 0;\n        int y= m-1;\n\n\n        while(x<y){\n            int mid = x+(y-x)/2;\n            if(mid >= m ) break;\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]<target){\n                if(mid+1>=m){\n                    break;\n                }\n                x=mid+1;\n            }else if(matrix[mid][n-1]>target){\n                y=mid-1;\n            }else{\n                break;\n            }\n        }\n        \n\n            if (matrix[x][n - 1] >= target) {\n        int left = 0;\n        int right = n-1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (matrix[x][mid] == target) {\n                return true;\n            } else if (matrix[x][mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n            }\n        \n                return false;\n    }\n};"
                    }
                ]
            },
            {
                "id": 2052456,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Post it in Solutions, please."
                    },
                    {
                        "username": "Shalhzaib_Saleem",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int start=0;\\n        int last=matrix.size()-1;\\n        int mid=start+(last-start)/2;\\n        while(start<last)\\n        {\\n            if(mid==last || mid == start)\\n            {\\n                break;\\n            }\\n            if(mid>target)\\n            {\\n                last=mid;\\n            }\\n            else if(mid<target)\\n            {\\n                start=mid;\\n            }\\n            if(matrix[mid/matrix.size()][mid%matrix.size()]==target)\\n            {\\n                return true;\\n            }\\n            mid=start+(last-start)/2;\\n        }\\n        return false;\\n    }\\n};\\n"
                    },
                    {
                        "username": "toanngo",
                        "content": "I naively did 2 binary search:\nFirst is a binary search vertically on the last column to see which row might contains the target\nSecond is just a normal bsearch on the row to get the final answer"
                    },
                    {
                        "username": "Nameresu",
                        "content": "[@Tom_Dev](/Tom_Dev) \\nAccording to Logarithmic product rule: \\nO(log m + log n) = O(log(m*n))"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This does not meet the requirements of the task. Two binary searches correspond to O(log m + log n). You must write a solution with O(log(m*n)) complexity."
                    },
                    {
                        "username": "koskirillall2008",
                        "content": "this is not medium "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Hi fellow LeetCoders,\\nWhile I was re-attempting this problem in C,\\nI observed this, kind of a weird thing, in the function\\'s formal parameters:\\n`bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target)`\\n\\n**matrixSize** (which denotes the number of rows) is simply an integer, however, **matrixColSize** (which denotes the number of columns in each row), is a pointer to an integer value.\\n\\nWhy is **matrixColSize** a pointer to int, where it could simply have been an integer ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "``*matrixColSize`` is an array of integers that stores the length of each row. Normally a matrix is rectangular meaning that each row has the same length but a matrix can also be non-rectangular (eg Pascal's Triangle).\nIf you know that the matrix is rectangular then you can just regard ``*matrixColSize`` as a constant variable in the same way as ``matrixSize``.\nIf you find that there will be too much typing to use the full names all the time then just declare simple variables such as ``int m = matrixSize, n = *matrixColSize;``. (This might save a small amount of running time since you are not doing indirection all the time)."
                    },
                    {
                        "username": "ankush20386",
                        "content": "can anyone help me out with the time complexity of this particular problem?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            if(matrix[i][0]<=target)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(matrix[i][j]==target){return true;}\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int left=0,right=m*n-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            int mid_value=matrix[mid/n][mid%n];\\n            if(mid_value==target)\\n                return true;\\n            \\n            else if(mid_value<target)\\n                left=mid-1;\\n            \\n            else\\n                right=mid-1;\\n        }\\n        return false;\\n    }\\n}\\n\\nI try this code but it shows TIME LIMIT EXCEEEDED solve the problem"
                    },
                    {
                        "username": "alextom",
                        "content": "This is too easy.  $O(log(m*n))$ can achieved by a binary search on the $m*n$ elements in the matrix.  A more challenging goal is to do it in $O(log(m)+log(n))$, which can be done by searching first to find the row, then to find the item in that row."
                    },
                    {
                        "username": "lakshya_17",
                        "content": "Can someone please tell me what would the time complexity of the following code be:\n`class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        b, l = 0, len(matrix) - 1\n        while b <= l:\n            m = (l + b)//2\n            if target < matrix[m][0]:\n                l = m - 1\n            elif target > matrix[m][-1]:\n                b = m + 1\n            else:\n                beg, last = 0, len(matrix[0]) - 1\n                while beg <= last:\n                    mid = (beg + last)//2\n                    if matrix[m][mid] == target:\n                        return True\n                    elif matrix[m][mid] > target:\n                        last -= 1\n                    else:\n                        beg += 1\n                return False`"
                    },
                    {
                        "username": "Utsarg",
                        "content": "*Spoiler : Solution ahead , just posted for discussion purpose*\n\n**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach)**\n\n\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\n\n\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\n\n\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it's use cases.\n\n\nclass Solution {\npublic:\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int x = 0;\n        int y= m-1;\n\n\n        while(x<y){\n            int mid = x+(y-x)/2;\n            if(mid >= m ) break;\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]<target){\n                if(mid+1>=m){\n                    break;\n                }\n                x=mid+1;\n            }else if(matrix[mid][n-1]>target){\n                y=mid-1;\n            }else{\n                break;\n            }\n        }\n        \n\n            if (matrix[x][n - 1] >= target) {\n        int left = 0;\n        int right = n-1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (matrix[x][mid] == target) {\n                return true;\n            } else if (matrix[x][mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n            }\n        \n                return false;\n    }\n};"
                    }
                ]
            },
            {
                "id": 2045617,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Post it in Solutions, please."
                    },
                    {
                        "username": "Shalhzaib_Saleem",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int start=0;\\n        int last=matrix.size()-1;\\n        int mid=start+(last-start)/2;\\n        while(start<last)\\n        {\\n            if(mid==last || mid == start)\\n            {\\n                break;\\n            }\\n            if(mid>target)\\n            {\\n                last=mid;\\n            }\\n            else if(mid<target)\\n            {\\n                start=mid;\\n            }\\n            if(matrix[mid/matrix.size()][mid%matrix.size()]==target)\\n            {\\n                return true;\\n            }\\n            mid=start+(last-start)/2;\\n        }\\n        return false;\\n    }\\n};\\n"
                    },
                    {
                        "username": "toanngo",
                        "content": "I naively did 2 binary search:\nFirst is a binary search vertically on the last column to see which row might contains the target\nSecond is just a normal bsearch on the row to get the final answer"
                    },
                    {
                        "username": "Nameresu",
                        "content": "[@Tom_Dev](/Tom_Dev) \\nAccording to Logarithmic product rule: \\nO(log m + log n) = O(log(m*n))"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This does not meet the requirements of the task. Two binary searches correspond to O(log m + log n). You must write a solution with O(log(m*n)) complexity."
                    },
                    {
                        "username": "koskirillall2008",
                        "content": "this is not medium "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Hi fellow LeetCoders,\\nWhile I was re-attempting this problem in C,\\nI observed this, kind of a weird thing, in the function\\'s formal parameters:\\n`bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target)`\\n\\n**matrixSize** (which denotes the number of rows) is simply an integer, however, **matrixColSize** (which denotes the number of columns in each row), is a pointer to an integer value.\\n\\nWhy is **matrixColSize** a pointer to int, where it could simply have been an integer ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "``*matrixColSize`` is an array of integers that stores the length of each row. Normally a matrix is rectangular meaning that each row has the same length but a matrix can also be non-rectangular (eg Pascal's Triangle).\nIf you know that the matrix is rectangular then you can just regard ``*matrixColSize`` as a constant variable in the same way as ``matrixSize``.\nIf you find that there will be too much typing to use the full names all the time then just declare simple variables such as ``int m = matrixSize, n = *matrixColSize;``. (This might save a small amount of running time since you are not doing indirection all the time)."
                    },
                    {
                        "username": "ankush20386",
                        "content": "can anyone help me out with the time complexity of this particular problem?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            if(matrix[i][0]<=target)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(matrix[i][j]==target){return true;}\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int left=0,right=m*n-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            int mid_value=matrix[mid/n][mid%n];\\n            if(mid_value==target)\\n                return true;\\n            \\n            else if(mid_value<target)\\n                left=mid-1;\\n            \\n            else\\n                right=mid-1;\\n        }\\n        return false;\\n    }\\n}\\n\\nI try this code but it shows TIME LIMIT EXCEEEDED solve the problem"
                    },
                    {
                        "username": "alextom",
                        "content": "This is too easy.  $O(log(m*n))$ can achieved by a binary search on the $m*n$ elements in the matrix.  A more challenging goal is to do it in $O(log(m)+log(n))$, which can be done by searching first to find the row, then to find the item in that row."
                    },
                    {
                        "username": "lakshya_17",
                        "content": "Can someone please tell me what would the time complexity of the following code be:\n`class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        b, l = 0, len(matrix) - 1\n        while b <= l:\n            m = (l + b)//2\n            if target < matrix[m][0]:\n                l = m - 1\n            elif target > matrix[m][-1]:\n                b = m + 1\n            else:\n                beg, last = 0, len(matrix[0]) - 1\n                while beg <= last:\n                    mid = (beg + last)//2\n                    if matrix[m][mid] == target:\n                        return True\n                    elif matrix[m][mid] > target:\n                        last -= 1\n                    else:\n                        beg += 1\n                return False`"
                    },
                    {
                        "username": "Utsarg",
                        "content": "*Spoiler : Solution ahead , just posted for discussion purpose*\n\n**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach)**\n\n\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\n\n\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\n\n\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it's use cases.\n\n\nclass Solution {\npublic:\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int x = 0;\n        int y= m-1;\n\n\n        while(x<y){\n            int mid = x+(y-x)/2;\n            if(mid >= m ) break;\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]<target){\n                if(mid+1>=m){\n                    break;\n                }\n                x=mid+1;\n            }else if(matrix[mid][n-1]>target){\n                y=mid-1;\n            }else{\n                break;\n            }\n        }\n        \n\n            if (matrix[x][n - 1] >= target) {\n        int left = 0;\n        int right = n-1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (matrix[x][mid] == target) {\n                return true;\n            } else if (matrix[x][mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n            }\n        \n                return false;\n    }\n};"
                    }
                ]
            },
            {
                "id": 2039547,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Post it in Solutions, please."
                    },
                    {
                        "username": "Shalhzaib_Saleem",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int start=0;\\n        int last=matrix.size()-1;\\n        int mid=start+(last-start)/2;\\n        while(start<last)\\n        {\\n            if(mid==last || mid == start)\\n            {\\n                break;\\n            }\\n            if(mid>target)\\n            {\\n                last=mid;\\n            }\\n            else if(mid<target)\\n            {\\n                start=mid;\\n            }\\n            if(matrix[mid/matrix.size()][mid%matrix.size()]==target)\\n            {\\n                return true;\\n            }\\n            mid=start+(last-start)/2;\\n        }\\n        return false;\\n    }\\n};\\n"
                    },
                    {
                        "username": "toanngo",
                        "content": "I naively did 2 binary search:\nFirst is a binary search vertically on the last column to see which row might contains the target\nSecond is just a normal bsearch on the row to get the final answer"
                    },
                    {
                        "username": "Nameresu",
                        "content": "[@Tom_Dev](/Tom_Dev) \\nAccording to Logarithmic product rule: \\nO(log m + log n) = O(log(m*n))"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This does not meet the requirements of the task. Two binary searches correspond to O(log m + log n). You must write a solution with O(log(m*n)) complexity."
                    },
                    {
                        "username": "koskirillall2008",
                        "content": "this is not medium "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Hi fellow LeetCoders,\\nWhile I was re-attempting this problem in C,\\nI observed this, kind of a weird thing, in the function\\'s formal parameters:\\n`bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target)`\\n\\n**matrixSize** (which denotes the number of rows) is simply an integer, however, **matrixColSize** (which denotes the number of columns in each row), is a pointer to an integer value.\\n\\nWhy is **matrixColSize** a pointer to int, where it could simply have been an integer ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "``*matrixColSize`` is an array of integers that stores the length of each row. Normally a matrix is rectangular meaning that each row has the same length but a matrix can also be non-rectangular (eg Pascal's Triangle).\nIf you know that the matrix is rectangular then you can just regard ``*matrixColSize`` as a constant variable in the same way as ``matrixSize``.\nIf you find that there will be too much typing to use the full names all the time then just declare simple variables such as ``int m = matrixSize, n = *matrixColSize;``. (This might save a small amount of running time since you are not doing indirection all the time)."
                    },
                    {
                        "username": "ankush20386",
                        "content": "can anyone help me out with the time complexity of this particular problem?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            if(matrix[i][0]<=target)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(matrix[i][j]==target){return true;}\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int left=0,right=m*n-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            int mid_value=matrix[mid/n][mid%n];\\n            if(mid_value==target)\\n                return true;\\n            \\n            else if(mid_value<target)\\n                left=mid-1;\\n            \\n            else\\n                right=mid-1;\\n        }\\n        return false;\\n    }\\n}\\n\\nI try this code but it shows TIME LIMIT EXCEEEDED solve the problem"
                    },
                    {
                        "username": "alextom",
                        "content": "This is too easy.  $O(log(m*n))$ can achieved by a binary search on the $m*n$ elements in the matrix.  A more challenging goal is to do it in $O(log(m)+log(n))$, which can be done by searching first to find the row, then to find the item in that row."
                    },
                    {
                        "username": "lakshya_17",
                        "content": "Can someone please tell me what would the time complexity of the following code be:\n`class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        b, l = 0, len(matrix) - 1\n        while b <= l:\n            m = (l + b)//2\n            if target < matrix[m][0]:\n                l = m - 1\n            elif target > matrix[m][-1]:\n                b = m + 1\n            else:\n                beg, last = 0, len(matrix[0]) - 1\n                while beg <= last:\n                    mid = (beg + last)//2\n                    if matrix[m][mid] == target:\n                        return True\n                    elif matrix[m][mid] > target:\n                        last -= 1\n                    else:\n                        beg += 1\n                return False`"
                    },
                    {
                        "username": "Utsarg",
                        "content": "*Spoiler : Solution ahead , just posted for discussion purpose*\n\n**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach)**\n\n\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\n\n\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\n\n\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it's use cases.\n\n\nclass Solution {\npublic:\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int x = 0;\n        int y= m-1;\n\n\n        while(x<y){\n            int mid = x+(y-x)/2;\n            if(mid >= m ) break;\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]<target){\n                if(mid+1>=m){\n                    break;\n                }\n                x=mid+1;\n            }else if(matrix[mid][n-1]>target){\n                y=mid-1;\n            }else{\n                break;\n            }\n        }\n        \n\n            if (matrix[x][n - 1] >= target) {\n        int left = 0;\n        int right = n-1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (matrix[x][mid] == target) {\n                return true;\n            } else if (matrix[x][mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n            }\n        \n                return false;\n    }\n};"
                    }
                ]
            },
            {
                "id": 2038995,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Post it in Solutions, please."
                    },
                    {
                        "username": "Shalhzaib_Saleem",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int start=0;\\n        int last=matrix.size()-1;\\n        int mid=start+(last-start)/2;\\n        while(start<last)\\n        {\\n            if(mid==last || mid == start)\\n            {\\n                break;\\n            }\\n            if(mid>target)\\n            {\\n                last=mid;\\n            }\\n            else if(mid<target)\\n            {\\n                start=mid;\\n            }\\n            if(matrix[mid/matrix.size()][mid%matrix.size()]==target)\\n            {\\n                return true;\\n            }\\n            mid=start+(last-start)/2;\\n        }\\n        return false;\\n    }\\n};\\n"
                    },
                    {
                        "username": "toanngo",
                        "content": "I naively did 2 binary search:\nFirst is a binary search vertically on the last column to see which row might contains the target\nSecond is just a normal bsearch on the row to get the final answer"
                    },
                    {
                        "username": "Nameresu",
                        "content": "[@Tom_Dev](/Tom_Dev) \\nAccording to Logarithmic product rule: \\nO(log m + log n) = O(log(m*n))"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This does not meet the requirements of the task. Two binary searches correspond to O(log m + log n). You must write a solution with O(log(m*n)) complexity."
                    },
                    {
                        "username": "koskirillall2008",
                        "content": "this is not medium "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Hi fellow LeetCoders,\\nWhile I was re-attempting this problem in C,\\nI observed this, kind of a weird thing, in the function\\'s formal parameters:\\n`bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target)`\\n\\n**matrixSize** (which denotes the number of rows) is simply an integer, however, **matrixColSize** (which denotes the number of columns in each row), is a pointer to an integer value.\\n\\nWhy is **matrixColSize** a pointer to int, where it could simply have been an integer ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "``*matrixColSize`` is an array of integers that stores the length of each row. Normally a matrix is rectangular meaning that each row has the same length but a matrix can also be non-rectangular (eg Pascal's Triangle).\nIf you know that the matrix is rectangular then you can just regard ``*matrixColSize`` as a constant variable in the same way as ``matrixSize``.\nIf you find that there will be too much typing to use the full names all the time then just declare simple variables such as ``int m = matrixSize, n = *matrixColSize;``. (This might save a small amount of running time since you are not doing indirection all the time)."
                    },
                    {
                        "username": "ankush20386",
                        "content": "can anyone help me out with the time complexity of this particular problem?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            if(matrix[i][0]<=target)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(matrix[i][j]==target){return true;}\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int left=0,right=m*n-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            int mid_value=matrix[mid/n][mid%n];\\n            if(mid_value==target)\\n                return true;\\n            \\n            else if(mid_value<target)\\n                left=mid-1;\\n            \\n            else\\n                right=mid-1;\\n        }\\n        return false;\\n    }\\n}\\n\\nI try this code but it shows TIME LIMIT EXCEEEDED solve the problem"
                    },
                    {
                        "username": "alextom",
                        "content": "This is too easy.  $O(log(m*n))$ can achieved by a binary search on the $m*n$ elements in the matrix.  A more challenging goal is to do it in $O(log(m)+log(n))$, which can be done by searching first to find the row, then to find the item in that row."
                    },
                    {
                        "username": "lakshya_17",
                        "content": "Can someone please tell me what would the time complexity of the following code be:\n`class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        b, l = 0, len(matrix) - 1\n        while b <= l:\n            m = (l + b)//2\n            if target < matrix[m][0]:\n                l = m - 1\n            elif target > matrix[m][-1]:\n                b = m + 1\n            else:\n                beg, last = 0, len(matrix[0]) - 1\n                while beg <= last:\n                    mid = (beg + last)//2\n                    if matrix[m][mid] == target:\n                        return True\n                    elif matrix[m][mid] > target:\n                        last -= 1\n                    else:\n                        beg += 1\n                return False`"
                    },
                    {
                        "username": "Utsarg",
                        "content": "*Spoiler : Solution ahead , just posted for discussion purpose*\n\n**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach)**\n\n\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\n\n\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\n\n\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it's use cases.\n\n\nclass Solution {\npublic:\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int x = 0;\n        int y= m-1;\n\n\n        while(x<y){\n            int mid = x+(y-x)/2;\n            if(mid >= m ) break;\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]<target){\n                if(mid+1>=m){\n                    break;\n                }\n                x=mid+1;\n            }else if(matrix[mid][n-1]>target){\n                y=mid-1;\n            }else{\n                break;\n            }\n        }\n        \n\n            if (matrix[x][n - 1] >= target) {\n        int left = 0;\n        int right = n-1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (matrix[x][mid] == target) {\n                return true;\n            } else if (matrix[x][mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n            }\n        \n                return false;\n    }\n};"
                    }
                ]
            },
            {
                "id": 2034274,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Post it in Solutions, please."
                    },
                    {
                        "username": "Shalhzaib_Saleem",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int start=0;\\n        int last=matrix.size()-1;\\n        int mid=start+(last-start)/2;\\n        while(start<last)\\n        {\\n            if(mid==last || mid == start)\\n            {\\n                break;\\n            }\\n            if(mid>target)\\n            {\\n                last=mid;\\n            }\\n            else if(mid<target)\\n            {\\n                start=mid;\\n            }\\n            if(matrix[mid/matrix.size()][mid%matrix.size()]==target)\\n            {\\n                return true;\\n            }\\n            mid=start+(last-start)/2;\\n        }\\n        return false;\\n    }\\n};\\n"
                    },
                    {
                        "username": "toanngo",
                        "content": "I naively did 2 binary search:\nFirst is a binary search vertically on the last column to see which row might contains the target\nSecond is just a normal bsearch on the row to get the final answer"
                    },
                    {
                        "username": "Nameresu",
                        "content": "[@Tom_Dev](/Tom_Dev) \\nAccording to Logarithmic product rule: \\nO(log m + log n) = O(log(m*n))"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This does not meet the requirements of the task. Two binary searches correspond to O(log m + log n). You must write a solution with O(log(m*n)) complexity."
                    },
                    {
                        "username": "koskirillall2008",
                        "content": "this is not medium "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Hi fellow LeetCoders,\\nWhile I was re-attempting this problem in C,\\nI observed this, kind of a weird thing, in the function\\'s formal parameters:\\n`bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target)`\\n\\n**matrixSize** (which denotes the number of rows) is simply an integer, however, **matrixColSize** (which denotes the number of columns in each row), is a pointer to an integer value.\\n\\nWhy is **matrixColSize** a pointer to int, where it could simply have been an integer ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "``*matrixColSize`` is an array of integers that stores the length of each row. Normally a matrix is rectangular meaning that each row has the same length but a matrix can also be non-rectangular (eg Pascal's Triangle).\nIf you know that the matrix is rectangular then you can just regard ``*matrixColSize`` as a constant variable in the same way as ``matrixSize``.\nIf you find that there will be too much typing to use the full names all the time then just declare simple variables such as ``int m = matrixSize, n = *matrixColSize;``. (This might save a small amount of running time since you are not doing indirection all the time)."
                    },
                    {
                        "username": "ankush20386",
                        "content": "can anyone help me out with the time complexity of this particular problem?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            if(matrix[i][0]<=target)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(matrix[i][j]==target){return true;}\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int left=0,right=m*n-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            int mid_value=matrix[mid/n][mid%n];\\n            if(mid_value==target)\\n                return true;\\n            \\n            else if(mid_value<target)\\n                left=mid-1;\\n            \\n            else\\n                right=mid-1;\\n        }\\n        return false;\\n    }\\n}\\n\\nI try this code but it shows TIME LIMIT EXCEEEDED solve the problem"
                    },
                    {
                        "username": "alextom",
                        "content": "This is too easy.  $O(log(m*n))$ can achieved by a binary search on the $m*n$ elements in the matrix.  A more challenging goal is to do it in $O(log(m)+log(n))$, which can be done by searching first to find the row, then to find the item in that row."
                    },
                    {
                        "username": "lakshya_17",
                        "content": "Can someone please tell me what would the time complexity of the following code be:\n`class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        b, l = 0, len(matrix) - 1\n        while b <= l:\n            m = (l + b)//2\n            if target < matrix[m][0]:\n                l = m - 1\n            elif target > matrix[m][-1]:\n                b = m + 1\n            else:\n                beg, last = 0, len(matrix[0]) - 1\n                while beg <= last:\n                    mid = (beg + last)//2\n                    if matrix[m][mid] == target:\n                        return True\n                    elif matrix[m][mid] > target:\n                        last -= 1\n                    else:\n                        beg += 1\n                return False`"
                    },
                    {
                        "username": "Utsarg",
                        "content": "*Spoiler : Solution ahead , just posted for discussion purpose*\n\n**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach)**\n\n\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\n\n\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\n\n\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it's use cases.\n\n\nclass Solution {\npublic:\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int x = 0;\n        int y= m-1;\n\n\n        while(x<y){\n            int mid = x+(y-x)/2;\n            if(mid >= m ) break;\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]<target){\n                if(mid+1>=m){\n                    break;\n                }\n                x=mid+1;\n            }else if(matrix[mid][n-1]>target){\n                y=mid-1;\n            }else{\n                break;\n            }\n        }\n        \n\n            if (matrix[x][n - 1] >= target) {\n        int left = 0;\n        int right = n-1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (matrix[x][mid] == target) {\n                return true;\n            } else if (matrix[x][mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n            }\n        \n                return false;\n    }\n};"
                    }
                ]
            },
            {
                "id": 2033117,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Post it in Solutions, please."
                    },
                    {
                        "username": "Shalhzaib_Saleem",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int start=0;\\n        int last=matrix.size()-1;\\n        int mid=start+(last-start)/2;\\n        while(start<last)\\n        {\\n            if(mid==last || mid == start)\\n            {\\n                break;\\n            }\\n            if(mid>target)\\n            {\\n                last=mid;\\n            }\\n            else if(mid<target)\\n            {\\n                start=mid;\\n            }\\n            if(matrix[mid/matrix.size()][mid%matrix.size()]==target)\\n            {\\n                return true;\\n            }\\n            mid=start+(last-start)/2;\\n        }\\n        return false;\\n    }\\n};\\n"
                    },
                    {
                        "username": "toanngo",
                        "content": "I naively did 2 binary search:\nFirst is a binary search vertically on the last column to see which row might contains the target\nSecond is just a normal bsearch on the row to get the final answer"
                    },
                    {
                        "username": "Nameresu",
                        "content": "[@Tom_Dev](/Tom_Dev) \\nAccording to Logarithmic product rule: \\nO(log m + log n) = O(log(m*n))"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This does not meet the requirements of the task. Two binary searches correspond to O(log m + log n). You must write a solution with O(log(m*n)) complexity."
                    },
                    {
                        "username": "koskirillall2008",
                        "content": "this is not medium "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Hi fellow LeetCoders,\\nWhile I was re-attempting this problem in C,\\nI observed this, kind of a weird thing, in the function\\'s formal parameters:\\n`bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target)`\\n\\n**matrixSize** (which denotes the number of rows) is simply an integer, however, **matrixColSize** (which denotes the number of columns in each row), is a pointer to an integer value.\\n\\nWhy is **matrixColSize** a pointer to int, where it could simply have been an integer ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "``*matrixColSize`` is an array of integers that stores the length of each row. Normally a matrix is rectangular meaning that each row has the same length but a matrix can also be non-rectangular (eg Pascal's Triangle).\nIf you know that the matrix is rectangular then you can just regard ``*matrixColSize`` as a constant variable in the same way as ``matrixSize``.\nIf you find that there will be too much typing to use the full names all the time then just declare simple variables such as ``int m = matrixSize, n = *matrixColSize;``. (This might save a small amount of running time since you are not doing indirection all the time)."
                    },
                    {
                        "username": "ankush20386",
                        "content": "can anyone help me out with the time complexity of this particular problem?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            if(matrix[i][0]<=target)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(matrix[i][j]==target){return true;}\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int left=0,right=m*n-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            int mid_value=matrix[mid/n][mid%n];\\n            if(mid_value==target)\\n                return true;\\n            \\n            else if(mid_value<target)\\n                left=mid-1;\\n            \\n            else\\n                right=mid-1;\\n        }\\n        return false;\\n    }\\n}\\n\\nI try this code but it shows TIME LIMIT EXCEEEDED solve the problem"
                    },
                    {
                        "username": "alextom",
                        "content": "This is too easy.  $O(log(m*n))$ can achieved by a binary search on the $m*n$ elements in the matrix.  A more challenging goal is to do it in $O(log(m)+log(n))$, which can be done by searching first to find the row, then to find the item in that row."
                    },
                    {
                        "username": "lakshya_17",
                        "content": "Can someone please tell me what would the time complexity of the following code be:\n`class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        b, l = 0, len(matrix) - 1\n        while b <= l:\n            m = (l + b)//2\n            if target < matrix[m][0]:\n                l = m - 1\n            elif target > matrix[m][-1]:\n                b = m + 1\n            else:\n                beg, last = 0, len(matrix[0]) - 1\n                while beg <= last:\n                    mid = (beg + last)//2\n                    if matrix[m][mid] == target:\n                        return True\n                    elif matrix[m][mid] > target:\n                        last -= 1\n                    else:\n                        beg += 1\n                return False`"
                    },
                    {
                        "username": "Utsarg",
                        "content": "*Spoiler : Solution ahead , just posted for discussion purpose*\n\n**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach)**\n\n\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\n\n\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\n\n\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it's use cases.\n\n\nclass Solution {\npublic:\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int x = 0;\n        int y= m-1;\n\n\n        while(x<y){\n            int mid = x+(y-x)/2;\n            if(mid >= m ) break;\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]<target){\n                if(mid+1>=m){\n                    break;\n                }\n                x=mid+1;\n            }else if(matrix[mid][n-1]>target){\n                y=mid-1;\n            }else{\n                break;\n            }\n        }\n        \n\n            if (matrix[x][n - 1] >= target) {\n        int left = 0;\n        int right = n-1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (matrix[x][mid] == target) {\n                return true;\n            } else if (matrix[x][mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n            }\n        \n                return false;\n    }\n};"
                    }
                ]
            },
            {
                "id": 2026283,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Post it in Solutions, please."
                    },
                    {
                        "username": "Shalhzaib_Saleem",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int start=0;\\n        int last=matrix.size()-1;\\n        int mid=start+(last-start)/2;\\n        while(start<last)\\n        {\\n            if(mid==last || mid == start)\\n            {\\n                break;\\n            }\\n            if(mid>target)\\n            {\\n                last=mid;\\n            }\\n            else if(mid<target)\\n            {\\n                start=mid;\\n            }\\n            if(matrix[mid/matrix.size()][mid%matrix.size()]==target)\\n            {\\n                return true;\\n            }\\n            mid=start+(last-start)/2;\\n        }\\n        return false;\\n    }\\n};\\n"
                    },
                    {
                        "username": "toanngo",
                        "content": "I naively did 2 binary search:\nFirst is a binary search vertically on the last column to see which row might contains the target\nSecond is just a normal bsearch on the row to get the final answer"
                    },
                    {
                        "username": "Nameresu",
                        "content": "[@Tom_Dev](/Tom_Dev) \\nAccording to Logarithmic product rule: \\nO(log m + log n) = O(log(m*n))"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This does not meet the requirements of the task. Two binary searches correspond to O(log m + log n). You must write a solution with O(log(m*n)) complexity."
                    },
                    {
                        "username": "koskirillall2008",
                        "content": "this is not medium "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Hi fellow LeetCoders,\\nWhile I was re-attempting this problem in C,\\nI observed this, kind of a weird thing, in the function\\'s formal parameters:\\n`bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target)`\\n\\n**matrixSize** (which denotes the number of rows) is simply an integer, however, **matrixColSize** (which denotes the number of columns in each row), is a pointer to an integer value.\\n\\nWhy is **matrixColSize** a pointer to int, where it could simply have been an integer ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "``*matrixColSize`` is an array of integers that stores the length of each row. Normally a matrix is rectangular meaning that each row has the same length but a matrix can also be non-rectangular (eg Pascal's Triangle).\nIf you know that the matrix is rectangular then you can just regard ``*matrixColSize`` as a constant variable in the same way as ``matrixSize``.\nIf you find that there will be too much typing to use the full names all the time then just declare simple variables such as ``int m = matrixSize, n = *matrixColSize;``. (This might save a small amount of running time since you are not doing indirection all the time)."
                    },
                    {
                        "username": "ankush20386",
                        "content": "can anyone help me out with the time complexity of this particular problem?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            if(matrix[i][0]<=target)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(matrix[i][j]==target){return true;}\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int left=0,right=m*n-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            int mid_value=matrix[mid/n][mid%n];\\n            if(mid_value==target)\\n                return true;\\n            \\n            else if(mid_value<target)\\n                left=mid-1;\\n            \\n            else\\n                right=mid-1;\\n        }\\n        return false;\\n    }\\n}\\n\\nI try this code but it shows TIME LIMIT EXCEEEDED solve the problem"
                    },
                    {
                        "username": "alextom",
                        "content": "This is too easy.  $O(log(m*n))$ can achieved by a binary search on the $m*n$ elements in the matrix.  A more challenging goal is to do it in $O(log(m)+log(n))$, which can be done by searching first to find the row, then to find the item in that row."
                    },
                    {
                        "username": "lakshya_17",
                        "content": "Can someone please tell me what would the time complexity of the following code be:\n`class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        b, l = 0, len(matrix) - 1\n        while b <= l:\n            m = (l + b)//2\n            if target < matrix[m][0]:\n                l = m - 1\n            elif target > matrix[m][-1]:\n                b = m + 1\n            else:\n                beg, last = 0, len(matrix[0]) - 1\n                while beg <= last:\n                    mid = (beg + last)//2\n                    if matrix[m][mid] == target:\n                        return True\n                    elif matrix[m][mid] > target:\n                        last -= 1\n                    else:\n                        beg += 1\n                return False`"
                    },
                    {
                        "username": "Utsarg",
                        "content": "*Spoiler : Solution ahead , just posted for discussion purpose*\n\n**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach)**\n\n\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\n\n\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\n\n\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it's use cases.\n\n\nclass Solution {\npublic:\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int x = 0;\n        int y= m-1;\n\n\n        while(x<y){\n            int mid = x+(y-x)/2;\n            if(mid >= m ) break;\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]<target){\n                if(mid+1>=m){\n                    break;\n                }\n                x=mid+1;\n            }else if(matrix[mid][n-1]>target){\n                y=mid-1;\n            }else{\n                break;\n            }\n        }\n        \n\n            if (matrix[x][n - 1] >= target) {\n        int left = 0;\n        int right = n-1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (matrix[x][mid] == target) {\n                return true;\n            } else if (matrix[x][mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n            }\n        \n                return false;\n    }\n};"
                    }
                ]
            },
            {
                "id": 2025887,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Post it in Solutions, please."
                    },
                    {
                        "username": "Shalhzaib_Saleem",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int start=0;\\n        int last=matrix.size()-1;\\n        int mid=start+(last-start)/2;\\n        while(start<last)\\n        {\\n            if(mid==last || mid == start)\\n            {\\n                break;\\n            }\\n            if(mid>target)\\n            {\\n                last=mid;\\n            }\\n            else if(mid<target)\\n            {\\n                start=mid;\\n            }\\n            if(matrix[mid/matrix.size()][mid%matrix.size()]==target)\\n            {\\n                return true;\\n            }\\n            mid=start+(last-start)/2;\\n        }\\n        return false;\\n    }\\n};\\n"
                    },
                    {
                        "username": "toanngo",
                        "content": "I naively did 2 binary search:\nFirst is a binary search vertically on the last column to see which row might contains the target\nSecond is just a normal bsearch on the row to get the final answer"
                    },
                    {
                        "username": "Nameresu",
                        "content": "[@Tom_Dev](/Tom_Dev) \\nAccording to Logarithmic product rule: \\nO(log m + log n) = O(log(m*n))"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This does not meet the requirements of the task. Two binary searches correspond to O(log m + log n). You must write a solution with O(log(m*n)) complexity."
                    },
                    {
                        "username": "koskirillall2008",
                        "content": "this is not medium "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Hi fellow LeetCoders,\\nWhile I was re-attempting this problem in C,\\nI observed this, kind of a weird thing, in the function\\'s formal parameters:\\n`bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target)`\\n\\n**matrixSize** (which denotes the number of rows) is simply an integer, however, **matrixColSize** (which denotes the number of columns in each row), is a pointer to an integer value.\\n\\nWhy is **matrixColSize** a pointer to int, where it could simply have been an integer ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "``*matrixColSize`` is an array of integers that stores the length of each row. Normally a matrix is rectangular meaning that each row has the same length but a matrix can also be non-rectangular (eg Pascal's Triangle).\nIf you know that the matrix is rectangular then you can just regard ``*matrixColSize`` as a constant variable in the same way as ``matrixSize``.\nIf you find that there will be too much typing to use the full names all the time then just declare simple variables such as ``int m = matrixSize, n = *matrixColSize;``. (This might save a small amount of running time since you are not doing indirection all the time)."
                    },
                    {
                        "username": "ankush20386",
                        "content": "can anyone help me out with the time complexity of this particular problem?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            if(matrix[i][0]<=target)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(matrix[i][j]==target){return true;}\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int left=0,right=m*n-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            int mid_value=matrix[mid/n][mid%n];\\n            if(mid_value==target)\\n                return true;\\n            \\n            else if(mid_value<target)\\n                left=mid-1;\\n            \\n            else\\n                right=mid-1;\\n        }\\n        return false;\\n    }\\n}\\n\\nI try this code but it shows TIME LIMIT EXCEEEDED solve the problem"
                    },
                    {
                        "username": "alextom",
                        "content": "This is too easy.  $O(log(m*n))$ can achieved by a binary search on the $m*n$ elements in the matrix.  A more challenging goal is to do it in $O(log(m)+log(n))$, which can be done by searching first to find the row, then to find the item in that row."
                    },
                    {
                        "username": "lakshya_17",
                        "content": "Can someone please tell me what would the time complexity of the following code be:\n`class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        b, l = 0, len(matrix) - 1\n        while b <= l:\n            m = (l + b)//2\n            if target < matrix[m][0]:\n                l = m - 1\n            elif target > matrix[m][-1]:\n                b = m + 1\n            else:\n                beg, last = 0, len(matrix[0]) - 1\n                while beg <= last:\n                    mid = (beg + last)//2\n                    if matrix[m][mid] == target:\n                        return True\n                    elif matrix[m][mid] > target:\n                        last -= 1\n                    else:\n                        beg += 1\n                return False`"
                    },
                    {
                        "username": "Utsarg",
                        "content": "*Spoiler : Solution ahead , just posted for discussion purpose*\n\n**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach)**\n\n\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\n\n\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\n\n\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it's use cases.\n\n\nclass Solution {\npublic:\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int x = 0;\n        int y= m-1;\n\n\n        while(x<y){\n            int mid = x+(y-x)/2;\n            if(mid >= m ) break;\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]<target){\n                if(mid+1>=m){\n                    break;\n                }\n                x=mid+1;\n            }else if(matrix[mid][n-1]>target){\n                y=mid-1;\n            }else{\n                break;\n            }\n        }\n        \n\n            if (matrix[x][n - 1] >= target) {\n        int left = 0;\n        int right = n-1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (matrix[x][mid] == target) {\n                return true;\n            } else if (matrix[x][mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n            }\n        \n                return false;\n    }\n};"
                    }
                ]
            },
            {
                "id": 2012930,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Post it in Solutions, please."
                    },
                    {
                        "username": "Shalhzaib_Saleem",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int start=0;\\n        int last=matrix.size()-1;\\n        int mid=start+(last-start)/2;\\n        while(start<last)\\n        {\\n            if(mid==last || mid == start)\\n            {\\n                break;\\n            }\\n            if(mid>target)\\n            {\\n                last=mid;\\n            }\\n            else if(mid<target)\\n            {\\n                start=mid;\\n            }\\n            if(matrix[mid/matrix.size()][mid%matrix.size()]==target)\\n            {\\n                return true;\\n            }\\n            mid=start+(last-start)/2;\\n        }\\n        return false;\\n    }\\n};\\n"
                    },
                    {
                        "username": "toanngo",
                        "content": "I naively did 2 binary search:\nFirst is a binary search vertically on the last column to see which row might contains the target\nSecond is just a normal bsearch on the row to get the final answer"
                    },
                    {
                        "username": "Nameresu",
                        "content": "[@Tom_Dev](/Tom_Dev) \\nAccording to Logarithmic product rule: \\nO(log m + log n) = O(log(m*n))"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This does not meet the requirements of the task. Two binary searches correspond to O(log m + log n). You must write a solution with O(log(m*n)) complexity."
                    },
                    {
                        "username": "koskirillall2008",
                        "content": "this is not medium "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Hi fellow LeetCoders,\\nWhile I was re-attempting this problem in C,\\nI observed this, kind of a weird thing, in the function\\'s formal parameters:\\n`bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target)`\\n\\n**matrixSize** (which denotes the number of rows) is simply an integer, however, **matrixColSize** (which denotes the number of columns in each row), is a pointer to an integer value.\\n\\nWhy is **matrixColSize** a pointer to int, where it could simply have been an integer ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "``*matrixColSize`` is an array of integers that stores the length of each row. Normally a matrix is rectangular meaning that each row has the same length but a matrix can also be non-rectangular (eg Pascal's Triangle).\nIf you know that the matrix is rectangular then you can just regard ``*matrixColSize`` as a constant variable in the same way as ``matrixSize``.\nIf you find that there will be too much typing to use the full names all the time then just declare simple variables such as ``int m = matrixSize, n = *matrixColSize;``. (This might save a small amount of running time since you are not doing indirection all the time)."
                    },
                    {
                        "username": "ankush20386",
                        "content": "can anyone help me out with the time complexity of this particular problem?\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            if(matrix[i][0]<=target)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(matrix[i][j]==target){return true;}\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int left=0,right=m*n-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            int mid_value=matrix[mid/n][mid%n];\\n            if(mid_value==target)\\n                return true;\\n            \\n            else if(mid_value<target)\\n                left=mid-1;\\n            \\n            else\\n                right=mid-1;\\n        }\\n        return false;\\n    }\\n}\\n\\nI try this code but it shows TIME LIMIT EXCEEEDED solve the problem"
                    },
                    {
                        "username": "alextom",
                        "content": "This is too easy.  $O(log(m*n))$ can achieved by a binary search on the $m*n$ elements in the matrix.  A more challenging goal is to do it in $O(log(m)+log(n))$, which can be done by searching first to find the row, then to find the item in that row."
                    },
                    {
                        "username": "lakshya_17",
                        "content": "Can someone please tell me what would the time complexity of the following code be:\n`class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        b, l = 0, len(matrix) - 1\n        while b <= l:\n            m = (l + b)//2\n            if target < matrix[m][0]:\n                l = m - 1\n            elif target > matrix[m][-1]:\n                b = m + 1\n            else:\n                beg, last = 0, len(matrix[0]) - 1\n                while beg <= last:\n                    mid = (beg + last)//2\n                    if matrix[m][mid] == target:\n                        return True\n                    elif matrix[m][mid] > target:\n                        last -= 1\n                    else:\n                        beg += 1\n                return False`"
                    },
                    {
                        "username": "Utsarg",
                        "content": "*Spoiler : Solution ahead , just posted for discussion purpose*\n\n**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach)**\n\n\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\n\n\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\n\n\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it's use cases.\n\n\nclass Solution {\npublic:\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int x = 0;\n        int y= m-1;\n\n\n        while(x<y){\n            int mid = x+(y-x)/2;\n            if(mid >= m ) break;\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\n                x=mid;\n                break;\n            }else if(matrix[mid][n-1]<target){\n                if(mid+1>=m){\n                    break;\n                }\n                x=mid+1;\n            }else if(matrix[mid][n-1]>target){\n                y=mid-1;\n            }else{\n                break;\n            }\n        }\n        \n\n            if (matrix[x][n - 1] >= target) {\n        int left = 0;\n        int right = n-1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (matrix[x][mid] == target) {\n                return true;\n            } else if (matrix[x][mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n            }\n        \n                return false;\n    }\n};"
                    }
                ]
            },
            {
                "id": 2012924,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach).\\n**\\n\\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\\n\\n\\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\\n\\n\\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it\\'s use cases.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int x = 0;\\n        int y= m-1;\\n\\n//Binary Search for Row\\n# heading\\n        while(x<y){\\n            int mid = x+(y-x)/2;\\n            if(mid >= m ) break;\\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\\n                x=mid;\\n                break;\\n        }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\\n                x=mid;\\n                break;\\n            }else if(matrix[mid][n-1]<target){\\n                if(mid+1>=m){\\n                    break;\\n                }\\n                 x=mid+1;\\n            }else if(matrix[mid][n-1]>target){\\n                y=mid-1;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n//Binary Search for Column\\n            if (matrix[x][n - 1] >= target) {\\n        int left = 0;\\n        int right = n-1;\\n        \\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (matrix[x][mid] == target) {\\n                return true;\\n            } else if (matrix[x][mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n            }\\n        // }\\n                return false;\\n    }\\n};"
                    },
                    {
                        "username": "PranavChindage",
                        "content": "More faster code :  Searching a element in row using binary search and extracting an array(arr) where that row element is first element of arr and arr[column-1] is last . Then searching target element in arr.\\n\\nclass Solution {\\npublic:\\n    bool binarySearchInColumn(vector<int>& arr, int col, int key) {\\n        int start = 0, end = col - 1;\\n        int mid = start + (end - start) / 2;\\n        \\n        while (start <= end){\\n            if (arr[mid] == key) {\\n                return true; \\n            }\\n            if (arr[mid] < key) {\\n                start = mid+1;\\n            } else {\\n                end = mid-1;\\n            }\\n            mid = start + (end - start) / 2;\\n        }\\n        return false;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int start = 0, end = row - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target >= matrix[mid][0] && target <= matrix[mid][col - 1]) {\\n                return binarySearchInColumn(matrix[mid], col, target);\\n            }\\n            if (matrix[mid][0] < target) {\\n                 start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn got it after two tries after thinking it was too hard last year ;D\nTIP:\nBinary Search to find the list the target might be in.\nBinary Search again to browse the selected list for the target"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "If we use even linear search too \\nfirst time it iterate the coloumn and thenn after finding specific row iterate from back until we found the target in same row \\nthen i think even wordt case Time Complexity would be O(m+n)  why everyone is saying O(m*n) for linear approach \\nCan anyone please explain .It would really help "
                    },
                    {
                        "username": "Nameresu",
                        "content": "I wrote 2 versions of the method to solve this problem, and I am confused why both of them have same time complexity.\n\nSuppose the row of 2D matrix is *n*, and column of 2D matrix is *m*\n\nMethod 1: binary search the whole 2D matrix\nThis method is to search the target by binary search in the whole 2D matrix which means searching in *m* * *n* elements, and because we search in *m* * *n* elements, so the time complexity is O(lg *nm*).\n\nMethod 2: Search the row that the target should be located, and then search in this row.\nFirst, we search the minimal value *d* that is greater or equal than the target in each row's last element (matrix[0][*m*-1], matrix[1][*m*-1], ..., matrix[*n*-1][*m*-1]), and it takes O(lg *n*) time.\nSecondly, the row which *d* is located is also the target located, otherwise the target would not in matrix, then we just search in this row, it takes O (log *m*) time.\nSo, the time complexity is O (lg *n* + lg *m*) = O (lg *nm*) \n\nThe question is, Method 1 searching the target in all elements in the matrix (*mn* elements), but Method 2 just first search in *n* elements, and then search in *m* elements secondly, which means \"it only search in *n* + *m* elements\". Why do both of these 2 methods still hold the same time complexity? Is my analysis wrong?"
                    },
                    {
                        "username": "dpw82",
                        "content": "The concept of this problem is very simple but I am still messing up the indexing. m1, m2 is midpoint. e1, e2 is end. I think it works without a b1, b2 for beginning. I am getting TLE. Help debugging....\n\n `\nwhile(m1 != e1){\n            if(target < matrix[m1][m2]){\n                e1 = m1;\n                e2 = m2;\n                m1/=2;\n                m2/=2;\n            } else if (target > matrix[m1][m2]){\n                m2 = (e2 - m2)/2;\n                m1 = (e1 - m2)/2;\n            }\n            if(matrix[m1][m2] == target){\n                return true;\n            }\n }\n\n`"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "We need to find the row which contains target. it will take O(m), so First we need to find how many rows and columns are there and search for the target in that row -> ( target is >= row starting element AND target<=row last element ). \\nif the above condition is TRUE then we can go to next step.\\nafter finding a row then perform binary search on that row this will take O(log n);\\nso the complexity will be O(m+log n);\\nso this complexity is smaller then the given complexity O(m*n);"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "[@serkora](/serkora) Thanks for the help"
                    },
                    {
                        "username": "serkora",
                        "content": "Unless they changed the description within the last two hours, the given complexity is O(**log**(mn)), **not** O(mn). You don't need to find the row linearly, you can use binary search as well, making it O(log(m) + log(n)), which is the same as the required log(mn)."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "You need to do 2 binary searches\\n1) First one should be to find the row. compare target with matrix[row][0] and matrix[row][matrix[0].size() - 1]\\n\\n2) Once you find the row then the second binary search would be the classical 1D binary search which we are remarkably aware "
                    },
                    {
                        "username": "SG-C",
                        "content": "ha ha easy !"
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "The key point of this solution is if we start finding from top left corner or bottom right corner we can not perform binary search because for top left index you will find every value bigger in both l adown and right and the opposite also happens for the right bottom index so we have to start from either top right or bottom left"
                    }
                ]
            },
            {
                "id": 2012419,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach).\\n**\\n\\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\\n\\n\\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\\n\\n\\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it\\'s use cases.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int x = 0;\\n        int y= m-1;\\n\\n//Binary Search for Row\\n# heading\\n        while(x<y){\\n            int mid = x+(y-x)/2;\\n            if(mid >= m ) break;\\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\\n                x=mid;\\n                break;\\n        }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\\n                x=mid;\\n                break;\\n            }else if(matrix[mid][n-1]<target){\\n                if(mid+1>=m){\\n                    break;\\n                }\\n                 x=mid+1;\\n            }else if(matrix[mid][n-1]>target){\\n                y=mid-1;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n//Binary Search for Column\\n            if (matrix[x][n - 1] >= target) {\\n        int left = 0;\\n        int right = n-1;\\n        \\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (matrix[x][mid] == target) {\\n                return true;\\n            } else if (matrix[x][mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n            }\\n        // }\\n                return false;\\n    }\\n};"
                    },
                    {
                        "username": "PranavChindage",
                        "content": "More faster code :  Searching a element in row using binary search and extracting an array(arr) where that row element is first element of arr and arr[column-1] is last . Then searching target element in arr.\\n\\nclass Solution {\\npublic:\\n    bool binarySearchInColumn(vector<int>& arr, int col, int key) {\\n        int start = 0, end = col - 1;\\n        int mid = start + (end - start) / 2;\\n        \\n        while (start <= end){\\n            if (arr[mid] == key) {\\n                return true; \\n            }\\n            if (arr[mid] < key) {\\n                start = mid+1;\\n            } else {\\n                end = mid-1;\\n            }\\n            mid = start + (end - start) / 2;\\n        }\\n        return false;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int start = 0, end = row - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target >= matrix[mid][0] && target <= matrix[mid][col - 1]) {\\n                return binarySearchInColumn(matrix[mid], col, target);\\n            }\\n            if (matrix[mid][0] < target) {\\n                 start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn got it after two tries after thinking it was too hard last year ;D\nTIP:\nBinary Search to find the list the target might be in.\nBinary Search again to browse the selected list for the target"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "If we use even linear search too \\nfirst time it iterate the coloumn and thenn after finding specific row iterate from back until we found the target in same row \\nthen i think even wordt case Time Complexity would be O(m+n)  why everyone is saying O(m*n) for linear approach \\nCan anyone please explain .It would really help "
                    },
                    {
                        "username": "Nameresu",
                        "content": "I wrote 2 versions of the method to solve this problem, and I am confused why both of them have same time complexity.\n\nSuppose the row of 2D matrix is *n*, and column of 2D matrix is *m*\n\nMethod 1: binary search the whole 2D matrix\nThis method is to search the target by binary search in the whole 2D matrix which means searching in *m* * *n* elements, and because we search in *m* * *n* elements, so the time complexity is O(lg *nm*).\n\nMethod 2: Search the row that the target should be located, and then search in this row.\nFirst, we search the minimal value *d* that is greater or equal than the target in each row's last element (matrix[0][*m*-1], matrix[1][*m*-1], ..., matrix[*n*-1][*m*-1]), and it takes O(lg *n*) time.\nSecondly, the row which *d* is located is also the target located, otherwise the target would not in matrix, then we just search in this row, it takes O (log *m*) time.\nSo, the time complexity is O (lg *n* + lg *m*) = O (lg *nm*) \n\nThe question is, Method 1 searching the target in all elements in the matrix (*mn* elements), but Method 2 just first search in *n* elements, and then search in *m* elements secondly, which means \"it only search in *n* + *m* elements\". Why do both of these 2 methods still hold the same time complexity? Is my analysis wrong?"
                    },
                    {
                        "username": "dpw82",
                        "content": "The concept of this problem is very simple but I am still messing up the indexing. m1, m2 is midpoint. e1, e2 is end. I think it works without a b1, b2 for beginning. I am getting TLE. Help debugging....\n\n `\nwhile(m1 != e1){\n            if(target < matrix[m1][m2]){\n                e1 = m1;\n                e2 = m2;\n                m1/=2;\n                m2/=2;\n            } else if (target > matrix[m1][m2]){\n                m2 = (e2 - m2)/2;\n                m1 = (e1 - m2)/2;\n            }\n            if(matrix[m1][m2] == target){\n                return true;\n            }\n }\n\n`"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "We need to find the row which contains target. it will take O(m), so First we need to find how many rows and columns are there and search for the target in that row -> ( target is >= row starting element AND target<=row last element ). \\nif the above condition is TRUE then we can go to next step.\\nafter finding a row then perform binary search on that row this will take O(log n);\\nso the complexity will be O(m+log n);\\nso this complexity is smaller then the given complexity O(m*n);"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "[@serkora](/serkora) Thanks for the help"
                    },
                    {
                        "username": "serkora",
                        "content": "Unless they changed the description within the last two hours, the given complexity is O(**log**(mn)), **not** O(mn). You don't need to find the row linearly, you can use binary search as well, making it O(log(m) + log(n)), which is the same as the required log(mn)."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "You need to do 2 binary searches\\n1) First one should be to find the row. compare target with matrix[row][0] and matrix[row][matrix[0].size() - 1]\\n\\n2) Once you find the row then the second binary search would be the classical 1D binary search which we are remarkably aware "
                    },
                    {
                        "username": "SG-C",
                        "content": "ha ha easy !"
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "The key point of this solution is if we start finding from top left corner or bottom right corner we can not perform binary search because for top left index you will find every value bigger in both l adown and right and the opposite also happens for the right bottom index so we have to start from either top right or bottom left"
                    }
                ]
            },
            {
                "id": 2010844,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach).\\n**\\n\\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\\n\\n\\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\\n\\n\\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it\\'s use cases.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int x = 0;\\n        int y= m-1;\\n\\n//Binary Search for Row\\n# heading\\n        while(x<y){\\n            int mid = x+(y-x)/2;\\n            if(mid >= m ) break;\\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\\n                x=mid;\\n                break;\\n        }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\\n                x=mid;\\n                break;\\n            }else if(matrix[mid][n-1]<target){\\n                if(mid+1>=m){\\n                    break;\\n                }\\n                 x=mid+1;\\n            }else if(matrix[mid][n-1]>target){\\n                y=mid-1;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n//Binary Search for Column\\n            if (matrix[x][n - 1] >= target) {\\n        int left = 0;\\n        int right = n-1;\\n        \\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (matrix[x][mid] == target) {\\n                return true;\\n            } else if (matrix[x][mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n            }\\n        // }\\n                return false;\\n    }\\n};"
                    },
                    {
                        "username": "PranavChindage",
                        "content": "More faster code :  Searching a element in row using binary search and extracting an array(arr) where that row element is first element of arr and arr[column-1] is last . Then searching target element in arr.\\n\\nclass Solution {\\npublic:\\n    bool binarySearchInColumn(vector<int>& arr, int col, int key) {\\n        int start = 0, end = col - 1;\\n        int mid = start + (end - start) / 2;\\n        \\n        while (start <= end){\\n            if (arr[mid] == key) {\\n                return true; \\n            }\\n            if (arr[mid] < key) {\\n                start = mid+1;\\n            } else {\\n                end = mid-1;\\n            }\\n            mid = start + (end - start) / 2;\\n        }\\n        return false;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int start = 0, end = row - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target >= matrix[mid][0] && target <= matrix[mid][col - 1]) {\\n                return binarySearchInColumn(matrix[mid], col, target);\\n            }\\n            if (matrix[mid][0] < target) {\\n                 start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn got it after two tries after thinking it was too hard last year ;D\nTIP:\nBinary Search to find the list the target might be in.\nBinary Search again to browse the selected list for the target"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "If we use even linear search too \\nfirst time it iterate the coloumn and thenn after finding specific row iterate from back until we found the target in same row \\nthen i think even wordt case Time Complexity would be O(m+n)  why everyone is saying O(m*n) for linear approach \\nCan anyone please explain .It would really help "
                    },
                    {
                        "username": "Nameresu",
                        "content": "I wrote 2 versions of the method to solve this problem, and I am confused why both of them have same time complexity.\n\nSuppose the row of 2D matrix is *n*, and column of 2D matrix is *m*\n\nMethod 1: binary search the whole 2D matrix\nThis method is to search the target by binary search in the whole 2D matrix which means searching in *m* * *n* elements, and because we search in *m* * *n* elements, so the time complexity is O(lg *nm*).\n\nMethod 2: Search the row that the target should be located, and then search in this row.\nFirst, we search the minimal value *d* that is greater or equal than the target in each row's last element (matrix[0][*m*-1], matrix[1][*m*-1], ..., matrix[*n*-1][*m*-1]), and it takes O(lg *n*) time.\nSecondly, the row which *d* is located is also the target located, otherwise the target would not in matrix, then we just search in this row, it takes O (log *m*) time.\nSo, the time complexity is O (lg *n* + lg *m*) = O (lg *nm*) \n\nThe question is, Method 1 searching the target in all elements in the matrix (*mn* elements), but Method 2 just first search in *n* elements, and then search in *m* elements secondly, which means \"it only search in *n* + *m* elements\". Why do both of these 2 methods still hold the same time complexity? Is my analysis wrong?"
                    },
                    {
                        "username": "dpw82",
                        "content": "The concept of this problem is very simple but I am still messing up the indexing. m1, m2 is midpoint. e1, e2 is end. I think it works without a b1, b2 for beginning. I am getting TLE. Help debugging....\n\n `\nwhile(m1 != e1){\n            if(target < matrix[m1][m2]){\n                e1 = m1;\n                e2 = m2;\n                m1/=2;\n                m2/=2;\n            } else if (target > matrix[m1][m2]){\n                m2 = (e2 - m2)/2;\n                m1 = (e1 - m2)/2;\n            }\n            if(matrix[m1][m2] == target){\n                return true;\n            }\n }\n\n`"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "We need to find the row which contains target. it will take O(m), so First we need to find how many rows and columns are there and search for the target in that row -> ( target is >= row starting element AND target<=row last element ). \\nif the above condition is TRUE then we can go to next step.\\nafter finding a row then perform binary search on that row this will take O(log n);\\nso the complexity will be O(m+log n);\\nso this complexity is smaller then the given complexity O(m*n);"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "[@serkora](/serkora) Thanks for the help"
                    },
                    {
                        "username": "serkora",
                        "content": "Unless they changed the description within the last two hours, the given complexity is O(**log**(mn)), **not** O(mn). You don't need to find the row linearly, you can use binary search as well, making it O(log(m) + log(n)), which is the same as the required log(mn)."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "You need to do 2 binary searches\\n1) First one should be to find the row. compare target with matrix[row][0] and matrix[row][matrix[0].size() - 1]\\n\\n2) Once you find the row then the second binary search would be the classical 1D binary search which we are remarkably aware "
                    },
                    {
                        "username": "SG-C",
                        "content": "ha ha easy !"
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "The key point of this solution is if we start finding from top left corner or bottom right corner we can not perform binary search because for top left index you will find every value bigger in both l adown and right and the opposite also happens for the right bottom index so we have to start from either top right or bottom left"
                    }
                ]
            },
            {
                "id": 2004988,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach).\\n**\\n\\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\\n\\n\\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\\n\\n\\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it\\'s use cases.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int x = 0;\\n        int y= m-1;\\n\\n//Binary Search for Row\\n# heading\\n        while(x<y){\\n            int mid = x+(y-x)/2;\\n            if(mid >= m ) break;\\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\\n                x=mid;\\n                break;\\n        }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\\n                x=mid;\\n                break;\\n            }else if(matrix[mid][n-1]<target){\\n                if(mid+1>=m){\\n                    break;\\n                }\\n                 x=mid+1;\\n            }else if(matrix[mid][n-1]>target){\\n                y=mid-1;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n//Binary Search for Column\\n            if (matrix[x][n - 1] >= target) {\\n        int left = 0;\\n        int right = n-1;\\n        \\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (matrix[x][mid] == target) {\\n                return true;\\n            } else if (matrix[x][mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n            }\\n        // }\\n                return false;\\n    }\\n};"
                    },
                    {
                        "username": "PranavChindage",
                        "content": "More faster code :  Searching a element in row using binary search and extracting an array(arr) where that row element is first element of arr and arr[column-1] is last . Then searching target element in arr.\\n\\nclass Solution {\\npublic:\\n    bool binarySearchInColumn(vector<int>& arr, int col, int key) {\\n        int start = 0, end = col - 1;\\n        int mid = start + (end - start) / 2;\\n        \\n        while (start <= end){\\n            if (arr[mid] == key) {\\n                return true; \\n            }\\n            if (arr[mid] < key) {\\n                start = mid+1;\\n            } else {\\n                end = mid-1;\\n            }\\n            mid = start + (end - start) / 2;\\n        }\\n        return false;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int start = 0, end = row - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target >= matrix[mid][0] && target <= matrix[mid][col - 1]) {\\n                return binarySearchInColumn(matrix[mid], col, target);\\n            }\\n            if (matrix[mid][0] < target) {\\n                 start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn got it after two tries after thinking it was too hard last year ;D\nTIP:\nBinary Search to find the list the target might be in.\nBinary Search again to browse the selected list for the target"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "If we use even linear search too \\nfirst time it iterate the coloumn and thenn after finding specific row iterate from back until we found the target in same row \\nthen i think even wordt case Time Complexity would be O(m+n)  why everyone is saying O(m*n) for linear approach \\nCan anyone please explain .It would really help "
                    },
                    {
                        "username": "Nameresu",
                        "content": "I wrote 2 versions of the method to solve this problem, and I am confused why both of them have same time complexity.\n\nSuppose the row of 2D matrix is *n*, and column of 2D matrix is *m*\n\nMethod 1: binary search the whole 2D matrix\nThis method is to search the target by binary search in the whole 2D matrix which means searching in *m* * *n* elements, and because we search in *m* * *n* elements, so the time complexity is O(lg *nm*).\n\nMethod 2: Search the row that the target should be located, and then search in this row.\nFirst, we search the minimal value *d* that is greater or equal than the target in each row's last element (matrix[0][*m*-1], matrix[1][*m*-1], ..., matrix[*n*-1][*m*-1]), and it takes O(lg *n*) time.\nSecondly, the row which *d* is located is also the target located, otherwise the target would not in matrix, then we just search in this row, it takes O (log *m*) time.\nSo, the time complexity is O (lg *n* + lg *m*) = O (lg *nm*) \n\nThe question is, Method 1 searching the target in all elements in the matrix (*mn* elements), but Method 2 just first search in *n* elements, and then search in *m* elements secondly, which means \"it only search in *n* + *m* elements\". Why do both of these 2 methods still hold the same time complexity? Is my analysis wrong?"
                    },
                    {
                        "username": "dpw82",
                        "content": "The concept of this problem is very simple but I am still messing up the indexing. m1, m2 is midpoint. e1, e2 is end. I think it works without a b1, b2 for beginning. I am getting TLE. Help debugging....\n\n `\nwhile(m1 != e1){\n            if(target < matrix[m1][m2]){\n                e1 = m1;\n                e2 = m2;\n                m1/=2;\n                m2/=2;\n            } else if (target > matrix[m1][m2]){\n                m2 = (e2 - m2)/2;\n                m1 = (e1 - m2)/2;\n            }\n            if(matrix[m1][m2] == target){\n                return true;\n            }\n }\n\n`"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "We need to find the row which contains target. it will take O(m), so First we need to find how many rows and columns are there and search for the target in that row -> ( target is >= row starting element AND target<=row last element ). \\nif the above condition is TRUE then we can go to next step.\\nafter finding a row then perform binary search on that row this will take O(log n);\\nso the complexity will be O(m+log n);\\nso this complexity is smaller then the given complexity O(m*n);"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "[@serkora](/serkora) Thanks for the help"
                    },
                    {
                        "username": "serkora",
                        "content": "Unless they changed the description within the last two hours, the given complexity is O(**log**(mn)), **not** O(mn). You don't need to find the row linearly, you can use binary search as well, making it O(log(m) + log(n)), which is the same as the required log(mn)."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "You need to do 2 binary searches\\n1) First one should be to find the row. compare target with matrix[row][0] and matrix[row][matrix[0].size() - 1]\\n\\n2) Once you find the row then the second binary search would be the classical 1D binary search which we are remarkably aware "
                    },
                    {
                        "username": "SG-C",
                        "content": "ha ha easy !"
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "The key point of this solution is if we start finding from top left corner or bottom right corner we can not perform binary search because for top left index you will find every value bigger in both l adown and right and the opposite also happens for the right bottom index so we have to start from either top right or bottom left"
                    }
                ]
            },
            {
                "id": 2004862,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach).\\n**\\n\\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\\n\\n\\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\\n\\n\\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it\\'s use cases.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int x = 0;\\n        int y= m-1;\\n\\n//Binary Search for Row\\n# heading\\n        while(x<y){\\n            int mid = x+(y-x)/2;\\n            if(mid >= m ) break;\\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\\n                x=mid;\\n                break;\\n        }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\\n                x=mid;\\n                break;\\n            }else if(matrix[mid][n-1]<target){\\n                if(mid+1>=m){\\n                    break;\\n                }\\n                 x=mid+1;\\n            }else if(matrix[mid][n-1]>target){\\n                y=mid-1;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n//Binary Search for Column\\n            if (matrix[x][n - 1] >= target) {\\n        int left = 0;\\n        int right = n-1;\\n        \\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (matrix[x][mid] == target) {\\n                return true;\\n            } else if (matrix[x][mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n            }\\n        // }\\n                return false;\\n    }\\n};"
                    },
                    {
                        "username": "PranavChindage",
                        "content": "More faster code :  Searching a element in row using binary search and extracting an array(arr) where that row element is first element of arr and arr[column-1] is last . Then searching target element in arr.\\n\\nclass Solution {\\npublic:\\n    bool binarySearchInColumn(vector<int>& arr, int col, int key) {\\n        int start = 0, end = col - 1;\\n        int mid = start + (end - start) / 2;\\n        \\n        while (start <= end){\\n            if (arr[mid] == key) {\\n                return true; \\n            }\\n            if (arr[mid] < key) {\\n                start = mid+1;\\n            } else {\\n                end = mid-1;\\n            }\\n            mid = start + (end - start) / 2;\\n        }\\n        return false;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int start = 0, end = row - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target >= matrix[mid][0] && target <= matrix[mid][col - 1]) {\\n                return binarySearchInColumn(matrix[mid], col, target);\\n            }\\n            if (matrix[mid][0] < target) {\\n                 start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn got it after two tries after thinking it was too hard last year ;D\nTIP:\nBinary Search to find the list the target might be in.\nBinary Search again to browse the selected list for the target"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "If we use even linear search too \\nfirst time it iterate the coloumn and thenn after finding specific row iterate from back until we found the target in same row \\nthen i think even wordt case Time Complexity would be O(m+n)  why everyone is saying O(m*n) for linear approach \\nCan anyone please explain .It would really help "
                    },
                    {
                        "username": "Nameresu",
                        "content": "I wrote 2 versions of the method to solve this problem, and I am confused why both of them have same time complexity.\n\nSuppose the row of 2D matrix is *n*, and column of 2D matrix is *m*\n\nMethod 1: binary search the whole 2D matrix\nThis method is to search the target by binary search in the whole 2D matrix which means searching in *m* * *n* elements, and because we search in *m* * *n* elements, so the time complexity is O(lg *nm*).\n\nMethod 2: Search the row that the target should be located, and then search in this row.\nFirst, we search the minimal value *d* that is greater or equal than the target in each row's last element (matrix[0][*m*-1], matrix[1][*m*-1], ..., matrix[*n*-1][*m*-1]), and it takes O(lg *n*) time.\nSecondly, the row which *d* is located is also the target located, otherwise the target would not in matrix, then we just search in this row, it takes O (log *m*) time.\nSo, the time complexity is O (lg *n* + lg *m*) = O (lg *nm*) \n\nThe question is, Method 1 searching the target in all elements in the matrix (*mn* elements), but Method 2 just first search in *n* elements, and then search in *m* elements secondly, which means \"it only search in *n* + *m* elements\". Why do both of these 2 methods still hold the same time complexity? Is my analysis wrong?"
                    },
                    {
                        "username": "dpw82",
                        "content": "The concept of this problem is very simple but I am still messing up the indexing. m1, m2 is midpoint. e1, e2 is end. I think it works without a b1, b2 for beginning. I am getting TLE. Help debugging....\n\n `\nwhile(m1 != e1){\n            if(target < matrix[m1][m2]){\n                e1 = m1;\n                e2 = m2;\n                m1/=2;\n                m2/=2;\n            } else if (target > matrix[m1][m2]){\n                m2 = (e2 - m2)/2;\n                m1 = (e1 - m2)/2;\n            }\n            if(matrix[m1][m2] == target){\n                return true;\n            }\n }\n\n`"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "We need to find the row which contains target. it will take O(m), so First we need to find how many rows and columns are there and search for the target in that row -> ( target is >= row starting element AND target<=row last element ). \\nif the above condition is TRUE then we can go to next step.\\nafter finding a row then perform binary search on that row this will take O(log n);\\nso the complexity will be O(m+log n);\\nso this complexity is smaller then the given complexity O(m*n);"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "[@serkora](/serkora) Thanks for the help"
                    },
                    {
                        "username": "serkora",
                        "content": "Unless they changed the description within the last two hours, the given complexity is O(**log**(mn)), **not** O(mn). You don't need to find the row linearly, you can use binary search as well, making it O(log(m) + log(n)), which is the same as the required log(mn)."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "You need to do 2 binary searches\\n1) First one should be to find the row. compare target with matrix[row][0] and matrix[row][matrix[0].size() - 1]\\n\\n2) Once you find the row then the second binary search would be the classical 1D binary search which we are remarkably aware "
                    },
                    {
                        "username": "SG-C",
                        "content": "ha ha easy !"
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "The key point of this solution is if we start finding from top left corner or bottom right corner we can not perform binary search because for top left index you will find every value bigger in both l adown and right and the opposite also happens for the right bottom index so we have to start from either top right or bottom left"
                    }
                ]
            },
            {
                "id": 2004858,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach).\\n**\\n\\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\\n\\n\\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\\n\\n\\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it\\'s use cases.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int x = 0;\\n        int y= m-1;\\n\\n//Binary Search for Row\\n# heading\\n        while(x<y){\\n            int mid = x+(y-x)/2;\\n            if(mid >= m ) break;\\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\\n                x=mid;\\n                break;\\n        }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\\n                x=mid;\\n                break;\\n            }else if(matrix[mid][n-1]<target){\\n                if(mid+1>=m){\\n                    break;\\n                }\\n                 x=mid+1;\\n            }else if(matrix[mid][n-1]>target){\\n                y=mid-1;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n//Binary Search for Column\\n            if (matrix[x][n - 1] >= target) {\\n        int left = 0;\\n        int right = n-1;\\n        \\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (matrix[x][mid] == target) {\\n                return true;\\n            } else if (matrix[x][mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n            }\\n        // }\\n                return false;\\n    }\\n};"
                    },
                    {
                        "username": "PranavChindage",
                        "content": "More faster code :  Searching a element in row using binary search and extracting an array(arr) where that row element is first element of arr and arr[column-1] is last . Then searching target element in arr.\\n\\nclass Solution {\\npublic:\\n    bool binarySearchInColumn(vector<int>& arr, int col, int key) {\\n        int start = 0, end = col - 1;\\n        int mid = start + (end - start) / 2;\\n        \\n        while (start <= end){\\n            if (arr[mid] == key) {\\n                return true; \\n            }\\n            if (arr[mid] < key) {\\n                start = mid+1;\\n            } else {\\n                end = mid-1;\\n            }\\n            mid = start + (end - start) / 2;\\n        }\\n        return false;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int start = 0, end = row - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target >= matrix[mid][0] && target <= matrix[mid][col - 1]) {\\n                return binarySearchInColumn(matrix[mid], col, target);\\n            }\\n            if (matrix[mid][0] < target) {\\n                 start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn got it after two tries after thinking it was too hard last year ;D\nTIP:\nBinary Search to find the list the target might be in.\nBinary Search again to browse the selected list for the target"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "If we use even linear search too \\nfirst time it iterate the coloumn and thenn after finding specific row iterate from back until we found the target in same row \\nthen i think even wordt case Time Complexity would be O(m+n)  why everyone is saying O(m*n) for linear approach \\nCan anyone please explain .It would really help "
                    },
                    {
                        "username": "Nameresu",
                        "content": "I wrote 2 versions of the method to solve this problem, and I am confused why both of them have same time complexity.\n\nSuppose the row of 2D matrix is *n*, and column of 2D matrix is *m*\n\nMethod 1: binary search the whole 2D matrix\nThis method is to search the target by binary search in the whole 2D matrix which means searching in *m* * *n* elements, and because we search in *m* * *n* elements, so the time complexity is O(lg *nm*).\n\nMethod 2: Search the row that the target should be located, and then search in this row.\nFirst, we search the minimal value *d* that is greater or equal than the target in each row's last element (matrix[0][*m*-1], matrix[1][*m*-1], ..., matrix[*n*-1][*m*-1]), and it takes O(lg *n*) time.\nSecondly, the row which *d* is located is also the target located, otherwise the target would not in matrix, then we just search in this row, it takes O (log *m*) time.\nSo, the time complexity is O (lg *n* + lg *m*) = O (lg *nm*) \n\nThe question is, Method 1 searching the target in all elements in the matrix (*mn* elements), but Method 2 just first search in *n* elements, and then search in *m* elements secondly, which means \"it only search in *n* + *m* elements\". Why do both of these 2 methods still hold the same time complexity? Is my analysis wrong?"
                    },
                    {
                        "username": "dpw82",
                        "content": "The concept of this problem is very simple but I am still messing up the indexing. m1, m2 is midpoint. e1, e2 is end. I think it works without a b1, b2 for beginning. I am getting TLE. Help debugging....\n\n `\nwhile(m1 != e1){\n            if(target < matrix[m1][m2]){\n                e1 = m1;\n                e2 = m2;\n                m1/=2;\n                m2/=2;\n            } else if (target > matrix[m1][m2]){\n                m2 = (e2 - m2)/2;\n                m1 = (e1 - m2)/2;\n            }\n            if(matrix[m1][m2] == target){\n                return true;\n            }\n }\n\n`"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "We need to find the row which contains target. it will take O(m), so First we need to find how many rows and columns are there and search for the target in that row -> ( target is >= row starting element AND target<=row last element ). \\nif the above condition is TRUE then we can go to next step.\\nafter finding a row then perform binary search on that row this will take O(log n);\\nso the complexity will be O(m+log n);\\nso this complexity is smaller then the given complexity O(m*n);"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "[@serkora](/serkora) Thanks for the help"
                    },
                    {
                        "username": "serkora",
                        "content": "Unless they changed the description within the last two hours, the given complexity is O(**log**(mn)), **not** O(mn). You don't need to find the row linearly, you can use binary search as well, making it O(log(m) + log(n)), which is the same as the required log(mn)."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "You need to do 2 binary searches\\n1) First one should be to find the row. compare target with matrix[row][0] and matrix[row][matrix[0].size() - 1]\\n\\n2) Once you find the row then the second binary search would be the classical 1D binary search which we are remarkably aware "
                    },
                    {
                        "username": "SG-C",
                        "content": "ha ha easy !"
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "The key point of this solution is if we start finding from top left corner or bottom right corner we can not perform binary search because for top left index you will find every value bigger in both l adown and right and the opposite also happens for the right bottom index so we have to start from either top right or bottom left"
                    }
                ]
            },
            {
                "id": 2004769,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach).\\n**\\n\\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\\n\\n\\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\\n\\n\\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it\\'s use cases.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int x = 0;\\n        int y= m-1;\\n\\n//Binary Search for Row\\n# heading\\n        while(x<y){\\n            int mid = x+(y-x)/2;\\n            if(mid >= m ) break;\\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\\n                x=mid;\\n                break;\\n        }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\\n                x=mid;\\n                break;\\n            }else if(matrix[mid][n-1]<target){\\n                if(mid+1>=m){\\n                    break;\\n                }\\n                 x=mid+1;\\n            }else if(matrix[mid][n-1]>target){\\n                y=mid-1;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n//Binary Search for Column\\n            if (matrix[x][n - 1] >= target) {\\n        int left = 0;\\n        int right = n-1;\\n        \\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (matrix[x][mid] == target) {\\n                return true;\\n            } else if (matrix[x][mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n            }\\n        // }\\n                return false;\\n    }\\n};"
                    },
                    {
                        "username": "PranavChindage",
                        "content": "More faster code :  Searching a element in row using binary search and extracting an array(arr) where that row element is first element of arr and arr[column-1] is last . Then searching target element in arr.\\n\\nclass Solution {\\npublic:\\n    bool binarySearchInColumn(vector<int>& arr, int col, int key) {\\n        int start = 0, end = col - 1;\\n        int mid = start + (end - start) / 2;\\n        \\n        while (start <= end){\\n            if (arr[mid] == key) {\\n                return true; \\n            }\\n            if (arr[mid] < key) {\\n                start = mid+1;\\n            } else {\\n                end = mid-1;\\n            }\\n            mid = start + (end - start) / 2;\\n        }\\n        return false;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int start = 0, end = row - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target >= matrix[mid][0] && target <= matrix[mid][col - 1]) {\\n                return binarySearchInColumn(matrix[mid], col, target);\\n            }\\n            if (matrix[mid][0] < target) {\\n                 start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn got it after two tries after thinking it was too hard last year ;D\nTIP:\nBinary Search to find the list the target might be in.\nBinary Search again to browse the selected list for the target"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "If we use even linear search too \\nfirst time it iterate the coloumn and thenn after finding specific row iterate from back until we found the target in same row \\nthen i think even wordt case Time Complexity would be O(m+n)  why everyone is saying O(m*n) for linear approach \\nCan anyone please explain .It would really help "
                    },
                    {
                        "username": "Nameresu",
                        "content": "I wrote 2 versions of the method to solve this problem, and I am confused why both of them have same time complexity.\n\nSuppose the row of 2D matrix is *n*, and column of 2D matrix is *m*\n\nMethod 1: binary search the whole 2D matrix\nThis method is to search the target by binary search in the whole 2D matrix which means searching in *m* * *n* elements, and because we search in *m* * *n* elements, so the time complexity is O(lg *nm*).\n\nMethod 2: Search the row that the target should be located, and then search in this row.\nFirst, we search the minimal value *d* that is greater or equal than the target in each row's last element (matrix[0][*m*-1], matrix[1][*m*-1], ..., matrix[*n*-1][*m*-1]), and it takes O(lg *n*) time.\nSecondly, the row which *d* is located is also the target located, otherwise the target would not in matrix, then we just search in this row, it takes O (log *m*) time.\nSo, the time complexity is O (lg *n* + lg *m*) = O (lg *nm*) \n\nThe question is, Method 1 searching the target in all elements in the matrix (*mn* elements), but Method 2 just first search in *n* elements, and then search in *m* elements secondly, which means \"it only search in *n* + *m* elements\". Why do both of these 2 methods still hold the same time complexity? Is my analysis wrong?"
                    },
                    {
                        "username": "dpw82",
                        "content": "The concept of this problem is very simple but I am still messing up the indexing. m1, m2 is midpoint. e1, e2 is end. I think it works without a b1, b2 for beginning. I am getting TLE. Help debugging....\n\n `\nwhile(m1 != e1){\n            if(target < matrix[m1][m2]){\n                e1 = m1;\n                e2 = m2;\n                m1/=2;\n                m2/=2;\n            } else if (target > matrix[m1][m2]){\n                m2 = (e2 - m2)/2;\n                m1 = (e1 - m2)/2;\n            }\n            if(matrix[m1][m2] == target){\n                return true;\n            }\n }\n\n`"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "We need to find the row which contains target. it will take O(m), so First we need to find how many rows and columns are there and search for the target in that row -> ( target is >= row starting element AND target<=row last element ). \\nif the above condition is TRUE then we can go to next step.\\nafter finding a row then perform binary search on that row this will take O(log n);\\nso the complexity will be O(m+log n);\\nso this complexity is smaller then the given complexity O(m*n);"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "[@serkora](/serkora) Thanks for the help"
                    },
                    {
                        "username": "serkora",
                        "content": "Unless they changed the description within the last two hours, the given complexity is O(**log**(mn)), **not** O(mn). You don't need to find the row linearly, you can use binary search as well, making it O(log(m) + log(n)), which is the same as the required log(mn)."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "You need to do 2 binary searches\\n1) First one should be to find the row. compare target with matrix[row][0] and matrix[row][matrix[0].size() - 1]\\n\\n2) Once you find the row then the second binary search would be the classical 1D binary search which we are remarkably aware "
                    },
                    {
                        "username": "SG-C",
                        "content": "ha ha easy !"
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "The key point of this solution is if we start finding from top left corner or bottom right corner we can not perform binary search because for top left index you will find every value bigger in both l adown and right and the opposite also happens for the right bottom index so we have to start from either top right or bottom left"
                    }
                ]
            },
            {
                "id": 2004681,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach).\\n**\\n\\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\\n\\n\\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\\n\\n\\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it\\'s use cases.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int x = 0;\\n        int y= m-1;\\n\\n//Binary Search for Row\\n# heading\\n        while(x<y){\\n            int mid = x+(y-x)/2;\\n            if(mid >= m ) break;\\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\\n                x=mid;\\n                break;\\n        }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\\n                x=mid;\\n                break;\\n            }else if(matrix[mid][n-1]<target){\\n                if(mid+1>=m){\\n                    break;\\n                }\\n                 x=mid+1;\\n            }else if(matrix[mid][n-1]>target){\\n                y=mid-1;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n//Binary Search for Column\\n            if (matrix[x][n - 1] >= target) {\\n        int left = 0;\\n        int right = n-1;\\n        \\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (matrix[x][mid] == target) {\\n                return true;\\n            } else if (matrix[x][mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n            }\\n        // }\\n                return false;\\n    }\\n};"
                    },
                    {
                        "username": "PranavChindage",
                        "content": "More faster code :  Searching a element in row using binary search and extracting an array(arr) where that row element is first element of arr and arr[column-1] is last . Then searching target element in arr.\\n\\nclass Solution {\\npublic:\\n    bool binarySearchInColumn(vector<int>& arr, int col, int key) {\\n        int start = 0, end = col - 1;\\n        int mid = start + (end - start) / 2;\\n        \\n        while (start <= end){\\n            if (arr[mid] == key) {\\n                return true; \\n            }\\n            if (arr[mid] < key) {\\n                start = mid+1;\\n            } else {\\n                end = mid-1;\\n            }\\n            mid = start + (end - start) / 2;\\n        }\\n        return false;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int start = 0, end = row - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target >= matrix[mid][0] && target <= matrix[mid][col - 1]) {\\n                return binarySearchInColumn(matrix[mid], col, target);\\n            }\\n            if (matrix[mid][0] < target) {\\n                 start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn got it after two tries after thinking it was too hard last year ;D\nTIP:\nBinary Search to find the list the target might be in.\nBinary Search again to browse the selected list for the target"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "If we use even linear search too \\nfirst time it iterate the coloumn and thenn after finding specific row iterate from back until we found the target in same row \\nthen i think even wordt case Time Complexity would be O(m+n)  why everyone is saying O(m*n) for linear approach \\nCan anyone please explain .It would really help "
                    },
                    {
                        "username": "Nameresu",
                        "content": "I wrote 2 versions of the method to solve this problem, and I am confused why both of them have same time complexity.\n\nSuppose the row of 2D matrix is *n*, and column of 2D matrix is *m*\n\nMethod 1: binary search the whole 2D matrix\nThis method is to search the target by binary search in the whole 2D matrix which means searching in *m* * *n* elements, and because we search in *m* * *n* elements, so the time complexity is O(lg *nm*).\n\nMethod 2: Search the row that the target should be located, and then search in this row.\nFirst, we search the minimal value *d* that is greater or equal than the target in each row's last element (matrix[0][*m*-1], matrix[1][*m*-1], ..., matrix[*n*-1][*m*-1]), and it takes O(lg *n*) time.\nSecondly, the row which *d* is located is also the target located, otherwise the target would not in matrix, then we just search in this row, it takes O (log *m*) time.\nSo, the time complexity is O (lg *n* + lg *m*) = O (lg *nm*) \n\nThe question is, Method 1 searching the target in all elements in the matrix (*mn* elements), but Method 2 just first search in *n* elements, and then search in *m* elements secondly, which means \"it only search in *n* + *m* elements\". Why do both of these 2 methods still hold the same time complexity? Is my analysis wrong?"
                    },
                    {
                        "username": "dpw82",
                        "content": "The concept of this problem is very simple but I am still messing up the indexing. m1, m2 is midpoint. e1, e2 is end. I think it works without a b1, b2 for beginning. I am getting TLE. Help debugging....\n\n `\nwhile(m1 != e1){\n            if(target < matrix[m1][m2]){\n                e1 = m1;\n                e2 = m2;\n                m1/=2;\n                m2/=2;\n            } else if (target > matrix[m1][m2]){\n                m2 = (e2 - m2)/2;\n                m1 = (e1 - m2)/2;\n            }\n            if(matrix[m1][m2] == target){\n                return true;\n            }\n }\n\n`"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "We need to find the row which contains target. it will take O(m), so First we need to find how many rows and columns are there and search for the target in that row -> ( target is >= row starting element AND target<=row last element ). \\nif the above condition is TRUE then we can go to next step.\\nafter finding a row then perform binary search on that row this will take O(log n);\\nso the complexity will be O(m+log n);\\nso this complexity is smaller then the given complexity O(m*n);"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "[@serkora](/serkora) Thanks for the help"
                    },
                    {
                        "username": "serkora",
                        "content": "Unless they changed the description within the last two hours, the given complexity is O(**log**(mn)), **not** O(mn). You don't need to find the row linearly, you can use binary search as well, making it O(log(m) + log(n)), which is the same as the required log(mn)."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "You need to do 2 binary searches\\n1) First one should be to find the row. compare target with matrix[row][0] and matrix[row][matrix[0].size() - 1]\\n\\n2) Once you find the row then the second binary search would be the classical 1D binary search which we are remarkably aware "
                    },
                    {
                        "username": "SG-C",
                        "content": "ha ha easy !"
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "The key point of this solution is if we start finding from top left corner or bottom right corner we can not perform binary search because for top left index you will find every value bigger in both l adown and right and the opposite also happens for the right bottom index so we have to start from either top right or bottom left"
                    }
                ]
            },
            {
                "id": 2004564,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach).\\n**\\n\\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\\n\\n\\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\\n\\n\\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it\\'s use cases.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int x = 0;\\n        int y= m-1;\\n\\n//Binary Search for Row\\n# heading\\n        while(x<y){\\n            int mid = x+(y-x)/2;\\n            if(mid >= m ) break;\\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\\n                x=mid;\\n                break;\\n        }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\\n                x=mid;\\n                break;\\n            }else if(matrix[mid][n-1]<target){\\n                if(mid+1>=m){\\n                    break;\\n                }\\n                 x=mid+1;\\n            }else if(matrix[mid][n-1]>target){\\n                y=mid-1;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n//Binary Search for Column\\n            if (matrix[x][n - 1] >= target) {\\n        int left = 0;\\n        int right = n-1;\\n        \\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (matrix[x][mid] == target) {\\n                return true;\\n            } else if (matrix[x][mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n            }\\n        // }\\n                return false;\\n    }\\n};"
                    },
                    {
                        "username": "PranavChindage",
                        "content": "More faster code :  Searching a element in row using binary search and extracting an array(arr) where that row element is first element of arr and arr[column-1] is last . Then searching target element in arr.\\n\\nclass Solution {\\npublic:\\n    bool binarySearchInColumn(vector<int>& arr, int col, int key) {\\n        int start = 0, end = col - 1;\\n        int mid = start + (end - start) / 2;\\n        \\n        while (start <= end){\\n            if (arr[mid] == key) {\\n                return true; \\n            }\\n            if (arr[mid] < key) {\\n                start = mid+1;\\n            } else {\\n                end = mid-1;\\n            }\\n            mid = start + (end - start) / 2;\\n        }\\n        return false;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int start = 0, end = row - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target >= matrix[mid][0] && target <= matrix[mid][col - 1]) {\\n                return binarySearchInColumn(matrix[mid], col, target);\\n            }\\n            if (matrix[mid][0] < target) {\\n                 start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn got it after two tries after thinking it was too hard last year ;D\nTIP:\nBinary Search to find the list the target might be in.\nBinary Search again to browse the selected list for the target"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "If we use even linear search too \\nfirst time it iterate the coloumn and thenn after finding specific row iterate from back until we found the target in same row \\nthen i think even wordt case Time Complexity would be O(m+n)  why everyone is saying O(m*n) for linear approach \\nCan anyone please explain .It would really help "
                    },
                    {
                        "username": "Nameresu",
                        "content": "I wrote 2 versions of the method to solve this problem, and I am confused why both of them have same time complexity.\n\nSuppose the row of 2D matrix is *n*, and column of 2D matrix is *m*\n\nMethod 1: binary search the whole 2D matrix\nThis method is to search the target by binary search in the whole 2D matrix which means searching in *m* * *n* elements, and because we search in *m* * *n* elements, so the time complexity is O(lg *nm*).\n\nMethod 2: Search the row that the target should be located, and then search in this row.\nFirst, we search the minimal value *d* that is greater or equal than the target in each row's last element (matrix[0][*m*-1], matrix[1][*m*-1], ..., matrix[*n*-1][*m*-1]), and it takes O(lg *n*) time.\nSecondly, the row which *d* is located is also the target located, otherwise the target would not in matrix, then we just search in this row, it takes O (log *m*) time.\nSo, the time complexity is O (lg *n* + lg *m*) = O (lg *nm*) \n\nThe question is, Method 1 searching the target in all elements in the matrix (*mn* elements), but Method 2 just first search in *n* elements, and then search in *m* elements secondly, which means \"it only search in *n* + *m* elements\". Why do both of these 2 methods still hold the same time complexity? Is my analysis wrong?"
                    },
                    {
                        "username": "dpw82",
                        "content": "The concept of this problem is very simple but I am still messing up the indexing. m1, m2 is midpoint. e1, e2 is end. I think it works without a b1, b2 for beginning. I am getting TLE. Help debugging....\n\n `\nwhile(m1 != e1){\n            if(target < matrix[m1][m2]){\n                e1 = m1;\n                e2 = m2;\n                m1/=2;\n                m2/=2;\n            } else if (target > matrix[m1][m2]){\n                m2 = (e2 - m2)/2;\n                m1 = (e1 - m2)/2;\n            }\n            if(matrix[m1][m2] == target){\n                return true;\n            }\n }\n\n`"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "We need to find the row which contains target. it will take O(m), so First we need to find how many rows and columns are there and search for the target in that row -> ( target is >= row starting element AND target<=row last element ). \\nif the above condition is TRUE then we can go to next step.\\nafter finding a row then perform binary search on that row this will take O(log n);\\nso the complexity will be O(m+log n);\\nso this complexity is smaller then the given complexity O(m*n);"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "[@serkora](/serkora) Thanks for the help"
                    },
                    {
                        "username": "serkora",
                        "content": "Unless they changed the description within the last two hours, the given complexity is O(**log**(mn)), **not** O(mn). You don't need to find the row linearly, you can use binary search as well, making it O(log(m) + log(n)), which is the same as the required log(mn)."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "You need to do 2 binary searches\\n1) First one should be to find the row. compare target with matrix[row][0] and matrix[row][matrix[0].size() - 1]\\n\\n2) Once you find the row then the second binary search would be the classical 1D binary search which we are remarkably aware "
                    },
                    {
                        "username": "SG-C",
                        "content": "ha ha easy !"
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "The key point of this solution is if we start finding from top left corner or bottom right corner we can not perform binary search because for top left index you will find every value bigger in both l adown and right and the opposite also happens for the right bottom index so we have to start from either top right or bottom left"
                    }
                ]
            },
            {
                "id": 2004543,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "**(Not the most optimised approach, uploaded the code for discussion mostly and sugestions on this approach).\\n**\\n\\nAs it is already sorted , Binary Search can be useful. Naive method,with a ot of if and else for handling multiple cases and using Binary Search for seraching in Row and then column.\\n\\n\\nKindly mention, any further optimization, and if this approach is good or can be implemented in a shorter way or if time complexity can be reduced further.\\n\\n\\nAs of now it is O(log n + Ologm). Woud love to discuss time complexity of most optimized approach(O(n+m)) , and this code (O(logn +logm) and it\\'s use cases.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int x = 0;\\n        int y= m-1;\\n\\n//Binary Search for Row\\n# heading\\n        while(x<y){\\n            int mid = x+(y-x)/2;\\n            if(mid >= m ) break;\\n            if(matrix[mid][n-1]<=target && matrix[mid][0]>=target ){\\n                x=mid;\\n                break;\\n        }else if(matrix[mid][n-1]>=target && matrix[mid][0]<=target){\\n                x=mid;\\n                break;\\n            }else if(matrix[mid][n-1]<target){\\n                if(mid+1>=m){\\n                    break;\\n                }\\n                 x=mid+1;\\n            }else if(matrix[mid][n-1]>target){\\n                y=mid-1;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n//Binary Search for Column\\n            if (matrix[x][n - 1] >= target) {\\n        int left = 0;\\n        int right = n-1;\\n        \\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (matrix[x][mid] == target) {\\n                return true;\\n            } else if (matrix[x][mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n            }\\n        // }\\n                return false;\\n    }\\n};"
                    },
                    {
                        "username": "PranavChindage",
                        "content": "More faster code :  Searching a element in row using binary search and extracting an array(arr) where that row element is first element of arr and arr[column-1] is last . Then searching target element in arr.\\n\\nclass Solution {\\npublic:\\n    bool binarySearchInColumn(vector<int>& arr, int col, int key) {\\n        int start = 0, end = col - 1;\\n        int mid = start + (end - start) / 2;\\n        \\n        while (start <= end){\\n            if (arr[mid] == key) {\\n                return true; \\n            }\\n            if (arr[mid] < key) {\\n                start = mid+1;\\n            } else {\\n                end = mid-1;\\n            }\\n            mid = start + (end - start) / 2;\\n        }\\n        return false;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int start = 0, end = row - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n\\n            if (target >= matrix[mid][0] && target <= matrix[mid][col - 1]) {\\n                return binarySearchInColumn(matrix[mid], col, target);\\n            }\\n            if (matrix[mid][0] < target) {\\n                 start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn got it after two tries after thinking it was too hard last year ;D\nTIP:\nBinary Search to find the list the target might be in.\nBinary Search again to browse the selected list for the target"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "If we use even linear search too \\nfirst time it iterate the coloumn and thenn after finding specific row iterate from back until we found the target in same row \\nthen i think even wordt case Time Complexity would be O(m+n)  why everyone is saying O(m*n) for linear approach \\nCan anyone please explain .It would really help "
                    },
                    {
                        "username": "Nameresu",
                        "content": "I wrote 2 versions of the method to solve this problem, and I am confused why both of them have same time complexity.\n\nSuppose the row of 2D matrix is *n*, and column of 2D matrix is *m*\n\nMethod 1: binary search the whole 2D matrix\nThis method is to search the target by binary search in the whole 2D matrix which means searching in *m* * *n* elements, and because we search in *m* * *n* elements, so the time complexity is O(lg *nm*).\n\nMethod 2: Search the row that the target should be located, and then search in this row.\nFirst, we search the minimal value *d* that is greater or equal than the target in each row's last element (matrix[0][*m*-1], matrix[1][*m*-1], ..., matrix[*n*-1][*m*-1]), and it takes O(lg *n*) time.\nSecondly, the row which *d* is located is also the target located, otherwise the target would not in matrix, then we just search in this row, it takes O (log *m*) time.\nSo, the time complexity is O (lg *n* + lg *m*) = O (lg *nm*) \n\nThe question is, Method 1 searching the target in all elements in the matrix (*mn* elements), but Method 2 just first search in *n* elements, and then search in *m* elements secondly, which means \"it only search in *n* + *m* elements\". Why do both of these 2 methods still hold the same time complexity? Is my analysis wrong?"
                    },
                    {
                        "username": "dpw82",
                        "content": "The concept of this problem is very simple but I am still messing up the indexing. m1, m2 is midpoint. e1, e2 is end. I think it works without a b1, b2 for beginning. I am getting TLE. Help debugging....\n\n `\nwhile(m1 != e1){\n            if(target < matrix[m1][m2]){\n                e1 = m1;\n                e2 = m2;\n                m1/=2;\n                m2/=2;\n            } else if (target > matrix[m1][m2]){\n                m2 = (e2 - m2)/2;\n                m1 = (e1 - m2)/2;\n            }\n            if(matrix[m1][m2] == target){\n                return true;\n            }\n }\n\n`"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "We need to find the row which contains target. it will take O(m), so First we need to find how many rows and columns are there and search for the target in that row -> ( target is >= row starting element AND target<=row last element ). \\nif the above condition is TRUE then we can go to next step.\\nafter finding a row then perform binary search on that row this will take O(log n);\\nso the complexity will be O(m+log n);\\nso this complexity is smaller then the given complexity O(m*n);"
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "[@serkora](/serkora) Thanks for the help"
                    },
                    {
                        "username": "serkora",
                        "content": "Unless they changed the description within the last two hours, the given complexity is O(**log**(mn)), **not** O(mn). You don't need to find the row linearly, you can use binary search as well, making it O(log(m) + log(n)), which is the same as the required log(mn)."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "You need to do 2 binary searches\\n1) First one should be to find the row. compare target with matrix[row][0] and matrix[row][matrix[0].size() - 1]\\n\\n2) Once you find the row then the second binary search would be the classical 1D binary search which we are remarkably aware "
                    },
                    {
                        "username": "SG-C",
                        "content": "ha ha easy !"
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "The key point of this solution is if we start finding from top left corner or bottom right corner we can not perform binary search because for top left index you will find every value bigger in both l adown and right and the opposite also happens for the right bottom index so we have to start from either top right or bottom left"
                    }
                ]
            },
            {
                "id": 2004522,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "SORTED READ KRTE HI REMEMBER BINARY SEARCH "
                    },
                    {
                        "username": "RushN24",
                        "content": "Pretty new to DSA. Other than for the purpose of practice with binary search why would we want to use it in this situation instead of simply looping over the arrays in matrix, and then looping over the elements in each array (linear search)? The below answer solves the problem and is accepted. Should not allow it to be accepted. Why is binary search a better solution from a programming/functionality standpoint?\n\nPython3\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for nums in matrix:\n            for num in nums:\n                if num == target:\n                    return True"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@sikora92](/sikora92) thanks"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@vladimirkhlghatyan](/vladimirkhlghatyan) thank you, that makes sense. "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "If, for example, m*n == 10000, the number of steps needed for a linear search algorithm would be 10000 (worst case), and for a binary search ~13 steps (log10000). Obviously, binary search works many times faster."
                    },
                    {
                        "username": "sikora92",
                        "content": "Binary search is much faster on big arrays. This is the only reason. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Brute force is simple\\ntry using binary search"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "easy"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "I\\'m surprised this problem is considered medium difficulty. With basic knowledge of binary search and 2D matrix, it can be solved very easily."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I want time travel ticket for next question,\\nThis one quite easy as i didn\\'t checked solutions for 3 cases"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "so, binary search week it is\\n"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "I am happy that I was able to find that one on my own."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I thought question with `target sum` in a matrix"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "how to solve this problem\\n1 2 3\\n5 6 7\\n8 9 10\\n\\neach row is sorted so we can easily apply binary search algorithm.\\nin single array row look like.1 2 3 5 6 7 8 9 10\\nabove array index position start from 0 to n-1(ie 9)\\n\\nsuppose out target is 5 and its index position is 3\\nso use divide and mode operation on index position using column size\\nint col=matrix[mid/col][mid%col]\\ne.g= 3/3=1 and 3%3=0 using this approch we can find exact row and column position of number if matrix[mid/col][mid%col]>target\\nie target present at left side use end=mid-1 else\\nstart=mid+1 using this technique you can find target."
                    }
                ]
            },
            {
                "id": 2004370,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "SORTED READ KRTE HI REMEMBER BINARY SEARCH "
                    },
                    {
                        "username": "RushN24",
                        "content": "Pretty new to DSA. Other than for the purpose of practice with binary search why would we want to use it in this situation instead of simply looping over the arrays in matrix, and then looping over the elements in each array (linear search)? The below answer solves the problem and is accepted. Should not allow it to be accepted. Why is binary search a better solution from a programming/functionality standpoint?\n\nPython3\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for nums in matrix:\n            for num in nums:\n                if num == target:\n                    return True"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@sikora92](/sikora92) thanks"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@vladimirkhlghatyan](/vladimirkhlghatyan) thank you, that makes sense. "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "If, for example, m*n == 10000, the number of steps needed for a linear search algorithm would be 10000 (worst case), and for a binary search ~13 steps (log10000). Obviously, binary search works many times faster."
                    },
                    {
                        "username": "sikora92",
                        "content": "Binary search is much faster on big arrays. This is the only reason. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Brute force is simple\\ntry using binary search"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "easy"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "I\\'m surprised this problem is considered medium difficulty. With basic knowledge of binary search and 2D matrix, it can be solved very easily."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I want time travel ticket for next question,\\nThis one quite easy as i didn\\'t checked solutions for 3 cases"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "so, binary search week it is\\n"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "I am happy that I was able to find that one on my own."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I thought question with `target sum` in a matrix"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "how to solve this problem\\n1 2 3\\n5 6 7\\n8 9 10\\n\\neach row is sorted so we can easily apply binary search algorithm.\\nin single array row look like.1 2 3 5 6 7 8 9 10\\nabove array index position start from 0 to n-1(ie 9)\\n\\nsuppose out target is 5 and its index position is 3\\nso use divide and mode operation on index position using column size\\nint col=matrix[mid/col][mid%col]\\ne.g= 3/3=1 and 3%3=0 using this approch we can find exact row and column position of number if matrix[mid/col][mid%col]>target\\nie target present at left side use end=mid-1 else\\nstart=mid+1 using this technique you can find target."
                    }
                ]
            },
            {
                "id": 2004139,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "SORTED READ KRTE HI REMEMBER BINARY SEARCH "
                    },
                    {
                        "username": "RushN24",
                        "content": "Pretty new to DSA. Other than for the purpose of practice with binary search why would we want to use it in this situation instead of simply looping over the arrays in matrix, and then looping over the elements in each array (linear search)? The below answer solves the problem and is accepted. Should not allow it to be accepted. Why is binary search a better solution from a programming/functionality standpoint?\n\nPython3\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for nums in matrix:\n            for num in nums:\n                if num == target:\n                    return True"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@sikora92](/sikora92) thanks"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@vladimirkhlghatyan](/vladimirkhlghatyan) thank you, that makes sense. "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "If, for example, m*n == 10000, the number of steps needed for a linear search algorithm would be 10000 (worst case), and for a binary search ~13 steps (log10000). Obviously, binary search works many times faster."
                    },
                    {
                        "username": "sikora92",
                        "content": "Binary search is much faster on big arrays. This is the only reason. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Brute force is simple\\ntry using binary search"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "easy"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "I\\'m surprised this problem is considered medium difficulty. With basic knowledge of binary search and 2D matrix, it can be solved very easily."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I want time travel ticket for next question,\\nThis one quite easy as i didn\\'t checked solutions for 3 cases"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "so, binary search week it is\\n"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "I am happy that I was able to find that one on my own."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I thought question with `target sum` in a matrix"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "how to solve this problem\\n1 2 3\\n5 6 7\\n8 9 10\\n\\neach row is sorted so we can easily apply binary search algorithm.\\nin single array row look like.1 2 3 5 6 7 8 9 10\\nabove array index position start from 0 to n-1(ie 9)\\n\\nsuppose out target is 5 and its index position is 3\\nso use divide and mode operation on index position using column size\\nint col=matrix[mid/col][mid%col]\\ne.g= 3/3=1 and 3%3=0 using this approch we can find exact row and column position of number if matrix[mid/col][mid%col]>target\\nie target present at left side use end=mid-1 else\\nstart=mid+1 using this technique you can find target."
                    }
                ]
            },
            {
                "id": 2004109,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "SORTED READ KRTE HI REMEMBER BINARY SEARCH "
                    },
                    {
                        "username": "RushN24",
                        "content": "Pretty new to DSA. Other than for the purpose of practice with binary search why would we want to use it in this situation instead of simply looping over the arrays in matrix, and then looping over the elements in each array (linear search)? The below answer solves the problem and is accepted. Should not allow it to be accepted. Why is binary search a better solution from a programming/functionality standpoint?\n\nPython3\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for nums in matrix:\n            for num in nums:\n                if num == target:\n                    return True"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@sikora92](/sikora92) thanks"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@vladimirkhlghatyan](/vladimirkhlghatyan) thank you, that makes sense. "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "If, for example, m*n == 10000, the number of steps needed for a linear search algorithm would be 10000 (worst case), and for a binary search ~13 steps (log10000). Obviously, binary search works many times faster."
                    },
                    {
                        "username": "sikora92",
                        "content": "Binary search is much faster on big arrays. This is the only reason. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Brute force is simple\\ntry using binary search"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "easy"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "I\\'m surprised this problem is considered medium difficulty. With basic knowledge of binary search and 2D matrix, it can be solved very easily."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I want time travel ticket for next question,\\nThis one quite easy as i didn\\'t checked solutions for 3 cases"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "so, binary search week it is\\n"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "I am happy that I was able to find that one on my own."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I thought question with `target sum` in a matrix"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "how to solve this problem\\n1 2 3\\n5 6 7\\n8 9 10\\n\\neach row is sorted so we can easily apply binary search algorithm.\\nin single array row look like.1 2 3 5 6 7 8 9 10\\nabove array index position start from 0 to n-1(ie 9)\\n\\nsuppose out target is 5 and its index position is 3\\nso use divide and mode operation on index position using column size\\nint col=matrix[mid/col][mid%col]\\ne.g= 3/3=1 and 3%3=0 using this approch we can find exact row and column position of number if matrix[mid/col][mid%col]>target\\nie target present at left side use end=mid-1 else\\nstart=mid+1 using this technique you can find target."
                    }
                ]
            },
            {
                "id": 2004104,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "SORTED READ KRTE HI REMEMBER BINARY SEARCH "
                    },
                    {
                        "username": "RushN24",
                        "content": "Pretty new to DSA. Other than for the purpose of practice with binary search why would we want to use it in this situation instead of simply looping over the arrays in matrix, and then looping over the elements in each array (linear search)? The below answer solves the problem and is accepted. Should not allow it to be accepted. Why is binary search a better solution from a programming/functionality standpoint?\n\nPython3\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for nums in matrix:\n            for num in nums:\n                if num == target:\n                    return True"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@sikora92](/sikora92) thanks"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@vladimirkhlghatyan](/vladimirkhlghatyan) thank you, that makes sense. "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "If, for example, m*n == 10000, the number of steps needed for a linear search algorithm would be 10000 (worst case), and for a binary search ~13 steps (log10000). Obviously, binary search works many times faster."
                    },
                    {
                        "username": "sikora92",
                        "content": "Binary search is much faster on big arrays. This is the only reason. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Brute force is simple\\ntry using binary search"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "easy"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "I\\'m surprised this problem is considered medium difficulty. With basic knowledge of binary search and 2D matrix, it can be solved very easily."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I want time travel ticket for next question,\\nThis one quite easy as i didn\\'t checked solutions for 3 cases"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "so, binary search week it is\\n"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "I am happy that I was able to find that one on my own."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I thought question with `target sum` in a matrix"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "how to solve this problem\\n1 2 3\\n5 6 7\\n8 9 10\\n\\neach row is sorted so we can easily apply binary search algorithm.\\nin single array row look like.1 2 3 5 6 7 8 9 10\\nabove array index position start from 0 to n-1(ie 9)\\n\\nsuppose out target is 5 and its index position is 3\\nso use divide and mode operation on index position using column size\\nint col=matrix[mid/col][mid%col]\\ne.g= 3/3=1 and 3%3=0 using this approch we can find exact row and column position of number if matrix[mid/col][mid%col]>target\\nie target present at left side use end=mid-1 else\\nstart=mid+1 using this technique you can find target."
                    }
                ]
            },
            {
                "id": 2004026,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "SORTED READ KRTE HI REMEMBER BINARY SEARCH "
                    },
                    {
                        "username": "RushN24",
                        "content": "Pretty new to DSA. Other than for the purpose of practice with binary search why would we want to use it in this situation instead of simply looping over the arrays in matrix, and then looping over the elements in each array (linear search)? The below answer solves the problem and is accepted. Should not allow it to be accepted. Why is binary search a better solution from a programming/functionality standpoint?\n\nPython3\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for nums in matrix:\n            for num in nums:\n                if num == target:\n                    return True"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@sikora92](/sikora92) thanks"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@vladimirkhlghatyan](/vladimirkhlghatyan) thank you, that makes sense. "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "If, for example, m*n == 10000, the number of steps needed for a linear search algorithm would be 10000 (worst case), and for a binary search ~13 steps (log10000). Obviously, binary search works many times faster."
                    },
                    {
                        "username": "sikora92",
                        "content": "Binary search is much faster on big arrays. This is the only reason. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Brute force is simple\\ntry using binary search"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "easy"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "I\\'m surprised this problem is considered medium difficulty. With basic knowledge of binary search and 2D matrix, it can be solved very easily."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I want time travel ticket for next question,\\nThis one quite easy as i didn\\'t checked solutions for 3 cases"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "so, binary search week it is\\n"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "I am happy that I was able to find that one on my own."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I thought question with `target sum` in a matrix"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "how to solve this problem\\n1 2 3\\n5 6 7\\n8 9 10\\n\\neach row is sorted so we can easily apply binary search algorithm.\\nin single array row look like.1 2 3 5 6 7 8 9 10\\nabove array index position start from 0 to n-1(ie 9)\\n\\nsuppose out target is 5 and its index position is 3\\nso use divide and mode operation on index position using column size\\nint col=matrix[mid/col][mid%col]\\ne.g= 3/3=1 and 3%3=0 using this approch we can find exact row and column position of number if matrix[mid/col][mid%col]>target\\nie target present at left side use end=mid-1 else\\nstart=mid+1 using this technique you can find target."
                    }
                ]
            },
            {
                "id": 2003935,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "SORTED READ KRTE HI REMEMBER BINARY SEARCH "
                    },
                    {
                        "username": "RushN24",
                        "content": "Pretty new to DSA. Other than for the purpose of practice with binary search why would we want to use it in this situation instead of simply looping over the arrays in matrix, and then looping over the elements in each array (linear search)? The below answer solves the problem and is accepted. Should not allow it to be accepted. Why is binary search a better solution from a programming/functionality standpoint?\n\nPython3\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for nums in matrix:\n            for num in nums:\n                if num == target:\n                    return True"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@sikora92](/sikora92) thanks"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@vladimirkhlghatyan](/vladimirkhlghatyan) thank you, that makes sense. "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "If, for example, m*n == 10000, the number of steps needed for a linear search algorithm would be 10000 (worst case), and for a binary search ~13 steps (log10000). Obviously, binary search works many times faster."
                    },
                    {
                        "username": "sikora92",
                        "content": "Binary search is much faster on big arrays. This is the only reason. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Brute force is simple\\ntry using binary search"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "easy"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "I\\'m surprised this problem is considered medium difficulty. With basic knowledge of binary search and 2D matrix, it can be solved very easily."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I want time travel ticket for next question,\\nThis one quite easy as i didn\\'t checked solutions for 3 cases"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "so, binary search week it is\\n"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "I am happy that I was able to find that one on my own."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I thought question with `target sum` in a matrix"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "how to solve this problem\\n1 2 3\\n5 6 7\\n8 9 10\\n\\neach row is sorted so we can easily apply binary search algorithm.\\nin single array row look like.1 2 3 5 6 7 8 9 10\\nabove array index position start from 0 to n-1(ie 9)\\n\\nsuppose out target is 5 and its index position is 3\\nso use divide and mode operation on index position using column size\\nint col=matrix[mid/col][mid%col]\\ne.g= 3/3=1 and 3%3=0 using this approch we can find exact row and column position of number if matrix[mid/col][mid%col]>target\\nie target present at left side use end=mid-1 else\\nstart=mid+1 using this technique you can find target."
                    }
                ]
            },
            {
                "id": 2003910,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "SORTED READ KRTE HI REMEMBER BINARY SEARCH "
                    },
                    {
                        "username": "RushN24",
                        "content": "Pretty new to DSA. Other than for the purpose of practice with binary search why would we want to use it in this situation instead of simply looping over the arrays in matrix, and then looping over the elements in each array (linear search)? The below answer solves the problem and is accepted. Should not allow it to be accepted. Why is binary search a better solution from a programming/functionality standpoint?\n\nPython3\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for nums in matrix:\n            for num in nums:\n                if num == target:\n                    return True"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@sikora92](/sikora92) thanks"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@vladimirkhlghatyan](/vladimirkhlghatyan) thank you, that makes sense. "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "If, for example, m*n == 10000, the number of steps needed for a linear search algorithm would be 10000 (worst case), and for a binary search ~13 steps (log10000). Obviously, binary search works many times faster."
                    },
                    {
                        "username": "sikora92",
                        "content": "Binary search is much faster on big arrays. This is the only reason. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Brute force is simple\\ntry using binary search"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "easy"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "I\\'m surprised this problem is considered medium difficulty. With basic knowledge of binary search and 2D matrix, it can be solved very easily."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I want time travel ticket for next question,\\nThis one quite easy as i didn\\'t checked solutions for 3 cases"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "so, binary search week it is\\n"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "I am happy that I was able to find that one on my own."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I thought question with `target sum` in a matrix"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "how to solve this problem\\n1 2 3\\n5 6 7\\n8 9 10\\n\\neach row is sorted so we can easily apply binary search algorithm.\\nin single array row look like.1 2 3 5 6 7 8 9 10\\nabove array index position start from 0 to n-1(ie 9)\\n\\nsuppose out target is 5 and its index position is 3\\nso use divide and mode operation on index position using column size\\nint col=matrix[mid/col][mid%col]\\ne.g= 3/3=1 and 3%3=0 using this approch we can find exact row and column position of number if matrix[mid/col][mid%col]>target\\nie target present at left side use end=mid-1 else\\nstart=mid+1 using this technique you can find target."
                    }
                ]
            },
            {
                "id": 2003880,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "SORTED READ KRTE HI REMEMBER BINARY SEARCH "
                    },
                    {
                        "username": "RushN24",
                        "content": "Pretty new to DSA. Other than for the purpose of practice with binary search why would we want to use it in this situation instead of simply looping over the arrays in matrix, and then looping over the elements in each array (linear search)? The below answer solves the problem and is accepted. Should not allow it to be accepted. Why is binary search a better solution from a programming/functionality standpoint?\n\nPython3\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for nums in matrix:\n            for num in nums:\n                if num == target:\n                    return True"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@sikora92](/sikora92) thanks"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@vladimirkhlghatyan](/vladimirkhlghatyan) thank you, that makes sense. "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "If, for example, m*n == 10000, the number of steps needed for a linear search algorithm would be 10000 (worst case), and for a binary search ~13 steps (log10000). Obviously, binary search works many times faster."
                    },
                    {
                        "username": "sikora92",
                        "content": "Binary search is much faster on big arrays. This is the only reason. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Brute force is simple\\ntry using binary search"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "easy"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "I\\'m surprised this problem is considered medium difficulty. With basic knowledge of binary search and 2D matrix, it can be solved very easily."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I want time travel ticket for next question,\\nThis one quite easy as i didn\\'t checked solutions for 3 cases"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "so, binary search week it is\\n"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "I am happy that I was able to find that one on my own."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I thought question with `target sum` in a matrix"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "how to solve this problem\\n1 2 3\\n5 6 7\\n8 9 10\\n\\neach row is sorted so we can easily apply binary search algorithm.\\nin single array row look like.1 2 3 5 6 7 8 9 10\\nabove array index position start from 0 to n-1(ie 9)\\n\\nsuppose out target is 5 and its index position is 3\\nso use divide and mode operation on index position using column size\\nint col=matrix[mid/col][mid%col]\\ne.g= 3/3=1 and 3%3=0 using this approch we can find exact row and column position of number if matrix[mid/col][mid%col]>target\\nie target present at left side use end=mid-1 else\\nstart=mid+1 using this technique you can find target."
                    }
                ]
            },
            {
                "id": 2003872,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "SORTED READ KRTE HI REMEMBER BINARY SEARCH "
                    },
                    {
                        "username": "RushN24",
                        "content": "Pretty new to DSA. Other than for the purpose of practice with binary search why would we want to use it in this situation instead of simply looping over the arrays in matrix, and then looping over the elements in each array (linear search)? The below answer solves the problem and is accepted. Should not allow it to be accepted. Why is binary search a better solution from a programming/functionality standpoint?\n\nPython3\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for nums in matrix:\n            for num in nums:\n                if num == target:\n                    return True"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@sikora92](/sikora92) thanks"
                    },
                    {
                        "username": "RushN24",
                        "content": "[@vladimirkhlghatyan](/vladimirkhlghatyan) thank you, that makes sense. "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "If, for example, m*n == 10000, the number of steps needed for a linear search algorithm would be 10000 (worst case), and for a binary search ~13 steps (log10000). Obviously, binary search works many times faster."
                    },
                    {
                        "username": "sikora92",
                        "content": "Binary search is much faster on big arrays. This is the only reason. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Brute force is simple\\ntry using binary search"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "easy"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "I\\'m surprised this problem is considered medium difficulty. With basic knowledge of binary search and 2D matrix, it can be solved very easily."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I want time travel ticket for next question,\\nThis one quite easy as i didn\\'t checked solutions for 3 cases"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "so, binary search week it is\\n"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "I am happy that I was able to find that one on my own."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I thought question with `target sum` in a matrix"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "how to solve this problem\\n1 2 3\\n5 6 7\\n8 9 10\\n\\neach row is sorted so we can easily apply binary search algorithm.\\nin single array row look like.1 2 3 5 6 7 8 9 10\\nabove array index position start from 0 to n-1(ie 9)\\n\\nsuppose out target is 5 and its index position is 3\\nso use divide and mode operation on index position using column size\\nint col=matrix[mid/col][mid%col]\\ne.g= 3/3=1 and 3%3=0 using this approch we can find exact row and column position of number if matrix[mid/col][mid%col]>target\\nie target present at left side use end=mid-1 else\\nstart=mid+1 using this technique you can find target."
                    }
                ]
            },
            {
                "id": 2003754,
                "content": [
                    {
                        "username": "charant587",
                        "content": "Resubmitting !!!!!!!!"
                    },
                    {
                        "username": "dpw82",
                        "content": " `\nwhile(beginning <= end){\n            if(mat[mid] > target){\n                end = mid;\n                mid = (beginning + end)/2;\n            } else if(mat[mid] < target){\n                beginning = mid;\n                mid = (beginning + end)/2;\n            }\n            if(mat[mid] == target){\n                return true;\n            }\n        }\n\n`\n\nheldp debugging, getting time limit exceeded. I flattened the array to 1D. \n"
                    },
                    {
                        "username": "sikora92",
                        "content": "Don\\'t flatten an array. You can use similar logic on 2D array, translating mid to row and column."
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem:  why is the acceptance rate so low?\\n\\nalso me: lowers the acceptance rate even further."
                    },
                    {
                        "username": "arshita129",
                        "content": "Simply use binary search on each row of the matrix and Voila!! It's done.\n\nIs anyone following any other approach?"
                    },
                    {
                        "username": "sikora92",
                        "content": "You can use binary search to find most suitable row as well. So binary search used twice is faster. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Probably should have some testcases that can constrain the passable submissions to mostly O(log(m * n)). 100 x 100 being the max is pretty small, but maybe it\\'s a memory usage issue to test with anything larger?"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "I basically wrote a brute force approach and it passes. Maybe need to have test case to cater for brute force scenario?"
                    },
                    {
                        "username": "jtman5",
                        "content": "How is this not an easy"
                    },
                    {
                        "username": "longluo",
                        "content": "[6 Approaches: Brute Force, Row Search, Column Search, One Binary Search, 2D Coordinate Axis](https://leetcode.com/problems/search-a-2d-matrix/solutions/1895889/6-approaches-brute-force-row-search-column-search-one-binary-search-2d-coordinate-axis/) "
                    },
                    {
                        "username": "dntwk707",
                        "content": "If I add an if-statement to check if target number is greater than current row's last element, would it be not log(n) time? like find a row and use the canonical left-right bin search."
                    },
                    {
                        "username": "goof312",
                        "content": " for i in matrix:\\n            if target in i:\\n                return True\\n        \\n        return False\\n\\n\\nis this bad? and why?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It works but it is a brute force solution. In spite of the small matrix sizes, they want you to find a time optimization (eg binary search)."
                    }
                ]
            },
            {
                "id": 2003721,
                "content": [
                    {
                        "username": "charant587",
                        "content": "Resubmitting !!!!!!!!"
                    },
                    {
                        "username": "dpw82",
                        "content": " `\nwhile(beginning <= end){\n            if(mat[mid] > target){\n                end = mid;\n                mid = (beginning + end)/2;\n            } else if(mat[mid] < target){\n                beginning = mid;\n                mid = (beginning + end)/2;\n            }\n            if(mat[mid] == target){\n                return true;\n            }\n        }\n\n`\n\nheldp debugging, getting time limit exceeded. I flattened the array to 1D. \n"
                    },
                    {
                        "username": "sikora92",
                        "content": "Don\\'t flatten an array. You can use similar logic on 2D array, translating mid to row and column."
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem:  why is the acceptance rate so low?\\n\\nalso me: lowers the acceptance rate even further."
                    },
                    {
                        "username": "arshita129",
                        "content": "Simply use binary search on each row of the matrix and Voila!! It's done.\n\nIs anyone following any other approach?"
                    },
                    {
                        "username": "sikora92",
                        "content": "You can use binary search to find most suitable row as well. So binary search used twice is faster. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Probably should have some testcases that can constrain the passable submissions to mostly O(log(m * n)). 100 x 100 being the max is pretty small, but maybe it\\'s a memory usage issue to test with anything larger?"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "I basically wrote a brute force approach and it passes. Maybe need to have test case to cater for brute force scenario?"
                    },
                    {
                        "username": "jtman5",
                        "content": "How is this not an easy"
                    },
                    {
                        "username": "longluo",
                        "content": "[6 Approaches: Brute Force, Row Search, Column Search, One Binary Search, 2D Coordinate Axis](https://leetcode.com/problems/search-a-2d-matrix/solutions/1895889/6-approaches-brute-force-row-search-column-search-one-binary-search-2d-coordinate-axis/) "
                    },
                    {
                        "username": "dntwk707",
                        "content": "If I add an if-statement to check if target number is greater than current row's last element, would it be not log(n) time? like find a row and use the canonical left-right bin search."
                    },
                    {
                        "username": "goof312",
                        "content": " for i in matrix:\\n            if target in i:\\n                return True\\n        \\n        return False\\n\\n\\nis this bad? and why?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It works but it is a brute force solution. In spite of the small matrix sizes, they want you to find a time optimization (eg binary search)."
                    }
                ]
            },
            {
                "id": 2003672,
                "content": [
                    {
                        "username": "charant587",
                        "content": "Resubmitting !!!!!!!!"
                    },
                    {
                        "username": "dpw82",
                        "content": " `\nwhile(beginning <= end){\n            if(mat[mid] > target){\n                end = mid;\n                mid = (beginning + end)/2;\n            } else if(mat[mid] < target){\n                beginning = mid;\n                mid = (beginning + end)/2;\n            }\n            if(mat[mid] == target){\n                return true;\n            }\n        }\n\n`\n\nheldp debugging, getting time limit exceeded. I flattened the array to 1D. \n"
                    },
                    {
                        "username": "sikora92",
                        "content": "Don\\'t flatten an array. You can use similar logic on 2D array, translating mid to row and column."
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem:  why is the acceptance rate so low?\\n\\nalso me: lowers the acceptance rate even further."
                    },
                    {
                        "username": "arshita129",
                        "content": "Simply use binary search on each row of the matrix and Voila!! It's done.\n\nIs anyone following any other approach?"
                    },
                    {
                        "username": "sikora92",
                        "content": "You can use binary search to find most suitable row as well. So binary search used twice is faster. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Probably should have some testcases that can constrain the passable submissions to mostly O(log(m * n)). 100 x 100 being the max is pretty small, but maybe it\\'s a memory usage issue to test with anything larger?"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "I basically wrote a brute force approach and it passes. Maybe need to have test case to cater for brute force scenario?"
                    },
                    {
                        "username": "jtman5",
                        "content": "How is this not an easy"
                    },
                    {
                        "username": "longluo",
                        "content": "[6 Approaches: Brute Force, Row Search, Column Search, One Binary Search, 2D Coordinate Axis](https://leetcode.com/problems/search-a-2d-matrix/solutions/1895889/6-approaches-brute-force-row-search-column-search-one-binary-search-2d-coordinate-axis/) "
                    },
                    {
                        "username": "dntwk707",
                        "content": "If I add an if-statement to check if target number is greater than current row's last element, would it be not log(n) time? like find a row and use the canonical left-right bin search."
                    },
                    {
                        "username": "goof312",
                        "content": " for i in matrix:\\n            if target in i:\\n                return True\\n        \\n        return False\\n\\n\\nis this bad? and why?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It works but it is a brute force solution. In spite of the small matrix sizes, they want you to find a time optimization (eg binary search)."
                    }
                ]
            },
            {
                "id": 2003646,
                "content": [
                    {
                        "username": "charant587",
                        "content": "Resubmitting !!!!!!!!"
                    },
                    {
                        "username": "dpw82",
                        "content": " `\nwhile(beginning <= end){\n            if(mat[mid] > target){\n                end = mid;\n                mid = (beginning + end)/2;\n            } else if(mat[mid] < target){\n                beginning = mid;\n                mid = (beginning + end)/2;\n            }\n            if(mat[mid] == target){\n                return true;\n            }\n        }\n\n`\n\nheldp debugging, getting time limit exceeded. I flattened the array to 1D. \n"
                    },
                    {
                        "username": "sikora92",
                        "content": "Don\\'t flatten an array. You can use similar logic on 2D array, translating mid to row and column."
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem:  why is the acceptance rate so low?\\n\\nalso me: lowers the acceptance rate even further."
                    },
                    {
                        "username": "arshita129",
                        "content": "Simply use binary search on each row of the matrix and Voila!! It's done.\n\nIs anyone following any other approach?"
                    },
                    {
                        "username": "sikora92",
                        "content": "You can use binary search to find most suitable row as well. So binary search used twice is faster. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Probably should have some testcases that can constrain the passable submissions to mostly O(log(m * n)). 100 x 100 being the max is pretty small, but maybe it\\'s a memory usage issue to test with anything larger?"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "I basically wrote a brute force approach and it passes. Maybe need to have test case to cater for brute force scenario?"
                    },
                    {
                        "username": "jtman5",
                        "content": "How is this not an easy"
                    },
                    {
                        "username": "longluo",
                        "content": "[6 Approaches: Brute Force, Row Search, Column Search, One Binary Search, 2D Coordinate Axis](https://leetcode.com/problems/search-a-2d-matrix/solutions/1895889/6-approaches-brute-force-row-search-column-search-one-binary-search-2d-coordinate-axis/) "
                    },
                    {
                        "username": "dntwk707",
                        "content": "If I add an if-statement to check if target number is greater than current row's last element, would it be not log(n) time? like find a row and use the canonical left-right bin search."
                    },
                    {
                        "username": "goof312",
                        "content": " for i in matrix:\\n            if target in i:\\n                return True\\n        \\n        return False\\n\\n\\nis this bad? and why?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It works but it is a brute force solution. In spite of the small matrix sizes, they want you to find a time optimization (eg binary search)."
                    }
                ]
            },
            {
                "id": 2003610,
                "content": [
                    {
                        "username": "charant587",
                        "content": "Resubmitting !!!!!!!!"
                    },
                    {
                        "username": "dpw82",
                        "content": " `\nwhile(beginning <= end){\n            if(mat[mid] > target){\n                end = mid;\n                mid = (beginning + end)/2;\n            } else if(mat[mid] < target){\n                beginning = mid;\n                mid = (beginning + end)/2;\n            }\n            if(mat[mid] == target){\n                return true;\n            }\n        }\n\n`\n\nheldp debugging, getting time limit exceeded. I flattened the array to 1D. \n"
                    },
                    {
                        "username": "sikora92",
                        "content": "Don\\'t flatten an array. You can use similar logic on 2D array, translating mid to row and column."
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem:  why is the acceptance rate so low?\\n\\nalso me: lowers the acceptance rate even further."
                    },
                    {
                        "username": "arshita129",
                        "content": "Simply use binary search on each row of the matrix and Voila!! It's done.\n\nIs anyone following any other approach?"
                    },
                    {
                        "username": "sikora92",
                        "content": "You can use binary search to find most suitable row as well. So binary search used twice is faster. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Probably should have some testcases that can constrain the passable submissions to mostly O(log(m * n)). 100 x 100 being the max is pretty small, but maybe it\\'s a memory usage issue to test with anything larger?"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "I basically wrote a brute force approach and it passes. Maybe need to have test case to cater for brute force scenario?"
                    },
                    {
                        "username": "jtman5",
                        "content": "How is this not an easy"
                    },
                    {
                        "username": "longluo",
                        "content": "[6 Approaches: Brute Force, Row Search, Column Search, One Binary Search, 2D Coordinate Axis](https://leetcode.com/problems/search-a-2d-matrix/solutions/1895889/6-approaches-brute-force-row-search-column-search-one-binary-search-2d-coordinate-axis/) "
                    },
                    {
                        "username": "dntwk707",
                        "content": "If I add an if-statement to check if target number is greater than current row's last element, would it be not log(n) time? like find a row and use the canonical left-right bin search."
                    },
                    {
                        "username": "goof312",
                        "content": " for i in matrix:\\n            if target in i:\\n                return True\\n        \\n        return False\\n\\n\\nis this bad? and why?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It works but it is a brute force solution. In spite of the small matrix sizes, they want you to find a time optimization (eg binary search)."
                    }
                ]
            },
            {
                "id": 2003591,
                "content": [
                    {
                        "username": "charant587",
                        "content": "Resubmitting !!!!!!!!"
                    },
                    {
                        "username": "dpw82",
                        "content": " `\nwhile(beginning <= end){\n            if(mat[mid] > target){\n                end = mid;\n                mid = (beginning + end)/2;\n            } else if(mat[mid] < target){\n                beginning = mid;\n                mid = (beginning + end)/2;\n            }\n            if(mat[mid] == target){\n                return true;\n            }\n        }\n\n`\n\nheldp debugging, getting time limit exceeded. I flattened the array to 1D. \n"
                    },
                    {
                        "username": "sikora92",
                        "content": "Don\\'t flatten an array. You can use similar logic on 2D array, translating mid to row and column."
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem:  why is the acceptance rate so low?\\n\\nalso me: lowers the acceptance rate even further."
                    },
                    {
                        "username": "arshita129",
                        "content": "Simply use binary search on each row of the matrix and Voila!! It's done.\n\nIs anyone following any other approach?"
                    },
                    {
                        "username": "sikora92",
                        "content": "You can use binary search to find most suitable row as well. So binary search used twice is faster. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Probably should have some testcases that can constrain the passable submissions to mostly O(log(m * n)). 100 x 100 being the max is pretty small, but maybe it\\'s a memory usage issue to test with anything larger?"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "I basically wrote a brute force approach and it passes. Maybe need to have test case to cater for brute force scenario?"
                    },
                    {
                        "username": "jtman5",
                        "content": "How is this not an easy"
                    },
                    {
                        "username": "longluo",
                        "content": "[6 Approaches: Brute Force, Row Search, Column Search, One Binary Search, 2D Coordinate Axis](https://leetcode.com/problems/search-a-2d-matrix/solutions/1895889/6-approaches-brute-force-row-search-column-search-one-binary-search-2d-coordinate-axis/) "
                    },
                    {
                        "username": "dntwk707",
                        "content": "If I add an if-statement to check if target number is greater than current row's last element, would it be not log(n) time? like find a row and use the canonical left-right bin search."
                    },
                    {
                        "username": "goof312",
                        "content": " for i in matrix:\\n            if target in i:\\n                return True\\n        \\n        return False\\n\\n\\nis this bad? and why?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It works but it is a brute force solution. In spite of the small matrix sizes, they want you to find a time optimization (eg binary search)."
                    }
                ]
            },
            {
                "id": 2003590,
                "content": [
                    {
                        "username": "charant587",
                        "content": "Resubmitting !!!!!!!!"
                    },
                    {
                        "username": "dpw82",
                        "content": " `\nwhile(beginning <= end){\n            if(mat[mid] > target){\n                end = mid;\n                mid = (beginning + end)/2;\n            } else if(mat[mid] < target){\n                beginning = mid;\n                mid = (beginning + end)/2;\n            }\n            if(mat[mid] == target){\n                return true;\n            }\n        }\n\n`\n\nheldp debugging, getting time limit exceeded. I flattened the array to 1D. \n"
                    },
                    {
                        "username": "sikora92",
                        "content": "Don\\'t flatten an array. You can use similar logic on 2D array, translating mid to row and column."
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem:  why is the acceptance rate so low?\\n\\nalso me: lowers the acceptance rate even further."
                    },
                    {
                        "username": "arshita129",
                        "content": "Simply use binary search on each row of the matrix and Voila!! It's done.\n\nIs anyone following any other approach?"
                    },
                    {
                        "username": "sikora92",
                        "content": "You can use binary search to find most suitable row as well. So binary search used twice is faster. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Probably should have some testcases that can constrain the passable submissions to mostly O(log(m * n)). 100 x 100 being the max is pretty small, but maybe it\\'s a memory usage issue to test with anything larger?"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "I basically wrote a brute force approach and it passes. Maybe need to have test case to cater for brute force scenario?"
                    },
                    {
                        "username": "jtman5",
                        "content": "How is this not an easy"
                    },
                    {
                        "username": "longluo",
                        "content": "[6 Approaches: Brute Force, Row Search, Column Search, One Binary Search, 2D Coordinate Axis](https://leetcode.com/problems/search-a-2d-matrix/solutions/1895889/6-approaches-brute-force-row-search-column-search-one-binary-search-2d-coordinate-axis/) "
                    },
                    {
                        "username": "dntwk707",
                        "content": "If I add an if-statement to check if target number is greater than current row's last element, would it be not log(n) time? like find a row and use the canonical left-right bin search."
                    },
                    {
                        "username": "goof312",
                        "content": " for i in matrix:\\n            if target in i:\\n                return True\\n        \\n        return False\\n\\n\\nis this bad? and why?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It works but it is a brute force solution. In spite of the small matrix sizes, they want you to find a time optimization (eg binary search)."
                    }
                ]
            },
            {
                "id": 2003573,
                "content": [
                    {
                        "username": "charant587",
                        "content": "Resubmitting !!!!!!!!"
                    },
                    {
                        "username": "dpw82",
                        "content": " `\nwhile(beginning <= end){\n            if(mat[mid] > target){\n                end = mid;\n                mid = (beginning + end)/2;\n            } else if(mat[mid] < target){\n                beginning = mid;\n                mid = (beginning + end)/2;\n            }\n            if(mat[mid] == target){\n                return true;\n            }\n        }\n\n`\n\nheldp debugging, getting time limit exceeded. I flattened the array to 1D. \n"
                    },
                    {
                        "username": "sikora92",
                        "content": "Don\\'t flatten an array. You can use similar logic on 2D array, translating mid to row and column."
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem:  why is the acceptance rate so low?\\n\\nalso me: lowers the acceptance rate even further."
                    },
                    {
                        "username": "arshita129",
                        "content": "Simply use binary search on each row of the matrix and Voila!! It's done.\n\nIs anyone following any other approach?"
                    },
                    {
                        "username": "sikora92",
                        "content": "You can use binary search to find most suitable row as well. So binary search used twice is faster. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Probably should have some testcases that can constrain the passable submissions to mostly O(log(m * n)). 100 x 100 being the max is pretty small, but maybe it\\'s a memory usage issue to test with anything larger?"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "I basically wrote a brute force approach and it passes. Maybe need to have test case to cater for brute force scenario?"
                    },
                    {
                        "username": "jtman5",
                        "content": "How is this not an easy"
                    },
                    {
                        "username": "longluo",
                        "content": "[6 Approaches: Brute Force, Row Search, Column Search, One Binary Search, 2D Coordinate Axis](https://leetcode.com/problems/search-a-2d-matrix/solutions/1895889/6-approaches-brute-force-row-search-column-search-one-binary-search-2d-coordinate-axis/) "
                    },
                    {
                        "username": "dntwk707",
                        "content": "If I add an if-statement to check if target number is greater than current row's last element, would it be not log(n) time? like find a row and use the canonical left-right bin search."
                    },
                    {
                        "username": "goof312",
                        "content": " for i in matrix:\\n            if target in i:\\n                return True\\n        \\n        return False\\n\\n\\nis this bad? and why?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It works but it is a brute force solution. In spite of the small matrix sizes, they want you to find a time optimization (eg binary search)."
                    }
                ]
            },
            {
                "id": 2000027,
                "content": [
                    {
                        "username": "charant587",
                        "content": "Resubmitting !!!!!!!!"
                    },
                    {
                        "username": "dpw82",
                        "content": " `\nwhile(beginning <= end){\n            if(mat[mid] > target){\n                end = mid;\n                mid = (beginning + end)/2;\n            } else if(mat[mid] < target){\n                beginning = mid;\n                mid = (beginning + end)/2;\n            }\n            if(mat[mid] == target){\n                return true;\n            }\n        }\n\n`\n\nheldp debugging, getting time limit exceeded. I flattened the array to 1D. \n"
                    },
                    {
                        "username": "sikora92",
                        "content": "Don\\'t flatten an array. You can use similar logic on 2D array, translating mid to row and column."
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem:  why is the acceptance rate so low?\\n\\nalso me: lowers the acceptance rate even further."
                    },
                    {
                        "username": "arshita129",
                        "content": "Simply use binary search on each row of the matrix and Voila!! It's done.\n\nIs anyone following any other approach?"
                    },
                    {
                        "username": "sikora92",
                        "content": "You can use binary search to find most suitable row as well. So binary search used twice is faster. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Probably should have some testcases that can constrain the passable submissions to mostly O(log(m * n)). 100 x 100 being the max is pretty small, but maybe it\\'s a memory usage issue to test with anything larger?"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "I basically wrote a brute force approach and it passes. Maybe need to have test case to cater for brute force scenario?"
                    },
                    {
                        "username": "jtman5",
                        "content": "How is this not an easy"
                    },
                    {
                        "username": "longluo",
                        "content": "[6 Approaches: Brute Force, Row Search, Column Search, One Binary Search, 2D Coordinate Axis](https://leetcode.com/problems/search-a-2d-matrix/solutions/1895889/6-approaches-brute-force-row-search-column-search-one-binary-search-2d-coordinate-axis/) "
                    },
                    {
                        "username": "dntwk707",
                        "content": "If I add an if-statement to check if target number is greater than current row's last element, would it be not log(n) time? like find a row and use the canonical left-right bin search."
                    },
                    {
                        "username": "goof312",
                        "content": " for i in matrix:\\n            if target in i:\\n                return True\\n        \\n        return False\\n\\n\\nis this bad? and why?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It works but it is a brute force solution. In spite of the small matrix sizes, they want you to find a time optimization (eg binary search)."
                    }
                ]
            },
            {
                "id": 1996034,
                "content": [
                    {
                        "username": "charant587",
                        "content": "Resubmitting !!!!!!!!"
                    },
                    {
                        "username": "dpw82",
                        "content": " `\nwhile(beginning <= end){\n            if(mat[mid] > target){\n                end = mid;\n                mid = (beginning + end)/2;\n            } else if(mat[mid] < target){\n                beginning = mid;\n                mid = (beginning + end)/2;\n            }\n            if(mat[mid] == target){\n                return true;\n            }\n        }\n\n`\n\nheldp debugging, getting time limit exceeded. I flattened the array to 1D. \n"
                    },
                    {
                        "username": "sikora92",
                        "content": "Don\\'t flatten an array. You can use similar logic on 2D array, translating mid to row and column."
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem:  why is the acceptance rate so low?\\n\\nalso me: lowers the acceptance rate even further."
                    },
                    {
                        "username": "arshita129",
                        "content": "Simply use binary search on each row of the matrix and Voila!! It's done.\n\nIs anyone following any other approach?"
                    },
                    {
                        "username": "sikora92",
                        "content": "You can use binary search to find most suitable row as well. So binary search used twice is faster. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Probably should have some testcases that can constrain the passable submissions to mostly O(log(m * n)). 100 x 100 being the max is pretty small, but maybe it\\'s a memory usage issue to test with anything larger?"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "I basically wrote a brute force approach and it passes. Maybe need to have test case to cater for brute force scenario?"
                    },
                    {
                        "username": "jtman5",
                        "content": "How is this not an easy"
                    },
                    {
                        "username": "longluo",
                        "content": "[6 Approaches: Brute Force, Row Search, Column Search, One Binary Search, 2D Coordinate Axis](https://leetcode.com/problems/search-a-2d-matrix/solutions/1895889/6-approaches-brute-force-row-search-column-search-one-binary-search-2d-coordinate-axis/) "
                    },
                    {
                        "username": "dntwk707",
                        "content": "If I add an if-statement to check if target number is greater than current row's last element, would it be not log(n) time? like find a row and use the canonical left-right bin search."
                    },
                    {
                        "username": "goof312",
                        "content": " for i in matrix:\\n            if target in i:\\n                return True\\n        \\n        return False\\n\\n\\nis this bad? and why?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It works but it is a brute force solution. In spite of the small matrix sizes, they want you to find a time optimization (eg binary search)."
                    }
                ]
            },
            {
                "id": 1985498,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "There are 4 approaches to this question:\\n\\n**1. Brute Force Approach:**\\nIterate over the whole matrix to find the element.\\nTime Complexity: O(n * m)\\n\\n**2. Better Approach:**\\nEach row is sorted, so we can apply binary search on each row to find the element.\\nTime Complexity: O(n * log(m))\\n\\n**3. More Better Approach:**\\nThe two-pointer approach starts from the top-right corner and moves either left or down, eliminating one row or column at each step. In the worst case, it will traverse either the entire top row or the entire rightmost column.\\nTime Complexity: O(n + m)\\n\\n**4. Optimal Approach:**\\nSince the 1st element of each row is greater than the last element of the previous row, this means that the whole matrix can be considered as sorted 1D array. So we can apply binary search over the whole matrix.\\nTime Complexity: O(log(n * m))\\n\\n[Codes for above approaches](https://github.com/amanhex/Leetcode-Solutions/blob/main/74.%20Search%20a%202D%20Matrix.cpp)"
                    },
                    {
                        "username": "alanmorais1503",
                        "content": "*** DON\\'T  LOOK IT MAY CONTAIN SOLUTION CODE***\\n\\nCan anyone check if the there is a bug in the platform, because this code should work I even code a unit test to make sure I am not crazy, I did some println!,  for some reason the return statement in the second loop is not exiting the function. \\n\\n`struct Solution{\\n}\\n\\nimpl Solution {\\n    pub fn search_matrix(self, matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let mut start = 0;\\n        let mut end = matrix.len() -1;\\n        let mut middle = 0;\\n\\n        while start != end {\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[middle][0] == target{\\n                return true;\\n            }else if target > matrix[middle][0] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        let row_to_search = start;\\n        start = 0;\\n        end = matrix[row_to_search].len() -1;\\n\\n        while start < end{\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[row_to_search][middle] == target{\\n                return true\\n            }else if target > matrix[row_to_search][middle] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        if matrix[row_to_search][start] == target{ true } else {false} \\n    }\\n}\\n\\npub fn main(){}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn it_works(){\\n        let sol = Solution{};\\n        let result = sol.search_matrix([[1,3,5,7].to_vec(),[10,11,16,20].to_vec(),[23,30,34,60].to_vec()].to_vec(), 3);\\n        assert_eq!(true, result);`\\n\\n  "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "we can make use of the fact that the first ele of each row is greater than the last ele of prev row.\\nby this way we can check the last ele of each row , if our target is bigger than the last ele of that row , it means that our target is not in that row , and we go to next row."
                    },
                    {
                        "username": "boyiddha_",
                        "content": "I applied binary search many times in 1D array/ matirx but never applied binary search in 2D array/ matrix. This problem gives this opportunity.\\n.\\nI learned new things; How to apply Binary Search in 2D array/ matrix!"
                    },
                    {
                        "username": "Vikas__7",
                        "content": "if you solve from nested loops then you time complexity is O(n^2).\nthen you solve this approach from different method like  - `int i = 0 , j = matrix[0].length - 1;`\nthen traverse the matrix\n\n "
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "As for me, this task should be an easy because it accepts the all solutions"
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "Anyone know why the solution is asking for a O(log(n * m)) instead of O(log(n) + log(m))? If you perform two binary search operators (one for rows and one for cols) shouldn\\'t you add them together instead of multiple? "
                    },
                    {
                        "username": "user2049D",
                        "content": "[@illya_holubiev](/illya_holubiev) For sure, you didn\\'t."
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "I have just passed in O(n)"
                    },
                    {
                        "username": "Indrijeet2042",
                        "content": "log(n*m)=log(n)+log(m) both are same."
                    },
                    {
                        "username": "harkiratsaini13",
                        "content": "Learn staircase search. Then you will easily solve this question and also Search a 2D Matrix II"
                    },
                    {
                        "username": "psionl0",
                        "content": "The staircase approach is not optimum for this problem since the end of each row is less than the start of the next which means that a row can be located by using a binary search."
                    },
                    {
                        "username": "AlekseyR007",
                        "content": "Why is it a jagged array (int[][]) in C#? I think it should be just a matrix like this int[,]."
                    },
                    {
                        "username": "nghia1303",
                        "content": "I wrote a O(n^2) solution but it still passed all the test cases "
                    }
                ]
            },
            {
                "id": 1984185,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "There are 4 approaches to this question:\\n\\n**1. Brute Force Approach:**\\nIterate over the whole matrix to find the element.\\nTime Complexity: O(n * m)\\n\\n**2. Better Approach:**\\nEach row is sorted, so we can apply binary search on each row to find the element.\\nTime Complexity: O(n * log(m))\\n\\n**3. More Better Approach:**\\nThe two-pointer approach starts from the top-right corner and moves either left or down, eliminating one row or column at each step. In the worst case, it will traverse either the entire top row or the entire rightmost column.\\nTime Complexity: O(n + m)\\n\\n**4. Optimal Approach:**\\nSince the 1st element of each row is greater than the last element of the previous row, this means that the whole matrix can be considered as sorted 1D array. So we can apply binary search over the whole matrix.\\nTime Complexity: O(log(n * m))\\n\\n[Codes for above approaches](https://github.com/amanhex/Leetcode-Solutions/blob/main/74.%20Search%20a%202D%20Matrix.cpp)"
                    },
                    {
                        "username": "alanmorais1503",
                        "content": "*** DON\\'T  LOOK IT MAY CONTAIN SOLUTION CODE***\\n\\nCan anyone check if the there is a bug in the platform, because this code should work I even code a unit test to make sure I am not crazy, I did some println!,  for some reason the return statement in the second loop is not exiting the function. \\n\\n`struct Solution{\\n}\\n\\nimpl Solution {\\n    pub fn search_matrix(self, matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let mut start = 0;\\n        let mut end = matrix.len() -1;\\n        let mut middle = 0;\\n\\n        while start != end {\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[middle][0] == target{\\n                return true;\\n            }else if target > matrix[middle][0] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        let row_to_search = start;\\n        start = 0;\\n        end = matrix[row_to_search].len() -1;\\n\\n        while start < end{\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[row_to_search][middle] == target{\\n                return true\\n            }else if target > matrix[row_to_search][middle] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        if matrix[row_to_search][start] == target{ true } else {false} \\n    }\\n}\\n\\npub fn main(){}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn it_works(){\\n        let sol = Solution{};\\n        let result = sol.search_matrix([[1,3,5,7].to_vec(),[10,11,16,20].to_vec(),[23,30,34,60].to_vec()].to_vec(), 3);\\n        assert_eq!(true, result);`\\n\\n  "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "we can make use of the fact that the first ele of each row is greater than the last ele of prev row.\\nby this way we can check the last ele of each row , if our target is bigger than the last ele of that row , it means that our target is not in that row , and we go to next row."
                    },
                    {
                        "username": "boyiddha_",
                        "content": "I applied binary search many times in 1D array/ matirx but never applied binary search in 2D array/ matrix. This problem gives this opportunity.\\n.\\nI learned new things; How to apply Binary Search in 2D array/ matrix!"
                    },
                    {
                        "username": "Vikas__7",
                        "content": "if you solve from nested loops then you time complexity is O(n^2).\nthen you solve this approach from different method like  - `int i = 0 , j = matrix[0].length - 1;`\nthen traverse the matrix\n\n "
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "As for me, this task should be an easy because it accepts the all solutions"
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "Anyone know why the solution is asking for a O(log(n * m)) instead of O(log(n) + log(m))? If you perform two binary search operators (one for rows and one for cols) shouldn\\'t you add them together instead of multiple? "
                    },
                    {
                        "username": "user2049D",
                        "content": "[@illya_holubiev](/illya_holubiev) For sure, you didn\\'t."
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "I have just passed in O(n)"
                    },
                    {
                        "username": "Indrijeet2042",
                        "content": "log(n*m)=log(n)+log(m) both are same."
                    },
                    {
                        "username": "harkiratsaini13",
                        "content": "Learn staircase search. Then you will easily solve this question and also Search a 2D Matrix II"
                    },
                    {
                        "username": "psionl0",
                        "content": "The staircase approach is not optimum for this problem since the end of each row is less than the start of the next which means that a row can be located by using a binary search."
                    },
                    {
                        "username": "AlekseyR007",
                        "content": "Why is it a jagged array (int[][]) in C#? I think it should be just a matrix like this int[,]."
                    },
                    {
                        "username": "nghia1303",
                        "content": "I wrote a O(n^2) solution but it still passed all the test cases "
                    }
                ]
            },
            {
                "id": 1978457,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "There are 4 approaches to this question:\\n\\n**1. Brute Force Approach:**\\nIterate over the whole matrix to find the element.\\nTime Complexity: O(n * m)\\n\\n**2. Better Approach:**\\nEach row is sorted, so we can apply binary search on each row to find the element.\\nTime Complexity: O(n * log(m))\\n\\n**3. More Better Approach:**\\nThe two-pointer approach starts from the top-right corner and moves either left or down, eliminating one row or column at each step. In the worst case, it will traverse either the entire top row or the entire rightmost column.\\nTime Complexity: O(n + m)\\n\\n**4. Optimal Approach:**\\nSince the 1st element of each row is greater than the last element of the previous row, this means that the whole matrix can be considered as sorted 1D array. So we can apply binary search over the whole matrix.\\nTime Complexity: O(log(n * m))\\n\\n[Codes for above approaches](https://github.com/amanhex/Leetcode-Solutions/blob/main/74.%20Search%20a%202D%20Matrix.cpp)"
                    },
                    {
                        "username": "alanmorais1503",
                        "content": "*** DON\\'T  LOOK IT MAY CONTAIN SOLUTION CODE***\\n\\nCan anyone check if the there is a bug in the platform, because this code should work I even code a unit test to make sure I am not crazy, I did some println!,  for some reason the return statement in the second loop is not exiting the function. \\n\\n`struct Solution{\\n}\\n\\nimpl Solution {\\n    pub fn search_matrix(self, matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let mut start = 0;\\n        let mut end = matrix.len() -1;\\n        let mut middle = 0;\\n\\n        while start != end {\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[middle][0] == target{\\n                return true;\\n            }else if target > matrix[middle][0] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        let row_to_search = start;\\n        start = 0;\\n        end = matrix[row_to_search].len() -1;\\n\\n        while start < end{\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[row_to_search][middle] == target{\\n                return true\\n            }else if target > matrix[row_to_search][middle] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        if matrix[row_to_search][start] == target{ true } else {false} \\n    }\\n}\\n\\npub fn main(){}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn it_works(){\\n        let sol = Solution{};\\n        let result = sol.search_matrix([[1,3,5,7].to_vec(),[10,11,16,20].to_vec(),[23,30,34,60].to_vec()].to_vec(), 3);\\n        assert_eq!(true, result);`\\n\\n  "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "we can make use of the fact that the first ele of each row is greater than the last ele of prev row.\\nby this way we can check the last ele of each row , if our target is bigger than the last ele of that row , it means that our target is not in that row , and we go to next row."
                    },
                    {
                        "username": "boyiddha_",
                        "content": "I applied binary search many times in 1D array/ matirx but never applied binary search in 2D array/ matrix. This problem gives this opportunity.\\n.\\nI learned new things; How to apply Binary Search in 2D array/ matrix!"
                    },
                    {
                        "username": "Vikas__7",
                        "content": "if you solve from nested loops then you time complexity is O(n^2).\nthen you solve this approach from different method like  - `int i = 0 , j = matrix[0].length - 1;`\nthen traverse the matrix\n\n "
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "As for me, this task should be an easy because it accepts the all solutions"
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "Anyone know why the solution is asking for a O(log(n * m)) instead of O(log(n) + log(m))? If you perform two binary search operators (one for rows and one for cols) shouldn\\'t you add them together instead of multiple? "
                    },
                    {
                        "username": "user2049D",
                        "content": "[@illya_holubiev](/illya_holubiev) For sure, you didn\\'t."
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "I have just passed in O(n)"
                    },
                    {
                        "username": "Indrijeet2042",
                        "content": "log(n*m)=log(n)+log(m) both are same."
                    },
                    {
                        "username": "harkiratsaini13",
                        "content": "Learn staircase search. Then you will easily solve this question and also Search a 2D Matrix II"
                    },
                    {
                        "username": "psionl0",
                        "content": "The staircase approach is not optimum for this problem since the end of each row is less than the start of the next which means that a row can be located by using a binary search."
                    },
                    {
                        "username": "AlekseyR007",
                        "content": "Why is it a jagged array (int[][]) in C#? I think it should be just a matrix like this int[,]."
                    },
                    {
                        "username": "nghia1303",
                        "content": "I wrote a O(n^2) solution but it still passed all the test cases "
                    }
                ]
            },
            {
                "id": 1976457,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "There are 4 approaches to this question:\\n\\n**1. Brute Force Approach:**\\nIterate over the whole matrix to find the element.\\nTime Complexity: O(n * m)\\n\\n**2. Better Approach:**\\nEach row is sorted, so we can apply binary search on each row to find the element.\\nTime Complexity: O(n * log(m))\\n\\n**3. More Better Approach:**\\nThe two-pointer approach starts from the top-right corner and moves either left or down, eliminating one row or column at each step. In the worst case, it will traverse either the entire top row or the entire rightmost column.\\nTime Complexity: O(n + m)\\n\\n**4. Optimal Approach:**\\nSince the 1st element of each row is greater than the last element of the previous row, this means that the whole matrix can be considered as sorted 1D array. So we can apply binary search over the whole matrix.\\nTime Complexity: O(log(n * m))\\n\\n[Codes for above approaches](https://github.com/amanhex/Leetcode-Solutions/blob/main/74.%20Search%20a%202D%20Matrix.cpp)"
                    },
                    {
                        "username": "alanmorais1503",
                        "content": "*** DON\\'T  LOOK IT MAY CONTAIN SOLUTION CODE***\\n\\nCan anyone check if the there is a bug in the platform, because this code should work I even code a unit test to make sure I am not crazy, I did some println!,  for some reason the return statement in the second loop is not exiting the function. \\n\\n`struct Solution{\\n}\\n\\nimpl Solution {\\n    pub fn search_matrix(self, matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let mut start = 0;\\n        let mut end = matrix.len() -1;\\n        let mut middle = 0;\\n\\n        while start != end {\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[middle][0] == target{\\n                return true;\\n            }else if target > matrix[middle][0] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        let row_to_search = start;\\n        start = 0;\\n        end = matrix[row_to_search].len() -1;\\n\\n        while start < end{\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[row_to_search][middle] == target{\\n                return true\\n            }else if target > matrix[row_to_search][middle] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        if matrix[row_to_search][start] == target{ true } else {false} \\n    }\\n}\\n\\npub fn main(){}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn it_works(){\\n        let sol = Solution{};\\n        let result = sol.search_matrix([[1,3,5,7].to_vec(),[10,11,16,20].to_vec(),[23,30,34,60].to_vec()].to_vec(), 3);\\n        assert_eq!(true, result);`\\n\\n  "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "we can make use of the fact that the first ele of each row is greater than the last ele of prev row.\\nby this way we can check the last ele of each row , if our target is bigger than the last ele of that row , it means that our target is not in that row , and we go to next row."
                    },
                    {
                        "username": "boyiddha_",
                        "content": "I applied binary search many times in 1D array/ matirx but never applied binary search in 2D array/ matrix. This problem gives this opportunity.\\n.\\nI learned new things; How to apply Binary Search in 2D array/ matrix!"
                    },
                    {
                        "username": "Vikas__7",
                        "content": "if you solve from nested loops then you time complexity is O(n^2).\nthen you solve this approach from different method like  - `int i = 0 , j = matrix[0].length - 1;`\nthen traverse the matrix\n\n "
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "As for me, this task should be an easy because it accepts the all solutions"
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "Anyone know why the solution is asking for a O(log(n * m)) instead of O(log(n) + log(m))? If you perform two binary search operators (one for rows and one for cols) shouldn\\'t you add them together instead of multiple? "
                    },
                    {
                        "username": "user2049D",
                        "content": "[@illya_holubiev](/illya_holubiev) For sure, you didn\\'t."
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "I have just passed in O(n)"
                    },
                    {
                        "username": "Indrijeet2042",
                        "content": "log(n*m)=log(n)+log(m) both are same."
                    },
                    {
                        "username": "harkiratsaini13",
                        "content": "Learn staircase search. Then you will easily solve this question and also Search a 2D Matrix II"
                    },
                    {
                        "username": "psionl0",
                        "content": "The staircase approach is not optimum for this problem since the end of each row is less than the start of the next which means that a row can be located by using a binary search."
                    },
                    {
                        "username": "AlekseyR007",
                        "content": "Why is it a jagged array (int[][]) in C#? I think it should be just a matrix like this int[,]."
                    },
                    {
                        "username": "nghia1303",
                        "content": "I wrote a O(n^2) solution but it still passed all the test cases "
                    }
                ]
            },
            {
                "id": 1975351,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "There are 4 approaches to this question:\\n\\n**1. Brute Force Approach:**\\nIterate over the whole matrix to find the element.\\nTime Complexity: O(n * m)\\n\\n**2. Better Approach:**\\nEach row is sorted, so we can apply binary search on each row to find the element.\\nTime Complexity: O(n * log(m))\\n\\n**3. More Better Approach:**\\nThe two-pointer approach starts from the top-right corner and moves either left or down, eliminating one row or column at each step. In the worst case, it will traverse either the entire top row or the entire rightmost column.\\nTime Complexity: O(n + m)\\n\\n**4. Optimal Approach:**\\nSince the 1st element of each row is greater than the last element of the previous row, this means that the whole matrix can be considered as sorted 1D array. So we can apply binary search over the whole matrix.\\nTime Complexity: O(log(n * m))\\n\\n[Codes for above approaches](https://github.com/amanhex/Leetcode-Solutions/blob/main/74.%20Search%20a%202D%20Matrix.cpp)"
                    },
                    {
                        "username": "alanmorais1503",
                        "content": "*** DON\\'T  LOOK IT MAY CONTAIN SOLUTION CODE***\\n\\nCan anyone check if the there is a bug in the platform, because this code should work I even code a unit test to make sure I am not crazy, I did some println!,  for some reason the return statement in the second loop is not exiting the function. \\n\\n`struct Solution{\\n}\\n\\nimpl Solution {\\n    pub fn search_matrix(self, matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let mut start = 0;\\n        let mut end = matrix.len() -1;\\n        let mut middle = 0;\\n\\n        while start != end {\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[middle][0] == target{\\n                return true;\\n            }else if target > matrix[middle][0] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        let row_to_search = start;\\n        start = 0;\\n        end = matrix[row_to_search].len() -1;\\n\\n        while start < end{\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[row_to_search][middle] == target{\\n                return true\\n            }else if target > matrix[row_to_search][middle] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        if matrix[row_to_search][start] == target{ true } else {false} \\n    }\\n}\\n\\npub fn main(){}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn it_works(){\\n        let sol = Solution{};\\n        let result = sol.search_matrix([[1,3,5,7].to_vec(),[10,11,16,20].to_vec(),[23,30,34,60].to_vec()].to_vec(), 3);\\n        assert_eq!(true, result);`\\n\\n  "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "we can make use of the fact that the first ele of each row is greater than the last ele of prev row.\\nby this way we can check the last ele of each row , if our target is bigger than the last ele of that row , it means that our target is not in that row , and we go to next row."
                    },
                    {
                        "username": "boyiddha_",
                        "content": "I applied binary search many times in 1D array/ matirx but never applied binary search in 2D array/ matrix. This problem gives this opportunity.\\n.\\nI learned new things; How to apply Binary Search in 2D array/ matrix!"
                    },
                    {
                        "username": "Vikas__7",
                        "content": "if you solve from nested loops then you time complexity is O(n^2).\nthen you solve this approach from different method like  - `int i = 0 , j = matrix[0].length - 1;`\nthen traverse the matrix\n\n "
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "As for me, this task should be an easy because it accepts the all solutions"
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "Anyone know why the solution is asking for a O(log(n * m)) instead of O(log(n) + log(m))? If you perform two binary search operators (one for rows and one for cols) shouldn\\'t you add them together instead of multiple? "
                    },
                    {
                        "username": "user2049D",
                        "content": "[@illya_holubiev](/illya_holubiev) For sure, you didn\\'t."
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "I have just passed in O(n)"
                    },
                    {
                        "username": "Indrijeet2042",
                        "content": "log(n*m)=log(n)+log(m) both are same."
                    },
                    {
                        "username": "harkiratsaini13",
                        "content": "Learn staircase search. Then you will easily solve this question and also Search a 2D Matrix II"
                    },
                    {
                        "username": "psionl0",
                        "content": "The staircase approach is not optimum for this problem since the end of each row is less than the start of the next which means that a row can be located by using a binary search."
                    },
                    {
                        "username": "AlekseyR007",
                        "content": "Why is it a jagged array (int[][]) in C#? I think it should be just a matrix like this int[,]."
                    },
                    {
                        "username": "nghia1303",
                        "content": "I wrote a O(n^2) solution but it still passed all the test cases "
                    }
                ]
            },
            {
                "id": 1962896,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "There are 4 approaches to this question:\\n\\n**1. Brute Force Approach:**\\nIterate over the whole matrix to find the element.\\nTime Complexity: O(n * m)\\n\\n**2. Better Approach:**\\nEach row is sorted, so we can apply binary search on each row to find the element.\\nTime Complexity: O(n * log(m))\\n\\n**3. More Better Approach:**\\nThe two-pointer approach starts from the top-right corner and moves either left or down, eliminating one row or column at each step. In the worst case, it will traverse either the entire top row or the entire rightmost column.\\nTime Complexity: O(n + m)\\n\\n**4. Optimal Approach:**\\nSince the 1st element of each row is greater than the last element of the previous row, this means that the whole matrix can be considered as sorted 1D array. So we can apply binary search over the whole matrix.\\nTime Complexity: O(log(n * m))\\n\\n[Codes for above approaches](https://github.com/amanhex/Leetcode-Solutions/blob/main/74.%20Search%20a%202D%20Matrix.cpp)"
                    },
                    {
                        "username": "alanmorais1503",
                        "content": "*** DON\\'T  LOOK IT MAY CONTAIN SOLUTION CODE***\\n\\nCan anyone check if the there is a bug in the platform, because this code should work I even code a unit test to make sure I am not crazy, I did some println!,  for some reason the return statement in the second loop is not exiting the function. \\n\\n`struct Solution{\\n}\\n\\nimpl Solution {\\n    pub fn search_matrix(self, matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let mut start = 0;\\n        let mut end = matrix.len() -1;\\n        let mut middle = 0;\\n\\n        while start != end {\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[middle][0] == target{\\n                return true;\\n            }else if target > matrix[middle][0] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        let row_to_search = start;\\n        start = 0;\\n        end = matrix[row_to_search].len() -1;\\n\\n        while start < end{\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[row_to_search][middle] == target{\\n                return true\\n            }else if target > matrix[row_to_search][middle] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        if matrix[row_to_search][start] == target{ true } else {false} \\n    }\\n}\\n\\npub fn main(){}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn it_works(){\\n        let sol = Solution{};\\n        let result = sol.search_matrix([[1,3,5,7].to_vec(),[10,11,16,20].to_vec(),[23,30,34,60].to_vec()].to_vec(), 3);\\n        assert_eq!(true, result);`\\n\\n  "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "we can make use of the fact that the first ele of each row is greater than the last ele of prev row.\\nby this way we can check the last ele of each row , if our target is bigger than the last ele of that row , it means that our target is not in that row , and we go to next row."
                    },
                    {
                        "username": "boyiddha_",
                        "content": "I applied binary search many times in 1D array/ matirx but never applied binary search in 2D array/ matrix. This problem gives this opportunity.\\n.\\nI learned new things; How to apply Binary Search in 2D array/ matrix!"
                    },
                    {
                        "username": "Vikas__7",
                        "content": "if you solve from nested loops then you time complexity is O(n^2).\nthen you solve this approach from different method like  - `int i = 0 , j = matrix[0].length - 1;`\nthen traverse the matrix\n\n "
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "As for me, this task should be an easy because it accepts the all solutions"
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "Anyone know why the solution is asking for a O(log(n * m)) instead of O(log(n) + log(m))? If you perform two binary search operators (one for rows and one for cols) shouldn\\'t you add them together instead of multiple? "
                    },
                    {
                        "username": "user2049D",
                        "content": "[@illya_holubiev](/illya_holubiev) For sure, you didn\\'t."
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "I have just passed in O(n)"
                    },
                    {
                        "username": "Indrijeet2042",
                        "content": "log(n*m)=log(n)+log(m) both are same."
                    },
                    {
                        "username": "harkiratsaini13",
                        "content": "Learn staircase search. Then you will easily solve this question and also Search a 2D Matrix II"
                    },
                    {
                        "username": "psionl0",
                        "content": "The staircase approach is not optimum for this problem since the end of each row is less than the start of the next which means that a row can be located by using a binary search."
                    },
                    {
                        "username": "AlekseyR007",
                        "content": "Why is it a jagged array (int[][]) in C#? I think it should be just a matrix like this int[,]."
                    },
                    {
                        "username": "nghia1303",
                        "content": "I wrote a O(n^2) solution but it still passed all the test cases "
                    }
                ]
            },
            {
                "id": 1960294,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "There are 4 approaches to this question:\\n\\n**1. Brute Force Approach:**\\nIterate over the whole matrix to find the element.\\nTime Complexity: O(n * m)\\n\\n**2. Better Approach:**\\nEach row is sorted, so we can apply binary search on each row to find the element.\\nTime Complexity: O(n * log(m))\\n\\n**3. More Better Approach:**\\nThe two-pointer approach starts from the top-right corner and moves either left or down, eliminating one row or column at each step. In the worst case, it will traverse either the entire top row or the entire rightmost column.\\nTime Complexity: O(n + m)\\n\\n**4. Optimal Approach:**\\nSince the 1st element of each row is greater than the last element of the previous row, this means that the whole matrix can be considered as sorted 1D array. So we can apply binary search over the whole matrix.\\nTime Complexity: O(log(n * m))\\n\\n[Codes for above approaches](https://github.com/amanhex/Leetcode-Solutions/blob/main/74.%20Search%20a%202D%20Matrix.cpp)"
                    },
                    {
                        "username": "alanmorais1503",
                        "content": "*** DON\\'T  LOOK IT MAY CONTAIN SOLUTION CODE***\\n\\nCan anyone check if the there is a bug in the platform, because this code should work I even code a unit test to make sure I am not crazy, I did some println!,  for some reason the return statement in the second loop is not exiting the function. \\n\\n`struct Solution{\\n}\\n\\nimpl Solution {\\n    pub fn search_matrix(self, matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let mut start = 0;\\n        let mut end = matrix.len() -1;\\n        let mut middle = 0;\\n\\n        while start != end {\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[middle][0] == target{\\n                return true;\\n            }else if target > matrix[middle][0] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        let row_to_search = start;\\n        start = 0;\\n        end = matrix[row_to_search].len() -1;\\n\\n        while start < end{\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[row_to_search][middle] == target{\\n                return true\\n            }else if target > matrix[row_to_search][middle] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        if matrix[row_to_search][start] == target{ true } else {false} \\n    }\\n}\\n\\npub fn main(){}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn it_works(){\\n        let sol = Solution{};\\n        let result = sol.search_matrix([[1,3,5,7].to_vec(),[10,11,16,20].to_vec(),[23,30,34,60].to_vec()].to_vec(), 3);\\n        assert_eq!(true, result);`\\n\\n  "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "we can make use of the fact that the first ele of each row is greater than the last ele of prev row.\\nby this way we can check the last ele of each row , if our target is bigger than the last ele of that row , it means that our target is not in that row , and we go to next row."
                    },
                    {
                        "username": "boyiddha_",
                        "content": "I applied binary search many times in 1D array/ matirx but never applied binary search in 2D array/ matrix. This problem gives this opportunity.\\n.\\nI learned new things; How to apply Binary Search in 2D array/ matrix!"
                    },
                    {
                        "username": "Vikas__7",
                        "content": "if you solve from nested loops then you time complexity is O(n^2).\nthen you solve this approach from different method like  - `int i = 0 , j = matrix[0].length - 1;`\nthen traverse the matrix\n\n "
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "As for me, this task should be an easy because it accepts the all solutions"
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "Anyone know why the solution is asking for a O(log(n * m)) instead of O(log(n) + log(m))? If you perform two binary search operators (one for rows and one for cols) shouldn\\'t you add them together instead of multiple? "
                    },
                    {
                        "username": "user2049D",
                        "content": "[@illya_holubiev](/illya_holubiev) For sure, you didn\\'t."
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "I have just passed in O(n)"
                    },
                    {
                        "username": "Indrijeet2042",
                        "content": "log(n*m)=log(n)+log(m) both are same."
                    },
                    {
                        "username": "harkiratsaini13",
                        "content": "Learn staircase search. Then you will easily solve this question and also Search a 2D Matrix II"
                    },
                    {
                        "username": "psionl0",
                        "content": "The staircase approach is not optimum for this problem since the end of each row is less than the start of the next which means that a row can be located by using a binary search."
                    },
                    {
                        "username": "AlekseyR007",
                        "content": "Why is it a jagged array (int[][]) in C#? I think it should be just a matrix like this int[,]."
                    },
                    {
                        "username": "nghia1303",
                        "content": "I wrote a O(n^2) solution but it still passed all the test cases "
                    }
                ]
            },
            {
                "id": 1960007,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "There are 4 approaches to this question:\\n\\n**1. Brute Force Approach:**\\nIterate over the whole matrix to find the element.\\nTime Complexity: O(n * m)\\n\\n**2. Better Approach:**\\nEach row is sorted, so we can apply binary search on each row to find the element.\\nTime Complexity: O(n * log(m))\\n\\n**3. More Better Approach:**\\nThe two-pointer approach starts from the top-right corner and moves either left or down, eliminating one row or column at each step. In the worst case, it will traverse either the entire top row or the entire rightmost column.\\nTime Complexity: O(n + m)\\n\\n**4. Optimal Approach:**\\nSince the 1st element of each row is greater than the last element of the previous row, this means that the whole matrix can be considered as sorted 1D array. So we can apply binary search over the whole matrix.\\nTime Complexity: O(log(n * m))\\n\\n[Codes for above approaches](https://github.com/amanhex/Leetcode-Solutions/blob/main/74.%20Search%20a%202D%20Matrix.cpp)"
                    },
                    {
                        "username": "alanmorais1503",
                        "content": "*** DON\\'T  LOOK IT MAY CONTAIN SOLUTION CODE***\\n\\nCan anyone check if the there is a bug in the platform, because this code should work I even code a unit test to make sure I am not crazy, I did some println!,  for some reason the return statement in the second loop is not exiting the function. \\n\\n`struct Solution{\\n}\\n\\nimpl Solution {\\n    pub fn search_matrix(self, matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let mut start = 0;\\n        let mut end = matrix.len() -1;\\n        let mut middle = 0;\\n\\n        while start != end {\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[middle][0] == target{\\n                return true;\\n            }else if target > matrix[middle][0] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        let row_to_search = start;\\n        start = 0;\\n        end = matrix[row_to_search].len() -1;\\n\\n        while start < end{\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[row_to_search][middle] == target{\\n                return true\\n            }else if target > matrix[row_to_search][middle] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        if matrix[row_to_search][start] == target{ true } else {false} \\n    }\\n}\\n\\npub fn main(){}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn it_works(){\\n        let sol = Solution{};\\n        let result = sol.search_matrix([[1,3,5,7].to_vec(),[10,11,16,20].to_vec(),[23,30,34,60].to_vec()].to_vec(), 3);\\n        assert_eq!(true, result);`\\n\\n  "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "we can make use of the fact that the first ele of each row is greater than the last ele of prev row.\\nby this way we can check the last ele of each row , if our target is bigger than the last ele of that row , it means that our target is not in that row , and we go to next row."
                    },
                    {
                        "username": "boyiddha_",
                        "content": "I applied binary search many times in 1D array/ matirx but never applied binary search in 2D array/ matrix. This problem gives this opportunity.\\n.\\nI learned new things; How to apply Binary Search in 2D array/ matrix!"
                    },
                    {
                        "username": "Vikas__7",
                        "content": "if you solve from nested loops then you time complexity is O(n^2).\nthen you solve this approach from different method like  - `int i = 0 , j = matrix[0].length - 1;`\nthen traverse the matrix\n\n "
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "As for me, this task should be an easy because it accepts the all solutions"
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "Anyone know why the solution is asking for a O(log(n * m)) instead of O(log(n) + log(m))? If you perform two binary search operators (one for rows and one for cols) shouldn\\'t you add them together instead of multiple? "
                    },
                    {
                        "username": "user2049D",
                        "content": "[@illya_holubiev](/illya_holubiev) For sure, you didn\\'t."
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "I have just passed in O(n)"
                    },
                    {
                        "username": "Indrijeet2042",
                        "content": "log(n*m)=log(n)+log(m) both are same."
                    },
                    {
                        "username": "harkiratsaini13",
                        "content": "Learn staircase search. Then you will easily solve this question and also Search a 2D Matrix II"
                    },
                    {
                        "username": "psionl0",
                        "content": "The staircase approach is not optimum for this problem since the end of each row is less than the start of the next which means that a row can be located by using a binary search."
                    },
                    {
                        "username": "AlekseyR007",
                        "content": "Why is it a jagged array (int[][]) in C#? I think it should be just a matrix like this int[,]."
                    },
                    {
                        "username": "nghia1303",
                        "content": "I wrote a O(n^2) solution but it still passed all the test cases "
                    }
                ]
            },
            {
                "id": 1951428,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "There are 4 approaches to this question:\\n\\n**1. Brute Force Approach:**\\nIterate over the whole matrix to find the element.\\nTime Complexity: O(n * m)\\n\\n**2. Better Approach:**\\nEach row is sorted, so we can apply binary search on each row to find the element.\\nTime Complexity: O(n * log(m))\\n\\n**3. More Better Approach:**\\nThe two-pointer approach starts from the top-right corner and moves either left or down, eliminating one row or column at each step. In the worst case, it will traverse either the entire top row or the entire rightmost column.\\nTime Complexity: O(n + m)\\n\\n**4. Optimal Approach:**\\nSince the 1st element of each row is greater than the last element of the previous row, this means that the whole matrix can be considered as sorted 1D array. So we can apply binary search over the whole matrix.\\nTime Complexity: O(log(n * m))\\n\\n[Codes for above approaches](https://github.com/amanhex/Leetcode-Solutions/blob/main/74.%20Search%20a%202D%20Matrix.cpp)"
                    },
                    {
                        "username": "alanmorais1503",
                        "content": "*** DON\\'T  LOOK IT MAY CONTAIN SOLUTION CODE***\\n\\nCan anyone check if the there is a bug in the platform, because this code should work I even code a unit test to make sure I am not crazy, I did some println!,  for some reason the return statement in the second loop is not exiting the function. \\n\\n`struct Solution{\\n}\\n\\nimpl Solution {\\n    pub fn search_matrix(self, matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let mut start = 0;\\n        let mut end = matrix.len() -1;\\n        let mut middle = 0;\\n\\n        while start != end {\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[middle][0] == target{\\n                return true;\\n            }else if target > matrix[middle][0] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        let row_to_search = start;\\n        start = 0;\\n        end = matrix[row_to_search].len() -1;\\n\\n        while start < end{\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[row_to_search][middle] == target{\\n                return true\\n            }else if target > matrix[row_to_search][middle] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        if matrix[row_to_search][start] == target{ true } else {false} \\n    }\\n}\\n\\npub fn main(){}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn it_works(){\\n        let sol = Solution{};\\n        let result = sol.search_matrix([[1,3,5,7].to_vec(),[10,11,16,20].to_vec(),[23,30,34,60].to_vec()].to_vec(), 3);\\n        assert_eq!(true, result);`\\n\\n  "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "we can make use of the fact that the first ele of each row is greater than the last ele of prev row.\\nby this way we can check the last ele of each row , if our target is bigger than the last ele of that row , it means that our target is not in that row , and we go to next row."
                    },
                    {
                        "username": "boyiddha_",
                        "content": "I applied binary search many times in 1D array/ matirx but never applied binary search in 2D array/ matrix. This problem gives this opportunity.\\n.\\nI learned new things; How to apply Binary Search in 2D array/ matrix!"
                    },
                    {
                        "username": "Vikas__7",
                        "content": "if you solve from nested loops then you time complexity is O(n^2).\nthen you solve this approach from different method like  - `int i = 0 , j = matrix[0].length - 1;`\nthen traverse the matrix\n\n "
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "As for me, this task should be an easy because it accepts the all solutions"
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "Anyone know why the solution is asking for a O(log(n * m)) instead of O(log(n) + log(m))? If you perform two binary search operators (one for rows and one for cols) shouldn\\'t you add them together instead of multiple? "
                    },
                    {
                        "username": "user2049D",
                        "content": "[@illya_holubiev](/illya_holubiev) For sure, you didn\\'t."
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "I have just passed in O(n)"
                    },
                    {
                        "username": "Indrijeet2042",
                        "content": "log(n*m)=log(n)+log(m) both are same."
                    },
                    {
                        "username": "harkiratsaini13",
                        "content": "Learn staircase search. Then you will easily solve this question and also Search a 2D Matrix II"
                    },
                    {
                        "username": "psionl0",
                        "content": "The staircase approach is not optimum for this problem since the end of each row is less than the start of the next which means that a row can be located by using a binary search."
                    },
                    {
                        "username": "AlekseyR007",
                        "content": "Why is it a jagged array (int[][]) in C#? I think it should be just a matrix like this int[,]."
                    },
                    {
                        "username": "nghia1303",
                        "content": "I wrote a O(n^2) solution but it still passed all the test cases "
                    }
                ]
            },
            {
                "id": 1949209,
                "content": [
                    {
                        "username": "amansingh4958",
                        "content": "There are 4 approaches to this question:\\n\\n**1. Brute Force Approach:**\\nIterate over the whole matrix to find the element.\\nTime Complexity: O(n * m)\\n\\n**2. Better Approach:**\\nEach row is sorted, so we can apply binary search on each row to find the element.\\nTime Complexity: O(n * log(m))\\n\\n**3. More Better Approach:**\\nThe two-pointer approach starts from the top-right corner and moves either left or down, eliminating one row or column at each step. In the worst case, it will traverse either the entire top row or the entire rightmost column.\\nTime Complexity: O(n + m)\\n\\n**4. Optimal Approach:**\\nSince the 1st element of each row is greater than the last element of the previous row, this means that the whole matrix can be considered as sorted 1D array. So we can apply binary search over the whole matrix.\\nTime Complexity: O(log(n * m))\\n\\n[Codes for above approaches](https://github.com/amanhex/Leetcode-Solutions/blob/main/74.%20Search%20a%202D%20Matrix.cpp)"
                    },
                    {
                        "username": "alanmorais1503",
                        "content": "*** DON\\'T  LOOK IT MAY CONTAIN SOLUTION CODE***\\n\\nCan anyone check if the there is a bug in the platform, because this code should work I even code a unit test to make sure I am not crazy, I did some println!,  for some reason the return statement in the second loop is not exiting the function. \\n\\n`struct Solution{\\n}\\n\\nimpl Solution {\\n    pub fn search_matrix(self, matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let mut start = 0;\\n        let mut end = matrix.len() -1;\\n        let mut middle = 0;\\n\\n        while start != end {\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[middle][0] == target{\\n                return true;\\n            }else if target > matrix[middle][0] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        let row_to_search = start;\\n        start = 0;\\n        end = matrix[row_to_search].len() -1;\\n\\n        while start < end{\\n            middle = start + (end - start) / 2;\\n\\n            if matrix[row_to_search][middle] == target{\\n                return true\\n            }else if target > matrix[row_to_search][middle] {\\n                start = middle + 1;\\n            }else {\\n                end = middle - 1;\\n            }\\n        }\\n\\n        if matrix[row_to_search][start] == target{ true } else {false} \\n    }\\n}\\n\\npub fn main(){}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn it_works(){\\n        let sol = Solution{};\\n        let result = sol.search_matrix([[1,3,5,7].to_vec(),[10,11,16,20].to_vec(),[23,30,34,60].to_vec()].to_vec(), 3);\\n        assert_eq!(true, result);`\\n\\n  "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "we can make use of the fact that the first ele of each row is greater than the last ele of prev row.\\nby this way we can check the last ele of each row , if our target is bigger than the last ele of that row , it means that our target is not in that row , and we go to next row."
                    },
                    {
                        "username": "boyiddha_",
                        "content": "I applied binary search many times in 1D array/ matirx but never applied binary search in 2D array/ matrix. This problem gives this opportunity.\\n.\\nI learned new things; How to apply Binary Search in 2D array/ matrix!"
                    },
                    {
                        "username": "Vikas__7",
                        "content": "if you solve from nested loops then you time complexity is O(n^2).\nthen you solve this approach from different method like  - `int i = 0 , j = matrix[0].length - 1;`\nthen traverse the matrix\n\n "
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "As for me, this task should be an easy because it accepts the all solutions"
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "Anyone know why the solution is asking for a O(log(n * m)) instead of O(log(n) + log(m))? If you perform two binary search operators (one for rows and one for cols) shouldn\\'t you add them together instead of multiple? "
                    },
                    {
                        "username": "user2049D",
                        "content": "[@illya_holubiev](/illya_holubiev) For sure, you didn\\'t."
                    },
                    {
                        "username": "illya_holubiev",
                        "content": "I have just passed in O(n)"
                    },
                    {
                        "username": "Indrijeet2042",
                        "content": "log(n*m)=log(n)+log(m) both are same."
                    },
                    {
                        "username": "harkiratsaini13",
                        "content": "Learn staircase search. Then you will easily solve this question and also Search a 2D Matrix II"
                    },
                    {
                        "username": "psionl0",
                        "content": "The staircase approach is not optimum for this problem since the end of each row is less than the start of the next which means that a row can be located by using a binary search."
                    },
                    {
                        "username": "AlekseyR007",
                        "content": "Why is it a jagged array (int[][]) in C#? I think it should be just a matrix like this int[,]."
                    },
                    {
                        "username": "nghia1303",
                        "content": "I wrote a O(n^2) solution but it still passed all the test cases "
                    }
                ]
            },
            {
                "id": 1946740,
                "content": [
                    {
                        "username": "quarkyy99",
                        "content": "Im getting the error in the binary search method where the array elements are [[1]] and target is 1 idk why my program isnt running\\n"
                    },
                    {
                        "username": "mastercode0001",
                        "content": "for log(m*n) T.C. you can apply following steps.\\n\\nAs que stats that matrix is sorted col as well as row wise so we can imagine this 2d matrix like a sorted array than apply binary search.\\n\\n1. for binary search\\n\\n  start = 0;\\n end = (n*m)-1; //last index of 2d matrix \\n\\n2. mid = (s+e)/2;\\n row and col for corresponding mid\\nrow = mid/m  //m = col size;\\nint col = mid%m;\\n\\n3. apply simple binary search.\\n\\n [leetcode](https://leetcode.com/problems/search-a-2d-matrix/submissions/978029907/)"
                    },
                    {
                        "username": "mEEt126",
                        "content": "1. Modified Binary Search on 1st column\\n2. Binary Search on row from step 1"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "Hint : converts the 2D matrix into a 1D representation and performs a binary search to find the target."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "that\\'s a quadratic time complexity,but this should be done in o(NlogN)"
                    },
                    {
                        "username": "hirithik05",
                        "content": " `class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int start = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int end  = row*col-1;\\n\\n        while(start<=end){\\n            int mid = (start)+(end-start)/2;\\n            int element = matrix[mid/col][mid%col];\\n            if(element==target){\\n                return true;\\n            }\\n            else if(element<target){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }mid = (start)+(end-start)/2;\\n        }\\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "lokhandepratham007",
                        "content": "why the code below is giving mentioned error for test case input:\\nmatrix=[[1],[3]]\\ntarget=2\\n\\n\\n `class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int pivot;\\n        if(target < matrix[0][0]) return false;\\n        for (int i=0;i<matrix.size();i++){\\n            \\n                if(matrix[0][i]==target) {return true;}\\n                else if (target<matrix[0][i]) {pivot = i-1;break;}\\n           \\n        }\\n\\n        for (int j=0;j<matrix[0].size();j++){\\n            if(matrix[pivot][j]==target) return true; \\n        }\\n\\n        return false;\\n        \\n    }\\n};`\\n\\n\\nError :\\n `==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000314 at pc 0x000000345e4c bp 0x7ffeac9a0610 sp 0x7ffeac9a0608\\nREAD of size 4 at 0x602000000314 thread T0\\n    #2 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000314 is located 0 bytes to the right of 4-byte region [0x602000000310,0x602000000314)\\nallocated by thread T0 here:\\n    #7 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8060: fa fa[04]fa fa fa 04 fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==30==ABORTING`"
                    },
                    {
                        "username": "logvinata",
                        "content": "This is easy, not medium - just a standard binary search"
                    },
                    {
                        "username": "abhaykesarwani",
                        "content": "class Solution {\\npublic:\\n    bool recur(vector<vector<int>>&matrix,int target,int i ,int j)\\n    {\\n    \\n        if(i<0 || j<0 || i>matrix.size()-1 || j>matrix[0].size()-1) return false;\\n        if(matrix[i][j] == target) return true;\\n        return(matrix[i][j]>target) ?recur(matrix,target,i--,j) : recur(matrix,target,i,j++);\\n\\n        return true;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       \\n        bool result = recur(matrix,target,matrix.size()-1,0);\\n        return result;\\n    }\\n};\\n\\nWhy is this givin TLE"
                    },
                    {
                        "username": "Raj_Singh005",
                        "content": "in the given matrix 3 is present but o/p for this is showing false (given test case)  for this test case but the correct output will be true (in my solution).\\n"
                    },
                    {
                        "username": "einsteine98",
                        "content": "I think I have a O(mlogn) solution and it still passes all tests.."
                    }
                ]
            },
            {
                "id": 1941297,
                "content": [
                    {
                        "username": "quarkyy99",
                        "content": "Im getting the error in the binary search method where the array elements are [[1]] and target is 1 idk why my program isnt running\\n"
                    },
                    {
                        "username": "mastercode0001",
                        "content": "for log(m*n) T.C. you can apply following steps.\\n\\nAs que stats that matrix is sorted col as well as row wise so we can imagine this 2d matrix like a sorted array than apply binary search.\\n\\n1. for binary search\\n\\n  start = 0;\\n end = (n*m)-1; //last index of 2d matrix \\n\\n2. mid = (s+e)/2;\\n row and col for corresponding mid\\nrow = mid/m  //m = col size;\\nint col = mid%m;\\n\\n3. apply simple binary search.\\n\\n [leetcode](https://leetcode.com/problems/search-a-2d-matrix/submissions/978029907/)"
                    },
                    {
                        "username": "mEEt126",
                        "content": "1. Modified Binary Search on 1st column\\n2. Binary Search on row from step 1"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "Hint : converts the 2D matrix into a 1D representation and performs a binary search to find the target."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "that\\'s a quadratic time complexity,but this should be done in o(NlogN)"
                    },
                    {
                        "username": "hirithik05",
                        "content": " `class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int start = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int end  = row*col-1;\\n\\n        while(start<=end){\\n            int mid = (start)+(end-start)/2;\\n            int element = matrix[mid/col][mid%col];\\n            if(element==target){\\n                return true;\\n            }\\n            else if(element<target){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }mid = (start)+(end-start)/2;\\n        }\\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "lokhandepratham007",
                        "content": "why the code below is giving mentioned error for test case input:\\nmatrix=[[1],[3]]\\ntarget=2\\n\\n\\n `class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int pivot;\\n        if(target < matrix[0][0]) return false;\\n        for (int i=0;i<matrix.size();i++){\\n            \\n                if(matrix[0][i]==target) {return true;}\\n                else if (target<matrix[0][i]) {pivot = i-1;break;}\\n           \\n        }\\n\\n        for (int j=0;j<matrix[0].size();j++){\\n            if(matrix[pivot][j]==target) return true; \\n        }\\n\\n        return false;\\n        \\n    }\\n};`\\n\\n\\nError :\\n `==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000314 at pc 0x000000345e4c bp 0x7ffeac9a0610 sp 0x7ffeac9a0608\\nREAD of size 4 at 0x602000000314 thread T0\\n    #2 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000314 is located 0 bytes to the right of 4-byte region [0x602000000310,0x602000000314)\\nallocated by thread T0 here:\\n    #7 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8060: fa fa[04]fa fa fa 04 fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==30==ABORTING`"
                    },
                    {
                        "username": "logvinata",
                        "content": "This is easy, not medium - just a standard binary search"
                    },
                    {
                        "username": "abhaykesarwani",
                        "content": "class Solution {\\npublic:\\n    bool recur(vector<vector<int>>&matrix,int target,int i ,int j)\\n    {\\n    \\n        if(i<0 || j<0 || i>matrix.size()-1 || j>matrix[0].size()-1) return false;\\n        if(matrix[i][j] == target) return true;\\n        return(matrix[i][j]>target) ?recur(matrix,target,i--,j) : recur(matrix,target,i,j++);\\n\\n        return true;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       \\n        bool result = recur(matrix,target,matrix.size()-1,0);\\n        return result;\\n    }\\n};\\n\\nWhy is this givin TLE"
                    },
                    {
                        "username": "Raj_Singh005",
                        "content": "in the given matrix 3 is present but o/p for this is showing false (given test case)  for this test case but the correct output will be true (in my solution).\\n"
                    },
                    {
                        "username": "einsteine98",
                        "content": "I think I have a O(mlogn) solution and it still passes all tests.."
                    }
                ]
            },
            {
                "id": 1918171,
                "content": [
                    {
                        "username": "quarkyy99",
                        "content": "Im getting the error in the binary search method where the array elements are [[1]] and target is 1 idk why my program isnt running\\n"
                    },
                    {
                        "username": "mastercode0001",
                        "content": "for log(m*n) T.C. you can apply following steps.\\n\\nAs que stats that matrix is sorted col as well as row wise so we can imagine this 2d matrix like a sorted array than apply binary search.\\n\\n1. for binary search\\n\\n  start = 0;\\n end = (n*m)-1; //last index of 2d matrix \\n\\n2. mid = (s+e)/2;\\n row and col for corresponding mid\\nrow = mid/m  //m = col size;\\nint col = mid%m;\\n\\n3. apply simple binary search.\\n\\n [leetcode](https://leetcode.com/problems/search-a-2d-matrix/submissions/978029907/)"
                    },
                    {
                        "username": "mEEt126",
                        "content": "1. Modified Binary Search on 1st column\\n2. Binary Search on row from step 1"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "Hint : converts the 2D matrix into a 1D representation and performs a binary search to find the target."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "that\\'s a quadratic time complexity,but this should be done in o(NlogN)"
                    },
                    {
                        "username": "hirithik05",
                        "content": " `class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int start = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int end  = row*col-1;\\n\\n        while(start<=end){\\n            int mid = (start)+(end-start)/2;\\n            int element = matrix[mid/col][mid%col];\\n            if(element==target){\\n                return true;\\n            }\\n            else if(element<target){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }mid = (start)+(end-start)/2;\\n        }\\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "lokhandepratham007",
                        "content": "why the code below is giving mentioned error for test case input:\\nmatrix=[[1],[3]]\\ntarget=2\\n\\n\\n `class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int pivot;\\n        if(target < matrix[0][0]) return false;\\n        for (int i=0;i<matrix.size();i++){\\n            \\n                if(matrix[0][i]==target) {return true;}\\n                else if (target<matrix[0][i]) {pivot = i-1;break;}\\n           \\n        }\\n\\n        for (int j=0;j<matrix[0].size();j++){\\n            if(matrix[pivot][j]==target) return true; \\n        }\\n\\n        return false;\\n        \\n    }\\n};`\\n\\n\\nError :\\n `==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000314 at pc 0x000000345e4c bp 0x7ffeac9a0610 sp 0x7ffeac9a0608\\nREAD of size 4 at 0x602000000314 thread T0\\n    #2 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000314 is located 0 bytes to the right of 4-byte region [0x602000000310,0x602000000314)\\nallocated by thread T0 here:\\n    #7 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8060: fa fa[04]fa fa fa 04 fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==30==ABORTING`"
                    },
                    {
                        "username": "logvinata",
                        "content": "This is easy, not medium - just a standard binary search"
                    },
                    {
                        "username": "abhaykesarwani",
                        "content": "class Solution {\\npublic:\\n    bool recur(vector<vector<int>>&matrix,int target,int i ,int j)\\n    {\\n    \\n        if(i<0 || j<0 || i>matrix.size()-1 || j>matrix[0].size()-1) return false;\\n        if(matrix[i][j] == target) return true;\\n        return(matrix[i][j]>target) ?recur(matrix,target,i--,j) : recur(matrix,target,i,j++);\\n\\n        return true;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       \\n        bool result = recur(matrix,target,matrix.size()-1,0);\\n        return result;\\n    }\\n};\\n\\nWhy is this givin TLE"
                    },
                    {
                        "username": "Raj_Singh005",
                        "content": "in the given matrix 3 is present but o/p for this is showing false (given test case)  for this test case but the correct output will be true (in my solution).\\n"
                    },
                    {
                        "username": "einsteine98",
                        "content": "I think I have a O(mlogn) solution and it still passes all tests.."
                    }
                ]
            },
            {
                "id": 1911881,
                "content": [
                    {
                        "username": "quarkyy99",
                        "content": "Im getting the error in the binary search method where the array elements are [[1]] and target is 1 idk why my program isnt running\\n"
                    },
                    {
                        "username": "mastercode0001",
                        "content": "for log(m*n) T.C. you can apply following steps.\\n\\nAs que stats that matrix is sorted col as well as row wise so we can imagine this 2d matrix like a sorted array than apply binary search.\\n\\n1. for binary search\\n\\n  start = 0;\\n end = (n*m)-1; //last index of 2d matrix \\n\\n2. mid = (s+e)/2;\\n row and col for corresponding mid\\nrow = mid/m  //m = col size;\\nint col = mid%m;\\n\\n3. apply simple binary search.\\n\\n [leetcode](https://leetcode.com/problems/search-a-2d-matrix/submissions/978029907/)"
                    },
                    {
                        "username": "mEEt126",
                        "content": "1. Modified Binary Search on 1st column\\n2. Binary Search on row from step 1"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "Hint : converts the 2D matrix into a 1D representation and performs a binary search to find the target."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "that\\'s a quadratic time complexity,but this should be done in o(NlogN)"
                    },
                    {
                        "username": "hirithik05",
                        "content": " `class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int start = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int end  = row*col-1;\\n\\n        while(start<=end){\\n            int mid = (start)+(end-start)/2;\\n            int element = matrix[mid/col][mid%col];\\n            if(element==target){\\n                return true;\\n            }\\n            else if(element<target){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }mid = (start)+(end-start)/2;\\n        }\\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "lokhandepratham007",
                        "content": "why the code below is giving mentioned error for test case input:\\nmatrix=[[1],[3]]\\ntarget=2\\n\\n\\n `class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int pivot;\\n        if(target < matrix[0][0]) return false;\\n        for (int i=0;i<matrix.size();i++){\\n            \\n                if(matrix[0][i]==target) {return true;}\\n                else if (target<matrix[0][i]) {pivot = i-1;break;}\\n           \\n        }\\n\\n        for (int j=0;j<matrix[0].size();j++){\\n            if(matrix[pivot][j]==target) return true; \\n        }\\n\\n        return false;\\n        \\n    }\\n};`\\n\\n\\nError :\\n `==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000314 at pc 0x000000345e4c bp 0x7ffeac9a0610 sp 0x7ffeac9a0608\\nREAD of size 4 at 0x602000000314 thread T0\\n    #2 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000314 is located 0 bytes to the right of 4-byte region [0x602000000310,0x602000000314)\\nallocated by thread T0 here:\\n    #7 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8060: fa fa[04]fa fa fa 04 fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==30==ABORTING`"
                    },
                    {
                        "username": "logvinata",
                        "content": "This is easy, not medium - just a standard binary search"
                    },
                    {
                        "username": "abhaykesarwani",
                        "content": "class Solution {\\npublic:\\n    bool recur(vector<vector<int>>&matrix,int target,int i ,int j)\\n    {\\n    \\n        if(i<0 || j<0 || i>matrix.size()-1 || j>matrix[0].size()-1) return false;\\n        if(matrix[i][j] == target) return true;\\n        return(matrix[i][j]>target) ?recur(matrix,target,i--,j) : recur(matrix,target,i,j++);\\n\\n        return true;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       \\n        bool result = recur(matrix,target,matrix.size()-1,0);\\n        return result;\\n    }\\n};\\n\\nWhy is this givin TLE"
                    },
                    {
                        "username": "Raj_Singh005",
                        "content": "in the given matrix 3 is present but o/p for this is showing false (given test case)  for this test case but the correct output will be true (in my solution).\\n"
                    },
                    {
                        "username": "einsteine98",
                        "content": "I think I have a O(mlogn) solution and it still passes all tests.."
                    }
                ]
            },
            {
                "id": 1872156,
                "content": [
                    {
                        "username": "quarkyy99",
                        "content": "Im getting the error in the binary search method where the array elements are [[1]] and target is 1 idk why my program isnt running\\n"
                    },
                    {
                        "username": "mastercode0001",
                        "content": "for log(m*n) T.C. you can apply following steps.\\n\\nAs que stats that matrix is sorted col as well as row wise so we can imagine this 2d matrix like a sorted array than apply binary search.\\n\\n1. for binary search\\n\\n  start = 0;\\n end = (n*m)-1; //last index of 2d matrix \\n\\n2. mid = (s+e)/2;\\n row and col for corresponding mid\\nrow = mid/m  //m = col size;\\nint col = mid%m;\\n\\n3. apply simple binary search.\\n\\n [leetcode](https://leetcode.com/problems/search-a-2d-matrix/submissions/978029907/)"
                    },
                    {
                        "username": "mEEt126",
                        "content": "1. Modified Binary Search on 1st column\\n2. Binary Search on row from step 1"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "Hint : converts the 2D matrix into a 1D representation and performs a binary search to find the target."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "that\\'s a quadratic time complexity,but this should be done in o(NlogN)"
                    },
                    {
                        "username": "hirithik05",
                        "content": " `class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int start = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int end  = row*col-1;\\n\\n        while(start<=end){\\n            int mid = (start)+(end-start)/2;\\n            int element = matrix[mid/col][mid%col];\\n            if(element==target){\\n                return true;\\n            }\\n            else if(element<target){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }mid = (start)+(end-start)/2;\\n        }\\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "lokhandepratham007",
                        "content": "why the code below is giving mentioned error for test case input:\\nmatrix=[[1],[3]]\\ntarget=2\\n\\n\\n `class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int pivot;\\n        if(target < matrix[0][0]) return false;\\n        for (int i=0;i<matrix.size();i++){\\n            \\n                if(matrix[0][i]==target) {return true;}\\n                else if (target<matrix[0][i]) {pivot = i-1;break;}\\n           \\n        }\\n\\n        for (int j=0;j<matrix[0].size();j++){\\n            if(matrix[pivot][j]==target) return true; \\n        }\\n\\n        return false;\\n        \\n    }\\n};`\\n\\n\\nError :\\n `==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000314 at pc 0x000000345e4c bp 0x7ffeac9a0610 sp 0x7ffeac9a0608\\nREAD of size 4 at 0x602000000314 thread T0\\n    #2 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000314 is located 0 bytes to the right of 4-byte region [0x602000000310,0x602000000314)\\nallocated by thread T0 here:\\n    #7 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8060: fa fa[04]fa fa fa 04 fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==30==ABORTING`"
                    },
                    {
                        "username": "logvinata",
                        "content": "This is easy, not medium - just a standard binary search"
                    },
                    {
                        "username": "abhaykesarwani",
                        "content": "class Solution {\\npublic:\\n    bool recur(vector<vector<int>>&matrix,int target,int i ,int j)\\n    {\\n    \\n        if(i<0 || j<0 || i>matrix.size()-1 || j>matrix[0].size()-1) return false;\\n        if(matrix[i][j] == target) return true;\\n        return(matrix[i][j]>target) ?recur(matrix,target,i--,j) : recur(matrix,target,i,j++);\\n\\n        return true;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       \\n        bool result = recur(matrix,target,matrix.size()-1,0);\\n        return result;\\n    }\\n};\\n\\nWhy is this givin TLE"
                    },
                    {
                        "username": "Raj_Singh005",
                        "content": "in the given matrix 3 is present but o/p for this is showing false (given test case)  for this test case but the correct output will be true (in my solution).\\n"
                    },
                    {
                        "username": "einsteine98",
                        "content": "I think I have a O(mlogn) solution and it still passes all tests.."
                    }
                ]
            },
            {
                "id": 1861665,
                "content": [
                    {
                        "username": "quarkyy99",
                        "content": "Im getting the error in the binary search method where the array elements are [[1]] and target is 1 idk why my program isnt running\\n"
                    },
                    {
                        "username": "mastercode0001",
                        "content": "for log(m*n) T.C. you can apply following steps.\\n\\nAs que stats that matrix is sorted col as well as row wise so we can imagine this 2d matrix like a sorted array than apply binary search.\\n\\n1. for binary search\\n\\n  start = 0;\\n end = (n*m)-1; //last index of 2d matrix \\n\\n2. mid = (s+e)/2;\\n row and col for corresponding mid\\nrow = mid/m  //m = col size;\\nint col = mid%m;\\n\\n3. apply simple binary search.\\n\\n [leetcode](https://leetcode.com/problems/search-a-2d-matrix/submissions/978029907/)"
                    },
                    {
                        "username": "mEEt126",
                        "content": "1. Modified Binary Search on 1st column\\n2. Binary Search on row from step 1"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "Hint : converts the 2D matrix into a 1D representation and performs a binary search to find the target."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "that\\'s a quadratic time complexity,but this should be done in o(NlogN)"
                    },
                    {
                        "username": "hirithik05",
                        "content": " `class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int start = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int end  = row*col-1;\\n\\n        while(start<=end){\\n            int mid = (start)+(end-start)/2;\\n            int element = matrix[mid/col][mid%col];\\n            if(element==target){\\n                return true;\\n            }\\n            else if(element<target){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }mid = (start)+(end-start)/2;\\n        }\\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "lokhandepratham007",
                        "content": "why the code below is giving mentioned error for test case input:\\nmatrix=[[1],[3]]\\ntarget=2\\n\\n\\n `class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int pivot;\\n        if(target < matrix[0][0]) return false;\\n        for (int i=0;i<matrix.size();i++){\\n            \\n                if(matrix[0][i]==target) {return true;}\\n                else if (target<matrix[0][i]) {pivot = i-1;break;}\\n           \\n        }\\n\\n        for (int j=0;j<matrix[0].size();j++){\\n            if(matrix[pivot][j]==target) return true; \\n        }\\n\\n        return false;\\n        \\n    }\\n};`\\n\\n\\nError :\\n `==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000314 at pc 0x000000345e4c bp 0x7ffeac9a0610 sp 0x7ffeac9a0608\\nREAD of size 4 at 0x602000000314 thread T0\\n    #2 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000314 is located 0 bytes to the right of 4-byte region [0x602000000310,0x602000000314)\\nallocated by thread T0 here:\\n    #7 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8060: fa fa[04]fa fa fa 04 fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==30==ABORTING`"
                    },
                    {
                        "username": "logvinata",
                        "content": "This is easy, not medium - just a standard binary search"
                    },
                    {
                        "username": "abhaykesarwani",
                        "content": "class Solution {\\npublic:\\n    bool recur(vector<vector<int>>&matrix,int target,int i ,int j)\\n    {\\n    \\n        if(i<0 || j<0 || i>matrix.size()-1 || j>matrix[0].size()-1) return false;\\n        if(matrix[i][j] == target) return true;\\n        return(matrix[i][j]>target) ?recur(matrix,target,i--,j) : recur(matrix,target,i,j++);\\n\\n        return true;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       \\n        bool result = recur(matrix,target,matrix.size()-1,0);\\n        return result;\\n    }\\n};\\n\\nWhy is this givin TLE"
                    },
                    {
                        "username": "Raj_Singh005",
                        "content": "in the given matrix 3 is present but o/p for this is showing false (given test case)  for this test case but the correct output will be true (in my solution).\\n"
                    },
                    {
                        "username": "einsteine98",
                        "content": "I think I have a O(mlogn) solution and it still passes all tests.."
                    }
                ]
            },
            {
                "id": 1854444,
                "content": [
                    {
                        "username": "quarkyy99",
                        "content": "Im getting the error in the binary search method where the array elements are [[1]] and target is 1 idk why my program isnt running\\n"
                    },
                    {
                        "username": "mastercode0001",
                        "content": "for log(m*n) T.C. you can apply following steps.\\n\\nAs que stats that matrix is sorted col as well as row wise so we can imagine this 2d matrix like a sorted array than apply binary search.\\n\\n1. for binary search\\n\\n  start = 0;\\n end = (n*m)-1; //last index of 2d matrix \\n\\n2. mid = (s+e)/2;\\n row and col for corresponding mid\\nrow = mid/m  //m = col size;\\nint col = mid%m;\\n\\n3. apply simple binary search.\\n\\n [leetcode](https://leetcode.com/problems/search-a-2d-matrix/submissions/978029907/)"
                    },
                    {
                        "username": "mEEt126",
                        "content": "1. Modified Binary Search on 1st column\\n2. Binary Search on row from step 1"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "Hint : converts the 2D matrix into a 1D representation and performs a binary search to find the target."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "that\\'s a quadratic time complexity,but this should be done in o(NlogN)"
                    },
                    {
                        "username": "hirithik05",
                        "content": " `class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int start = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int end  = row*col-1;\\n\\n        while(start<=end){\\n            int mid = (start)+(end-start)/2;\\n            int element = matrix[mid/col][mid%col];\\n            if(element==target){\\n                return true;\\n            }\\n            else if(element<target){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }mid = (start)+(end-start)/2;\\n        }\\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "lokhandepratham007",
                        "content": "why the code below is giving mentioned error for test case input:\\nmatrix=[[1],[3]]\\ntarget=2\\n\\n\\n `class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int pivot;\\n        if(target < matrix[0][0]) return false;\\n        for (int i=0;i<matrix.size();i++){\\n            \\n                if(matrix[0][i]==target) {return true;}\\n                else if (target<matrix[0][i]) {pivot = i-1;break;}\\n           \\n        }\\n\\n        for (int j=0;j<matrix[0].size();j++){\\n            if(matrix[pivot][j]==target) return true; \\n        }\\n\\n        return false;\\n        \\n    }\\n};`\\n\\n\\nError :\\n `==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000314 at pc 0x000000345e4c bp 0x7ffeac9a0610 sp 0x7ffeac9a0608\\nREAD of size 4 at 0x602000000314 thread T0\\n    #2 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000314 is located 0 bytes to the right of 4-byte region [0x602000000310,0x602000000314)\\nallocated by thread T0 here:\\n    #7 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8060: fa fa[04]fa fa fa 04 fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==30==ABORTING`"
                    },
                    {
                        "username": "logvinata",
                        "content": "This is easy, not medium - just a standard binary search"
                    },
                    {
                        "username": "abhaykesarwani",
                        "content": "class Solution {\\npublic:\\n    bool recur(vector<vector<int>>&matrix,int target,int i ,int j)\\n    {\\n    \\n        if(i<0 || j<0 || i>matrix.size()-1 || j>matrix[0].size()-1) return false;\\n        if(matrix[i][j] == target) return true;\\n        return(matrix[i][j]>target) ?recur(matrix,target,i--,j) : recur(matrix,target,i,j++);\\n\\n        return true;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       \\n        bool result = recur(matrix,target,matrix.size()-1,0);\\n        return result;\\n    }\\n};\\n\\nWhy is this givin TLE"
                    },
                    {
                        "username": "Raj_Singh005",
                        "content": "in the given matrix 3 is present but o/p for this is showing false (given test case)  for this test case but the correct output will be true (in my solution).\\n"
                    },
                    {
                        "username": "einsteine98",
                        "content": "I think I have a O(mlogn) solution and it still passes all tests.."
                    }
                ]
            },
            {
                "id": 1841144,
                "content": [
                    {
                        "username": "quarkyy99",
                        "content": "Im getting the error in the binary search method where the array elements are [[1]] and target is 1 idk why my program isnt running\\n"
                    },
                    {
                        "username": "mastercode0001",
                        "content": "for log(m*n) T.C. you can apply following steps.\\n\\nAs que stats that matrix is sorted col as well as row wise so we can imagine this 2d matrix like a sorted array than apply binary search.\\n\\n1. for binary search\\n\\n  start = 0;\\n end = (n*m)-1; //last index of 2d matrix \\n\\n2. mid = (s+e)/2;\\n row and col for corresponding mid\\nrow = mid/m  //m = col size;\\nint col = mid%m;\\n\\n3. apply simple binary search.\\n\\n [leetcode](https://leetcode.com/problems/search-a-2d-matrix/submissions/978029907/)"
                    },
                    {
                        "username": "mEEt126",
                        "content": "1. Modified Binary Search on 1st column\\n2. Binary Search on row from step 1"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "Hint : converts the 2D matrix into a 1D representation and performs a binary search to find the target."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "that\\'s a quadratic time complexity,but this should be done in o(NlogN)"
                    },
                    {
                        "username": "hirithik05",
                        "content": " `class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int start = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int end  = row*col-1;\\n\\n        while(start<=end){\\n            int mid = (start)+(end-start)/2;\\n            int element = matrix[mid/col][mid%col];\\n            if(element==target){\\n                return true;\\n            }\\n            else if(element<target){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }mid = (start)+(end-start)/2;\\n        }\\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "lokhandepratham007",
                        "content": "why the code below is giving mentioned error for test case input:\\nmatrix=[[1],[3]]\\ntarget=2\\n\\n\\n `class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int pivot;\\n        if(target < matrix[0][0]) return false;\\n        for (int i=0;i<matrix.size();i++){\\n            \\n                if(matrix[0][i]==target) {return true;}\\n                else if (target<matrix[0][i]) {pivot = i-1;break;}\\n           \\n        }\\n\\n        for (int j=0;j<matrix[0].size();j++){\\n            if(matrix[pivot][j]==target) return true; \\n        }\\n\\n        return false;\\n        \\n    }\\n};`\\n\\n\\nError :\\n `==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000314 at pc 0x000000345e4c bp 0x7ffeac9a0610 sp 0x7ffeac9a0608\\nREAD of size 4 at 0x602000000314 thread T0\\n    #2 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000314 is located 0 bytes to the right of 4-byte region [0x602000000310,0x602000000314)\\nallocated by thread T0 here:\\n    #7 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8060: fa fa[04]fa fa fa 04 fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==30==ABORTING`"
                    },
                    {
                        "username": "logvinata",
                        "content": "This is easy, not medium - just a standard binary search"
                    },
                    {
                        "username": "abhaykesarwani",
                        "content": "class Solution {\\npublic:\\n    bool recur(vector<vector<int>>&matrix,int target,int i ,int j)\\n    {\\n    \\n        if(i<0 || j<0 || i>matrix.size()-1 || j>matrix[0].size()-1) return false;\\n        if(matrix[i][j] == target) return true;\\n        return(matrix[i][j]>target) ?recur(matrix,target,i--,j) : recur(matrix,target,i,j++);\\n\\n        return true;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       \\n        bool result = recur(matrix,target,matrix.size()-1,0);\\n        return result;\\n    }\\n};\\n\\nWhy is this givin TLE"
                    },
                    {
                        "username": "Raj_Singh005",
                        "content": "in the given matrix 3 is present but o/p for this is showing false (given test case)  for this test case but the correct output will be true (in my solution).\\n"
                    },
                    {
                        "username": "einsteine98",
                        "content": "I think I have a O(mlogn) solution and it still passes all tests.."
                    }
                ]
            },
            {
                "id": 1840254,
                "content": [
                    {
                        "username": "quarkyy99",
                        "content": "Im getting the error in the binary search method where the array elements are [[1]] and target is 1 idk why my program isnt running\\n"
                    },
                    {
                        "username": "mastercode0001",
                        "content": "for log(m*n) T.C. you can apply following steps.\\n\\nAs que stats that matrix is sorted col as well as row wise so we can imagine this 2d matrix like a sorted array than apply binary search.\\n\\n1. for binary search\\n\\n  start = 0;\\n end = (n*m)-1; //last index of 2d matrix \\n\\n2. mid = (s+e)/2;\\n row and col for corresponding mid\\nrow = mid/m  //m = col size;\\nint col = mid%m;\\n\\n3. apply simple binary search.\\n\\n [leetcode](https://leetcode.com/problems/search-a-2d-matrix/submissions/978029907/)"
                    },
                    {
                        "username": "mEEt126",
                        "content": "1. Modified Binary Search on 1st column\\n2. Binary Search on row from step 1"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "Hint : converts the 2D matrix into a 1D representation and performs a binary search to find the target."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "that\\'s a quadratic time complexity,but this should be done in o(NlogN)"
                    },
                    {
                        "username": "hirithik05",
                        "content": " `class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int start = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int end  = row*col-1;\\n\\n        while(start<=end){\\n            int mid = (start)+(end-start)/2;\\n            int element = matrix[mid/col][mid%col];\\n            if(element==target){\\n                return true;\\n            }\\n            else if(element<target){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }mid = (start)+(end-start)/2;\\n        }\\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "lokhandepratham007",
                        "content": "why the code below is giving mentioned error for test case input:\\nmatrix=[[1],[3]]\\ntarget=2\\n\\n\\n `class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int pivot;\\n        if(target < matrix[0][0]) return false;\\n        for (int i=0;i<matrix.size();i++){\\n            \\n                if(matrix[0][i]==target) {return true;}\\n                else if (target<matrix[0][i]) {pivot = i-1;break;}\\n           \\n        }\\n\\n        for (int j=0;j<matrix[0].size();j++){\\n            if(matrix[pivot][j]==target) return true; \\n        }\\n\\n        return false;\\n        \\n    }\\n};`\\n\\n\\nError :\\n `==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000314 at pc 0x000000345e4c bp 0x7ffeac9a0610 sp 0x7ffeac9a0608\\nREAD of size 4 at 0x602000000314 thread T0\\n    #2 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000314 is located 0 bytes to the right of 4-byte region [0x602000000310,0x602000000314)\\nallocated by thread T0 here:\\n    #7 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8060: fa fa[04]fa fa fa 04 fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==30==ABORTING`"
                    },
                    {
                        "username": "logvinata",
                        "content": "This is easy, not medium - just a standard binary search"
                    },
                    {
                        "username": "abhaykesarwani",
                        "content": "class Solution {\\npublic:\\n    bool recur(vector<vector<int>>&matrix,int target,int i ,int j)\\n    {\\n    \\n        if(i<0 || j<0 || i>matrix.size()-1 || j>matrix[0].size()-1) return false;\\n        if(matrix[i][j] == target) return true;\\n        return(matrix[i][j]>target) ?recur(matrix,target,i--,j) : recur(matrix,target,i,j++);\\n\\n        return true;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       \\n        bool result = recur(matrix,target,matrix.size()-1,0);\\n        return result;\\n    }\\n};\\n\\nWhy is this givin TLE"
                    },
                    {
                        "username": "Raj_Singh005",
                        "content": "in the given matrix 3 is present but o/p for this is showing false (given test case)  for this test case but the correct output will be true (in my solution).\\n"
                    },
                    {
                        "username": "einsteine98",
                        "content": "I think I have a O(mlogn) solution and it still passes all tests.."
                    }
                ]
            },
            {
                "id": 1840009,
                "content": [
                    {
                        "username": "quarkyy99",
                        "content": "Im getting the error in the binary search method where the array elements are [[1]] and target is 1 idk why my program isnt running\\n"
                    },
                    {
                        "username": "mastercode0001",
                        "content": "for log(m*n) T.C. you can apply following steps.\\n\\nAs que stats that matrix is sorted col as well as row wise so we can imagine this 2d matrix like a sorted array than apply binary search.\\n\\n1. for binary search\\n\\n  start = 0;\\n end = (n*m)-1; //last index of 2d matrix \\n\\n2. mid = (s+e)/2;\\n row and col for corresponding mid\\nrow = mid/m  //m = col size;\\nint col = mid%m;\\n\\n3. apply simple binary search.\\n\\n [leetcode](https://leetcode.com/problems/search-a-2d-matrix/submissions/978029907/)"
                    },
                    {
                        "username": "mEEt126",
                        "content": "1. Modified Binary Search on 1st column\\n2. Binary Search on row from step 1"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "Hint : converts the 2D matrix into a 1D representation and performs a binary search to find the target."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "that\\'s a quadratic time complexity,but this should be done in o(NlogN)"
                    },
                    {
                        "username": "hirithik05",
                        "content": " `class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int start = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int end  = row*col-1;\\n\\n        while(start<=end){\\n            int mid = (start)+(end-start)/2;\\n            int element = matrix[mid/col][mid%col];\\n            if(element==target){\\n                return true;\\n            }\\n            else if(element<target){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }mid = (start)+(end-start)/2;\\n        }\\n        return false;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "lokhandepratham007",
                        "content": "why the code below is giving mentioned error for test case input:\\nmatrix=[[1],[3]]\\ntarget=2\\n\\n\\n `class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int pivot;\\n        if(target < matrix[0][0]) return false;\\n        for (int i=0;i<matrix.size();i++){\\n            \\n                if(matrix[0][i]==target) {return true;}\\n                else if (target<matrix[0][i]) {pivot = i-1;break;}\\n           \\n        }\\n\\n        for (int j=0;j<matrix[0].size();j++){\\n            if(matrix[pivot][j]==target) return true; \\n        }\\n\\n        return false;\\n        \\n    }\\n};`\\n\\n\\nError :\\n `==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000314 at pc 0x000000345e4c bp 0x7ffeac9a0610 sp 0x7ffeac9a0608\\nREAD of size 4 at 0x602000000314 thread T0\\n    #2 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000314 is located 0 bytes to the right of 4-byte region [0x602000000310,0x602000000314)\\nallocated by thread T0 here:\\n    #7 0x7f4fbb28d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8010: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8020: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8060: fa fa[04]fa fa fa 04 fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==30==ABORTING`"
                    },
                    {
                        "username": "logvinata",
                        "content": "This is easy, not medium - just a standard binary search"
                    },
                    {
                        "username": "abhaykesarwani",
                        "content": "class Solution {\\npublic:\\n    bool recur(vector<vector<int>>&matrix,int target,int i ,int j)\\n    {\\n    \\n        if(i<0 || j<0 || i>matrix.size()-1 || j>matrix[0].size()-1) return false;\\n        if(matrix[i][j] == target) return true;\\n        return(matrix[i][j]>target) ?recur(matrix,target,i--,j) : recur(matrix,target,i,j++);\\n\\n        return true;\\n    }\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       \\n        bool result = recur(matrix,target,matrix.size()-1,0);\\n        return result;\\n    }\\n};\\n\\nWhy is this givin TLE"
                    },
                    {
                        "username": "Raj_Singh005",
                        "content": "in the given matrix 3 is present but o/p for this is showing false (given test case)  for this test case but the correct output will be true (in my solution).\\n"
                    },
                    {
                        "username": "einsteine98",
                        "content": "I think I have a O(mlogn) solution and it still passes all tests.."
                    }
                ]
            },
            {
                "id": 1836057,
                "content": [
                    {
                        "username": "alikhanarman786",
                        "content": "Java Solution\\n\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int r=0;\\n        for(int i = 0 ; i < m;i++){\\n            if(matrix[i][0]<=target && matrix[i][matrix[i].length-1]>=target){\\n                r=i;\\n            }\\n        }\\n    \\n        for(int i = 0 ; i < matrix[r].length ; i++){\\n            \\n            if(matrix[r][i] == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kumar30roshan",
                        "content": "i think this question tag should be easy , simply you have find mid row first by using one binary search for row of matrix by taking column  index 0, then again by using binary search you can find the column of target if present in array else return false. It will take time complexity log(m+n). "
                    },
                    {
                        "username": "pr1524",
                        "content": "Beats 100%  \\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int s = 0;\\n        int e = row*col-1;\\n\\n        int mid = s + (e-s)/2;\\n\\n        while(s<=e)\\n        {\\n            int element = matrix[mid/col][mid%col];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                s = mid + 1;\\n            \\n            else\\n                e = mid - 1;\\n            \\n            mid = s + (e-s)/2;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "AmritpalSIngh2002",
                        "content": "//can anyone tell me why my testcases are not passing  for the following code\\n int row = 0, column = matrix.length-1;\\n        while(row<matrix.length && column>0){\\n            if(matrix[row][column]==target){\\n                return true;\\n            }\\n            else if (matrix[row][column]<target){\\n                row++;\\n            }\\n            else{\\n                column--;\\n            }\\n        }\\n        return false;"
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "I think this question should be marked as easy."
                    },
                    {
                        "username": "seraphsword",
                        "content": "I think I found a bug. I wrote my code, but after hitting `return true;` it just starts the whole thing over again from the beginning, without completing the test case. I have `cout` messages that show that the true condition fires, and then everything keeps running.\nDoes it just keep going if you don't hit the O(log m * n) requirement? With no useful information to let you know? I'm sure my code can be massively improved, but I do think it mostly fits the parameters of binary search.\n```class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int position = (m * n)/2;\n        int gap = position;\n        cout << \"gap \" << gap << endl;\n        cout << \"position \" << position << endl;\n        while (gap >= 1)\n        {\n            int x, y;\n            if (position >= m)\n            {\n                x = position/m - 1;\n            } else\n            {\n                x = 0;\n            }\n            if (position >= n)\n            {\n                y = position % n - 1;\n            } else\n            {\n                y = position - 1;\n            }\n            if (matrix[x][y] == target)\n            {\n                cout << \"true\" << endl;\n                gap = 0;\n                return true;\n            } else if (matrix[x][y] > target)\n            {\n                int temp = position;\n                position -= gap/2;\n                gap = temp - position;\n            } else if (matrix[x][y] < target)\n            {\n                int temp = position;\n                position += gap/2;\n                gap = position - temp;\n            }\n        }\n        return false;\n    }\n};```\n"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing's happening with my code. Did you find any way around this?"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The problem makes no guarantees on ordering within other columns.\n    e.x. \n    1 2 100\n    2 3 4\n    3 4 5\n    is a valid input according to description. However, in the official solution, \n    it treats the matrix as a folded, sorted list which makes the above example invalid. \nAm i missing anything here?"
                    },
                    {
                        "username": "nikitamanjhi",
                        "content": "It\\'s not a valid input, because in description it\\'s given that 1st element of each row should be greater than the last element of previous row, but in your example 2 is not greater than 100."
                    },
                    {
                        "username": "itsmerachit",
                        "content": "Hello community,\\nI posted a solution with for( ; ; ) loop and it got a runtime of 104ms. Meanwhile I submitted the same solution with while(true) and got 45ms. \\nMy language of submission was Javascript. Can anyone tell me how they are different while there is no documentation available there which states a while is faster than a for. "
                    },
                    {
                        "username": "paljugnu50",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                if(matrix[i][j]==target)\\n                return true;\\n                \\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n    \\n}"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": " `your inline code...\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int start=0;\\n        int end= row*col-1;\\n\\n        int mid= start+(end-start)/2;\\n\\n        while(start<=end){\\n          int element=matrix[mid/col][mid%col];\\n          if(element == target){\\n            return 1;\\n          }\\n          else if(element<target){\\n            start=mid+1;\\n          }\\n          else{\\n            end=mid-1;\\n          }\\n          int mid= start+(end-start)/2;\\n        }\\n        return 0;\\n    }\\n\\nyour inline code...`\\n\\nthis is giving me a TLE ,whyy???"
                    }
                ]
            },
            {
                "id": 1816622,
                "content": [
                    {
                        "username": "alikhanarman786",
                        "content": "Java Solution\\n\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int r=0;\\n        for(int i = 0 ; i < m;i++){\\n            if(matrix[i][0]<=target && matrix[i][matrix[i].length-1]>=target){\\n                r=i;\\n            }\\n        }\\n    \\n        for(int i = 0 ; i < matrix[r].length ; i++){\\n            \\n            if(matrix[r][i] == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kumar30roshan",
                        "content": "i think this question tag should be easy , simply you have find mid row first by using one binary search for row of matrix by taking column  index 0, then again by using binary search you can find the column of target if present in array else return false. It will take time complexity log(m+n). "
                    },
                    {
                        "username": "pr1524",
                        "content": "Beats 100%  \\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int s = 0;\\n        int e = row*col-1;\\n\\n        int mid = s + (e-s)/2;\\n\\n        while(s<=e)\\n        {\\n            int element = matrix[mid/col][mid%col];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                s = mid + 1;\\n            \\n            else\\n                e = mid - 1;\\n            \\n            mid = s + (e-s)/2;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "AmritpalSIngh2002",
                        "content": "//can anyone tell me why my testcases are not passing  for the following code\\n int row = 0, column = matrix.length-1;\\n        while(row<matrix.length && column>0){\\n            if(matrix[row][column]==target){\\n                return true;\\n            }\\n            else if (matrix[row][column]<target){\\n                row++;\\n            }\\n            else{\\n                column--;\\n            }\\n        }\\n        return false;"
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "I think this question should be marked as easy."
                    },
                    {
                        "username": "seraphsword",
                        "content": "I think I found a bug. I wrote my code, but after hitting `return true;` it just starts the whole thing over again from the beginning, without completing the test case. I have `cout` messages that show that the true condition fires, and then everything keeps running.\nDoes it just keep going if you don't hit the O(log m * n) requirement? With no useful information to let you know? I'm sure my code can be massively improved, but I do think it mostly fits the parameters of binary search.\n```class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int position = (m * n)/2;\n        int gap = position;\n        cout << \"gap \" << gap << endl;\n        cout << \"position \" << position << endl;\n        while (gap >= 1)\n        {\n            int x, y;\n            if (position >= m)\n            {\n                x = position/m - 1;\n            } else\n            {\n                x = 0;\n            }\n            if (position >= n)\n            {\n                y = position % n - 1;\n            } else\n            {\n                y = position - 1;\n            }\n            if (matrix[x][y] == target)\n            {\n                cout << \"true\" << endl;\n                gap = 0;\n                return true;\n            } else if (matrix[x][y] > target)\n            {\n                int temp = position;\n                position -= gap/2;\n                gap = temp - position;\n            } else if (matrix[x][y] < target)\n            {\n                int temp = position;\n                position += gap/2;\n                gap = position - temp;\n            }\n        }\n        return false;\n    }\n};```\n"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing's happening with my code. Did you find any way around this?"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The problem makes no guarantees on ordering within other columns.\n    e.x. \n    1 2 100\n    2 3 4\n    3 4 5\n    is a valid input according to description. However, in the official solution, \n    it treats the matrix as a folded, sorted list which makes the above example invalid. \nAm i missing anything here?"
                    },
                    {
                        "username": "nikitamanjhi",
                        "content": "It\\'s not a valid input, because in description it\\'s given that 1st element of each row should be greater than the last element of previous row, but in your example 2 is not greater than 100."
                    },
                    {
                        "username": "itsmerachit",
                        "content": "Hello community,\\nI posted a solution with for( ; ; ) loop and it got a runtime of 104ms. Meanwhile I submitted the same solution with while(true) and got 45ms. \\nMy language of submission was Javascript. Can anyone tell me how they are different while there is no documentation available there which states a while is faster than a for. "
                    },
                    {
                        "username": "paljugnu50",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                if(matrix[i][j]==target)\\n                return true;\\n                \\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n    \\n}"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": " `your inline code...\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int start=0;\\n        int end= row*col-1;\\n\\n        int mid= start+(end-start)/2;\\n\\n        while(start<=end){\\n          int element=matrix[mid/col][mid%col];\\n          if(element == target){\\n            return 1;\\n          }\\n          else if(element<target){\\n            start=mid+1;\\n          }\\n          else{\\n            end=mid-1;\\n          }\\n          int mid= start+(end-start)/2;\\n        }\\n        return 0;\\n    }\\n\\nyour inline code...`\\n\\nthis is giving me a TLE ,whyy???"
                    }
                ]
            },
            {
                "id": 1799421,
                "content": [
                    {
                        "username": "alikhanarman786",
                        "content": "Java Solution\\n\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int r=0;\\n        for(int i = 0 ; i < m;i++){\\n            if(matrix[i][0]<=target && matrix[i][matrix[i].length-1]>=target){\\n                r=i;\\n            }\\n        }\\n    \\n        for(int i = 0 ; i < matrix[r].length ; i++){\\n            \\n            if(matrix[r][i] == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kumar30roshan",
                        "content": "i think this question tag should be easy , simply you have find mid row first by using one binary search for row of matrix by taking column  index 0, then again by using binary search you can find the column of target if present in array else return false. It will take time complexity log(m+n). "
                    },
                    {
                        "username": "pr1524",
                        "content": "Beats 100%  \\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int s = 0;\\n        int e = row*col-1;\\n\\n        int mid = s + (e-s)/2;\\n\\n        while(s<=e)\\n        {\\n            int element = matrix[mid/col][mid%col];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                s = mid + 1;\\n            \\n            else\\n                e = mid - 1;\\n            \\n            mid = s + (e-s)/2;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "AmritpalSIngh2002",
                        "content": "//can anyone tell me why my testcases are not passing  for the following code\\n int row = 0, column = matrix.length-1;\\n        while(row<matrix.length && column>0){\\n            if(matrix[row][column]==target){\\n                return true;\\n            }\\n            else if (matrix[row][column]<target){\\n                row++;\\n            }\\n            else{\\n                column--;\\n            }\\n        }\\n        return false;"
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "I think this question should be marked as easy."
                    },
                    {
                        "username": "seraphsword",
                        "content": "I think I found a bug. I wrote my code, but after hitting `return true;` it just starts the whole thing over again from the beginning, without completing the test case. I have `cout` messages that show that the true condition fires, and then everything keeps running.\nDoes it just keep going if you don't hit the O(log m * n) requirement? With no useful information to let you know? I'm sure my code can be massively improved, but I do think it mostly fits the parameters of binary search.\n```class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int position = (m * n)/2;\n        int gap = position;\n        cout << \"gap \" << gap << endl;\n        cout << \"position \" << position << endl;\n        while (gap >= 1)\n        {\n            int x, y;\n            if (position >= m)\n            {\n                x = position/m - 1;\n            } else\n            {\n                x = 0;\n            }\n            if (position >= n)\n            {\n                y = position % n - 1;\n            } else\n            {\n                y = position - 1;\n            }\n            if (matrix[x][y] == target)\n            {\n                cout << \"true\" << endl;\n                gap = 0;\n                return true;\n            } else if (matrix[x][y] > target)\n            {\n                int temp = position;\n                position -= gap/2;\n                gap = temp - position;\n            } else if (matrix[x][y] < target)\n            {\n                int temp = position;\n                position += gap/2;\n                gap = position - temp;\n            }\n        }\n        return false;\n    }\n};```\n"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing's happening with my code. Did you find any way around this?"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The problem makes no guarantees on ordering within other columns.\n    e.x. \n    1 2 100\n    2 3 4\n    3 4 5\n    is a valid input according to description. However, in the official solution, \n    it treats the matrix as a folded, sorted list which makes the above example invalid. \nAm i missing anything here?"
                    },
                    {
                        "username": "nikitamanjhi",
                        "content": "It\\'s not a valid input, because in description it\\'s given that 1st element of each row should be greater than the last element of previous row, but in your example 2 is not greater than 100."
                    },
                    {
                        "username": "itsmerachit",
                        "content": "Hello community,\\nI posted a solution with for( ; ; ) loop and it got a runtime of 104ms. Meanwhile I submitted the same solution with while(true) and got 45ms. \\nMy language of submission was Javascript. Can anyone tell me how they are different while there is no documentation available there which states a while is faster than a for. "
                    },
                    {
                        "username": "paljugnu50",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                if(matrix[i][j]==target)\\n                return true;\\n                \\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n    \\n}"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": " `your inline code...\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int start=0;\\n        int end= row*col-1;\\n\\n        int mid= start+(end-start)/2;\\n\\n        while(start<=end){\\n          int element=matrix[mid/col][mid%col];\\n          if(element == target){\\n            return 1;\\n          }\\n          else if(element<target){\\n            start=mid+1;\\n          }\\n          else{\\n            end=mid-1;\\n          }\\n          int mid= start+(end-start)/2;\\n        }\\n        return 0;\\n    }\\n\\nyour inline code...`\\n\\nthis is giving me a TLE ,whyy???"
                    }
                ]
            },
            {
                "id": 1795162,
                "content": [
                    {
                        "username": "alikhanarman786",
                        "content": "Java Solution\\n\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int r=0;\\n        for(int i = 0 ; i < m;i++){\\n            if(matrix[i][0]<=target && matrix[i][matrix[i].length-1]>=target){\\n                r=i;\\n            }\\n        }\\n    \\n        for(int i = 0 ; i < matrix[r].length ; i++){\\n            \\n            if(matrix[r][i] == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kumar30roshan",
                        "content": "i think this question tag should be easy , simply you have find mid row first by using one binary search for row of matrix by taking column  index 0, then again by using binary search you can find the column of target if present in array else return false. It will take time complexity log(m+n). "
                    },
                    {
                        "username": "pr1524",
                        "content": "Beats 100%  \\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int s = 0;\\n        int e = row*col-1;\\n\\n        int mid = s + (e-s)/2;\\n\\n        while(s<=e)\\n        {\\n            int element = matrix[mid/col][mid%col];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                s = mid + 1;\\n            \\n            else\\n                e = mid - 1;\\n            \\n            mid = s + (e-s)/2;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "AmritpalSIngh2002",
                        "content": "//can anyone tell me why my testcases are not passing  for the following code\\n int row = 0, column = matrix.length-1;\\n        while(row<matrix.length && column>0){\\n            if(matrix[row][column]==target){\\n                return true;\\n            }\\n            else if (matrix[row][column]<target){\\n                row++;\\n            }\\n            else{\\n                column--;\\n            }\\n        }\\n        return false;"
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "I think this question should be marked as easy."
                    },
                    {
                        "username": "seraphsword",
                        "content": "I think I found a bug. I wrote my code, but after hitting `return true;` it just starts the whole thing over again from the beginning, without completing the test case. I have `cout` messages that show that the true condition fires, and then everything keeps running.\nDoes it just keep going if you don't hit the O(log m * n) requirement? With no useful information to let you know? I'm sure my code can be massively improved, but I do think it mostly fits the parameters of binary search.\n```class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int position = (m * n)/2;\n        int gap = position;\n        cout << \"gap \" << gap << endl;\n        cout << \"position \" << position << endl;\n        while (gap >= 1)\n        {\n            int x, y;\n            if (position >= m)\n            {\n                x = position/m - 1;\n            } else\n            {\n                x = 0;\n            }\n            if (position >= n)\n            {\n                y = position % n - 1;\n            } else\n            {\n                y = position - 1;\n            }\n            if (matrix[x][y] == target)\n            {\n                cout << \"true\" << endl;\n                gap = 0;\n                return true;\n            } else if (matrix[x][y] > target)\n            {\n                int temp = position;\n                position -= gap/2;\n                gap = temp - position;\n            } else if (matrix[x][y] < target)\n            {\n                int temp = position;\n                position += gap/2;\n                gap = position - temp;\n            }\n        }\n        return false;\n    }\n};```\n"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing's happening with my code. Did you find any way around this?"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The problem makes no guarantees on ordering within other columns.\n    e.x. \n    1 2 100\n    2 3 4\n    3 4 5\n    is a valid input according to description. However, in the official solution, \n    it treats the matrix as a folded, sorted list which makes the above example invalid. \nAm i missing anything here?"
                    },
                    {
                        "username": "nikitamanjhi",
                        "content": "It\\'s not a valid input, because in description it\\'s given that 1st element of each row should be greater than the last element of previous row, but in your example 2 is not greater than 100."
                    },
                    {
                        "username": "itsmerachit",
                        "content": "Hello community,\\nI posted a solution with for( ; ; ) loop and it got a runtime of 104ms. Meanwhile I submitted the same solution with while(true) and got 45ms. \\nMy language of submission was Javascript. Can anyone tell me how they are different while there is no documentation available there which states a while is faster than a for. "
                    },
                    {
                        "username": "paljugnu50",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                if(matrix[i][j]==target)\\n                return true;\\n                \\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n    \\n}"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": " `your inline code...\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int start=0;\\n        int end= row*col-1;\\n\\n        int mid= start+(end-start)/2;\\n\\n        while(start<=end){\\n          int element=matrix[mid/col][mid%col];\\n          if(element == target){\\n            return 1;\\n          }\\n          else if(element<target){\\n            start=mid+1;\\n          }\\n          else{\\n            end=mid-1;\\n          }\\n          int mid= start+(end-start)/2;\\n        }\\n        return 0;\\n    }\\n\\nyour inline code...`\\n\\nthis is giving me a TLE ,whyy???"
                    }
                ]
            },
            {
                "id": 1789561,
                "content": [
                    {
                        "username": "alikhanarman786",
                        "content": "Java Solution\\n\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int r=0;\\n        for(int i = 0 ; i < m;i++){\\n            if(matrix[i][0]<=target && matrix[i][matrix[i].length-1]>=target){\\n                r=i;\\n            }\\n        }\\n    \\n        for(int i = 0 ; i < matrix[r].length ; i++){\\n            \\n            if(matrix[r][i] == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kumar30roshan",
                        "content": "i think this question tag should be easy , simply you have find mid row first by using one binary search for row of matrix by taking column  index 0, then again by using binary search you can find the column of target if present in array else return false. It will take time complexity log(m+n). "
                    },
                    {
                        "username": "pr1524",
                        "content": "Beats 100%  \\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int s = 0;\\n        int e = row*col-1;\\n\\n        int mid = s + (e-s)/2;\\n\\n        while(s<=e)\\n        {\\n            int element = matrix[mid/col][mid%col];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                s = mid + 1;\\n            \\n            else\\n                e = mid - 1;\\n            \\n            mid = s + (e-s)/2;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "AmritpalSIngh2002",
                        "content": "//can anyone tell me why my testcases are not passing  for the following code\\n int row = 0, column = matrix.length-1;\\n        while(row<matrix.length && column>0){\\n            if(matrix[row][column]==target){\\n                return true;\\n            }\\n            else if (matrix[row][column]<target){\\n                row++;\\n            }\\n            else{\\n                column--;\\n            }\\n        }\\n        return false;"
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "I think this question should be marked as easy."
                    },
                    {
                        "username": "seraphsword",
                        "content": "I think I found a bug. I wrote my code, but after hitting `return true;` it just starts the whole thing over again from the beginning, without completing the test case. I have `cout` messages that show that the true condition fires, and then everything keeps running.\nDoes it just keep going if you don't hit the O(log m * n) requirement? With no useful information to let you know? I'm sure my code can be massively improved, but I do think it mostly fits the parameters of binary search.\n```class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int position = (m * n)/2;\n        int gap = position;\n        cout << \"gap \" << gap << endl;\n        cout << \"position \" << position << endl;\n        while (gap >= 1)\n        {\n            int x, y;\n            if (position >= m)\n            {\n                x = position/m - 1;\n            } else\n            {\n                x = 0;\n            }\n            if (position >= n)\n            {\n                y = position % n - 1;\n            } else\n            {\n                y = position - 1;\n            }\n            if (matrix[x][y] == target)\n            {\n                cout << \"true\" << endl;\n                gap = 0;\n                return true;\n            } else if (matrix[x][y] > target)\n            {\n                int temp = position;\n                position -= gap/2;\n                gap = temp - position;\n            } else if (matrix[x][y] < target)\n            {\n                int temp = position;\n                position += gap/2;\n                gap = position - temp;\n            }\n        }\n        return false;\n    }\n};```\n"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing's happening with my code. Did you find any way around this?"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The problem makes no guarantees on ordering within other columns.\n    e.x. \n    1 2 100\n    2 3 4\n    3 4 5\n    is a valid input according to description. However, in the official solution, \n    it treats the matrix as a folded, sorted list which makes the above example invalid. \nAm i missing anything here?"
                    },
                    {
                        "username": "nikitamanjhi",
                        "content": "It\\'s not a valid input, because in description it\\'s given that 1st element of each row should be greater than the last element of previous row, but in your example 2 is not greater than 100."
                    },
                    {
                        "username": "itsmerachit",
                        "content": "Hello community,\\nI posted a solution with for( ; ; ) loop and it got a runtime of 104ms. Meanwhile I submitted the same solution with while(true) and got 45ms. \\nMy language of submission was Javascript. Can anyone tell me how they are different while there is no documentation available there which states a while is faster than a for. "
                    },
                    {
                        "username": "paljugnu50",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                if(matrix[i][j]==target)\\n                return true;\\n                \\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n    \\n}"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": " `your inline code...\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int start=0;\\n        int end= row*col-1;\\n\\n        int mid= start+(end-start)/2;\\n\\n        while(start<=end){\\n          int element=matrix[mid/col][mid%col];\\n          if(element == target){\\n            return 1;\\n          }\\n          else if(element<target){\\n            start=mid+1;\\n          }\\n          else{\\n            end=mid-1;\\n          }\\n          int mid= start+(end-start)/2;\\n        }\\n        return 0;\\n    }\\n\\nyour inline code...`\\n\\nthis is giving me a TLE ,whyy???"
                    }
                ]
            },
            {
                "id": 1777099,
                "content": [
                    {
                        "username": "alikhanarman786",
                        "content": "Java Solution\\n\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int r=0;\\n        for(int i = 0 ; i < m;i++){\\n            if(matrix[i][0]<=target && matrix[i][matrix[i].length-1]>=target){\\n                r=i;\\n            }\\n        }\\n    \\n        for(int i = 0 ; i < matrix[r].length ; i++){\\n            \\n            if(matrix[r][i] == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kumar30roshan",
                        "content": "i think this question tag should be easy , simply you have find mid row first by using one binary search for row of matrix by taking column  index 0, then again by using binary search you can find the column of target if present in array else return false. It will take time complexity log(m+n). "
                    },
                    {
                        "username": "pr1524",
                        "content": "Beats 100%  \\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int s = 0;\\n        int e = row*col-1;\\n\\n        int mid = s + (e-s)/2;\\n\\n        while(s<=e)\\n        {\\n            int element = matrix[mid/col][mid%col];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                s = mid + 1;\\n            \\n            else\\n                e = mid - 1;\\n            \\n            mid = s + (e-s)/2;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "AmritpalSIngh2002",
                        "content": "//can anyone tell me why my testcases are not passing  for the following code\\n int row = 0, column = matrix.length-1;\\n        while(row<matrix.length && column>0){\\n            if(matrix[row][column]==target){\\n                return true;\\n            }\\n            else if (matrix[row][column]<target){\\n                row++;\\n            }\\n            else{\\n                column--;\\n            }\\n        }\\n        return false;"
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "I think this question should be marked as easy."
                    },
                    {
                        "username": "seraphsword",
                        "content": "I think I found a bug. I wrote my code, but after hitting `return true;` it just starts the whole thing over again from the beginning, without completing the test case. I have `cout` messages that show that the true condition fires, and then everything keeps running.\nDoes it just keep going if you don't hit the O(log m * n) requirement? With no useful information to let you know? I'm sure my code can be massively improved, but I do think it mostly fits the parameters of binary search.\n```class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int position = (m * n)/2;\n        int gap = position;\n        cout << \"gap \" << gap << endl;\n        cout << \"position \" << position << endl;\n        while (gap >= 1)\n        {\n            int x, y;\n            if (position >= m)\n            {\n                x = position/m - 1;\n            } else\n            {\n                x = 0;\n            }\n            if (position >= n)\n            {\n                y = position % n - 1;\n            } else\n            {\n                y = position - 1;\n            }\n            if (matrix[x][y] == target)\n            {\n                cout << \"true\" << endl;\n                gap = 0;\n                return true;\n            } else if (matrix[x][y] > target)\n            {\n                int temp = position;\n                position -= gap/2;\n                gap = temp - position;\n            } else if (matrix[x][y] < target)\n            {\n                int temp = position;\n                position += gap/2;\n                gap = position - temp;\n            }\n        }\n        return false;\n    }\n};```\n"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing's happening with my code. Did you find any way around this?"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The problem makes no guarantees on ordering within other columns.\n    e.x. \n    1 2 100\n    2 3 4\n    3 4 5\n    is a valid input according to description. However, in the official solution, \n    it treats the matrix as a folded, sorted list which makes the above example invalid. \nAm i missing anything here?"
                    },
                    {
                        "username": "nikitamanjhi",
                        "content": "It\\'s not a valid input, because in description it\\'s given that 1st element of each row should be greater than the last element of previous row, but in your example 2 is not greater than 100."
                    },
                    {
                        "username": "itsmerachit",
                        "content": "Hello community,\\nI posted a solution with for( ; ; ) loop and it got a runtime of 104ms. Meanwhile I submitted the same solution with while(true) and got 45ms. \\nMy language of submission was Javascript. Can anyone tell me how they are different while there is no documentation available there which states a while is faster than a for. "
                    },
                    {
                        "username": "paljugnu50",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                if(matrix[i][j]==target)\\n                return true;\\n                \\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n    \\n}"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": " `your inline code...\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int start=0;\\n        int end= row*col-1;\\n\\n        int mid= start+(end-start)/2;\\n\\n        while(start<=end){\\n          int element=matrix[mid/col][mid%col];\\n          if(element == target){\\n            return 1;\\n          }\\n          else if(element<target){\\n            start=mid+1;\\n          }\\n          else{\\n            end=mid-1;\\n          }\\n          int mid= start+(end-start)/2;\\n        }\\n        return 0;\\n    }\\n\\nyour inline code...`\\n\\nthis is giving me a TLE ,whyy???"
                    }
                ]
            },
            {
                "id": 1775789,
                "content": [
                    {
                        "username": "alikhanarman786",
                        "content": "Java Solution\\n\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int r=0;\\n        for(int i = 0 ; i < m;i++){\\n            if(matrix[i][0]<=target && matrix[i][matrix[i].length-1]>=target){\\n                r=i;\\n            }\\n        }\\n    \\n        for(int i = 0 ; i < matrix[r].length ; i++){\\n            \\n            if(matrix[r][i] == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kumar30roshan",
                        "content": "i think this question tag should be easy , simply you have find mid row first by using one binary search for row of matrix by taking column  index 0, then again by using binary search you can find the column of target if present in array else return false. It will take time complexity log(m+n). "
                    },
                    {
                        "username": "pr1524",
                        "content": "Beats 100%  \\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int s = 0;\\n        int e = row*col-1;\\n\\n        int mid = s + (e-s)/2;\\n\\n        while(s<=e)\\n        {\\n            int element = matrix[mid/col][mid%col];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                s = mid + 1;\\n            \\n            else\\n                e = mid - 1;\\n            \\n            mid = s + (e-s)/2;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "AmritpalSIngh2002",
                        "content": "//can anyone tell me why my testcases are not passing  for the following code\\n int row = 0, column = matrix.length-1;\\n        while(row<matrix.length && column>0){\\n            if(matrix[row][column]==target){\\n                return true;\\n            }\\n            else if (matrix[row][column]<target){\\n                row++;\\n            }\\n            else{\\n                column--;\\n            }\\n        }\\n        return false;"
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "I think this question should be marked as easy."
                    },
                    {
                        "username": "seraphsword",
                        "content": "I think I found a bug. I wrote my code, but after hitting `return true;` it just starts the whole thing over again from the beginning, without completing the test case. I have `cout` messages that show that the true condition fires, and then everything keeps running.\nDoes it just keep going if you don't hit the O(log m * n) requirement? With no useful information to let you know? I'm sure my code can be massively improved, but I do think it mostly fits the parameters of binary search.\n```class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int position = (m * n)/2;\n        int gap = position;\n        cout << \"gap \" << gap << endl;\n        cout << \"position \" << position << endl;\n        while (gap >= 1)\n        {\n            int x, y;\n            if (position >= m)\n            {\n                x = position/m - 1;\n            } else\n            {\n                x = 0;\n            }\n            if (position >= n)\n            {\n                y = position % n - 1;\n            } else\n            {\n                y = position - 1;\n            }\n            if (matrix[x][y] == target)\n            {\n                cout << \"true\" << endl;\n                gap = 0;\n                return true;\n            } else if (matrix[x][y] > target)\n            {\n                int temp = position;\n                position -= gap/2;\n                gap = temp - position;\n            } else if (matrix[x][y] < target)\n            {\n                int temp = position;\n                position += gap/2;\n                gap = position - temp;\n            }\n        }\n        return false;\n    }\n};```\n"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing's happening with my code. Did you find any way around this?"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The problem makes no guarantees on ordering within other columns.\n    e.x. \n    1 2 100\n    2 3 4\n    3 4 5\n    is a valid input according to description. However, in the official solution, \n    it treats the matrix as a folded, sorted list which makes the above example invalid. \nAm i missing anything here?"
                    },
                    {
                        "username": "nikitamanjhi",
                        "content": "It\\'s not a valid input, because in description it\\'s given that 1st element of each row should be greater than the last element of previous row, but in your example 2 is not greater than 100."
                    },
                    {
                        "username": "itsmerachit",
                        "content": "Hello community,\\nI posted a solution with for( ; ; ) loop and it got a runtime of 104ms. Meanwhile I submitted the same solution with while(true) and got 45ms. \\nMy language of submission was Javascript. Can anyone tell me how they are different while there is no documentation available there which states a while is faster than a for. "
                    },
                    {
                        "username": "paljugnu50",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                if(matrix[i][j]==target)\\n                return true;\\n                \\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n    \\n}"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": " `your inline code...\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int start=0;\\n        int end= row*col-1;\\n\\n        int mid= start+(end-start)/2;\\n\\n        while(start<=end){\\n          int element=matrix[mid/col][mid%col];\\n          if(element == target){\\n            return 1;\\n          }\\n          else if(element<target){\\n            start=mid+1;\\n          }\\n          else{\\n            end=mid-1;\\n          }\\n          int mid= start+(end-start)/2;\\n        }\\n        return 0;\\n    }\\n\\nyour inline code...`\\n\\nthis is giving me a TLE ,whyy???"
                    }
                ]
            },
            {
                "id": 1772167,
                "content": [
                    {
                        "username": "alikhanarman786",
                        "content": "Java Solution\\n\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int r=0;\\n        for(int i = 0 ; i < m;i++){\\n            if(matrix[i][0]<=target && matrix[i][matrix[i].length-1]>=target){\\n                r=i;\\n            }\\n        }\\n    \\n        for(int i = 0 ; i < matrix[r].length ; i++){\\n            \\n            if(matrix[r][i] == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kumar30roshan",
                        "content": "i think this question tag should be easy , simply you have find mid row first by using one binary search for row of matrix by taking column  index 0, then again by using binary search you can find the column of target if present in array else return false. It will take time complexity log(m+n). "
                    },
                    {
                        "username": "pr1524",
                        "content": "Beats 100%  \\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int s = 0;\\n        int e = row*col-1;\\n\\n        int mid = s + (e-s)/2;\\n\\n        while(s<=e)\\n        {\\n            int element = matrix[mid/col][mid%col];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                s = mid + 1;\\n            \\n            else\\n                e = mid - 1;\\n            \\n            mid = s + (e-s)/2;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "AmritpalSIngh2002",
                        "content": "//can anyone tell me why my testcases are not passing  for the following code\\n int row = 0, column = matrix.length-1;\\n        while(row<matrix.length && column>0){\\n            if(matrix[row][column]==target){\\n                return true;\\n            }\\n            else if (matrix[row][column]<target){\\n                row++;\\n            }\\n            else{\\n                column--;\\n            }\\n        }\\n        return false;"
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "I think this question should be marked as easy."
                    },
                    {
                        "username": "seraphsword",
                        "content": "I think I found a bug. I wrote my code, but after hitting `return true;` it just starts the whole thing over again from the beginning, without completing the test case. I have `cout` messages that show that the true condition fires, and then everything keeps running.\nDoes it just keep going if you don't hit the O(log m * n) requirement? With no useful information to let you know? I'm sure my code can be massively improved, but I do think it mostly fits the parameters of binary search.\n```class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int position = (m * n)/2;\n        int gap = position;\n        cout << \"gap \" << gap << endl;\n        cout << \"position \" << position << endl;\n        while (gap >= 1)\n        {\n            int x, y;\n            if (position >= m)\n            {\n                x = position/m - 1;\n            } else\n            {\n                x = 0;\n            }\n            if (position >= n)\n            {\n                y = position % n - 1;\n            } else\n            {\n                y = position - 1;\n            }\n            if (matrix[x][y] == target)\n            {\n                cout << \"true\" << endl;\n                gap = 0;\n                return true;\n            } else if (matrix[x][y] > target)\n            {\n                int temp = position;\n                position -= gap/2;\n                gap = temp - position;\n            } else if (matrix[x][y] < target)\n            {\n                int temp = position;\n                position += gap/2;\n                gap = position - temp;\n            }\n        }\n        return false;\n    }\n};```\n"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing's happening with my code. Did you find any way around this?"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The problem makes no guarantees on ordering within other columns.\n    e.x. \n    1 2 100\n    2 3 4\n    3 4 5\n    is a valid input according to description. However, in the official solution, \n    it treats the matrix as a folded, sorted list which makes the above example invalid. \nAm i missing anything here?"
                    },
                    {
                        "username": "nikitamanjhi",
                        "content": "It\\'s not a valid input, because in description it\\'s given that 1st element of each row should be greater than the last element of previous row, but in your example 2 is not greater than 100."
                    },
                    {
                        "username": "itsmerachit",
                        "content": "Hello community,\\nI posted a solution with for( ; ; ) loop and it got a runtime of 104ms. Meanwhile I submitted the same solution with while(true) and got 45ms. \\nMy language of submission was Javascript. Can anyone tell me how they are different while there is no documentation available there which states a while is faster than a for. "
                    },
                    {
                        "username": "paljugnu50",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                if(matrix[i][j]==target)\\n                return true;\\n                \\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n    \\n}"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": " `your inline code...\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int start=0;\\n        int end= row*col-1;\\n\\n        int mid= start+(end-start)/2;\\n\\n        while(start<=end){\\n          int element=matrix[mid/col][mid%col];\\n          if(element == target){\\n            return 1;\\n          }\\n          else if(element<target){\\n            start=mid+1;\\n          }\\n          else{\\n            end=mid-1;\\n          }\\n          int mid= start+(end-start)/2;\\n        }\\n        return 0;\\n    }\\n\\nyour inline code...`\\n\\nthis is giving me a TLE ,whyy???"
                    }
                ]
            },
            {
                "id": 1766054,
                "content": [
                    {
                        "username": "alikhanarman786",
                        "content": "Java Solution\\n\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int r=0;\\n        for(int i = 0 ; i < m;i++){\\n            if(matrix[i][0]<=target && matrix[i][matrix[i].length-1]>=target){\\n                r=i;\\n            }\\n        }\\n    \\n        for(int i = 0 ; i < matrix[r].length ; i++){\\n            \\n            if(matrix[r][i] == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kumar30roshan",
                        "content": "i think this question tag should be easy , simply you have find mid row first by using one binary search for row of matrix by taking column  index 0, then again by using binary search you can find the column of target if present in array else return false. It will take time complexity log(m+n). "
                    },
                    {
                        "username": "pr1524",
                        "content": "Beats 100%  \\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int s = 0;\\n        int e = row*col-1;\\n\\n        int mid = s + (e-s)/2;\\n\\n        while(s<=e)\\n        {\\n            int element = matrix[mid/col][mid%col];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                s = mid + 1;\\n            \\n            else\\n                e = mid - 1;\\n            \\n            mid = s + (e-s)/2;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "AmritpalSIngh2002",
                        "content": "//can anyone tell me why my testcases are not passing  for the following code\\n int row = 0, column = matrix.length-1;\\n        while(row<matrix.length && column>0){\\n            if(matrix[row][column]==target){\\n                return true;\\n            }\\n            else if (matrix[row][column]<target){\\n                row++;\\n            }\\n            else{\\n                column--;\\n            }\\n        }\\n        return false;"
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "I think this question should be marked as easy."
                    },
                    {
                        "username": "seraphsword",
                        "content": "I think I found a bug. I wrote my code, but after hitting `return true;` it just starts the whole thing over again from the beginning, without completing the test case. I have `cout` messages that show that the true condition fires, and then everything keeps running.\nDoes it just keep going if you don't hit the O(log m * n) requirement? With no useful information to let you know? I'm sure my code can be massively improved, but I do think it mostly fits the parameters of binary search.\n```class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int position = (m * n)/2;\n        int gap = position;\n        cout << \"gap \" << gap << endl;\n        cout << \"position \" << position << endl;\n        while (gap >= 1)\n        {\n            int x, y;\n            if (position >= m)\n            {\n                x = position/m - 1;\n            } else\n            {\n                x = 0;\n            }\n            if (position >= n)\n            {\n                y = position % n - 1;\n            } else\n            {\n                y = position - 1;\n            }\n            if (matrix[x][y] == target)\n            {\n                cout << \"true\" << endl;\n                gap = 0;\n                return true;\n            } else if (matrix[x][y] > target)\n            {\n                int temp = position;\n                position -= gap/2;\n                gap = temp - position;\n            } else if (matrix[x][y] < target)\n            {\n                int temp = position;\n                position += gap/2;\n                gap = position - temp;\n            }\n        }\n        return false;\n    }\n};```\n"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing's happening with my code. Did you find any way around this?"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The problem makes no guarantees on ordering within other columns.\n    e.x. \n    1 2 100\n    2 3 4\n    3 4 5\n    is a valid input according to description. However, in the official solution, \n    it treats the matrix as a folded, sorted list which makes the above example invalid. \nAm i missing anything here?"
                    },
                    {
                        "username": "nikitamanjhi",
                        "content": "It\\'s not a valid input, because in description it\\'s given that 1st element of each row should be greater than the last element of previous row, but in your example 2 is not greater than 100."
                    },
                    {
                        "username": "itsmerachit",
                        "content": "Hello community,\\nI posted a solution with for( ; ; ) loop and it got a runtime of 104ms. Meanwhile I submitted the same solution with while(true) and got 45ms. \\nMy language of submission was Javascript. Can anyone tell me how they are different while there is no documentation available there which states a while is faster than a for. "
                    },
                    {
                        "username": "paljugnu50",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                if(matrix[i][j]==target)\\n                return true;\\n                \\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n    \\n}"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": " `your inline code...\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int start=0;\\n        int end= row*col-1;\\n\\n        int mid= start+(end-start)/2;\\n\\n        while(start<=end){\\n          int element=matrix[mid/col][mid%col];\\n          if(element == target){\\n            return 1;\\n          }\\n          else if(element<target){\\n            start=mid+1;\\n          }\\n          else{\\n            end=mid-1;\\n          }\\n          int mid= start+(end-start)/2;\\n        }\\n        return 0;\\n    }\\n\\nyour inline code...`\\n\\nthis is giving me a TLE ,whyy???"
                    }
                ]
            },
            {
                "id": 1754422,
                "content": [
                    {
                        "username": "alikhanarman786",
                        "content": "Java Solution\\n\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int r=0;\\n        for(int i = 0 ; i < m;i++){\\n            if(matrix[i][0]<=target && matrix[i][matrix[i].length-1]>=target){\\n                r=i;\\n            }\\n        }\\n    \\n        for(int i = 0 ; i < matrix[r].length ; i++){\\n            \\n            if(matrix[r][i] == target){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "kumar30roshan",
                        "content": "i think this question tag should be easy , simply you have find mid row first by using one binary search for row of matrix by taking column  index 0, then again by using binary search you can find the column of target if present in array else return false. It will take time complexity log(m+n). "
                    },
                    {
                        "username": "pr1524",
                        "content": "Beats 100%  \\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int s = 0;\\n        int e = row*col-1;\\n\\n        int mid = s + (e-s)/2;\\n\\n        while(s<=e)\\n        {\\n            int element = matrix[mid/col][mid%col];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                s = mid + 1;\\n            \\n            else\\n                e = mid - 1;\\n            \\n            mid = s + (e-s)/2;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "AmritpalSIngh2002",
                        "content": "//can anyone tell me why my testcases are not passing  for the following code\\n int row = 0, column = matrix.length-1;\\n        while(row<matrix.length && column>0){\\n            if(matrix[row][column]==target){\\n                return true;\\n            }\\n            else if (matrix[row][column]<target){\\n                row++;\\n            }\\n            else{\\n                column--;\\n            }\\n        }\\n        return false;"
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "I think this question should be marked as easy."
                    },
                    {
                        "username": "seraphsword",
                        "content": "I think I found a bug. I wrote my code, but after hitting `return true;` it just starts the whole thing over again from the beginning, without completing the test case. I have `cout` messages that show that the true condition fires, and then everything keeps running.\nDoes it just keep going if you don't hit the O(log m * n) requirement? With no useful information to let you know? I'm sure my code can be massively improved, but I do think it mostly fits the parameters of binary search.\n```class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int position = (m * n)/2;\n        int gap = position;\n        cout << \"gap \" << gap << endl;\n        cout << \"position \" << position << endl;\n        while (gap >= 1)\n        {\n            int x, y;\n            if (position >= m)\n            {\n                x = position/m - 1;\n            } else\n            {\n                x = 0;\n            }\n            if (position >= n)\n            {\n                y = position % n - 1;\n            } else\n            {\n                y = position - 1;\n            }\n            if (matrix[x][y] == target)\n            {\n                cout << \"true\" << endl;\n                gap = 0;\n                return true;\n            } else if (matrix[x][y] > target)\n            {\n                int temp = position;\n                position -= gap/2;\n                gap = temp - position;\n            } else if (matrix[x][y] < target)\n            {\n                int temp = position;\n                position += gap/2;\n                gap = position - temp;\n            }\n        }\n        return false;\n    }\n};```\n"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing's happening with my code. Did you find any way around this?"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The problem makes no guarantees on ordering within other columns.\n    e.x. \n    1 2 100\n    2 3 4\n    3 4 5\n    is a valid input according to description. However, in the official solution, \n    it treats the matrix as a folded, sorted list which makes the above example invalid. \nAm i missing anything here?"
                    },
                    {
                        "username": "nikitamanjhi",
                        "content": "It\\'s not a valid input, because in description it\\'s given that 1st element of each row should be greater than the last element of previous row, but in your example 2 is not greater than 100."
                    },
                    {
                        "username": "itsmerachit",
                        "content": "Hello community,\\nI posted a solution with for( ; ; ) loop and it got a runtime of 104ms. Meanwhile I submitted the same solution with while(true) and got 45ms. \\nMy language of submission was Javascript. Can anyone tell me how they are different while there is no documentation available there which states a while is faster than a for. "
                    },
                    {
                        "username": "paljugnu50",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                if(matrix[i][j]==target)\\n                return true;\\n                \\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n    \\n}"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": " `your inline code...\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int start=0;\\n        int end= row*col-1;\\n\\n        int mid= start+(end-start)/2;\\n\\n        while(start<=end){\\n          int element=matrix[mid/col][mid%col];\\n          if(element == target){\\n            return 1;\\n          }\\n          else if(element<target){\\n            start=mid+1;\\n          }\\n          else{\\n            end=mid-1;\\n          }\\n          int mid= start+(end-start)/2;\\n        }\\n        return 0;\\n    }\\n\\nyour inline code...`\\n\\nthis is giving me a TLE ,whyy???"
                    }
                ]
            },
            {
                "id": 1754127,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "archit208027",
                        "content": "I am getting some failed test cases can Someone help me debug this code please\\n\\nDisclaimer - answer ahead\\nclass Solution {\\npublic:\\nbool binaryrow(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix[0].size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[0][mid]==target)\\n        return 1;\\n        else if(matrix[0][mid]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\nbool binarycol(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix.size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[mid][0*mid]==target)\\n        return 1;\\n        else if(matrix[mid][0]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\n\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n       int startrow=0;\\n       int endrow=matrix.size()-1;\\n       int startcol=0;\\n       int endcol=matrix[0].size()-1;\\n       cout<<endrow<<\" \"<<endcol;\\n        if(endrow==0)\\n        {\\n            return binaryrow(matrix,target);\\n        }\\n        if(endcol==0)\\n        {\\n            return binarycol(matrix,target);\\n        }\\n      \\n       while(startrow<=endrow&&startcol<=endcol)\\n       {\\n            int midrow=(startrow+endrow)/2;\\n            int midcol=(startcol+endcol)/2;\\n           if(matrix[midrow][midcol]==target)\\n           return 1;\\n           else if(matrix[midrow][midcol]>target)\\n           {\\n               if(target>matrix[midrow][endcol])\\n               endcol=midcol+1;\\n               else \\n               endrow=midrow-1;\\n           }\\n           else \\n           {\\n               if(target<matrix[midrow][startcol])\\n               {\\n                   endcol=midcol-1;\\n               }\\n               else \\n               {\\n                   endrow=endrow-1;\\n               }\\n           }\\n       }\\n       return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "What is wrong with this code?\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        //size of rows and col\\n        int n = matrix[0].size();\\n        int m = matrix.size();\\n        int s = 0;\\n        int e = m - 1;\\n\\n        while(s>=0 && s<n && e>=0 && e<m){\\n            if(matrix[s][e] == target){\\n                return true;\\n            }\\n            else if(matrix[s][e] < target){\\n                s++;\\n\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\n        return false;\\n        \\n    }\\n};  "
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Code is running even after the return statement\\n\\nbool binarySearch(vector<int>&mat,int key){\\n        cout<<binary_search(mat.begin(),mat.end(),key)<<\"\\\\n===\\\\n\";\\n        return binary_search(mat.begin(),mat.end(),key);\\n    }\\n    bool searchMatrix(vector<vector<int>>& mat, int key) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        int s = 0 , e = n-1;\\n\\t    while(s<e){\\n\\t        int midRow = s + (e-s)/2;\\n            cout<<mat[midRow][0]<<\"  \"<<mat[midRow][m-1]<<endl;\\n\\t        if(mat[midRow][0] >= key and mat[midRow][m-1]){\\n                cout<<\"inside === \\\\n \";\\n\\t            return binarySearch(mat[midRow],key);\\n\\t        }else if(mat[midRow][0] > key){\\n\\t            e = midRow - 1;\\n\\t            cout<<\"s \"<<s<<endl;\\n\\t        }else if(mat[midRow][m-1] < key){\\n\\t            s = midRow + 1;\\n\\t            cout<<\"e \"<<e<<endl;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    return false;\\n    }\\n};"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing\\'s happening to me. Did you find any way around this?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "mkohar",
                        "content": "Intuition:\\n1. Nothing screams **binary search** louder than the term \"Sorted\".\\n\\n\\nApproach:\\n1. Find Row of target in LogN \\n2. Then find element again in that row in LogN"
                    },
                    {
                        "username": "xatcher",
                        "content": "Why I am getting overflow from this code?\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i,j;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(i=0; i<m; i++){\\n            if(target<=matrix[i][n-1])break;\\n        }\\n        for(j=0; j<n; j++){\\n            if(target==matrix[i][j])return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/74_search_a_2d_matrix.cpp"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = row * col - 1;\\n        int mid = start +(end - start )/2;\\n\\n        while(start <= end){\\n            int element = matrix[mid/col] [mid%col];\\n\\n                if(element == target){\\n                    return 1;\\n                }\\n                if(element < target){\\n                    start = mid+1;\\n                }\\n                else{ // (element > target)\\n                    end = mid-1;\\n                }\\n                mid = start +(end-start)/2;\\n            }\\n            return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "remove last mid= and put first mid on top of for loop"
                    }
                ]
            },
            {
                "id": 1752685,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "archit208027",
                        "content": "I am getting some failed test cases can Someone help me debug this code please\\n\\nDisclaimer - answer ahead\\nclass Solution {\\npublic:\\nbool binaryrow(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix[0].size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[0][mid]==target)\\n        return 1;\\n        else if(matrix[0][mid]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\nbool binarycol(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix.size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[mid][0*mid]==target)\\n        return 1;\\n        else if(matrix[mid][0]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\n\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n       int startrow=0;\\n       int endrow=matrix.size()-1;\\n       int startcol=0;\\n       int endcol=matrix[0].size()-1;\\n       cout<<endrow<<\" \"<<endcol;\\n        if(endrow==0)\\n        {\\n            return binaryrow(matrix,target);\\n        }\\n        if(endcol==0)\\n        {\\n            return binarycol(matrix,target);\\n        }\\n      \\n       while(startrow<=endrow&&startcol<=endcol)\\n       {\\n            int midrow=(startrow+endrow)/2;\\n            int midcol=(startcol+endcol)/2;\\n           if(matrix[midrow][midcol]==target)\\n           return 1;\\n           else if(matrix[midrow][midcol]>target)\\n           {\\n               if(target>matrix[midrow][endcol])\\n               endcol=midcol+1;\\n               else \\n               endrow=midrow-1;\\n           }\\n           else \\n           {\\n               if(target<matrix[midrow][startcol])\\n               {\\n                   endcol=midcol-1;\\n               }\\n               else \\n               {\\n                   endrow=endrow-1;\\n               }\\n           }\\n       }\\n       return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "What is wrong with this code?\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        //size of rows and col\\n        int n = matrix[0].size();\\n        int m = matrix.size();\\n        int s = 0;\\n        int e = m - 1;\\n\\n        while(s>=0 && s<n && e>=0 && e<m){\\n            if(matrix[s][e] == target){\\n                return true;\\n            }\\n            else if(matrix[s][e] < target){\\n                s++;\\n\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\n        return false;\\n        \\n    }\\n};  "
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Code is running even after the return statement\\n\\nbool binarySearch(vector<int>&mat,int key){\\n        cout<<binary_search(mat.begin(),mat.end(),key)<<\"\\\\n===\\\\n\";\\n        return binary_search(mat.begin(),mat.end(),key);\\n    }\\n    bool searchMatrix(vector<vector<int>>& mat, int key) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        int s = 0 , e = n-1;\\n\\t    while(s<e){\\n\\t        int midRow = s + (e-s)/2;\\n            cout<<mat[midRow][0]<<\"  \"<<mat[midRow][m-1]<<endl;\\n\\t        if(mat[midRow][0] >= key and mat[midRow][m-1]){\\n                cout<<\"inside === \\\\n \";\\n\\t            return binarySearch(mat[midRow],key);\\n\\t        }else if(mat[midRow][0] > key){\\n\\t            e = midRow - 1;\\n\\t            cout<<\"s \"<<s<<endl;\\n\\t        }else if(mat[midRow][m-1] < key){\\n\\t            s = midRow + 1;\\n\\t            cout<<\"e \"<<e<<endl;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    return false;\\n    }\\n};"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing\\'s happening to me. Did you find any way around this?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "mkohar",
                        "content": "Intuition:\\n1. Nothing screams **binary search** louder than the term \"Sorted\".\\n\\n\\nApproach:\\n1. Find Row of target in LogN \\n2. Then find element again in that row in LogN"
                    },
                    {
                        "username": "xatcher",
                        "content": "Why I am getting overflow from this code?\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i,j;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(i=0; i<m; i++){\\n            if(target<=matrix[i][n-1])break;\\n        }\\n        for(j=0; j<n; j++){\\n            if(target==matrix[i][j])return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/74_search_a_2d_matrix.cpp"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = row * col - 1;\\n        int mid = start +(end - start )/2;\\n\\n        while(start <= end){\\n            int element = matrix[mid/col] [mid%col];\\n\\n                if(element == target){\\n                    return 1;\\n                }\\n                if(element < target){\\n                    start = mid+1;\\n                }\\n                else{ // (element > target)\\n                    end = mid-1;\\n                }\\n                mid = start +(end-start)/2;\\n            }\\n            return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "remove last mid= and put first mid on top of for loop"
                    }
                ]
            },
            {
                "id": 1751572,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "archit208027",
                        "content": "I am getting some failed test cases can Someone help me debug this code please\\n\\nDisclaimer - answer ahead\\nclass Solution {\\npublic:\\nbool binaryrow(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix[0].size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[0][mid]==target)\\n        return 1;\\n        else if(matrix[0][mid]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\nbool binarycol(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix.size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[mid][0*mid]==target)\\n        return 1;\\n        else if(matrix[mid][0]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\n\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n       int startrow=0;\\n       int endrow=matrix.size()-1;\\n       int startcol=0;\\n       int endcol=matrix[0].size()-1;\\n       cout<<endrow<<\" \"<<endcol;\\n        if(endrow==0)\\n        {\\n            return binaryrow(matrix,target);\\n        }\\n        if(endcol==0)\\n        {\\n            return binarycol(matrix,target);\\n        }\\n      \\n       while(startrow<=endrow&&startcol<=endcol)\\n       {\\n            int midrow=(startrow+endrow)/2;\\n            int midcol=(startcol+endcol)/2;\\n           if(matrix[midrow][midcol]==target)\\n           return 1;\\n           else if(matrix[midrow][midcol]>target)\\n           {\\n               if(target>matrix[midrow][endcol])\\n               endcol=midcol+1;\\n               else \\n               endrow=midrow-1;\\n           }\\n           else \\n           {\\n               if(target<matrix[midrow][startcol])\\n               {\\n                   endcol=midcol-1;\\n               }\\n               else \\n               {\\n                   endrow=endrow-1;\\n               }\\n           }\\n       }\\n       return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "What is wrong with this code?\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        //size of rows and col\\n        int n = matrix[0].size();\\n        int m = matrix.size();\\n        int s = 0;\\n        int e = m - 1;\\n\\n        while(s>=0 && s<n && e>=0 && e<m){\\n            if(matrix[s][e] == target){\\n                return true;\\n            }\\n            else if(matrix[s][e] < target){\\n                s++;\\n\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\n        return false;\\n        \\n    }\\n};  "
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Code is running even after the return statement\\n\\nbool binarySearch(vector<int>&mat,int key){\\n        cout<<binary_search(mat.begin(),mat.end(),key)<<\"\\\\n===\\\\n\";\\n        return binary_search(mat.begin(),mat.end(),key);\\n    }\\n    bool searchMatrix(vector<vector<int>>& mat, int key) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        int s = 0 , e = n-1;\\n\\t    while(s<e){\\n\\t        int midRow = s + (e-s)/2;\\n            cout<<mat[midRow][0]<<\"  \"<<mat[midRow][m-1]<<endl;\\n\\t        if(mat[midRow][0] >= key and mat[midRow][m-1]){\\n                cout<<\"inside === \\\\n \";\\n\\t            return binarySearch(mat[midRow],key);\\n\\t        }else if(mat[midRow][0] > key){\\n\\t            e = midRow - 1;\\n\\t            cout<<\"s \"<<s<<endl;\\n\\t        }else if(mat[midRow][m-1] < key){\\n\\t            s = midRow + 1;\\n\\t            cout<<\"e \"<<e<<endl;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    return false;\\n    }\\n};"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing\\'s happening to me. Did you find any way around this?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "mkohar",
                        "content": "Intuition:\\n1. Nothing screams **binary search** louder than the term \"Sorted\".\\n\\n\\nApproach:\\n1. Find Row of target in LogN \\n2. Then find element again in that row in LogN"
                    },
                    {
                        "username": "xatcher",
                        "content": "Why I am getting overflow from this code?\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i,j;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(i=0; i<m; i++){\\n            if(target<=matrix[i][n-1])break;\\n        }\\n        for(j=0; j<n; j++){\\n            if(target==matrix[i][j])return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/74_search_a_2d_matrix.cpp"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = row * col - 1;\\n        int mid = start +(end - start )/2;\\n\\n        while(start <= end){\\n            int element = matrix[mid/col] [mid%col];\\n\\n                if(element == target){\\n                    return 1;\\n                }\\n                if(element < target){\\n                    start = mid+1;\\n                }\\n                else{ // (element > target)\\n                    end = mid-1;\\n                }\\n                mid = start +(end-start)/2;\\n            }\\n            return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "remove last mid= and put first mid on top of for loop"
                    }
                ]
            },
            {
                "id": 1751465,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "archit208027",
                        "content": "I am getting some failed test cases can Someone help me debug this code please\\n\\nDisclaimer - answer ahead\\nclass Solution {\\npublic:\\nbool binaryrow(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix[0].size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[0][mid]==target)\\n        return 1;\\n        else if(matrix[0][mid]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\nbool binarycol(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix.size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[mid][0*mid]==target)\\n        return 1;\\n        else if(matrix[mid][0]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\n\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n       int startrow=0;\\n       int endrow=matrix.size()-1;\\n       int startcol=0;\\n       int endcol=matrix[0].size()-1;\\n       cout<<endrow<<\" \"<<endcol;\\n        if(endrow==0)\\n        {\\n            return binaryrow(matrix,target);\\n        }\\n        if(endcol==0)\\n        {\\n            return binarycol(matrix,target);\\n        }\\n      \\n       while(startrow<=endrow&&startcol<=endcol)\\n       {\\n            int midrow=(startrow+endrow)/2;\\n            int midcol=(startcol+endcol)/2;\\n           if(matrix[midrow][midcol]==target)\\n           return 1;\\n           else if(matrix[midrow][midcol]>target)\\n           {\\n               if(target>matrix[midrow][endcol])\\n               endcol=midcol+1;\\n               else \\n               endrow=midrow-1;\\n           }\\n           else \\n           {\\n               if(target<matrix[midrow][startcol])\\n               {\\n                   endcol=midcol-1;\\n               }\\n               else \\n               {\\n                   endrow=endrow-1;\\n               }\\n           }\\n       }\\n       return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "What is wrong with this code?\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        //size of rows and col\\n        int n = matrix[0].size();\\n        int m = matrix.size();\\n        int s = 0;\\n        int e = m - 1;\\n\\n        while(s>=0 && s<n && e>=0 && e<m){\\n            if(matrix[s][e] == target){\\n                return true;\\n            }\\n            else if(matrix[s][e] < target){\\n                s++;\\n\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\n        return false;\\n        \\n    }\\n};  "
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Code is running even after the return statement\\n\\nbool binarySearch(vector<int>&mat,int key){\\n        cout<<binary_search(mat.begin(),mat.end(),key)<<\"\\\\n===\\\\n\";\\n        return binary_search(mat.begin(),mat.end(),key);\\n    }\\n    bool searchMatrix(vector<vector<int>>& mat, int key) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        int s = 0 , e = n-1;\\n\\t    while(s<e){\\n\\t        int midRow = s + (e-s)/2;\\n            cout<<mat[midRow][0]<<\"  \"<<mat[midRow][m-1]<<endl;\\n\\t        if(mat[midRow][0] >= key and mat[midRow][m-1]){\\n                cout<<\"inside === \\\\n \";\\n\\t            return binarySearch(mat[midRow],key);\\n\\t        }else if(mat[midRow][0] > key){\\n\\t            e = midRow - 1;\\n\\t            cout<<\"s \"<<s<<endl;\\n\\t        }else if(mat[midRow][m-1] < key){\\n\\t            s = midRow + 1;\\n\\t            cout<<\"e \"<<e<<endl;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    return false;\\n    }\\n};"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing\\'s happening to me. Did you find any way around this?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "mkohar",
                        "content": "Intuition:\\n1. Nothing screams **binary search** louder than the term \"Sorted\".\\n\\n\\nApproach:\\n1. Find Row of target in LogN \\n2. Then find element again in that row in LogN"
                    },
                    {
                        "username": "xatcher",
                        "content": "Why I am getting overflow from this code?\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i,j;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(i=0; i<m; i++){\\n            if(target<=matrix[i][n-1])break;\\n        }\\n        for(j=0; j<n; j++){\\n            if(target==matrix[i][j])return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/74_search_a_2d_matrix.cpp"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = row * col - 1;\\n        int mid = start +(end - start )/2;\\n\\n        while(start <= end){\\n            int element = matrix[mid/col] [mid%col];\\n\\n                if(element == target){\\n                    return 1;\\n                }\\n                if(element < target){\\n                    start = mid+1;\\n                }\\n                else{ // (element > target)\\n                    end = mid-1;\\n                }\\n                mid = start +(end-start)/2;\\n            }\\n            return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "remove last mid= and put first mid on top of for loop"
                    }
                ]
            },
            {
                "id": 1744366,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "archit208027",
                        "content": "I am getting some failed test cases can Someone help me debug this code please\\n\\nDisclaimer - answer ahead\\nclass Solution {\\npublic:\\nbool binaryrow(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix[0].size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[0][mid]==target)\\n        return 1;\\n        else if(matrix[0][mid]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\nbool binarycol(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix.size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[mid][0*mid]==target)\\n        return 1;\\n        else if(matrix[mid][0]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\n\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n       int startrow=0;\\n       int endrow=matrix.size()-1;\\n       int startcol=0;\\n       int endcol=matrix[0].size()-1;\\n       cout<<endrow<<\" \"<<endcol;\\n        if(endrow==0)\\n        {\\n            return binaryrow(matrix,target);\\n        }\\n        if(endcol==0)\\n        {\\n            return binarycol(matrix,target);\\n        }\\n      \\n       while(startrow<=endrow&&startcol<=endcol)\\n       {\\n            int midrow=(startrow+endrow)/2;\\n            int midcol=(startcol+endcol)/2;\\n           if(matrix[midrow][midcol]==target)\\n           return 1;\\n           else if(matrix[midrow][midcol]>target)\\n           {\\n               if(target>matrix[midrow][endcol])\\n               endcol=midcol+1;\\n               else \\n               endrow=midrow-1;\\n           }\\n           else \\n           {\\n               if(target<matrix[midrow][startcol])\\n               {\\n                   endcol=midcol-1;\\n               }\\n               else \\n               {\\n                   endrow=endrow-1;\\n               }\\n           }\\n       }\\n       return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "What is wrong with this code?\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        //size of rows and col\\n        int n = matrix[0].size();\\n        int m = matrix.size();\\n        int s = 0;\\n        int e = m - 1;\\n\\n        while(s>=0 && s<n && e>=0 && e<m){\\n            if(matrix[s][e] == target){\\n                return true;\\n            }\\n            else if(matrix[s][e] < target){\\n                s++;\\n\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\n        return false;\\n        \\n    }\\n};  "
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Code is running even after the return statement\\n\\nbool binarySearch(vector<int>&mat,int key){\\n        cout<<binary_search(mat.begin(),mat.end(),key)<<\"\\\\n===\\\\n\";\\n        return binary_search(mat.begin(),mat.end(),key);\\n    }\\n    bool searchMatrix(vector<vector<int>>& mat, int key) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        int s = 0 , e = n-1;\\n\\t    while(s<e){\\n\\t        int midRow = s + (e-s)/2;\\n            cout<<mat[midRow][0]<<\"  \"<<mat[midRow][m-1]<<endl;\\n\\t        if(mat[midRow][0] >= key and mat[midRow][m-1]){\\n                cout<<\"inside === \\\\n \";\\n\\t            return binarySearch(mat[midRow],key);\\n\\t        }else if(mat[midRow][0] > key){\\n\\t            e = midRow - 1;\\n\\t            cout<<\"s \"<<s<<endl;\\n\\t        }else if(mat[midRow][m-1] < key){\\n\\t            s = midRow + 1;\\n\\t            cout<<\"e \"<<e<<endl;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    return false;\\n    }\\n};"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing\\'s happening to me. Did you find any way around this?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "mkohar",
                        "content": "Intuition:\\n1. Nothing screams **binary search** louder than the term \"Sorted\".\\n\\n\\nApproach:\\n1. Find Row of target in LogN \\n2. Then find element again in that row in LogN"
                    },
                    {
                        "username": "xatcher",
                        "content": "Why I am getting overflow from this code?\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i,j;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(i=0; i<m; i++){\\n            if(target<=matrix[i][n-1])break;\\n        }\\n        for(j=0; j<n; j++){\\n            if(target==matrix[i][j])return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/74_search_a_2d_matrix.cpp"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = row * col - 1;\\n        int mid = start +(end - start )/2;\\n\\n        while(start <= end){\\n            int element = matrix[mid/col] [mid%col];\\n\\n                if(element == target){\\n                    return 1;\\n                }\\n                if(element < target){\\n                    start = mid+1;\\n                }\\n                else{ // (element > target)\\n                    end = mid-1;\\n                }\\n                mid = start +(end-start)/2;\\n            }\\n            return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "remove last mid= and put first mid on top of for loop"
                    }
                ]
            },
            {
                "id": 1733542,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "archit208027",
                        "content": "I am getting some failed test cases can Someone help me debug this code please\\n\\nDisclaimer - answer ahead\\nclass Solution {\\npublic:\\nbool binaryrow(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix[0].size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[0][mid]==target)\\n        return 1;\\n        else if(matrix[0][mid]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\nbool binarycol(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix.size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[mid][0*mid]==target)\\n        return 1;\\n        else if(matrix[mid][0]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\n\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n       int startrow=0;\\n       int endrow=matrix.size()-1;\\n       int startcol=0;\\n       int endcol=matrix[0].size()-1;\\n       cout<<endrow<<\" \"<<endcol;\\n        if(endrow==0)\\n        {\\n            return binaryrow(matrix,target);\\n        }\\n        if(endcol==0)\\n        {\\n            return binarycol(matrix,target);\\n        }\\n      \\n       while(startrow<=endrow&&startcol<=endcol)\\n       {\\n            int midrow=(startrow+endrow)/2;\\n            int midcol=(startcol+endcol)/2;\\n           if(matrix[midrow][midcol]==target)\\n           return 1;\\n           else if(matrix[midrow][midcol]>target)\\n           {\\n               if(target>matrix[midrow][endcol])\\n               endcol=midcol+1;\\n               else \\n               endrow=midrow-1;\\n           }\\n           else \\n           {\\n               if(target<matrix[midrow][startcol])\\n               {\\n                   endcol=midcol-1;\\n               }\\n               else \\n               {\\n                   endrow=endrow-1;\\n               }\\n           }\\n       }\\n       return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "What is wrong with this code?\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        //size of rows and col\\n        int n = matrix[0].size();\\n        int m = matrix.size();\\n        int s = 0;\\n        int e = m - 1;\\n\\n        while(s>=0 && s<n && e>=0 && e<m){\\n            if(matrix[s][e] == target){\\n                return true;\\n            }\\n            else if(matrix[s][e] < target){\\n                s++;\\n\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\n        return false;\\n        \\n    }\\n};  "
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Code is running even after the return statement\\n\\nbool binarySearch(vector<int>&mat,int key){\\n        cout<<binary_search(mat.begin(),mat.end(),key)<<\"\\\\n===\\\\n\";\\n        return binary_search(mat.begin(),mat.end(),key);\\n    }\\n    bool searchMatrix(vector<vector<int>>& mat, int key) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        int s = 0 , e = n-1;\\n\\t    while(s<e){\\n\\t        int midRow = s + (e-s)/2;\\n            cout<<mat[midRow][0]<<\"  \"<<mat[midRow][m-1]<<endl;\\n\\t        if(mat[midRow][0] >= key and mat[midRow][m-1]){\\n                cout<<\"inside === \\\\n \";\\n\\t            return binarySearch(mat[midRow],key);\\n\\t        }else if(mat[midRow][0] > key){\\n\\t            e = midRow - 1;\\n\\t            cout<<\"s \"<<s<<endl;\\n\\t        }else if(mat[midRow][m-1] < key){\\n\\t            s = midRow + 1;\\n\\t            cout<<\"e \"<<e<<endl;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    return false;\\n    }\\n};"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing\\'s happening to me. Did you find any way around this?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "mkohar",
                        "content": "Intuition:\\n1. Nothing screams **binary search** louder than the term \"Sorted\".\\n\\n\\nApproach:\\n1. Find Row of target in LogN \\n2. Then find element again in that row in LogN"
                    },
                    {
                        "username": "xatcher",
                        "content": "Why I am getting overflow from this code?\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i,j;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(i=0; i<m; i++){\\n            if(target<=matrix[i][n-1])break;\\n        }\\n        for(j=0; j<n; j++){\\n            if(target==matrix[i][j])return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/74_search_a_2d_matrix.cpp"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = row * col - 1;\\n        int mid = start +(end - start )/2;\\n\\n        while(start <= end){\\n            int element = matrix[mid/col] [mid%col];\\n\\n                if(element == target){\\n                    return 1;\\n                }\\n                if(element < target){\\n                    start = mid+1;\\n                }\\n                else{ // (element > target)\\n                    end = mid-1;\\n                }\\n                mid = start +(end-start)/2;\\n            }\\n            return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "remove last mid= and put first mid on top of for loop"
                    }
                ]
            },
            {
                "id": 1727912,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "archit208027",
                        "content": "I am getting some failed test cases can Someone help me debug this code please\\n\\nDisclaimer - answer ahead\\nclass Solution {\\npublic:\\nbool binaryrow(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix[0].size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[0][mid]==target)\\n        return 1;\\n        else if(matrix[0][mid]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\nbool binarycol(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix.size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[mid][0*mid]==target)\\n        return 1;\\n        else if(matrix[mid][0]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\n\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n       int startrow=0;\\n       int endrow=matrix.size()-1;\\n       int startcol=0;\\n       int endcol=matrix[0].size()-1;\\n       cout<<endrow<<\" \"<<endcol;\\n        if(endrow==0)\\n        {\\n            return binaryrow(matrix,target);\\n        }\\n        if(endcol==0)\\n        {\\n            return binarycol(matrix,target);\\n        }\\n      \\n       while(startrow<=endrow&&startcol<=endcol)\\n       {\\n            int midrow=(startrow+endrow)/2;\\n            int midcol=(startcol+endcol)/2;\\n           if(matrix[midrow][midcol]==target)\\n           return 1;\\n           else if(matrix[midrow][midcol]>target)\\n           {\\n               if(target>matrix[midrow][endcol])\\n               endcol=midcol+1;\\n               else \\n               endrow=midrow-1;\\n           }\\n           else \\n           {\\n               if(target<matrix[midrow][startcol])\\n               {\\n                   endcol=midcol-1;\\n               }\\n               else \\n               {\\n                   endrow=endrow-1;\\n               }\\n           }\\n       }\\n       return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "What is wrong with this code?\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        //size of rows and col\\n        int n = matrix[0].size();\\n        int m = matrix.size();\\n        int s = 0;\\n        int e = m - 1;\\n\\n        while(s>=0 && s<n && e>=0 && e<m){\\n            if(matrix[s][e] == target){\\n                return true;\\n            }\\n            else if(matrix[s][e] < target){\\n                s++;\\n\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\n        return false;\\n        \\n    }\\n};  "
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Code is running even after the return statement\\n\\nbool binarySearch(vector<int>&mat,int key){\\n        cout<<binary_search(mat.begin(),mat.end(),key)<<\"\\\\n===\\\\n\";\\n        return binary_search(mat.begin(),mat.end(),key);\\n    }\\n    bool searchMatrix(vector<vector<int>>& mat, int key) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        int s = 0 , e = n-1;\\n\\t    while(s<e){\\n\\t        int midRow = s + (e-s)/2;\\n            cout<<mat[midRow][0]<<\"  \"<<mat[midRow][m-1]<<endl;\\n\\t        if(mat[midRow][0] >= key and mat[midRow][m-1]){\\n                cout<<\"inside === \\\\n \";\\n\\t            return binarySearch(mat[midRow],key);\\n\\t        }else if(mat[midRow][0] > key){\\n\\t            e = midRow - 1;\\n\\t            cout<<\"s \"<<s<<endl;\\n\\t        }else if(mat[midRow][m-1] < key){\\n\\t            s = midRow + 1;\\n\\t            cout<<\"e \"<<e<<endl;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    return false;\\n    }\\n};"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing\\'s happening to me. Did you find any way around this?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "mkohar",
                        "content": "Intuition:\\n1. Nothing screams **binary search** louder than the term \"Sorted\".\\n\\n\\nApproach:\\n1. Find Row of target in LogN \\n2. Then find element again in that row in LogN"
                    },
                    {
                        "username": "xatcher",
                        "content": "Why I am getting overflow from this code?\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i,j;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(i=0; i<m; i++){\\n            if(target<=matrix[i][n-1])break;\\n        }\\n        for(j=0; j<n; j++){\\n            if(target==matrix[i][j])return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/74_search_a_2d_matrix.cpp"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = row * col - 1;\\n        int mid = start +(end - start )/2;\\n\\n        while(start <= end){\\n            int element = matrix[mid/col] [mid%col];\\n\\n                if(element == target){\\n                    return 1;\\n                }\\n                if(element < target){\\n                    start = mid+1;\\n                }\\n                else{ // (element > target)\\n                    end = mid-1;\\n                }\\n                mid = start +(end-start)/2;\\n            }\\n            return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "remove last mid= and put first mid on top of for loop"
                    }
                ]
            },
            {
                "id": 1725183,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "archit208027",
                        "content": "I am getting some failed test cases can Someone help me debug this code please\\n\\nDisclaimer - answer ahead\\nclass Solution {\\npublic:\\nbool binaryrow(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix[0].size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[0][mid]==target)\\n        return 1;\\n        else if(matrix[0][mid]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\nbool binarycol(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix.size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[mid][0*mid]==target)\\n        return 1;\\n        else if(matrix[mid][0]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\n\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n       int startrow=0;\\n       int endrow=matrix.size()-1;\\n       int startcol=0;\\n       int endcol=matrix[0].size()-1;\\n       cout<<endrow<<\" \"<<endcol;\\n        if(endrow==0)\\n        {\\n            return binaryrow(matrix,target);\\n        }\\n        if(endcol==0)\\n        {\\n            return binarycol(matrix,target);\\n        }\\n      \\n       while(startrow<=endrow&&startcol<=endcol)\\n       {\\n            int midrow=(startrow+endrow)/2;\\n            int midcol=(startcol+endcol)/2;\\n           if(matrix[midrow][midcol]==target)\\n           return 1;\\n           else if(matrix[midrow][midcol]>target)\\n           {\\n               if(target>matrix[midrow][endcol])\\n               endcol=midcol+1;\\n               else \\n               endrow=midrow-1;\\n           }\\n           else \\n           {\\n               if(target<matrix[midrow][startcol])\\n               {\\n                   endcol=midcol-1;\\n               }\\n               else \\n               {\\n                   endrow=endrow-1;\\n               }\\n           }\\n       }\\n       return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "What is wrong with this code?\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        //size of rows and col\\n        int n = matrix[0].size();\\n        int m = matrix.size();\\n        int s = 0;\\n        int e = m - 1;\\n\\n        while(s>=0 && s<n && e>=0 && e<m){\\n            if(matrix[s][e] == target){\\n                return true;\\n            }\\n            else if(matrix[s][e] < target){\\n                s++;\\n\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\n        return false;\\n        \\n    }\\n};  "
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Code is running even after the return statement\\n\\nbool binarySearch(vector<int>&mat,int key){\\n        cout<<binary_search(mat.begin(),mat.end(),key)<<\"\\\\n===\\\\n\";\\n        return binary_search(mat.begin(),mat.end(),key);\\n    }\\n    bool searchMatrix(vector<vector<int>>& mat, int key) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        int s = 0 , e = n-1;\\n\\t    while(s<e){\\n\\t        int midRow = s + (e-s)/2;\\n            cout<<mat[midRow][0]<<\"  \"<<mat[midRow][m-1]<<endl;\\n\\t        if(mat[midRow][0] >= key and mat[midRow][m-1]){\\n                cout<<\"inside === \\\\n \";\\n\\t            return binarySearch(mat[midRow],key);\\n\\t        }else if(mat[midRow][0] > key){\\n\\t            e = midRow - 1;\\n\\t            cout<<\"s \"<<s<<endl;\\n\\t        }else if(mat[midRow][m-1] < key){\\n\\t            s = midRow + 1;\\n\\t            cout<<\"e \"<<e<<endl;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    return false;\\n    }\\n};"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing\\'s happening to me. Did you find any way around this?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "mkohar",
                        "content": "Intuition:\\n1. Nothing screams **binary search** louder than the term \"Sorted\".\\n\\n\\nApproach:\\n1. Find Row of target in LogN \\n2. Then find element again in that row in LogN"
                    },
                    {
                        "username": "xatcher",
                        "content": "Why I am getting overflow from this code?\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i,j;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(i=0; i<m; i++){\\n            if(target<=matrix[i][n-1])break;\\n        }\\n        for(j=0; j<n; j++){\\n            if(target==matrix[i][j])return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/74_search_a_2d_matrix.cpp"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = row * col - 1;\\n        int mid = start +(end - start )/2;\\n\\n        while(start <= end){\\n            int element = matrix[mid/col] [mid%col];\\n\\n                if(element == target){\\n                    return 1;\\n                }\\n                if(element < target){\\n                    start = mid+1;\\n                }\\n                else{ // (element > target)\\n                    end = mid-1;\\n                }\\n                mid = start +(end-start)/2;\\n            }\\n            return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "remove last mid= and put first mid on top of for loop"
                    }
                ]
            },
            {
                "id": 1724221,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "archit208027",
                        "content": "I am getting some failed test cases can Someone help me debug this code please\\n\\nDisclaimer - answer ahead\\nclass Solution {\\npublic:\\nbool binaryrow(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix[0].size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[0][mid]==target)\\n        return 1;\\n        else if(matrix[0][mid]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\nbool binarycol(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix.size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[mid][0*mid]==target)\\n        return 1;\\n        else if(matrix[mid][0]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\n\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n       int startrow=0;\\n       int endrow=matrix.size()-1;\\n       int startcol=0;\\n       int endcol=matrix[0].size()-1;\\n       cout<<endrow<<\" \"<<endcol;\\n        if(endrow==0)\\n        {\\n            return binaryrow(matrix,target);\\n        }\\n        if(endcol==0)\\n        {\\n            return binarycol(matrix,target);\\n        }\\n      \\n       while(startrow<=endrow&&startcol<=endcol)\\n       {\\n            int midrow=(startrow+endrow)/2;\\n            int midcol=(startcol+endcol)/2;\\n           if(matrix[midrow][midcol]==target)\\n           return 1;\\n           else if(matrix[midrow][midcol]>target)\\n           {\\n               if(target>matrix[midrow][endcol])\\n               endcol=midcol+1;\\n               else \\n               endrow=midrow-1;\\n           }\\n           else \\n           {\\n               if(target<matrix[midrow][startcol])\\n               {\\n                   endcol=midcol-1;\\n               }\\n               else \\n               {\\n                   endrow=endrow-1;\\n               }\\n           }\\n       }\\n       return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "What is wrong with this code?\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        //size of rows and col\\n        int n = matrix[0].size();\\n        int m = matrix.size();\\n        int s = 0;\\n        int e = m - 1;\\n\\n        while(s>=0 && s<n && e>=0 && e<m){\\n            if(matrix[s][e] == target){\\n                return true;\\n            }\\n            else if(matrix[s][e] < target){\\n                s++;\\n\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\n        return false;\\n        \\n    }\\n};  "
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Code is running even after the return statement\\n\\nbool binarySearch(vector<int>&mat,int key){\\n        cout<<binary_search(mat.begin(),mat.end(),key)<<\"\\\\n===\\\\n\";\\n        return binary_search(mat.begin(),mat.end(),key);\\n    }\\n    bool searchMatrix(vector<vector<int>>& mat, int key) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        int s = 0 , e = n-1;\\n\\t    while(s<e){\\n\\t        int midRow = s + (e-s)/2;\\n            cout<<mat[midRow][0]<<\"  \"<<mat[midRow][m-1]<<endl;\\n\\t        if(mat[midRow][0] >= key and mat[midRow][m-1]){\\n                cout<<\"inside === \\\\n \";\\n\\t            return binarySearch(mat[midRow],key);\\n\\t        }else if(mat[midRow][0] > key){\\n\\t            e = midRow - 1;\\n\\t            cout<<\"s \"<<s<<endl;\\n\\t        }else if(mat[midRow][m-1] < key){\\n\\t            s = midRow + 1;\\n\\t            cout<<\"e \"<<e<<endl;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    return false;\\n    }\\n};"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing\\'s happening to me. Did you find any way around this?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "mkohar",
                        "content": "Intuition:\\n1. Nothing screams **binary search** louder than the term \"Sorted\".\\n\\n\\nApproach:\\n1. Find Row of target in LogN \\n2. Then find element again in that row in LogN"
                    },
                    {
                        "username": "xatcher",
                        "content": "Why I am getting overflow from this code?\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i,j;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(i=0; i<m; i++){\\n            if(target<=matrix[i][n-1])break;\\n        }\\n        for(j=0; j<n; j++){\\n            if(target==matrix[i][j])return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/74_search_a_2d_matrix.cpp"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = row * col - 1;\\n        int mid = start +(end - start )/2;\\n\\n        while(start <= end){\\n            int element = matrix[mid/col] [mid%col];\\n\\n                if(element == target){\\n                    return 1;\\n                }\\n                if(element < target){\\n                    start = mid+1;\\n                }\\n                else{ // (element > target)\\n                    end = mid-1;\\n                }\\n                mid = start +(end-start)/2;\\n            }\\n            return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "remove last mid= and put first mid on top of for loop"
                    }
                ]
            },
            {
                "id": 1722607,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/search-a-2d-matrix-leet-code-74/"
                    },
                    {
                        "username": "archit208027",
                        "content": "I am getting some failed test cases can Someone help me debug this code please\\n\\nDisclaimer - answer ahead\\nclass Solution {\\npublic:\\nbool binaryrow(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix[0].size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[0][mid]==target)\\n        return 1;\\n        else if(matrix[0][mid]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\nbool binarycol(vector<vector<int>>& matrix,int target)\\n{\\n    int start=0;\\n    int end=matrix.size()-1;\\n    while(start<=end)\\n    {\\n        int mid=(start+end)>>1;\\n        if(matrix[mid][0*mid]==target)\\n        return 1;\\n        else if(matrix[mid][0]>target)\\n            end=mid-1;\\n            else \\n            start=mid+1;\\n    }\\n    return 0;\\n}\\n\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n       int startrow=0;\\n       int endrow=matrix.size()-1;\\n       int startcol=0;\\n       int endcol=matrix[0].size()-1;\\n       cout<<endrow<<\" \"<<endcol;\\n        if(endrow==0)\\n        {\\n            return binaryrow(matrix,target);\\n        }\\n        if(endcol==0)\\n        {\\n            return binarycol(matrix,target);\\n        }\\n      \\n       while(startrow<=endrow&&startcol<=endcol)\\n       {\\n            int midrow=(startrow+endrow)/2;\\n            int midcol=(startcol+endcol)/2;\\n           if(matrix[midrow][midcol]==target)\\n           return 1;\\n           else if(matrix[midrow][midcol]>target)\\n           {\\n               if(target>matrix[midrow][endcol])\\n               endcol=midcol+1;\\n               else \\n               endrow=midrow-1;\\n           }\\n           else \\n           {\\n               if(target<matrix[midrow][startcol])\\n               {\\n                   endcol=midcol-1;\\n               }\\n               else \\n               {\\n                   endrow=endrow-1;\\n               }\\n           }\\n       }\\n       return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "What is wrong with this code?\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        //size of rows and col\\n        int n = matrix[0].size();\\n        int m = matrix.size();\\n        int s = 0;\\n        int e = m - 1;\\n\\n        while(s>=0 && s<n && e>=0 && e<m){\\n            if(matrix[s][e] == target){\\n                return true;\\n            }\\n            else if(matrix[s][e] < target){\\n                s++;\\n\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\n        return false;\\n        \\n    }\\n};  "
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Code is running even after the return statement\\n\\nbool binarySearch(vector<int>&mat,int key){\\n        cout<<binary_search(mat.begin(),mat.end(),key)<<\"\\\\n===\\\\n\";\\n        return binary_search(mat.begin(),mat.end(),key);\\n    }\\n    bool searchMatrix(vector<vector<int>>& mat, int key) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        int s = 0 , e = n-1;\\n\\t    while(s<e){\\n\\t        int midRow = s + (e-s)/2;\\n            cout<<mat[midRow][0]<<\"  \"<<mat[midRow][m-1]<<endl;\\n\\t        if(mat[midRow][0] >= key and mat[midRow][m-1]){\\n                cout<<\"inside === \\\\n \";\\n\\t            return binarySearch(mat[midRow],key);\\n\\t        }else if(mat[midRow][0] > key){\\n\\t            e = midRow - 1;\\n\\t            cout<<\"s \"<<s<<endl;\\n\\t        }else if(mat[midRow][m-1] < key){\\n\\t            s = midRow + 1;\\n\\t            cout<<\"e \"<<e<<endl;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    return false;\\n    }\\n};"
                    },
                    {
                        "username": "jaztriumph",
                        "content": "Same thing\\'s happening to me. Did you find any way around this?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "mkohar",
                        "content": "Intuition:\\n1. Nothing screams **binary search** louder than the term \"Sorted\".\\n\\n\\nApproach:\\n1. Find Row of target in LogN \\n2. Then find element again in that row in LogN"
                    },
                    {
                        "username": "xatcher",
                        "content": "Why I am getting overflow from this code?\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i,j;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(i=0; i<m; i++){\\n            if(target<=matrix[i][n-1])break;\\n        }\\n        for(j=0; j<n; j++){\\n            if(target==matrix[i][j])return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/74_search_a_2d_matrix.cpp"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = row * col - 1;\\n        int mid = start +(end - start )/2;\\n\\n        while(start <= end){\\n            int element = matrix[mid/col] [mid%col];\\n\\n                if(element == target){\\n                    return 1;\\n                }\\n                if(element < target){\\n                    start = mid+1;\\n                }\\n                else{ // (element > target)\\n                    end = mid-1;\\n                }\\n                mid = start +(end-start)/2;\\n            }\\n            return 0;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "remove last mid= and put first mid on top of for loop"
                    }
                ]
            },
            {
                "id": 1722545,
                "content": [
                    {
                        "username": "S_A_D_I_K",
                        "content": "leetcode needs more congruence on results, they seem to use different testcases for each submission\\n\\na O(log(m+n)) solution took 85 ms and O(m+n) solution took 42 ms\\n ```class Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        if target>matrix[R][C] or target<matrix[0][0]:\\n            return False\\n        r,c = 0,C\\n        while 0<=r<=R and 0<=c<=C:\\n            if target == matrix[r][c]:\\n                return True\\n            elif target > matrix[r][c]:\\n                r += 1\\n            elif target < matrix[r][c]:\\n                c -= 1\\n        return False\\n        \\nthis is a O(m+n) solution , which performed better than the below code\\n    ```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix or not matrix[0]:\\n            return False\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        \\n        if target > matrix[R][C] or target < matrix[0][0]:\\n            return False\\n        top,bottom = 0,R\\n        while top<=bottom:\\n            middle = (top+bottom)//2\\n            if target < matrix[middle][0]:\\n                bottom = middle-1\\n            elif target > matrix[middle][-1]:\\n                top = middle+1\\n            else:\\n                break\\n \\n        l,r = 0,C\\n        while l<=r:\\n            m = (l+r)//2\\n            if target == matrix[middle][m]:\\n                return True\\n            elif target < matrix[middle][m]:\\n                r = m - 1\\n            elif target > matrix[middle][m]:\\n                l = m + 1\\n        return False\\n \\n"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the eaisest one in which linear traversing of each element if it found the element return true otherwise return false\\n"
                    },
                    {
                        "username": "xandergardner",
                        "content": "Leetcode C++ Compiler Broken?\\n\\nThis code works locally but infinitely loops when run on leetcode:\\n\\n ```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int minrow = 0;\\n        int maxrow = matrix.size()-1;\\n        int midrow;\\n        int i = 0;\\n        while (minrow < maxrow) {\\n            // cout << minrow << \" \";\\n            // cout << maxrow << \" \";\\n            midrow = (minrow + maxrow) / 2;\\n            if (target < matrix[midrow][0]) {\\n                maxrow = midrow-1;\\n                // cout << \"ch to max: \" << maxrow;\\n            } else if (target > matrix[midrow][0]) {\\n                minrow = midrow;\\n                // cout << \"ch to min: \" << minrow;\\n            } else {\\n                cout << 1;\\n                return true;\\n            }\\n            // cout << i << \\'\\\\n\\';\\n            i++;\\n        }\\n        return binary_search(matrix[minrow].begin(), matrix[minrow].end(), target);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "jslominsky",
                        "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n         int row = getRow(matrix, target);\\n        if(row == -1)\\n            return false;\\n        else\\n        {\\n            boolean  result = binarySearch(matrix[row],target);\\n            return result;\\n        }\\n        \\n    \\n    \\n        \\n    }\\n    \\n static int getRow(int [][] matrix, int target)\\n    {\\n        int top = 0;\\n        int middle = matrix.length/2;\\n        int bottom = matrix.length;\\n        boolean rowFound = false;\\n        int row = -1;\\n        int inspectRight = matrix[middle][matrix[middle].length-1];\\n        int inspectLeft = matrix[middle][0];\\n        int maxIterations = (int)Math.ceil(Math.log(bottom));\\n        int i = 0;\\n        while(rowFound == false )\\n        {\\n            inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n           i++;\\n            if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                rowFound = true;\\n                row = middle;\\n            }\\n            else\\n            {\\n               \\n                if(target < inspectRight)\\n                {\\n                    bottom = middle;\\n                    middle = (top+bottom)/2;\\n                }\\n                else\\n                {\\n                    top = middle;\\n                    middle = (top+bottom)/2;\\n                    \\n                }\\n            }\\n            \\n            if(top == middle && top == bottom -1)\\n            {\\n                rowFound = true;\\n            }\\n            else if(top == middle && top == bottom)\\n            {\\n                rowFound = true;\\n            }\\n            \\n            \\n        }\\n     \\n      inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n         if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                \\n                row = middle;\\n            }\\n         \\n        return row;\\n }\\n        \\n    \\n    static boolean binarySearch(int v[], int To_Find)\\n    {\\n    int lo = 0, hi = v.length - 1;\\n    // This below check covers all cases , so need to check\\n    // for mid=lo-(hi-lo)/2\\n    while (hi - lo > 1) {\\n        int mid = (hi + lo) / 2;\\n        if (v[mid] < To_Find) {\\n            lo = mid + 1;\\n        }\\n        else {\\n            hi = mid;\\n        }\\n    }\\n    if (v[lo] == To_Find) {\\n      return true;\\n    }\\n    else if (v[hi] == To_Find) {\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n}\\n    \\n    \\n    \\n    \\n}"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0 , col = matrix[0].length-1;\\n        while(row < matrix.length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            }else if(matrix[row][col] < target){\\n                row ++;\\n            }else{\\n                col--;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "aditrout29",
                        "content": "class Solution {\npublic:\n    bool searchRow(vector<vector<int>>& matrix, int target,int s, int e,int row{\n           while(e>=s){\n            if(matrix[row][e]==target){\n                return true;\n            }\n            --e;\n        }  \n         return false;\n    }\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n       bool flag=false;\n       int row=matrix.size();\n       int col=matrix[0].size();\n\n       int prevRow=0;\n       int nextRow=1;\n\n        if(target<=matrix[prevRow][col-1]){\n           return searchRow(matrix,target,0,col-1,prevRow);\n        }\n\n        while(nextRow<row){\n            if(target>matrix[prevRow][col-1] && target<=matrix[nextRow][col-1]){\n                return searchRow(matrix,target,0,col-1,nextRow);\n            }else if(target>matrix[prevRow][col-1] && target>matrix[nextRow][col-1]){\n                ++prevRow;\n                ++nextRow;\n            }\n        }\n    return false;\n    }\n};"
                    },
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "TIME COMPLEXITY   O(nlogm);;\\n\\n public boolean searchMatrix(int[][] matrix, int target) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        for(int i=0; i<n; i++){\\n           if(matrix[i][0]<=target && target<=matrix[i][m-1]){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j]==target)\\n                return true;\\n            }\\n            return false;\\n           }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "only2sachd",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n        int r = binarySearchRoeSelect(matrix,target);\\n        boolean isFound = binarySearch(matrix,r,target);\\n        return isFound;\\n        \\n    }\\n\\n    public static int binarySearchRoeSelect(int[][] matrix, int target){\\n        int low = 0;\\n        int high = matrix.length-1;\\n        int lc = matrix[0].length-1;\\n\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n\\n            if(matrix[mid][0] <= target && matrix[mid][lc] >= target){\\n                return mid;\\n            }\\n            else if(matrix[mid][0] < target){\\n                low = mid+1;\\n            }\\n            else if(matrix[mid][0] > target){\\n                high = mid-1;\\n            }\\n\\n        }\\n        return -1;\\n\\n\\n\\n    }\\n\\n    public static boolean binarySearch(int[][] matrix, int r, int target){\\n        int left =0;\\n        int right = matrix[0].length-1;\\n\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n\\n            if(matrix[r][mid] == target){\\n                return true;\\n            }\\n            else if(matrix[r][mid] > target){\\n                right = mid -1;\\n            }\\n            else{\\n                left = mid +1;\\n            }\\n\\n      \\n\\n        }\\n        return false;\\n\\n    }\\n}\\n\\nWhat is the problem with my solution ?\\n\\nits giving error in  \" if(matrix[r][mid] == target) \" in these line"
                    },
                    {
                        "username": "sakshi1jain",
                        "content": "good"
                    },
                    {
                        "username": "zephyr8",
                        "content": "Given the matrix properties - we can flatten out the matrix as if it were an array and do a binary search. TC would be O(logmn)\nI wonder if this is better than O(m+n) approach to move left or down from top right corner ( move up or right if we start at bottom left corner). \nComplexity wise -  logarithmic TC is better, but intuitively something seems off. Can some one help here?"
                    }
                ]
            },
            {
                "id": 1720624,
                "content": [
                    {
                        "username": "S_A_D_I_K",
                        "content": "leetcode needs more congruence on results, they seem to use different testcases for each submission\\n\\na O(log(m+n)) solution took 85 ms and O(m+n) solution took 42 ms\\n ```class Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        if target>matrix[R][C] or target<matrix[0][0]:\\n            return False\\n        r,c = 0,C\\n        while 0<=r<=R and 0<=c<=C:\\n            if target == matrix[r][c]:\\n                return True\\n            elif target > matrix[r][c]:\\n                r += 1\\n            elif target < matrix[r][c]:\\n                c -= 1\\n        return False\\n        \\nthis is a O(m+n) solution , which performed better than the below code\\n    ```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix or not matrix[0]:\\n            return False\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        \\n        if target > matrix[R][C] or target < matrix[0][0]:\\n            return False\\n        top,bottom = 0,R\\n        while top<=bottom:\\n            middle = (top+bottom)//2\\n            if target < matrix[middle][0]:\\n                bottom = middle-1\\n            elif target > matrix[middle][-1]:\\n                top = middle+1\\n            else:\\n                break\\n \\n        l,r = 0,C\\n        while l<=r:\\n            m = (l+r)//2\\n            if target == matrix[middle][m]:\\n                return True\\n            elif target < matrix[middle][m]:\\n                r = m - 1\\n            elif target > matrix[middle][m]:\\n                l = m + 1\\n        return False\\n \\n"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the eaisest one in which linear traversing of each element if it found the element return true otherwise return false\\n"
                    },
                    {
                        "username": "xandergardner",
                        "content": "Leetcode C++ Compiler Broken?\\n\\nThis code works locally but infinitely loops when run on leetcode:\\n\\n ```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int minrow = 0;\\n        int maxrow = matrix.size()-1;\\n        int midrow;\\n        int i = 0;\\n        while (minrow < maxrow) {\\n            // cout << minrow << \" \";\\n            // cout << maxrow << \" \";\\n            midrow = (minrow + maxrow) / 2;\\n            if (target < matrix[midrow][0]) {\\n                maxrow = midrow-1;\\n                // cout << \"ch to max: \" << maxrow;\\n            } else if (target > matrix[midrow][0]) {\\n                minrow = midrow;\\n                // cout << \"ch to min: \" << minrow;\\n            } else {\\n                cout << 1;\\n                return true;\\n            }\\n            // cout << i << \\'\\\\n\\';\\n            i++;\\n        }\\n        return binary_search(matrix[minrow].begin(), matrix[minrow].end(), target);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "jslominsky",
                        "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n         int row = getRow(matrix, target);\\n        if(row == -1)\\n            return false;\\n        else\\n        {\\n            boolean  result = binarySearch(matrix[row],target);\\n            return result;\\n        }\\n        \\n    \\n    \\n        \\n    }\\n    \\n static int getRow(int [][] matrix, int target)\\n    {\\n        int top = 0;\\n        int middle = matrix.length/2;\\n        int bottom = matrix.length;\\n        boolean rowFound = false;\\n        int row = -1;\\n        int inspectRight = matrix[middle][matrix[middle].length-1];\\n        int inspectLeft = matrix[middle][0];\\n        int maxIterations = (int)Math.ceil(Math.log(bottom));\\n        int i = 0;\\n        while(rowFound == false )\\n        {\\n            inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n           i++;\\n            if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                rowFound = true;\\n                row = middle;\\n            }\\n            else\\n            {\\n               \\n                if(target < inspectRight)\\n                {\\n                    bottom = middle;\\n                    middle = (top+bottom)/2;\\n                }\\n                else\\n                {\\n                    top = middle;\\n                    middle = (top+bottom)/2;\\n                    \\n                }\\n            }\\n            \\n            if(top == middle && top == bottom -1)\\n            {\\n                rowFound = true;\\n            }\\n            else if(top == middle && top == bottom)\\n            {\\n                rowFound = true;\\n            }\\n            \\n            \\n        }\\n     \\n      inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n         if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                \\n                row = middle;\\n            }\\n         \\n        return row;\\n }\\n        \\n    \\n    static boolean binarySearch(int v[], int To_Find)\\n    {\\n    int lo = 0, hi = v.length - 1;\\n    // This below check covers all cases , so need to check\\n    // for mid=lo-(hi-lo)/2\\n    while (hi - lo > 1) {\\n        int mid = (hi + lo) / 2;\\n        if (v[mid] < To_Find) {\\n            lo = mid + 1;\\n        }\\n        else {\\n            hi = mid;\\n        }\\n    }\\n    if (v[lo] == To_Find) {\\n      return true;\\n    }\\n    else if (v[hi] == To_Find) {\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n}\\n    \\n    \\n    \\n    \\n}"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0 , col = matrix[0].length-1;\\n        while(row < matrix.length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            }else if(matrix[row][col] < target){\\n                row ++;\\n            }else{\\n                col--;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "aditrout29",
                        "content": "class Solution {\npublic:\n    bool searchRow(vector<vector<int>>& matrix, int target,int s, int e,int row{\n           while(e>=s){\n            if(matrix[row][e]==target){\n                return true;\n            }\n            --e;\n        }  \n         return false;\n    }\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n       bool flag=false;\n       int row=matrix.size();\n       int col=matrix[0].size();\n\n       int prevRow=0;\n       int nextRow=1;\n\n        if(target<=matrix[prevRow][col-1]){\n           return searchRow(matrix,target,0,col-1,prevRow);\n        }\n\n        while(nextRow<row){\n            if(target>matrix[prevRow][col-1] && target<=matrix[nextRow][col-1]){\n                return searchRow(matrix,target,0,col-1,nextRow);\n            }else if(target>matrix[prevRow][col-1] && target>matrix[nextRow][col-1]){\n                ++prevRow;\n                ++nextRow;\n            }\n        }\n    return false;\n    }\n};"
                    },
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "TIME COMPLEXITY   O(nlogm);;\\n\\n public boolean searchMatrix(int[][] matrix, int target) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        for(int i=0; i<n; i++){\\n           if(matrix[i][0]<=target && target<=matrix[i][m-1]){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j]==target)\\n                return true;\\n            }\\n            return false;\\n           }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "only2sachd",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n        int r = binarySearchRoeSelect(matrix,target);\\n        boolean isFound = binarySearch(matrix,r,target);\\n        return isFound;\\n        \\n    }\\n\\n    public static int binarySearchRoeSelect(int[][] matrix, int target){\\n        int low = 0;\\n        int high = matrix.length-1;\\n        int lc = matrix[0].length-1;\\n\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n\\n            if(matrix[mid][0] <= target && matrix[mid][lc] >= target){\\n                return mid;\\n            }\\n            else if(matrix[mid][0] < target){\\n                low = mid+1;\\n            }\\n            else if(matrix[mid][0] > target){\\n                high = mid-1;\\n            }\\n\\n        }\\n        return -1;\\n\\n\\n\\n    }\\n\\n    public static boolean binarySearch(int[][] matrix, int r, int target){\\n        int left =0;\\n        int right = matrix[0].length-1;\\n\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n\\n            if(matrix[r][mid] == target){\\n                return true;\\n            }\\n            else if(matrix[r][mid] > target){\\n                right = mid -1;\\n            }\\n            else{\\n                left = mid +1;\\n            }\\n\\n      \\n\\n        }\\n        return false;\\n\\n    }\\n}\\n\\nWhat is the problem with my solution ?\\n\\nits giving error in  \" if(matrix[r][mid] == target) \" in these line"
                    },
                    {
                        "username": "sakshi1jain",
                        "content": "good"
                    },
                    {
                        "username": "zephyr8",
                        "content": "Given the matrix properties - we can flatten out the matrix as if it were an array and do a binary search. TC would be O(logmn)\nI wonder if this is better than O(m+n) approach to move left or down from top right corner ( move up or right if we start at bottom left corner). \nComplexity wise -  logarithmic TC is better, but intuitively something seems off. Can some one help here?"
                    }
                ]
            },
            {
                "id": 1711193,
                "content": [
                    {
                        "username": "S_A_D_I_K",
                        "content": "leetcode needs more congruence on results, they seem to use different testcases for each submission\\n\\na O(log(m+n)) solution took 85 ms and O(m+n) solution took 42 ms\\n ```class Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        if target>matrix[R][C] or target<matrix[0][0]:\\n            return False\\n        r,c = 0,C\\n        while 0<=r<=R and 0<=c<=C:\\n            if target == matrix[r][c]:\\n                return True\\n            elif target > matrix[r][c]:\\n                r += 1\\n            elif target < matrix[r][c]:\\n                c -= 1\\n        return False\\n        \\nthis is a O(m+n) solution , which performed better than the below code\\n    ```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix or not matrix[0]:\\n            return False\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        \\n        if target > matrix[R][C] or target < matrix[0][0]:\\n            return False\\n        top,bottom = 0,R\\n        while top<=bottom:\\n            middle = (top+bottom)//2\\n            if target < matrix[middle][0]:\\n                bottom = middle-1\\n            elif target > matrix[middle][-1]:\\n                top = middle+1\\n            else:\\n                break\\n \\n        l,r = 0,C\\n        while l<=r:\\n            m = (l+r)//2\\n            if target == matrix[middle][m]:\\n                return True\\n            elif target < matrix[middle][m]:\\n                r = m - 1\\n            elif target > matrix[middle][m]:\\n                l = m + 1\\n        return False\\n \\n"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the eaisest one in which linear traversing of each element if it found the element return true otherwise return false\\n"
                    },
                    {
                        "username": "xandergardner",
                        "content": "Leetcode C++ Compiler Broken?\\n\\nThis code works locally but infinitely loops when run on leetcode:\\n\\n ```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int minrow = 0;\\n        int maxrow = matrix.size()-1;\\n        int midrow;\\n        int i = 0;\\n        while (minrow < maxrow) {\\n            // cout << minrow << \" \";\\n            // cout << maxrow << \" \";\\n            midrow = (minrow + maxrow) / 2;\\n            if (target < matrix[midrow][0]) {\\n                maxrow = midrow-1;\\n                // cout << \"ch to max: \" << maxrow;\\n            } else if (target > matrix[midrow][0]) {\\n                minrow = midrow;\\n                // cout << \"ch to min: \" << minrow;\\n            } else {\\n                cout << 1;\\n                return true;\\n            }\\n            // cout << i << \\'\\\\n\\';\\n            i++;\\n        }\\n        return binary_search(matrix[minrow].begin(), matrix[minrow].end(), target);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "jslominsky",
                        "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n         int row = getRow(matrix, target);\\n        if(row == -1)\\n            return false;\\n        else\\n        {\\n            boolean  result = binarySearch(matrix[row],target);\\n            return result;\\n        }\\n        \\n    \\n    \\n        \\n    }\\n    \\n static int getRow(int [][] matrix, int target)\\n    {\\n        int top = 0;\\n        int middle = matrix.length/2;\\n        int bottom = matrix.length;\\n        boolean rowFound = false;\\n        int row = -1;\\n        int inspectRight = matrix[middle][matrix[middle].length-1];\\n        int inspectLeft = matrix[middle][0];\\n        int maxIterations = (int)Math.ceil(Math.log(bottom));\\n        int i = 0;\\n        while(rowFound == false )\\n        {\\n            inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n           i++;\\n            if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                rowFound = true;\\n                row = middle;\\n            }\\n            else\\n            {\\n               \\n                if(target < inspectRight)\\n                {\\n                    bottom = middle;\\n                    middle = (top+bottom)/2;\\n                }\\n                else\\n                {\\n                    top = middle;\\n                    middle = (top+bottom)/2;\\n                    \\n                }\\n            }\\n            \\n            if(top == middle && top == bottom -1)\\n            {\\n                rowFound = true;\\n            }\\n            else if(top == middle && top == bottom)\\n            {\\n                rowFound = true;\\n            }\\n            \\n            \\n        }\\n     \\n      inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n         if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                \\n                row = middle;\\n            }\\n         \\n        return row;\\n }\\n        \\n    \\n    static boolean binarySearch(int v[], int To_Find)\\n    {\\n    int lo = 0, hi = v.length - 1;\\n    // This below check covers all cases , so need to check\\n    // for mid=lo-(hi-lo)/2\\n    while (hi - lo > 1) {\\n        int mid = (hi + lo) / 2;\\n        if (v[mid] < To_Find) {\\n            lo = mid + 1;\\n        }\\n        else {\\n            hi = mid;\\n        }\\n    }\\n    if (v[lo] == To_Find) {\\n      return true;\\n    }\\n    else if (v[hi] == To_Find) {\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n}\\n    \\n    \\n    \\n    \\n}"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0 , col = matrix[0].length-1;\\n        while(row < matrix.length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            }else if(matrix[row][col] < target){\\n                row ++;\\n            }else{\\n                col--;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "aditrout29",
                        "content": "class Solution {\npublic:\n    bool searchRow(vector<vector<int>>& matrix, int target,int s, int e,int row{\n           while(e>=s){\n            if(matrix[row][e]==target){\n                return true;\n            }\n            --e;\n        }  \n         return false;\n    }\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n       bool flag=false;\n       int row=matrix.size();\n       int col=matrix[0].size();\n\n       int prevRow=0;\n       int nextRow=1;\n\n        if(target<=matrix[prevRow][col-1]){\n           return searchRow(matrix,target,0,col-1,prevRow);\n        }\n\n        while(nextRow<row){\n            if(target>matrix[prevRow][col-1] && target<=matrix[nextRow][col-1]){\n                return searchRow(matrix,target,0,col-1,nextRow);\n            }else if(target>matrix[prevRow][col-1] && target>matrix[nextRow][col-1]){\n                ++prevRow;\n                ++nextRow;\n            }\n        }\n    return false;\n    }\n};"
                    },
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "TIME COMPLEXITY   O(nlogm);;\\n\\n public boolean searchMatrix(int[][] matrix, int target) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        for(int i=0; i<n; i++){\\n           if(matrix[i][0]<=target && target<=matrix[i][m-1]){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j]==target)\\n                return true;\\n            }\\n            return false;\\n           }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "only2sachd",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n        int r = binarySearchRoeSelect(matrix,target);\\n        boolean isFound = binarySearch(matrix,r,target);\\n        return isFound;\\n        \\n    }\\n\\n    public static int binarySearchRoeSelect(int[][] matrix, int target){\\n        int low = 0;\\n        int high = matrix.length-1;\\n        int lc = matrix[0].length-1;\\n\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n\\n            if(matrix[mid][0] <= target && matrix[mid][lc] >= target){\\n                return mid;\\n            }\\n            else if(matrix[mid][0] < target){\\n                low = mid+1;\\n            }\\n            else if(matrix[mid][0] > target){\\n                high = mid-1;\\n            }\\n\\n        }\\n        return -1;\\n\\n\\n\\n    }\\n\\n    public static boolean binarySearch(int[][] matrix, int r, int target){\\n        int left =0;\\n        int right = matrix[0].length-1;\\n\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n\\n            if(matrix[r][mid] == target){\\n                return true;\\n            }\\n            else if(matrix[r][mid] > target){\\n                right = mid -1;\\n            }\\n            else{\\n                left = mid +1;\\n            }\\n\\n      \\n\\n        }\\n        return false;\\n\\n    }\\n}\\n\\nWhat is the problem with my solution ?\\n\\nits giving error in  \" if(matrix[r][mid] == target) \" in these line"
                    },
                    {
                        "username": "sakshi1jain",
                        "content": "good"
                    },
                    {
                        "username": "zephyr8",
                        "content": "Given the matrix properties - we can flatten out the matrix as if it were an array and do a binary search. TC would be O(logmn)\nI wonder if this is better than O(m+n) approach to move left or down from top right corner ( move up or right if we start at bottom left corner). \nComplexity wise -  logarithmic TC is better, but intuitively something seems off. Can some one help here?"
                    }
                ]
            },
            {
                "id": 1711086,
                "content": [
                    {
                        "username": "S_A_D_I_K",
                        "content": "leetcode needs more congruence on results, they seem to use different testcases for each submission\\n\\na O(log(m+n)) solution took 85 ms and O(m+n) solution took 42 ms\\n ```class Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        if target>matrix[R][C] or target<matrix[0][0]:\\n            return False\\n        r,c = 0,C\\n        while 0<=r<=R and 0<=c<=C:\\n            if target == matrix[r][c]:\\n                return True\\n            elif target > matrix[r][c]:\\n                r += 1\\n            elif target < matrix[r][c]:\\n                c -= 1\\n        return False\\n        \\nthis is a O(m+n) solution , which performed better than the below code\\n    ```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix or not matrix[0]:\\n            return False\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        \\n        if target > matrix[R][C] or target < matrix[0][0]:\\n            return False\\n        top,bottom = 0,R\\n        while top<=bottom:\\n            middle = (top+bottom)//2\\n            if target < matrix[middle][0]:\\n                bottom = middle-1\\n            elif target > matrix[middle][-1]:\\n                top = middle+1\\n            else:\\n                break\\n \\n        l,r = 0,C\\n        while l<=r:\\n            m = (l+r)//2\\n            if target == matrix[middle][m]:\\n                return True\\n            elif target < matrix[middle][m]:\\n                r = m - 1\\n            elif target > matrix[middle][m]:\\n                l = m + 1\\n        return False\\n \\n"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the eaisest one in which linear traversing of each element if it found the element return true otherwise return false\\n"
                    },
                    {
                        "username": "xandergardner",
                        "content": "Leetcode C++ Compiler Broken?\\n\\nThis code works locally but infinitely loops when run on leetcode:\\n\\n ```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int minrow = 0;\\n        int maxrow = matrix.size()-1;\\n        int midrow;\\n        int i = 0;\\n        while (minrow < maxrow) {\\n            // cout << minrow << \" \";\\n            // cout << maxrow << \" \";\\n            midrow = (minrow + maxrow) / 2;\\n            if (target < matrix[midrow][0]) {\\n                maxrow = midrow-1;\\n                // cout << \"ch to max: \" << maxrow;\\n            } else if (target > matrix[midrow][0]) {\\n                minrow = midrow;\\n                // cout << \"ch to min: \" << minrow;\\n            } else {\\n                cout << 1;\\n                return true;\\n            }\\n            // cout << i << \\'\\\\n\\';\\n            i++;\\n        }\\n        return binary_search(matrix[minrow].begin(), matrix[minrow].end(), target);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "jslominsky",
                        "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n         int row = getRow(matrix, target);\\n        if(row == -1)\\n            return false;\\n        else\\n        {\\n            boolean  result = binarySearch(matrix[row],target);\\n            return result;\\n        }\\n        \\n    \\n    \\n        \\n    }\\n    \\n static int getRow(int [][] matrix, int target)\\n    {\\n        int top = 0;\\n        int middle = matrix.length/2;\\n        int bottom = matrix.length;\\n        boolean rowFound = false;\\n        int row = -1;\\n        int inspectRight = matrix[middle][matrix[middle].length-1];\\n        int inspectLeft = matrix[middle][0];\\n        int maxIterations = (int)Math.ceil(Math.log(bottom));\\n        int i = 0;\\n        while(rowFound == false )\\n        {\\n            inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n           i++;\\n            if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                rowFound = true;\\n                row = middle;\\n            }\\n            else\\n            {\\n               \\n                if(target < inspectRight)\\n                {\\n                    bottom = middle;\\n                    middle = (top+bottom)/2;\\n                }\\n                else\\n                {\\n                    top = middle;\\n                    middle = (top+bottom)/2;\\n                    \\n                }\\n            }\\n            \\n            if(top == middle && top == bottom -1)\\n            {\\n                rowFound = true;\\n            }\\n            else if(top == middle && top == bottom)\\n            {\\n                rowFound = true;\\n            }\\n            \\n            \\n        }\\n     \\n      inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n         if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                \\n                row = middle;\\n            }\\n         \\n        return row;\\n }\\n        \\n    \\n    static boolean binarySearch(int v[], int To_Find)\\n    {\\n    int lo = 0, hi = v.length - 1;\\n    // This below check covers all cases , so need to check\\n    // for mid=lo-(hi-lo)/2\\n    while (hi - lo > 1) {\\n        int mid = (hi + lo) / 2;\\n        if (v[mid] < To_Find) {\\n            lo = mid + 1;\\n        }\\n        else {\\n            hi = mid;\\n        }\\n    }\\n    if (v[lo] == To_Find) {\\n      return true;\\n    }\\n    else if (v[hi] == To_Find) {\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n}\\n    \\n    \\n    \\n    \\n}"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0 , col = matrix[0].length-1;\\n        while(row < matrix.length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            }else if(matrix[row][col] < target){\\n                row ++;\\n            }else{\\n                col--;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "aditrout29",
                        "content": "class Solution {\npublic:\n    bool searchRow(vector<vector<int>>& matrix, int target,int s, int e,int row{\n           while(e>=s){\n            if(matrix[row][e]==target){\n                return true;\n            }\n            --e;\n        }  \n         return false;\n    }\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n       bool flag=false;\n       int row=matrix.size();\n       int col=matrix[0].size();\n\n       int prevRow=0;\n       int nextRow=1;\n\n        if(target<=matrix[prevRow][col-1]){\n           return searchRow(matrix,target,0,col-1,prevRow);\n        }\n\n        while(nextRow<row){\n            if(target>matrix[prevRow][col-1] && target<=matrix[nextRow][col-1]){\n                return searchRow(matrix,target,0,col-1,nextRow);\n            }else if(target>matrix[prevRow][col-1] && target>matrix[nextRow][col-1]){\n                ++prevRow;\n                ++nextRow;\n            }\n        }\n    return false;\n    }\n};"
                    },
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "TIME COMPLEXITY   O(nlogm);;\\n\\n public boolean searchMatrix(int[][] matrix, int target) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        for(int i=0; i<n; i++){\\n           if(matrix[i][0]<=target && target<=matrix[i][m-1]){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j]==target)\\n                return true;\\n            }\\n            return false;\\n           }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "only2sachd",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n        int r = binarySearchRoeSelect(matrix,target);\\n        boolean isFound = binarySearch(matrix,r,target);\\n        return isFound;\\n        \\n    }\\n\\n    public static int binarySearchRoeSelect(int[][] matrix, int target){\\n        int low = 0;\\n        int high = matrix.length-1;\\n        int lc = matrix[0].length-1;\\n\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n\\n            if(matrix[mid][0] <= target && matrix[mid][lc] >= target){\\n                return mid;\\n            }\\n            else if(matrix[mid][0] < target){\\n                low = mid+1;\\n            }\\n            else if(matrix[mid][0] > target){\\n                high = mid-1;\\n            }\\n\\n        }\\n        return -1;\\n\\n\\n\\n    }\\n\\n    public static boolean binarySearch(int[][] matrix, int r, int target){\\n        int left =0;\\n        int right = matrix[0].length-1;\\n\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n\\n            if(matrix[r][mid] == target){\\n                return true;\\n            }\\n            else if(matrix[r][mid] > target){\\n                right = mid -1;\\n            }\\n            else{\\n                left = mid +1;\\n            }\\n\\n      \\n\\n        }\\n        return false;\\n\\n    }\\n}\\n\\nWhat is the problem with my solution ?\\n\\nits giving error in  \" if(matrix[r][mid] == target) \" in these line"
                    },
                    {
                        "username": "sakshi1jain",
                        "content": "good"
                    },
                    {
                        "username": "zephyr8",
                        "content": "Given the matrix properties - we can flatten out the matrix as if it were an array and do a binary search. TC would be O(logmn)\nI wonder if this is better than O(m+n) approach to move left or down from top right corner ( move up or right if we start at bottom left corner). \nComplexity wise -  logarithmic TC is better, but intuitively something seems off. Can some one help here?"
                    }
                ]
            },
            {
                "id": 1709378,
                "content": [
                    {
                        "username": "S_A_D_I_K",
                        "content": "leetcode needs more congruence on results, they seem to use different testcases for each submission\\n\\na O(log(m+n)) solution took 85 ms and O(m+n) solution took 42 ms\\n ```class Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        if target>matrix[R][C] or target<matrix[0][0]:\\n            return False\\n        r,c = 0,C\\n        while 0<=r<=R and 0<=c<=C:\\n            if target == matrix[r][c]:\\n                return True\\n            elif target > matrix[r][c]:\\n                r += 1\\n            elif target < matrix[r][c]:\\n                c -= 1\\n        return False\\n        \\nthis is a O(m+n) solution , which performed better than the below code\\n    ```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix or not matrix[0]:\\n            return False\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        \\n        if target > matrix[R][C] or target < matrix[0][0]:\\n            return False\\n        top,bottom = 0,R\\n        while top<=bottom:\\n            middle = (top+bottom)//2\\n            if target < matrix[middle][0]:\\n                bottom = middle-1\\n            elif target > matrix[middle][-1]:\\n                top = middle+1\\n            else:\\n                break\\n \\n        l,r = 0,C\\n        while l<=r:\\n            m = (l+r)//2\\n            if target == matrix[middle][m]:\\n                return True\\n            elif target < matrix[middle][m]:\\n                r = m - 1\\n            elif target > matrix[middle][m]:\\n                l = m + 1\\n        return False\\n \\n"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the eaisest one in which linear traversing of each element if it found the element return true otherwise return false\\n"
                    },
                    {
                        "username": "xandergardner",
                        "content": "Leetcode C++ Compiler Broken?\\n\\nThis code works locally but infinitely loops when run on leetcode:\\n\\n ```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int minrow = 0;\\n        int maxrow = matrix.size()-1;\\n        int midrow;\\n        int i = 0;\\n        while (minrow < maxrow) {\\n            // cout << minrow << \" \";\\n            // cout << maxrow << \" \";\\n            midrow = (minrow + maxrow) / 2;\\n            if (target < matrix[midrow][0]) {\\n                maxrow = midrow-1;\\n                // cout << \"ch to max: \" << maxrow;\\n            } else if (target > matrix[midrow][0]) {\\n                minrow = midrow;\\n                // cout << \"ch to min: \" << minrow;\\n            } else {\\n                cout << 1;\\n                return true;\\n            }\\n            // cout << i << \\'\\\\n\\';\\n            i++;\\n        }\\n        return binary_search(matrix[minrow].begin(), matrix[minrow].end(), target);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "jslominsky",
                        "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n         int row = getRow(matrix, target);\\n        if(row == -1)\\n            return false;\\n        else\\n        {\\n            boolean  result = binarySearch(matrix[row],target);\\n            return result;\\n        }\\n        \\n    \\n    \\n        \\n    }\\n    \\n static int getRow(int [][] matrix, int target)\\n    {\\n        int top = 0;\\n        int middle = matrix.length/2;\\n        int bottom = matrix.length;\\n        boolean rowFound = false;\\n        int row = -1;\\n        int inspectRight = matrix[middle][matrix[middle].length-1];\\n        int inspectLeft = matrix[middle][0];\\n        int maxIterations = (int)Math.ceil(Math.log(bottom));\\n        int i = 0;\\n        while(rowFound == false )\\n        {\\n            inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n           i++;\\n            if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                rowFound = true;\\n                row = middle;\\n            }\\n            else\\n            {\\n               \\n                if(target < inspectRight)\\n                {\\n                    bottom = middle;\\n                    middle = (top+bottom)/2;\\n                }\\n                else\\n                {\\n                    top = middle;\\n                    middle = (top+bottom)/2;\\n                    \\n                }\\n            }\\n            \\n            if(top == middle && top == bottom -1)\\n            {\\n                rowFound = true;\\n            }\\n            else if(top == middle && top == bottom)\\n            {\\n                rowFound = true;\\n            }\\n            \\n            \\n        }\\n     \\n      inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n         if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                \\n                row = middle;\\n            }\\n         \\n        return row;\\n }\\n        \\n    \\n    static boolean binarySearch(int v[], int To_Find)\\n    {\\n    int lo = 0, hi = v.length - 1;\\n    // This below check covers all cases , so need to check\\n    // for mid=lo-(hi-lo)/2\\n    while (hi - lo > 1) {\\n        int mid = (hi + lo) / 2;\\n        if (v[mid] < To_Find) {\\n            lo = mid + 1;\\n        }\\n        else {\\n            hi = mid;\\n        }\\n    }\\n    if (v[lo] == To_Find) {\\n      return true;\\n    }\\n    else if (v[hi] == To_Find) {\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n}\\n    \\n    \\n    \\n    \\n}"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0 , col = matrix[0].length-1;\\n        while(row < matrix.length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            }else if(matrix[row][col] < target){\\n                row ++;\\n            }else{\\n                col--;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "aditrout29",
                        "content": "class Solution {\npublic:\n    bool searchRow(vector<vector<int>>& matrix, int target,int s, int e,int row{\n           while(e>=s){\n            if(matrix[row][e]==target){\n                return true;\n            }\n            --e;\n        }  \n         return false;\n    }\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n       bool flag=false;\n       int row=matrix.size();\n       int col=matrix[0].size();\n\n       int prevRow=0;\n       int nextRow=1;\n\n        if(target<=matrix[prevRow][col-1]){\n           return searchRow(matrix,target,0,col-1,prevRow);\n        }\n\n        while(nextRow<row){\n            if(target>matrix[prevRow][col-1] && target<=matrix[nextRow][col-1]){\n                return searchRow(matrix,target,0,col-1,nextRow);\n            }else if(target>matrix[prevRow][col-1] && target>matrix[nextRow][col-1]){\n                ++prevRow;\n                ++nextRow;\n            }\n        }\n    return false;\n    }\n};"
                    },
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "TIME COMPLEXITY   O(nlogm);;\\n\\n public boolean searchMatrix(int[][] matrix, int target) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        for(int i=0; i<n; i++){\\n           if(matrix[i][0]<=target && target<=matrix[i][m-1]){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j]==target)\\n                return true;\\n            }\\n            return false;\\n           }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "only2sachd",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n        int r = binarySearchRoeSelect(matrix,target);\\n        boolean isFound = binarySearch(matrix,r,target);\\n        return isFound;\\n        \\n    }\\n\\n    public static int binarySearchRoeSelect(int[][] matrix, int target){\\n        int low = 0;\\n        int high = matrix.length-1;\\n        int lc = matrix[0].length-1;\\n\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n\\n            if(matrix[mid][0] <= target && matrix[mid][lc] >= target){\\n                return mid;\\n            }\\n            else if(matrix[mid][0] < target){\\n                low = mid+1;\\n            }\\n            else if(matrix[mid][0] > target){\\n                high = mid-1;\\n            }\\n\\n        }\\n        return -1;\\n\\n\\n\\n    }\\n\\n    public static boolean binarySearch(int[][] matrix, int r, int target){\\n        int left =0;\\n        int right = matrix[0].length-1;\\n\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n\\n            if(matrix[r][mid] == target){\\n                return true;\\n            }\\n            else if(matrix[r][mid] > target){\\n                right = mid -1;\\n            }\\n            else{\\n                left = mid +1;\\n            }\\n\\n      \\n\\n        }\\n        return false;\\n\\n    }\\n}\\n\\nWhat is the problem with my solution ?\\n\\nits giving error in  \" if(matrix[r][mid] == target) \" in these line"
                    },
                    {
                        "username": "sakshi1jain",
                        "content": "good"
                    },
                    {
                        "username": "zephyr8",
                        "content": "Given the matrix properties - we can flatten out the matrix as if it were an array and do a binary search. TC would be O(logmn)\nI wonder if this is better than O(m+n) approach to move left or down from top right corner ( move up or right if we start at bottom left corner). \nComplexity wise -  logarithmic TC is better, but intuitively something seems off. Can some one help here?"
                    }
                ]
            },
            {
                "id": 1697565,
                "content": [
                    {
                        "username": "S_A_D_I_K",
                        "content": "leetcode needs more congruence on results, they seem to use different testcases for each submission\\n\\na O(log(m+n)) solution took 85 ms and O(m+n) solution took 42 ms\\n ```class Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        if target>matrix[R][C] or target<matrix[0][0]:\\n            return False\\n        r,c = 0,C\\n        while 0<=r<=R and 0<=c<=C:\\n            if target == matrix[r][c]:\\n                return True\\n            elif target > matrix[r][c]:\\n                r += 1\\n            elif target < matrix[r][c]:\\n                c -= 1\\n        return False\\n        \\nthis is a O(m+n) solution , which performed better than the below code\\n    ```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix or not matrix[0]:\\n            return False\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        \\n        if target > matrix[R][C] or target < matrix[0][0]:\\n            return False\\n        top,bottom = 0,R\\n        while top<=bottom:\\n            middle = (top+bottom)//2\\n            if target < matrix[middle][0]:\\n                bottom = middle-1\\n            elif target > matrix[middle][-1]:\\n                top = middle+1\\n            else:\\n                break\\n \\n        l,r = 0,C\\n        while l<=r:\\n            m = (l+r)//2\\n            if target == matrix[middle][m]:\\n                return True\\n            elif target < matrix[middle][m]:\\n                r = m - 1\\n            elif target > matrix[middle][m]:\\n                l = m + 1\\n        return False\\n \\n"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the eaisest one in which linear traversing of each element if it found the element return true otherwise return false\\n"
                    },
                    {
                        "username": "xandergardner",
                        "content": "Leetcode C++ Compiler Broken?\\n\\nThis code works locally but infinitely loops when run on leetcode:\\n\\n ```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int minrow = 0;\\n        int maxrow = matrix.size()-1;\\n        int midrow;\\n        int i = 0;\\n        while (minrow < maxrow) {\\n            // cout << minrow << \" \";\\n            // cout << maxrow << \" \";\\n            midrow = (minrow + maxrow) / 2;\\n            if (target < matrix[midrow][0]) {\\n                maxrow = midrow-1;\\n                // cout << \"ch to max: \" << maxrow;\\n            } else if (target > matrix[midrow][0]) {\\n                minrow = midrow;\\n                // cout << \"ch to min: \" << minrow;\\n            } else {\\n                cout << 1;\\n                return true;\\n            }\\n            // cout << i << \\'\\\\n\\';\\n            i++;\\n        }\\n        return binary_search(matrix[minrow].begin(), matrix[minrow].end(), target);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "jslominsky",
                        "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n         int row = getRow(matrix, target);\\n        if(row == -1)\\n            return false;\\n        else\\n        {\\n            boolean  result = binarySearch(matrix[row],target);\\n            return result;\\n        }\\n        \\n    \\n    \\n        \\n    }\\n    \\n static int getRow(int [][] matrix, int target)\\n    {\\n        int top = 0;\\n        int middle = matrix.length/2;\\n        int bottom = matrix.length;\\n        boolean rowFound = false;\\n        int row = -1;\\n        int inspectRight = matrix[middle][matrix[middle].length-1];\\n        int inspectLeft = matrix[middle][0];\\n        int maxIterations = (int)Math.ceil(Math.log(bottom));\\n        int i = 0;\\n        while(rowFound == false )\\n        {\\n            inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n           i++;\\n            if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                rowFound = true;\\n                row = middle;\\n            }\\n            else\\n            {\\n               \\n                if(target < inspectRight)\\n                {\\n                    bottom = middle;\\n                    middle = (top+bottom)/2;\\n                }\\n                else\\n                {\\n                    top = middle;\\n                    middle = (top+bottom)/2;\\n                    \\n                }\\n            }\\n            \\n            if(top == middle && top == bottom -1)\\n            {\\n                rowFound = true;\\n            }\\n            else if(top == middle && top == bottom)\\n            {\\n                rowFound = true;\\n            }\\n            \\n            \\n        }\\n     \\n      inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n         if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                \\n                row = middle;\\n            }\\n         \\n        return row;\\n }\\n        \\n    \\n    static boolean binarySearch(int v[], int To_Find)\\n    {\\n    int lo = 0, hi = v.length - 1;\\n    // This below check covers all cases , so need to check\\n    // for mid=lo-(hi-lo)/2\\n    while (hi - lo > 1) {\\n        int mid = (hi + lo) / 2;\\n        if (v[mid] < To_Find) {\\n            lo = mid + 1;\\n        }\\n        else {\\n            hi = mid;\\n        }\\n    }\\n    if (v[lo] == To_Find) {\\n      return true;\\n    }\\n    else if (v[hi] == To_Find) {\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n}\\n    \\n    \\n    \\n    \\n}"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0 , col = matrix[0].length-1;\\n        while(row < matrix.length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            }else if(matrix[row][col] < target){\\n                row ++;\\n            }else{\\n                col--;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "aditrout29",
                        "content": "class Solution {\npublic:\n    bool searchRow(vector<vector<int>>& matrix, int target,int s, int e,int row{\n           while(e>=s){\n            if(matrix[row][e]==target){\n                return true;\n            }\n            --e;\n        }  \n         return false;\n    }\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n       bool flag=false;\n       int row=matrix.size();\n       int col=matrix[0].size();\n\n       int prevRow=0;\n       int nextRow=1;\n\n        if(target<=matrix[prevRow][col-1]){\n           return searchRow(matrix,target,0,col-1,prevRow);\n        }\n\n        while(nextRow<row){\n            if(target>matrix[prevRow][col-1] && target<=matrix[nextRow][col-1]){\n                return searchRow(matrix,target,0,col-1,nextRow);\n            }else if(target>matrix[prevRow][col-1] && target>matrix[nextRow][col-1]){\n                ++prevRow;\n                ++nextRow;\n            }\n        }\n    return false;\n    }\n};"
                    },
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "TIME COMPLEXITY   O(nlogm);;\\n\\n public boolean searchMatrix(int[][] matrix, int target) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        for(int i=0; i<n; i++){\\n           if(matrix[i][0]<=target && target<=matrix[i][m-1]){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j]==target)\\n                return true;\\n            }\\n            return false;\\n           }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "only2sachd",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n        int r = binarySearchRoeSelect(matrix,target);\\n        boolean isFound = binarySearch(matrix,r,target);\\n        return isFound;\\n        \\n    }\\n\\n    public static int binarySearchRoeSelect(int[][] matrix, int target){\\n        int low = 0;\\n        int high = matrix.length-1;\\n        int lc = matrix[0].length-1;\\n\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n\\n            if(matrix[mid][0] <= target && matrix[mid][lc] >= target){\\n                return mid;\\n            }\\n            else if(matrix[mid][0] < target){\\n                low = mid+1;\\n            }\\n            else if(matrix[mid][0] > target){\\n                high = mid-1;\\n            }\\n\\n        }\\n        return -1;\\n\\n\\n\\n    }\\n\\n    public static boolean binarySearch(int[][] matrix, int r, int target){\\n        int left =0;\\n        int right = matrix[0].length-1;\\n\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n\\n            if(matrix[r][mid] == target){\\n                return true;\\n            }\\n            else if(matrix[r][mid] > target){\\n                right = mid -1;\\n            }\\n            else{\\n                left = mid +1;\\n            }\\n\\n      \\n\\n        }\\n        return false;\\n\\n    }\\n}\\n\\nWhat is the problem with my solution ?\\n\\nits giving error in  \" if(matrix[r][mid] == target) \" in these line"
                    },
                    {
                        "username": "sakshi1jain",
                        "content": "good"
                    },
                    {
                        "username": "zephyr8",
                        "content": "Given the matrix properties - we can flatten out the matrix as if it were an array and do a binary search. TC would be O(logmn)\nI wonder if this is better than O(m+n) approach to move left or down from top right corner ( move up or right if we start at bottom left corner). \nComplexity wise -  logarithmic TC is better, but intuitively something seems off. Can some one help here?"
                    }
                ]
            },
            {
                "id": 1692064,
                "content": [
                    {
                        "username": "S_A_D_I_K",
                        "content": "leetcode needs more congruence on results, they seem to use different testcases for each submission\\n\\na O(log(m+n)) solution took 85 ms and O(m+n) solution took 42 ms\\n ```class Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        if target>matrix[R][C] or target<matrix[0][0]:\\n            return False\\n        r,c = 0,C\\n        while 0<=r<=R and 0<=c<=C:\\n            if target == matrix[r][c]:\\n                return True\\n            elif target > matrix[r][c]:\\n                r += 1\\n            elif target < matrix[r][c]:\\n                c -= 1\\n        return False\\n        \\nthis is a O(m+n) solution , which performed better than the below code\\n    ```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix or not matrix[0]:\\n            return False\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        \\n        if target > matrix[R][C] or target < matrix[0][0]:\\n            return False\\n        top,bottom = 0,R\\n        while top<=bottom:\\n            middle = (top+bottom)//2\\n            if target < matrix[middle][0]:\\n                bottom = middle-1\\n            elif target > matrix[middle][-1]:\\n                top = middle+1\\n            else:\\n                break\\n \\n        l,r = 0,C\\n        while l<=r:\\n            m = (l+r)//2\\n            if target == matrix[middle][m]:\\n                return True\\n            elif target < matrix[middle][m]:\\n                r = m - 1\\n            elif target > matrix[middle][m]:\\n                l = m + 1\\n        return False\\n \\n"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the eaisest one in which linear traversing of each element if it found the element return true otherwise return false\\n"
                    },
                    {
                        "username": "xandergardner",
                        "content": "Leetcode C++ Compiler Broken?\\n\\nThis code works locally but infinitely loops when run on leetcode:\\n\\n ```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int minrow = 0;\\n        int maxrow = matrix.size()-1;\\n        int midrow;\\n        int i = 0;\\n        while (minrow < maxrow) {\\n            // cout << minrow << \" \";\\n            // cout << maxrow << \" \";\\n            midrow = (minrow + maxrow) / 2;\\n            if (target < matrix[midrow][0]) {\\n                maxrow = midrow-1;\\n                // cout << \"ch to max: \" << maxrow;\\n            } else if (target > matrix[midrow][0]) {\\n                minrow = midrow;\\n                // cout << \"ch to min: \" << minrow;\\n            } else {\\n                cout << 1;\\n                return true;\\n            }\\n            // cout << i << \\'\\\\n\\';\\n            i++;\\n        }\\n        return binary_search(matrix[minrow].begin(), matrix[minrow].end(), target);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "jslominsky",
                        "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n         int row = getRow(matrix, target);\\n        if(row == -1)\\n            return false;\\n        else\\n        {\\n            boolean  result = binarySearch(matrix[row],target);\\n            return result;\\n        }\\n        \\n    \\n    \\n        \\n    }\\n    \\n static int getRow(int [][] matrix, int target)\\n    {\\n        int top = 0;\\n        int middle = matrix.length/2;\\n        int bottom = matrix.length;\\n        boolean rowFound = false;\\n        int row = -1;\\n        int inspectRight = matrix[middle][matrix[middle].length-1];\\n        int inspectLeft = matrix[middle][0];\\n        int maxIterations = (int)Math.ceil(Math.log(bottom));\\n        int i = 0;\\n        while(rowFound == false )\\n        {\\n            inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n           i++;\\n            if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                rowFound = true;\\n                row = middle;\\n            }\\n            else\\n            {\\n               \\n                if(target < inspectRight)\\n                {\\n                    bottom = middle;\\n                    middle = (top+bottom)/2;\\n                }\\n                else\\n                {\\n                    top = middle;\\n                    middle = (top+bottom)/2;\\n                    \\n                }\\n            }\\n            \\n            if(top == middle && top == bottom -1)\\n            {\\n                rowFound = true;\\n            }\\n            else if(top == middle && top == bottom)\\n            {\\n                rowFound = true;\\n            }\\n            \\n            \\n        }\\n     \\n      inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n         if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                \\n                row = middle;\\n            }\\n         \\n        return row;\\n }\\n        \\n    \\n    static boolean binarySearch(int v[], int To_Find)\\n    {\\n    int lo = 0, hi = v.length - 1;\\n    // This below check covers all cases , so need to check\\n    // for mid=lo-(hi-lo)/2\\n    while (hi - lo > 1) {\\n        int mid = (hi + lo) / 2;\\n        if (v[mid] < To_Find) {\\n            lo = mid + 1;\\n        }\\n        else {\\n            hi = mid;\\n        }\\n    }\\n    if (v[lo] == To_Find) {\\n      return true;\\n    }\\n    else if (v[hi] == To_Find) {\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n}\\n    \\n    \\n    \\n    \\n}"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0 , col = matrix[0].length-1;\\n        while(row < matrix.length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            }else if(matrix[row][col] < target){\\n                row ++;\\n            }else{\\n                col--;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "aditrout29",
                        "content": "class Solution {\npublic:\n    bool searchRow(vector<vector<int>>& matrix, int target,int s, int e,int row{\n           while(e>=s){\n            if(matrix[row][e]==target){\n                return true;\n            }\n            --e;\n        }  \n         return false;\n    }\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n       bool flag=false;\n       int row=matrix.size();\n       int col=matrix[0].size();\n\n       int prevRow=0;\n       int nextRow=1;\n\n        if(target<=matrix[prevRow][col-1]){\n           return searchRow(matrix,target,0,col-1,prevRow);\n        }\n\n        while(nextRow<row){\n            if(target>matrix[prevRow][col-1] && target<=matrix[nextRow][col-1]){\n                return searchRow(matrix,target,0,col-1,nextRow);\n            }else if(target>matrix[prevRow][col-1] && target>matrix[nextRow][col-1]){\n                ++prevRow;\n                ++nextRow;\n            }\n        }\n    return false;\n    }\n};"
                    },
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "TIME COMPLEXITY   O(nlogm);;\\n\\n public boolean searchMatrix(int[][] matrix, int target) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        for(int i=0; i<n; i++){\\n           if(matrix[i][0]<=target && target<=matrix[i][m-1]){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j]==target)\\n                return true;\\n            }\\n            return false;\\n           }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "only2sachd",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n        int r = binarySearchRoeSelect(matrix,target);\\n        boolean isFound = binarySearch(matrix,r,target);\\n        return isFound;\\n        \\n    }\\n\\n    public static int binarySearchRoeSelect(int[][] matrix, int target){\\n        int low = 0;\\n        int high = matrix.length-1;\\n        int lc = matrix[0].length-1;\\n\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n\\n            if(matrix[mid][0] <= target && matrix[mid][lc] >= target){\\n                return mid;\\n            }\\n            else if(matrix[mid][0] < target){\\n                low = mid+1;\\n            }\\n            else if(matrix[mid][0] > target){\\n                high = mid-1;\\n            }\\n\\n        }\\n        return -1;\\n\\n\\n\\n    }\\n\\n    public static boolean binarySearch(int[][] matrix, int r, int target){\\n        int left =0;\\n        int right = matrix[0].length-1;\\n\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n\\n            if(matrix[r][mid] == target){\\n                return true;\\n            }\\n            else if(matrix[r][mid] > target){\\n                right = mid -1;\\n            }\\n            else{\\n                left = mid +1;\\n            }\\n\\n      \\n\\n        }\\n        return false;\\n\\n    }\\n}\\n\\nWhat is the problem with my solution ?\\n\\nits giving error in  \" if(matrix[r][mid] == target) \" in these line"
                    },
                    {
                        "username": "sakshi1jain",
                        "content": "good"
                    },
                    {
                        "username": "zephyr8",
                        "content": "Given the matrix properties - we can flatten out the matrix as if it were an array and do a binary search. TC would be O(logmn)\nI wonder if this is better than O(m+n) approach to move left or down from top right corner ( move up or right if we start at bottom left corner). \nComplexity wise -  logarithmic TC is better, but intuitively something seems off. Can some one help here?"
                    }
                ]
            },
            {
                "id": 1689574,
                "content": [
                    {
                        "username": "S_A_D_I_K",
                        "content": "leetcode needs more congruence on results, they seem to use different testcases for each submission\\n\\na O(log(m+n)) solution took 85 ms and O(m+n) solution took 42 ms\\n ```class Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        if target>matrix[R][C] or target<matrix[0][0]:\\n            return False\\n        r,c = 0,C\\n        while 0<=r<=R and 0<=c<=C:\\n            if target == matrix[r][c]:\\n                return True\\n            elif target > matrix[r][c]:\\n                r += 1\\n            elif target < matrix[r][c]:\\n                c -= 1\\n        return False\\n        \\nthis is a O(m+n) solution , which performed better than the below code\\n    ```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix or not matrix[0]:\\n            return False\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        \\n        if target > matrix[R][C] or target < matrix[0][0]:\\n            return False\\n        top,bottom = 0,R\\n        while top<=bottom:\\n            middle = (top+bottom)//2\\n            if target < matrix[middle][0]:\\n                bottom = middle-1\\n            elif target > matrix[middle][-1]:\\n                top = middle+1\\n            else:\\n                break\\n \\n        l,r = 0,C\\n        while l<=r:\\n            m = (l+r)//2\\n            if target == matrix[middle][m]:\\n                return True\\n            elif target < matrix[middle][m]:\\n                r = m - 1\\n            elif target > matrix[middle][m]:\\n                l = m + 1\\n        return False\\n \\n"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the eaisest one in which linear traversing of each element if it found the element return true otherwise return false\\n"
                    },
                    {
                        "username": "xandergardner",
                        "content": "Leetcode C++ Compiler Broken?\\n\\nThis code works locally but infinitely loops when run on leetcode:\\n\\n ```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int minrow = 0;\\n        int maxrow = matrix.size()-1;\\n        int midrow;\\n        int i = 0;\\n        while (minrow < maxrow) {\\n            // cout << minrow << \" \";\\n            // cout << maxrow << \" \";\\n            midrow = (minrow + maxrow) / 2;\\n            if (target < matrix[midrow][0]) {\\n                maxrow = midrow-1;\\n                // cout << \"ch to max: \" << maxrow;\\n            } else if (target > matrix[midrow][0]) {\\n                minrow = midrow;\\n                // cout << \"ch to min: \" << minrow;\\n            } else {\\n                cout << 1;\\n                return true;\\n            }\\n            // cout << i << \\'\\\\n\\';\\n            i++;\\n        }\\n        return binary_search(matrix[minrow].begin(), matrix[minrow].end(), target);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "jslominsky",
                        "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n         int row = getRow(matrix, target);\\n        if(row == -1)\\n            return false;\\n        else\\n        {\\n            boolean  result = binarySearch(matrix[row],target);\\n            return result;\\n        }\\n        \\n    \\n    \\n        \\n    }\\n    \\n static int getRow(int [][] matrix, int target)\\n    {\\n        int top = 0;\\n        int middle = matrix.length/2;\\n        int bottom = matrix.length;\\n        boolean rowFound = false;\\n        int row = -1;\\n        int inspectRight = matrix[middle][matrix[middle].length-1];\\n        int inspectLeft = matrix[middle][0];\\n        int maxIterations = (int)Math.ceil(Math.log(bottom));\\n        int i = 0;\\n        while(rowFound == false )\\n        {\\n            inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n           i++;\\n            if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                rowFound = true;\\n                row = middle;\\n            }\\n            else\\n            {\\n               \\n                if(target < inspectRight)\\n                {\\n                    bottom = middle;\\n                    middle = (top+bottom)/2;\\n                }\\n                else\\n                {\\n                    top = middle;\\n                    middle = (top+bottom)/2;\\n                    \\n                }\\n            }\\n            \\n            if(top == middle && top == bottom -1)\\n            {\\n                rowFound = true;\\n            }\\n            else if(top == middle && top == bottom)\\n            {\\n                rowFound = true;\\n            }\\n            \\n            \\n        }\\n     \\n      inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n         if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                \\n                row = middle;\\n            }\\n         \\n        return row;\\n }\\n        \\n    \\n    static boolean binarySearch(int v[], int To_Find)\\n    {\\n    int lo = 0, hi = v.length - 1;\\n    // This below check covers all cases , so need to check\\n    // for mid=lo-(hi-lo)/2\\n    while (hi - lo > 1) {\\n        int mid = (hi + lo) / 2;\\n        if (v[mid] < To_Find) {\\n            lo = mid + 1;\\n        }\\n        else {\\n            hi = mid;\\n        }\\n    }\\n    if (v[lo] == To_Find) {\\n      return true;\\n    }\\n    else if (v[hi] == To_Find) {\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n}\\n    \\n    \\n    \\n    \\n}"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0 , col = matrix[0].length-1;\\n        while(row < matrix.length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            }else if(matrix[row][col] < target){\\n                row ++;\\n            }else{\\n                col--;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "aditrout29",
                        "content": "class Solution {\npublic:\n    bool searchRow(vector<vector<int>>& matrix, int target,int s, int e,int row{\n           while(e>=s){\n            if(matrix[row][e]==target){\n                return true;\n            }\n            --e;\n        }  \n         return false;\n    }\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n       bool flag=false;\n       int row=matrix.size();\n       int col=matrix[0].size();\n\n       int prevRow=0;\n       int nextRow=1;\n\n        if(target<=matrix[prevRow][col-1]){\n           return searchRow(matrix,target,0,col-1,prevRow);\n        }\n\n        while(nextRow<row){\n            if(target>matrix[prevRow][col-1] && target<=matrix[nextRow][col-1]){\n                return searchRow(matrix,target,0,col-1,nextRow);\n            }else if(target>matrix[prevRow][col-1] && target>matrix[nextRow][col-1]){\n                ++prevRow;\n                ++nextRow;\n            }\n        }\n    return false;\n    }\n};"
                    },
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "TIME COMPLEXITY   O(nlogm);;\\n\\n public boolean searchMatrix(int[][] matrix, int target) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        for(int i=0; i<n; i++){\\n           if(matrix[i][0]<=target && target<=matrix[i][m-1]){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j]==target)\\n                return true;\\n            }\\n            return false;\\n           }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "only2sachd",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n        int r = binarySearchRoeSelect(matrix,target);\\n        boolean isFound = binarySearch(matrix,r,target);\\n        return isFound;\\n        \\n    }\\n\\n    public static int binarySearchRoeSelect(int[][] matrix, int target){\\n        int low = 0;\\n        int high = matrix.length-1;\\n        int lc = matrix[0].length-1;\\n\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n\\n            if(matrix[mid][0] <= target && matrix[mid][lc] >= target){\\n                return mid;\\n            }\\n            else if(matrix[mid][0] < target){\\n                low = mid+1;\\n            }\\n            else if(matrix[mid][0] > target){\\n                high = mid-1;\\n            }\\n\\n        }\\n        return -1;\\n\\n\\n\\n    }\\n\\n    public static boolean binarySearch(int[][] matrix, int r, int target){\\n        int left =0;\\n        int right = matrix[0].length-1;\\n\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n\\n            if(matrix[r][mid] == target){\\n                return true;\\n            }\\n            else if(matrix[r][mid] > target){\\n                right = mid -1;\\n            }\\n            else{\\n                left = mid +1;\\n            }\\n\\n      \\n\\n        }\\n        return false;\\n\\n    }\\n}\\n\\nWhat is the problem with my solution ?\\n\\nits giving error in  \" if(matrix[r][mid] == target) \" in these line"
                    },
                    {
                        "username": "sakshi1jain",
                        "content": "good"
                    },
                    {
                        "username": "zephyr8",
                        "content": "Given the matrix properties - we can flatten out the matrix as if it were an array and do a binary search. TC would be O(logmn)\nI wonder if this is better than O(m+n) approach to move left or down from top right corner ( move up or right if we start at bottom left corner). \nComplexity wise -  logarithmic TC is better, but intuitively something seems off. Can some one help here?"
                    }
                ]
            },
            {
                "id": 1682626,
                "content": [
                    {
                        "username": "S_A_D_I_K",
                        "content": "leetcode needs more congruence on results, they seem to use different testcases for each submission\\n\\na O(log(m+n)) solution took 85 ms and O(m+n) solution took 42 ms\\n ```class Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        if target>matrix[R][C] or target<matrix[0][0]:\\n            return False\\n        r,c = 0,C\\n        while 0<=r<=R and 0<=c<=C:\\n            if target == matrix[r][c]:\\n                return True\\n            elif target > matrix[r][c]:\\n                r += 1\\n            elif target < matrix[r][c]:\\n                c -= 1\\n        return False\\n        \\nthis is a O(m+n) solution , which performed better than the below code\\n    ```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix or not matrix[0]:\\n            return False\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        \\n        if target > matrix[R][C] or target < matrix[0][0]:\\n            return False\\n        top,bottom = 0,R\\n        while top<=bottom:\\n            middle = (top+bottom)//2\\n            if target < matrix[middle][0]:\\n                bottom = middle-1\\n            elif target > matrix[middle][-1]:\\n                top = middle+1\\n            else:\\n                break\\n \\n        l,r = 0,C\\n        while l<=r:\\n            m = (l+r)//2\\n            if target == matrix[middle][m]:\\n                return True\\n            elif target < matrix[middle][m]:\\n                r = m - 1\\n            elif target > matrix[middle][m]:\\n                l = m + 1\\n        return False\\n \\n"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the eaisest one in which linear traversing of each element if it found the element return true otherwise return false\\n"
                    },
                    {
                        "username": "xandergardner",
                        "content": "Leetcode C++ Compiler Broken?\\n\\nThis code works locally but infinitely loops when run on leetcode:\\n\\n ```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int minrow = 0;\\n        int maxrow = matrix.size()-1;\\n        int midrow;\\n        int i = 0;\\n        while (minrow < maxrow) {\\n            // cout << minrow << \" \";\\n            // cout << maxrow << \" \";\\n            midrow = (minrow + maxrow) / 2;\\n            if (target < matrix[midrow][0]) {\\n                maxrow = midrow-1;\\n                // cout << \"ch to max: \" << maxrow;\\n            } else if (target > matrix[midrow][0]) {\\n                minrow = midrow;\\n                // cout << \"ch to min: \" << minrow;\\n            } else {\\n                cout << 1;\\n                return true;\\n            }\\n            // cout << i << \\'\\\\n\\';\\n            i++;\\n        }\\n        return binary_search(matrix[minrow].begin(), matrix[minrow].end(), target);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "jslominsky",
                        "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n         int row = getRow(matrix, target);\\n        if(row == -1)\\n            return false;\\n        else\\n        {\\n            boolean  result = binarySearch(matrix[row],target);\\n            return result;\\n        }\\n        \\n    \\n    \\n        \\n    }\\n    \\n static int getRow(int [][] matrix, int target)\\n    {\\n        int top = 0;\\n        int middle = matrix.length/2;\\n        int bottom = matrix.length;\\n        boolean rowFound = false;\\n        int row = -1;\\n        int inspectRight = matrix[middle][matrix[middle].length-1];\\n        int inspectLeft = matrix[middle][0];\\n        int maxIterations = (int)Math.ceil(Math.log(bottom));\\n        int i = 0;\\n        while(rowFound == false )\\n        {\\n            inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n           i++;\\n            if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                rowFound = true;\\n                row = middle;\\n            }\\n            else\\n            {\\n               \\n                if(target < inspectRight)\\n                {\\n                    bottom = middle;\\n                    middle = (top+bottom)/2;\\n                }\\n                else\\n                {\\n                    top = middle;\\n                    middle = (top+bottom)/2;\\n                    \\n                }\\n            }\\n            \\n            if(top == middle && top == bottom -1)\\n            {\\n                rowFound = true;\\n            }\\n            else if(top == middle && top == bottom)\\n            {\\n                rowFound = true;\\n            }\\n            \\n            \\n        }\\n     \\n      inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n         if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                \\n                row = middle;\\n            }\\n         \\n        return row;\\n }\\n        \\n    \\n    static boolean binarySearch(int v[], int To_Find)\\n    {\\n    int lo = 0, hi = v.length - 1;\\n    // This below check covers all cases , so need to check\\n    // for mid=lo-(hi-lo)/2\\n    while (hi - lo > 1) {\\n        int mid = (hi + lo) / 2;\\n        if (v[mid] < To_Find) {\\n            lo = mid + 1;\\n        }\\n        else {\\n            hi = mid;\\n        }\\n    }\\n    if (v[lo] == To_Find) {\\n      return true;\\n    }\\n    else if (v[hi] == To_Find) {\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n}\\n    \\n    \\n    \\n    \\n}"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0 , col = matrix[0].length-1;\\n        while(row < matrix.length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            }else if(matrix[row][col] < target){\\n                row ++;\\n            }else{\\n                col--;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "aditrout29",
                        "content": "class Solution {\npublic:\n    bool searchRow(vector<vector<int>>& matrix, int target,int s, int e,int row{\n           while(e>=s){\n            if(matrix[row][e]==target){\n                return true;\n            }\n            --e;\n        }  \n         return false;\n    }\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n       bool flag=false;\n       int row=matrix.size();\n       int col=matrix[0].size();\n\n       int prevRow=0;\n       int nextRow=1;\n\n        if(target<=matrix[prevRow][col-1]){\n           return searchRow(matrix,target,0,col-1,prevRow);\n        }\n\n        while(nextRow<row){\n            if(target>matrix[prevRow][col-1] && target<=matrix[nextRow][col-1]){\n                return searchRow(matrix,target,0,col-1,nextRow);\n            }else if(target>matrix[prevRow][col-1] && target>matrix[nextRow][col-1]){\n                ++prevRow;\n                ++nextRow;\n            }\n        }\n    return false;\n    }\n};"
                    },
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "TIME COMPLEXITY   O(nlogm);;\\n\\n public boolean searchMatrix(int[][] matrix, int target) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        for(int i=0; i<n; i++){\\n           if(matrix[i][0]<=target && target<=matrix[i][m-1]){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j]==target)\\n                return true;\\n            }\\n            return false;\\n           }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "only2sachd",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n        int r = binarySearchRoeSelect(matrix,target);\\n        boolean isFound = binarySearch(matrix,r,target);\\n        return isFound;\\n        \\n    }\\n\\n    public static int binarySearchRoeSelect(int[][] matrix, int target){\\n        int low = 0;\\n        int high = matrix.length-1;\\n        int lc = matrix[0].length-1;\\n\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n\\n            if(matrix[mid][0] <= target && matrix[mid][lc] >= target){\\n                return mid;\\n            }\\n            else if(matrix[mid][0] < target){\\n                low = mid+1;\\n            }\\n            else if(matrix[mid][0] > target){\\n                high = mid-1;\\n            }\\n\\n        }\\n        return -1;\\n\\n\\n\\n    }\\n\\n    public static boolean binarySearch(int[][] matrix, int r, int target){\\n        int left =0;\\n        int right = matrix[0].length-1;\\n\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n\\n            if(matrix[r][mid] == target){\\n                return true;\\n            }\\n            else if(matrix[r][mid] > target){\\n                right = mid -1;\\n            }\\n            else{\\n                left = mid +1;\\n            }\\n\\n      \\n\\n        }\\n        return false;\\n\\n    }\\n}\\n\\nWhat is the problem with my solution ?\\n\\nits giving error in  \" if(matrix[r][mid] == target) \" in these line"
                    },
                    {
                        "username": "sakshi1jain",
                        "content": "good"
                    },
                    {
                        "username": "zephyr8",
                        "content": "Given the matrix properties - we can flatten out the matrix as if it were an array and do a binary search. TC would be O(logmn)\nI wonder if this is better than O(m+n) approach to move left or down from top right corner ( move up or right if we start at bottom left corner). \nComplexity wise -  logarithmic TC is better, but intuitively something seems off. Can some one help here?"
                    }
                ]
            },
            {
                "id": 1679662,
                "content": [
                    {
                        "username": "S_A_D_I_K",
                        "content": "leetcode needs more congruence on results, they seem to use different testcases for each submission\\n\\na O(log(m+n)) solution took 85 ms and O(m+n) solution took 42 ms\\n ```class Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        if target>matrix[R][C] or target<matrix[0][0]:\\n            return False\\n        r,c = 0,C\\n        while 0<=r<=R and 0<=c<=C:\\n            if target == matrix[r][c]:\\n                return True\\n            elif target > matrix[r][c]:\\n                r += 1\\n            elif target < matrix[r][c]:\\n                c -= 1\\n        return False\\n        \\nthis is a O(m+n) solution , which performed better than the below code\\n    ```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix or not matrix[0]:\\n            return False\\n        R = len(matrix)-1\\n        C = len(matrix[0])-1\\n        \\n        if target > matrix[R][C] or target < matrix[0][0]:\\n            return False\\n        top,bottom = 0,R\\n        while top<=bottom:\\n            middle = (top+bottom)//2\\n            if target < matrix[middle][0]:\\n                bottom = middle-1\\n            elif target > matrix[middle][-1]:\\n                top = middle+1\\n            else:\\n                break\\n \\n        l,r = 0,C\\n        while l<=r:\\n            m = (l+r)//2\\n            if target == matrix[middle][m]:\\n                return True\\n            elif target < matrix[middle][m]:\\n                r = m - 1\\n            elif target > matrix[middle][m]:\\n                l = m + 1\\n        return False\\n \\n"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the eaisest one in which linear traversing of each element if it found the element return true otherwise return false\\n"
                    },
                    {
                        "username": "xandergardner",
                        "content": "Leetcode C++ Compiler Broken?\\n\\nThis code works locally but infinitely loops when run on leetcode:\\n\\n ```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int minrow = 0;\\n        int maxrow = matrix.size()-1;\\n        int midrow;\\n        int i = 0;\\n        while (minrow < maxrow) {\\n            // cout << minrow << \" \";\\n            // cout << maxrow << \" \";\\n            midrow = (minrow + maxrow) / 2;\\n            if (target < matrix[midrow][0]) {\\n                maxrow = midrow-1;\\n                // cout << \"ch to max: \" << maxrow;\\n            } else if (target > matrix[midrow][0]) {\\n                minrow = midrow;\\n                // cout << \"ch to min: \" << minrow;\\n            } else {\\n                cout << 1;\\n                return true;\\n            }\\n            // cout << i << \\'\\\\n\\';\\n            i++;\\n        }\\n        return binary_search(matrix[minrow].begin(), matrix[minrow].end(), target);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "jslominsky",
                        "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n         int row = getRow(matrix, target);\\n        if(row == -1)\\n            return false;\\n        else\\n        {\\n            boolean  result = binarySearch(matrix[row],target);\\n            return result;\\n        }\\n        \\n    \\n    \\n        \\n    }\\n    \\n static int getRow(int [][] matrix, int target)\\n    {\\n        int top = 0;\\n        int middle = matrix.length/2;\\n        int bottom = matrix.length;\\n        boolean rowFound = false;\\n        int row = -1;\\n        int inspectRight = matrix[middle][matrix[middle].length-1];\\n        int inspectLeft = matrix[middle][0];\\n        int maxIterations = (int)Math.ceil(Math.log(bottom));\\n        int i = 0;\\n        while(rowFound == false )\\n        {\\n            inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n           i++;\\n            if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                rowFound = true;\\n                row = middle;\\n            }\\n            else\\n            {\\n               \\n                if(target < inspectRight)\\n                {\\n                    bottom = middle;\\n                    middle = (top+bottom)/2;\\n                }\\n                else\\n                {\\n                    top = middle;\\n                    middle = (top+bottom)/2;\\n                    \\n                }\\n            }\\n            \\n            if(top == middle && top == bottom -1)\\n            {\\n                rowFound = true;\\n            }\\n            else if(top == middle && top == bottom)\\n            {\\n                rowFound = true;\\n            }\\n            \\n            \\n        }\\n     \\n      inspectRight = matrix[middle][matrix[middle].length-1];\\n            inspectLeft = matrix[middle][0];\\n         if(inspectLeft <= target && inspectRight >= target )\\n            {\\n                \\n                row = middle;\\n            }\\n         \\n        return row;\\n }\\n        \\n    \\n    static boolean binarySearch(int v[], int To_Find)\\n    {\\n    int lo = 0, hi = v.length - 1;\\n    // This below check covers all cases , so need to check\\n    // for mid=lo-(hi-lo)/2\\n    while (hi - lo > 1) {\\n        int mid = (hi + lo) / 2;\\n        if (v[mid] < To_Find) {\\n            lo = mid + 1;\\n        }\\n        else {\\n            hi = mid;\\n        }\\n    }\\n    if (v[lo] == To_Find) {\\n      return true;\\n    }\\n    else if (v[hi] == To_Find) {\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n}\\n    \\n    \\n    \\n    \\n}"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0 , col = matrix[0].length-1;\\n        while(row < matrix.length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            }else if(matrix[row][col] < target){\\n                row ++;\\n            }else{\\n                col--;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "aditrout29",
                        "content": "class Solution {\npublic:\n    bool searchRow(vector<vector<int>>& matrix, int target,int s, int e,int row{\n           while(e>=s){\n            if(matrix[row][e]==target){\n                return true;\n            }\n            --e;\n        }  \n         return false;\n    }\n\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n       bool flag=false;\n       int row=matrix.size();\n       int col=matrix[0].size();\n\n       int prevRow=0;\n       int nextRow=1;\n\n        if(target<=matrix[prevRow][col-1]){\n           return searchRow(matrix,target,0,col-1,prevRow);\n        }\n\n        while(nextRow<row){\n            if(target>matrix[prevRow][col-1] && target<=matrix[nextRow][col-1]){\n                return searchRow(matrix,target,0,col-1,nextRow);\n            }else if(target>matrix[prevRow][col-1] && target>matrix[nextRow][col-1]){\n                ++prevRow;\n                ++nextRow;\n            }\n        }\n    return false;\n    }\n};"
                    },
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "TIME COMPLEXITY   O(nlogm);;\\n\\n public boolean searchMatrix(int[][] matrix, int target) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        for(int i=0; i<n; i++){\\n           if(matrix[i][0]<=target && target<=matrix[i][m-1]){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j]==target)\\n                return true;\\n            }\\n            return false;\\n           }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "only2sachd",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n        int r = binarySearchRoeSelect(matrix,target);\\n        boolean isFound = binarySearch(matrix,r,target);\\n        return isFound;\\n        \\n    }\\n\\n    public static int binarySearchRoeSelect(int[][] matrix, int target){\\n        int low = 0;\\n        int high = matrix.length-1;\\n        int lc = matrix[0].length-1;\\n\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n\\n            if(matrix[mid][0] <= target && matrix[mid][lc] >= target){\\n                return mid;\\n            }\\n            else if(matrix[mid][0] < target){\\n                low = mid+1;\\n            }\\n            else if(matrix[mid][0] > target){\\n                high = mid-1;\\n            }\\n\\n        }\\n        return -1;\\n\\n\\n\\n    }\\n\\n    public static boolean binarySearch(int[][] matrix, int r, int target){\\n        int left =0;\\n        int right = matrix[0].length-1;\\n\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n\\n            if(matrix[r][mid] == target){\\n                return true;\\n            }\\n            else if(matrix[r][mid] > target){\\n                right = mid -1;\\n            }\\n            else{\\n                left = mid +1;\\n            }\\n\\n      \\n\\n        }\\n        return false;\\n\\n    }\\n}\\n\\nWhat is the problem with my solution ?\\n\\nits giving error in  \" if(matrix[r][mid] == target) \" in these line"
                    },
                    {
                        "username": "sakshi1jain",
                        "content": "good"
                    },
                    {
                        "username": "zephyr8",
                        "content": "Given the matrix properties - we can flatten out the matrix as if it were an array and do a binary search. TC would be O(logmn)\nI wonder if this is better than O(m+n) approach to move left or down from top right corner ( move up or right if we start at bottom left corner). \nComplexity wise -  logarithmic TC is better, but intuitively something seems off. Can some one help here?"
                    }
                ]
            }
        ]
    }
]