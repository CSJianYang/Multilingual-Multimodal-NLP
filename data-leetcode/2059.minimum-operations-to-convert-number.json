[
    {
        "title": "Minimum Operations to Convert Number",
        "question_content": "You are given a 0-indexed integer array nums containing distinct numbers, an integer start, and an integer goal. There is an integer x that is initially set to start, and you want to perform operations on x such that it is converted to goal. You can perform the following operation repeatedly on the number x:\nIf 0 <= x <= 1000, then for any index i in the array (0 <= i < nums.length), you can set x to any of the following:\n\n\tx + nums[i]\n\tx - nums[i]\n\tx ^ nums[i] (bitwise-XOR)\n\nNote that you can use each nums[i] any number of times in any order. Operations that set x to be out of the range 0 <= x <= 1000 are valid, but no more operations can be done afterward.\nReturn the minimum number of operations needed to convert x = start into goal, and -1 if it is not possible.\n&nbsp;\nExample 1:\n\nInput: nums = [2,4,12], start = 2, goal = 12\nOutput: 2\nExplanation: We can go from 2 &rarr; 14 &rarr; 12 with the following 2 operations.\n- 2 + 12 = 14\n- 14 - 2 = 12\n\nExample 2:\n\nInput: nums = [3,5,7], start = 0, goal = -4\nOutput: 2\nExplanation: We can go from 0 &rarr; 3 &rarr; -4 with the following 2 operations. \n- 0 + 3 = 3\n- 3 - 7 = -4\nNote that the last operation sets x out of the range 0 <= x <= 1000, which is valid.\n\nExample 3:\n\nInput: nums = [2,8,16], start = 0, goal = 1\nOutput: -1\nExplanation: There is no way to convert 0 into 1.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1000\n\t-109 <= nums[i], goal <= 109\n\t0 <= start <= 1000\n\tstart != goal\n\tAll the integers in nums are distinct.",
        "solutions": [
            {
                "id": 1549960,
                "title": "c-bfs-clean-code",
                "content": "1. **Just do simple BFS and maintain a visited array to keep track of numbers that we have seen already.**\\n2. Here keypoint is numbers can be from 0 to 1000 so make visited array and once we have seen that number we don\\'t have to include that number again.\\n\\n**Time Complexity**:-```O(n*m)``` where n is size of the array and m is the range.\\n```\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        vector<bool>visited(1001,false);\\n        int ans=0;\\n        queue<int>q;\\n        q.push(start);\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                int node=q.front();q.pop();\\n                if(node==goal)\\n                    return ans;\\n                if(node>1000 || node<0 || visited[node])\\n                    continue;\\n                visited[node]=true;\\n                for(int i=0;i<nums.size();i++){\\n                    int a=node+nums[i],b=node-nums[i],c=node^nums[i];\\n                    for(auto j :{a,b,c})\\n                            q.push(j);\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```O(n*m)```\n```\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        vector<bool>visited(1001,false);\\n        int ans=0;\\n        queue<int>q;\\n        q.push(start);\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                int node=q.front();q.pop();\\n                if(node==goal)\\n                    return ans;\\n                if(node>1000 || node<0 || visited[node])\\n                    continue;\\n                visited[node]=true;\\n                for(int i=0;i<nums.size();i++){\\n                    int a=node+nums[i],b=node-nums[i],c=node^nums[i];\\n                    for(auto j :{a,b,c})\\n                            q.push(j);\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1550392,
                "title": "c-bfs-best-explanation",
                "content": "**How to get the intuition of BFS?**\\nSo, Bascially we have to reach goal from start with certain operations(as many you want) allowed.The operations allowed are + , -, ^.\\nSo, let\\'s say we want to reach goal from start, then we might be using one or more of the given operations. **Right?**\\nLet\\'s say we used these operations on start and we get :\\n```\\nstart + nums[i] = a;\\nstart - nums[i] = b;\\nstart ^ nums[i] = c;\\n```\\n\\n\\nNow, we have 2 conditions: \\n1. Either of a, b ,c  is equal to goal then we reached our destination\\n2. a, b,c is not equal to goal. So in this case we might be doing the operations again and again on a , b, c till we reach goal. Now, someone would say- In this way we might fall in an infinite loop and ends up inTLE.  So, to avoid that we are using visited array to mark which numbers we already got using these operations. So, if we again get a visited number we won\\'t be performing operations for that number.\\n\\nSo, this is kind of **BFS** , as we are getting new numbers level by level( after performing operations on older numbers that we got).\\nAlso, this is given in question that whenever the value of number(start) becomes larger than 1000 or smaller than 0 then we can\\'t do further operations. So, whenever we get the value >1000 or value<0 then we wouldn\\'t do further operation on that number and we will proceed with other numbers in our queue.\\nAnd at anytime, we get the value in queue equals to goal then we will return the answer.\\n\\n**Below is the code in C++**\\n```\\nint minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n=nums.size();\\n        queue<int>qq;\\n        vector<bool>visited(1001,false);\\n        qq.push(start);\\n        int ans=0;\\n        while(!qq.empty()){\\n            int size=qq.size();\\n            while(size--){\\n                int front_element=qq.front();\\n                qq.pop();\\n                if(front_element==goal)\\n                    return ans;\\n                if(front_element>1000 or front_element<0 or visited[front_element]==true)\\n                    continue;\\n                visited[front_element]=true;\\n                for(int i=0;i<nums.size();i++){\\n                    int first=front_element+nums[i];\\n                    int second=front_element-nums[i];\\n                    int third=front_element^nums[i];\\n                    qq.push(first);\\n                    qq.push(second);\\n                    qq.push(third);\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1; // not possible to reach goal\\n    }\\n```\\n**Time Complexity : O(n*k)** ; where n is size of array and k is max number of elements that can be pushed in queue. Here, k will be range that is 1001 elements -> (0 to 1000).\\n\\nHope it helps\\n\\nThank you!",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nstart + nums[i] = a;\\nstart - nums[i] = b;\\nstart ^ nums[i] = c;\\n```\n```\\nint minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n=nums.size();\\n        queue<int>qq;\\n        vector<bool>visited(1001,false);\\n        qq.push(start);\\n        int ans=0;\\n        while(!qq.empty()){\\n            int size=qq.size();\\n            while(size--){\\n                int front_element=qq.front();\\n                qq.pop();\\n                if(front_element==goal)\\n                    return ans;\\n                if(front_element>1000 or front_element<0 or visited[front_element]==true)\\n                    continue;\\n                visited[front_element]=true;\\n                for(int i=0;i<nums.size();i++){\\n                    int first=front_element+nums[i];\\n                    int second=front_element-nums[i];\\n                    int third=front_element^nums[i];\\n                    qq.push(first);\\n                    qq.push(second);\\n                    qq.push(third);\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1; // not possible to reach goal\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549956,
                "title": "bottom-up-dp",
                "content": "Somehow I could not get a top-down DP accepted. For the bottom-up one, we start from the goal, and fill the range [0, 1000] with the minimum operations to reach the goal.\\n\\nWe use queue `q` to maintain the reachable numbers for `cnt` number of operations.\\n\\nThe complexity of this solution is *O(n * m)* where *n* is the length of the `nums` array, and *m* - size of the range.\\n\\n**C++**\\n```cpp\\nint minimumOperations(vector<int>& nums, int start, int goal) {\\n    short seen[1001] = {}, cnt = 0;\\n    vector<int> q{goal};\\n    while (!q.empty()) {\\n        ++cnt;\\n        vector<int> q1;\\n        for (auto x : q)\\n            for (int n : nums)\\n                for (int xn : {x + n, x - n, x ^ n})\\n                    if (xn >= 0 && xn <= 1000 && !seen[xn]) {\\n                        if (xn == start)\\n                            return cnt;\\n                        seen[xn] = true; \\n                        q1.push_back(xn);\\n                    }\\n        swap(q, q1);\\n    }\\n    return -1;\\n}\\n```\\n**Java**\\n```java\\npublic int minimumOperations(int[] nums, int start, int goal) {\\n    boolean seen[] = new boolean[1001];\\n    List<Integer> q = Arrays.asList(goal);\\n    int cnt = 0;\\n    while(!q.isEmpty()) {\\n        ++cnt;\\n        List<Integer> q1 = new ArrayList<>();\\n        for (int x : q)\\n            for (int n : nums) {\\n                for (int xn : new int[] {x + n, x - n, x ^ n})\\n                    if (xn >= 0 && xn <= 1000 && !seen[xn]) {\\n                        if (xn == start)\\n                            return cnt;\\n                        seen[xn] = true; \\n                        q1.add(xn);\\n                    }\\n            }\\n        q = q1;\\n    }    \\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint minimumOperations(vector<int>& nums, int start, int goal) {\\n    short seen[1001] = {}, cnt = 0;\\n    vector<int> q{goal};\\n    while (!q.empty()) {\\n        ++cnt;\\n        vector<int> q1;\\n        for (auto x : q)\\n            for (int n : nums)\\n                for (int xn : {x + n, x - n, x ^ n})\\n                    if (xn >= 0 && xn <= 1000 && !seen[xn]) {\\n                        if (xn == start)\\n                            return cnt;\\n                        seen[xn] = true; \\n                        q1.push_back(xn);\\n                    }\\n        swap(q, q1);\\n    }\\n    return -1;\\n}\\n```\n```java\\npublic int minimumOperations(int[] nums, int start, int goal) {\\n    boolean seen[] = new boolean[1001];\\n    List<Integer> q = Arrays.asList(goal);\\n    int cnt = 0;\\n    while(!q.isEmpty()) {\\n        ++cnt;\\n        List<Integer> q1 = new ArrayList<>();\\n        for (int x : q)\\n            for (int n : nums) {\\n                for (int xn : new int[] {x + n, x - n, x ^ n})\\n                    if (xn >= 0 && xn <= 1000 && !seen[xn]) {\\n                        if (xn == start)\\n                            return cnt;\\n                        seen[xn] = true; \\n                        q1.add(xn);\\n                    }\\n            }\\n        q = q1;\\n    }    \\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1550007,
                "title": "python3-bfs",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/4001168494179e85482f91afbf0cd66b908544f3) for my solutions of weekly 265. \\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        ans = 0\\n        seen = {start}\\n        queue = deque([start])\\n        while queue: \\n            for _ in range(len(queue)): \\n                val = queue.popleft()\\n                if val == goal: return ans \\n                if 0 <= val <= 1000: \\n                    for x in nums: \\n                        for op in (add, sub, xor): \\n                            if op(val, x) not in seen: \\n                                seen.add(op(val, x))\\n                                queue.append(op(val, x))\\n            ans += 1\\n        return -1 \\n```\\n\\nI saw a few comments complaining TLE. But I\\'ve tried multiple submissions they are all consistently 6000-7000ms which is well within the range of AC (see the pic).\\n\\n\\n![image](https://assets.leetcode.com/users/images/6473d69e-4aa4-44ed-8a3b-28676086bb76_1635691838.9372997.png)\\n\\nAn alternative implementation using `list` runs 3500-4000ms\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        ans = 0\\n        queue = deque([start])\\n        visited = [False]*1001\\n        while queue: \\n            for _ in range(len(queue)): \\n                val = queue.popleft()\\n                if val == goal: return ans \\n                if 0 <= val <= 1000 and not visited[val]: \\n                    visited[val] = True\\n                    for x in nums: \\n                        for xx in (val+x, val-x, val^x):\\n                            queue.append(xx)\\n            ans += 1\\n        return -1 \\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        ans = 0\\n        seen = {start}\\n        queue = deque([start])\\n        while queue: \\n            for _ in range(len(queue)): \\n                val = queue.popleft()\\n                if val == goal: return ans \\n                if 0 <= val <= 1000: \\n                    for x in nums: \\n                        for op in (add, sub, xor): \\n                            if op(val, x) not in seen: \\n                                seen.add(op(val, x))\\n                                queue.append(op(val, x))\\n            ans += 1\\n        return -1 \\n```\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        ans = 0\\n        queue = deque([start])\\n        visited = [False]*1001\\n        while queue: \\n            for _ in range(len(queue)): \\n                val = queue.popleft()\\n                if val == goal: return ans \\n                if 0 <= val <= 1000 and not visited[val]: \\n                    visited[val] = True\\n                    for x in nums: \\n                        for xx in (val+x, val-x, val^x):\\n                            queue.append(xx)\\n            ans += 1\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550030,
                "title": "java-bfs-set-easy-implementation",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(start);\\n        \\n        Set<Integer> set = new HashSet<>();\\n        \\n        int res = 0;\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            \\n            for(int i = 0; i < size; i++){\\n                int val = q.poll();\\n                \\n                if(val == goal) return res;\\n                \\n                if((!(val >= 0 && val <= 1000)) || set.contains(val)){\\n                    continue;\\n                }\\n                \\n                if(!set.contains(val)) set.add(val);\\n                \\n                for(int num : nums){\\n                    q.offer(val + num);\\n                    q.offer(val - num);\\n                    q.offer(val ^ num);\\n                }\\n            }\\n            \\n            res++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(start);\\n        \\n        Set<Integer> set = new HashSet<>();\\n        \\n        int res = 0;\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            \\n            for(int i = 0; i < size; i++){\\n                int val = q.poll();\\n                \\n                if(val == goal) return res;\\n                \\n                if((!(val >= 0 && val <= 1000)) || set.contains(val)){\\n                    continue;\\n                }\\n                \\n                if(!set.contains(val)) set.add(val);\\n                \\n                for(int num : nums){\\n                    q.offer(val + num);\\n                    q.offer(val - num);\\n                    q.offer(val ^ num);\\n                }\\n            }\\n            \\n            res++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550126,
                "title": "python3-fast-bfs-100-200-ms",
                "content": "First we can start with the standard BFS solution:\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        seen = set()\\n        \\n        q = deque([(start, 0)])\\n        while q:\\n            cur, steps = q.popleft()\\n            for num in nums:\\n                for cand in (cur + num, cur - num, cur ^ num):\\n                    if cand == goal:\\n                        return steps + 1\\n                    if cand not in seen and 0 <= cand <= 1000:\\n                        q.append((cand, steps + 1))\\n                        seen.add(cand)\\n\\n        return -1\\n```\\n\\nHowever, what if we had an input like:\\n\\nnums = [1,0,1000000000,999999999,999999998,999999997,999999996,999999995]\\n\\nClearly, the large numbers should never be considered, because reaching the goal with those is only possible by operating on numbers outside of the acceptable range of [0, 1000]. Therefore, we can get a much faster solution by pruning these numbers, reducing search space on each step of BFS. \\n\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        seen = set()\\n        \\n        # If a candidate number requires the current number to be outside the range (0, 1000) to meet the goal, then filter it out. \\n        filtered_nums = []\\n        for num in nums:\\n            # outside range\\n            outside = num < 0 or num > 1000\\n            # requires number outside of [0, 1000] to reach goal with addition\\n            add_check = (goal - num < 0 or goal - num > 1000)\\n            # requires number outside of [0, 1000] to reach goal with subtraction\\n            sub_check = (goal + num < 0 or goal + num > 1000)\\n            # requires number outside of [0, 1000] to reach goal with xor \\n            xor_check = (goal ^ num > 1000 or goal ^ num < 0)\\n            \\n\\t\\t\\t# Perform all checks above, and also filter out 0\\n            if not (outside and add_check and sub_check and xor_check) and num:\\n                filtered_nums.append(num)\\n        nums = filtered_nums\\n        del filtered_nums\\n        \\n        q = deque([(start, 0)])\\n        while q:\\n            cur, steps = q.popleft()\\n            for num in nums:\\n                for cand in (cur + num, cur - num, cur ^ num):\\n                    if cand == goal:\\n                        return steps + 1\\n                    if cand not in seen and 0 <= cand <= 1000:\\n                        q.append((cand, steps + 1))\\n                        seen.add(cand)\\n\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        seen = set()\\n        \\n        q = deque([(start, 0)])\\n        while q:\\n            cur, steps = q.popleft()\\n            for num in nums:\\n                for cand in (cur + num, cur - num, cur ^ num):\\n                    if cand == goal:\\n                        return steps + 1\\n                    if cand not in seen and 0 <= cand <= 1000:\\n                        q.append((cand, steps + 1))\\n                        seen.add(cand)\\n\\n        return -1\\n```\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        seen = set()\\n        \\n        # If a candidate number requires the current number to be outside the range (0, 1000) to meet the goal, then filter it out. \\n        filtered_nums = []\\n        for num in nums:\\n            # outside range\\n            outside = num < 0 or num > 1000\\n            # requires number outside of [0, 1000] to reach goal with addition\\n            add_check = (goal - num < 0 or goal - num > 1000)\\n            # requires number outside of [0, 1000] to reach goal with subtraction\\n            sub_check = (goal + num < 0 or goal + num > 1000)\\n            # requires number outside of [0, 1000] to reach goal with xor \\n            xor_check = (goal ^ num > 1000 or goal ^ num < 0)\\n            \\n\\t\\t\\t# Perform all checks above, and also filter out 0\\n            if not (outside and add_check and sub_check and xor_check) and num:\\n                filtered_nums.append(num)\\n        nums = filtered_nums\\n        del filtered_nums\\n        \\n        q = deque([(start, 0)])\\n        while q:\\n            cur, steps = q.popleft()\\n            for num in nums:\\n                for cand in (cur + num, cur - num, cur ^ num):\\n                    if cand == goal:\\n                        return steps + 1\\n                    if cand not in seen and 0 <= cand <= 1000:\\n                        q.append((cand, steps + 1))\\n                        seen.add(cand)\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1559142,
                "title": "python-3-bfs-with-a-queue",
                "content": "```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def minimumOperations(self, nums, start: int, goal: int) -> int:\\n        \"\"\"\\n        Given an array of integers (nums), a start value (start),\\n        and a target value (goal), this program uses breadth-\\n        first search (BFS) with the help of a queue to determine\\n        the minimum number of operations needed to convert start\\n        to goal using nums and the add, subtract, xor operations.\\n        If it is not possible to reach goal, the program will\\n        return -1.\\n\\n        :param nums: array of integers\\n        :type nums: list[int]\\n        :param start: start value\\n        :type start: int\\n        :param goal: target value\\n        :type goal: int\\n        :return: minimum operations needed to convert start\\n                 to goal, or -1 if conversion is not possible\\n        :rtype: int\\n        \"\"\"\\n        \\n        \"\"\"\\n        Initialize:\\n        - queue will contain entries with the following:\\n          - a value that will be converted using nums and the\\n            operations in this problem.\\n          - number of operations that it took to get to this\\n            value.\\n        - visited will contain previously converted values. It\\n          is used to prevent redundant conversion of the same\\n          values.\\n        \"\"\"\\n        queue = deque()\\n        visited = set()\\n        \\n        \"\"\"\\n        Breadth-First Search (BFS):\\n        - Begin with the start value (start).\\n        - Continue BFS while there is at least one entry in the\\n          queue or until the target value (goal) is reached.\\n        - If the queue becomes empty without goal being reached,\\n          return -1.\\n        \"\"\"\\n        queue.append((start, 0))\\n        visited.add(start)\\n        while queue:\\n            x, ops = queue.popleft()\\n            for num in nums:\\n                for next_x in (x + num, x - num, x ^ num):\\n                    if next_x == goal:\\n                        return ops + 1\\n                    if 0 <= next_x <= 1000 and next_x not in visited:\\n                        visited.add(next_x)\\n                        queue.append((next_x, ops + 1))\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def minimumOperations(self, nums, start: int, goal: int) -> int:\\n        \"\"\"\\n        Given an array of integers (nums), a start value (start),\\n        and a target value (goal), this program uses breadth-\\n        first search (BFS) with the help of a queue to determine\\n        the minimum number of operations needed to convert start\\n        to goal using nums and the add, subtract, xor operations.\\n        If it is not possible to reach goal, the program will\\n        return -1.\\n\\n        :param nums: array of integers\\n        :type nums: list[int]\\n        :param start: start value\\n        :type start: int\\n        :param goal: target value\\n        :type goal: int\\n        :return: minimum operations needed to convert start\\n                 to goal, or -1 if conversion is not possible\\n        :rtype: int\\n        \"\"\"\\n        \\n        \"\"\"\\n        Initialize:\\n        - queue will contain entries with the following:\\n          - a value that will be converted using nums and the\\n            operations in this problem.\\n          - number of operations that it took to get to this\\n            value.\\n        - visited will contain previously converted values. It\\n          is used to prevent redundant conversion of the same\\n          values.\\n        \"\"\"\\n        queue = deque()\\n        visited = set()\\n        \\n        \"\"\"\\n        Breadth-First Search (BFS):\\n        - Begin with the start value (start).\\n        - Continue BFS while there is at least one entry in the\\n          queue or until the target value (goal) is reached.\\n        - If the queue becomes empty without goal being reached,\\n          return -1.\\n        \"\"\"\\n        queue.append((start, 0))\\n        visited.add(start)\\n        while queue:\\n            x, ops = queue.popleft()\\n            for num in nums:\\n                for next_x in (x + num, x - num, x ^ num):\\n                    if next_x == goal:\\n                        return ops + 1\\n                    if 0 <= next_x <= 1000 and next_x not in visited:\\n                        visited.add(next_x)\\n                        queue.append((next_x, ops + 1))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556197,
                "title": "c-bfs-self-explainatory-clean-code",
                "content": "```\\nint minimumOperations(vector<int>& nums, int start, int goal) {\\n        unordered_map <int,int> visited; // to check which node i had visited\\n        queue <pair<int,int>> q;  // queue of pair which stores the node and the step size\\n        q.push({start,0});\\n        visited[start] = 1;\\n        while(!q.empty()){\\n            pair<int,int> temp = q.front();\\n            q.pop();\\n            \\n            int ele = temp.first;\\n            int count = temp.second;\\n            \\n            for(auto num:nums){\\n                int add = ele+num,sub = ele-num,xr = ele^num;\\n                if(add == goal || sub == goal || xr==goal) \\n                    return count+1;\\n                \\n                if(add>=0 && add<=1000 && visited[add]==0){\\n                    q.push({add,count+1});\\n                    visited[add]=1;\\n                }\\n                if(sub>=0 && sub<=1000 && visited[sub]==0){\\n                    q.push({sub,count+1});\\n                    visited[sub] = 1;\\n                }\\n                if(xr>=0 && xr<=1000 && visited[xr]==0){\\n                    q.push({xr,count+1});\\n                    visited[xr] = 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n***PS: Upvote if it helps***",
                "solutionTags": [],
                "code": "```\\nint minimumOperations(vector<int>& nums, int start, int goal) {\\n        unordered_map <int,int> visited; // to check which node i had visited\\n        queue <pair<int,int>> q;  // queue of pair which stores the node and the step size\\n        q.push({start,0});\\n        visited[start] = 1;\\n        while(!q.empty()){\\n            pair<int,int> temp = q.front();\\n            q.pop();\\n            \\n            int ele = temp.first;\\n            int count = temp.second;\\n            \\n            for(auto num:nums){\\n                int add = ele+num,sub = ele-num,xr = ele^num;\\n                if(add == goal || sub == goal || xr==goal) \\n                    return count+1;\\n                \\n                if(add>=0 && add<=1000 && visited[add]==0){\\n                    q.push({add,count+1});\\n                    visited[add]=1;\\n                }\\n                if(sub>=0 && sub<=1000 && visited[sub]==0){\\n                    q.push({sub,count+1});\\n                    visited[sub] = 1;\\n                }\\n                if(xr>=0 && xr<=1000 && visited[xr]==0){\\n                    q.push({xr,count+1});\\n                    visited[xr] = 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1550092,
                "title": "why-does-this-recursive-solution-won-t-work-please-help",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        operations_counts = []\\n        seen = set()\\n        self.recursive(nums, start, goal, operations_counts, 0, seen)\\n        print(operations_counts)\\n        return min(operations_counts) if len(operations_counts) > 0 else -1\\n    \\n    def recursive(self, nums, x, goal, operations_counts, currOp, seen):\\n        if x == goal:\\n            operations_counts.append(currOp)\\n            return \\n        if x in seen: return\\n        if x >= 0 and x <= 1000:\\n            seen.add(x)\\n            for num in nums:\\n                self.recursive(nums, x - num, goal, operations_counts, currOp+1, seen)\\n                self.recursive(nums, x + num, goal, operations_counts, currOp+1, seen)   \\n                self.recursive(nums, x ^ num, goal, operations_counts, currOp+1, seen)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        operations_counts = []\\n        seen = set()\\n        self.recursive(nums, start, goal, operations_counts, 0, seen)\\n        print(operations_counts)\\n        return min(operations_counts) if len(operations_counts) > 0 else -1\\n    \\n    def recursive(self, nums, x, goal, operations_counts, currOp, seen):\\n        if x == goal:\\n            operations_counts.append(currOp)\\n            return \\n        if x in seen: return\\n        if x >= 0 and x <= 1000:\\n            seen.add(x)\\n            for num in nums:\\n                self.recursive(nums, x - num, goal, operations_counts, currOp+1, seen)\\n                self.recursive(nums, x + num, goal, operations_counts, currOp+1, seen)   \\n                self.recursive(nums, x ^ num, goal, operations_counts, currOp+1, seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549954,
                "title": "java-bfs-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        if (nums == null || nums.length == 0) {\\n            return -1;\\n        }\\n        \\n        Set<Integer> seen = new HashSet<>();\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(start);\\n        int steps = 0;\\n        \\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            steps++;\\n            for (int k = 0; k < size; k++) {\\n                int val = q.poll();\\n                \\n                if (val == goal) {\\n                    return steps;\\n                }\\n                \\n                if (seen.contains(val)) {\\n                    continue;\\n                }\\n                \\n                seen.add(val);\\n                \\n                for (int i = 0; i < nums.length; i++) {\\n                    int add = val + nums[i];\\n                    int subtract = val - nums[i];\\n                    int xor = val ^ nums[i];\\n                    \\n                    // If the goal is found in this step, no need to add to the queue and return the steps taken\\n                    if (add == goal || subtract == goal || xor == goal) {\\n                        return steps;\\n                    }\\n                    \\n                    // Add the next step to the queue only if x satifies the condition 0 <= x <= 1000\\n                    // This plus the seen Set ensures that the queue gets drained at some point\\n                    if (add >= 0 && add <= 1000 && !seen.contains(add)) {\\n                        q.offer(add);\\n                    }\\n                    \\n                    if (subtract >= 0 && subtract <= 1000 && !seen.contains(subtract)) {\\n                        q.offer(subtract);\\n                    }\\n                    \\n                    if (xor >= 0 && xor <= 1000 && !seen.contains(xor)) {\\n                        q.offer(xor);\\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        if (nums == null || nums.length == 0) {\\n            return -1;\\n        }\\n        \\n        Set<Integer> seen = new HashSet<>();\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(start);\\n        int steps = 0;\\n        \\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            steps++;\\n            for (int k = 0; k < size; k++) {\\n                int val = q.poll();\\n                \\n                if (val == goal) {\\n                    return steps;\\n                }\\n                \\n                if (seen.contains(val)) {\\n                    continue;\\n                }\\n                \\n                seen.add(val);\\n                \\n                for (int i = 0; i < nums.length; i++) {\\n                    int add = val + nums[i];\\n                    int subtract = val - nums[i];\\n                    int xor = val ^ nums[i];\\n                    \\n                    // If the goal is found in this step, no need to add to the queue and return the steps taken\\n                    if (add == goal || subtract == goal || xor == goal) {\\n                        return steps;\\n                    }\\n                    \\n                    // Add the next step to the queue only if x satifies the condition 0 <= x <= 1000\\n                    // This plus the seen Set ensures that the queue gets drained at some point\\n                    if (add >= 0 && add <= 1000 && !seen.contains(add)) {\\n                        q.offer(add);\\n                    }\\n                    \\n                    if (subtract >= 0 && subtract <= 1000 && !seen.contains(subtract)) {\\n                        q.offer(subtract);\\n                    }\\n                    \\n                    if (xor >= 0 && xor <= 1000 && !seen.contains(xor)) {\\n                        q.offer(xor);\\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551110,
                "title": "bfs-approach-well-coded-easy-to-understand",
                "content": "## IDEA :\\n*Go through all the possibilities. \\nwe are storing each possibility in seen so Maximum space required is 1000.*\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        if start==goal:\\n            return 0\\n        \\n        q = [(start,0)]\\n        seen = {start}\\n        while q:\\n            n,s = q.pop(0)\\n            for num in nums:\\n                for cand in [n+num,n-num,n^num]:\\n                    if cand==goal:\\n                        return s+1\\n                    if 0<=cand<=1000 and cand not in seen:\\n                        seen.add(cand)\\n                        q.append((cand,s+1))\\n        \\n        return -1\\n\\n**Thanks and Upvote if you got any help and like the Idea !!\\uD83E\\uDD1E**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "class Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        if start==goal:\\n            return 0\\n        \\n        q = [(start,0)]\\n        seen = {start}",
                "codeTag": "Java"
            },
            {
                "id": 2837283,
                "title": "python-3-10-lines-queue-and-sets-w-comments-t-m-80-92",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n\\n        queue, unseen = deque([(start, 1)]), set(range(1001))   # queue: contains still-possible candidates  \\n                                                                # unseen: takes care of already seen and negs\\n        while queue:\\n            x, ct = queue.popleft()\\n            for n in nums:\\n\\n                for cand in {x+n, x-n, x^n}:                    # <-- set here reduces redundant checks\\n                    if cand == goal: return ct                  #     (for example x, n = 3, 0)\\n\\n                    if cand in unseen:                          \\n                        queue.append((cand, ct + 1))\\n                        unseen.remove(cand)\\n                    \\n        return -1\\n```\\n[https://leetcode.com/submissions/detail/847633707/](http://)\\n\\n\\n\\n\\n\\n\\nI could be wrong, but I think it\\'s *O*(*N*)/*O*(*N*), both because of `unseen`. The number of iterations is less than  N x 3 x 1001.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n\\n        queue, unseen = deque([(start, 1)]), set(range(1001))   # queue: contains still-possible candidates  \\n                                                                # unseen: takes care of already seen and negs\\n        while queue:\\n            x, ct = queue.popleft()\\n            for n in nums:\\n\\n                for cand in {x+n, x-n, x^n}:                    # <-- set here reduces redundant checks\\n                    if cand == goal: return ct                  #     (for example x, n = 3, 0)\\n\\n                    if cand in unseen:                          \\n                        queue.append((cand, ct + 1))\\n                        unseen.remove(cand)\\n                    \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554941,
                "title": "modified-bfs-c",
                "content": "There can be 3 options for each member of the array so , we just push all the possible options into the \\nqueue and rest is normal BFS .\\nPlease do comment if you dont understand any part .\\n\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        \\n         vector<bool > vis(1001 , 0) ;\\n        \\n         queue<int > q ;\\n         q.push(start) ;\\n         int cnt = 0;\\n        \\n        \\n         while(!q.empty())\\n         {\\n             int sz = q.size() ;\\n             \\n             while(sz--)\\n             {\\n                 int top = q.front(); \\n                 q.pop() ;\\n                 \\n                 if(top == goal) return cnt ;\\n                 \\n                 if(top<0 || top>1000 || vis[top]) continue ;\\n                 \\n                 vis[top] = 1 ;\\n                 \\n                 for(auto x: nums)\\n                 {\\n                     q.push(top+x);\\n                     q.push(top-x);\\n                     q.push(top^x);\\n\\n                 }\\n             }\\n             \\n             cnt++;\\n         }\\n        \\n        return -1 ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        \\n         vector<bool > vis(1001 , 0) ;\\n        \\n         queue<int > q ;\\n         q.push(start) ;\\n         int cnt = 0;\\n        \\n        \\n         while(!q.empty())\\n         {\\n             int sz = q.size() ;\\n             \\n             while(sz--)\\n             {\\n                 int top = q.front(); \\n                 q.pop() ;\\n                 \\n                 if(top == goal) return cnt ;\\n                 \\n                 if(top<0 || top>1000 || vis[top]) continue ;\\n                 \\n                 vis[top] = 1 ;\\n                 \\n                 for(auto x: nums)\\n                 {\\n                     q.push(top+x);\\n                     q.push(top-x);\\n                     q.push(top^x);\\n\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 1549955,
                "title": "py3-simple-bfs",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        seen = set()\\n        que = deque([(start, 0)])\\n        \\n        while que:\\n            item, cnt = que.popleft()\\n            if item == goal:\\n                return cnt\\n            if item in seen:\\n                continue\\n            if item >= 0 and item <= 1000:\\n                for n in nums:\\n                    que.append((item + n, cnt + 1))\\n                    que.append((item - n, cnt + 1))\\n                    que.append((item ^ n, cnt + 1))\\n            seen.add(item)\\n        \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        seen = set()\\n        que = deque([(start, 0)])\\n        \\n        while que:\\n            item, cnt = que.popleft()\\n            if item == goal:\\n                return cnt\\n            if item in seen:\\n                continue\\n            if item >= 0 and item <= 1000:\\n                for n in nums:\\n                    que.append((item + n, cnt + 1))\\n                    que.append((item - n, cnt + 1))\\n                    que.append((item ^ n, cnt + 1))\\n            seen.add(item)\\n        \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211975,
                "title": "python-3-bfs-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        q = collections.deque([(start, 0)])\\n        visited = {start}\\n        \\n        while q:\\n            x, count = q.popleft()\\n            count += 1\\n            for num in nums:\\n                for newX in (x + num, x - num, x ^ num):\\n                    if newX == goal:\\n                        return count\\n                    if newX < 0 or 1000 < newX or newX in visited:\\n                        continue\\n                    visited.add(newX)\\n                    q.append((newX, count))\\n        \\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        q = collections.deque([(start, 0)])\\n        visited = {start}",
                "codeTag": "Java"
            },
            {
                "id": 2121320,
                "title": "c-bfs-using-queue-clean-code-no-dp",
                "content": "```\\n// This is The Basic BFS Question i have Solved.\\n// Basically What I did Is Gone All to its Neighbour Using loop i.e. All the Thee Operations as stated in question And Correspondingly Pushing in queue.\\n// If i found in set then i wont\\'t proceed because calculation for that particular is already being made.\\n// Also if val < 0 || val > 1000 then also I won\\'t Proceed Becuase it is stated in question.\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n       int n = nums.size();\\n        queue<int>q;\\n        q.push(start);\\n        set<int>output;\\n        int lvl = -1;\\n        while(!q.empty())\\n        {\\n            int sz  = q.size();\\n            lvl++;\\n            while(sz--)\\n            {\\n                int val = q.front();\\n                q.pop();\\n                if(val==goal)\\n                {\\n                    return lvl;\\n                }\\n                if(val <0 || val> 1000)\\n                {\\n                    continue;\\n                }\\n                if(output.find(val)!=output.end())\\n                {\\n                    continue;\\n                }\\n                output.insert(val);\\n                for(int i = 0 ; i < n ; i++)\\n                {\\n                    int h = val + nums[i];\\n                    q.push(h);\\n                    int g = val - nums[i];\\n                    q.push(g);\\n                    int k = val^nums[i];\\n                    q.push(k);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Please Upvote If you Like the Solution and Explanantion...\\u2714\\uFE0F\\uD83D\\uDD25\\uD83D\\uDE0A\\uD83D\\uDC4D**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n// This is The Basic BFS Question i have Solved.\\n// Basically What I did Is Gone All to its Neighbour Using loop i.e. All the Thee Operations as stated in question And Correspondingly Pushing in queue.\\n// If i found in set then i wont\\'t proceed because calculation for that particular is already being made.\\n// Also if val < 0 || val > 1000 then also I won\\'t Proceed Becuase it is stated in question.\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n       int n = nums.size();\\n        queue<int>q;\\n        q.push(start);\\n        set<int>output;\\n        int lvl = -1;\\n        while(!q.empty())\\n        {\\n            int sz  = q.size();\\n            lvl++;\\n            while(sz--)\\n            {\\n                int val = q.front();\\n                q.pop();\\n                if(val==goal)\\n                {\\n                    return lvl;\\n                }\\n                if(val <0 || val> 1000)\\n                {\\n                    continue;\\n                }\\n                if(output.find(val)!=output.end())\\n                {\\n                    continue;\\n                }\\n                output.insert(val);\\n                for(int i = 0 ; i < n ; i++)\\n                {\\n                    int h = val + nums[i];\\n                    q.push(h);\\n                    int g = val - nums[i];\\n                    q.push(g);\\n                    int k = val^nums[i];\\n                    q.push(k);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892626,
                "title": "c-easy-simple-code-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> q;\\n        vector<int> vis(1001,0);\\n        int ans = 0;\\n        q.push(start);\\n        while(!q.empty()){\\n            int t = q.size();\\n            while(t--){\\n               int tmp  = q.front();\\n                q.pop();\\n                if(tmp == goal){return ans;}\\n                if(tmp > 1000 || tmp < 0 || vis[tmp] == 1){continue;}\\n                vis[tmp] = 1;\\n                for(auto x:nums){\\n                    q.push(tmp + x);\\n                    q.push(tmp - x);\\n                    q.push(tmp ^ x);\\n                } \\n            }\\n            ans++;        \\n        }\\n        return -1;\\n    }\\n};\\n```\\nDo upvote if it helped :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> q;\\n        vector<int> vis(1001,0);\\n        int ans = 0;\\n        q.push(start);\\n        while(!q.empty()){\\n            int t = q.size();\\n            while(t--){\\n               int tmp  = q.front();\\n                q.pop();\\n                if(tmp == goal){return ans;}\\n                if(tmp > 1000 || tmp < 0 || vis[tmp] == 1){continue;}\\n                vis[tmp] = 1;\\n                for(auto x:nums){\\n                    q.push(tmp + x);\\n                    q.push(tmp - x);\\n                    q.push(tmp ^ x);\\n                } \\n            }\\n            ans++;        \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552000,
                "title": "100-faster-c-solution-simple-bfs",
                "content": "We\\'ll take start value as initial value and push it in the queue and we\\'ll take all 3 possibilities and calculate the result and keep on pushing it in the queue{if the numbers is in the range and if the number is not already visited}.\\n\\nWe have taken visited array to keep watch on the already visited numbers\\n\\nThe variable **level** will be the answer if it is possible, else it will return -1\\n\\nTake any sample input and dry run it, You\\'ll understand the code completely.\\n```\\nint minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int>q;\\n        q.push(start);\\n        \\n        bool visited[1001];\\n        for(int i=0 ; i<=1000 ; i++)\\n            visited[i]=false;\\n        \\n        int level=0;\\n        if(start==goal)\\n            return level;\\n        \\n        while(!q.empty()){\\n            int size=q.size();\\n            \\n            for(int i=0 ; i<size ; i++){\\n                int curr=q.front();\\n                q.pop();\\n                \\n                for(int i:nums){\\n                    if((i+curr)==goal)\\n                        return level+1;\\n                    if((i+curr)>=0 && (i+curr)<=1000 && !visited[i+curr]){\\n                        visited[i+curr]=true;\\n                        q.push(i+curr);\\n                    }\\n                \\n                    if((curr-i)==goal)\\n                        return level+1;\\n                    if((curr-i)>=0 && (curr-i)<=1000 && !visited[curr-i]){\\n                        visited[curr-i]=true;\\n                        q.push(curr-i);\\n                    }\\n                \\n                    if((i^curr)==goal)\\n                        return level+1;\\n                    if((i^curr)>=0 && (i^curr)<=1000 && !visited[i^curr]){\\n                        visited[i^curr]=true;\\n                        q.push(i^curr);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "We\\'ll take start value as initial value and push it in the queue and we\\'ll take all 3 possibilities and calculate the result and keep on pushing it in the queue{if the numbers is in the range and if the number is not already visited}.\\n\\nWe have taken visited array to keep watch on the already visited numbers\\n\\nThe variable **level** will be the answer if it is possible, else it will return -1\\n\\nTake any sample input and dry run it, You\\'ll understand the code completely.\\n```\\nint minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int>q;\\n        q.push(start);\\n        \\n        bool visited[1001];\\n        for(int i=0 ; i<=1000 ; i++)\\n            visited[i]=false;\\n        \\n        int level=0;\\n        if(start==goal)\\n            return level;\\n        \\n        while(!q.empty()){\\n            int size=q.size();\\n            \\n            for(int i=0 ; i<size ; i++){\\n                int curr=q.front();\\n                q.pop();\\n                \\n                for(int i:nums){\\n                    if((i+curr)==goal)\\n                        return level+1;\\n                    if((i+curr)>=0 && (i+curr)<=1000 && !visited[i+curr]){\\n                        visited[i+curr]=true;\\n                        q.push(i+curr);\\n                    }\\n                \\n                    if((curr-i)==goal)\\n                        return level+1;\\n                    if((curr-i)>=0 && (curr-i)<=1000 && !visited[curr-i]){\\n                        visited[curr-i]=true;\\n                        q.push(curr-i);\\n                    }\\n                \\n                    if((i^curr)==goal)\\n                        return level+1;\\n                    if((i^curr)>=0 && (i^curr)<=1000 && !visited[i^curr]){\\n                        visited[i^curr]=true;\\n                        q.push(i^curr);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1550189,
                "title": "java-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        int res = 0;\\n        Queue<Integer> q = new LinkedList<>();\\n        Set<Integer> set = new HashSet<>();\\n        q.offer(start);\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            \\n            for(int i = 0;i<size;i++){\\n                int val = q.poll();\\n                if(val == goal)return res;\\n                if((val < 0 || val > 1000) || set.contains(val))continue;\\n                if(!set.contains(val))set.add(val);\\n\\n                for(int num : nums){\\n                    q.offer(val + num);\\n                    q.offer(val - num);\\n                    q.offer(val ^ num);\\n                }\\n            }\\n            res++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        int res = 0;\\n        Queue<Integer> q = new LinkedList<>();\\n        Set<Integer> set = new HashSet<>();\\n        q.offer(start);\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            \\n            for(int i = 0;i<size;i++){\\n                int val = q.poll();\\n                if(val == goal)return res;\\n                if((val < 0 || val > 1000) || set.contains(val))continue;\\n                if(!set.contains(val))set.add(val);\\n\\n                for(int num : nums){\\n                    q.offer(val + num);\\n                    q.offer(val - num);\\n                    q.offer(val ^ num);\\n                }\\n            }\\n            res++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549988,
                "title": "c-bfs-with-detailed-explanation",
                "content": "- idea:\\n\\t- given a number `nums[i]`, **from what numbers** can we convert to `goal` in one step?\\n\\t\\t- `goal-nums[i]`, `goal+nums[i]`, `goal^nums[i]`\\n\\t- start searching from these numbers, and the numbers that can convert to `x` in one step (given `nums[i]`) are `x-nums[i]`, `x+nums[i]`, `x^nums[i]`\\n\\t\\t- if some `x-nums[i]` or `x+nums[i]` or `x^nums[i]` is out of the range `[0, 1000]`, we don\\'t have to consider it since we can\\'t convert from those numbers.\\n\\t- keep searching until we found `start` and report the current distance, or report `-1` after all reachable numbers have been visited.\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n = nums.size();\\n        // BFS\\n        queue<int> q;\\n        vector<bool> vis(1001, false);\\n        \\n        q.push(goal);\\n        if (0 <= goal && goal <= 1000) vis[goal] = true;\\n        \\n        int dist = -1;\\n        bool done = false;\\n        while (!q.empty() && !done) {\\n            dist++;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                int cur = q.front(); q.pop();\\n                if (cur == start) {\\n                    done = true;\\n                    break;\\n                }\\n                for (int j = 0; j < n; j++) {\\n                    if (0 <= cur-nums[j] && cur-nums[j] <= 1000 && !vis[cur-nums[j]]) {\\n                        q.push(cur-nums[j]);\\n                        vis[cur-nums[j]] = true;\\n                    }\\n                    if (0 <= cur+nums[j] && cur+nums[j] <= 1000 && !vis[cur+nums[j]]) {\\n                        q.push(cur+nums[j]);\\n                        vis[cur+nums[j]] = true;\\n                    }\\n                    if (0 <= (cur^nums[j]) && (cur^nums[j]) <= 1000 && !vis[cur^nums[j]]) {\\n                        q.push(cur^nums[j]);\\n                        vis[cur^nums[j]] = true;\\n                    }\\n                }\\n            }\\n        }\\n    \\n        return done ? dist : -1;\\n    }\\n};\\n```\\n\\n- Time Complexity: `O(V+E)` where `V <= 1001` and `E <= 3003` \\n\\t- BFS\\n- Space Complexity: `O(V)`\\n\\t- queue `q` and vector `vis`",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n = nums.size();\\n        // BFS\\n        queue<int> q;\\n        vector<bool> vis(1001, false);\\n        \\n        q.push(goal);\\n        if (0 <= goal && goal <= 1000) vis[goal] = true;\\n        \\n        int dist = -1;\\n        bool done = false;\\n        while (!q.empty() && !done) {\\n            dist++;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                int cur = q.front(); q.pop();\\n                if (cur == start) {\\n                    done = true;\\n                    break;\\n                }\\n                for (int j = 0; j < n; j++) {\\n                    if (0 <= cur-nums[j] && cur-nums[j] <= 1000 && !vis[cur-nums[j]]) {\\n                        q.push(cur-nums[j]);\\n                        vis[cur-nums[j]] = true;\\n                    }\\n                    if (0 <= cur+nums[j] && cur+nums[j] <= 1000 && !vis[cur+nums[j]]) {\\n                        q.push(cur+nums[j]);\\n                        vis[cur+nums[j]] = true;\\n                    }\\n                    if (0 <= (cur^nums[j]) && (cur^nums[j]) <= 1000 && !vis[cur^nums[j]]) {\\n                        q.push(cur^nums[j]);\\n                        vis[cur^nums[j]] = true;\\n                    }\\n                }\\n            }\\n        }\\n    \\n        return done ? dist : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800885,
                "title": "easy-implementation-using-bfs-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n = nums.size();\\n        queue<int>q;\\n        q.push(start);\\n        int ops = 0;\\n        unordered_set<int>s; s.insert(start);\\n        vector<int>vis(1001,0); vis[start] = 1;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                int x = q.front(); q.pop();\\n                if(x == goal) return ops;\\n                for(int j=0; j<n; j++){\\n                    int a = x + nums[j];\\n                    int b = x - nums[j];\\n                    int c = (x ^ nums[j]);\\n                    if(a == goal || b == goal || c == goal) return ops+1;\\n                    if(a >= 0 && a <= 1000 && vis[a] == 0) q.push(a), vis[a] = 1;\\n                    if(b >= 0 && b <= 1000 && vis[b] == 0) q.push(b), vis[b] = 1;\\n                    if(c >= 0 && c <= 1000 && vis[c] == 0) q.push(c), vis[c] = 1;\\n                }\\n            }\\n            ops++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n = nums.size();\\n        queue<int>q;\\n        q.push(start);\\n        int ops = 0;\\n        unordered_set<int>s; s.insert(start);\\n        vector<int>vis(1001,0); vis[start] = 1;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                int x = q.front(); q.pop();\\n                if(x == goal) return ops;\\n                for(int j=0; j<n; j++){\\n                    int a = x + nums[j];\\n                    int b = x - nums[j];\\n                    int c = (x ^ nums[j]);\\n                    if(a == goal || b == goal || c == goal) return ops+1;\\n                    if(a >= 0 && a <= 1000 && vis[a] == 0) q.push(a), vis[a] = 1;\\n                    if(b >= 0 && b <= 1000 && vis[b] == 0) q.push(b), vis[b] = 1;\\n                    if(c >= 0 && c <= 1000 && vis[c] == 0) q.push(c), vis[c] = 1;\\n                }\\n            }\\n            ops++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548305,
                "title": "c-bfs-easy-to-understand-code",
                "content": "```\\n\\tclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> q;\\n        int n = nums.size();\\n        q.push(start);\\n        int ans = 0;\\n        unordered_set<int> vis;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                int curr = q.front();\\n                q.pop();\\n                if(curr == goal) return ans;\\n                if(curr < 0 || curr > 1000 || vis.find(curr) != vis.end()) continue;\\n                vis.insert(curr);\\n                for(int i=0;i<n;i++){\\n                    int add = curr + nums[i];\\n                    int sub = curr - nums[i];\\n                    int xxor = curr ^ nums[i];\\n                    q.push(add);\\n                    q.push(sub);\\n                    q.push(xxor);\\n                }\\n            }\\n            ans++;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> q;\\n        int n = nums.size();\\n        q.push(start);\\n        int ans = 0;\\n        unordered_set<int> vis;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                int curr = q.front();\\n                q.pop();\\n                if(curr == goal) return ans;\\n                if(curr < 0 || curr > 1000 || vis.find(curr) != vis.end()) continue;\\n                vis.insert(curr);\\n                for(int i=0;i<n;i++){\\n                    int add = curr + nums[i];\\n                    int sub = curr - nums[i];\\n                    int xxor = curr ^ nums[i];\\n                    q.push(add);\\n                    q.push(sub);\\n                    q.push(xxor);\\n                }\\n            }\\n            ans++;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753902,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        q=collections.deque([start])\\n        seen=set([start])\\n        ans=0\\n        while q:\\n            for _ in range(len(q)):\\n                x=q.popleft()\\n                for num in nums:\\n                    for val in (x-num,x+num,x ^ num):\\n                        if val==goal: return ans+1\\n                        if val not in seen and 0<=val<=1000:\\n                            seen.add(val)\\n                            q.append(val)\\n            ans+=1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        q=collections.deque([start])\\n        seen=set([start])\\n        ans=0\\n        while q:\\n            for _ in range(len(q)):\\n                x=q.popleft()\\n                for num in nums:\\n                    for val in (x-num,x+num,x ^ num):\\n                        if val==goal: return ans+1\\n                        if val not in seen and 0<=val<=1000:\\n                            seen.add(val)\\n                            q.append(val)\\n            ans+=1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552012,
                "title": "java-easy-bfs",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(int[] arr, int start, int goal) {\\n      //Always think of BFS when you have a source and a destination and you want to make it using minimum number of steps\\n        boolean visited[] = new boolean[1001];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(start);\\n        int steps = 0;\\n      //BFS\\n       while(q.size() > 0){\\n          int count = q.size();\\n         \\n          while(count-->0){\\n              int cn = q.remove();\\n              for(int val : arr){\\n                //Perform all given operations\\n                int nn1 = cn + val;\\n                int nn2 = cn - val;\\n                int nn3 = cn ^ val;\\n               \\n              if(nn1 == goal || nn2 == goal || nn3 == goal) return steps + 1;  \\n              \\n              if(nn1 >= 0 && nn1 <= 1000 && visited[nn1] == false){\\n                  q.add(nn1);\\n                  visited[nn1] = true;\\n              }\\n              if(nn2 >= 0 && nn2 <= 1000 && visited[nn2] == false){\\n                  q.add(nn2);\\n                  visited[nn2] = true;\\n              }\\n                if(nn3 >= 0 && nn3 <= 1000 && visited[nn3] == false){\\n                  q.add(nn3);\\n                  visited[nn3] = true;\\n              }\\n                \\n              }\\n          }\\n          steps++;\\n       }\\n      return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] arr, int start, int goal) {\\n      //Always think of BFS when you have a source and a destination and you want to make it using minimum number of steps\\n        boolean visited[] = new boolean[1001];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(start);\\n        int steps = 0;\\n      //BFS\\n       while(q.size() > 0){\\n          int count = q.size();\\n         \\n          while(count-->0){\\n              int cn = q.remove();\\n              for(int val : arr){\\n                //Perform all given operations\\n                int nn1 = cn + val;\\n                int nn2 = cn - val;\\n                int nn3 = cn ^ val;\\n               \\n              if(nn1 == goal || nn2 == goal || nn3 == goal) return steps + 1;  \\n              \\n              if(nn1 >= 0 && nn1 <= 1000 && visited[nn1] == false){\\n                  q.add(nn1);\\n                  visited[nn1] = true;\\n              }\\n              if(nn2 >= 0 && nn2 <= 1000 && visited[nn2] == false){\\n                  q.add(nn2);\\n                  visited[nn2] = true;\\n              }\\n                if(nn3 >= 0 && nn3 <= 1000 && visited[nn3] == false){\\n                  q.add(nn3);\\n                  visited[nn3] = true;\\n              }\\n                \\n              }\\n          }\\n          steps++;\\n       }\\n      return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550214,
                "title": "javascript-bfs-192ms",
                "content": "```\\nconst minimumOperations = (a, x, y) => {\\n    let dis = Array(1001).fill(Number.MAX_SAFE_INTEGER);\\n    let q = [];\\n    q.push(x);\\n    dis[x] = 0;\\n    while (q.length) {\\n        let cur = q.shift();\\n        if (cur == y) return dis[cur];\\n        for (const e of a) {\\n            let t1 = cur + e, t2 = cur - e; t3 = cur ^ e;\\n            let next = [t1, t2, t3];\\n            for (const ne of next) {\\n                if (ne >= 0 && ne <= 1000) {\\n                    if (dis[ne] > dis[cur] + 1) { // bfs next node if smaller, and update current min distance \\n                        dis[ne] = dis[cur] + 1;\\n                        q.push(ne);\\n                    }\\n                } else {\\n                    if (ne == y) return dis[cur] + 1; // reach the goal\\n                }\\n            }\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst minimumOperations = (a, x, y) => {\\n    let dis = Array(1001).fill(Number.MAX_SAFE_INTEGER);\\n    let q = [];\\n    q.push(x);\\n    dis[x] = 0;\\n    while (q.length) {\\n        let cur = q.shift();\\n        if (cur == y) return dis[cur];\\n        for (const e of a) {\\n            let t1 = cur + e, t2 = cur - e; t3 = cur ^ e;\\n            let next = [t1, t2, t3];\\n            for (const ne of next) {\\n                if (ne >= 0 && ne <= 1000) {\\n                    if (dis[ne] > dis[cur] + 1) { // bfs next node if smaller, and update current min distance \\n                        dis[ne] = dis[cur] + 1;\\n                        q.push(ne);\\n                    }\\n                } else {\\n                    if (ne == y) return dis[cur] + 1; // reach the goal\\n                }\\n            }\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1550150,
                "title": "c-bfs-easy-simple",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint minimumOperations(vector<int>& nums, int start, int goal) {\\n\\t\\tint ans = 0;\\n\\n\\t\\tvector<bool> visited(1001, false); //visited array\\n\\t\\tqueue<int>q;//queue for BFS\\n\\n\\t\\tq.push(start); //add start in queue as base for BFS\\n\\n\\t\\twhile (!q.empty())\\n\\t\\t{\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\twhile (size--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint x = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tif (x == goal) //x == goal return ans\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (x > 1000 || x < 0 || visited[x]) //x out of bound [0,1000] or x is previously visited //no need to again proceed it\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//so now x is un visited\\n\\t\\t\\t\\tfor (auto i : nums) //do all three operation(+,-,^) on x and add that value in queue\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tq.push(x + i);\\n\\t\\t\\t\\t\\tq.push(x - i);\\n\\t\\t\\t\\t\\tq.push(x ^ i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvisited[x] = true; //mark x as visited\\n\\t\\t\\t}\\n\\t\\t\\tans++; //operation count increase by 1\\n\\t\\t}\\n\\t\\treturn -1; //not fount goal in above BFS so return -1\\n\\t}\\n};\\n```\\n\\n**If find Helpful *Upvote It* \\uD83D\\uDC4D**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumOperations(vector<int>& nums, int start, int goal) {\\n\\t\\tint ans = 0;\\n\\n\\t\\tvector<bool> visited(1001, false); //visited array\\n\\t\\tqueue<int>q;//queue for BFS\\n\\n\\t\\tq.push(start); //add start in queue as base for BFS\\n\\n\\t\\twhile (!q.empty())\\n\\t\\t{\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\twhile (size--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint x = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tif (x == goal) //x == goal return ans\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (x > 1000 || x < 0 || visited[x]) //x out of bound [0,1000] or x is previously visited //no need to again proceed it\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//so now x is un visited\\n\\t\\t\\t\\tfor (auto i : nums) //do all three operation(+,-,^) on x and add that value in queue\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tq.push(x + i);\\n\\t\\t\\t\\t\\tq.push(x - i);\\n\\t\\t\\t\\t\\tq.push(x ^ i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvisited[x] = true; //mark x as visited\\n\\t\\t\\t}\\n\\t\\t\\tans++; //operation count increase by 1\\n\\t\\t}\\n\\t\\treturn -1; //not fount goal in above BFS so return -1\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550064,
                "title": "python-bfs-solution",
                "content": "```python\\nq = [(start, 0)]\\nseen = set()\\nwhile q:\\n\\tx, step = q.pop(0)\\n\\tfor num in nums:\\n\\t\\tfor y in x + num, x - num, x ^ num:\\n\\t\\t\\tif y == goal:\\n\\t\\t\\t\\treturn step + 1\\n\\t\\t\\tif y not in seen and 0 <= y <= 1000:\\n\\t\\t\\t\\tq.append((y, step + 1))\\n\\t\\t\\t\\tseen.add(y)\\nreturn -1\\n```",
                "solutionTags": [],
                "code": "```python\\nq = [(start, 0)]\\nseen = set()\\nwhile q:\\n\\tx, step = q.pop(0)\\n\\tfor num in nums:\\n\\t\\tfor y in x + num, x - num, x ^ num:\\n\\t\\t\\tif y == goal:\\n\\t\\t\\t\\treturn step + 1\\n\\t\\t\\tif y not in seen and 0 <= y <= 1000:\\n\\t\\t\\t\\tq.append((y, step + 1))\\n\\t\\t\\t\\tseen.add(y)\\nreturn -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1550019,
                "title": "python-silky-smooth-breadth-first-search",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        seen = set()\\n        bfsList = {start}\\n        ops = 0\\n        while bfsList:\\n            newList = set()\\n            for i in bfsList:\\n                if i == goal: return ops\\n                if 0 <= i <= 1000:\\n                    if i not in seen:\\n                        seen.add(i)\\n                        for num in nums:\\n                            newList.add(i + num)\\n                            newList.add(i - num)\\n                            newList.add(i ^ num)\\n            ops += 1\\n            bfsList = newList\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        seen = set()\\n        bfsList = {start}\\n        ops = 0\\n        while bfsList:\\n            newList = set()\\n            for i in bfsList:\\n                if i == goal: return ops\\n                if 0 <= i <= 1000:\\n                    if i not in seen:\\n                        seen.add(i)\\n                        for num in nums:\\n                            newList.add(i + num)\\n                            newList.add(i - num)\\n                            newList.add(i ^ num)\\n            ops += 1\\n            bfsList = newList\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2383827,
                "title": "c-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> q;\\n        q.push(start);\\n        unordered_set<int> vis; //keep track of processed number\\n        int steps=0; //count steps\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                if(temp==goal)\\n                {\\n                    return steps;\\n                }\\n                if(temp<0 || temp>1000 || vis.find(temp)!=vis.end()) //if x<0 || x>100 || already processed\\n                {\\n                    continue;\\n                }\\n                vis.insert(temp);\\n                for(int i=0;i<nums.size();++i)\\n                {\\n                    //performing operations\\n                    int op1=temp+nums[i];\\n                    int op2=temp-nums[i];\\n                    int op3=temp^nums[i];\\n                    q.push(op1);\\n                    q.push(op2);\\n                    q.push(op3);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> q;\\n        q.push(start);\\n        unordered_set<int> vis; //keep track of processed number\\n        int steps=0; //count steps\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                if(temp==goal)\\n                {\\n                    return steps;\\n                }\\n                if(temp<0 || temp>1000 || vis.find(temp)!=vis.end()) //if x<0 || x>100 || already processed\\n                {\\n                    continue;\\n                }\\n                vis.insert(temp);\\n                for(int i=0;i<nums.size();++i)\\n                {\\n                    //performing operations\\n                    int op1=temp+nums[i];\\n                    int op2=temp-nums[i];\\n                    int op3=temp^nums[i];\\n                    q.push(op1);\\n                    q.push(op2);\\n                    q.push(op3);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336524,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n = nums.size();\\n        queue<int> q;\\n        q.push(start);\\n        int ans = 0;\\n        vector<int> visited(1000+1, 0);\\n        visited[start]++;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            ans++;\\n            while(sz--)\\n            {\\n                int x = q.front();\\n                q.pop();\\n                int val1, val2, val3;\\n                for(int i = 0; i < n; i++)\\n                {\\n                    int g = nums[i];\\n                    val1 = x + g;\\n                    val2 = x - g;\\n                    val3 = x ^ g;\\n                    if(val1 == goal || val2 == goal || val3 == goal) return ans;\\n                    if(val1 >= 0 && val1 <= 1000 && !visited[val1])\\n                    {\\n                        q.push(val1);\\n                        visited[val1]++;\\n                    }\\n                    if(val2 >= 0 && val2 <= 1000 && !visited[val2])\\n                    {\\n                        q.push(val2);\\n                        visited[val2]++;\\n                    }\\n                    if(val3 >= 0 && val3 <= 1000 && !visited[val3])\\n                    {\\n                        q.push(val3);\\n                        visited[val3]++;\\n                    }\\n                }\\n            }\\n            if(ans == 1000)\\n                break;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n = nums.size();\\n        queue<int> q;\\n        q.push(start);\\n        int ans = 0;\\n        vector<int> visited(1000+1, 0);\\n        visited[start]++;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            ans++;\\n            while(sz--)\\n            {\\n                int x = q.front();\\n                q.pop();\\n                int val1, val2, val3;\\n                for(int i = 0; i < n; i++)\\n                {\\n                    int g = nums[i];\\n                    val1 = x + g;\\n                    val2 = x - g;\\n                    val3 = x ^ g;\\n                    if(val1 == goal || val2 == goal || val3 == goal) return ans;\\n                    if(val1 >= 0 && val1 <= 1000 && !visited[val1])\\n                    {\\n                        q.push(val1);\\n                        visited[val1]++;\\n                    }\\n                    if(val2 >= 0 && val2 <= 1000 && !visited[val2])\\n                    {\\n                        q.push(val2);\\n                        visited[val2]++;\\n                    }\\n                    if(val3 >= 0 && val3 <= 1000 && !visited[val3])\\n                    {\\n                        q.push(val3);\\n                        visited[val3]++;\\n                    }\\n                }\\n            }\\n            if(ans == 1000)\\n                break;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323792,
                "title": "bfs-with-typescript-beats-100",
                "content": "```\\nfunction minimumOperations(nums: number[], start: number, goal: number): number {\\n    let currentLevel:Array<[number, number]> = [[start , 0]];\\n    let nextLevel:Array<[number, number]> = [];\\n    const operations = \\n        [\\n            (n:number, m:number) => n + m,\\n            (n:number, m:number) => n - m,\\n            (n:number, m:number) => n ^ m,\\n        ]\\n    const visited = new Set([start]);\\n    while(currentLevel.length){\\n        const [current, numberOfOperations] = currentLevel.shift();\\n        if(current === goal)\\n            return numberOfOperations;\\n        \\n        if(current >= 0 && current <= 1000){\\n            for(const num of nums){\\n                for(const operation of operations){\\n                    const next = operation(current, num);\\n                    if(!visited.has(next)){\\n                        visited.add(next)\\n                        nextLevel.push([next, numberOfOperations + 1]);\\n                    } \\n                }\\n            }\\n        }\\n        if(!currentLevel.length)\\n            [currentLevel, nextLevel] = [nextLevel, currentLevel];\\n    }\\n    return -1;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunction minimumOperations(nums: number[], start: number, goal: number): number {\\n    let currentLevel:Array<[number, number]> = [[start , 0]];\\n    let nextLevel:Array<[number, number]> = [];\\n    const operations = \\n        [\\n            (n:number, m:number) => n + m,\\n            (n:number, m:number) => n - m,\\n            (n:number, m:number) => n ^ m,\\n        ]\\n    const visited = new Set([start]);\\n    while(currentLevel.length){\\n        const [current, numberOfOperations] = currentLevel.shift();\\n        if(current === goal)\\n            return numberOfOperations;\\n        \\n        if(current >= 0 && current <= 1000){\\n            for(const num of nums){\\n                for(const operation of operations){\\n                    const next = operation(current, num);\\n                    if(!visited.has(next)){\\n                        visited.add(next)\\n                        nextLevel.push([next, numberOfOperations + 1]);\\n                    } \\n                }\\n            }\\n        }\\n        if(!currentLevel.length)\\n            [currentLevel, nextLevel] = [nextLevel, currentLevel];\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2249019,
                "title": "python-bfs-faster-than-90-96",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        res = 0\\n        \\n        q = deque([start])\\n        seen = {start}\\n        while q:\\n            n = len(q)\\n            for _ in range(n):\\n                num = q.popleft()\\n                \\n                for partner in nums:\\n                    if num + partner == goal:\\n                        return res + 1\\n                    elif 0 <= num + partner <= 1000 and num + partner not in seen:\\n                        seen.add(num + partner)\\n                        q.append(num + partner)\\n                    \\n                    if num - partner == goal:\\n                        return res + 1\\n                    elif 0 <= num - partner <= 1000 and num - partner not in seen:\\n                        seen.add(num - partner)\\n                        q.append(num - partner)\\n                    \\n                    if num ^ partner == goal:\\n                        return res + 1\\n                    elif 0 <= num ^ partner <= 1000 and num ^ partner not in seen:\\n                        seen.add(num ^ partner)\\n                        q.append(num ^ partner)\\n                        \\n            res += 1\\n        \\n        return -1\\n```\\nRuntime: 1426 ms (faster than 90.96%)\\nMemory: 14 MB (smaller than 95.18%)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        res = 0\\n        \\n        q = deque([start])\\n        seen = {start}\\n        while q:\\n            n = len(q)\\n            for _ in range(n):\\n                num = q.popleft()\\n                \\n                for partner in nums:\\n                    if num + partner == goal:\\n                        return res + 1\\n                    elif 0 <= num + partner <= 1000 and num + partner not in seen:\\n                        seen.add(num + partner)\\n                        q.append(num + partner)\\n                    \\n                    if num - partner == goal:\\n                        return res + 1\\n                    elif 0 <= num - partner <= 1000 and num - partner not in seen:\\n                        seen.add(num - partner)\\n                        q.append(num - partner)\\n                    \\n                    if num ^ partner == goal:\\n                        return res + 1\\n                    elif 0 <= num ^ partner <= 1000 and num ^ partner not in seen:\\n                        seen.add(num ^ partner)\\n                        q.append(num ^ partner)\\n                        \\n            res += 1\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138021,
                "title": "c-easy-to-understand-simple-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n=nums.size();\\n        queue<int> q;\\n        set<int> st;\\n        q.push(start);\\n        int level=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            level++;\\n            for(int i=0;i<size;i++)\\n            {\\n                int ele=q.front();\\n                q.pop();\\n                if(ele<0||ele>1000)\\n                {\\n                    continue;\\n                }\\n                if(st.find(ele)!=st.end())\\n                {\\n                    continue;\\n                }\\n                st.insert(ele);\\n                for(int i=0;i<n;i++)\\n                {\\n                    if(ele+nums[i]==goal)\\n                    {\\n                        return level;\\n                    }\\n                    if(ele-nums[i]==goal)\\n                    {\\n                        return level;   \\n                    }\\n                    if((ele^nums[i])==goal)\\n                    {\\n                        return level;\\n                    }\\n                    \\n                    q.push(ele+nums[i]);\\n                    q.push(ele-nums[i]);\\n                    q.push(ele^nums[i]);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n=nums.size();\\n        queue<int> q;\\n        set<int> st;\\n        q.push(start);\\n        int level=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            level++;\\n            for(int i=0;i<size;i++)\\n            {\\n                int ele=q.front();\\n                q.pop();\\n                if(ele<0||ele>1000)\\n                {\\n                    continue;\\n                }\\n                if(st.find(ele)!=st.end())\\n                {\\n                    continue;\\n                }\\n                st.insert(ele);\\n                for(int i=0;i<n;i++)\\n                {\\n                    if(ele+nums[i]==goal)\\n                    {\\n                        return level;\\n                    }\\n                    if(ele-nums[i]==goal)\\n                    {\\n                        return level;   \\n                    }\\n                    if((ele^nums[i])==goal)\\n                    {\\n                        return level;\\n                    }\\n                    \\n                    q.push(ele+nums[i]);\\n                    q.push(ele-nums[i]);\\n                    q.push(ele^nums[i]);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658694,
                "title": "java-bff",
                "content": "class Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        \\n      List<String> operationList = new ArrayList<>();\\n        operationList.add(\"+\");\\n        operationList.add(\"-\");\\n        operationList.add(\"^\");\\n\\n        Queue<Integer> bfsQueue = new LinkedList<>();\\n        Map<Integer, Integer> visited = new HashMap<>();\\n\\n        bfsQueue.add(start);\\n        int stepCount = 0;\\n        visited.put(start, 1);\\n        boolean goalReached = false;\\n        while (!bfsQueue.isEmpty()) {\\n            stepCount++;\\n            int size = bfsQueue.size();\\n\\n            while (size > 0) {\\n\\n                int operableValue = bfsQueue.poll();\\n                size--;\\n                if (operableValue == goal) {\\n                    goalReached = true;\\n                    break;\\n                }\\n                if (operableValue >= 0 && operableValue <= 1000) {\\n                    for (int idx = 0; idx < nums.length; idx++) {\\n\\n                        for (String operation : operationList) {\\n                            int operatedValue = operate(operation, operableValue, nums[idx]);\\n                            if (operatedValue == goal) {\\n                                goalReached = true;\\n                                break;\\n                            }\\n                            if(operatedValue >= 0 && operatedValue <= 1000 && (!visited.containsKey(operatedValue))){\\n                                visited.put(operatedValue, 1);\\n                                bfsQueue.add(operatedValue);\\n                            }\\n                        }\\n                        // end operation for\\n                    }\\n                }\\n\\n            }\\n            if (goalReached) {\\n                break;\\n            }\\n        }\\n        stepCount = goalReached ? stepCount : -1;\\n        return stepCount;\\n    }\\n    \\n    public static int operate(String operation, int operableValue, int operationValue) {\\n        switch (operation) {\\n            case \"+\":\\n                return operableValue + operationValue;\\n\\n            case \"-\":\\n                return operableValue - operationValue;\\n\\n            case \"^\":\\n                return operableValue ^ operationValue;\\n\\n            default:\\n                return -1;\\n\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        \\n      List<String> operationList = new ArrayList<>();\\n        operationList.add(\"+\");\\n        operationList.add(\"-\");\\n        operationList.add(\"^\");\\n\\n        Queue<Integer> bfsQueue = new LinkedList<>();\\n        Map<Integer, Integer> visited = new HashMap<>();\\n\\n        bfsQueue.add(start);\\n        int stepCount = 0;\\n        visited.put(start, 1);\\n        boolean goalReached = false;\\n        while (!bfsQueue.isEmpty()) {\\n            stepCount++;\\n            int size = bfsQueue.size();\\n\\n            while (size > 0) {\\n\\n                int operableValue = bfsQueue.poll();\\n                size--;\\n                if (operableValue == goal) {\\n                    goalReached = true;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1618140,
                "title": "java-bfs-with-queue-and-memorization-of-checked-values",
                "content": "```\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        Queue<Integer> q = new LinkedList<>();\\n        Set<Integer> set = new HashSet<>();\\n        int step = 1;\\n\\n        q.offer(start);\\n        set.add(start);\\n        \\n        while(!q.isEmpty()){\\n            int len = q.size();\\n            for(int i=0;i<len;i++){\\n                int val = q.poll();\\n                for(int n : nums){\\n                    for(int op : new int[]{val^n,val-n,val+n}){\\n                        if(op == goal)\\n                            return step;\\n                        if(op>=0 && op<=1000 && set.add(op))\\n                            q.offer(op);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        Queue<Integer> q = new LinkedList<>();\\n        Set<Integer> set = new HashSet<>();\\n        int step = 1;\\n\\n        q.offer(start);\\n        set.add(start);\\n        \\n        while(!q.isEmpty()){\\n            int len = q.size();\\n            for(int i=0;i<len;i++){\\n                int val = q.poll();\\n                for(int n : nums){\\n                    for(int op : new int[]{val^n,val-n,val+n}){\\n                        if(op == goal)\\n                            return step;\\n                        if(op>=0 && op<=1000 && set.add(op))\\n                            q.offer(op);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1562504,
                "title": "python-3-with-only-three-lists-67-14-98-21-easy-to-understand",
                "content": "\\t\\tsteps = 0\\n        prev_list = [start]\\n        pool = [start]\\n        while 1:\\n            steps+=1\\n            rlist = []\\n            for i in prev_list:\\n                for j in nums:\\n                    r1 = i + j\\n                    r2 = i - j\\n                    r3 = i ^ j\\n                    if r1==goal or r2==goal or r3==goal:\\n                        return steps\\n                    if 0<=r1<=1000 and r1 not in rlist and r1 not in pool:\\n                        rlist.append(r1)\\n                    if 0<=r2<=1000 and r2 not in rlist and r2 not in pool:\\n                        rlist.append(r2)\\n                    if 0<=r3<=1000 and r3 not in rlist and r3 not in pool:\\n                        rlist.append(r3)\\n            if not rlist:\\n                return -1\\n            prev_list = rlist\\n            pool.extend(rlist)\\n",
                "solutionTags": [],
                "code": "\\t\\tsteps = 0\\n        prev_list = [start]\\n        pool = [start]\\n        while 1:\\n            steps+=1\\n            rlist = []\\n            for i in prev_list:\\n                for j in nums:\\n                    r1 = i + j\\n                    r2 = i - j\\n                    r3 = i ^ j\\n                    if r1==goal or r2==goal or r3==goal:\\n                        return steps\\n                    if 0<=r1<=1000 and r1 not in rlist and r1 not in pool:\\n                        rlist.append(r1)\\n                    if 0<=r2<=1000 and r2 not in rlist and r2 not in pool:\\n                        rlist.append(r2)\\n                    if 0<=r3<=1000 and r3 not in rlist and r3 not in pool:\\n                        rlist.append(r3)\\n            if not rlist:\\n                return -1\\n            prev_list = rlist\\n            pool.extend(rlist)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1557050,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int x, int goal) {\\n        function<int(int,int)> ops[3] = {[] (int a, int b) {return a + b;},\\n                       [] (int a, int b) {return a - b;},\\n                       [] (int a, int b) {return a ^ b;}};\\n        queue<int> q;\\n        q.push(x);\\n        unordered_set<int> v;\\n        v.insert(x);\\n        for (int i = 1; !q.empty(); i++) {\\n            for (int j = 0, e = q.size(); j < e; j++) {\\n                int cur = q.front();\\n                q.pop();\\n                for (auto t : nums) {\\n                    for (auto &op : ops) {\\n                        int val = op(cur, t);\\n                        if (val == goal) return i;\\n                        if (!v.count(val) && val >= 0 && val <= 1000) {\\n                            v.insert(val);\\n                            q.push(val);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int x, int goal) {\\n        function<int(int,int)> ops[3] = {[] (int a, int b) {return a + b;},\\n                       [] (int a, int b) {return a - b;},\\n                       [] (int a, int b) {return a ^ b;}};\\n        queue<int> q;\\n        q.push(x);\\n        unordered_set<int> v;\\n        v.insert(x);\\n        for (int i = 1; !q.empty(); i++) {\\n            for (int j = 0, e = q.size(); j < e; j++) {\\n                int cur = q.front();\\n                q.pop();\\n                for (auto t : nums) {\\n                    for (auto &op : ops) {\\n                        int val = op(cur, t);\\n                        if (val == goal) return i;\\n                        if (!v.count(val) && val >= 0 && val <= 1000) {\\n                            v.insert(val);\\n                            q.push(val);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557023,
                "title": "set-operations-abc-8-lines",
                "content": "So if you find the classical BFS boring, see how it can be done differently with [set operations](https://en.wikipedia.org/wiki/Algebra_of_sets) (let\\'s call it ABC algorithm \\uD83D\\uDE05):\\n- `A` is frontwave of BFS\\n- `B` contains visited numbers in range [0; 1000]\\n- `C` contains all numbers in range [0; 1000]\\n\\n```cs\\npublic int MinimumOperations(int[] nums, int start, int goal) {\\n    HashSet<int> A = new() { start }, B = new(), C = new(Enumerable.Range(0, 1001));\\n    for (start = 0; A.Any() && !A.Contains(goal); ++start) {\\n        A.IntersectWith(C);\\n        A.ExceptWith(B);\\n        B.UnionWith(A);\\n        A = A.SelectMany(x => nums.SelectMany(n => new[] { x + n, x - n, x ^ n })).ToHashSet();\\n    }\\n    return A.Any() ? start : -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```cs\\npublic int MinimumOperations(int[] nums, int start, int goal) {\\n    HashSet<int> A = new() { start }, B = new(), C = new(Enumerable.Range(0, 1001));\\n    for (start = 0; A.Any() && !A.Contains(goal); ++start) {\\n        A.IntersectWith(C);\\n        A.ExceptWith(B);\\n        B.UnionWith(A);\\n        A = A.SelectMany(x => nums.SelectMany(n => new[] { x + n, x - n, x ^ n })).ToHashSet();\\n    }\\n    return A.Any() ? start : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1555912,
                "title": "a-few-solutions",
                "content": "Perform BFS from source `S` to target `T`.\\n\\nNote: Javascript & Python3 are AC, however Kotlin & C++ result in TLE \\xAF\\\\\\\\_(\\u30C4)_/\\xAF\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minimumOperations(A: IntArray, S: Int, T: Int): Int {\\n        var depth = 0\\n        var q: Queue<Int> = LinkedList<Int>(listOf(S))\\n        var seen = mutableSetOf<Int>(S)\\n        while (0 < q.size) {\\n            var k = q.size\\n            while (0 < k--) {\\n                var x = q.poll()\\n                if (x == T)\\n                    return depth\\n                if (x < 0 || 1000 < x)\\n                    continue\\n                for (y in A) {\\n                    var (a, b, c) = listOf(x + y, x - y, x xor y)\\n                    for (z in listOf(a, b, c)) {\\n                        if (!seen.contains(z)) {\\n                            q.add(z); seen.add(z)\\n                        }\\n                    }\\n                }\\n            }\\n            ++depth\\n        }\\n        return -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minimumOperations = (A, S, T, depth = 0) => {\\n    let [q, seen] = [[S], new Set([S])];\\n    while (q.length) {\\n        let k = q.length;\\n        while (k--) {\\n            let x = q.shift();\\n            if (x == T)\\n                return depth;\\n            if (x < 0 || 1000 < x)\\n                continue;\\n            for (let y of A) {\\n                let a = x + y,\\n                    b = x - y,\\n                    c = x ^ y;\\n                for (let z of [a, b, c])\\n                    if (!seen.has(z))\\n                        q.push(z), seen.add(z);\\n            }\\n        }\\n        ++depth;\\n    }\\n    return -1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minimumOperations(self, A: List[int], S: int, T: int, depth = 0) -> int:\\n        q, seen = deque([S]), set([S])\\n        while q:\\n            k = len(q)\\n            while k:\\n                x = q.popleft(); k -= 1\\n                if x == T:\\n                    return depth\\n                if x < 0 or 1000 < x:\\n                    continue\\n                for y in A:\\n                    a = x + y\\n                    b = x - y\\n                    c = x ^ y\\n                    for z in [a, b, c]:\\n                        if z not in seen:\\n                            q.append(z); seen.add(z)\\n            depth += 1\\n        return -1\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using Queue = queue<int>;\\n    int minimumOperations(VI& A, int S, int T, int depth = 0) {\\n        Set seen{ S };\\n        Queue q{{ S }};\\n        while (q.size()) {\\n            int k = q.size();\\n            while (k--) {\\n                auto x = q.front(); q.pop();\\n                if (x == T)\\n                    return depth;\\n                if (x < 0 || 1000 < x)\\n                    continue;\\n                for (auto y: A) {\\n                    auto a = x - y,\\n                         b = x + y,\\n                         c = x ^ y;\\n                    for (auto z: VI{ a, b, c })\\n                        if (seen.insert(z).second)\\n                            q.push(z);\\n                }\\n            }\\n            ++depth;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumOperations(A: IntArray, S: Int, T: Int): Int {\\n        var depth = 0\\n        var q: Queue<Int> = LinkedList<Int>(listOf(S))\\n        var seen = mutableSetOf<Int>(S)\\n        while (0 < q.size) {\\n            var k = q.size\\n            while (0 < k--) {\\n                var x = q.poll()\\n                if (x == T)\\n                    return depth\\n                if (x < 0 || 1000 < x)\\n                    continue\\n                for (y in A) {\\n                    var (a, b, c) = listOf(x + y, x - y, x xor y)\\n                    for (z in listOf(a, b, c)) {\\n                        if (!seen.contains(z)) {\\n                            q.add(z); seen.add(z)\\n                        }\\n                    }\\n                }\\n            }\\n            ++depth\\n        }\\n        return -1\\n    }\\n}\\n```\n```\\nlet minimumOperations = (A, S, T, depth = 0) => {\\n    let [q, seen] = [[S], new Set([S])];\\n    while (q.length) {\\n        let k = q.length;\\n        while (k--) {\\n            let x = q.shift();\\n            if (x == T)\\n                return depth;\\n            if (x < 0 || 1000 < x)\\n                continue;\\n            for (let y of A) {\\n                let a = x + y,\\n                    b = x - y,\\n                    c = x ^ y;\\n                for (let z of [a, b, c])\\n                    if (!seen.has(z))\\n                        q.push(z), seen.add(z);\\n            }\\n        }\\n        ++depth;\\n    }\\n    return -1;\\n};\\n```\n```\\nclass Solution:\\n    def minimumOperations(self, A: List[int], S: int, T: int, depth = 0) -> int:\\n        q, seen = deque([S]), set([S])\\n        while q:\\n            k = len(q)\\n            while k:\\n                x = q.popleft(); k -= 1\\n                if x == T:\\n                    return depth\\n                if x < 0 or 1000 < x:\\n                    continue\\n                for y in A:\\n                    a = x + y\\n                    b = x - y\\n                    c = x ^ y\\n                    for z in [a, b, c]:\\n                        if z not in seen:\\n                            q.append(z); seen.add(z)\\n            depth += 1\\n        return -1\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using Queue = queue<int>;\\n    int minimumOperations(VI& A, int S, int T, int depth = 0) {\\n        Set seen{ S };\\n        Queue q{{ S }};\\n        while (q.size()) {\\n            int k = q.size();\\n            while (k--) {\\n                auto x = q.front(); q.pop();\\n                if (x == T)\\n                    return depth;\\n                if (x < 0 || 1000 < x)\\n                    continue;\\n                for (auto y: A) {\\n                    auto a = x - y,\\n                         b = x + y,\\n                         c = x ^ y;\\n                    for (auto z: VI{ a, b, c })\\n                        if (seen.insert(z).second)\\n                            q.push(z);\\n                }\\n            }\\n            ++depth;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552752,
                "title": "c-bfs-simple-to-understand-and-implement",
                "content": "My solution is proceed as follows \\nWe are using a bfs type algorithm so , we needed a queue  (q) , in it we push the start value.\\nAs we are going the level by level , so in addition to queue , we require level variable which indicates the minimum level needed to require to reach the goal.\\nAs we doing level wise traversal , so we determine the size of queue in each level , then exhaust that many starts value from queue.\\nAlso we needed a vis map that ensures no startNew value is push more than once in the queue , otherwise we will end up getting into an infinite loop.\\nstep-1 -> Condersing the start value then performing every operation on it , that is add, sub,xor with every element of the nums vector , for example  start + nums[i[ , start-nums[i] , start^nums[i] , for 1<=i && i<= n , iterating in the nums array .\\nstep-2-> After obtaining the new start values that is startNew = start  (+,-,^)  nums[i] , first check the startNew  value matches with goal , if it matches return level+1 ,\\nstep-3-> The startNew obtain check if it follows in the range of  1<=val && val<=1000 if yes then only push to queue for future possible solution.\\n\\nif the queue becomes exhausted that means no return statements above it, is executed then there is no valid answer exist so in the end return -1; \\nCode for the above explaination \\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        \\n        queue<int> q;\\n        q.push(start);\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        int sz,curr,curr1;\\n        int level=0;\\n        while(!q.empty()){\\n            sz = q.size();\\n            for(int i=0;i<sz;i++){\\n                curr = q.front(); q.pop();\\n                if(curr==goal) return level;\\n                \\n                for(int i=0;i<n;i++){\\n                    curr1 = curr + nums[i];\\n                    if(curr1<0 || curr1>1000){\\n                        if(curr1==goal) return level+1;\\n                    }else{\\n                        if(mp[curr1]==0){\\n                            q.push(curr1);\\n                        }\\n                        mp[curr1] = 1;\\n                        \\n                    }\\n                    curr1 = curr - nums[i];\\n                    if(curr1<0 || curr1>1000){\\n                        if(curr1==goal) return level+1;\\n                    }else{\\n                        if(mp[curr1]==0){\\n                            q.push(curr1);\\n                        }\\n                        mp[curr1] = 1;\\n                        \\n                    }\\n                    curr1 = curr^nums[i];\\n                    if(curr1<0 || curr1>1000){\\n                        if(curr1==goal) return level+1;\\n                    }else{\\n                        if(mp[curr1]==0){\\n                            q.push(curr1);\\n                        }\\n                        mp[curr1] = 1;\\n                        \\n                    }\\n                }\\n            }\\n            \\n            level++;\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};\\n```\\nPlease upvote if it helped you in anyway, happy coding:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        \\n        queue<int> q;\\n        q.push(start);\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        int sz,curr,curr1;\\n        int level=0;\\n        while(!q.empty()){\\n            sz = q.size();\\n            for(int i=0;i<sz;i++){\\n                curr = q.front(); q.pop();\\n                if(curr==goal) return level;\\n                \\n                for(int i=0;i<n;i++){\\n                    curr1 = curr + nums[i];\\n                    if(curr1<0 || curr1>1000){\\n                        if(curr1==goal) return level+1;\\n                    }else{\\n                        if(mp[curr1]==0){\\n                            q.push(curr1);\\n                        }\\n                        mp[curr1] = 1;\\n                        \\n                    }\\n                    curr1 = curr - nums[i];\\n                    if(curr1<0 || curr1>1000){\\n                        if(curr1==goal) return level+1;\\n                    }else{\\n                        if(mp[curr1]==0){\\n                            q.push(curr1);\\n                        }\\n                        mp[curr1] = 1;\\n                        \\n                    }\\n                    curr1 = curr^nums[i];\\n                    if(curr1<0 || curr1>1000){\\n                        if(curr1==goal) return level+1;\\n                    }else{\\n                        if(mp[curr1]==0){\\n                            q.push(curr1);\\n                        }\\n                        mp[curr1] = 1;\\n                        \\n                    }\\n                }\\n            }\\n            \\n            level++;\\n        }\\n        \\n        \\n        \\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552384,
                "title": "first-solution-that-popped-in-my-head",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int moves = 0; \\n        queue<int>q; \\n        q.push(start); \\n        vector<bool> visited(1001,0); \\n        while(!q.empty()){\\n            int size = q.size(); \\n            for(int s=0;s<size;s++){\\n                int curr = q.front();\\n                q.pop();\\n                if(curr == goal){\\n                    return moves; \\n                } \\n                if(curr<0 || curr>1000 || visited[curr]) \\n                    continue; \\n                visited[curr] = 1; \\n                for(int i=0;i<nums.size();i++){\\n                    q.push(curr+nums[i]); \\n                    q.push(curr-nums[i]);\\n                    q.push(curr^nums[i]);                     \\n                }\\n            }\\n            moves++; \\n        }\\n        \\n        return -1; \\n    }\\n};\\n```\\nRuntime: 600ms \\nIf you can think of any other optimized solution feel free to comment below :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int moves = 0; \\n        queue<int>q; \\n        q.push(start); \\n        vector<bool> visited(1001,0); \\n        while(!q.empty()){\\n            int size = q.size(); \\n            for(int s=0;s<size;s++){\\n                int curr = q.front();\\n                q.pop();\\n                if(curr == goal){\\n                    return moves; \\n                } \\n                if(curr<0 || curr>1000 || visited[curr]) \\n                    continue; \\n                visited[curr] = 1; \\n                for(int i=0;i<nums.size();i++){\\n                    q.push(curr+nums[i]); \\n                    q.push(curr-nums[i]);\\n                    q.push(curr^nums[i]);                     \\n                }\\n            }\\n            moves++; \\n        }\\n        \\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552316,
                "title": "simple-bfs",
                "content": "Main idea Why to do bfs is: if we even generate all the numbers by applying given operations any number of times we have to check max 1000 numbers between 0 and 1000 since after that we cant apply any operation. so at max our bfs will run for approx 1000 times.so generate all the numbers possible by given operations between 0 and 1000 and check if u get your goal. \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n=nums.size();\\n        queue<pair<int,int>>q;\\n        if(start==goal)return 0;\\n     \\n        vector<int>visited(1001,0);\\n        q.push({start,0});\\n        \\n        while(!q.empty())\\n        {\\n            int cur=q.front().first;\\n            int ans=q.front().second;\\n            q.pop();\\n            if((cur>1000||cur<0)&&cur!=goal)continue;\\n            if(cur==goal)return ans;\\n            if(visited[cur]==1)continue;\\n            \\n            visited[cur]=1;\\n            for(int i=0;i<n;i++){\\n                int a=cur+nums[i];\\n                int b=cur-nums[i];\\n                int c=cur^nums[i];\\n                q.push({a,ans+1});\\n                q.push({b,ans+1});\\n                q.push({c,ans+1});\\n            }\\n           \\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n=nums.size();\\n        queue<pair<int,int>>q;\\n        if(start==goal)return 0;\\n     \\n        vector<int>visited(1001,0);\\n        q.push({start,0});\\n        \\n        while(!q.empty())\\n        {\\n            int cur=q.front().first;\\n            int ans=q.front().second;\\n            q.pop();\\n            if((cur>1000||cur<0)&&cur!=goal)continue;\\n            if(cur==goal)return ans;\\n            if(visited[cur]==1)continue;\\n            \\n            visited[cur]=1;\\n            for(int i=0;i<n;i++){\\n                int a=cur+nums[i];\\n                int b=cur-nums[i];\\n                int c=cur^nums[i];\\n                q.push({a,ans+1});\\n                q.push({b,ans+1});\\n                q.push({c,ans+1});\\n            }\\n           \\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551954,
                "title": "c-2059-minimum-operations-to-convert-number",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> q; q.push(start); \\n        bool visited[1001] = {false}; \\n        for (int ans = 0; q.size(); ++ans) \\n            for (int sz = q.size(); sz; --sz) {\\n                int val = q.front(); q.pop(); \\n                if (val == goal) return ans; \\n                if (0 <= val && val <= 1000 && !visited[val]) {\\n                    visited[val] = true; \\n                    for (auto& x : nums) \\n                        for (auto& cand : {val+x, val-x, val^x}) \\n                            q.push(cand); \\n                }\\n            }\\n        return -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> q; q.push(start); \\n        bool visited[1001] = {false}; \\n        for (int ans = 0; q.size(); ++ans) \\n            for (int sz = q.size(); sz; --sz) {\\n                int val = q.front(); q.pop(); \\n                if (val == goal) return ans; \\n                if (0 <= val && val <= 1000 && !visited[val]) {\\n                    visited[val] = true; \\n                    for (auto& x : nums) \\n                        for (auto& cand : {val+x, val-x, val^x}) \\n                            q.push(cand); \\n                }\\n            }\\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551421,
                "title": "java-bfs-path-finder-ideas-and-tricks",
                "content": "First of all, this question is a solid con master which could lure you to consider DFS + memorization or DP like techniques, but if you dare go top down dp, you will struggle cause during the state search, you will not always result in sub-problems, you may have to re-visit the parent states and they are not yet computed. For instance, for input [2], start = 3, goal = 1, you can have this search path 3 -> 7 -> 5 -> 3. You need to reconsider the DP formulation such that the parent problem only depend on sub-problem and will not depend on grand-parent problem...\\n\\nThis 3 -> 7 -> 5 -> 3 instance immediately motivates me that I should not revisit nodes / states cause it is a wasted step. Then, it seems like modelling the question into a graph is very reasonable. Any number that is reachable is a node, and we just traverse from start node to all its possible neighbors and we travel again from those neighbors until we found goal. Note, the travel cost is unit cost 1, so we can use BFS path finder (nerfed version of Dijkstra, when travel cost is not unit, use Dijkstra). \\n\\n* Additional gate keeper from this question: in generic BFS path finder problems, we are often allowed to \"over shoot\", that is adding nodes that went beyond the target and when they get popped, we can ignore them cause they \"over shoot\". In this question, you could often find yourself in TLE issue if you just simply add every possible node into the queue. The problem is due to two reasons: \\n\\t- The extra nodes could be as many as `N*N*3`, where `N = 1000`, cause the question bounded valid states to be within this range. For each valid state, we expand the search state based on its neighbors in the graph, and we know we can have N * 3 many possible expansions (we have <=N number of items in input array and each number has 3 ways to compute next state/node). Adding those out of bound (>1000 or < 0) nodes will just result in them being ignored later on, so the compute time is wasted. \\n\\t\\n\\t- The hashing cost for those extra nodes is NOT negligible. Hashing cost for integers is a constant, but when your data scale is small like in this question, using hashing will cost you evidently. Therefore, the avoidance of hashing those additional nodes is also critical. Generally, if the complexity of a problem is O(n), and we hash every item in the `n` scope, then we are doing `O(c*n)` and one should not believe this `c = 1` or some small number, it does not. You can easily find yourself in this situation: my boolean[] visited implementation costs 1ms while my hash set implementation costs 7ms to 10ms, why? The above is why.\\n\\n\\nCode is here, the implementation is not short and concise, but it should be very easy to read.\\nComplexity: N = 1000, O(V + E) = O(N + N*N*3) ~= O(N^2). For example, when the array is small, but we need to return -1, we will deal with N=1000 nodes in the BFS graph.\\n\\n```\\nclass Solution {\\n    // BFS path finder\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        Queue<Integer> bq = new LinkedList<>();\\n        bq.offer(start);\\n        boolean[] visited = new boolean[1001];\\n        \\n        int level = 0;\\n        // Corner handling cause we need to quit \\n        // when we found result at NEXT level.\\n        if (start == goal) return level;\\n        \\n        // Main logic.\\n        while (!bq.isEmpty()) {\\n            int levelSize = bq.size();\\n            for (int l = 0; l < levelSize; l++) {\\n                int cur = bq.poll();\\n                \\n                // Expand.\\n                for (int n : nums) {\\n                    if (cur + n == goal) return level + 1;\\n                    if (cur + n <= 1000 && cur + n >= 0 &&\\n                        !visited[cur + n]) {\\n                        bq.offer(cur + n);\\n                        visited[cur + n] = true;\\n                    }\\n                    \\n                    if (cur - n == goal) return level + 1;\\n                    if (cur - n <= 1000 && cur - n >= 0 &&\\n                        !visited[cur - n]) {\\n                        bq.offer(cur - n);\\n                        visited[cur - n] = true;\\n                    }\\n                    \\n                    if ((cur ^ n) == goal) return level + 1;\\n                    if ((cur ^ n) <= 1000 && (cur ^ n) >= 0 &&\\n                        !visited[cur ^ n]) {\\n                        bq.offer(cur ^ n);\\n                        visited[cur ^ n] = true;\\n                    }\\n                }\\n            }\\n            \\n            level += 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // BFS path finder\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        Queue<Integer> bq = new LinkedList<>();\\n        bq.offer(start);\\n        boolean[] visited = new boolean[1001];\\n        \\n        int level = 0;\\n        // Corner handling cause we need to quit \\n        // when we found result at NEXT level.\\n        if (start == goal) return level;\\n        \\n        // Main logic.\\n        while (!bq.isEmpty()) {\\n            int levelSize = bq.size();\\n            for (int l = 0; l < levelSize; l++) {\\n                int cur = bq.poll();\\n                \\n                // Expand.\\n                for (int n : nums) {\\n                    if (cur + n == goal) return level + 1;\\n                    if (cur + n <= 1000 && cur + n >= 0 &&\\n                        !visited[cur + n]) {\\n                        bq.offer(cur + n);\\n                        visited[cur + n] = true;\\n                    }\\n                    \\n                    if (cur - n == goal) return level + 1;\\n                    if (cur - n <= 1000 && cur - n >= 0 &&\\n                        !visited[cur - n]) {\\n                        bq.offer(cur - n);\\n                        visited[cur - n] = true;\\n                    }\\n                    \\n                    if ((cur ^ n) == goal) return level + 1;\\n                    if ((cur ^ n) <= 1000 && (cur ^ n) >= 0 &&\\n                        !visited[cur ^ n]) {\\n                        bq.offer(cur ^ n);\\n                        visited[cur ^ n] = true;\\n                    }\\n                }\\n            }\\n            \\n            level += 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550907,
                "title": "c-bfs-memoization",
                "content": "We can calculate the shortest path from `start` to `goal` with BFS. Since we have to perform operations on `x` only if `0 <= x <= 1000 && x != goal`, a queue storing number `0` to `1000` is sufficient and a `visited` array is used to keep track the visited numbers, avoiding duplicates.\\n\\n**Complexity**\\n\\nTime: `O(sum(visited)*n)`.\\nMemory: `O(m)`, where `m` is the size of range `x`.\\n\\n**Code**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<pair<int, int>> q ({ {start, 0} });\\n        bitset<1001> visited;\\n        while (!q.empty()) {\\n            auto [cur, dist] = q.front(); q.pop();\\n            for (const auto &n : nums) {\\n                int a = cur + n, b = cur - n, c = cur ^ n;\\n                for (auto &x : {a, b, c}) {\\n                    if (x == goal) return dist + 1;\\n                    if (x >= 0 && x <= 1000  && !visited[x]) {\\n                        q.push({ x, dist + 1 });\\n                        visited[x] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<pair<int, int>> q ({ {start, 0} });\\n        bitset<1001> visited;\\n        while (!q.empty()) {\\n            auto [cur, dist] = q.front(); q.pop();\\n            for (const auto &n : nums) {\\n                int a = cur + n, b = cur - n, c = cur ^ n;\\n                for (auto &x : {a, b, c}) {\\n                    if (x == goal) return dist + 1;\\n                    if (x >= 0 && x <= 1000  && !visited[x]) {\\n                        q.push({ x, dist + 1 });\\n                        visited[x] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550441,
                "title": "java-intuitive-bfs-solution",
                "content": "```\\nclass Solution {\\n    private static final int MAX = 1000;\\n    private static final int MIN = 0;\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        if(start == goal) {\\n            return 0;\\n        }\\n        final boolean[] visited = new boolean[MAX + 1];\\n        int steps = 0;\\n        final Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(start);\\n        while(!q.isEmpty()) {\\n            final int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                final int curr = q.poll();\\n                if(curr == goal) {\\n                    return steps;\\n                }\\n                if(visited[curr]) {\\n                    continue;\\n                }\\n                visited[curr] = true;\\n                for(final int num : nums) {\\n                    // before adding to the queue , we can check \\n                    // if new element is equal to goal\\n                    // if new element is between [0, 1000]\\n                    // not visited;\\n                    if(canBeAdded(curr + num, goal, visited)) {\\n                        q.offer(curr + num);\\n                    }\\n                    if(canBeAdded(curr - num, goal, visited)) {\\n                        q.offer(curr - num);\\n                    }\\n                    if(canBeAdded((curr ^ num), goal, visited)) {\\n                        q.offer((curr ^ num));\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean canBeAdded(final int x, final int goal, final boolean[] visited) {\\n        // before adding to the queue , we can check \\n            // if new element is equal to goal\\n            // if new element is between [0, 1000]\\n            // not visited;\\n        if(x == goal) {\\n            return true;\\n        }\\n        if(x < MIN || x > MAX) {\\n            return false;\\n        }\\n        if(visited[x]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int MAX = 1000;\\n    private static final int MIN = 0;\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        if(start == goal) {\\n            return 0;\\n        }\\n        final boolean[] visited = new boolean[MAX + 1];\\n        int steps = 0;\\n        final Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(start);\\n        while(!q.isEmpty()) {\\n            final int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                final int curr = q.poll();\\n                if(curr == goal) {\\n                    return steps;\\n                }\\n                if(visited[curr]) {\\n                    continue;\\n                }\\n                visited[curr] = true;\\n                for(final int num : nums) {\\n                    // before adding to the queue , we can check \\n                    // if new element is equal to goal\\n                    // if new element is between [0, 1000]\\n                    // not visited;\\n                    if(canBeAdded(curr + num, goal, visited)) {\\n                        q.offer(curr + num);\\n                    }\\n                    if(canBeAdded(curr - num, goal, visited)) {\\n                        q.offer(curr - num);\\n                    }\\n                    if(canBeAdded((curr ^ num), goal, visited)) {\\n                        q.offer((curr ^ num));\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean canBeAdded(final int x, final int goal, final boolean[] visited) {\\n        // before adding to the queue , we can check \\n            // if new element is equal to goal\\n            // if new element is between [0, 1000]\\n            // not visited;\\n        if(x == goal) {\\n            return true;\\n        }\\n        if(x < MIN || x > MAX) {\\n            return false;\\n        }\\n        if(visited[x]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550285,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) \\n    {\\n        queue<int> que;\\n        que.push(start); \\n        vector<int> visit(1001, 0); \\n        int level = 0;\\n        \\n        while(!que.empty()) {\\n            int size = que.size(); \\n            for(int i=0; i<size; i++) {\\n                int curr = que.front(); \\n                que.pop();\\n                if(curr == goal)\\n                    return level; \\n                if(curr<0 || curr>1000 || visit[curr] == 1)\\n                    continue; \\n                visit[curr] = 1; \\n                for(int i=0; i< nums.size(); i++) {\\n                    que.push(curr + nums[i]);\\n                    que.push(curr - nums[i]); \\n                    que.push(curr ^ nums[i]);                    \\n                }\\n            }\\n            level++; \\n        }\\n        return -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) \\n    {\\n        queue<int> que;\\n        que.push(start); \\n        vector<int> visit(1001, 0); \\n        int level = 0;\\n        \\n        while(!que.empty()) {\\n            int size = que.size(); \\n            for(int i=0; i<size; i++) {\\n                int curr = que.front(); \\n                que.pop();\\n                if(curr == goal)\\n                    return level; \\n                if(curr<0 || curr>1000 || visit[curr] == 1)\\n                    continue; \\n                visit[curr] = 1; \\n                for(int i=0; i< nums.size(); i++) {\\n                    que.push(curr + nums[i]);\\n                    que.push(curr - nums[i]); \\n                    que.push(curr ^ nums[i]);                    \\n                }\\n            }\\n            level++; \\n        }\\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550174,
                "title": "java-bfs-with-visited-array",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        boolean[] visited = new boolean[1001];\\n        int res=0;\\n        queue.offer(start);\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                int val = queue.poll();\\n                if(val==goal) return res;\\n                if(!(val>=0 && val<=1000) || visited[val]){\\n                    continue;\\n                }\\n                if(!visited[val]) visited[val]=true;\\n                for(int num : nums){\\n                    queue.offer(val+num);\\n                    queue.offer(val-num);\\n                    queue.offer(val^num);\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        boolean[] visited = new boolean[1001];\\n        int res=0;\\n        queue.offer(start);\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                int val = queue.poll();\\n                if(val==goal) return res;\\n                if(!(val>=0 && val<=1000) || visited[val]){\\n                    continue;\\n                }\\n                if(!visited[val]) visited[val]=true;\\n                for(int num : nums){\\n                    queue.offer(val+num);\\n                    queue.offer(val-num);\\n                    queue.offer(val^num);\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550107,
                "title": "why-would-adding-invalid-number-to-queue-and-skipping-it-lead-to-tle",
                "content": "My solution leads to TLE. After comparing it to the accepted solutions, I find the only difference is I put invalid numbers to queue and then skip them in the next iteration while accepted solutions do not put invalid numbers to queue. I admit that is an optimization.  But the time complexity should be the same. Does the time constraint have to be so strict?\\n\\nHere is my solution\\n```\\npublic int minimumOperations(int[] nums, int start, int goal) {\\n        Set<Integer> set = new HashSet<Integer>();\\n        int step = 0;\\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        queue.add(start);\\n        set.add(start);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int number = queue.poll();\\n                if (number > 1000 || number < 0)\\n                    continue;\\n                for (int j = 0; j < nums.length; j++) {\\n                    if (number + nums[j] == goal) {\\n                        return step + 1;\\n                    }\\n                    if (!set.contains(number + nums[j])) {\\n                        queue.add(number + nums[j]);\\n                        set.add(number + nums[j]);\\n                    }\\n                    if (number - nums[j] == goal) {\\n                        return step + 1;\\n                    }\\n                    if (!set.contains(number - nums[j])) {\\n                        queue.add(number - nums[j]);\\n                        set.add(number - nums[j]);\\n                    }\\n                    if ((number ^ nums[j]) == goal) {\\n                        return step + 1;\\n                    }\\n                    if (!set.contains(number ^ nums[j])) {\\n                        set.add(number ^ nums[j]);\\n                        queue.add(number ^ nums[j]);\\n                }\\n            }\\n        }\\n            step++;\\n    }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minimumOperations(int[] nums, int start, int goal) {\\n        Set<Integer> set = new HashSet<Integer>();\\n        int step = 0;\\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        queue.add(start);\\n        set.add(start);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int number = queue.poll();\\n                if (number > 1000 || number < 0)\\n                    continue;\\n                for (int j = 0; j < nums.length; j++) {\\n                    if (number + nums[j] == goal) {\\n                        return step + 1;\\n                    }\\n                    if (!set.contains(number + nums[j])) {\\n                        queue.add(number + nums[j]);\\n                        set.add(number + nums[j]);\\n                    }\\n                    if (number - nums[j] == goal) {\\n                        return step + 1;\\n                    }\\n                    if (!set.contains(number - nums[j])) {\\n                        queue.add(number - nums[j]);\\n                        set.add(number - nums[j]);\\n                    }\\n                    if ((number ^ nums[j]) == goal) {\\n                        return step + 1;\\n                    }\\n                    if (!set.contains(number ^ nums[j])) {\\n                        set.add(number ^ nums[j]);\\n                        queue.add(number ^ nums[j]);\\n                }\\n            }\\n        }\\n            step++;\\n    }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076809,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& v, int start, int goal) {\\n        if(start==goal) return 0;\\n        vector<bool>visited(1001, false);\\n        queue<int>q;\\n        q.push(start);\\n        visited[start]=true;\\n        int steps=0;\\n        \\n        while(!q.empty()) {\\n            steps++;\\n            int len=q.size();\\n            for(int i=0;i<len;i++) {\\n                int curr=q.front();\\n                q.pop();\\n                for(int&num:v) {\\n                    if(curr+num==goal || curr-num==goal || (curr^num)==goal) return steps;\\n                    int val=curr+num;\\n                    if(val>=0 && val<=1000 && visited[val]==false) {\\n                        q.push(val);\\n                        visited[val]=true;\\n                    }\\n                    val=curr-num;\\n                    if(val>=0 && val<=1000 && visited[val]==false) {\\n                        q.push(val);\\n                        visited[val]=true;\\n                    }\\n                    val=curr^num;\\n                    if(val>=0 && val<=1000 && visited[val]==false) {\\n                        q.push(val);\\n                        visited[val]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& v, int start, int goal) {\\n        if(start==goal) return 0;\\n        vector<bool>visited(1001, false);\\n        queue<int>q;\\n        q.push(start);\\n        visited[start]=true;\\n        int steps=0;\\n        \\n        while(!q.empty()) {\\n            steps++;\\n            int len=q.size();\\n            for(int i=0;i<len;i++) {\\n                int curr=q.front();\\n                q.pop();\\n                for(int&num:v) {\\n                    if(curr+num==goal || curr-num==goal || (curr^num)==goal) return steps;\\n                    int val=curr+num;\\n                    if(val>=0 && val<=1000 && visited[val]==false) {\\n                        q.push(val);\\n                        visited[val]=true;\\n                    }\\n                    val=curr-num;\\n                    if(val>=0 && val<=1000 && visited[val]==false) {\\n                        q.push(val);\\n                        visited[val]=true;\\n                    }\\n                    val=curr^num;\\n                    if(val>=0 && val<=1000 && visited[val]==false) {\\n                        q.push(val);\\n                        visited[val]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069827,
                "title": "complete-bfs-solution-in-c-no-use-of-size-only-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n=nums.size();\\n        int ans=0;\\n        queue<pair<int,int>> q;\\n        q.push({start,0});\\n        vector<bool> visited(1001,false);\\n        visited[start]=true;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n            for(int i=0; i<n; i++){\\n                int a=p.first-nums[i], b=p.first+nums[i], c=p.first^nums[i];\\n                if(a==goal||b==goal||c==goal)   return p.second+1;\\n                if((a>=0 && a<=1000) && !visited[a]){\\n                    q.push({a,p.second+1});\\n                    visited[a]=true;\\n                }\\n                if((b>=0 && b<=1000) && !visited[b]){\\n                    q.push({b,p.second+1});\\n                    visited[b]=true;\\n                }\\n                if((c>=0 && c<=1000) && !visited[c]){\\n                    q.push({c,p.second+1});\\n                    visited[c]=true;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n=nums.size();\\n        int ans=0;\\n        queue<pair<int,int>> q;\\n        q.push({start,0});\\n        vector<bool> visited(1001,false);\\n        visited[start]=true;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n            for(int i=0; i<n; i++){\\n                int a=p.first-nums[i], b=p.first+nums[i], c=p.first^nums[i];\\n                if(a==goal||b==goal||c==goal)   return p.second+1;\\n                if((a>=0 && a<=1000) && !visited[a]){\\n                    q.push({a,p.second+1});\\n                    visited[a]=true;\\n                }\\n                if((b>=0 && b<=1000) && !visited[b]){\\n                    q.push({b,p.second+1});\\n                    visited[b]=true;\\n                }\\n                if((c>=0 && c<=1000) && !visited[c]){\\n                    q.push({c,p.second+1});\\n                    visited[c]=true;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067285,
                "title": "bfs-cpp",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. --> Just doing BFS\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<pair<int,int>>q;\\n        //num level\\n        q.push({start,0});\\n        vector<bool>visited(1001,false);\\n        visited[start]=true;\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            q.pop();\\n            int num=p.first;\\n            int lvl=p.second;\\n            for(auto i:nums)\\n            {\\n                int val=num+i;\\n                if(val==goal) return lvl+1;\\n                if(val>=0 and val<1001 and !visited[val])\\n                {\\n                  q.push({val,lvl+1});\\n                  visited[val]=true;\\n                }\\n                val=num-i;\\n                if(val==goal) return lvl+1;\\n                if(val>=0 and val<1001 and !visited[val])\\n                {\\n                  q.push({val,lvl+1});\\n                  visited[val]=true;\\n                }\\n                val=num^i;\\n                if(val==goal) return lvl+1;\\n                if(val>=0 and val<1001 and !visited[val])\\n                {\\n                  q.push({val,lvl+1});\\n                  visited[val]=true;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<pair<int,int>>q;\\n        //num level\\n        q.push({start,0});\\n        vector<bool>visited(1001,false);\\n        visited[start]=true;\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            q.pop();\\n            int num=p.first;\\n            int lvl=p.second;\\n            for(auto i:nums)\\n            {\\n                int val=num+i;\\n                if(val==goal) return lvl+1;\\n                if(val>=0 and val<1001 and !visited[val])\\n                {\\n                  q.push({val,lvl+1});\\n                  visited[val]=true;\\n                }\\n                val=num-i;\\n                if(val==goal) return lvl+1;\\n                if(val>=0 and val<1001 and !visited[val])\\n                {\\n                  q.push({val,lvl+1});\\n                  visited[val]=true;\\n                }\\n                val=num^i;\\n                if(val==goal) return lvl+1;\\n                if(val>=0 and val<1001 and !visited[val])\\n                {\\n                  q.push({val,lvl+1});\\n                  visited[val]=true;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999982,
                "title": "simple-c-solution-using-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        vector<int> vis(1001);\\n        queue<int> q;\\n        q.push(start);\\n        vis[start]=1;\\n        int ans=0;\\n        while(q.size())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                int x=q.front();\\n                q.pop();\\n                for(auto i:nums)\\n                {\\n                    int a=x+i;\\n                    int b=x-i;\\n                    int c=x^i;\\n                    if(a==goal||b==goal||c==goal)\\n                        return ans+1;\\n                    if(a<=1000&&a>=0&&!vis[a])\\n                    {\\n                        q.push(a);\\n                        vis[a]=1;\\n                    }\\n                    if(b<=1000&&b>=0&&!vis[b])\\n                    {\\n                        q.push(b);\\n                        vis[b]=1;\\n                    }\\n                    if(c<=1000&&c>=0&&!vis[c])\\n                    {\\n                        q.push(c);\\n                        vis[c]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        vector<int> vis(1001);\\n        queue<int> q;\\n        q.push(start);\\n        vis[start]=1;\\n        int ans=0;\\n        while(q.size())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                int x=q.front();\\n                q.pop();\\n                for(auto i:nums)\\n                {\\n                    int a=x+i;\\n                    int b=x-i;\\n                    int c=x^i;\\n                    if(a==goal||b==goal||c==goal)\\n                        return ans+1;\\n                    if(a<=1000&&a>=0&&!vis[a])\\n                    {\\n                        q.push(a);\\n                        vis[a]=1;\\n                    }\\n                    if(b<=1000&&b>=0&&!vis[b])\\n                    {\\n                        q.push(b);\\n                        vis[b]=1;\\n                    }\\n                    if(c<=1000&&c>=0&&!vis[c])\\n                    {\\n                        q.push(c);\\n                        vis[c]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834375,
                "title": "cleanest-c-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        vector<int> vis(1001);\\n        queue<pair<int,int>> q;\\n        q.push({start,0});\\n        while(!q.empty()){\\n            auto it = q.front();\\n            int num = it.first;\\n            int dist = it.second;\\n            q.pop();\\n            if(num==goal) return dist;\\n            for(int i=0;i<nums.size();i++){\\n                if(num>=0 && num<=1000 && !vis[num]){\\n                    q.push({num + nums[i],dist + 1});\\n                    q.push({num - nums[i],dist + 1});\\n                    q.push({num ^ nums[i],dist + 1});\\n                }else break;\\n            }\\n            if(num>=0 && num<=1000) vis[num] = 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        vector<int> vis(1001);\\n        queue<pair<int,int>> q;\\n        q.push({start,0});\\n        while(!q.empty()){\\n            auto it = q.front();\\n            int num = it.first;\\n            int dist = it.second;\\n            q.pop();\\n            if(num==goal) return dist;\\n            for(int i=0;i<nums.size();i++){\\n                if(num>=0 && num<=1000 && !vis[num]){\\n                    q.push({num + nums[i],dist + 1});\\n                    q.push({num - nums[i],dist + 1});\\n                    q.push({num ^ nums[i],dist + 1});\\n                }else break;\\n            }\\n            if(num>=0 && num<=1000) vis[num] = 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735855,
                "title": "c-bfs-add-sub-and-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\tclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> q;\\n        int n = nums.size();\\n        q.push(start);\\n        int ans = 0;\\n        unordered_set<int> vis;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                int curr = q.front();\\n                q.pop();\\n                if(curr == goal) return ans;\\n                if(curr < 0 or curr > 1000 or  vis.count(curr)!=0 ) continue;\\n                vis.insert(curr);\\n                for(int i=0;i<n;i++){\\n                    int add = curr + nums[i];\\n                    int sub = curr - nums[i];\\n                    int xxor = curr ^ nums[i];\\n                    q.push(add);\\n                    q.push(sub);\\n                    q.push(xxor);\\n                }\\n            }\\n            ans++;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> q;\\n        int n = nums.size();\\n        q.push(start);\\n        int ans = 0;\\n        unordered_set<int> vis;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                int curr = q.front();\\n                q.pop();\\n                if(curr == goal) return ans;\\n                if(curr < 0 or curr > 1000 or  vis.count(curr)!=0 ) continue;\\n                vis.insert(curr);\\n                for(int i=0;i<n;i++){\\n                    int add = curr + nums[i];\\n                    int sub = curr - nums[i];\\n                    int xxor = curr ^ nums[i];\\n                    q.push(add);\\n                    q.push(sub);\\n                    q.push(xxor);\\n                }\\n            }\\n            ans++;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588839,
                "title": "c-bfs-beats-100-space-and-90-time",
                "content": "# Intuition and Approach\\nThis can be treated as a graph problem where each number as a node. There exists an edge (v,w) if v can be changed to w through one maong the 3 operations.\\nWe can get shorted path from start node to end node using simple BFS (since it\\'ll be an unweighted graph because each of the operations are of equal value).\\nAll the nodes with values less than 0 or greater than 1000 are dead ends, no edges will be originate from them.\\nThe amount of operations need to be performed are stored in the visited array.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int vis[1001];\\n        memset(vis,-1,sizeof(vis));//initializing all to -1\\n        queue<int> q;\\n        q.push(start);\\n        vis[start]=0;// 0 operations performed to reach start from start\\n        while(!q.empty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                int x=q.front();q.pop();\\n                if(x<0 || x>1000) continue;\\n                for(auto num:nums){\\n                    int a=x+num,b=x-num,c=x^num;\\n                    //if goal is achieved using one of the operations then return 1+number of operations required to reach x\\n                    if(a==goal || b==goal || c==goal) return vis[x]+1;\\n                    if(a>=0 && a<=1000 && vis[a]==-1){\\n                        q.push(a);vis[a]=vis[x]+1;\\n                    }\\n                    if(b>=0 && b<=1000 && vis[b]==-1){\\n                        q.push(b);vis[b]=vis[x]+1;\\n                    }\\n                    if(c>=0 && c<=1000 && vis[c]==-1){\\n                        q.push(c);vis[c]=vis[x]+1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int vis[1001];\\n        memset(vis,-1,sizeof(vis));//initializing all to -1\\n        queue<int> q;\\n        q.push(start);\\n        vis[start]=0;// 0 operations performed to reach start from start\\n        while(!q.empty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                int x=q.front();q.pop();\\n                if(x<0 || x>1000) continue;\\n                for(auto num:nums){\\n                    int a=x+num,b=x-num,c=x^num;\\n                    //if goal is achieved using one of the operations then return 1+number of operations required to reach x\\n                    if(a==goal || b==goal || c==goal) return vis[x]+1;\\n                    if(a>=0 && a<=1000 && vis[a]==-1){\\n                        q.push(a);vis[a]=vis[x]+1;\\n                    }\\n                    if(b>=0 && b<=1000 && vis[b]==-1){\\n                        q.push(b);vis[b]=vis[x]+1;\\n                    }\\n                    if(c>=0 && c<=1000 && vis[c]==-1){\\n                        q.push(c);vis[c]=vis[x]+1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547812,
                "title": "c-python-bfs-solution-with-explanation",
                "content": "we can use bfs to search ```goal``` with the operation problem mentioned.\\nand use an array ```seen``` to record which number we have seen to avoid visiting it again.\\n\\ntc is O(n), sc is O(n).\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        deque<int> q (1, start);\\n        bool seen[1001] {false};\\n        seen[start] = true;\\n        int step = 0;\\n        while (! q.empty()) {\\n            step += 1;\\n            for (int i = 0, size = q.size(); i < size; i+=1) {\\n                int cur = q.front(); q.pop_front();\\n                for (int& n: nums) {\\n                    if (cur + n == goal || cur - n == goal || (cur ^ n) == goal) return step;\\n                    if (cur + n >= 0 && cur + n <= 1000 && ! seen[cur + n]) {\\n                        seen[cur + n] = true;\\n                        q.emplace_back(cur + n);\\n                    }\\n                    if (cur - n >= 0 && cur - n <= 1000 && ! seen[cur - n]) {\\n                        seen[cur - n] = true;\\n                        q.emplace_back(cur - n);\\n                    }\\n                    if ((cur ^ n) >= 0 && (cur ^ n) <= 1000 && ! seen[cur ^ n]) {\\n                        seen[cur ^ n] = true;\\n                        q.emplace_back(cur ^ n);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n### python\\n```python\\nfrom collections import deque\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        q = deque([start])\\n        step = 0\\n        seen = [False] * 1001\\n        seen[start] = True\\n        while q:\\n            step += 1\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                for n in nums:\\n                    if (cur + n == goal) or (cur - n == goal) or (cur ^ n == goal): return step\\n                    if 0 <= cur + n <= 1000 and not seen[cur + n]:\\n                        seen[cur + n] = True\\n                        q.append(cur + n)\\n                    if 0 <= cur - n <= 1000 and not seen[cur - n]:\\n                        seen[cur - n] = True\\n                        q.append(cur - n)\\n                    if 0 <= cur ^ n <= 1000 and not seen[cur ^ n]:\\n                        seen[cur ^ n] = True\\n                        q.append(cur ^ n)\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```goal```\n```seen```\n```cpp\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        deque<int> q (1, start);\\n        bool seen[1001] {false};\\n        seen[start] = true;\\n        int step = 0;\\n        while (! q.empty()) {\\n            step += 1;\\n            for (int i = 0, size = q.size(); i < size; i+=1) {\\n                int cur = q.front(); q.pop_front();\\n                for (int& n: nums) {\\n                    if (cur + n == goal || cur - n == goal || (cur ^ n) == goal) return step;\\n                    if (cur + n >= 0 && cur + n <= 1000 && ! seen[cur + n]) {\\n                        seen[cur + n] = true;\\n                        q.emplace_back(cur + n);\\n                    }\\n                    if (cur - n >= 0 && cur - n <= 1000 && ! seen[cur - n]) {\\n                        seen[cur - n] = true;\\n                        q.emplace_back(cur - n);\\n                    }\\n                    if ((cur ^ n) >= 0 && (cur ^ n) <= 1000 && ! seen[cur ^ n]) {\\n                        seen[cur ^ n] = true;\\n                        q.emplace_back(cur ^ n);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```python\\nfrom collections import deque\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        q = deque([start])\\n        step = 0\\n        seen = [False] * 1001\\n        seen[start] = True\\n        while q:\\n            step += 1\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                for n in nums:\\n                    if (cur + n == goal) or (cur - n == goal) or (cur ^ n == goal): return step\\n                    if 0 <= cur + n <= 1000 and not seen[cur + n]:\\n                        seen[cur + n] = True\\n                        q.append(cur + n)\\n                    if 0 <= cur - n <= 1000 and not seen[cur - n]:\\n                        seen[cur - n] = True\\n                        q.append(cur - n)\\n                    if 0 <= cur ^ n <= 1000 and not seen[cur ^ n]:\\n                        seen[cur ^ n] = True\\n                        q.append(cur ^ n)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539998,
                "title": "go-bfs",
                "content": "# Code\\n```\\nfunc minimumOperations(nums []int, start int, goal int) int {\\n    ans := 0\\n    queue := make([]int, 0, 1000)\\n    queue = append(queue, start)\\n    visited := make(map[int]bool, 1000)\\n\\n    for len(queue) > 0 {\\n        size := len(queue)\\n        for i := 0; i < size; i++ {\\n            x := queue[i]\\n            if x == goal {\\n                return ans\\n            }\\n            if x < 0 || x > 1000 || visited[x] {\\n                continue\\n            }\\n            visited[x] = true\\n            for _, num := range nums {\\n                queue = append(queue, x+num)\\n                queue = append(queue, x-num)\\n                queue = append(queue, x^num)\\n            }\\n        }\\n        queue = queue[size:]\\n        ans++\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumOperations(nums []int, start int, goal int) int {\\n    ans := 0\\n    queue := make([]int, 0, 1000)\\n    queue = append(queue, start)\\n    visited := make(map[int]bool, 1000)\\n\\n    for len(queue) > 0 {\\n        size := len(queue)\\n        for i := 0; i < size; i++ {\\n            x := queue[i]\\n            if x == goal {\\n                return ans\\n            }\\n            if x < 0 || x > 1000 || visited[x] {\\n                continue\\n            }\\n            visited[x] = true\\n            for _, num := range nums {\\n                queue = append(queue, x+num)\\n                queue = append(queue, x-num)\\n                queue = append(queue, x^num)\\n            }\\n        }\\n        queue = queue[size:]\\n        ans++\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526929,
                "title": "bfs-c-solution-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\nconst long long mod = 1e9 + 7;\\nconst double PI = acos(-1.0);\\n#define IOS ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);\\n#define ll long long\\n#define ve vector<int>\\n#define graph vector<ve>\\n#define tc          ll testcase;   cin>>testcase;   while(testcase--)\\n#define all(num)      (num).begin(), (num).end()\\n\\n//             \"\\u0648\\u064E\\u0623\\u064E\\u0646 \\u0644\\u0651\\u064E\\u064A\\u0652\\u0633\\u064E \\u0644\\u0650\\u0644\\u0652\\u0625\\u0650\\u0646\\u0633\\u064E\\u0627\\u0646\\u0650 \\u0625\\u0650\\u0644\\u0651\\u064E\\u0627 \\u0645\\u064E\\u0627 \\u0633\\u064E\\u0639\\u064E\\u0649 \\uFD3F39\\uFD3E \\u0648\\u064E\\u0623\\u064E\\u0646\\u0651\\u064E \\u0633\\u064E\\u0639\\u0652\\u064A\\u064E\\u0647\\u064F \\u0633\\u064E\\u0648\\u0652\\u0641\\u064E \\u064A\\u064F\\u0631\\u064E\\u0649 \\uFD3F40\\uFD3E \\u062B\\u064F\\u0645\\u0651\\u064E \\u064A\\u064F\\u062C\\u0652\\u0632\\u064E\\u0627\\u0647\\u064F \\u0627\\u0644\\u0652\\u062C\\u064E\\u0632\\u064E\\u0627\\u0621 \\u0627\\u0644\\u0652\\u0623\\u064E\\u0648\\u0652\\u0641\\u064E\\u0649 \"\\n//                                  My way to My dream\\n//#ifdef ONLINE_JUDGE\\n//    freopen(\"input.txt\", \"r\", stdin);\\n//    freopen(\"output.txt\", \"w\", stdout);\\n//#endif\\n//////////////////////////////////////////////////////////////////////////////////////////////////\\nclass Solution {\\npublic:\\nll n ;\\nint BFS(ve &v , ll start , ll goal)\\n{\\n    queue<ll> q ;\\nvector<bool>vis(1001, 0);\\nq.push(start);\\nvis[start]=1;\\n    int ans = 0 ;\\nwhile (!q.empty())\\n{\\n    ans ++ ;\\n    ll sz= q.size();\\n    for (int i = 0; i < sz; ++i) {\\n        ll node = q.front();\\n        q.pop();\\n        for(auto x : v){\\n            if(node + x == goal)\\n                return ans;\\n            if(node + x >=0 && node + x <= 1000 && !vis[node +  x ]) {\\n                vis[node + x] = 1;\\n                q.push(node + x);\\n            }\\n            if(node - x == goal)\\n                return ans;\\n            if(node - x >=0 && node - x <= 1000 && !vis[node -  x ]) {\\n                q.push(node - x);\\n                vis[node - x] = 1;\\n            }\\n            if((node ^ x) == goal)\\n                return ans;\\n            if((node ^ x) >=0 && (node ^ x) <= 1000 && !vis[(node ^ x)]) {\\n                q.push((node ^ x));\\n                vis[(node ^ x)] = 1;\\n            }\\n        }\\n\\n    }\\n}\\n    return -1;\\n}\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n       return BFS(nums , start , goal);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\nconst long long mod = 1e9 + 7;\\nconst double PI = acos(-1.0);\\n#define IOS ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);\\n#define ll long long\\n#define ve vector<int>\\n#define graph vector<ve>\\n#define tc          ll testcase;   cin>>testcase;   while(testcase--)\\n#define all(num)      (num).begin(), (num).end()\\n\\n//             \"\\u0648\\u064E\\u0623\\u064E\\u0646 \\u0644\\u0651\\u064E\\u064A\\u0652\\u0633\\u064E \\u0644\\u0650\\u0644\\u0652\\u0625\\u0650\\u0646\\u0633\\u064E\\u0627\\u0646\\u0650 \\u0625\\u0650\\u0644\\u0651\\u064E\\u0627 \\u0645\\u064E\\u0627 \\u0633\\u064E\\u0639\\u064E\\u0649 \\uFD3F39\\uFD3E \\u0648\\u064E\\u0623\\u064E\\u0646\\u0651\\u064E \\u0633\\u064E\\u0639\\u0652\\u064A\\u064E\\u0647\\u064F \\u0633\\u064E\\u0648\\u0652\\u0641\\u064E \\u064A\\u064F\\u0631\\u064E\\u0649 \\uFD3F40\\uFD3E \\u062B\\u064F\\u0645\\u0651\\u064E \\u064A\\u064F\\u062C\\u0652\\u0632\\u064E\\u0627\\u0647\\u064F \\u0627\\u0644\\u0652\\u062C\\u064E\\u0632\\u064E\\u0627\\u0621 \\u0627\\u0644\\u0652\\u0623\\u064E\\u0648\\u0652\\u0641\\u064E\\u0649 \"\\n//                                  My way to My dream\\n//#ifdef ONLINE_JUDGE\\n//    freopen(\"input.txt\", \"r\", stdin);\\n//    freopen(\"output.txt\", \"w\", stdout);\\n//#endif\\n//////////////////////////////////////////////////////////////////////////////////////////////////\\nclass Solution {\\npublic:\\nll n ;\\nint BFS(ve &v , ll start , ll goal)\\n{\\n    queue<ll> q ;\\nvector<bool>vis(1001, 0);\\nq.push(start);\\nvis[start]=1;\\n    int ans = 0 ;\\nwhile (!q.empty())\\n{\\n    ans ++ ;\\n    ll sz= q.size();\\n    for (int i = 0; i < sz; ++i) {\\n        ll node = q.front();\\n        q.pop();\\n        for(auto x : v){\\n            if(node + x == goal)\\n                return ans;\\n            if(node + x >=0 && node + x <= 1000 && !vis[node +  x ]) {\\n                vis[node + x] = 1;\\n                q.push(node + x);\\n            }\\n            if(node - x == goal)\\n                return ans;\\n            if(node - x >=0 && node - x <= 1000 && !vis[node -  x ]) {\\n                q.push(node - x);\\n                vis[node - x] = 1;\\n            }\\n            if((node ^ x) == goal)\\n                return ans;\\n            if((node ^ x) >=0 && (node ^ x) <= 1000 && !vis[(node ^ x)]) {\\n                q.push((node ^ x));\\n                vis[(node ^ x)] = 1;\\n            }\\n        }\\n\\n    }\\n}\\n    return -1;\\n}\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n       return BFS(nums , start , goal);\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3484344,
                "title": "python3-clean-bfs-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, target: int) -> int:\\n        \\n        \\n        q=deque()\\n        q.append(start)\\n        seen=set([start])\\n        steps=0\\n        \\n        while q:\\n            \\n            for i in range(len(q)):\\n                node=q.popleft()\\n                if node==target:\\n                    return steps\\n                \\n                if not 0<=node<=1000:\\n                    continue\\n                \\n                for val in nums:\\n                    if node+val not in seen:\\n                        seen.add(node+val)\\n                        q.append(node+val)\\n                        \\n                    if node-val not in seen:\\n                        seen.add(node-val)\\n                        q.append(node-val)\\n                    \\n                    if node^val not in seen:\\n                        seen.add(node^val)\\n                        q.append(node^val)\\n            \\n            steps+=1\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, target: int) -> int:\\n        \\n        \\n        q=deque()\\n        q.append(start)\\n        seen=set([start])\\n        steps=0\\n        \\n        while q:\\n            \\n            for i in range(len(q)):\\n                node=q.popleft()\\n                if node==target:\\n                    return steps\\n                \\n                if not 0<=node<=1000:\\n                    continue\\n                \\n                for val in nums:\\n                    if node+val not in seen:\\n                        seen.add(node+val)\\n                        q.append(node+val)\\n                        \\n                    if node-val not in seen:\\n                        seen.add(node-val)\\n                        q.append(node-val)\\n                    \\n                    if node^val not in seen:\\n                        seen.add(node^val)\\n                        q.append(node^val)\\n            \\n            steps+=1\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455329,
                "title": "easy-to-understand-solution-using-bfs-in-c",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MinimumOperations(int[] nums, int start, int goal) {\\n        HashSet<int> map = new HashSet<int>();\\n        Queue<(int x, int count, int or)> q = new Queue<(int, int, int)>();\\n        if(start < 0 || start > 1000){\\n            q.Enqueue((start, 0, 1));\\n        }\\n        else\\n            q.Enqueue((start, 0, 0));\\n        while(q.Count > 0){\\n        \\n            int x = q.Peek().x;\\n            int count = q.Peek().count;\\n            int or = q.Peek().or; \\n            if(x == goal) return count;\\n            q.Dequeue();\\n\\n            if(or >= 1) continue;\\n            \\n \\n            if(map.Contains(x)) continue;\\n            map.Add(x);\\n            for(int i=0;i < nums.Length;i++){\\n                //\\n                \\n                int op1 = nums[i] + x;\\n                int op2 = x - nums[i];\\n                int op3 = x ^ nums[i];\\n                if(op1 < 0 || op1 > 1000){\\n                    q.Enqueue((op1, count+1, or + 1));\\n                }\\n                else\\n                    q.Enqueue((op1 , count+1, or));\\n                if(op2 < 0 || op2 > 1000){\\n                    q.Enqueue((op2, count+1, or + 1));\\n                }\\n                else\\n                    q.Enqueue((op2 , count+1, or));\\n                if(op3 < 0 || op3 > 1000){\\n                    q.Enqueue((op3, count+1, or + 1));\\n                }\\n                else\\n                    q.Enqueue((op3 , count+1, or));\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumOperations(int[] nums, int start, int goal) {\\n        HashSet<int> map = new HashSet<int>();\\n        Queue<(int x, int count, int or)> q = new Queue<(int, int, int)>();\\n        if(start < 0 || start > 1000){\\n            q.Enqueue((start, 0, 1));\\n        }\\n        else\\n            q.Enqueue((start, 0, 0));\\n        while(q.Count > 0){\\n        \\n            int x = q.Peek().x;\\n            int count = q.Peek().count;\\n            int or = q.Peek().or; \\n            if(x == goal) return count;\\n            q.Dequeue();\\n\\n            if(or >= 1) continue;\\n            \\n \\n            if(map.Contains(x)) continue;\\n            map.Add(x);\\n            for(int i=0;i < nums.Length;i++){\\n                //\\n                \\n                int op1 = nums[i] + x;\\n                int op2 = x - nums[i];\\n                int op3 = x ^ nums[i];\\n                if(op1 < 0 || op1 > 1000){\\n                    q.Enqueue((op1, count+1, or + 1));\\n                }\\n                else\\n                    q.Enqueue((op1 , count+1, or));\\n                if(op2 < 0 || op2 > 1000){\\n                    q.Enqueue((op2, count+1, or + 1));\\n                }\\n                else\\n                    q.Enqueue((op2 , count+1, or));\\n                if(op3 < 0 || op3 > 1000){\\n                    q.Enqueue((op3, count+1, or + 1));\\n                }\\n                else\\n                    q.Enqueue((op3 , count+1, or));\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424337,
                "title": "js-bfs-beast-100",
                "content": "# Intuition\\nJust do simple BFS and maintain a visited array to keep track of numbers that we have seen already.\\n\\n# Approach\\nBFS\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1000num + 1000queue)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minimumOperations = function (nums, start, goal) {\\n  const q = [];\\n  const seen = new Set();\\n  q.push([start, 0]);\\n  seen.add(start);\\n  let front = 0;\\n\\n  const operations = [\\n    (n, m) => n + m,\\n    (n, m) => n - m,\\n    (n, m) => n ^ m,\\n  ];\\n\\n  while (front < q.length) {\\n    let length = q.length - front;\\n\\n    while (length > 0) {\\n      let [num, steps] = q[front];\\n      front++;\\n      length--;\\n\\n      for (const operation of operations) {\\n        for (const n of nums) {\\n          const newNum = operation(num, n);\\n\\n          if (newNum === goal) {\\n            return steps + 1;\\n          }\\n\\n          if (0 <= newNum && newNum <= 1000 && !seen.has(newNum)) {\\n            seen.add(newNum);\\n            q.push([newNum, steps + 1]);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minimumOperations = function (nums, start, goal) {\\n  const q = [];\\n  const seen = new Set();\\n  q.push([start, 0]);\\n  seen.add(start);\\n  let front = 0;\\n\\n  const operations = [\\n    (n, m) => n + m,\\n    (n, m) => n - m,\\n    (n, m) => n ^ m,\\n  ];\\n\\n  while (front < q.length) {\\n    let length = q.length - front;\\n\\n    while (length > 0) {\\n      let [num, steps] = q[front];\\n      front++;\\n      length--;\\n\\n      for (const operation of operations) {\\n        for (const n of nums) {\\n          const newNum = operation(num, n);\\n\\n          if (newNum === goal) {\\n            return steps + 1;\\n          }\\n\\n          if (0 <= newNum && newNum <= 1000 && !seen.has(newNum)) {\\n            seen.add(newNum);\\n            q.push([newNum, steps + 1]);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3410457,
                "title": "c-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> Queue;\\n        Queue.push(start);\\n        int ans = 0;\\n        vector<bool> visited(1001);\\n        visited[start] = true;\\n        while(!Queue.empty()) {\\n            ans++;\\n            int sz = Queue.size();\\n            for(int i = 0; i < sz; i++) {\\n                int curr = Queue.front();\\n                Queue.pop();\\n                for(int val: nums) {\\n                    int next1 = curr + val;\\n                    int next2 = curr - val;\\n                    int next3 = curr ^ val;\\n                    if(next1 == goal || next2 == goal || next3 == goal) return ans;\\n                    if(0 <= next1 && next1 <= 1000 && !visited[next1]) {\\n                        Queue.push(next1);\\n                        visited[next1] = true;\\n                    }\\n                    if(0 <= next2 && next2 <= 1000 && !visited[next2]) {\\n                        Queue.push(next2);\\n                        visited[next2] = true;\\n                    }\\n                    if(0 <= next3 && next3 <= 1000 && !visited[next3]) {\\n                        Queue.push(next3);\\n                        visited[next3] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> Queue;\\n        Queue.push(start);\\n        int ans = 0;\\n        vector<bool> visited(1001);\\n        visited[start] = true;\\n        while(!Queue.empty()) {\\n            ans++;\\n            int sz = Queue.size();\\n            for(int i = 0; i < sz; i++) {\\n                int curr = Queue.front();\\n                Queue.pop();\\n                for(int val: nums) {\\n                    int next1 = curr + val;\\n                    int next2 = curr - val;\\n                    int next3 = curr ^ val;\\n                    if(next1 == goal || next2 == goal || next3 == goal) return ans;\\n                    if(0 <= next1 && next1 <= 1000 && !visited[next1]) {\\n                        Queue.push(next1);\\n                        visited[next1] = true;\\n                    }\\n                    if(0 <= next2 && next2 <= 1000 && !visited[next2]) {\\n                        Queue.push(next2);\\n                        visited[next2] = true;\\n                    }\\n                    if(0 <= next3 && next3 <= 1000 && !visited[next3]) {\\n                        Queue.push(next3);\\n                        visited[next3] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400349,
                "title": "c-bfs",
                "content": "# Intuition\\nTry all possobilities and push the new number in queue if it is in range 0 to 1000 and make a visited map so that we don\\'t end up visiting same numbers again and again.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n = nums.size();\\n        queue<int> q;\\n        q.push(start);\\n        int ans=0;\\n        map<int,int> vis;\\n        vis[start] = 1;\\n        while(!q.empty())\\n        {\\n            int siz = q.size();\\n            for(int i=0;i<siz;i++)\\n            {\\n                int node = q.front();\\n                q.pop();\\n                if(node==goal)\\n                return ans;\\n                for(int j=0;j<n;j++)\\n                {\\n                    int a1 = node+nums[j];\\n                    int a2 = node-nums[j];\\n                    int a3 = node^nums[j];\\n                    if(vis.find(a1)==vis.end())\\n                    {\\n                        if(a1<0 || a1>1000)\\n                        {\\n                            if(a1==goal)\\n                            return ans+1;\\n                        }\\n                        else\\n                        {\\n                            q.push(a1);\\n                            vis[a1] = 1;\\n                        }\\n                    }\\n                    if(vis.find(a2)==vis.end())\\n                    {\\n                        if(a2<0 || a2>1000)\\n                        {\\n                            if(a2==goal)\\n                            return ans+1;\\n                        }\\n                        else\\n                        {\\n                            q.push(a2);\\n                            vis[a2] = 1;\\n                        }\\n                    }\\n                    if(vis.find(a3)==vis.end())\\n                    {\\n                        if(a3<0 || a3>1000)\\n                        {\\n                            if(a3==goal)\\n                            return ans+1;\\n                        }\\n                        else\\n                        {\\n                            q.push(a3);\\n                            vis[a3] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n = nums.size();\\n        queue<int> q;\\n        q.push(start);\\n        int ans=0;\\n        map<int,int> vis;\\n        vis[start] = 1;\\n        while(!q.empty())\\n        {\\n            int siz = q.size();\\n            for(int i=0;i<siz;i++)\\n            {\\n                int node = q.front();\\n                q.pop();\\n                if(node==goal)\\n                return ans;\\n                for(int j=0;j<n;j++)\\n                {\\n                    int a1 = node+nums[j];\\n                    int a2 = node-nums[j];\\n                    int a3 = node^nums[j];\\n                    if(vis.find(a1)==vis.end())\\n                    {\\n                        if(a1<0 || a1>1000)\\n                        {\\n                            if(a1==goal)\\n                            return ans+1;\\n                        }\\n                        else\\n                        {\\n                            q.push(a1);\\n                            vis[a1] = 1;\\n                        }\\n                    }\\n                    if(vis.find(a2)==vis.end())\\n                    {\\n                        if(a2<0 || a2>1000)\\n                        {\\n                            if(a2==goal)\\n                            return ans+1;\\n                        }\\n                        else\\n                        {\\n                            q.push(a2);\\n                            vis[a2] = 1;\\n                        }\\n                    }\\n                    if(vis.find(a3)==vis.end())\\n                    {\\n                        if(a3<0 || a3>1000)\\n                        {\\n                            if(a3==goal)\\n                            return ans+1;\\n                        }\\n                        else\\n                        {\\n                            q.push(a3);\\n                            vis[a3] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382806,
                "title": "easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) \\n    {\\n        int steps = 0;\\n\\n        queue<pair<int,int>>q;\\n        unordered_set<int>vis;\\n       \\n        if(start>=0 and start<=1000)\\n        q.push(make_pair(start,0));\\n\\n        vis.insert(start);\\n\\n        while(!q.empty())\\n        {\\n           int size = q.size();\\n           \\n           for(int j=0;j<size;j++)\\n           {\\n               auto p = q.front();\\n               q.pop();\\n        \\n               if(p.first == goal) \\n               return p.second;\\n\\n                   for(int i=0;i<nums.size();i++)\\n                   {\\n                       int val1 = p.first + nums[i];\\n                       if(val1 == goal) \\n                       return p.second+1;\\n\\n                       if(vis.find(val1) == vis.end() and (!(val1<0 or val1>1000)))\\n                       {\\n                           vis.insert(val1);\\n                           q.push({val1,p.second+1});\\n                       }\\n                       int val2 = p.first - nums[i];\\n                       if(val2 == goal) \\n                       return p.second+1;\\n\\n                       if(vis.find(val2) == vis.end() and (!(val2<0 or val2>1000)))\\n                       {\\n                           vis.insert(val2);\\n                           q.push({val2,p.second+1});\\n                       }\\n\\n                       int val3 = p.first ^ nums[i];\\n                       if(val3 == goal) \\n                       return p.second+1;\\n\\n                       if(vis.find(val3) == vis.end() and (!(val3<0 or val3>1000)))\\n                       {\\n                           vis.insert(val3);\\n                           q.push({val3,p.second+1});\\n                       }\\n                   }\\n           }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) \\n    {\\n        int steps = 0;\\n\\n        queue<pair<int,int>>q;\\n        unordered_set<int>vis;\\n       \\n        if(start>=0 and start<=1000)\\n        q.push(make_pair(start,0));\\n\\n        vis.insert(start);\\n\\n        while(!q.empty())\\n        {\\n           int size = q.size();\\n           \\n           for(int j=0;j<size;j++)\\n           {\\n               auto p = q.front();\\n               q.pop();\\n        \\n               if(p.first == goal) \\n               return p.second;\\n\\n                   for(int i=0;i<nums.size();i++)\\n                   {\\n                       int val1 = p.first + nums[i];\\n                       if(val1 == goal) \\n                       return p.second+1;\\n\\n                       if(vis.find(val1) == vis.end() and (!(val1<0 or val1>1000)))\\n                       {\\n                           vis.insert(val1);\\n                           q.push({val1,p.second+1});\\n                       }\\n                       int val2 = p.first - nums[i];\\n                       if(val2 == goal) \\n                       return p.second+1;\\n\\n                       if(vis.find(val2) == vis.end() and (!(val2<0 or val2>1000)))\\n                       {\\n                           vis.insert(val2);\\n                           q.push({val2,p.second+1});\\n                       }\\n\\n                       int val3 = p.first ^ nums[i];\\n                       if(val3 == goal) \\n                       return p.second+1;\\n\\n                       if(vis.find(val3) == vis.end() and (!(val3<0 or val3>1000)))\\n                       {\\n                           vis.insert(val3);\\n                           q.push({val3,p.second+1});\\n                       }\\n                   }\\n           }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344260,
                "title": "c-solution-faster-than-100",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumOperations(int[] nums, int start, int goal) {\\n        if(nums.Length == 0) return -1;\\n        Queue<int> q = new Queue<int>();\\n        HashSet<int> set = new HashSet<int>();\\n        q.Enqueue(start);\\n        set.Add(start);\\n        int ops = 0;\\n        while(q.Count > 0){\\n            int size = q.Count;\\n            for(int i = 0; i < size;i++){\\n                int cur = q.Dequeue();\\n                for(int j = 0;j < nums.Length;j++){\\n                    int plus = cur + nums[j], minus = cur - nums[j], xor = cur ^ nums[j];\\n                    if(plus == goal || minus == goal || xor == goal) return ops + 1;\\n                    if(plus >= 0 && plus <= 1000 && !set.Contains(plus)){\\n                        q.Enqueue(plus);\\n                        set.Add(plus);\\n                    } \\n                    if(minus >= 0 && minus <= 1000 && !set.Contains(minus)){\\n                        q.Enqueue(minus);\\n                        set.Add(minus);\\n                    } \\n                    if(xor >= 0 && xor <= 1000 && !set.Contains(xor)){\\n                        q.Enqueue(xor);\\n                        set.Add(xor);\\n                    }  \\n                }\\n            }\\n            ops++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumOperations(int[] nums, int start, int goal) {\\n        if(nums.Length == 0) return -1;\\n        Queue<int> q = new Queue<int>();\\n        HashSet<int> set = new HashSet<int>();\\n        q.Enqueue(start);\\n        set.Add(start);\\n        int ops = 0;\\n        while(q.Count > 0){\\n            int size = q.Count;\\n            for(int i = 0; i < size;i++){\\n                int cur = q.Dequeue();\\n                for(int j = 0;j < nums.Length;j++){\\n                    int plus = cur + nums[j], minus = cur - nums[j], xor = cur ^ nums[j];\\n                    if(plus == goal || minus == goal || xor == goal) return ops + 1;\\n                    if(plus >= 0 && plus <= 1000 && !set.Contains(plus)){\\n                        q.Enqueue(plus);\\n                        set.Add(plus);\\n                    } \\n                    if(minus >= 0 && minus <= 1000 && !set.Contains(minus)){\\n                        q.Enqueue(minus);\\n                        set.Add(minus);\\n                    } \\n                    if(xor >= 0 && xor <= 1000 && !set.Contains(xor)){\\n                        q.Enqueue(xor);\\n                        set.Add(xor);\\n                    }  \\n                }\\n            }\\n            ops++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315669,
                "title": "bfs-and-dijkstra-s-algo-with-explanation",
                "content": "Consider each number we will obtain in the process as a node of the graph.\\nThe edge will denote that we can reach from previous number to next resultant number.\\nIf the number is outside the given range we won\\'t use it further.\\nNow we will apply dijkstra algo to get the shortest path from start to each node of the graph.\\n```\\nclass Solution {\\n  class Edge\\n  {\\n    int n;int dist;\\n    public Edge(int n, int dist)\\n    {\\n      this.n = n;\\n      this.dist = dist;\\n    }\\n  }\\n  class edgecom implements Comparator<Edge>\\n  {\\n    @Override\\n    public int compare(Edge e1,Edge e2)\\n    {\\n      int res = Integer.compare(e1.dist,e2.dist);\\n      return res;\\n    }\\n  }\\n    public int minimumOperations(int[] arr, int start, int end) {\\n      int dp[]= new int[1001];\\n      Arrays.fill(dp,Integer.MAX_VALUE);\\n        dp[start] = 0;\\n      PriorityQueue<Edge> pq = new PriorityQueue<>(new edgecom());\\n      pq.add(new Edge(start,0));\\n      while(!pq.isEmpty())\\n      {\\n        Edge e = pq.poll();\\n        for(int i:arr)\\n        {\\n          int a = e.n+i;\\n          int b = e.n-i;\\n          int c = e.n^i;\\n          if(a>=0 && a<=1000)\\n          {\\n            if(e.dist+1<dp[a])\\n            {\\n              dp[a]= e.dist+1;\\n              pq.add(new Edge(a,dp[a]));\\n            }\\n          }\\n          else\\n          {\\n            if(end==a)\\n              return e.dist+1;\\n          }\\n         \\n        if(b>=0 && b<=1000)\\n          {\\n            if(e.dist+1<dp[b])\\n            {\\n              dp[b]= e.dist+1;\\n              pq.add(new Edge(b,dp[b]));\\n            }\\n          }\\n          else\\n          {\\n            if(end==b)\\n              return e.dist+1;\\n          }\\n         \\n      if(c>=0 && c<=1000)\\n          {\\n            if(e.dist+1<dp[c])\\n            {\\n              dp[c]= e.dist+1;\\n              pq.add(new Edge(c,dp[c]));\\n            }\\n          }\\n          else\\n          {\\n            if(end==c)\\n              return e.dist+1;\\n          }\\n        }\\n      }\\n      if(end<0 || end>1000)\\n        return -1;\\n      if(dp[end]==Integer.MAX_VALUE)\\n        return -1;\\n      return dp[end];\\n\\n      \\n    }\\n}\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n  class Edge\\n  {\\n    int n;int dist;\\n    public Edge(int n, int dist)\\n    {\\n      this.n = n;\\n      this.dist = dist;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3266332,
                "title": "simple-bfs-with-intuition-and-approach-well-commented",
                "content": "# Intuition\\nWe are given a start and a goal.\\nnums = [2,4,12] , start = 2, goal = 12\\n\\nWe have to convert start into goal and we can perform three operations on start.\\nSince we have to find the minimum number of operations, we have to find all of the different ways to figure out the minimum one.\\n\\nSo starting with the 0th index, we have to perform all the operations on start with the array elements.\\n\\nwhich are \\n1. start + nums[i]\\n2. start - nums[i]\\n3. start ^ nums[i]\\n\\nNow if it keeps generating new numbers then it will end up in an infinite loop so to avoid that we have to maintain a visited array to keep track of numbers that has already been visited.\\nAnd it can be done easily with BFS.\\n\\n\\n# Approach\\n1. Take a queue\\n2. Put start in the queue\\n3. Perform basic BFS\\n4. While popping, we will check if\\n    a. the number is equal to the goal, return count.\\n    b. if the number is out of rangeb(a/q to question we can\\'t perform further operation if the number goes out of range) or has already been visited, we will continue.\\n   c. else we will mark it visited and traverse in the nums array and perform the operations and push the generated values in the queue.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n*k), where k is the range from (0 to 1000)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int>q;\\n        vector<int>vis(1001, 0);\\n        q.push(start);\\n        int count = 0;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                int x = q.front();\\n                q.pop();\\n\\n                if(x == goal)return count;\\n                if(x < 0 || x > 1000 || vis[x])continue;\\n                vis[x] = 1;\\n                for(auto i: nums){\\n                    q.push(x+i);\\n                    q.push(x-i);\\n                    q.push(x^i);\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int>q;\\n        vector<int>vis(1001, 0);\\n        q.push(start);\\n        int count = 0;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                int x = q.front();\\n                q.pop();\\n\\n                if(x == goal)return count;\\n                if(x < 0 || x > 1000 || vis[x])continue;\\n                vis[x] = 1;\\n                for(auto i: nums){\\n                    q.push(x+i);\\n                    q.push(x-i);\\n                    q.push(x^i);\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247357,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_operations(nums: Vec<i32>, start: i32, goal: i32) -> i32 {\\n        let mut seen = vec![false; 1001];\\n        let mut cnt = 0;\\n        let mut q = vec![goal];\\n        while !q.is_empty() {\\n            cnt += 1;\\n            let mut q1 = vec![];\\n            for &x in q.iter() {\\n                for &n in nums.iter() {\\n                    for &xn in [x + n, x - n, x ^ n].iter() {\\n                        if (0..=1000).contains(&xn) && !seen[xn as usize] {\\n                            if xn == start {\\n                                return cnt;\\n                            }\\n                            seen[xn as usize] = true;\\n                            q1.push(xn);\\n                        }\\n                    }\\n                }\\n            }\\n            q = q1;\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_operations(nums: Vec<i32>, start: i32, goal: i32) -> i32 {\\n        let mut seen = vec![false; 1001];\\n        let mut cnt = 0;\\n        let mut q = vec![goal];\\n        while !q.is_empty() {\\n            cnt += 1;\\n            let mut q1 = vec![];\\n            for &x in q.iter() {\\n                for &n in nums.iter() {\\n                    for &xn in [x + n, x - n, x ^ n].iter() {\\n                        if (0..=1000).contains(&xn) && !seen[xn as usize] {\\n                            if xn == start {\\n                                return cnt;\\n                            }\\n                            seen[xn as usize] = true;\\n                            q1.push(xn);\\n                        }\\n                    }\\n                }\\n            }\\n            q = q1;\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3234662,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int step = 0 ;\\n        vector<bool>visited(1001) ;\\n        queue<int>q{{start}} ;\\n        visited[start] = true ;\\n        while(!q.empty()){\\n            int cn = q.size() ;\\n            step++ ;\\n            for(int i = 0; i < cn; i++){\\n                int cur = q.front() ;\\n                q.pop() ;\\n                for(auto& num : nums){\\n                    for(int next : {cur+num, cur-num, cur^num}){\\n                        if(next == goal)\\n                            return step ;\\n                        if(next < 0 || next > 1000 || visited[next])\\n                            continue ;\\n                        visited[next] = true ;\\n                        q.push(next) ;\\n                    }\\n                }\\n            }\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int step = 0 ;\\n        vector<bool>visited(1001) ;\\n        queue<int>q{{start}} ;\\n        visited[start] = true ;\\n        while(!q.empty()){\\n            int cn = q.size() ;\\n            step++ ;\\n            for(int i = 0; i < cn; i++){\\n                int cur = q.front() ;\\n                q.pop() ;\\n                for(auto& num : nums){\\n                    for(int next : {cur+num, cur-num, cur^num}){\\n                        if(next == goal)\\n                            return step ;\\n                        if(next < 0 || next > 1000 || visited[next])\\n                            continue ;\\n                        visited[next] = true ;\\n                        q.push(next) ;\\n                    }\\n                }\\n            }\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205306,
                "title": "dart-bfs-try-all-possibilities",
                "content": "# Approach\\nCalc both 3 operations and put into the queue for iterate again. Visited set will check it\\'s already seen. If found return steps.\\n\\n\\n# Code\\n```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int minimumOperations(List<int> nums, int start, int goal) {\\n    int n = nums.length;\\n    Queue<int> q = Queue();\\n    HashSet<int> visited = HashSet();\\n    q.add(start);\\n    bool check(x) => x < 0 || x > 1000 || visited.contains(x);\\n    int steps = 0;\\n    while (q.isNotEmpty) {\\n      int k = q.length;\\n      steps++;\\n      for (var i = 0; i < k; i++) {\\n        int p = q.removeFirst();\\n        if (check(p)) {\\n          continue;\\n        }\\n        visited.add(p);\\n        for (var j = 0; j < n; j++) {\\n          var x = nums[j];\\n          int add = p + x;\\n          int sub = p - x;\\n          int xor = p ^ x;\\n\\n          if (add == goal || sub == goal || xor == goal) {\\n            return steps;\\n          }\\n          q.add(add);\\n          q.add(sub);\\n          q.add(xor);\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int minimumOperations(List<int> nums, int start, int goal) {\\n    int n = nums.length;\\n    Queue<int> q = Queue();\\n    HashSet<int> visited = HashSet();\\n    q.add(start);\\n    bool check(x) => x < 0 || x > 1000 || visited.contains(x);\\n    int steps = 0;\\n    while (q.isNotEmpty) {\\n      int k = q.length;\\n      steps++;\\n      for (var i = 0; i < k; i++) {\\n        int p = q.removeFirst();\\n        if (check(p)) {\\n          continue;\\n        }\\n        visited.add(p);\\n        for (var j = 0; j < n; j++) {\\n          var x = nums[j];\\n          int add = p + x;\\n          int sub = p - x;\\n          int xor = p ^ x;\\n\\n          if (add == goal || sub == goal || xor == goal) {\\n            return steps;\\n          }\\n          q.add(add);\\n          q.add(sub);\\n          q.add(xor);\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090677,
                "title": "help-memoization-solution-passing-57-60-test-cases",
                "content": "**Please Help me My memoization solution is passing 57 test cases but falling on 58th why this wont work can u please tell**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&nums,int x,int goal,vector<int>&dp){\\n        if(x==goal) return 0;\\n        if(x<0) return 1e9;\\n        if(x>1000)  return 1e9;\\n        if(dp[x]!=-1) return dp[x];\\n        dp[x]=1e9;\\n        int ans=1e9;\\n        for(int i=0;i<nums.size();i++){\\n            int add=1+helper(nums,x+nums[i],goal,dp);\\n            int minus=1+helper(nums,x-nums[i],goal,dp);\\n            int xo=1+helper(nums,x^nums[i],goal,dp);\\n            ans=min(add,min(minus,xo));\\n            dp[x]=min(ans,dp[x]);\\n        }\\n        return dp[x];\\n    }\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        vector<int> dp(1001,-1);\\n        int ans=helper(nums,start,goal,dp);\\n            if(ans>=1e9) return -1;\\n        else return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2afc2518-8c0e-453f-972f-855c070b856e_1674486075.0659983.png)\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&nums,int x,int goal,vector<int>&dp){\\n        if(x==goal) return 0;\\n        if(x<0) return 1e9;\\n        if(x>1000)  return 1e9;\\n        if(dp[x]!=-1) return dp[x];\\n        dp[x]=1e9;\\n        int ans=1e9;\\n        for(int i=0;i<nums.size();i++){\\n            int add=1+helper(nums,x+nums[i],goal,dp);\\n            int minus=1+helper(nums,x-nums[i],goal,dp);\\n            int xo=1+helper(nums,x^nums[i],goal,dp);\\n            ans=min(add,min(minus,xo));\\n            dp[x]=min(ans,dp[x]);\\n        }\\n        return dp[x];\\n    }\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        vector<int> dp(1001,-1);\\n        int ans=helper(nums,start,goal,dp);\\n            if(ans>=1e9) return -1;\\n        else return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070818,
                "title": "python-bfs",
                "content": "# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        que = deque([(start, 0)])\\n        visited = set()\\n        while que:\\n            x, d = que.popleft()\\n            if x in visited: continue\\n            visited.add(x)\\n            for num in nums:\\n                if x + num == goal: return d+1\\n                if 0 <= x + num <= 1000:\\n                    que.append((x+num, d+1))\\n                if x - num == goal: return d+1\\n                if 0 <= x - num <= 1000:\\n                    que.append((x-num, d+1))\\n                if x ^ num == goal: return d+1\\n                if 0 <= x ^ num <= 1000:\\n                    que.append((x^num, d+1))\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        que = deque([(start, 0)])\\n        visited = set()\\n        while que:\\n            x, d = que.popleft()\\n            if x in visited: continue\\n            visited.add(x)\\n            for num in nums:\\n                if x + num == goal: return d+1\\n                if 0 <= x + num <= 1000:\\n                    que.append((x+num, d+1))\\n                if x - num == goal: return d+1\\n                if 0 <= x - num <= 1000:\\n                    que.append((x-num, d+1))\\n                if x ^ num == goal: return d+1\\n                if 0 <= x ^ num <= 1000:\\n                    que.append((x^num, d+1))\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981777,
                "title": "python-bfs",
                "content": "- 90% for time, 97% for memory\\n# Code\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        seen = set()\\n        queue = deque([(start, 0)])\\n\\n        while queue:\\n            x,count = queue.popleft()\\n\\n            for num in nums:\\n                for val in (x+num, x-num, x^num):\\n                    if val in seen:\\n                        continue\\n\\n                    if val == goal:\\n                        return count + 1 \\n\\n                    if val<0 or val>1000:\\n                        continue\\n\\n                    queue.append((val, count+1))\\n                    seen.add(val)\\n\\n        return -1 \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        seen = set()\\n        queue = deque([(start, 0)])\\n\\n        while queue:\\n            x,count = queue.popleft()\\n\\n            for num in nums:\\n                for val in (x+num, x-num, x^num):\\n                    if val in seen:\\n                        continue\\n\\n                    if val == goal:\\n                        return count + 1 \\n\\n                    if val<0 or val>1000:\\n                        continue\\n\\n                    queue.append((val, count+1))\\n                    seen.add(val)\\n\\n        return -1 \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959178,
                "title": "bfs-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can represent the generated numbers as nodes in graph and apply bfs on this graph. BFS will traverse the graph level by level and the level represents the number of operations needed to generate the numbers present in this level\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**BFS**\\n\\n# Complexity\\n- Time complexity: **O(m * n)** where m is the numbers in range of 0 and 1000\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(m)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        HashSet<Integer> generated = new HashSet<Integer>();\\n        queue.add(start);\\n        generated.add(start);\\n        for(int operations = 1, size = 1; !queue.isEmpty(); size = queue.size(), operations++){\\n            while(size-- > 0){\\n                int x = queue.poll();\\n                for(int i = 0; i < nums.length; i++){\\n                    if(process(nums, x + nums[i], generated, queue, goal)||\\n                    process(nums, x - nums[i], generated, queue, goal)||\\n                    process(nums, x ^ nums[i], generated, queue, goal)) return operations;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    public boolean process(int[] nums, int n, HashSet<Integer> set, Queue<Integer> queue, int goal){\\n        if(n == goal) return true;\\n        if(n >= 0 && n <= 1000 && !set.contains(n)){\\n            queue.add(n);\\n            set.add(n);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        HashSet<Integer> generated = new HashSet<Integer>();\\n        queue.add(start);\\n        generated.add(start);\\n        for(int operations = 1, size = 1; !queue.isEmpty(); size = queue.size(), operations++){\\n            while(size-- > 0){\\n                int x = queue.poll();\\n                for(int i = 0; i < nums.length; i++){\\n                    if(process(nums, x + nums[i], generated, queue, goal)||\\n                    process(nums, x - nums[i], generated, queue, goal)||\\n                    process(nums, x ^ nums[i], generated, queue, goal)) return operations;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    public boolean process(int[] nums, int n, HashSet<Integer> set, Queue<Integer> queue, int goal){\\n        if(n == goal) return true;\\n        if(n >= 0 && n <= 1000 && !set.contains(n)){\\n            queue.add(n);\\n            set.add(n);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946241,
                "title": "c-bfs-solution",
                "content": "# Code\\n```\\ntypedef struct StatusBlock {\\n    int ops;\\n    int * x_arr;\\n} block;\\n\\nint * search_nums(int * nums, int numsSize, int x)\\n{\\n    int * arr = malloc(3 * numsSize * sizeof(int));\\n    for (int i = 0; i < numsSize; i++)\\n    {\\n        arr[3 * i] = x + nums[i];\\n        arr[3 * i + 1] = x - nums[i];\\n        arr[3 * i + 2] = x ^ nums[i];\\n    }\\n    return arr;\\n}\\n\\nblock * extend(block * old_queue, int data_size, int * limit)\\n{\\n    *limit = *limit << 2;\\n    block * new_queue = malloc((size_t)(*limit) * sizeof(block));\\n    memcpy(new_queue, old_queue, data_size * sizeof(block));\\n    free(old_queue);\\n    return new_queue;\\n}\\n\\nvoid free_queue(block * queue, size_t range)\\n{\\n    for (size_t i = 0; i < range; i++)\\n    {\\n        free(queue[i].x_arr);\\n    }\\n    free(queue);\\n}\\n\\nint minimumOperations(int* nums, int numsSize, int start, int goal) {\\n    if (start == goal) return 0;\\n    bool * visited = calloc(1024, sizeof(bool));\\n    visited[start] = true;\\n\\n    int limit = 64;\\n    int front = 0;\\n    int rear = 0;\\n    block * queue_body = malloc(limit * sizeof(block));\\n\\n    queue_body[front].ops = 1;\\n    queue_body[front].x_arr = search_nums(nums, numsSize, start);\\n    ++front;\\n\\n    while(rear < front)\\n    {  \\n        int ops = queue_body[rear].ops;\\n        int * x_arr = queue_body[rear].x_arr;\\n        int x;\\n\\n        ++rear;\\n\\n        for (int i = 0; i < 3 * numsSize; i++)\\n        {\\n            x = x_arr[i];\\n\\n            if (x == goal)\\n            {\\n                free_queue(queue_body, front);\\n                return ops;\\n            }\\n\\n            if (x < 0 || x > 1000 || visited[x]) continue;\\n            visited[x] = true;\\n\\n            if (front == limit) queue_body = extend(queue_body, front, &limit);\\n            queue_body[front].ops = ops + 1;\\n            queue_body[front].x_arr = search_nums(nums, numsSize, x);\\n            ++front;\\n        }\\n    }\\n\\n    free_queue(queue_body, front);\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct StatusBlock {\\n    int ops;\\n    int * x_arr;\\n} block;\\n\\nint * search_nums(int * nums, int numsSize, int x)\\n{\\n    int * arr = malloc(3 * numsSize * sizeof(int));\\n    for (int i = 0; i < numsSize; i++)\\n    {\\n        arr[3 * i] = x + nums[i];\\n        arr[3 * i + 1] = x - nums[i];\\n        arr[3 * i + 2] = x ^ nums[i];\\n    }\\n    return arr;\\n}\\n\\nblock * extend(block * old_queue, int data_size, int * limit)\\n{\\n    *limit = *limit << 2;\\n    block * new_queue = malloc((size_t)(*limit) * sizeof(block));\\n    memcpy(new_queue, old_queue, data_size * sizeof(block));\\n    free(old_queue);\\n    return new_queue;\\n}\\n\\nvoid free_queue(block * queue, size_t range)\\n{\\n    for (size_t i = 0; i < range; i++)\\n    {\\n        free(queue[i].x_arr);\\n    }\\n    free(queue);\\n}\\n\\nint minimumOperations(int* nums, int numsSize, int start, int goal) {\\n    if (start == goal) return 0;\\n    bool * visited = calloc(1024, sizeof(bool));\\n    visited[start] = true;\\n\\n    int limit = 64;\\n    int front = 0;\\n    int rear = 0;\\n    block * queue_body = malloc(limit * sizeof(block));\\n\\n    queue_body[front].ops = 1;\\n    queue_body[front].x_arr = search_nums(nums, numsSize, start);\\n    ++front;\\n\\n    while(rear < front)\\n    {  \\n        int ops = queue_body[rear].ops;\\n        int * x_arr = queue_body[rear].x_arr;\\n        int x;\\n\\n        ++rear;\\n\\n        for (int i = 0; i < 3 * numsSize; i++)\\n        {\\n            x = x_arr[i];\\n\\n            if (x == goal)\\n            {\\n                free_queue(queue_body, front);\\n                return ops;\\n            }\\n\\n            if (x < 0 || x > 1000 || visited[x]) continue;\\n            visited[x] = true;\\n\\n            if (front == limit) queue_body = extend(queue_body, front, &limit);\\n            queue_body[front].ops = ops + 1;\\n            queue_body[front].x_arr = search_nums(nums, numsSize, x);\\n            ++front;\\n        }\\n    }\\n\\n    free_queue(queue_body, front);\\n    return -1;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2926215,
                "title": "python-simple-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumOperations(self, nums, start, goal):\\n        n, stack, visited = len(nums), [(start,0)], set()\\n\\n        while stack:\\n            val, step = stack.pop(0)\\n\\n            if val == goal:\\n                return step\\n\\n            visited.add(val)\\n\\n            if 0 <= val <= 1000:\\n                for i in range(n):\\n                    if (val + nums[i]) not in visited:\\n                        stack.append((val+nums[i],step+1))\\n                        visited.add(val+nums[i])\\n\\n                    if (val - nums[i]) not in visited:\\n                        stack.append((val-nums[i],step+1))\\n                        visited.add(val-nums[i])\\n\\n                    if val^nums[i] not in visited:\\n                        stack.append((val^nums[i],step+1))\\n                        visited.add(val^nums[i])\\n\\n        return -1\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums, start, goal):\\n        n, stack, visited = len(nums), [(start,0)], set()\\n\\n        while stack:\\n            val, step = stack.pop(0)\\n\\n            if val == goal:\\n                return step\\n\\n            visited.add(val)\\n\\n            if 0 <= val <= 1000:\\n                for i in range(n):\\n                    if (val + nums[i]) not in visited:\\n                        stack.append((val+nums[i],step+1))\\n                        visited.add(val+nums[i])\\n\\n                    if (val - nums[i]) not in visited:\\n                        stack.append((val-nums[i],step+1))\\n                        visited.add(val-nums[i])\\n\\n                    if val^nums[i] not in visited:\\n                        stack.append((val^nums[i],step+1))\\n                        visited.add(val^nums[i])\\n\\n        return -1\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836940,
                "title": "c-bfs-solution",
                "content": "# Intuition\\nuse vector to store all the previously visited numbers so that we don\\'t get a runtime error.put start in queue and add numbers to the queue after applying all the three operations.\\n\\n# Approach\\nuse simple bfs and take a depth  variable to give the shortest path.\\n\\n# Complexity\\n- Time complexity:\\no(1000)\\n\\n- Space complexity:\\no(1000)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) \\n    {\\n        vector<int>v(1005,0);\\n        queue<int>q;\\n        q.push(start);\\n        v[start]=1;\\n        int depth=0;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            depth++;\\n            while(sz--)\\n            {\\n                int curr=q.front();\\n                q.pop();\\n                for (int i=0;i<nums.size();i++)\\n                {\\n                    int t1=curr+nums[i];\\n                    if (t1==goal) return depth;\\n                    if (t1<=1000 && t1>=0 && v[t1]==0)\\n                    {\\n                        v[t1]=1;\\n                        q.push(t1);\\n                    }\\n                    t1=curr-nums[i];\\n                    if (t1==goal) return depth;\\n                    if (t1<=1000 && t1>=0 && v[t1]==0)\\n                    {\\n                        v[t1]=1;\\n                        q.push(t1);\\n                    }\\n                    t1=(curr^nums[i]);\\n                    if (t1==goal) return depth;\\n                    if (t1<=1000 && t1>=0 && v[t1]==0)\\n                    {\\n                        v[t1]=1;\\n                        q.push(t1);\\n                    }\\n                }\\n            }\\n        \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) \\n    {\\n        vector<int>v(1005,0);\\n        queue<int>q;\\n        q.push(start);\\n        v[start]=1;\\n        int depth=0;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            depth++;\\n            while(sz--)\\n            {\\n                int curr=q.front();\\n                q.pop();\\n                for (int i=0;i<nums.size();i++)\\n                {\\n                    int t1=curr+nums[i];\\n                    if (t1==goal) return depth;\\n                    if (t1<=1000 && t1>=0 && v[t1]==0)\\n                    {\\n                        v[t1]=1;\\n                        q.push(t1);\\n                    }\\n                    t1=curr-nums[i];\\n                    if (t1==goal) return depth;\\n                    if (t1<=1000 && t1>=0 && v[t1]==0)\\n                    {\\n                        v[t1]=1;\\n                        q.push(t1);\\n                    }\\n                    t1=(curr^nums[i]);\\n                    if (t1==goal) return depth;\\n                    if (t1<=1000 && t1>=0 && v[t1]==0)\\n                    {\\n                        v[t1]=1;\\n                        q.push(t1);\\n                    }\\n                }\\n            }\\n        \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821111,
                "title": "easy-bfs-solution-using-java",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal)\\n    {\\n        Queue<Integer> queue=new LinkedList<>();\\n        int[] vis=new int[1001];\\n        \\n        queue.add(start);\\n        int count=0;\\n        \\n        while(!queue.isEmpty())\\n        {\\n            int len=queue.size();\\n            \\n            while(len-->0)\\n            {\\n                int temp=queue.remove();\\n                if(temp==goal)\\n                {\\n                    return count;\\n                }\\n                \\n                if(temp<0 || temp>1000 || vis[temp]==1)\\n                {\\n                    continue;\\n                }\\n                \\n                vis[temp]=1;\\n                \\n                for(int i:nums)\\n                {\\n                    queue.add(temp+i);\\n                    queue.add(temp-i);\\n                    queue.add(temp^i);\\n                }\\n            }\\n            \\n            count++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal)\\n    {\\n        Queue<Integer> queue=new LinkedList<>();\\n        int[] vis=new int[1001];\\n        \\n        queue.add(start);\\n        int count=0;\\n        \\n        while(!queue.isEmpty())\\n        {\\n            int len=queue.size();\\n            \\n            while(len-->0)\\n            {\\n                int temp=queue.remove();\\n                if(temp==goal)\\n                {\\n                    return count;\\n                }\\n                \\n                if(temp<0 || temp>1000 || vis[temp]==1)\\n                {\\n                    continue;\\n                }\\n                \\n                vis[temp]=1;\\n                \\n                for(int i:nums)\\n                {\\n                    queue.add(temp+i);\\n                    queue.add(temp-i);\\n                    queue.add(temp^i);\\n                }\\n            }\\n            \\n            count++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789248,
                "title": "python-generic-bfs-solution-concise-code",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        seen, Q = [False]*1001, deque()\\n        Q.append([start,0]) # [current_number, operations done]\\n        seen[start] = True\\n        \\n        while Q:\\n            curr, operations = Q.popleft()\\n            \\n            for n in nums:\\n                new_states = [curr + n, curr - n, curr ^ n]\\n                \\n                for S in new_states:\\n                    \\n                    if S == goal:\\n                        return operations + 1\\n                    \\n                    if 0<=S<=1000 and not seen[S]:\\n                        Q.append([S, operations + 1])\\n                        seen[S] = True\\n            \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        seen, Q = [False]*1001, deque()\\n        Q.append([start,0]) # [current_number, operations done]\\n        seen[start] = True\\n        \\n        while Q:\\n            curr, operations = Q.popleft()\\n            \\n            for n in nums:\\n                new_states = [curr + n, curr - n, curr ^ n]\\n                \\n                for S in new_states:\\n                    \\n                    if S == goal:\\n                        return operations + 1\\n                    \\n                    if 0<=S<=1000 and not seen[S]:\\n                        Q.append([S, operations + 1])\\n                        seen[S] = True\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762428,
                "title": "c-bfs-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int>q;\\n        vector<bool>vis(1001,false);\\n        q.push(start);\\n        int ans=0;\\n        int x;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int temp=q.front();\\n                q.pop();\\n                if(temp==goal)\\n                {\\n                    return ans;\\n                }\\n                if(temp<0 or temp>1000 or vis[temp]==true)\\n                {\\n                    continue;\\n                }\\n                vis[temp]=true;\\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    x=temp+nums[j];\\n                    q.push(x);\\n                    x=temp-nums[j];\\n                    q.push(x);\\n                    x=temp^nums[j];\\n                    q.push(x);\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int>q;\\n        vector<bool>vis(1001,false);\\n        q.push(start);\\n        int ans=0;\\n        int x;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int temp=q.front();\\n                q.pop();\\n                if(temp==goal)\\n                {\\n                    return ans;\\n                }\\n                if(temp<0 or temp>1000 or vis[temp]==true)\\n                {\\n                    continue;\\n                }\\n                vis[temp]=true;\\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    x=temp+nums[j];\\n                    q.push(x);\\n                    x=temp-nums[j];\\n                    q.push(x);\\n                    x=temp^nums[j];\\n                    q.push(x);\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664279,
                "title": "c-bfs-clean-code",
                "content": "[@aman282571](https://leetcode.com/aman282571/) proposed this [solution](https://leetcode.com/problems/minimum-operations-to-convert-number/solutions/1549960/c-bfs-clean-code/), and I refactor the code.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int minimumOperations(const vector<int>& nums, const int start, const int goal) {\\n        array<bool, 1001> visited{};\\n        int ans = 0;\\n        queue<int> q;\\n        q.push(start);\\n        for (int qsize = 0; qsize = q.size(); ++ans)\\n            while (qsize--) {\\n                int node = q.front();\\n                q.pop();\\n                if (node == goal)\\n                    return ans;\\n                if (node > 1000 || node < 0 || visited[node])\\n                    continue;\\n                visited[node] = true;\\n                for (auto i : nums) {\\n                    q.push(node + i);\\n                    q.push(node - i);\\n                    q.push(node ^ i);\\n                }\\n            }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int minimumOperations(const vector<int>& nums, const int start, const int goal) {\\n        array<bool, 1001> visited{};\\n        int ans = 0;\\n        queue<int> q;\\n        q.push(start);\\n        for (int qsize = 0; qsize = q.size(); ++ans)\\n            while (qsize--) {\\n                int node = q.front();\\n                q.pop();\\n                if (node == goal)\\n                    return ans;\\n                if (node > 1000 || node < 0 || visited[node])\\n                    continue;\\n                visited[node] = true;\\n                for (auto i : nums) {\\n                    q.push(node + i);\\n                    q.push(node - i);\\n                    q.push(node ^ i);\\n                }\\n            }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652907,
                "title": "python-bfs-solution-with-pre-processing-300-ms",
                "content": "```\\ndef minimumOperations(self, nums: List[int], s: int, x: int) -> int:\\n\\tcans = []\\n\\tfor n in nums:\\n\\t\\tif 0<=x-n<=1000 or 0<=x+n<=1000 or 0<=x^n<=1000 or 0<n<=1000:\\n\\t\\t\\tcans.append(n)\\n\\n\\tq = deque([s])\\n\\tvisited, step = set([s]), 0\\n\\twhile(q):\\n\\t\\tfor _ in range(len(q)):\\n\\t\\t\\tn = q.popleft()\\n\\t\\t\\tfor k in cans:\\n\\t\\t\\t\\tfor nxt in (n+k, n-k, n^k):\\n\\t\\t\\t\\t\\tif nxt==x:\\n\\t\\t\\t\\t\\t\\treturn step+1\\n\\t\\t\\t\\t\\tif nxt not in visited and 0<=nxt<=1000:\\n\\t\\t\\t\\t\\t\\tvisited.add(nxt)\\n\\t\\t\\t\\t\\t\\tq.append(nxt)\\n\\t\\tstep += 1\\n\\treturn -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumOperations(self, nums: List[int], s: int, x: int) -> int:\\n\\tcans = []\\n\\tfor n in nums:\\n\\t\\tif 0<=x-n<=1000 or 0<=x+n<=1000 or 0<=x^n<=1000 or 0<n<=1000:\\n\\t\\t\\tcans.append(n)\\n\\n\\tq = deque([s])\\n\\tvisited, step = set([s]), 0\\n\\twhile(q):\\n\\t\\tfor _ in range(len(q)):\\n\\t\\t\\tn = q.popleft()\\n\\t\\t\\tfor k in cans:\\n\\t\\t\\t\\tfor nxt in (n+k, n-k, n^k):\\n\\t\\t\\t\\t\\tif nxt==x:\\n\\t\\t\\t\\t\\t\\treturn step+1\\n\\t\\t\\t\\t\\tif nxt not in visited and 0<=nxt<=1000:\\n\\t\\t\\t\\t\\t\\tvisited.add(nxt)\\n\\t\\t\\t\\t\\t\\tq.append(nxt)\\n\\t\\tstep += 1\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2597766,
                "title": "java-bfs-dp-optimized-code",
                "content": "```\\n/*\\nTo understand the code better,\\ndry run for the test case:\\nnums = [2,4,12], start = 2, goal = 12\\n*/\\n\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        Queue<Integer> q = new LinkedList<>() ;\\n        int[] visited = new int [1001] ;\\n        int result = 0 ;\\n        q.offer(start) ;\\n        \\n        while (!q.isEmpty()) {\\n            int n = q.size() ;\\n            while (n-- > 0) {\\n                int temp = q.poll() ;\\n                if (temp == goal) return result ;\\n                if (temp < 0 || temp > 1000 || visited[temp] == 1)\\n                    continue ;\\n                visited[temp] = 1 ;\\n                \\n                for (int x : nums) {\\n                    q.offer(temp + x) ;\\n                    q.offer(temp - x) ;\\n                    q.offer(temp ^ x) ;\\n                }\\n            }\\n            result++ ;\\n        }\\n        return -1 ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\nTo understand the code better,\\ndry run for the test case:\\nnums = [2,4,12], start = 2, goal = 12\\n*/\\n\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        Queue<Integer> q = new LinkedList<>() ;\\n        int[] visited = new int [1001] ;\\n        int result = 0 ;\\n        q.offer(start) ;\\n        \\n        while (!q.isEmpty()) {\\n            int n = q.size() ;\\n            while (n-- > 0) {\\n                int temp = q.poll() ;\\n                if (temp == goal) return result ;\\n                if (temp < 0 || temp > 1000 || visited[temp] == 1)\\n                    continue ;\\n                visited[temp] = 1 ;\\n                \\n                for (int x : nums) {\\n                    q.offer(temp + x) ;\\n                    q.offer(temp - x) ;\\n                    q.offer(temp ^ x) ;\\n                }\\n            }\\n            result++ ;\\n        }\\n        return -1 ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583782,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def isValid(self, num: int) -> bool:\\n        return num > -1 and num < 1001\\n    \\n    def process(self, newNum: int, goal: int, queue, visited: List[bool]) -> bool:\\n        # check if number reach the goal\\n        if newNum == goal:\\n            return True\\n        # we must not visit number twice\\n        if not self.isValid(newNum) or visited[newNum]:\\n            return False\\n        queue.append(newNum)\\n        visited[newNum] = True\\n        return False\\n    \\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        queue, level = collections.deque(), 0\\n        visited = [False for _ in range(1001)]\\n        visited[start] = True\\n        queue.append(start)\\n        # We ensure that each iterate the queue pop all numbers belong to previous level in bfs\\n        # so we could know each number to any level belong (shortest path)\\n        while len(queue):\\n            size = len(queue)\\n            while size:\\n                num = queue.popleft()\\n                for i in range(len(nums)):\\n                    # use one function for the three operations\\n                    if self.process(num + nums[i], goal, queue, visited) or self.process(num - nums[i], goal, queue, visited) or self.process(num ^ nums[i], goal, queue, visited):\\n                            # if we reach the goal we know is the shortest path for it so we return the level\\n                            return level + 1\\n                size -= 1\\n            level += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, num: int) -> bool:\\n        return num > -1 and num < 1001\\n    \\n    def process(self, newNum: int, goal: int, queue, visited: List[bool]) -> bool:\\n        # check if number reach the goal\\n        if newNum == goal:\\n            return True\\n        # we must not visit number twice\\n        if not self.isValid(newNum) or visited[newNum]:\\n            return False\\n        queue.append(newNum)\\n        visited[newNum] = True\\n        return False\\n    \\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        queue, level = collections.deque(), 0\\n        visited = [False for _ in range(1001)]\\n        visited[start] = True\\n        queue.append(start)\\n        # We ensure that each iterate the queue pop all numbers belong to previous level in bfs\\n        # so we could know each number to any level belong (shortest path)\\n        while len(queue):\\n            size = len(queue)\\n            while size:\\n                num = queue.popleft()\\n                for i in range(len(nums)):\\n                    # use one function for the three operations\\n                    if self.process(num + nums[i], goal, queue, visited) or self.process(num - nums[i], goal, queue, visited) or self.process(num ^ nums[i], goal, queue, visited):\\n                            # if we reach the goal we know is the shortest path for it so we return the level\\n                            return level + 1\\n                size -= 1\\n            level += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2582647,
                "title": "clean-demonstration-c-code",
                "content": "We could think this problem as shortest path problem \\nSo we can iterate each number and add to start using Modified Bfs\\nThere is 1001 state M=1001 ( number of numbers we could reach ) and the loop iterate N times Complexity=N*M\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    bool valid(int x)\\n    {\\n        return x > -1 && x < 1001;\\n    }\\n    bool process(int newNum, int goal, queue<int> &q, vector<bool> &visit)\\n    { /* check if number reach the goal */\\n        if (newNum == goal)\\n        {\\n            return true;\\n        }\\n        /* we must not visit number twicely\\n        because in first visit we itreate all numbers in array and do all operations on it */\\n        if (!valid(newNum) || visit[newNum])\\n        {\\n            return false;\\n        }\\n        q.push(newNum);\\n        visit[newNum] = true;\\n        return false;\\n    }\\n    int bfs(int start, vector<int> &nums, int goal)\\n    {\\n        queue<int> q;\\n        q.push(start);\\n\\n        vector<bool> visit(1001, false);\\n        visit[start] = true;\\n        /* We ensure that each iterate the queue pop all numbers belong to previous level in bfs */\\n        /* so we could know each number to any level belong (shortest path) */\\n        for (int level = 0, sz = 1; !q.empty(); sz = q.size(), ++level)\\n        {\\n\\n            while (sz--)\\n            {\\n                int x = q.front();\\n                q.pop();\\n\\n                for (int i = 0; i < nums.size(); i++)\\n                {\\n                    /* don\\'t repeat code use one function for the three operations */\\n                    if (process(x + nums[i], goal, q, visit) ||\\n                        process(x - nums[i], goal, q, visit) ||\\n                        process(x ^ nums[i], goal, q, visit))\\n                    {\\n                        /* if we reach the goal we know is the shortest path for it so we return the level */\\n                        return level + 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int minimumOperations(vector<int> &nums, int start, int goal)\\n    {\\n        return bfs(start, nums, goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    bool valid(int x)\\n    {\\n        return x > -1 && x < 1001;\\n    }\\n    bool process(int newNum, int goal, queue<int> &q, vector<bool> &visit)\\n    { /* check if number reach the goal */\\n        if (newNum == goal)\\n        {\\n            return true;\\n        }\\n        /* we must not visit number twicely\\n        because in first visit we itreate all numbers in array and do all operations on it */\\n        if (!valid(newNum) || visit[newNum])\\n        {\\n            return false;\\n        }\\n        q.push(newNum);\\n        visit[newNum] = true;\\n        return false;\\n    }\\n    int bfs(int start, vector<int> &nums, int goal)\\n    {\\n        queue<int> q;\\n        q.push(start);\\n\\n        vector<bool> visit(1001, false);\\n        visit[start] = true;\\n        /* We ensure that each iterate the queue pop all numbers belong to previous level in bfs */\\n        /* so we could know each number to any level belong (shortest path) */\\n        for (int level = 0, sz = 1; !q.empty(); sz = q.size(), ++level)\\n        {\\n\\n            while (sz--)\\n            {\\n                int x = q.front();\\n                q.pop();\\n\\n                for (int i = 0; i < nums.size(); i++)\\n                {\\n                    /* don\\'t repeat code use one function for the three operations */\\n                    if (process(x + nums[i], goal, q, visit) ||\\n                        process(x - nums[i], goal, q, visit) ||\\n                        process(x ^ nums[i], goal, q, visit))\\n                    {\\n                        /* if we reach the goal we know is the shortest path for it so we return the level */\\n                        return level + 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int minimumOperations(vector<int> &nums, int start, int goal)\\n    {\\n        return bfs(start, nums, goal);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2559478,
                "title": "c-bfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumOperations(vector<int>& a, int start, int goal) {\\n\\t\\t\\tvector<int> vis(1001);\\n\\t\\t\\tint count=0;\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tq.push(start);\\n\\t\\t\\twhile(q.size()) {\\n\\t\\t\\t\\tint sz=q.size();\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\twhile(sz--) {\\n\\t\\t\\t\\t\\tint x=q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tfor(int i=0;i<a.size();i++) {\\n\\t\\t\\t\\t\\t\\tfor(int y:{x+a[i],x-a[i],x^a[i]}) {\\n\\t\\t\\t\\t\\t\\t\\tif(y==goal||y==goal||y==goal) return count;\\n\\t\\t\\t\\t\\t\\t\\tif(y>=0&&y<=1000&&!vis[y]) {\\n\\t\\t\\t\\t\\t\\t\\t\\tvis[y]=1;\\n\\t\\t\\t\\t\\t\\t\\t\\tq.push(y);\\n\\t\\t\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumOperations(vector<int>& a, int start, int goal) {\\n\\t\\t\\tvector<int> vis(1001);\\n\\t\\t\\tint count=0;\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tq.push(start);\\n\\t\\t\\twhile(q.size()) {\\n\\t\\t\\t\\tint sz=q.size();\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\twhile(sz--) {\\n\\t\\t\\t\\t\\tint x=q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tfor(int i=0;i<a.size();i++) {\\n\\t\\t\\t\\t\\t\\tfor(int y:{x+a[i],x-a[i],x^a[i]}",
                "codeTag": "Java"
            },
            {
                "id": 2535560,
                "title": "python-solution",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        q = deque()\\n        q.append(start)\\n        ans = 0\\n        visited = set()\\n        while q:\\n            for _ in range(len(q)):\\n                el = q.popleft()\\n                if el == goal:\\n                    return ans\\n                if not (el < 0 or el > 1000 or el in visited):\\n                    visited.add(el)\\n                    for v in nums:\\n                        for op in [el + v, el - v, el ^ v]:\\n                            if op == goal:\\n                                return ans + 1\\n                            if not (op < 0 or op > 1000 or op in visited):\\n                                q.append(op)\\n            ans += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        q = deque()\\n        q.append(start)\\n        ans = 0\\n        visited = set()\\n        while q:\\n            for _ in range(len(q)):\\n                el = q.popleft()\\n                if el == goal:\\n                    return ans\\n                if not (el < 0 or el > 1000 or el in visited):\\n                    visited.add(el)\\n                    for v in nums:\\n                        for op in [el + v, el - v, el ^ v]:\\n                            if op == goal:\\n                                return ans + 1\\n                            if not (op < 0 or op > 1000 or op in visited):\\n                                q.append(op)\\n            ans += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425664,
                "title": "c-bfs",
                "content": "Top Down DP won\\'t work here beacuse subporblems are not independent of each others in other words the DP tree we will get won\\'t be Directed Acyclic Graph. We will get stuck in loops.\\n\\nAnd the order of operations also matter as we also have XOR so TOP DOWN just won\\'t work\\n```\\n\\nclass Solution\\n{\\npublic:\\n    bool check(int n)\\n    {\\n        return n >= 0 && n <= 1000;\\n    }\\n    int minimumOperations(vector<int> &nums, int start, int goal)\\n    {\\n\\n        vector<bool> vis(1001, false);\\n\\n        queue<int> q;\\n\\n        q.push(start);\\n\\n        int steps = 0;\\n\\n        while (!q.empty())\\n        {\\n            int s = q.size();\\n\\n            steps++;\\n\\n            while (s--)\\n            {\\n                int cur = q.front();\\n                q.pop();\\n\\n                if (cur < 0 || cur > 1000)\\n                    continue;\\n\\n                for (int n : nums)\\n\\n                {\\n                    int c1 = cur + n;\\n                    int c2 = cur - n;\\n                    int c3 = cur ^ n;\\n\\n                    if (c1 == goal || c2 == goal || c3 == goal)\\n                        return steps;\\n\\n                    if (check(c1) && !vis[c1])\\n                    {\\n                        q.push(c1);\\n                        vis[c1] = 1;\\n                    }\\n\\n                    if (check(c2) && !vis[c2])\\n                    {\\n                        q.push(c2);\\n                        vis[c2] = 1;\\n                    }\\n\\n                    if (check(c3) && !vis[c3])\\n                    {\\n                        q.push(c3);\\n                        vis[c3] = 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    bool check(int n)\\n    {\\n        return n >= 0 && n <= 1000;\\n    }\\n    int minimumOperations(vector<int> &nums, int start, int goal)\\n    {\\n\\n        vector<bool> vis(1001, false);\\n\\n        queue<int> q;\\n\\n        q.push(start);\\n\\n        int steps = 0;\\n\\n        while (!q.empty())\\n        {\\n            int s = q.size();\\n\\n            steps++;\\n\\n            while (s--)\\n            {\\n                int cur = q.front();\\n                q.pop();\\n\\n                if (cur < 0 || cur > 1000)\\n                    continue;\\n\\n                for (int n : nums)\\n\\n                {\\n                    int c1 = cur + n;\\n                    int c2 = cur - n;\\n                    int c3 = cur ^ n;\\n\\n                    if (c1 == goal || c2 == goal || c3 == goal)\\n                        return steps;\\n\\n                    if (check(c1) && !vis[c1])\\n                    {\\n                        q.push(c1);\\n                        vis[c1] = 1;\\n                    }\\n\\n                    if (check(c2) && !vis[c2])\\n                    {\\n                        q.push(c2);\\n                        vis[c2] = 1;\\n                    }\\n\\n                    if (check(c3) && !vis[c3])\\n                    {\\n                        q.push(c3);\\n                        vis[c3] = 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382471,
                "title": "c-basic-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        unordered_map<int, int> mp;\\n        queue<int> q;\\n        q.push(start);\\n        int ans=0;\\n        \\n        while(q.empty()==false){\\n            int count=q.size();\\n            while(count--){\\n                int v=q.front();\\n                q.pop();\\n                if(v==goal)return ans;\\n                if(v<0 || v>1000 || mp.find(v)!=mp.end()){\\n                    continue;\\n                }\\n                mp[v]++;\\n                for(int i=0;i<nums.size();i++){\\n                    int a=nums[i]+v;\\n                    int b=v-nums[i];\\n                    int c=nums[i]^v;\\n                    q.push(a);\\n                    q.push(b);\\n                    q.push(c);\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        unordered_map<int, int> mp;\\n        queue<int> q;\\n        q.push(start);\\n        int ans=0;\\n        \\n        while(q.empty()==false){\\n            int count=q.size();\\n            while(count--){\\n                int v=q.front();\\n                q.pop();\\n                if(v==goal)return ans;\\n                if(v<0 || v>1000 || mp.find(v)!=mp.end()){\\n                    continue;\\n                }\\n                mp[v]++;\\n                for(int i=0;i<nums.size();i++){\\n                    int a=nums[i]+v;\\n                    int b=v-nums[i];\\n                    int c=nums[i]^v;\\n                    q.push(a);\\n                    q.push(b);\\n                    q.push(c);\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354923,
                "title": "best-solution-c-thanks-to-deepak",
                "content": "class Solution {\\npublic:\\n   \\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n      int n=nums.size();\\n        queue<int>q;\\n        vector<bool>visited(1001,false);\\n        q.push(start);\\n        int ans=0;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                int x=q.front();\\n                q.pop();\\n                if(x==goal)   \\n                {\\n                    return ans;\\n                }\\n                if(x>1000 || x<0 ||visited[x]==true)\\n                {\\n                    continue;\\n                }\\n                visited[x]=true;\\n                for(int i=0;i<nums.size();i++){\\n                    int first=x+nums[i];\\n                    int second=x-nums[i];\\n                    int third=x^nums[i];\\n                    q.push(first);\\n                    q.push(second);\\n                    q.push(third);\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1; \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n   \\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n      int n=nums.size();\\n        queue<int>q;\\n        vector<bool>visited(1001,false);\\n        q.push(start);\\n        int ans=0;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                int x=q.front();\\n                q.pop();\\n                if(x==goal)   \\n                {\\n                    return ans;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2323879,
                "title": "typescript-iterative-bfs-solution",
                "content": "```TypeScript\\nfunction minimumOperations(\\n  nums: number[],\\n  start: number,\\n  goal: number\\n): number {\\n  const queueOfConversions: NumberConversion[] = [\\n    { currentNumber: start, numberOfOperations: 0 },\\n  ];\\n  const isVisitedNumber: IsVisitedNumber = {};\\n  let minimumNumberOfOperations = -1;\\n\\n  const isInTheRange = (num: number) => num >= 0 && num <= 1000;\\n  const updateMinimumOperations = (operations: number) =>\\n    minimumNumberOfOperations === -1\\n      ? (minimumNumberOfOperations = operations)\\n      : operations < minimumNumberOfOperations\\n      ? (minimumNumberOfOperations = operations)\\n      : null;\\n\\n  const handleNumberConversion = (\\n    currentNumber: number,\\n    numberOfOperations: number\\n  ) => {\\n    if (!isVisitedNumber[currentNumber] && isInTheRange(currentNumber)) {\\n      queueOfConversions.push({\\n        currentNumber,\\n        numberOfOperations,\\n      });\\n      isVisitedNumber[currentNumber] = true;\\n    } else if (!isInTheRange(currentNumber) && currentNumber === goal)\\n      updateMinimumOperations(numberOfOperations);\\n  };\\n\\n  while (queueOfConversions.length > 0) {\\n    let { currentNumber, numberOfOperations } =\\n      queueOfConversions.shift() as NumberConversion;\\n\\n    if (currentNumber === goal) {\\n      updateMinimumOperations(numberOfOperations);\\n      continue;\\n    }\\n\\n    numberOfOperations += 1;\\n\\n    nums.forEach((num) => {\\n      handleNumberConversion(currentNumber + num, numberOfOperations);\\n      handleNumberConversion(currentNumber - num, numberOfOperations);\\n      handleNumberConversion(currentNumber ^ num, numberOfOperations);\\n    });\\n  }\\n\\n  return minimumNumberOfOperations;\\n}\\n\\ninterface NumberConversion {\\n  currentNumber: number;\\n  numberOfOperations: number;\\n}\\n\\ninterface IsVisitedNumber {\\n  [num: number]: boolean;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Breadth-First Search"
                ],
                "code": "```TypeScript\\nfunction minimumOperations(\\n  nums: number[],\\n  start: number,\\n  goal: number\\n): number {\\n  const queueOfConversions: NumberConversion[] = [\\n    { currentNumber: start, numberOfOperations: 0 },\\n  ];\\n  const isVisitedNumber: IsVisitedNumber = {};\\n  let minimumNumberOfOperations = -1;\\n\\n  const isInTheRange = (num: number) => num >= 0 && num <= 1000;\\n  const updateMinimumOperations = (operations: number) =>\\n    minimumNumberOfOperations === -1\\n      ? (minimumNumberOfOperations = operations)\\n      : operations < minimumNumberOfOperations\\n      ? (minimumNumberOfOperations = operations)\\n      : null;\\n\\n  const handleNumberConversion = (\\n    currentNumber: number,\\n    numberOfOperations: number\\n  ) => {\\n    if (!isVisitedNumber[currentNumber] && isInTheRange(currentNumber)) {\\n      queueOfConversions.push({\\n        currentNumber,\\n        numberOfOperations,\\n      });\\n      isVisitedNumber[currentNumber] = true;\\n    } else if (!isInTheRange(currentNumber) && currentNumber === goal)\\n      updateMinimumOperations(numberOfOperations);\\n  };\\n\\n  while (queueOfConversions.length > 0) {\\n    let { currentNumber, numberOfOperations } =\\n      queueOfConversions.shift() as NumberConversion;\\n\\n    if (currentNumber === goal) {\\n      updateMinimumOperations(numberOfOperations);\\n      continue;\\n    }\\n\\n    numberOfOperations += 1;\\n\\n    nums.forEach((num) => {\\n      handleNumberConversion(currentNumber + num, numberOfOperations);\\n      handleNumberConversion(currentNumber - num, numberOfOperations);\\n      handleNumberConversion(currentNumber ^ num, numberOfOperations);\\n    });\\n  }\\n\\n  return minimumNumberOfOperations;\\n}\\n\\ninterface NumberConversion {\\n  currentNumber: number;\\n  numberOfOperations: number;\\n}\\n\\ninterface IsVisitedNumber {\\n  [num: number]: boolean;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2291606,
                "title": "walkthrough-on-approach-c-bfs-easy-to-understand-with-comments",
                "content": "```\\n//Time Complexity: O((1000 * N) //since we traverse each value only once for all x in the range\\n// space complexity: O(1000)\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        // at any time I can perform 3 operations to update start => goal \\n        // if(x < 0 || x > 1000) no more operations can be performed \\n        // so just check if we reach the goal or not \\n        // we do a BFS here \\n        // in start we push the start in the queue \\n        // we perform all three operations and check the conditions \\n        \\n        if(start == goal ) return 0; \\n        \\n        int n = nums.size(); \\n        queue<pair<int, int>> q; //[start, no of moves]\\n        q.push({start, 0}); // \\n\\n        // I also need to keep track of vis values and no of operations\\n        // if we visit again some value we again traverse the same routes so we skip them \\n        vector<int> vis(1001, 0);  \\n        vis[start] = 1;  \\n        \\n        while(!q.empty()){\\n            auto [x, d] = q.front(); \\n            q.pop();  \\n\\n           // Now we can perform 3 operations on the x \\n            \\n            for(auto it: nums){\\n                int np = x + it; \\n                int ns = x - it; \\n                int nx = x ^ it; \\n                \\n                 // if x >= 1000 or x <= 0 we don\\'t want to perform any operations \\n                \\n                if(np == goal) return d+1; \\n                if(ns == goal) return d+1; \\n                if(nx == goal) return d+1; \\n            \\n                \\n                if( np>= 0 && np<= 1000  && !vis[np] ) { //we check if we already visited or not\\n                    q.push({np, d+1});\\n                    vis[np] = 1; \\n                }\\n                if( ns>= 0 && ns<= 1000  && !vis[ns]) {\\n                    q.push({ns, d+1}); \\n                    vis[ns] = 1; \\n                }\\n                if( nx>= 0 && nx<= 1000 && !vis[nx]) {\\n                    q.push({nx, d+1}); \\n                    vis[nx] = 1; \\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        return -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n//Time Complexity: O((1000 * N) //since we traverse each value only once for all x in the range\\n// space complexity: O(1000)\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        // at any time I can perform 3 operations to update start => goal \\n        // if(x < 0 || x > 1000) no more operations can be performed \\n        // so just check if we reach the goal or not \\n        // we do a BFS here \\n        // in start we push the start in the queue \\n        // we perform all three operations and check the conditions \\n        \\n        if(start == goal ) return 0; \\n        \\n        int n = nums.size(); \\n        queue<pair<int, int>> q; //[start, no of moves]\\n        q.push({start, 0}); // \\n\\n        // I also need to keep track of vis values and no of operations\\n        // if we visit again some value we again traverse the same routes so we skip them \\n        vector<int> vis(1001, 0);  \\n        vis[start] = 1;  \\n        \\n        while(!q.empty()){\\n            auto [x, d] = q.front(); \\n            q.pop();  \\n\\n           // Now we can perform 3 operations on the x \\n            \\n            for(auto it: nums){\\n                int np = x + it; \\n                int ns = x - it; \\n                int nx = x ^ it; \\n                \\n                 // if x >= 1000 or x <= 0 we don\\'t want to perform any operations \\n                \\n                if(np == goal) return d+1; \\n                if(ns == goal) return d+1; \\n                if(nx == goal) return d+1; \\n            \\n                \\n                if( np>= 0 && np<= 1000  && !vis[np] ) { //we check if we already visited or not\\n                    q.push({np, d+1});\\n                    vis[np] = 1; \\n                }\\n                if( ns>= 0 && ns<= 1000  && !vis[ns]) {\\n                    q.push({ns, d+1}); \\n                    vis[ns] = 1; \\n                }\\n                if( nx>= 0 && nx<= 1000 && !vis[nx]) {\\n                    q.push({nx, d+1}); \\n                    vis[nx] = 1; \\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289994,
                "title": "c-bfs-clean-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        //jai shri ram\\n        queue<int>q;\\n        q.push(start);\\n        int level=0;\\n        unordered_set<int>vis;\\n        while(q.size()>0){\\n            int sz=q.size();\\n            while(sz-- >0){\\n                int top=q.front();\\n                q.pop();\\n                if(top==goal) return level;\\n                if(top<0 || top>1000) continue;\\n                if(vis.find(top)!=vis.end()) continue;\\n                vis.insert(top);\\n                for(auto x:nums){\\n                    q.push(top+x);\\n                    q.push(top-x);\\n                    q.push(top^x);\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        //jai shri ram\\n        queue<int>q;\\n        q.push(start);\\n        int level=0;\\n        unordered_set<int>vis;\\n        while(q.size()>0){\\n            int sz=q.size();\\n            while(sz-- >0){\\n                int top=q.front();\\n                q.pop();\\n                if(top==goal) return level;\\n                if(top<0 || top>1000) continue;\\n                if(vis.find(top)!=vis.end()) continue;\\n                vis.insert(top);\\n                for(auto x:nums){\\n                    q.push(top+x);\\n                    q.push(top-x);\\n                    q.push(top^x);\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276576,
                "title": "c-bfs-clean-elegant-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& arr, int start, int goal) {\\n        int mx = *max_element(arr.begin(), arr.end());\\n        int mn = *min_element(arr.begin(), arr.end());\\n        \\n        if(goal > 0 && 1000 + max(mx,mn) < goal) return -1;\\n        if(goal < 0 && max(mx,mn) < abs(goal)) return -1;\\n        \\n        queue<int> q;\\n        int n = arr.size(), lev = 0;\\n        \\n        bool vis[1001] = {false};\\n        \\n        q.push(start);\\n        \\n        while(!q.empty())\\n        {\\n            ++lev;\\n            int sz = q.size();\\n            \\n            for(int i=0; i<sz; ++i)\\n            {\\n                int front = q.front();\\n                q.pop();\\n                \\n                for(int j=0; j<n; ++j)\\n                {\\n                    int add = front + arr[j];\\n                    int sub = front - arr[j];\\n                    int xOr = front ^ arr[j];\\n                    \\n                    if(add == goal || sub == goal || xOr == goal)\\n                        return lev;\\n                    \\n                    if(add >= 0 && add <= 1000 && !vis[add])\\n                    {\\n                        vis[add] = true;\\n                        q.push(add);\\n                    }\\n                    if(sub >= 0 && sub <= 1000 && !vis[sub])\\n                    {\\n                        vis[sub] = true;\\n                        q.push(sub);\\n                    }\\n                    if(xOr >= 0 && xOr <= 1000 && !vis[xOr])\\n                    {\\n                        vis[xOr] = true;\\n                        q.push(xOr);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& arr, int start, int goal) {\\n        int mx = *max_element(arr.begin(), arr.end());\\n        int mn = *min_element(arr.begin(), arr.end());\\n        \\n        if(goal > 0 && 1000 + max(mx,mn) < goal) return -1;\\n        if(goal < 0 && max(mx,mn) < abs(goal)) return -1;\\n        \\n        queue<int> q;\\n        int n = arr.size(), lev = 0;\\n        \\n        bool vis[1001] = {false};\\n        \\n        q.push(start);\\n        \\n        while(!q.empty())\\n        {\\n            ++lev;\\n            int sz = q.size();\\n            \\n            for(int i=0; i<sz; ++i)\\n            {\\n                int front = q.front();\\n                q.pop();\\n                \\n                for(int j=0; j<n; ++j)\\n                {\\n                    int add = front + arr[j];\\n                    int sub = front - arr[j];\\n                    int xOr = front ^ arr[j];\\n                    \\n                    if(add == goal || sub == goal || xOr == goal)\\n                        return lev;\\n                    \\n                    if(add >= 0 && add <= 1000 && !vis[add])\\n                    {\\n                        vis[add] = true;\\n                        q.push(add);\\n                    }\\n                    if(sub >= 0 && sub <= 1000 && !vis[sub])\\n                    {\\n                        vis[sub] = true;\\n                        q.push(sub);\\n                    }\\n                    if(xOr >= 0 && xOr <= 1000 && !vis[xOr])\\n                    {\\n                        vis[xOr] = true;\\n                        q.push(xOr);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199119,
                "title": "c-faster-than-95-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& x, int start, int goal) {\\n        queue<long long int> q;\\n        vector<long long int> v(1003,-1);\\n        long long int i,j;\\n        int k;\\n        for(k=1;k<v.size();k++) v[k]=-1;\\n        v[start]=0;\\n        q.push(start);\\n        while (q.size()>0)\\n        {\\n            i=q.front();\\n            q.pop();\\n            if (i==goal)return v[i];\\n            for(k=0;k<x.size();k++)\\n            {\\n                j=x[k];\\n                if (j+i==goal || i-j==goal || (i^j)==goal)\\n                    return v[i]+1;\\n                if (0<=j+i&& j+i<=1000 && v[j+i]==-1)\\n                {\\n                    v[j+i]=v[i]+1;\\n                    q.push(j+i);\\n                }\\n\\n                 if (0<=(i-j)&& (i-j)<=1000 && v[i-j]==-1)\\n                     \\n                {\\n                            v[i-j]=v[i]+1;\\n                            q.push(i-j);\\n                }\\n                if (0<=(j^i)&& (j^i)<=1000 && v[(j^i)]==-1)\\n                {\\n                    v[(i^j)]=v[i]+1;\\n                    q.push(j^i);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& x, int start, int goal) {\\n        queue<long long int> q;\\n        vector<long long int> v(1003,-1);\\n        long long int i,j;\\n        int k;\\n        for(k=1;k<v.size();k++) v[k]=-1;\\n        v[start]=0;\\n        q.push(start);\\n        while (q.size()>0)\\n        {\\n            i=q.front();\\n            q.pop();\\n            if (i==goal)return v[i];\\n            for(k=0;k<x.size();k++)\\n            {\\n                j=x[k];\\n                if (j+i==goal || i-j==goal || (i^j)==goal)\\n                    return v[i]+1;\\n                if (0<=j+i&& j+i<=1000 && v[j+i]==-1)\\n                {\\n                    v[j+i]=v[i]+1;\\n                    q.push(j+i);\\n                }\\n\\n                 if (0<=(i-j)&& (i-j)<=1000 && v[i-j]==-1)\\n                     \\n                {\\n                            v[i-j]=v[i]+1;\\n                            q.push(i-j);\\n                }\\n                if (0<=(j^i)&& (j^i)<=1000 && v[(j^i)]==-1)\\n                {\\n                    v[(i^j)]=v[i]+1;\\n                    q.push(j^i);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182534,
                "title": "easy-c-approach",
                "content": "\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<pair<int,int>>q;\\n        vector<bool>v(1001, false);\\n        q.push({0,start});\\n        while(q.size())\\n        {\\n            pair<int,int>a = q.front();\\n           \\n            q.pop();\\n            if(a.second == goal)\\n                return a.first;\\n            if(a.second < 0 || a.second > 1000 || v[a.second] == true)\\n                continue;\\n            v[a.second] = true;\\n            for(auto x:nums)\\n            {\\n                int y = a.second+x;\\n               \\n                    q.push({a.first+1,y});\\n                \\n                int t = a.second - x;\\n                \\n                    q.push({a.first+1, t});\\n                \\n                int z = a.second^x;\\n                \\n                    q.push({a.first+1, z});\\n                \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<pair<int,int>>q;\\n        vector<bool>v(1001, false);\\n        q.push({0,start});\\n        while(q.size())\\n        {\\n            pair<int,int>a = q.front();\\n           \\n            q.pop();\\n            if(a.second == goal)\\n                return a.first;\\n            if(a.second < 0 || a.second > 1000 || v[a.second] == true)\\n                continue;\\n            v[a.second] = true;\\n            for(auto x:nums)\\n            {\\n                int y = a.second+x;\\n               \\n                    q.push({a.first+1,y});\\n                \\n                int t = a.second - x;\\n                \\n                    q.push({a.first+1, t});\\n                \\n                int z = a.second^x;\\n                \\n                    q.push({a.first+1, z});\\n                \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152593,
                "title": "c-bfs-like-approach",
                "content": "class Solution {\\npublic:\\n\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> q;\\n        q.push(start);\\n        vector<bool> v(1001, false);\\n        int ans = 0;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                int x = q.front();\\n                q.pop();\\n                if(x==goal) return ans;\\n                if(x>1000 or x<0 or v[x]==true) continue;\\n                v[x]= true;\\n                for(auto y: nums){\\n                    q.push(x+y);\\n                    q.push(x-y);\\n                    q.push(x^y);\\n                    \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> q;\\n        q.push(start);\\n        vector<bool> v(1001, false);\\n        int ans = 0;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                int x = q.front();\\n                q.pop();\\n                if(x==goal) return ans;\\n                if(x>1000 or x<0 or v[x]==true) continue;\\n                v[x]= true;\\n                for(auto y: nums){\\n                    q.push(x+y);\\n                    q.push(x-y);\\n                    q.push(x^y);\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2138013,
                "title": "simple-and-fast-java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal){\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        int arr[] = new int[1001];\\n        arr[start] = 1;\\n        q.add(start);\\n        int level = 1;\\n        while(q.isEmpty()==false){\\n            int size = q.size();\\n            while(size-- >0){\\n                int el = q.poll();\\n                for(int i : nums){\\n                    int val1 = el+i;\\n                    int val2 = el-i;\\n                    int val3 = el^i;\\n                    if(val1==goal || val2==goal || val3==goal){\\n                        return level;\\n                    }\\n                    if(val1<=1000 && val1>=0 && arr[val1]==0){\\n                        arr[val1] = 1;\\n                        q.add(val1);\\n                    }\\n                    if(val2<=1000 && val2>=0 && arr[val2]==0){\\n                        arr[val2] = 1;\\n                        q.add(val2);\\n                    }\\n                    if(val3<=1000 && val3>=0 && arr[val3]==0){\\n                        arr[val3] = 1;\\n                        q.add(val3);\\n                    }\\n                }\\n            }\\n            level++; \\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal){\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        int arr[] = new int[1001];\\n        arr[start] = 1;\\n        q.add(start);\\n        int level = 1;\\n        while(q.isEmpty()==false){\\n            int size = q.size();\\n            while(size-- >0){\\n                int el = q.poll();\\n                for(int i : nums){\\n                    int val1 = el+i;\\n                    int val2 = el-i;\\n                    int val3 = el^i;\\n                    if(val1==goal || val2==goal || val3==goal){\\n                        return level;\\n                    }\\n                    if(val1<=1000 && val1>=0 && arr[val1]==0){\\n                        arr[val1] = 1;\\n                        q.add(val1);\\n                    }\\n                    if(val2<=1000 && val2>=0 && arr[val2]==0){\\n                        arr[val2] = 1;\\n                        q.add(val2);\\n                    }\\n                    if(val3<=1000 && val3>=0 && arr[val3]==0){\\n                        arr[val3] = 1;\\n                        q.add(val3);\\n                    }\\n                }\\n            }\\n            level++; \\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088016,
                "title": "golang-bfs",
                "content": "```\\n\\nfunc minimumOperations(nums []int, start int, goal int) int {\\n    record:= make([]int,1001)\\n    for idx:=0;idx<len(record);idx++{\\n        record[idx]=-1\\n    }\\n    record[start]=0\\n    queue:=[]int{start}\\n    \\n    for len(queue)>0{\\n        cur:=queue[0]\\n        val:= record[cur]\\n        queue=queue[1:]\\n        for _,num:=range nums{\\n            if cur+num == goal || cur-num == goal||cur^num==goal{\\n                return val+1\\n            }\\n            if cur+num>=0&&cur+num<=1000&&record[cur+num]==-1{\\n                record[cur+num]=val+1\\n                queue=append(queue,cur+num)\\n            }\\n            \\n            if cur-num>=0&&cur-num<=1000&&record[cur-num]==-1{\\n                record[cur-num]=val+1\\n                queue=append(queue,cur-num)\\n            }\\n            \\n            if cur^num>=0 &&cur^num<=1000&&record[cur^num]==-1{\\n                record[cur^num]=val+1\\n                queue=append(queue,cur^num)\\n            }\\n        }\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nfunc minimumOperations(nums []int, start int, goal int) int {\\n    record:= make([]int,1001)\\n    for idx:=0;idx<len(record);idx++{\\n        record[idx]=-1\\n    }\\n    record[start]=0\\n    queue:=[]int{start}\\n    \\n    for len(queue)>0{\\n        cur:=queue[0]\\n        val:= record[cur]\\n        queue=queue[1:]\\n        for _,num:=range nums{\\n            if cur+num == goal || cur-num == goal||cur^num==goal{\\n                return val+1\\n            }\\n            if cur+num>=0&&cur+num<=1000&&record[cur+num]==-1{\\n                record[cur+num]=val+1\\n                queue=append(queue,cur+num)\\n            }\\n            \\n            if cur-num>=0&&cur-num<=1000&&record[cur-num]==-1{\\n                record[cur-num]=val+1\\n                queue=append(queue,cur-num)\\n            }\\n            \\n            if cur^num>=0 &&cur^num<=1000&&record[cur^num]==-1{\\n                record[cur^num]=val+1\\n                queue=append(queue,cur^num)\\n            }\\n        }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2060149,
                "title": "c-priority-queue-bfs",
                "content": "```\\n\\n//this solution is to find out the shortest path distance from start to goal, by traversing the graph\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        if(goal==start) return 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, std::greater<pair<int, int>>> q;\\n        q.push({ 0,start });\\n\\n        bool visited[1001]={};\\n        while (!q.empty()) {\\n            auto t = q.top(); \\n\\t\\t\\tq.pop();\\n\\t\\t\\t\\n            if (visited[t.second]) continue;\\n            visited[t.second] = true;\\n\\n            for (auto& n : nums)  //for each next candidates, BFS traverse the graph\\n              for(auto&next: {t.second + n, t.second -n, t.second ^ n}) {\\n                if(next==goal)  return t.first+1;\\n                if(next>=0&&next<=1000)  { q.push({ t.first + 1, next }); }\\n              }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n//this solution is to find out the shortest path distance from start to goal, by traversing the graph\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        if(goal==start) return 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, std::greater<pair<int, int>>> q;\\n        q.push({ 0,start });\\n\\n        bool visited[1001]={};\\n        while (!q.empty()) {\\n            auto t = q.top(); \\n\\t\\t\\tq.pop();\\n\\t\\t\\t\\n            if (visited[t.second]) continue;\\n            visited[t.second] = true;\\n\\n            for (auto& n : nums)  //for each next candidates, BFS traverse the graph\\n              for(auto&next: {t.second + n, t.second -n, t.second ^ n}) {\\n                if(next==goal)  return t.first+1;\\n                if(next>=0&&next<=1000)  { q.push({ t.first + 1, next }); }\\n              }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020375,
                "title": "java-easy-understanding-bfs",
                "content": "\\tclass Solution {\\n\\t\\tpublic int minimumOperations(int[] nums, int start, int goal) {\\n\\t\\t\\t// Set up linked list \\n\\t\\t\\tLinkedList<Integer> queue = new LinkedList<>();\\n\\t\\t\\tqueue.add(start);\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tif (start == goal) {\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t\\tboolean[] visited = new boolean[1001];\\n\\t\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tint size = queue.size();\\n\\t\\t\\t\\tfor (int i = 0; i<size;i++) {\\n\\t\\t\\t\\t\\tint cur = queue.pollFirst();\\n\\t\\t\\t\\t\\tif (visited[cur] == false) {\\n\\t\\t\\t\\t\\t\\tvisited[cur] = true;\\n\\t\\t\\t\\t\\t\\tfor (int num:nums) {\\n\\t\\t\\t\\t\\t\\t\\t// Plus\\n\\t\\t\\t\\t\\t\\t\\tint curPlus = cur + num;\\n\\t\\t\\t\\t\\t\\t\\tif (curPlus == goal) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif (curPlus >= 0 && curPlus <= 1000) {\\n\\t\\t\\t\\t\\t\\t\\t\\tqueue.addLast(curPlus);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t// Minus\\n\\t\\t\\t\\t\\t\\t\\tint curMinus = cur - num;\\n\\t\\t\\t\\t\\t\\t\\tif (curMinus == goal) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif (curMinus >= 0 && curMinus <= 1000) {\\n\\t\\t\\t\\t\\t\\t\\t\\tqueue.addLast(curMinus);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t// XOR\\n\\t\\t\\t\\t\\t\\t\\tint curXOR = cur^num;\\n\\t\\t\\t\\t\\t\\t\\tif (curXOR == goal) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif (curXOR >= 0 && curXOR <= 1000) {\\n\\t\\t\\t\\t\\t\\t\\t\\tqueue.addLast(curXOR);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int minimumOperations(int[] nums, int start, int goal) {\\n\\t\\t\\t// Set up linked list \\n\\t\\t\\tLinkedList<Integer> queue = new LinkedList<>();\\n\\t\\t\\tqueue.add(start);\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tif (start == goal) {\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1973376,
                "title": "scala-bitset",
                "content": "```\\nimport scala.annotation.tailrec\\nimport scala.collection.immutable.BitSet\\n\\nobject Solution {\\n  private val Range = 0 to 1000\\n  \\n  def minimumOperations(nums: Array[Int], start: Int, goal: Int): Int = {\\n    @tailrec\\n    def search(xs: Set[Int], visited: Set[Int], numOperations: Int): Int = {\\n      if (xs.isEmpty) -1\\n      else xs\\n        .iterator\\n        .flatMap(x => nums\\n          .iterator\\n          .flatMap(num => Iterator(x + num, x - num, x ^ num).filter(!xs.contains(_)).filter(!visited.contains(_))))\\n        .partition(Range.contains) match {\\n          case (inRange, _) if Range.contains(goal) => \\n            val newXs = inRange.toSet\\n            if (newXs.contains(goal)) numOperations + 1 else search(newXs, visited | xs, numOperations + 1)\\n\\n          case (_, notInRange) if notInRange.contains(goal) => numOperations + 1\\n\\n          case (inRange, _) => search(inRange.toSet, visited | xs, numOperations + 1)\\n        }\\n      }\\n    \\n    if (start == goal) 0 else search(BitSet(start).filter(Range.contains), BitSet.empty, 0)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```\\nimport scala.annotation.tailrec\\nimport scala.collection.immutable.BitSet\\n\\nobject Solution {\\n  private val Range = 0 to 1000\\n  \\n  def minimumOperations(nums: Array[Int], start: Int, goal: Int): Int = {\\n    @tailrec\\n    def search(xs: Set[Int], visited: Set[Int], numOperations: Int): Int = {\\n      if (xs.isEmpty) -1\\n      else xs\\n        .iterator\\n        .flatMap(x => nums\\n          .iterator\\n          .flatMap(num => Iterator(x + num, x - num, x ^ num).filter(!xs.contains(_)).filter(!visited.contains(_))))\\n        .partition(Range.contains) match {\\n          case (inRange, _) if Range.contains(goal) => \\n            val newXs = inRange.toSet\\n            if (newXs.contains(goal)) numOperations + 1 else search(newXs, visited | xs, numOperations + 1)\\n\\n          case (_, notInRange) if notInRange.contains(goal) => numOperations + 1\\n\\n          case (inRange, _) => search(inRange.toSet, visited | xs, numOperations + 1)\\n        }\\n      }\\n    \\n    if (start == goal) 0 else search(BitSet(start).filter(Range.contains), BitSet.empty, 0)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1973348,
                "title": "neat-bi-directional-bfs-template-usage",
                "content": "I saw most answers are based on default BFS, while this problem should be a good candidate to utilize Bi-directional BFS given both `start` & `goal`.\\nOther problems that can apply bi-direction BFS: #752, #1197, #127, #403\\nhttps://leetcode.com/problems/frog-jump/\\nhttps://leetcode.com/problems/minimum-knight-moves/\\nhttps://leetcode.com/problems/open-the-lock/\\nhttps://leetcode.com/problems/word-ladder/\\n\\n```\\ndef minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n\\t\"\"\"\\n\\tRuntime: 2479 ms, faster than 74.19% of Python3 online submissions for Minimum Operations to Convert Number.\\n\\t\"\"\"\\n\\tq1, q2 = set([start]), set([goal])\\n\\tstep = 0\\n\\tvis = set([start, goal])\\n\\twhile q1:\\n\\t\\t# swap the q\\'s, always expand the smaller one (optimize)\\n\\t\\tif len(q1) > len(q2):\\n\\t\\t\\tq1, q2 = q2, q1\\n\\t\\tq1_nxt = set()\\n\\t\\tfor v in q1:\\n\\t\\t\\t# BUG:\\n\\t\\t\\t# if v in q2:\\n\\t\\t\\t#     return step\\n\\t\\t\\tfor n in nums:\\n\\t\\t\\t\\tfor vv in (v + n, v - n, v ^ n):\\n\\t\\t\\t\\t\\tif vv in q2:\\n\\t\\t\\t\\t\\t\\treturn step + 1\\n\\t\\t\\t\\t\\tif vv in vis or not 0 <= vv <= 1000:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tvis.add(vv)\\n\\t\\t\\t\\t\\tq1_nxt.add(vv)\\n\\t\\tq1 = q1_nxt\\n\\t\\tstep += 1\\n\\treturn -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n\\t\"\"\"\\n\\tRuntime: 2479 ms, faster than 74.19% of Python3 online submissions for Minimum Operations to Convert Number.\\n\\t\"\"\"\\n\\tq1, q2 = set([start]), set([goal])\\n\\tstep = 0\\n\\tvis = set([start, goal])\\n\\twhile q1:\\n\\t\\t# swap the q\\'s, always expand the smaller one (optimize)\\n\\t\\tif len(q1) > len(q2):\\n\\t\\t\\tq1, q2 = q2, q1\\n\\t\\tq1_nxt = set()\\n\\t\\tfor v in q1:\\n\\t\\t\\t# BUG:\\n\\t\\t\\t# if v in q2:\\n\\t\\t\\t#     return step\\n\\t\\t\\tfor n in nums:\\n\\t\\t\\t\\tfor vv in (v + n, v - n, v ^ n):\\n\\t\\t\\t\\t\\tif vv in q2:\\n\\t\\t\\t\\t\\t\\treturn step + 1\\n\\t\\t\\t\\t\\tif vv in vis or not 0 <= vv <= 1000:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tvis.add(vv)\\n\\t\\t\\t\\t\\tq1_nxt.add(vv)\\n\\t\\tq1 = q1_nxt\\n\\t\\tstep += 1\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1903705,
                "title": "c-clean-code-100ms-bfs-simple-solution-friendly-for-reading",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        vector<bool> visited(1001, false); // [0, 1000] are valid\\n        queue<int> q;\\n        queue<int> nextQ;\\n        int cur;\\n        int steps = 1;\\n\\n        auto checkPush = [&](int val) {\\n            if (val == goal) { // goal might be out of range[0,1000] , we should check it first\\n                return true;\\n            }\\n            if (val < 0 || val > 1000) {\\n                return false;\\n            }\\n            if (visited[val] == true) {\\n                return false;\\n            }\\n            visited[val] = true;\\n            nextQ.push(val);\\n            return false;\\n        };\\n\\n        q.push(start);\\n        visited[start] = true;\\n        while (true) {\\n            while (q.size() > 0) {\\n                cur = q.front();\\n                q.pop();\\n\\n                for (auto &num : nums) {\\n                    if (checkPush(cur+num) ||\\n                        checkPush(cur-num) ||\\n                        checkPush(cur^num)) {\\n                        return steps;\\n                    }\\n                }\\n            }\\n            \\n            if (nextQ.size() == 0) {\\n\\t\\t\\t    // all the possibilities are out of range, hence break and return -1\\n                break;\\n            }\\n\\n            q = move(nextQ);\\n            ++steps;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        vector<bool> visited(1001, false); // [0, 1000] are valid\\n        queue<int> q;\\n        queue<int> nextQ;\\n        int cur;\\n        int steps = 1;\\n\\n        auto checkPush = [&](int val) {\\n            if (val == goal) { // goal might be out of range[0,1000] , we should check it first\\n                return true;\\n            }\\n            if (val < 0 || val > 1000) {\\n                return false;\\n            }\\n            if (visited[val] == true) {\\n                return false;\\n            }\\n            visited[val] = true;\\n            nextQ.push(val);\\n            return false;\\n        };\\n\\n        q.push(start);\\n        visited[start] = true;\\n        while (true) {\\n            while (q.size() > 0) {\\n                cur = q.front();\\n                q.pop();\\n\\n                for (auto &num : nums) {\\n                    if (checkPush(cur+num) ||\\n                        checkPush(cur-num) ||\\n                        checkPush(cur^num)) {\\n                        return steps;\\n                    }\\n                }\\n            }\\n            \\n            if (nextQ.size() == 0) {\\n\\t\\t\\t    // all the possibilities are out of range, hence break and return -1\\n                break;\\n            }\\n\\n            q = move(nextQ);\\n            ++steps;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877030,
                "title": "javascript-bfs-solution",
                "content": "```var minimumOperations = function(nums, start, goal) {\\n    let dist = {}\\n    dist[start] = 0\\n    let y = []\\n    y.push(start)\\n    while(y.length > 0) {\\n        let current = y.shift(0)\\n        \\n        for(let i = 0; i < nums.length; i++) {\\n            let nx = current + nums[i]\\n            let ny = current - nums[i]\\n            let nz = current ^ nums[i]\\n            \\n            if(nx === goal || ny === goal || nz === goal) {\\n                return dist[current] + 1\\n            }\\n            \\n            if(0 <= nx <= 1000) {\\n               if (!dist[nx]) {\\n                    dist[nx] = dist[current] + 1\\n                    y.push(nx)\\n                } \\n            }\\n            if(0 <= ny <= 1000) {\\n               if (!dist[ny]) {\\n                    dist[ny] = dist[current] + 1\\n                    y.push(ny)\\n                } \\n            }\\n            if(0 <= nz <= 1000)\\n            if (!dist[nz]) {\\n                dist[nz] = dist[current] + 1\\n                y.push(nz)\\n            }\\n        } \\n    }\\n    \\n    return -1\\n};```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```var minimumOperations = function(nums, start, goal) {\\n    let dist = {}\\n    dist[start] = 0\\n    let y = []\\n    y.push(start)\\n    while(y.length > 0) {\\n        let current = y.shift(0)\\n        \\n        for(let i = 0; i < nums.length; i++) {\\n            let nx = current + nums[i]\\n            let ny = current - nums[i]\\n            let nz = current ^ nums[i]\\n            \\n            if(nx === goal || ny === goal || nz === goal) {\\n                return dist[current] + 1\\n            }\\n            \\n            if(0 <= nx <= 1000) {\\n               if (!dist[nx]) {\\n                    dist[nx] = dist[current] + 1\\n                    y.push(nx)\\n                } \\n            }\\n            if(0 <= ny <= 1000) {\\n               if (!dist[ny]) {\\n                    dist[ny] = dist[current] + 1\\n                    y.push(ny)\\n                } \\n            }\\n            if(0 <= nz <= 1000)\\n            if (!dist[nz]) {\\n                dist[nz] = dist[current] + 1\\n                y.push(nz)\\n            }\\n        } \\n    }\\n    \\n    return -1\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 1874418,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    private void check(long val,Queue<Long>q,Set<Long>set){\\n        if(val>=0&&val<=1000&&!set.contains(val)){\\n            set.add(val);\\n            q.add(val);\\n        }\\n    }\\n    public int minimumOperations(int[] arr, int start, int goal) {\\n        Queue<Long>q=new LinkedList<>();\\n        Set<Long>set=new HashSet<>();\\n        q.add((long)start);\\n        int count=0;\\n        long nums[]=new long[arr.length];\\n        for(int i=0;i<arr.length;i++)\\n            nums[i]=(long)arr[i];\\n        while(!q.isEmpty()){\\n            for(int size=q.size();size!=0;size--){\\n                long mid=q.remove();\\n                for(long num:nums){\\n                    long res=num+mid;\\n                    if(res==goal)return count+1;\\n                    check(res,q,set);\\n                    res=mid-num;\\n                    if(res==goal)return count+1;\\n                    check(res,q,set);\\n                    res=(num^mid);\\n                    if(res==goal)return count+1;\\n                    check(res,q,set);\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private void check(long val,Queue<Long>q,Set<Long>set){\\n        if(val>=0&&val<=1000&&!set.contains(val)){\\n            set.add(val);\\n            q.add(val);\\n        }\\n    }\\n    public int minimumOperations(int[] arr, int start, int goal) {\\n        Queue<Long>q=new LinkedList<>();\\n        Set<Long>set=new HashSet<>();\\n        q.add((long)start);\\n        int count=0;\\n        long nums[]=new long[arr.length];\\n        for(int i=0;i<arr.length;i++)\\n            nums[i]=(long)arr[i];\\n        while(!q.isEmpty()){\\n            for(int size=q.size();size!=0;size--){\\n                long mid=q.remove();\\n                for(long num:nums){\\n                    long res=num+mid;\\n                    if(res==goal)return count+1;\\n                    check(res,q,set);\\n                    res=mid-num;\\n                    if(res==goal)return count+1;\\n                    check(res,q,set);\\n                    res=(num^mid);\\n                    if(res==goal)return count+1;\\n                    check(res,q,set);\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867417,
                "title": "java-simple-bfs-solution",
                "content": "```\\n    public int minimumOperations(int[] nums, int start, int goal) {        \\n        if(start==goal) return 0;\\n        \\n        int ops=0;\\n        Queue<Integer> bfsQ = new LinkedList<>(); bfsQ.add(start);\\n        HashSet<Integer> visited = new HashSet<>(); //Can use an array of length 1000 as well, as items will always be 0 <= x <= 1000\\n        \\n        while(!bfsQ.isEmpty()){\\n            int currItemCount = bfsQ.size();\\n            for(int i=0; i<currItemCount; i++){\\n                int item = bfsQ.poll();\\n                for(int num:nums){\\n                    int res=item+num;\\n                    if(res==goal) return ops+1;\\n                    checkAndAdd(res, bfsQ, visited);\\n                    res=item-num;\\n                    if(res==goal) return ops+1;\\n                    checkAndAdd(res, bfsQ, visited);\\n                    res=item^num;\\n                    if(res==goal) return ops+1;\\n                    checkAndAdd(res, bfsQ, visited);\\n                }\\n            }\\n            ops++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private void checkAndAdd(int res, Queue<Integer> neighbours, HashSet<Integer> visited){\\n        if(res>=0&&res<=1000&&!visited.contains(res)){\\n            neighbours.add(res);\\n            visited.add(res);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int minimumOperations(int[] nums, int start, int goal) {        \\n        if(start==goal) return 0;\\n        \\n        int ops=0;\\n        Queue<Integer> bfsQ = new LinkedList<>(); bfsQ.add(start);\\n        HashSet<Integer> visited = new HashSet<>(); //Can use an array of length 1000 as well, as items will always be 0 <= x <= 1000\\n        \\n        while(!bfsQ.isEmpty()){\\n            int currItemCount = bfsQ.size();\\n            for(int i=0; i<currItemCount; i++){\\n                int item = bfsQ.poll();\\n                for(int num:nums){\\n                    int res=item+num;\\n                    if(res==goal) return ops+1;\\n                    checkAndAdd(res, bfsQ, visited);\\n                    res=item-num;\\n                    if(res==goal) return ops+1;\\n                    checkAndAdd(res, bfsQ, visited);\\n                    res=item^num;\\n                    if(res==goal) return ops+1;\\n                    checkAndAdd(res, bfsQ, visited);\\n                }\\n            }\\n            ops++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private void checkAndAdd(int res, Queue<Integer> neighbours, HashSet<Integer> visited){\\n        if(res>=0&&res<=1000&&!visited.contains(res)){\\n            neighbours.add(res);\\n            visited.add(res);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1827710,
                "title": "c-bfs-concise",
                "content": "```\\nint minimumOperations(vector<int>& nums, int start, int goal) \\n    {\\n        int ctr=0;\\n        vector<bool> vis(1001, false);\\n        queue<int> q;\\n        q.push(start);\\n        int i=0;\\n        \\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int curr=q.front();\\n                q.pop();\\n                if(curr==goal)\\n                    return ctr;\\n                if(curr>1000||curr<0||vis[curr])\\n                    continue;\\n                vis[curr]=true;\\n                \\n                for(auto i:nums)\\n                {\\n                    q.push(curr+i);\\n                    q.push(curr-i);\\n                    q.push(curr^i);\\n                }\\n            }\\n            \\n            ctr++;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nint minimumOperations(vector<int>& nums, int start, int goal) \\n    {\\n        int ctr=0;\\n        vector<bool> vis(1001, false);\\n        queue<int> q;\\n        q.push(start);\\n        int i=0;\\n        \\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int curr=q.front();\\n                q.pop();\\n                if(curr==goal)\\n                    return ctr;\\n                if(curr>1000||curr<0||vis[curr])\\n                    continue;\\n                vis[curr]=true;\\n                \\n                for(auto i:nums)\\n                {\\n                    q.push(curr+i);\\n                    q.push(curr-i);\\n                    q.push(curr^i);\\n                }\\n            }\\n            \\n            ctr++;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1800370,
                "title": "check-this-one-clean-explained",
                "content": "```\\nclass Solution {\\nprivate:\\n    const int MIN = 0, MAX = 1000;\\n    \\n    bool isValid(const int &value){\\n        return MIN <= value && value <= MAX;\\n    }\\n\\n    int bfs_path(const vector<int> &nums, const int &start, const int &goal){\\n        queue<int> q;\\n        vector<bool> visited(MAX + 1);\\n\\n        q.push(start);\\n        visited[start] = true;\\n\\n        for(int steps = 0, sz = q.size(); !q.empty(); ++steps, sz = q.size()){\\n            while(sz--){\\n                int cur = q.front();\\n                q.pop();\\n\\n                for(const auto &val : nums){\\n                    int newVal1 = cur - val, newVal2 = cur + val, newVal3 = cur ^ val;\\n                    \\n                    if(newVal1 == goal || newVal2 == goal || newVal3 == goal)\\n                        return steps + 1;\\n\\n                    if(!isValid(cur))\\n                        continue;\\n\\n                    if(isValid(newVal1) && !visited[newVal1])\\n                        visited[newVal1] = true, q.push(newVal1);\\n\\n                    if(isValid(newVal2) && !visited[newVal2])\\n                        visited[newVal2] = true, q.push(newVal2);\\n\\n                    if(isValid(newVal3) && !visited[newVal3])\\n                        visited[newVal3] = true, q.push(newVal3);\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        return bfs_path(nums, start, goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const int MIN = 0, MAX = 1000;\\n    \\n    bool isValid(const int &value){\\n        return MIN <= value && value <= MAX;\\n    }\\n\\n    int bfs_path(const vector<int> &nums, const int &start, const int &goal){\\n        queue<int> q;\\n        vector<bool> visited(MAX + 1);\\n\\n        q.push(start);\\n        visited[start] = true;\\n\\n        for(int steps = 0, sz = q.size(); !q.empty(); ++steps, sz = q.size()){\\n            while(sz--){\\n                int cur = q.front();\\n                q.pop();\\n\\n                for(const auto &val : nums){\\n                    int newVal1 = cur - val, newVal2 = cur + val, newVal3 = cur ^ val;\\n                    \\n                    if(newVal1 == goal || newVal2 == goal || newVal3 == goal)\\n                        return steps + 1;\\n\\n                    if(!isValid(cur))\\n                        continue;\\n\\n                    if(isValid(newVal1) && !visited[newVal1])\\n                        visited[newVal1] = true, q.push(newVal1);\\n\\n                    if(isValid(newVal2) && !visited[newVal2])\\n                        visited[newVal2] = true, q.push(newVal2);\\n\\n                    if(isValid(newVal3) && !visited[newVal3])\\n                        visited[newVal3] = true, q.push(newVal3);\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        return bfs_path(nums, start, goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783107,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        int[] bfs = new int[1001];\\n        Queue<Integer> q = new LinkedList();\\n        q.offer(start);\\n        int moves = 0;\\n        while(!q.isEmpty())\\n        {\\n            int len = q.size();\\n            for(int i = 0; i < len; i++)\\n            {\\n                int val = q.poll();\\n                if(val == goal) return moves;\\n                if(val > 1000 || val < 0 || bfs[val] != 0) continue;\\n                \\n                bfs[val] = 1;\\n                for(int n: nums)\\n                {\\n                    q.offer(val + n);\\n                    q.offer(val - n);\\n                    q.offer(val ^ n);\\n                }\\n                \\n            }\\n            moves++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        int[] bfs = new int[1001];\\n        Queue<Integer> q = new LinkedList();\\n        q.offer(start);\\n        int moves = 0;\\n        while(!q.isEmpty())\\n        {\\n            int len = q.size();\\n            for(int i = 0; i < len; i++)\\n            {\\n                int val = q.poll();\\n                if(val == goal) return moves;\\n                if(val > 1000 || val < 0 || bfs[val] != 0) continue;\\n                \\n                bfs[val] = 1;\\n                for(int n: nums)\\n                {\\n                    q.offer(val + n);\\n                    q.offer(val - n);\\n                    q.offer(val ^ n);\\n                }\\n                \\n            }\\n            moves++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767725,
                "title": "golang-bfs",
                "content": "```\\nfunc minimumOperations(nums []int, start int, goal int) int {\\n    set := make([]bool, 1001)\\n    set[start] = true\\n    \\n    flist := []func(int, int)int{func(a int, b int)int{return a + b},\\n                           func(a int, b int)int{return a - b},\\n                           func(a int, b int)int{return a ^ b}}\\n    \\n    queue := []int{start}\\n    cnt := 1\\n    for len(queue) > 0  {\\n        l := len(queue)\\n        for i := 0; i < l; i++ {\\n            for _, v := range nums {\\n                for _, f := range flist {\\n                    y := f(queue[i], v)\\n                    if y == goal {\\n                        return cnt\\n                    } else if y >= 0 && y <= 1000 && !set[y] {\\n                        set[y] = true\\n                        queue = append(queue, y)\\n                    }\\n                }\\n            }\\n        }\\n        cnt++\\n        queue = queue[l:]\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minimumOperations(nums []int, start int, goal int) int {\\n    set := make([]bool, 1001)\\n    set[start] = true\\n    \\n    flist := []func(int, int)int{func(a int, b int)int{return a + b},\\n                           func(a int, b int)int{return a - b},\\n                           func(a int, b int)int{return a ^ b}}\\n    \\n    queue := []int{start}\\n    cnt := 1\\n    for len(queue) > 0  {\\n        l := len(queue)\\n        for i := 0; i < l; i++ {\\n            for _, v := range nums {\\n                for _, f := range flist {\\n                    y := f(queue[i], v)\\n                    if y == goal {\\n                        return cnt\\n                    } else if y >= 0 && y <= 1000 && !set[y] {\\n                        set[y] = true\\n                        queue = append(queue, y)\\n                    }\\n                }\\n            }\\n        }\\n        cnt++\\n        queue = queue[l:]\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1743249,
                "title": "bfs-clean-and-simple-code",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        if start == goal:\\n            return 0\\n        if start < 0 or start > 1000 or len(nums) == 0:\\n            return -1\\n        q = deque()\\n        seen = set()\\n        x = start \\n        for i in range(len(nums)):\\n            q.append(x + nums[i])\\n            q.append(x - nums[i])\\n            q.append(x ^ nums[i])\\n            seen.add(x + nums[i])\\n            seen.add(x - nums[i])\\n            seen.add(x ^ nums[i])\\n        step = 1\\n        while len(q) > 0:\\n            s = len(q)\\n            while s > 0:\\n                s = s - 1 \\n                r = q.popleft()\\n                if r == goal:\\n                    return step\\n                if r < 0 or r > 1000:\\n                    continue\\n                for i in range(len(nums)):\\n                    v1, v2, v3 = r + nums[i], r - nums[i], r ^ nums[i]\\n                    if v1 not in seen:\\n                        seen.add(v1)\\n                        q.append(v1)\\n                    if v2 not in seen:\\n                        seen.add(v2)\\n                        q.append(v2)\\n                    if v3 not in seen:\\n                        seen.add(v3)\\n                        q.append(v3)\\n            step += 1\\n        return -1            \\n        \\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        if start == goal:\\n            return 0\\n        if start < 0 or start > 1000 or len(nums) == 0:\\n            return -1\\n        q = deque()\\n        seen = set()\\n        x = start \\n        for i in range(len(nums)):\\n            q.append(x + nums[i])\\n            q.append(x - nums[i])\\n            q.append(x ^ nums[i])\\n            seen.add(x + nums[i])\\n            seen.add(x - nums[i])\\n            seen.add(x ^ nums[i])\\n        step = 1\\n        while len(q) > 0:\\n            s = len(q)\\n            while s > 0:\\n                s = s - 1 \\n                r = q.popleft()\\n                if r == goal:\\n                    return step\\n                if r < 0 or r > 1000:\\n                    continue\\n                for i in range(len(nums)):\\n                    v1, v2, v3 = r + nums[i], r - nums[i], r ^ nums[i]\\n                    if v1 not in seen:\\n                        seen.add(v1)\\n                        q.append(v1)\\n                    if v2 not in seen:\\n                        seen.add(v2)\\n                        q.append(v2)\\n                    if v3 not in seen:\\n                        seen.add(v3)\\n                        q.append(v3)\\n            step += 1\\n        return -1            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742524,
                "title": "c-bfs-only-code-you-need-to-understand-the-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n = nums.size();\\n        queue<pair<int, int>> q;\\n        vector<bool> vis(1001, false); // As the number can only be in the range 0 to 1000. \\n        \\n        vis[start] = true;\\n        q.push({start, 0});\\n        \\n        while(!q.empty()) {\\n            auto [curr, count] = q.front();\\n            q.pop();\\n\\n            for(int i = 0; i<n; i++) {\\n                int add = curr+nums[i], sub = curr-nums[i], bit = curr^nums[i], newCount = count+1;\\n                if(add == goal || sub == goal || bit == goal) return newCount;\\n\\t\\t\\t\\t\\n                if(add <= 1000 && add >= 0 && !vis[add]) {q.push({add, newCount}); vis[add] = true;}\\n                if(sub <= 1000 && sub >= 0 && !vis[sub]) {q.push({sub, newCount}); vis[sub] = true;}\\n                if(bit <= 1000 && bit >= 0 && !vis[bit]) {q.push({bit, newCount}); vis[bit] = true;}\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n = nums.size();\\n        queue<pair<int, int>> q;\\n        vector<bool> vis(1001, false); // As the number can only be in the range 0 to 1000. \\n        \\n        vis[start] = true;\\n        q.push({start, 0}",
                "codeTag": "Java"
            },
            {
                "id": 1707143,
                "title": "using-sets-for-new-numbers-84-speed",
                "content": "![image](https://assets.leetcode.com/users/images/7dfbb574-7b95-44be-9eba-387e5e2723a7_1642778432.1137986.png)\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        seen, level, ops = {start}, {start}, 0\\n        while level:\\n            new_level = set()\\n            ops += 1\\n            for x in level:\\n                for n in nums:\\n                    for new_x in [x + n, x - n, x ^ n]:\\n                        if new_x == goal:\\n                            return ops\\n                        elif 0 <= new_x <= 1000 and new_x not in seen:\\n                            new_level.add(new_x)\\n            level = new_level\\n            seen.update(level)\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        seen, level, ops = {start}, {start}, 0\\n        while level:\\n            new_level = set()\\n            ops += 1\\n            for x in level:\\n                for n in nums:\\n                    for new_x in [x + n, x - n, x ^ n]:\\n                        if new_x == goal:\\n                            return ops\\n                        elif 0 <= new_x <= 1000 and new_x not in seen:\\n                            new_level.add(new_x)\\n            level = new_level\\n            seen.update(level)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703555,
                "title": "clean-easy-c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int x=1000;\\n        queue<int>q;\\n        vector<int>st(10001);\\n        q.push(start);\\n        int steps=0;\\n        while(!q.empty()){\\n            int n=q.size(); \\n            while(n--){\\n                int a=q.front();\\n                q.pop();\\n                if(a==goal)return steps;\\n                if(a<0 || a>1000 || st[a]) continue;\\n                st[a]++;\\n                for(auto&i:nums){\\n                    int f=a+i,s=a-i,t=a^i;\\n                    q.push(f);\\n                    q.push(s);\\n                    q.push(t);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int x=1000;\\n        queue<int>q;\\n        vector<int>st(10001);\\n        q.push(start);\\n        int steps=0;\\n        while(!q.empty()){\\n            int n=q.size(); \\n            while(n--){\\n                int a=q.front();\\n                q.pop();\\n                if(a==goal)return steps;\\n                if(a<0 || a>1000 || st[a]) continue;\\n                st[a]++;\\n                for(auto&i:nums){\\n                    int f=a+i,s=a-i,t=a^i;\\n                    q.push(f);\\n                    q.push(s);\\n                    q.push(t);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678507,
                "title": "bfs-easy-implementation",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) { \\n        Queue<Integer> que = new LinkedList<>();\\n        que.add(start);\\n        // Add Integer.MIN_VALUE to keep track of level\\n        que.add(Integer.MIN_VALUE);\\n        Set<Integer> set = new HashSet<>();\\n        int result = 0;\\n        while(que.size() > 1) {\\n            int tempNum = que.poll();\\n            // If Integer.MIN_VALUE found insert it at last which states end of current level\\n            if(tempNum == Integer.MIN_VALUE) {\\n                result++;\\n                que.add(Integer.MIN_VALUE);\\n            }\\n            else {\\n                if(tempNum == goal) {\\n                    return result;\\n                }\\n                if(tempNum < 0 || tempNum > 1000 || set.contains(tempNum)) {\\n                    continue;\\n                }\\n                set.add(tempNum);\\n                for(int num: nums) {\\n                    int a = tempNum + num;\\n                    int b = tempNum - num;\\n                    int c = tempNum ^ num;\\n                    que.add(a);\\n                    que.add(b);\\n                    que.add(c);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) { \\n        Queue<Integer> que = new LinkedList<>();\\n        que.add(start);\\n        // Add Integer.MIN_VALUE to keep track of level\\n        que.add(Integer.MIN_VALUE);\\n        Set<Integer> set = new HashSet<>();\\n        int result = 0;\\n        while(que.size() > 1) {\\n            int tempNum = que.poll();\\n            // If Integer.MIN_VALUE found insert it at last which states end of current level\\n            if(tempNum == Integer.MIN_VALUE) {\\n                result++;\\n                que.add(Integer.MIN_VALUE);\\n            }\\n            else {\\n                if(tempNum == goal) {\\n                    return result;\\n                }\\n                if(tempNum < 0 || tempNum > 1000 || set.contains(tempNum)) {\\n                    continue;\\n                }\\n                set.add(tempNum);\\n                for(int num: nums) {\\n                    int a = tempNum + num;\\n                    int b = tempNum - num;\\n                    int c = tempNum ^ num;\\n                    que.add(a);\\n                    que.add(b);\\n                    que.add(c);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629358,
                "title": "c-solution",
                "content": "BFS\\n```\\npublic class Solution {\\n    public int MinimumOperations(int[] n, int s, int g) {\\n        int r = -1;\\n        \\n        HashSet<int> cn = new HashSet<int>() { s };\\n        Queue<(int x, int o)> q = new Queue<(int x, int o)>();\\n        q.Enqueue((s, 0));\\n        \\n        while (q.Count > 0) {\\n            (int x, int o) c = q.Dequeue();\\n            if (c.x == g || ((c.x < 0 || c.x > 1000) && c.x == g)) \\n                return c.o;\\n            else if (c.x < 0 || c.x > 1000) {\\n                continue;\\n            }\\n                \\n            \\n            for (int i = 0; i < n.Length; ++i) {\\n                int ac = c.x + n[i];\\n                if (!cn.Contains(ac)) {\\n                    cn.Add(ac);\\n                    q.Enqueue((ac, c.o + 1));\\n                }\\n                \\n                int sc = c.x - n[i];\\n                if (!cn.Contains(sc)) {\\n                    cn.Add(sc);\\n                    q.Enqueue((sc, c.o + 1));\\n                }\\n                \\n                int xorc = c.x ^ n[i];\\n                if (!cn.Contains(xorc)) {\\n                    cn.Add(xorc);\\n                    q.Enqueue((xorc, c.o + 1));\\n                }\\n                \\n            }\\n        }\\n        \\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinimumOperations(int[] n, int s, int g) {\\n        int r = -1;\\n        \\n        HashSet<int> cn = new HashSet<int>() { s };\\n        Queue<(int x, int o)> q = new Queue<(int x, int o)>();\\n        q.Enqueue((s, 0));\\n        \\n        while (q.Count > 0) {\\n            (int x, int o) c = q.Dequeue();\\n            if (c.x == g || ((c.x < 0 || c.x > 1000) && c.x == g)) \\n                return c.o;\\n            else if (c.x < 0 || c.x > 1000) {\\n                continue;\\n            }\\n                \\n            \\n            for (int i = 0; i < n.Length; ++i) {\\n                int ac = c.x + n[i];\\n                if (!cn.Contains(ac)) {\\n                    cn.Add(ac);\\n                    q.Enqueue((ac, c.o + 1));\\n                }\\n                \\n                int sc = c.x - n[i];\\n                if (!cn.Contains(sc)) {\\n                    cn.Add(sc);\\n                    q.Enqueue((sc, c.o + 1));\\n                }\\n                \\n                int xorc = c.x ^ n[i];\\n                if (!cn.Contains(xorc)) {\\n                    cn.Add(xorc);\\n                    q.Enqueue((xorc, c.o + 1));\\n                }\\n                \\n            }\\n        }\\n        \\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628196,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) \\n    {\\n        vector<bool>vis(1001,false);\\n        queue<int>q;\\n        q.push(start);\\n        int res=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int x=q.front();\\n                q.pop();\\n                if(x==goal)\\n                    return res;\\n                if(x<0 || x>1000 || vis[x])\\n                    continue;\\n                vis[x]=true;\\n                for(auto &y:nums)\\n                {\\n                    q.push(x+y);\\n                    q.push(x-y);\\n                    q.push(x^y);\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) \\n    {\\n        vector<bool>vis(1001,false);\\n        queue<int>q;\\n        q.push(start);\\n        int res=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int x=q.front();\\n                q.pop();\\n                if(x==goal)\\n                    return res;\\n                if(x<0 || x>1000 || vis[x])\\n                    continue;\\n                vis[x]=true;\\n                for(auto &y:nums)\\n                {\\n                    q.push(x+y);\\n                    q.push(x-y);\\n                    q.push(x^y);\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625740,
                "title": "easy-bfs-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int>q;\\n        vector<int>vis(1001,0);\\n        q.push(start);\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            while(n--)\\n            {\\n                int x=q.front();\\n                q.pop();\\n                if(x==goal)\\n                    return ans;\\n                if(x<0 || x>1000 || vis[x])\\n                    continue;\\n                vis[x]=1;\\n                for(int i:nums)\\n                {\\n                q.push(x+i);\\n                q.push(x-i);\\n                q.push(x^i);\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int>q;\\n        vector<int>vis(1001,0);\\n        q.push(start);\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            while(n--)\\n            {\\n                int x=q.front();\\n                q.pop();\\n                if(x==goal)\\n                    return ans;\\n                if(x<0 || x>1000 || vis[x])\\n                    continue;\\n                vis[x]=1;\\n                for(int i:nums)\\n                {\\n                q.push(x+i);\\n                q.push(x-i);\\n                q.push(x^i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1623798,
                "title": "python-simple-bfs-95",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        current = set([start])\\n        visisted = set()\\n        res = 0\\n        while current:\\n            res += 1\\n            visisted.update(current)\\n            temp = set()\\n            for cur in current:\\n                for num in nums:\\n                    a, b, c = cur + num, cur - num, cur ^ num\\n                    if a == goal or b == goal or c == goal:\\n                        return res\\n                    if 0 <= a <= 1000:\\n                        temp.add(a)\\n                    if 0 <= b <= 1000:\\n                        temp.add(b)\\n                    if 0 <= c <= 1000:\\n                        temp.add(c)\\n            current = temp - visisted\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        current = set([start])\\n        visisted = set()\\n        res = 0\\n        while current:\\n            res += 1\\n            visisted.update(current)\\n            temp = set()\\n            for cur in current:\\n                for num in nums:\\n                    a, b, c = cur + num, cur - num, cur ^ num\\n                    if a == goal or b == goal or c == goal:\\n                        return res\\n                    if 0 <= a <= 1000:\\n                        temp.add(a)\\n                    if 0 <= b <= 1000:\\n                        temp.add(b)\\n                    if 0 <= c <= 1000:\\n                        temp.add(c)\\n            current = temp - visisted\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615096,
                "title": "golang-bfs-100-solution",
                "content": "```go\\nfunc minimumOperations(nums []int, start int, goal int) int {\\n\\t// marker-array mark numbers already try\\n\\tmarker := make([]bool, 1001)\\n\\tmarker[start] = true\\n\\tcurrent := []int{start}\\n\\tstep := 0\\n\\tfor len(current) > 0 {\\n\\t\\tnext := make([]int, 0)\\n\\t\\tstep++\\n\\t\\tfor _, c := range current {\\n\\t\\t\\tfor _, v := range nums {\\n\\t\\t\\t\\tif v1 := c+v; v1 == goal {\\n\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t} else if v1 >= 0 && v1 <= 1000 && marker[v1] == false {\\n\\t\\t\\t\\t\\tmarker[v1] = true\\n\\t\\t\\t\\t\\tnext = append(next, v1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif v2 := c-v; v2 == goal {\\n\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t} else if v2 >= 0 && v2 <= 1000 && marker[v2] == false {\\n\\t\\t\\t\\t\\tmarker[v2] = true\\n\\t\\t\\t\\t\\tnext = append(next, v2)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif v3 := c^v; v3 == goal {\\n\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t} else if v3 >= 0 && v3 <= 1000 && marker[v3] == false {\\n\\t\\t\\t\\t\\tmarker[v3] = true\\n\\t\\t\\t\\t\\tnext = append(next, v3)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurrent = next\\n\\t}\\n\\t// impossible\\n\\treturn -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```go\\nfunc minimumOperations(nums []int, start int, goal int) int {\\n\\t// marker-array mark numbers already try\\n\\tmarker := make([]bool, 1001)\\n\\tmarker[start] = true\\n\\tcurrent := []int{start}\\n\\tstep := 0\\n\\tfor len(current) > 0 {\\n\\t\\tnext := make([]int, 0)\\n\\t\\tstep++\\n\\t\\tfor _, c := range current {\\n\\t\\t\\tfor _, v := range nums {\\n\\t\\t\\t\\tif v1 := c+v; v1 == goal {\\n\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t} else if v1 >= 0 && v1 <= 1000 && marker[v1] == false {\\n\\t\\t\\t\\t\\tmarker[v1] = true\\n\\t\\t\\t\\t\\tnext = append(next, v1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif v2 := c-v; v2 == goal {\\n\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t} else if v2 >= 0 && v2 <= 1000 && marker[v2] == false {\\n\\t\\t\\t\\t\\tmarker[v2] = true\\n\\t\\t\\t\\t\\tnext = append(next, v2)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif v3 := c^v; v3 == goal {\\n\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t} else if v3 >= 0 && v3 <= 1000 && marker[v3] == false {\\n\\t\\t\\t\\t\\tmarker[v3] = true\\n\\t\\t\\t\\t\\tnext = append(next, v3)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurrent = next\\n\\t}\\n\\t// impossible\\n\\treturn -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1612404,
                "title": "c-basic-bfs",
                "content": "```\\nclass Solution {\\n    static int Add(int a, int b) {\\n        return a + b;\\n    }\\n    \\n    static int Sub(int a, int b) {\\n        return a - b;\\n    }\\n    \\n    static int Xor(int a, int b) {\\n        return a ^ b;\\n    }\\n    \\n    using func = int (int, int);\\n    \\n    func* op[3] = {Add, Sub, Xor};\\n    \\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int ans = 0;\\n        \\n        queue<int> q;\\n        q.push(start);\\n        \\n        unordered_set<int> visited;\\n        visited.insert(start);\\n        \\n        while (!q.empty()) {\\n            ++ans;\\n            \\n            int cnt = q.size();\\n            \\n            while (cnt-- > 0) {\\n                int x = q.front();\\n                q.pop();\\n                \\n                for (int i = 0; i < 3; ++i) {\\n                    for (int j = 0; j < nums.size(); ++j) {\\n                        int dx = (*op[i])(x, nums[j]);\\n                        \\n                        if (dx == goal) {\\n                            return ans;\\n                        }\\n                        \\n                        if (visited.find(dx) != visited.end()) {\\n                            continue;\\n                        }\\n                        \\n                        if (dx < 0 || dx > 1000) {\\n                            continue;\\n                        }\\n                        \\n                        q.push(dx);\\n                        visited.insert(dx);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static int Add(int a, int b) {\\n        return a + b;\\n    }\\n    \\n    static int Sub(int a, int b) {\\n        return a - b;\\n    }\\n    \\n    static int Xor(int a, int b) {\\n        return a ^ b;\\n    }\\n    \\n    using func = int (int, int);\\n    \\n    func* op[3] = {Add, Sub, Xor};\\n    \\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int ans = 0;\\n        \\n        queue<int> q;\\n        q.push(start);\\n        \\n        unordered_set<int> visited;\\n        visited.insert(start);\\n        \\n        while (!q.empty()) {\\n            ++ans;\\n            \\n            int cnt = q.size();\\n            \\n            while (cnt-- > 0) {\\n                int x = q.front();\\n                q.pop();\\n                \\n                for (int i = 0; i < 3; ++i) {\\n                    for (int j = 0; j < nums.size(); ++j) {\\n                        int dx = (*op[i])(x, nums[j]);\\n                        \\n                        if (dx == goal) {\\n                            return ans;\\n                        }\\n                        \\n                        if (visited.find(dx) != visited.end()) {\\n                            continue;\\n                        }\\n                        \\n                        if (dx < 0 || dx > 1000) {\\n                            continue;\\n                        }\\n                        \\n                        q.push(dx);\\n                        visited.insert(dx);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605480,
                "title": "javascript-bfs-solution",
                "content": "```\\nvar minimumOperations = function(nums, start, goal) {\\n    let operations = 0, queue = [start], visited = new Set();\\n\\n    while (queue.length) {\\n        operations++;\\n        let len = queue.length, temp = [];\\n        for (const cur of queue) {\\n            for (const num of nums) {\\n                for (const next of [cur + num, cur - num, cur ^ num]) {\\n                    if (next === goal)\\n                        return operations;\\n                    if (next >= 0 && next <= 1000 && !visited.has(next)) {\\n                        visited.add(next);\\n                        temp.push(next);\\n                    }\\n                }\\n            }\\n        }\\n        queue = temp;\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minimumOperations = function(nums, start, goal) {\\n    let operations = 0, queue = [start], visited = new Set();\\n\\n    while (queue.length) {\\n        operations++;\\n        let len = queue.length, temp = [];\\n        for (const cur of queue) {\\n            for (const num of nums) {\\n                for (const next of [cur + num, cur - num, cur ^ num]) {\\n                    if (next === goal)\\n                        return operations;\\n                    if (next >= 0 && next <= 1000 && !visited.has(next)) {\\n                        visited.add(next);\\n                        temp.push(next);\\n                    }\\n                }\\n            }\\n        }\\n        queue = temp;\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1595348,
                "title": "python-3-bfs-implementation-faster-than-91-85-submissions",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        open_queue = []\\n        closed_set = set()\\n        edge_dict = dict()\\n\\n        open_queue.append(start)\\n        closed_set.add(start)\\n\\n        while len(open_queue) > 0:\\n            node = open_queue.pop(0)\\n            for adj_node in self.getAdjacentNodes(node, nums, goal):\\n                if adj_node not in closed_set:\\n                    closed_set.add(adj_node)\\n                    open_queue.append(adj_node)\\n                    edge_dict[adj_node] = node\\n                    if adj_node == goal:\\n                        return self.countSteps(edge_dict, start, goal)\\n                    if adj_node < 0 or adj_node > 1000:\\n                        open_queue.pop()\\n        return -1\\n\\n    def getAdjacentNodes(self, node: int, nums: List[int], goal: int):\\n        for number in nums:\\n            s = node+number\\n            if s>=0 and s<=1000:\\n                yield s\\n            elif s == goal:\\n                yield s\\n\\n            d = node-number\\n            if d>=0 and d<=1000:\\n                yield d\\n            elif d == goal:\\n                yield d\\n\\n            x = node^number\\n            if x>=0 and x<=1000:\\n                yield x\\n            elif x == goal:\\n                yield x\\n\\n    def countSteps(self, edge_dict: Dict, start: int, goal: int) -> int:\\n        p = goal\\n        step = 0\\n        while True:\\n            q = edge_dict[p]\\n            step += 1\\n            if q == start:\\n                return step\\n            p = q\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        open_queue = []\\n        closed_set = set()\\n        edge_dict = dict()\\n\\n        open_queue.append(start)\\n        closed_set.add(start)\\n\\n        while len(open_queue) > 0:\\n            node = open_queue.pop(0)\\n            for adj_node in self.getAdjacentNodes(node, nums, goal):\\n                if adj_node not in closed_set:\\n                    closed_set.add(adj_node)\\n                    open_queue.append(adj_node)\\n                    edge_dict[adj_node] = node\\n                    if adj_node == goal:\\n                        return self.countSteps(edge_dict, start, goal)\\n                    if adj_node < 0 or adj_node > 1000:\\n                        open_queue.pop()\\n        return -1\\n\\n    def getAdjacentNodes(self, node: int, nums: List[int], goal: int):\\n        for number in nums:\\n            s = node+number\\n            if s>=0 and s<=1000:\\n                yield s\\n            elif s == goal:\\n                yield s\\n\\n            d = node-number\\n            if d>=0 and d<=1000:\\n                yield d\\n            elif d == goal:\\n                yield d\\n\\n            x = node^number\\n            if x>=0 and x<=1000:\\n                yield x\\n            elif x == goal:\\n                yield x\\n\\n    def countSteps(self, edge_dict: Dict, start: int, goal: int) -> int:\\n        p = goal\\n        step = 0\\n        while True:\\n            q = edge_dict[p]\\n            step += 1\\n            if q == start:\\n                return step\\n            p = q\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587775,
                "title": "c-bfs-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int>que;\\n        que.push(start);\\n\\n        int minStep=0;\\n        vector<bool>vis(1001,false);\\n        while(!que.empty()){\\n            minStep++;\\n            \\n            queue<int> temp;\\n            while(!que.empty()){\\n                auto k=que.front();\\n                que.pop();\\n                if(k==goal) return --minStep;\\n                if(k<0 or k>1000 or vis[k]) continue;\\n                vis[k]=true;\\n                for(auto x:nums){\\n                    temp.push(k^x);\\n                    temp.push(k+x);\\n                    temp.push(k-x);\\n                }\\n            }\\n            que = temp;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int>que;\\n        que.push(start);\\n\\n        int minStep=0;\\n        vector<bool>vis(1001,false);\\n        while(!que.empty()){\\n            minStep++;\\n            \\n            queue<int> temp;\\n            while(!que.empty()){\\n                auto k=que.front();\\n                que.pop();\\n                if(k==goal) return --minStep;\\n                if(k<0 or k>1000 or vis[k]) continue;\\n                vis[k]=true;\\n                for(auto x:nums){\\n                    temp.push(k^x);\\n                    temp.push(k+x);\\n                    temp.push(k-x);\\n                }\\n            }\\n            que = temp;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581961,
                "title": "c-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        \\n        queue<int>q;\\n        q.push(start);\\n        \\n        int cnt=0;\\n        vector<bool>vis(1001,false);\\n        while(!q.empty()){\\n            \\n            int n=q.size();\\n            \\n            for(int i=0; i<n; ++i){\\n                \\n                auto k=q.front();\\n                q.pop();\\n                \\n                if(k==goal) return cnt;\\n                \\n                if(k<0 or k>1000 or vis[k]) continue;\\n                \\n                vis[k]=true;\\n                for(auto x:nums){\\n                    q.push(k^x);\\n                    q.push(k+x);\\n                    q.push(k-x);\\n                }\\n                \\n            }\\n            cnt++;\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        \\n        queue<int>q;\\n        q.push(start);\\n        \\n        int cnt=0;\\n        vector<bool>vis(1001,false);\\n        while(!q.empty()){\\n            \\n            int n=q.size();\\n            \\n            for(int i=0; i<n; ++i){\\n                \\n                auto k=q.front();\\n                q.pop();\\n                \\n                if(k==goal) return cnt;\\n                \\n                if(k<0 or k>1000 or vis[k]) continue;\\n                \\n                vis[k]=true;\\n                for(auto x:nums){\\n                    q.push(k^x);\\n                    q.push(k+x);\\n                    q.push(k-x);\\n                }\\n                \\n            }\\n            cnt++;\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1574060,
                "title": "c-very-clean-bfs",
                "content": "```\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        if(start == goal)\\n            return 0;\\n        unordered_set<int> seen{start};\\n        \\n        queue<int> q;\\n        q.push(start);\\n        \\n        int step = 0;\\n        while(!q.empty()) {\\n            ++step;\\n            for(int i = q.size(); i; --i) {\\n                int cur = q.front();\\n                q.pop();\\n                \\n                for(int j = 0; j < nums.size(); ++j) {\\n                    array<int, 3> vals{\\n                        cur + nums[j], cur - nums[j], cur ^ nums[j]\\n                    };\\n                    \\n                    for(auto v: vals) {\\n                        if(v == goal)\\n                            return step;\\n                        if(v >= 0 and v <= 1000 and seen.find(v) == seen.end()) {\\n                            seen.insert(v);                            \\n                            q.push(v);\\n                        }\\n                    }\\n                } \\n            }            \\n        }\\n        \\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Combinatorics"
                ],
                "code": "```\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        if(start == goal)\\n            return 0;\\n        unordered_set<int> seen{start};\\n        \\n        queue<int> q;\\n        q.push(start);\\n        \\n        int step = 0;\\n        while(!q.empty()) {\\n            ++step;\\n            for(int i = q.size(); i; --i) {\\n                int cur = q.front();\\n                q.pop();\\n                \\n                for(int j = 0; j < nums.size(); ++j) {\\n                    array<int, 3> vals{\\n                        cur + nums[j], cur - nums[j], cur ^ nums[j]\\n                    };\\n                    \\n                    for(auto v: vals) {\\n                        if(v == goal)\\n                            return step;\\n                        if(v >= 0 and v <= 1000 and seen.find(v) == seen.end()) {\\n                            seen.insert(v);                            \\n                            q.push(v);\\n                        }\\n                    }\\n                } \\n            }            \\n        }\\n        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1572114,
                "title": "bfs-c-minimal-code-with-explanation-easy-to-understand",
                "content": "### The Traditional Breadth First Search\\n\\nForm a queue of pair of integers, first part of the pair will be our `x` and the second part of the pair will be the moves we took to reach that `x`. Like in every other BFS, we will have a `visited` set here which will make sure that we don\\'t do repetitive calculations. Rest of the code is self explanatory, just don\\'t forget the condition `0 <= x <= 1000`, so if `x` goes out of these bounds pop the queue and `continue`.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<pair<int,int>>q;\\n        q.push({start,0});\\n        unordered_set<int>visited;\\n        \\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int moves=q.front().second;\\n            \\n            if(x == goal){\\n                return moves; \\n            }\\n            if(visited.count(x) || x<0 || x>1000){\\n                q.pop();\\n                continue;\\n            }\\n            visited.insert(x);\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                q.push({x+nums[i], moves+1});\\n                q.push({x-nums[i], moves+1});\\n                q.push({x^nums[i], moves+1});\\n            }\\n            q.pop();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<pair<int,int>>q;\\n        q.push({start,0});\\n        unordered_set<int>visited;\\n        \\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int moves=q.front().second;\\n            \\n            if(x == goal){\\n                return moves; \\n            }\\n            if(visited.count(x) || x<0 || x>1000){\\n                q.pop();\\n                continue;\\n            }\\n            visited.insert(x);\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                q.push({x+nums[i], moves+1});\\n                q.push({x-nums[i], moves+1});\\n                q.push({x^nums[i], moves+1});\\n            }\\n            q.pop();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1559304,
                "title": "help-why-my-code-ttl",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> queue_;\\n        queue_.push(start);\\n        unordered_set<int> visisted{start};\\n        int step = 0;\\n        while (true) {\\n            step++;\\n            int generate_new = false;\\n            int cur_size = queue_.size();\\n            for(int i = 0; i < cur_size; i++) {\\n                int pop_num = queue_.front();\\n                queue_.pop();\\n                if (pop_num > 1000 || pop_num < 0 ) {\\n                    continue;\\n                }    \\n                for (int num : nums) {\\n                    for (int cand_ : {pop_num + num, pop_num - num, pop_num ^ num}) {\\n                        if (cand_ == goal) {\\n                            return step;\\n                        }\\n                        if (visisted.find(cand_) == visisted.end()) {\\n                            generate_new = true;\\n                            queue_.push(cand_);\\n                            visisted.insert(cand_);\\n                        }\\n                    }\\n                }\\n            } \\n            if (!generate_new) {\\n                return -1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        queue<int> queue_;\\n        queue_.push(start);\\n        unordered_set<int> visisted{start};\\n        int step = 0;\\n        while (true) {\\n            step++;\\n            int generate_new = false;\\n            int cur_size = queue_.size();\\n            for(int i = 0; i < cur_size; i++) {\\n                int pop_num = queue_.front();\\n                queue_.pop();\\n                if (pop_num > 1000 || pop_num < 0 ) {\\n                    continue;\\n                }    \\n                for (int num : nums) {\\n                    for (int cand_ : {pop_num + num, pop_num - num, pop_num ^ num}) {\\n                        if (cand_ == goal) {\\n                            return step;\\n                        }\\n                        if (visisted.find(cand_) == visisted.end()) {\\n                            generate_new = true;\\n                            queue_.push(cand_);\\n                            visisted.insert(cand_);\\n                        }\\n                    }\\n                }\\n            } \\n            if (!generate_new) {\\n                return -1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557241,
                "title": "c-bfs-solution",
                "content": "```\\npublic int MinimumOperations(int[] nums, int start, int goal) {\\n        int result = 1;\\n        var uniqueElements = new HashSet<int>(1001);\\n        uniqueElements.Add(start);\\n        var queue = new Queue<int>(1001);\\n        queue.Enqueue(start);\\n        while (true) {\\n            var prevStepCount = uniqueElements.Count;\\n            var queueCount = queue.Count;\\n            for (int i=0; i<queueCount; i++) \\n            {\\n                var x = queue.Dequeue();\\n                foreach (var num in nums) \\n                {\\n                    if (IsGoalReached(x+num, goal, queue, uniqueElements) || \\n                        IsGoalReached(x-num, goal, queue, uniqueElements) || \\n                        IsGoalReached(x^num, goal, queue, uniqueElements))\\n                        return result;\\n                }   \\n            }\\n            if (uniqueElements.Count == prevStepCount) // the same size of hashset means that we already processed all available numbers\\n                return -1;\\n            result++;\\n        }\\n    }\\n    \\n\\t// inside this method can be modified input parameters: queue and uniqueElements (I know it\\'s not the best idea, but I am lazy)\\n    bool IsGoalReached(int val, int goal, Queue<int> queue, HashSet<int> uniqueElements) {\\n        if (val == goal)\\n            return true;\\n        if (val >= 0 && val <= 1000 && uniqueElements.Add(val))\\n            queue.Enqueue(val);     \\n            \\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MinimumOperations(int[] nums, int start, int goal) {\\n        int result = 1;\\n        var uniqueElements = new HashSet<int>(1001);\\n        uniqueElements.Add(start);\\n        var queue = new Queue<int>(1001);\\n        queue.Enqueue(start);\\n        while (true) {\\n            var prevStepCount = uniqueElements.Count;\\n            var queueCount = queue.Count;\\n            for (int i=0; i<queueCount; i++) \\n            {\\n                var x = queue.Dequeue();\\n                foreach (var num in nums) \\n                {\\n                    if (IsGoalReached(x+num, goal, queue, uniqueElements) || \\n                        IsGoalReached(x-num, goal, queue, uniqueElements) || \\n                        IsGoalReached(x^num, goal, queue, uniqueElements))\\n                        return result;\\n                }   \\n            }\\n            if (uniqueElements.Count == prevStepCount) // the same size of hashset means that we already processed all available numbers\\n                return -1;\\n            result++;\\n        }\\n    }\\n    \\n\\t// inside this method can be modified input parameters: queue and uniqueElements (I know it\\'s not the best idea, but I am lazy)\\n    bool IsGoalReached(int val, int goal, Queue<int> queue, HashSet<int> uniqueElements) {\\n        if (val == goal)\\n            return true;\\n        if (val >= 0 && val <= 1000 && uniqueElements.Add(val))\\n            queue.Enqueue(val);     \\n            \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1555227,
                "title": "go-bfs",
                "content": "```\\nfunc minimumOperations(nums []int, start int, goal int) int {\\n    queue := []int{start}\\n    visited := map[int]bool{}\\n    visited[start] = true\\n    opCnt := 1\\n    for len(queue) > 0{\\n        queueLen := len(queue)\\n        for i := 0; i < queueLen;i++{\\n            cur := queue[i]\\n            \\n            for j := range nums{\\n                num := nums[j]\\n                val := cur+num\\n                if val == goal{\\n                    return opCnt\\n                }else{\\n                    if val >= 0 && val <= 1000 && !visited[val]{\\n                        visited[val] = true\\n                        queue = append(queue, val)\\n                    }\\n                }\\n\\n                val = cur-num\\n                if val == goal{\\n                    return opCnt\\n                }else{\\n                    if val >= 0 && val <= 1000 && !visited[val]{\\n                        visited[val] = true\\n                        queue = append(queue, val)\\n                    }\\n                }\\n\\n                val = cur^num\\n                if val == goal{\\n                    return opCnt\\n                }else{\\n                    if val >= 0 && val <= 1000 && !visited[val]{\\n                        visited[val] = true\\n                        queue = append(queue, val)\\n                    }\\n                }\\n            }\\n            \\n        }\\n        queue = queue[queueLen:]\\n        opCnt++\\n    }\\n    \\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumOperations(nums []int, start int, goal int) int {\\n    queue := []int{start}\\n    visited := map[int]bool{}\\n    visited[start] = true\\n    opCnt := 1\\n    for len(queue) > 0{\\n        queueLen := len(queue)\\n        for i := 0; i < queueLen;i++{\\n            cur := queue[i]\\n            \\n            for j := range nums{\\n                num := nums[j]\\n                val := cur+num\\n                if val == goal{\\n                    return opCnt\\n                }else{\\n                    if val >= 0 && val <= 1000 && !visited[val]{\\n                        visited[val] = true\\n                        queue = append(queue, val)\\n                    }\\n                }\\n\\n                val = cur-num\\n                if val == goal{\\n                    return opCnt\\n                }else{\\n                    if val >= 0 && val <= 1000 && !visited[val]{\\n                        visited[val] = true\\n                        queue = append(queue, val)\\n                    }\\n                }\\n\\n                val = cur^num\\n                if val == goal{\\n                    return opCnt\\n                }else{\\n                    if val >= 0 && val <= 1000 && !visited[val]{\\n                        visited[val] = true\\n                        queue = append(queue, val)\\n                    }\\n                }\\n            }\\n            \\n        }\\n        queue = queue[queueLen:]\\n        opCnt++\\n    }\\n    \\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1552843,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int i, j;\\n        queue<pair<int, int>> bfs;\\n        unordered_set<int> visited;\\n        bfs.push(make_pair(start, 0));\\n        visited.insert(start);\\n        \\n        while(!bfs.empty()){\\n            pair<int, int> p = bfs.front();\\n            bfs.pop();\\n            int current = p.first;\\n            int steps = p.second;\\n            if(current == goal){\\n                return steps;\\n            }\\n            else{\\n                for(i = 0; i < nums.size(); i++){\\n                    if(current + nums[i] == goal){\\n                        return steps + 1;\\n                    }\\n                    else if(current + nums[i] >= 0 && current + nums[i] <= 1000 && visited.find(current + nums[i]) == visited.end()){\\n                        visited.insert(current + nums[i]);\\n                        bfs.push(make_pair(current + nums[i], steps + 1));\\n                    }\\n                    if(current - nums[i] == goal){\\n                        return steps + 1;\\n                    }\\n                    else if(current - nums[i] >= 0 && current - nums[i] <= 1000 && visited.find(current - nums[i]) == visited.end()){\\n                        visited.insert(current - nums[i]);\\n                        bfs.push(make_pair(current - nums[i], steps + 1));\\n                    }\\n                    if((current ^ nums[i]) == goal){\\n                        return steps + 1;\\n                    }\\n                    else if((current ^ nums[i]) >= 0 && (current ^ nums[i]) <= 1000 && visited.find(current ^ nums[i]) == visited.end()){\\n                        visited.insert(current ^ nums[i]);\\n                        bfs.push(make_pair(current ^ nums[i], steps + 1));\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int i, j;\\n        queue<pair<int, int>> bfs;\\n        unordered_set<int> visited;\\n        bfs.push(make_pair(start, 0));\\n        visited.insert(start);\\n        \\n        while(!bfs.empty()){\\n            pair<int, int> p = bfs.front();\\n            bfs.pop();\\n            int current = p.first;\\n            int steps = p.second;\\n            if(current == goal){\\n                return steps;\\n            }\\n            else{\\n                for(i = 0; i < nums.size(); i++){\\n                    if(current + nums[i] == goal){\\n                        return steps + 1;\\n                    }\\n                    else if(current + nums[i] >= 0 && current + nums[i] <= 1000 && visited.find(current + nums[i]) == visited.end()){\\n                        visited.insert(current + nums[i]);\\n                        bfs.push(make_pair(current + nums[i], steps + 1));\\n                    }\\n                    if(current - nums[i] == goal){\\n                        return steps + 1;\\n                    }\\n                    else if(current - nums[i] >= 0 && current - nums[i] <= 1000 && visited.find(current - nums[i]) == visited.end()){\\n                        visited.insert(current - nums[i]);\\n                        bfs.push(make_pair(current - nums[i], steps + 1));\\n                    }\\n                    if((current ^ nums[i]) == goal){\\n                        return steps + 1;\\n                    }\\n                    else if((current ^ nums[i]) >= 0 && (current ^ nums[i]) <= 1000 && visited.find(current ^ nums[i]) == visited.end()){\\n                        visited.insert(current ^ nums[i]);\\n                        bfs.push(make_pair(current ^ nums[i], steps + 1));\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552510,
                "title": "easy-to-understand-bfs-c-code",
                "content": "**BFS approach is used**\\n```\\nint minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n=nums.size();\\n        vector<bool> visited(1000,false);\\n        queue<int> q;\\n        q.push(start);\\n        int res=0;              //min operations\\n        while(q.empty()==false)\\n        {\\n            int queue_size=q.size();\\n            //do all operations for one complete level\\n            while(queue_size--)\\n            {\\n                int front=q.front();\\n                q.pop();\\n                if(front==goal)\\n                    return res;\\n                if(front<0 || front>1000 || visited[front]==true)\\n                    continue;\\n                visited[front]=true;     //mark as visited\\n                for(int i=0;i<n;i++)\\n                {\\n                    int a = front + nums[i];\\n                    int b = front - nums[i];\\n                    int c = (front ^ nums[i]);\\n                    q.push(a);\\n                    q.push(b);\\n                    q.push(c);\\n                }\\n            }\\n            res++;   \\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n=nums.size();\\n        vector<bool> visited(1000,false);\\n        queue<int> q;\\n        q.push(start);\\n        int res=0;              //min operations\\n        while(q.empty()==false)\\n        {\\n            int queue_size=q.size();\\n            //do all operations for one complete level\\n            while(queue_size--)\\n            {\\n                int front=q.front();\\n                q.pop();\\n                if(front==goal)\\n                    return res;\\n                if(front<0 || front>1000 || visited[front]==true)\\n                    continue;\\n                visited[front]=true;     //mark as visited\\n                for(int i=0;i<n;i++)\\n                {\\n                    int a = front + nums[i];\\n                    int b = front - nums[i];\\n                    int c = (front ^ nums[i]);\\n                    q.push(a);\\n                    q.push(b);\\n                    q.push(c);\\n                }\\n            }\\n            res++;   \\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1552336,
                "title": "simple-python-solution-using-bfs-beating-100-in-time-and-space",
                "content": "```\\ndef minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n    visited = set()\\n    next = list()\\n\\tvisited.add(start)\\n    next.append((start, 0)) # element is (current value, step)\\n    while next:\\n        (curr, step) = next.pop(0)\\n        step += 1\\n        for i in nums:\\n            temp = [curr + i, curr - i, curr ^ i]\\n            for t in temp:\\n                if t == goal: return step\\n                if 0 <= t <= 1000 and t not in visited:\\n                    visited.add(t)\\n                    next.append((t, step))\\n    return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n    visited = set()\\n    next = list()\\n\\tvisited.add(start)\\n    next.append((start, 0)) # element is (current value, step)\\n    while next:\\n        (curr, step) = next.pop(0)\\n        step += 1\\n        for i in nums:\\n            temp = [curr + i, curr - i, curr ^ i]\\n            for t in temp:\\n                if t == goal: return step\\n                if 0 <= t <= 1000 and t not in visited:\\n                    visited.add(t)\\n                    next.append((t, step))\\n    return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1552086,
                "title": "pyhton-bfs-beats-100",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n\\n        visited = set()\\n        \\n        q = deque([(start, 0)])\\n        visited.add(start)\\n        \\n        while q:\\n            node, num = q.popleft()\\n            if node == goal:\\n                return num\\n            for v in nums:\\n                temp = node + v\\n                if temp == goal:\\n                    return num + 1\\n                if 0 <= temp <= 1000 and not temp in visited:\\n                        q.append((temp, num+1))\\n                        visited.add(temp)\\n                temp = node - v\\n                if temp == goal:\\n                    return num + 1      \\n                if 0 <= temp <= 1000 and not temp in visited:\\n                        q.append((temp, num+1))\\n                        visited.add(temp)\\n                temp = node ^ v\\n                if temp == goal:\\n                    return num + 1                       \\n                if 0 <= temp <= 1000 and not temp in visited:\\n                        q.append((temp, num+1))\\n                        visited.add(temp)\\n                        \\n\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n\\n        visited = set()\\n        \\n        q = deque([(start, 0)])\\n        visited.add(start)\\n        \\n        while q:\\n            node, num = q.popleft()\\n            if node == goal:\\n                return num\\n            for v in nums:\\n                temp = node + v\\n                if temp == goal:\\n                    return num + 1\\n                if 0 <= temp <= 1000 and not temp in visited:\\n                        q.append((temp, num+1))\\n                        visited.add(temp)\\n                temp = node - v\\n                if temp == goal:\\n                    return num + 1      \\n                if 0 <= temp <= 1000 and not temp in visited:\\n                        q.append((temp, num+1))\\n                        visited.add(temp)\\n                temp = node ^ v\\n                if temp == goal:\\n                    return num + 1                       \\n                if 0 <= temp <= 1000 and not temp in visited:\\n                        q.append((temp, num+1))\\n                        visited.add(temp)\\n                        \\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552063,
                "title": "scala-just-a-very-clean-and-standard-bfs",
                "content": "```scala\\n  def minimumOperations(nums: Array[Int], start: Int, goal: Int): Int = {\\n\\n    if (goal == start) return 0\\n    type int = Int\\n    import scala.collection.mutable.{Queue, HashSet}\\n    val isv  = new HashSet[int]\\n    val q    = new Queue[int]\\n    var step = 0\\n    q += start\\n    while (q.nonEmpty) {\\n      var size = q.size\\n\\n      while (size > 0) {\\n        size -= 1\\n        val curr = q.dequeue\\n      \\n        if (!isv.contains(curr)) {\\n          isv += curr\\n          nums.foreach(t => {\\n            Seq(curr + t, curr - t, curr ^ t).foreach(next => {\\n              if (next == goal) return step + 1\\n              if (!isv.contains(next) && next >= 0 && next <= 1000) q += next\\n            })\\n\\n          })\\n        }\\n\\n      }\\n      step += 1\\n\\n    }\\n\\n    -1\\n\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def minimumOperations(nums: Array[Int], start: Int, goal: Int): Int = {\\n\\n    if (goal == start) return 0\\n    type int = Int\\n    import scala.collection.mutable.{Queue, HashSet}\\n    val isv  = new HashSet[int]\\n    val q    = new Queue[int]\\n    var step = 0\\n    q += start\\n    while (q.nonEmpty) {\\n      var size = q.size\\n\\n      while (size > 0) {\\n        size -= 1\\n        val curr = q.dequeue\\n      \\n        if (!isv.contains(curr)) {\\n          isv += curr\\n          nums.foreach(t => {\\n            Seq(curr + t, curr - t, curr ^ t).foreach(next => {\\n              if (next == goal) return step + 1\\n              if (!isv.contains(next) && next >= 0 && next <= 1000) q += next\\n            })\\n\\n          })\\n        }\\n\\n      }\\n      step += 1\\n\\n    }\\n\\n    -1\\n\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1551879,
                "title": "c-bfs-40ms-100",
                "content": "```\\nint minimumOperations(vector<int>& nums, int start, int goal) {\\n        vector<int> n(1001, -1);\\n        n[start]=0;\\n        queue<int> tq;\\n        tq.push(start);\\n        while(tq.size()) {\\n            int i = tq.front();\\n            tq.pop();\\n                for(auto num:nums) {\\n                    int t = i+num;\\n                    int r = n[i]+1;\\n                    if(t == goal)\\n                        return r;\\n                    if(t>=0 && t<=1000 && n[t]==-1) {\\n                        //cout<<t<<\":\"<<r<<endl;\\n                        n[t] = r;\\n                        tq.push(t);\\n                    }\\n                    \\n                    t = i-num;\\n                    if(t == goal)\\n                        return r;\\n                    if(t>=0 && t<=1000 && n[t]==-1) {\\n                        //cout<<t<<\":\"<<r<<endl;\\n                        n[t] = r;\\n                        tq.push(t);\\n                    }\\n                    \\n                    t = i^num;\\n                    if(t == goal)\\n                        return r;\\n                    if(t>=0 && t<=1000 && n[t]==-1) {\\n                        //cout<<t<<\":\"<<r<<endl;\\n                        n[t] = r;\\n                        tq.push(t);\\n                    }\\n                }\\n        }\\n        return -1;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\nint minimumOperations(vector<int>& nums, int start, int goal) {\\n        vector<int> n(1001, -1);\\n        n[start]=0;\\n        queue<int> tq;\\n        tq.push(start);\\n        while(tq.size()) {\\n            int i = tq.front();\\n            tq.pop();\\n                for(auto num:nums) {\\n                    int t = i+num;\\n                    int r = n[i]+1;\\n                    if(t == goal)\\n                        return r;\\n                    if(t>=0 && t<=1000 && n[t]==-1) {\\n                        //cout<<t<<\":\"<<r<<endl;\\n                        n[t] = r;\\n                        tq.push(t);\\n                    }\\n                    \\n                    t = i-num;\\n                    if(t == goal)\\n                        return r;\\n                    if(t>=0 && t<=1000 && n[t]==-1) {\\n                        //cout<<t<<\":\"<<r<<endl;\\n                        n[t] = r;\\n                        tq.push(t);\\n                    }\\n                    \\n                    t = i^num;\\n                    if(t == goal)\\n                        return r;\\n                    if(t>=0 && t<=1000 && n[t]==-1) {\\n                        //cout<<t<<\":\"<<r<<endl;\\n                        n[t] = r;\\n                        tq.push(t);\\n                    }\\n                }\\n        }\\n        return -1;\\n    }\\n\\t",
                "codeTag": "C++"
            },
            {
                "id": 1551857,
                "title": "python-iterative-approach-with-complexity-o-len-nums-1000",
                "content": "The key here is to make use of constraint that 0<=x<=1000. Hence, if we try to trace back from goal to target we can consider only relevant options to reach the goal using minimal operations. The only edge case would be start==goal in which case ans is 0.\\nI had to first operate on goal separately so as to make sure options variable have at least one value. I later on realized that one can start with options=([goal]) saving this extra effort i have done. But I would like to leave it as an excercise for someone who would like to try it out.\\n\\nPlease let me know if you find any bugs in it or a way to optimize it.\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        if start==goal:\\n            return 0\\n        store = [-1 for i in range(1001)]\\n        if goal<=1000 and goal>=0:\\n            store[goal] = 0\\n        options = set()\\n        for val in nums:\\n            if goal-val<=1000 and goal-val>=0:\\n                store[goal-val] = 1\\n                options.add(goal-val)\\n            if goal+val<=1000 and goal+val>=0:\\n                store[goal+val] = 1\\n                options.add(goal+val)\\n            if goal^val<=1000 and goal^val>=0:\\n                store[goal^val] = 1\\n                options.add(goal^val)\\n        counter = 1\\n        while store[start]==-1 and len(options):\\n            counter += 1\\n            temp = set()\\n            for opt in options:\\n                for val in nums:\\n                    t = opt-val\\n                    if t<=1000 and t>=0 and store[t]==-1:\\n                        store[t] = counter\\n                        temp.add(t)\\n                    t = opt+val\\n                    if t<=1000 and t>=0 and store[t]==-1:\\n                        store[t] = counter\\n                        temp.add(t)\\n                    t = opt^val\\n                    if t<=1000 and t>=0 and store[t]==-1:\\n                        store[t] = counter\\n                        temp.add(t)\\n            options = temp\\n        return store[start]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        if start==goal:\\n            return 0\\n        store = [-1 for i in range(1001)]\\n        if goal<=1000 and goal>=0:\\n            store[goal] = 0\\n        options = set()\\n        for val in nums:\\n            if goal-val<=1000 and goal-val>=0:\\n                store[goal-val] = 1\\n                options.add(goal-val)\\n            if goal+val<=1000 and goal+val>=0:\\n                store[goal+val] = 1\\n                options.add(goal+val)\\n            if goal^val<=1000 and goal^val>=0:\\n                store[goal^val] = 1\\n                options.add(goal^val)\\n        counter = 1\\n        while store[start]==-1 and len(options):\\n            counter += 1\\n            temp = set()\\n            for opt in options:\\n                for val in nums:\\n                    t = opt-val\\n                    if t<=1000 and t>=0 and store[t]==-1:\\n                        store[t] = counter\\n                        temp.add(t)\\n                    t = opt+val\\n                    if t<=1000 and t>=0 and store[t]==-1:\\n                        store[t] = counter\\n                        temp.add(t)\\n                    t = opt^val\\n                    if t<=1000 and t>=0 and store[t]==-1:\\n                        store[t] = counter\\n                        temp.add(t)\\n            options = temp\\n        return store[start]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551779,
                "title": "simple-python-solution-bfs",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:      \\n        if goal == start: return 0\\n        que = deque([goal])\\n        visited = {goal} if 0 <= goal <= 1000 else set()\\n        res = 0\\n\\n        while que and len(visited) < 1001:\\n            res += 1\\n            leng = len(que)\\n            for _ in range(leng):\\n                v = que.popleft()\\n                for n in nums:\\n                    for m in [v + n, v - n, v ^ n]:\\n                        if m < 0 or m > 1000: continue\\n                        if m not in visited:\\n                            if m == start: return res\\n                            visited.add(m)\\n                            que.append(m)\\n                        \\n        return -1\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:      \\n        if goal == start: return 0\\n        que = deque([goal])\\n        visited = {goal}",
                "codeTag": "Java"
            },
            {
                "id": 1551751,
                "title": "c-bfs-with-visited-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        unordered_set<int> frontier;\\n        frontier.insert(start);\\n        int count = 0;\\n        unordered_set<int> visited;\\n        while (!frontier.empty()) {\\n            count++;\\n            unordered_set<int> next_frontier;\\n            while (!frontier.empty()) {\\n                int num = *frontier.begin();\\n                frontier.erase(num);\\n                visited.insert(num);\\n                for (const auto& n : nums) {\\n                    if (((num + n) == goal) || ((num - n) == goal) || ((num ^ n) == goal)) return count;\\n                    if (valid(num + n, visited)) next_frontier.insert(num + n); \\n                    if (valid(num - n, visited)) next_frontier.insert(num - n); \\n                    if (valid(num ^ n, visited)) next_frontier.insert(num ^ n);\\n                }\\n            }\\n            frontier = next_frontier;\\n        }\\n        return -1;\\n    }\\n    \\n    bool valid(int n, const unordered_set<int>& visited) {\\n        return n >= 0 && n <= 1000 && visited.find(n) == visited.end();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        unordered_set<int> frontier;\\n        frontier.insert(start);\\n        int count = 0;\\n        unordered_set<int> visited;\\n        while (!frontier.empty()) {\\n            count++;\\n            unordered_set<int> next_frontier;\\n            while (!frontier.empty()) {\\n                int num = *frontier.begin();\\n                frontier.erase(num);\\n                visited.insert(num);\\n                for (const auto& n : nums) {\\n                    if (((num + n) == goal) || ((num - n) == goal) || ((num ^ n) == goal)) return count;\\n                    if (valid(num + n, visited)) next_frontier.insert(num + n); \\n                    if (valid(num - n, visited)) next_frontier.insert(num - n); \\n                    if (valid(num ^ n, visited)) next_frontier.insert(num ^ n);\\n                }\\n            }\\n            frontier = next_frontier;\\n        }\\n        return -1;\\n    }\\n    \\n    bool valid(int n, const unordered_set<int>& visited) {\\n        return n >= 0 && n <= 1000 && visited.find(n) == visited.end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551552,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        int[] cnt = new int[1001];\\n        Queue<Integer> q = new LinkedList();\\n        q.offer(start);\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            steps++;\\n            for(int i=0; i<size; i++){\\n                int cur = q.poll();\\n                for(int num : nums){\\n                    int plus = cur+num;\\n                    if(plus>=0 && plus<=1000 && cnt[plus]==0){\\n                        cnt[plus] = steps;\\n                        q.offer(plus);\\n                    }\\n                    int minus = cur-num;\\n                    if(minus>=0 && minus<=1000 && cnt[minus]==0){\\n                        cnt[minus] = steps;\\n                        q.offer(minus);\\n                    }\\n                    int xor = (cur^num);\\n                    if(xor>=0 && xor<=1000 && cnt[xor]==0){\\n                        cnt[xor] = steps;\\n                        q.offer(xor);\\n                    }\\n                    if(plus==goal || minus==goal || xor==goal)\\n                        return steps;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        int[] cnt = new int[1001];\\n        Queue<Integer> q = new LinkedList();\\n        q.offer(start);\\n        int steps = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            steps++;\\n            for(int i=0; i<size; i++){\\n                int cur = q.poll();\\n                for(int num : nums){\\n                    int plus = cur+num;\\n                    if(plus>=0 && plus<=1000 && cnt[plus]==0){\\n                        cnt[plus] = steps;\\n                        q.offer(plus);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1551257,
                "title": "python3-bfs-beat-100",
                "content": "```python\\nclass Solution:\\n    def minimumOperations(self, A: List[int], start: int, goal: int) -> int:\\n        seen = set()\\n        x = start\\n        q = {x}\\n        res = 0\\n        while q:\\n            res += 1\\n            nq = set()\\n            seen |= q\\n            for x in q:\\n                for w in A:\\n                    for v in [x + w, x - w, x ^ w]:\\n                        if v == goal:\\n                            return res\\n                        if (v not in seen) and 0 <= v < 1001:\\n                            nq.add(v)\\n            if not nq: return -1\\n            q = nq\\n```\\t\\t\\t",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumOperations(self, A: List[int], start: int, goal: int) -> int:\\n        seen = set()\\n        x = start\\n        q = {x}\\n        res = 0\\n        while q:\\n            res += 1\\n            nq = set()\\n            seen |= q\\n            for x in q:\\n                for w in A:\\n                    for v in [x + w, x - w, x ^ w]:\\n                        if v == goal:\\n                            return res\\n                        if (v not in seen) and 0 <= v < 1001:\\n                            nq.add(v)\\n            if not nq: return -1\\n            q = nq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551203,
                "title": "python3-bfs-100",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        n = len(nums)\\n        que = [start]\\n        steps = 0\\n        visited = set()\\n        while que:\\n            # print(que)\\n            nxt = []\\n            for x in que:\\n                if x == goal:\\n                    return steps\\n                if x in visited or x < 0 or x > 1000:\\n                    continue\\n                visited.add(x)\\n                for i in range(n):\\n                    nxt.append(x + nums[i]) \\n                    nxt.append(x - nums[i])\\n                    nxt.append(x ^ nums[i]) \\n            steps += 1\\n            que = nxt\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        n = len(nums)\\n        que = [start]\\n        steps = 0\\n        visited = set()\\n        while que:\\n            # print(que)\\n            nxt = []\\n            for x in que:\\n                if x == goal:\\n                    return steps\\n                if x in visited or x < 0 or x > 1000:\\n                    continue\\n                visited.add(x)\\n                for i in range(n):\\n                    nxt.append(x + nums[i]) \\n                    nxt.append(x - nums[i])\\n                    nxt.append(x ^ nums[i]) \\n            steps += 1\\n            que = nxt\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551106,
                "title": "python-3-two-head-bfs",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, target: int) -> int:\\n        n = len(nums)\\n        vis = defaultdict(lambda: float(\\'inf\\'), {start: 0})\\n        vis2 = defaultdict(lambda: float(\\'inf\\'), {target: 0})\\n        q = deque([(0, start, 0), (0, target, 1)])\\n        nums = set(nums)\\n        \\n        while q:\\n            steps, cur, typ = q.popleft()\\n            if typ == 0:\\n                for x in nums:\\n                    for ops in \\'+-^\\':\\n                        if ops == \\'+\\': new = cur + x\\n                        elif ops == \\'-\\': new = cur - x\\n                        else: new = cur ^ x\\n                        # new = eval(f\"{cur}{ops}{x}\")\\n                        if new in vis2:\\n                            return steps + 1 + vis2[new]\\n                        if new > 1000 or new < 0:\\n                            continue                     \\n                        if vis[new] > steps + 1:\\n                            vis[new] = steps + 1\\n                            q.append((steps + 1, new, typ))\\n            else:\\n                for x in nums:\\n                    for ops in \\'+-^\\':\\n                        if ops == \\'+\\': new = cur + x\\n                        elif ops == \\'-\\': new = cur - x\\n                        else: new = cur ^ x\\n                        # new = eval(f\"{cur}{ops}{x}\")\\n                        if new in vis:\\n                            return steps + 1 + vis[new]\\n                        if new > 1000 or new < 0:\\n                            continue                     \\n                        if vis2[new] > steps + 1:\\n                            vis2[new] = steps + 1\\n                            q.append((steps + 1, new, typ))\\n            \\n        \\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "class Solution:\\n    def minimumOperations(self, nums: List[int], start: int, target: int) -> int:\\n        n = len(nums)\\n        vis = defaultdict(lambda: float(\\'inf\\'), {start: 0}",
                "codeTag": "Java"
            },
            {
                "id": 1551008,
                "title": "c-bfs-hashset",
                "content": "```\\npublic class Solution {\\n    public int MinimumOperations(int[] nums, int start, int goal) {\\n        HashSet<int> hs = new HashSet<int>();\\n        Queue<int> queue = new Queue<int>();\\n        int res = 1;\\n        queue.Enqueue(start);\\n        \\n        while(queue.Count>0)\\n        {\\n            int cnt = queue.Count;\\n            while(cnt>0)\\n            {\\n                int num = queue.Dequeue();\\n                if(num>=0 && num<=1000 )\\n                {\\n                    for(int i = 0; i < nums.Length; i++)\\n                    {\\n                        if(!hs.Contains(num+nums[i]))\\n                            queue.Enqueue(num+nums[i]);\\n                        if(!hs.Contains(num-nums[i]))\\n                            queue.Enqueue(num-nums[i]);\\n                        if(!hs.Contains(num^nums[i]))\\n                            queue.Enqueue(num^nums[i]);\\n                        hs.Add(num+nums[i]);\\n                        hs.Add(num-nums[i]);\\n                        hs.Add(num^nums[i]);\\n\\n                    }\\n                }\\n                if(hs.Contains(goal))\\n                    return res;\\n                cnt--;\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public int MinimumOperations(int[] nums, int start, int goal) {\\n        HashSet<int> hs = new HashSet<int>();\\n        Queue<int> queue = new Queue<int>();\\n        int res = 1;\\n        queue.Enqueue(start);\\n        \\n        while(queue.Count>0)\\n        {\\n            int cnt = queue.Count;\\n            while(cnt>0)\\n            {\\n                int num = queue.Dequeue();\\n                if(num>=0 && num<=1000 )\\n                {\\n                    for(int i = 0; i < nums.Length; i++)\\n                    {\\n                        if(!hs.Contains(num+nums[i]))\\n                            queue.Enqueue(num+nums[i]);\\n                        if(!hs.Contains(num-nums[i]))\\n                            queue.Enqueue(num-nums[i]);\\n                        if(!hs.Contains(num^nums[i]))\\n                            queue.Enqueue(num^nums[i]);\\n                        hs.Add(num+nums[i]);\\n                        hs.Add(num-nums[i]);\\n                        hs.Add(num^nums[i]);\\n\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1550999,
                "title": "python-bfs-solution",
                "content": "``` \\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        visited,q,ans=set(),deque(),0\\n        q.append(start)\\n        while len(q):\\n          for i in range(len(q)):\\n                val=q.popleft()\\n                if val==goal: return ans\\n                if val>1000 or val<0 or val in visited: continue\\n                visited.add(val)\\n                for i in nums:\\n                    q.append(val+i)\\n                    q.append(val-i)\\n                    q.append(val^i)\\n          ans+=1\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "``` \\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        visited,q,ans=set(),deque(),0\\n        q.append(start)\\n        while len(q):\\n          for i in range(len(q)):\\n                val=q.popleft()\\n                if val==goal: return ans\\n                if val>1000 or val<0 or val in visited: continue\\n                visited.add(val)\\n                for i in nums:\\n                    q.append(val+i)\\n                    q.append(val-i)\\n                    q.append(val^i)\\n          ans+=1\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550978,
                "title": "python-solution-using-dfs-memorization",
                "content": "``` \\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        visited=set()\\n        nums.sort()\\n        @lru_cache(None)\\n        def dfs(start):\\n            if start==goal:return 0\\n            if start<0 or start>1000 or start in visited:return 10**20\\n            visited.add(start)\\n            mini=10**20\\n            for i in nums:\\n                mini=min(mini,dfs(start+i)+1,dfs(start-i)+1,dfs(start^i)+1)\\n            visited.remove(start)\\n            return mini\\n        ans=dfs(start)\\n        return -1 if ans>=10**20 else ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` \\nclass Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        visited=set()\\n        nums.sort()\\n        @lru_cache(None)\\n        def dfs(start):\\n            if start==goal:return 0\\n            if start<0 or start>1000 or start in visited:return 10**20\\n            visited.add(start)\\n            mini=10**20\\n            for i in nums:\\n                mini=min(mini,dfs(start+i)+1,dfs(start-i)+1,dfs(start^i)+1)\\n            visited.remove(start)\\n            return mini\\n        ans=dfs(start)\\n        return -1 if ans>=10**20 else ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550938,
                "title": "java-bfs",
                "content": "\\nclass Solution {\\n\\n\\tpublic int minimumOperations(int[] nums, int start, int goal) {\\n\\t\\tQueue<Integer> queue = new LinkedList<>();\\n\\t\\tint vis[] = new int[1001];\\n\\t\\tqueue.add(start);\\n\\t\\tint ans = 0;\\n\\t\\twhile (queue.size() > 0) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\twhile (size-- > 0) {\\n\\t\\t\\t\\tint top = queue.poll();\\n\\t\\t\\t\\tif (top == goal)\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\tif (top < 0 || top > 1000 || vis[top] == 1)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tvis[top] = 1;\\n\\t\\t\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\t\\t\\tint add = top + nums[i];\\n\\t\\t\\t\\t\\tint sub = top - nums[i];\\n\\t\\t\\t\\t\\tint xor = top ^ nums[i];\\n\\t\\t\\t\\t\\tqueue.add(add);\\n\\t\\t\\t\\t\\tqueue.add(sub);\\n\\t\\t\\t\\t\\tqueue.add(xor);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\tpublic int minimumOperations(int[] nums, int start, int goal) {\\n\\t\\tQueue<Integer> queue = new LinkedList<>();\\n\\t\\tint vis[] = new int[1001];\\n\\t\\tqueue.add(start);\\n\\t\\tint ans = 0;\\n\\t\\twhile (queue.size() > 0) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\twhile (size-- > 0) {\\n\\t\\t\\t\\tint top = queue.poll();\\n\\t\\t\\t\\tif (top == goal)\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\tif (top < 0 || top > 1000 || vis[top] == 1)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tvis[top] = 1;\\n\\t\\t\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\t\\t\\tint add = top + nums[i];\\n\\t\\t\\t\\t\\tint sub = top - nums[i];\\n\\t\\t\\t\\t\\tint xor = top ^ nums[i];\\n\\t\\t\\t\\t\\tqueue.add(add);\\n\\t\\t\\t\\t\\tqueue.add(sub);\\n\\t\\t\\t\\t\\tqueue.add(xor);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1550879,
                "title": "java-bfs-from-goal",
                "content": "```\\nclass Solution {\\n    enum Op{ADD, SUB, XOR};\\n    \\n    public int minimumOperations(int[] nums, int start, int goal) {\\n        int n= nums.length;\\n        LinkedList<Integer> q= new LinkedList<>();\\n        boolean[] visited= new boolean[1001];\\n        if(goal>=0 && goal<=1000) visited[goal]= true;\\n        q.add(goal);\\n        for(int steps= 0; !q.isEmpty(); steps++){\\n            for(int k= q.size(); k>0; k--){\\n                int curr= q.remove(), next;\\n                for(int i=0; i<n; i++){\\n                    for(Op op:Op.values()){\\n                        switch(op){\\n                            case ADD: next= curr+nums[i]; break;\\n                            case SUB: next= curr-nums[i]; break;\\n                            case XOR: \\n                            default: next= curr^nums[i]; break;\\n                        }\\n                        if(next<0 || next>1000 || visited[next]) continue;\\n                        if(next==start) return steps+1;\\n                        visited[next]= true;\\n                        q.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    enum Op{ADD, SUB, XOR}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1764257,
                "content": [
                    {
                        "username": "aryonbe",
                        "content": "This is graph problem considering each number as a node. There exists an edge (v,w) if v can be changed to w through an operation. We can do BFS."
                    },
                    {
                        "username": "realyogendra",
                        "content": "I found it hard \\nYour opinions??"
                    },
                    {
                        "username": "zechengli",
                        "content": "Couldn\\'t pass the 57/60 case? Any ideas what causes the problem?\\npublic int minimumOperations(int[] nums, int start, int goal) {\\n        Integer[] dp = new Integer[1001];\\n        return topDown(start, nums, goal, dp, new HashSet<>());\\n    }\\n\\n    public int topDown(int current, int[] nums, int goal, Integer[] dp, Set<Integer> visited) {\\n\\n        // System.out.println(current);\\n        if (current == goal) {\\n            return 0;\\n        }\\n        if (current < 0 || current > 1000) {\\n            return -1;\\n        }\\n        if (dp[current] != null) {\\n            //  System.out.println(\"cache: \"+ current);\\n            return dp[current];\\n        }\\n        if (visited.contains(current)) {\\n            return -1;\\n        }\\n\\n\\n        visited.add(current);\\n        int currentSteps = Integer.MAX_VALUE;\\n        for (int index = 0; index < nums.length; index++) {          \\n            int next1 = topDown(current + nums[index], nums, goal, dp, visited);\\n            int next2 = topDown(current - nums[index], nums, goal, dp, visited);\\n            int next3 = topDown(current ^ nums[index], nums, goal, dp, visited);\\n            if (next1 != -1) {\\n                currentSteps = Math.min(currentSteps, next1 + 1);\\n            }\\n            if (next2 != -1) {\\n                currentSteps = Math.min(currentSteps, next2 + 1);\\n            }\\n            if (next3 != -1) {\\n                currentSteps = Math.min(currentSteps, next3 + 1);\\n            }\\n\\n        }\\n        visited.remove(current);\\n        dp[current] = currentSteps == Integer.MAX_VALUE ? -1 : currentSteps;\\n        return dp[current];\\n    }"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro! don\\'t upload solutions here"
                    }
                ]
            },
            {
                "id": 1575912,
                "content": [
                    {
                        "username": "aryonbe",
                        "content": "This is graph problem considering each number as a node. There exists an edge (v,w) if v can be changed to w through an operation. We can do BFS."
                    },
                    {
                        "username": "realyogendra",
                        "content": "I found it hard \\nYour opinions??"
                    },
                    {
                        "username": "zechengli",
                        "content": "Couldn\\'t pass the 57/60 case? Any ideas what causes the problem?\\npublic int minimumOperations(int[] nums, int start, int goal) {\\n        Integer[] dp = new Integer[1001];\\n        return topDown(start, nums, goal, dp, new HashSet<>());\\n    }\\n\\n    public int topDown(int current, int[] nums, int goal, Integer[] dp, Set<Integer> visited) {\\n\\n        // System.out.println(current);\\n        if (current == goal) {\\n            return 0;\\n        }\\n        if (current < 0 || current > 1000) {\\n            return -1;\\n        }\\n        if (dp[current] != null) {\\n            //  System.out.println(\"cache: \"+ current);\\n            return dp[current];\\n        }\\n        if (visited.contains(current)) {\\n            return -1;\\n        }\\n\\n\\n        visited.add(current);\\n        int currentSteps = Integer.MAX_VALUE;\\n        for (int index = 0; index < nums.length; index++) {          \\n            int next1 = topDown(current + nums[index], nums, goal, dp, visited);\\n            int next2 = topDown(current - nums[index], nums, goal, dp, visited);\\n            int next3 = topDown(current ^ nums[index], nums, goal, dp, visited);\\n            if (next1 != -1) {\\n                currentSteps = Math.min(currentSteps, next1 + 1);\\n            }\\n            if (next2 != -1) {\\n                currentSteps = Math.min(currentSteps, next2 + 1);\\n            }\\n            if (next3 != -1) {\\n                currentSteps = Math.min(currentSteps, next3 + 1);\\n            }\\n\\n        }\\n        visited.remove(current);\\n        dp[current] = currentSteps == Integer.MAX_VALUE ? -1 : currentSteps;\\n        return dp[current];\\n    }"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro! don\\'t upload solutions here"
                    }
                ]
            },
            {
                "id": 1854050,
                "content": [
                    {
                        "username": "aryonbe",
                        "content": "This is graph problem considering each number as a node. There exists an edge (v,w) if v can be changed to w through an operation. We can do BFS."
                    },
                    {
                        "username": "realyogendra",
                        "content": "I found it hard \\nYour opinions??"
                    },
                    {
                        "username": "zechengli",
                        "content": "Couldn\\'t pass the 57/60 case? Any ideas what causes the problem?\\npublic int minimumOperations(int[] nums, int start, int goal) {\\n        Integer[] dp = new Integer[1001];\\n        return topDown(start, nums, goal, dp, new HashSet<>());\\n    }\\n\\n    public int topDown(int current, int[] nums, int goal, Integer[] dp, Set<Integer> visited) {\\n\\n        // System.out.println(current);\\n        if (current == goal) {\\n            return 0;\\n        }\\n        if (current < 0 || current > 1000) {\\n            return -1;\\n        }\\n        if (dp[current] != null) {\\n            //  System.out.println(\"cache: \"+ current);\\n            return dp[current];\\n        }\\n        if (visited.contains(current)) {\\n            return -1;\\n        }\\n\\n\\n        visited.add(current);\\n        int currentSteps = Integer.MAX_VALUE;\\n        for (int index = 0; index < nums.length; index++) {          \\n            int next1 = topDown(current + nums[index], nums, goal, dp, visited);\\n            int next2 = topDown(current - nums[index], nums, goal, dp, visited);\\n            int next3 = topDown(current ^ nums[index], nums, goal, dp, visited);\\n            if (next1 != -1) {\\n                currentSteps = Math.min(currentSteps, next1 + 1);\\n            }\\n            if (next2 != -1) {\\n                currentSteps = Math.min(currentSteps, next2 + 1);\\n            }\\n            if (next3 != -1) {\\n                currentSteps = Math.min(currentSteps, next3 + 1);\\n            }\\n\\n        }\\n        visited.remove(current);\\n        dp[current] = currentSteps == Integer.MAX_VALUE ? -1 : currentSteps;\\n        return dp[current];\\n    }"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro! don\\'t upload solutions here"
                    }
                ]
            }
        ]
    }
]