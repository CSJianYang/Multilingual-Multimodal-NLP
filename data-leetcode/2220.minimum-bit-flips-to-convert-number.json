[
    {
        "title": "Minimum Bit Flips to Convert Number",
        "question_content": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.\n\n\tFor example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.\n\nGiven two integers start and goal, return the minimum number of bit flips to convert start to goal.\n&nbsp;\nExample 1:\n\nInput: start = 10, goal = 7\nOutput: 3\nExplanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:\n- Flip the first bit from the right: 1010 -> 1011.\n- Flip the third bit from the right: 1011 -> 1111.\n- Flip the fourth bit from the right: 1111 -> 0111.\nIt can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.\nExample 2:\n\nInput: start = 3, goal = 4\nOutput: 3\nExplanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:\n- Flip the first bit from the right: 011 -> 010.\n- Flip the second bit from the right: 010 -> 000.\n- Flip the third bit from the right: 000 -> 100.\nIt can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3.\n\n&nbsp;\nConstraints:\n\n\t0 <= start, goal <= 109",
        "solutions": [
            {
                "id": 1907028,
                "title": "c-1-liner-xor-count-set-bits",
                "content": "To get minimum bit flips we find XOR of two number : which have set bits only at those places where A differs from B. \\nSo, after getting the **xor** `( a ^ b )` , we need to count the number of set bits.\\nWe can do that using **__builtin_popcount(i)**: This function is used to count the number of set bits in an integer.\\n\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```\\nPlease let me know ways to improve my solution.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911170,
                "title": "one-liners-have-a-look",
                "content": "Number of different bits is the required bits to flip, to make start and goal same.\\nWe can efficiently calculate them using xor operation : \\n\\n**Java one liner :** \\n```\\npublic int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n}\\n```\\n\\n\\n**CPP one liner :**\\n```\\nint minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n}\\n```\\n\\n**Python one liner :**\\n```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        return (start ^ goal).bit_count()\\n```\\n\\n**Javascript one liner :**\\n```\\nvar minBitFlips = function(start, goal) {\\n    return (start^goal).toString(2).split(\"0\").join(\"\").length;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\npublic int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n}\\n```\n```\\nint minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n}\\n```\n```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        return (start ^ goal).bit_count()\\n```\n```\\nvar minBitFlips = function(start, goal) {\\n    return (start^goal).toString(2).split(\"0\").join(\"\").length;\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1907470,
                "title": "c-2-methods-1-line-solution",
                "content": "## Method-1\\n\\nWe find last bit of both start and goal by two and check if the bit is same or not. Then divide the numbers by 2.\\n\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        while(start>0 or goal>0){\\n            int temp1=start%2;\\n            int temp2=goal%2;\\n            if(temp1!=temp2){\\n                ans++;\\n            }\\n            start/=2;\\n            goal/=2;\\n        }\\n        return ans;\\n    }\\n}; \\n```\\n\\n## Method-2\\n**XOR** start and goal to find the bits that are different\\nUse in-built method **popcount** to count the number of set bits\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        while(start>0 or goal>0){\\n            int temp1=start%2;\\n            int temp2=goal%2;\\n            if(temp1!=temp2){\\n                ans++;\\n            }\\n            start/=2;\\n            goal/=2;\\n        }\\n        return ans;\\n    }\\n}; \\n```\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907264,
                "title": "java-xor-and-counting-bits-beats-100",
                "content": "We need to count the number of corresponding bits of start and goal that are different.\\nxor-ing start and goal will result in a new number with binary representation of 0 where the corresponding bits of start and goal are equal and 1 where the corresponding bits are different.\\n\\nFor example: 10 and 7 \\n10 = 1010\\n  7 = 0111\\n  \\n10 xor 7 =  1101 (3 ones)\\n\\nNext we need to count the number of 1s (different bits)\\nThe quickest way to count the number of 1s in a number is by eliminating the right most 1 each time and count the number of eliminations, this is done by and-ing the number with (number-1)\\nSubtracting a 1 from a number flips all right most bits until the first right most 1 and by and-ing with the number itself we eliminating the all bits until the first tight most 1 (inclusive)\\nex. \\nnumber =1101\\nnumber -1 = 1100\\nnumber and (number -1) = 1100 (we eliminated the right most 1)\\n\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor =start ^ goal;\\n        int count=0;\\n        while(xor>0){\\n            count++;\\n            xor=xor & (xor-1);\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor =start ^ goal;\\n        int count=0;\\n        while(xor>0){\\n            count++;\\n            xor=xor & (xor-1);\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775126,
                "title": "python-java-c-solution-without-xor",
                "content": "# Divmod Remainder Approach:\\n#### Time Complexity: O(log(min(s,g))) --> O(log(n)) \\n#### Space Complexity: O(1)\\n\\nWe divide s and q by 2 until either s or g equals zero.\\nDuring this process, if the remainder of either of them **do not** equal eachother, we increment the counter.\\n\\n***This process is similar to converting a decimal number to binary***\\n\\n**Example:** s=10 g=7\\n\\n| iterations | s (binary) | g (binary) | counter | explaination\\n| - | --- | --- | --- | ---- |\\n1|   1010 |0111|+1| The last digit of s and g are ***different***\\n2|    0101 |0011|+0| The last digits are the **same** so we do nothing\\n3|    0010 |0001|+1| The last digit of s and g are ***different***\\n4|    0001 |0000|+1|The last digit of s and g are ***different***\\n\\n```Python []\\nclass Solution:\\n    def minBitFlips(self, s: int, g: int) -> int:\\n        count = 0 \\n        while s or g:\\n            if s%2 != g%2: count+=1\\n            s, g = s//2, g//2\\n        return count\\n```\\n```Java []\\nclass Solution {\\n    public int minBitFlips(int s, int g) {\\n        int count = 0;\\n        while(s > 0 || g > 0){\\n            if(s%2 != g%2) count++;\\n            s = s/2;\\n            g = g/2;\\n        }\\n        return count;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minBitFlips(int s, int g) {\\n        int count = 0;\\n        while(s > 0 || g > 0){\\n            if(s%2 != g%2) count++;\\n            s = s/2;\\n            g = g/2;\\n        }\\n        return count;\\n    }\\n};\\n```\\n```PsudoCode []\\nfunction minBitFlips(integer s, integer g){\\n\\tinitilize counter integer to 0\\n\\tloop until s or g is equal to zero{\\n\\t\\tif the s mod 2 and g mod 2 have the same remainder, increment counter\\n\\t\\tdivide s and g by 2 every pass\\n\\t}\\n\\treturn counter\\n}\\n```\\n\\n# PLEASE UPVOTE IF THIS HELPED YOU :)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python []\\nclass Solution:\\n    def minBitFlips(self, s: int, g: int) -> int:\\n        count = 0 \\n        while s or g:\\n            if s%2 != g%2: count+=1\\n            s, g = s//2, g//2\\n        return count\\n```\n```Java []\\nclass Solution {\\n    public int minBitFlips(int s, int g) {\\n        int count = 0;\\n        while(s > 0 || g > 0){\\n            if(s%2 != g%2) count++;\\n            s = s/2;\\n            g = g/2;\\n        }\\n        return count;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minBitFlips(int s, int g) {\\n        int count = 0;\\n        while(s > 0 || g > 0){\\n            if(s%2 != g%2) count++;\\n            s = s/2;\\n            g = g/2;\\n        }\\n        return count;\\n    }\\n};\\n```\n```PsudoCode []\\nfunction minBitFlips(integer s, integer g){\\n\\tinitilize counter integer to 0\\n\\tloop until s or g is equal to zero{\\n\\t\\tif the s mod 2 and g mod 2 have the same remainder, increment counter\\n\\t\\tdivide s and g by 2 every pass\\n\\t}\\n\\treturn counter\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911547,
                "title": "builtin-popcount-start-goal",
                "content": "**C++**\\n```cpp\\nint minBitFlips(int start, int goal) {\\n    return __builtin_popcount(start ^ goal);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minBitFlips(int start, int goal) {\\n    return __builtin_popcount(start ^ goal);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1916182,
                "title": "c-easy-o-n-solution-basic-maths",
                "content": "**Please upvote if you find this solution helpful**\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    //we just check whether binary bit is equal or not \\n    //if it is we do nothing otherwise we flips the bit and increase the count\\n    int minBitFlips(int start, int goal) \\n    {   \\n        int flips=0;\\n\\t\\t\\n\\t\\t//iterate until both numbers get 0\\n        while(start || goal)\\n        {\\n\\t\\t\\t//check whether bits are equal or not, if not we flip the bit\\n            if(start%2 != goal%2)\\n                flips++;\\n            \\n            start /= 2;\\n            goal /= 2;\\n        }\\n        return flips;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //we just check whether binary bit is equal or not \\n    //if it is we do nothing otherwise we flips the bit and increase the count\\n    int minBitFlips(int start, int goal) \\n    {   \\n        int flips=0;\\n\\t\\t\\n\\t\\t//iterate until both numbers get 0\\n        while(start || goal)\\n        {\\n\\t\\t\\t//check whether bits are equal or not, if not we flip the bit\\n            if(start%2 != goal%2)\\n                flips++;\\n            \\n            start /= 2;\\n            goal /= 2;\\n        }\\n        return flips;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513711,
                "title": "c-java-javascript-easy-solution-beats-100-bit-manipulation",
                "content": "# Intuition\\n - Question -> Here given Two numbers. If both no. are represented in Binary then how many minimum bits are required to change in one no. so it convert into second no. \\n\\n*example* ->  \\n```\\n  10  =   1   0   (1)   0\\n  7   =   0   1   (1)   1\\n```\\nhere, 3 bits are different in both no.s and need to be change in one of them to covert into another.\\n\\n# Approach \\nHere, we have to identify the different bits so , XOR operator can help us -->\\n```                                     \\n                                         A | B | A XOR B\\n                                         0 | 0 |   0\\n      10   = 1  0  1  0                  0 | 1 |   1                \\n      7    = 0  1  1  1                  1 | 0 |   1   \\n____________________________             1 | 1 |   0\\nxor(10,7)  = 1  1  0  1\\n```\\nNow , We have to just count the Set Bits(1) in result of xor.\\n no.of Set bits = 3. So, There is minimum 3 flips required.\\n# Complexity\\n- Time complexity:\\n\\n   Best case - O(1)\\n   Worst Case - O(n)\\n\\n- Space complexity:\\n \\n   Constant Space - O(1)\\n\\n# Code\\n\\n- C++ Code ->\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        int a = (start ^ goal); // this will do xor of given numbers\\n           //now count set bits\\n        int count = 0; \\n        while(a){\\n            if(a&1){\\n                count++;\\n            }\\n        a = a>>1;  // this is right shift operator\\n        }\\n        return count;\\n    }\\n};\\n```\\n- Java Code ->\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int a = (start ^ goal);\\n        int count = 0;\\n        \\n        while(a != 0) {\\n            if((a & 1) == 1) {\\n                count++;\\n            }\\n            \\n            a = a >> 1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```\\n- JavaScript code ->\\n```\\nvar minBitFlips = function(start, goal) {\\n    let a = start ^ goal;\\n        let count = 0;\\n        \\n        while (a !== 0) {\\n            if (a & 1) {\\n                count++;\\n            }\\n            \\n            a = a >> 1;\\n        }\\n        \\n        return count;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n  10  =   1   0   (1)   0\\n  7   =   0   1   (1)   1\\n```\n```                                     \\n                                         A | B | A XOR B\\n                                         0 | 0 |   0\\n      10   = 1  0  1  0                  0 | 1 |   1                \\n      7    = 0  1  1  1                  1 | 0 |   1   \\n____________________________             1 | 1 |   0\\nxor(10,7)  = 1  1  0  1\\n```\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        int a = (start ^ goal); // this will do xor of given numbers\\n           //now count set bits\\n        int count = 0; \\n        while(a){\\n            if(a&1){\\n                count++;\\n            }\\n        a = a>>1;  // this is right shift operator\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int a = (start ^ goal);\\n        int count = 0;\\n        \\n        while(a != 0) {\\n            if((a & 1) == 1) {\\n                count++;\\n            }\\n            \\n            a = a >> 1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```\n```\\nvar minBitFlips = function(start, goal) {\\n    let a = start ^ goal;\\n        let count = 0;\\n        \\n        while (a !== 0) {\\n            if (a & 1) {\\n                count++;\\n            }\\n            \\n            a = a >> 1;\\n        }\\n        \\n        return count;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014986,
                "title": "java-solution-with-explaination",
                "content": "# Intuition\\nWe want to check how many bits need to flipped in the input number to get the output number. So we would need to check the bits which are different in both numbers (No point in counting bits which are same in both) and count them.\\n\\n# Approach\\nE.g. \\n10 = 1010\\n7  = 0111\\nso different bits are, from rightmost bit, 1st, 3rd and 4th. \\nWe know XOR operation between two numbers will give us these different bits.\\n\\n      1010\\n    ^ 0111\\n    ____________   \\n      1101\\nAs we see here, in the output number only bits are set which are different in both numbers. (1 ^ 1) = 0 and (1 ^ 0) = 1\\n\\nNow, we just have to count these set bits and for that we will use  Kernighan\\u2019s algorithm to find the number of set bits in a number. The idea behind the algorithm is that when we subtract one from an integer, all the bits following the rightmost set of bits are inverted, turning 1 to 0 and 0 to 1. The rightmost set bit also gets inverted with the bits right to it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        if(start == goal) return 0;\\n        int xor = start ^ goal;\\n        int counter=0;\\n        while(xor > 0) {\\n            xor = xor & (xor-1);\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        if(start == goal) return 0;\\n        int xor = start ^ goal;\\n        int counter=0;\\n        while(xor > 0) {\\n            xor = xor & (xor-1);\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260588,
                "title": "python-easy-interview-thinking",
                "content": "The given question requires us to count the total number of flips we need to do inorder to make `start -> goal`.\\nEx:  \\n7 - 0111\\n10 - 1010\\nHere, we only flip the bits which are different in both **start** and **goal**, i.e. `01` or `10`. And, what helps us to find if the bits are different? **XOR**. \\nNow, we count these bits (i.e. different bits). And how do we calculate the number of `1\\'s` in a number? `n & (n-1)` technique.\\n\\nSo, the number of flips required is **3**.\\n\\nTherefore, the solution is divided into two parts - identify the distinct bits in both numbers and then, count these bits.\\n\\nSolution:\\n```python\\nclass Solution(object):\\n    def minBitFlips(self, start, goal):\\n        res = start ^ goal\\n        cnt = 0\\n        while res:\\n            res &= res - 1\\n            cnt += 1\\n        return cnt\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution(object):\\n    def minBitFlips(self, start, goal):\\n        res = start ^ goal\\n        cnt = 0\\n        while res:\\n            res &= res - 1\\n            cnt += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907288,
                "title": "python-solution-one-liner",
                "content": "**Just xor so we get 1 at places where bits are different and then count those bits.**\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return (bin(start^goal).count(\"1\"))\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return (bin(start^goal).count(\"1\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907216,
                "title": "c-easy-2-different-ways",
                "content": "We have to count all positions where the i\\'th bit of number **A** and **B** is different , so just iterate from bit 32 to 0 and check.\\n\\n```\\nclass Solution\\n{\\n    public:\\n        int minBitFlips(int start, int goal)\\n        {\\n            int cnt = 0;\\n            for (int i = 32; i >= 0; i--)\\n            {\\n\\t\\t\\t\\tint current = (1LL << i) & start;\\n                int required = (1LL << i) & goal;\\n                if (required != current)\\n                    cnt++;\\n            }\\n            return cnt;\\n        }\\n};\\n```\\n\\nAfter submitting , I realised that we can get different bit when we will do **XOR** of **A** and **B** \\nlike A = 101111\\nlike B = 110001\\nA^B  =  011110 , so just count how many ones in A^B , to count 1\\'s in a number we have a fucntion called **__builtin_popcount(N)** where N = A^B\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int A, int B) {\\n        return __builtin_popcount(A^B);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int minBitFlips(int start, int goal)\\n        {\\n            int cnt = 0;\\n            for (int i = 32; i >= 0; i--)\\n            {\\n\\t\\t\\t\\tint current = (1LL << i) & start;\\n                int required = (1LL << i) & goal;\\n                if (required != current)\\n                    cnt++;\\n            }\\n            return cnt;\\n        }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int A, int B) {\\n        return __builtin_popcount(A^B);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907471,
                "title": "c-0ms-solution-without-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start && goal){\\n            if(start%2!=goal%2) count++;\\n            start/=2;\\n            goal/=2;\\n        }\\n        while(start){\\n            if(start%2)count++;\\n            start/=2;\\n        }\\n        while(goal){\\n            if(goal%2)count++;\\n            goal/=2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start && goal){\\n            if(start%2!=goal%2) count++;\\n            start/=2;\\n            goal/=2;\\n        }\\n        while(start){\\n            if(start%2)count++;\\n            start/=2;\\n        }\\n        while(goal){\\n            if(goal%2)count++;\\n            goal/=2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526404,
                "title": "beats-100-easiest-code-using-inbuilt-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        string s= bitset<32> (start).to_string();\\n        string str= bitset<32> (goal).to_string();\\n        for(int i=0;i<32;i++){\\n            if(s[i]!=str[i]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\nDo UPVOTE\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        string s= bitset<32> (start).to_string();\\n        string str= bitset<32> (goal).to_string();\\n        for(int i=0;i<32;i++){\\n            if(s[i]!=str[i]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\nDo UPVOTE\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232519,
                "title": "curious-logic-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        s=bin(start)[2:].zfill(50)\\n        g=bin(goal)[2:].zfill(50)\\n        count=0\\n        for i in range(50):\\n            if s[i]!=g[i]:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        s=bin(start)[2:].zfill(50)\\n        g=bin(goal)[2:].zfill(50)\\n        count=0\\n        for i in range(50):\\n            if s[i]!=g[i]:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298518,
                "title": "cpp-ez-amazon-google-interview-o-set-bits",
                "content": "# ***UPVOTE PLZ  \\u2763***\\n# **Approach-1** Always takes O(N)\\nclass Solution {                        //O(N) soln.\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int c=0, i=0;\\n        while(start != goal){\\n            int mask=1<<i;\\n            if((start & mask) == (goal & mask))\\n                i++;\\n            else{\\n                start=start ^ mask;\\n                c++;\\n                i++;\\n            }    \\n        }\\n        return c;\\n    }\\n};\\n\\n# **Approach-2**   Faster :)\\nclass Solution {                         // O(No. of set bits in start^goal)\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int res = start ^ goal;\\n        int c=0;\\n        while(res!=0){\\n            res = res & (res-1);\\n            c++;\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {                        //O(N) soln.\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int c=0, i=0;\\n        while(start != goal){\\n            int mask=1<<i;\\n            if((start & mask) == (goal & mask))\\n                i++;\\n            else{\\n                start=start ^ mask;\\n                c++;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1910049,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn min_bit_flips(start: i32, goal: i32) -> i32 {\\n        (start ^ goal).count_ones() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_bit_flips(start: i32, goal: i32) -> i32 {\\n        (start ^ goal).count_ones() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907429,
                "title": "c-easy-and-operation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        int res(0);\\n        for (int i=32; ~i; i--) {\\n            if ((start & 1) != (goal & 1))  res++;\\n            start >>= 1; goal >>= 1;\\n        }\\n        return res;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        int res(0);\\n        for (int i=32; ~i; i--) {\\n            if ((start & 1) != (goal & 1))  res++;\\n            start >>= 1; goal >>= 1;\\n        }\\n        return res;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906980,
                "title": "easy-approach-o-n-time-no-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans = 0;\\n        while(start && goal) { \\n            if(start%2 != goal%2)\\n                ans++;\\n            start /= 2;\\n            goal /= 2;\\n        } \\n        while(start) { \\n            if(start%2)\\n                ans++;\\n            start /= 2;\\n        } \\n        while(goal) { \\n            if(goal%2)\\n                ans++;   \\n            goal /= 2;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans = 0;\\n        while(start && goal) { \\n            if(start%2 != goal%2)\\n                ans++;\\n            start /= 2;\\n            goal /= 2;\\n        } \\n        while(start) { \\n            if(start%2)\\n                ans++;\\n            start /= 2;\\n        } \\n        while(goal) { \\n            if(goal%2)\\n                ans++;   \\n            goal /= 2;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608176,
                "title": "0ms-solution-bit-manipulation",
                "content": "# Intuition\\nJust try to make the $start$ equals to $goal$ using $Bit Manipulations$.\\n\\n# Approach\\nIf the $goal$ bit is **set**, check if the $start$ bit is **set**, if not increase the count, as we will use one $flip$ operation.\\n\\nIf the $goal$ bit is **unset**, check if the $start$ bit is **unset**, if not increase the count, as we will use one $flip$ operation \\n\\n# Complexity\\n- Time complexity: $$O(log(max(start, goal)))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        while(goal || start)\\n        {\\n            bool goalBit = (goal&1);\\n            bool startBit = (start&1);\\n            if(goalBit)\\n            {\\n                if(startBit)\\n                {\\n                    // Do Nothing\\n                }\\n                else\\n                {\\n                    cnt++;\\n                }\\n            }\\n            else\\n            {\\n                if(startBit)\\n                {\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    // Do Nothing\\n                }\\n            }\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n# Follow up Question:\\nhttps://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/\\n**My Solution:** https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/solutions/3607616/0ms-solution-bit-manipulation/",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        while(goal || start)\\n        {\\n            bool goalBit = (goal&1);\\n            bool startBit = (start&1);\\n            if(goalBit)\\n            {\\n                if(startBit)\\n                {\\n                    // Do Nothing\\n                }\\n                else\\n                {\\n                    cnt++;\\n                }\\n            }\\n            else\\n            {\\n                if(startBit)\\n                {\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    // Do Nothing\\n                }\\n            }\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471702,
                "title": "kernighan-s-algorithm-easy-to-understand-with-explaination",
                "content": "\\n\\n\\n    class Solution {\\n    public:\\n    int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n        \\n        // # Here we get he number if set bits which are required for getting our goal number\\n        int set=start^goal;\\n        \\n        // # kernighan\\'s algo for finding no of set bits\\n        while(set!=0){\\n            \\n            // # a mask in which only right most bit is set\\n            int rsb=(set&(-set));\\n            set=set-rsb;\\n            cnt++;\\n        }\\n         return cnt;\\n     }\\n    };",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n    int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n        \\n        // # Here we get he number if set bits which are required for getting our goal number\\n        int set=start^goal;\\n        \\n        // # kernighan\\'s algo for finding no of set bits\\n        while(set!=0){\\n            \\n            // # a mask in which only right most bit is set\\n            int rsb=(set&(-set));\\n            set=set-rsb;\\n            cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3222968,
                "title": "easy-and-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly On Reading The Problem, We have to find How Many Bits \\nAre Different in **start** And **goal**.\\n\\nfor finding How many different bits,we use X-OR Gate .(0^1=1 and 1^0=1)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**_step1_** : find x-or of start and goal\\n**_step2_** : now find no.of set bits (i.e., no.of 1s) in xOredResult.\\n             (this is becuase \\'1\\' in xOredResult denotes the bits          are         different,so we have to flip them) \\n**_step3_** : the no.of set bits gives the no.of bits to flip actually\\n\\n(Read $$Brian-Kerninghan algorithm$$ to count no.of set bits in a particular number) \\n\\n# Complexity\\n- Time complexity: $$O(logn)$$ where \\'n\\' is the number whose set bits need to     be calculated\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n**Please upvote my solution if you really liked it**\\n\\n# Code\\n```\\nclass Solution {\\n    private int count = 0;\\n    public int minBitFlips(int start, int goal) {\\n\\n        // Find X-OR of start and goal to know no.of different bits\\n        int xOredResult = (start^goal);\\n\\n        // now Count no.of SetBits in xOredResult\\n        // using Brian-Kerninghan Algorithm\\n        return brianKerninghanAlgo(xOredResult);\\n    }\\n    public  int brianKerninghanAlgo(int num)\\n    {\\n        while(num != 0)\\n        {\\n            num&=(num-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    private int count = 0;\\n    public int minBitFlips(int start, int goal) {\\n\\n        // Find X-OR of start and goal to know no.of different bits\\n        int xOredResult = (start^goal);\\n\\n        // now Count no.of SetBits in xOredResult\\n        // using Brian-Kerninghan Algorithm\\n        return brianKerninghanAlgo(xOredResult);\\n    }\\n    public  int brianKerninghanAlgo(int num)\\n    {\\n        while(num != 0)\\n        {\\n            num&=(num-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527196,
                "title": "java-easy-solution-using-kernighan-s-algorithm",
                "content": "First we find xor of the two input numbers and count the number of set bits in the result using kernighan\\'s algorithm\\n\\nhere result=start^goal\\n\\nkernighan\\'s algorithm-\\n\\nIn a loop till the result > 0\\nStep 1 increase the count by 1\\nStep 2 result=result xor (result - 1)\\n\\n\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int n=start^goal,c=0;\\n        while(n>0)\\n        {\\n            n&=(n-1);\\n            c+=1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int n=start^goal,c=0;\\n        while(n>0)\\n        {\\n            n&=(n-1);\\n            c+=1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379732,
                "title": "one-liner-python",
                "content": "\\n```\\nreturn(start^goal).bit_count()\\n```\\n**Please upvote if you want to see more one liners and simple solutions**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nreturn(start^goal).bit_count()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2153745,
                "title": "c-solution-well-explained-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n     // Function to count the set bits\\n    int countSetBits(int n)\\n    {\\n        int count = 0;\\n        while(n > 0){\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    int minBitFlips(int start, int goal) {\\n        \\n        return countSetBits(start ^ goal); // start ^ goal : gives the differenciating bits\\n        \\n    }\\n};\\n```\\n\\n**Liked it ? Do upvote it, it do motivates !**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     // Function to count the set bits\\n    int countSetBits(int n)\\n    {\\n        int count = 0;\\n        while(n > 0){\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    int minBitFlips(int start, int goal) {\\n        \\n        return countSetBits(start ^ goal); // start ^ goal : gives the differenciating bits\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984124,
                "title": "python-solution-hamming-distance-based-one-liner",
                "content": "## Hamming Distance\\nHamming Distance between two integers is the number of bits that are different at the same position in both numbers. \\n\\nAlgorithm\\n- XOR the numbers\\n- Count set bits (1)\\n\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return bin(start ^ goal).count(\"1\")\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return bin(start ^ goal).count(\"1\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935603,
                "title": "c-simple-xor-operation-100-faster",
                "content": "```\\n//let start = 1101\\n//goal      = 1000\\n// Xor      = 0101\\n//NUmber of set bits in Xor\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) \\n    {\\n        int xorr = start xor goal;\\n        unsigned int ans=0;\\n        //Count number of bits to be flipped\\n        while(xorr)\\n        {\\n           ans++;\\n           xorr = xorr&(xorr-1);// Brian Kernighan\\'s Algorithm to count set bit;\\n        }\\n        return ans;\\n    }\\n};\\n//Please Do Upvote \\n//If you find Anything Incorrect or have doubt drop it down;",
                "solutionTags": [
                    "Counting"
                ],
                "code": "class Solution {\\npublic:\\n    int minBitFlips(int start, int goal) \\n    {\\n        int xorr = start xor goal;\\n        unsigned int ans=0;\\n        //Count number of bits to be flipped\\n        while(xorr)\\n        {\\n           ans++;\\n           xorr = xorr&(xorr-1);// Brian Kernighan\\'s Algorithm to count set bit;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1909597,
                "title": "bits-manipulation-xor",
                "content": "```\\nclass Solution {\\n\\tpublic static int minBitFlips(int a1, int a2) {\\n\\t\\tint n = (a1 ^ a2);\\n\\t\\tint res = 0;\\n\\t\\twhile (n != 0) {\\n\\t\\t\\tres++;\\n\\t\\t\\tn &= (n - 1);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic static int minBitFlips(int a1, int a2) {\\n\\t\\tint n = (a1 ^ a2);\\n\\t\\tint res = 0;\\n\\t\\twhile (n != 0) {\\n\\t\\t\\tres++;\\n\\t\\t\\tn &= (n - 1);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907384,
                "title": "c-xor-builtinpop-count",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1.\\n\\nXOR sets the bits that are different between `start` and `goal`, and unsets bits that are the same.\\n\\n`__builtin_popcount(mask)` counts the `1`s in `mask`.\\n\\nExample:\\n\\nExpression | Value\\n---|--\\nstart|      `0011010`\\ngoal|       `0101100`\\nstart^goal| `0110110`\\n__builtin_popcount(start^goal) | 4\\n\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start ^ goal);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start ^ goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907134,
                "title": "bitwise-easiest-logic-complexity-analysis-c",
                "content": "## **Solution**\\n\\n\\n#### **LOGIC**\\n* This is simpliy asking about [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance)\\n* Take [XOR](https://en.wikipedia.org/wiki/Exclusive_or), because it will set bit to 1 only when both bits are different\\n* Then simply count the bits\\n\\n\\n#### **Code**  \\n```cpp\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int a = start ^ goal;\\n        int sol = 0;\\n        \\n        while (a > 0) {\\n            sol += a & 1;\\n            a >>= 1;\\n        }\\n        \\n        return sol;\\n    }\\n};\\n```\\n\\n## **Complexity**\\n\\n##### __Apporach : 1__  \\n##### Time Complexity:  **O(floor(log10(n) + 1))**, where is ```n``` is ```max(start, goal)```.\\n\\n##### Space Complexity: **O(1)**\\n\\n\\n<br>\\n\\n __Check out all [my](https://leetcode.com/siddp6/) recent solutions [here](https://github.com/sidd6p/LeetCode)__\\n\\n \\n __Feel Free to Ask Doubts\\nAnd Please Share Some Suggestions\\nHAPPY CODING :)__\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int a = start ^ goal;\\n        int sol = 0;\\n        \\n        while (a > 0) {\\n            sol += a & 1;\\n            a >>= 1;\\n        }\\n        \\n        return sol;\\n    }\\n};\\n```\n```n```\n```max(start, goal)```",
                "codeTag": "Java"
            },
            {
                "id": 3821164,
                "title": "2220-java-bit-manipulation-100-efficient",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int mask=(1<<i);\\n            if(((start & mask)==0 && (goal & mask)!=0) || ((start & mask)!=0 && (goal & mask)==0))\\n                count++;\\n\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int mask=(1<<i);\\n            if(((start & mask)==0 && (goal & mask)!=0) || ((start & mask)!=0 && (goal & mask)==0))\\n                count++;\\n\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613891,
                "title": "java-bit-manipulation-beats-100-kernighan-s-algorithm-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing XOR operator the bits that are different will become 1 and same bits will become 0 . After that we just need to count the number of 1\\'s using the Kernighan\\'s Algorithm.\\n\\n# Approach\\n\\nFirst we store the XOR operator result in n and then we initialize a counter with 0 . Now we loop until the n!=0 and inside the loop we are initializing rsbm (right most set bit mask ) for the n. And after that we subtract the rightmost set bit from n using n -= rsbm. This clears the rightmost set bit from n. The counter variable is incremented by 1. At last we return counter .\\n\\n# Complexity\\n- Time complexity:\\n    O(Log(n))\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int n = start^goal;\\n        int counter = 0;\\n       \\n        while(n!=0){\\n            int rsbm = n & -n;\\n            n -= rsbm;\\n            counter++;\\n        }\\n\\n        return counter;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int n = start^goal;\\n        int counter = 0;\\n       \\n        while(n!=0){\\n            int rsbm = n & -n;\\n            n -= rsbm;\\n            counter++;\\n        }\\n\\n        return counter;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193970,
                "title": "c-easy-100-acceptance",
                "content": "<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int s,g,cnt=0;\\n        while(start!=goal){\\n            s=start&1;\\n            g=goal&1;\\n            if(s!=g)\\n                cnt++;\\n                start=start>>1;\\n                goal=goal>>1;\\n        }\\n    return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int s,g,cnt=0;\\n        while(start!=goal){\\n            s=start&1;\\n            g=goal&1;\\n            if(s!=g)\\n                cnt++;\\n                start=start>>1;\\n                goal=goal>>1;\\n        }\\n    return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896646,
                "title": "c-simple-solution-with-explanation",
                "content": "**Please upvote if my solution was helpful ;)**\\n# Explanation\\nExample: start = 10, goal = 7, in binary representation are 1010 and 0111 respectively\\n\\n![dsadasdasd.png](https://assets.leetcode.com/users/images/d3e73bbc-7534-452f-8f32-999d0fc8f029_1670664733.3221765.png)\\n\\n\\n1101 is a result of XOR operation - result = start^goal. Answer is a count of \"1\" bits in result.\\n\\n# Algorithm\\n1) Initialize \"result\" as a start^goal (xor operation)\\n2) Count \"1\" bits in result and return it\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int MinBitFlips(int start, int goal)\\n    {\\n        int result = start^goal;\\n        int output = 0;\\n        while(result > 0)\\n        {\\n            if((result & 1) == 1) output++;\\n            result = result>>1;\\n        }\\n        return output;\\n    }\\n}\\n```\\n# Code 2(memory optimization)\\n\\nIn the code below we are using method parameters start and goal as a local variables \\n\\n```\\npublic class Solution \\n{\\n    public int MinBitFlips(int start, int goal)\\n    {\\n        start = start^goal;\\n        goal = 0;\\n        while(start > 0)\\n        {\\n            if((start & 1) == 1) goal++;\\n            start = start>>1;\\n        }\\n        return goal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MinBitFlips(int start, int goal)\\n    {\\n        int result = start^goal;\\n        int output = 0;\\n        while(result > 0)\\n        {\\n            if((result & 1) == 1) output++;\\n            result = result>>1;\\n        }\\n        return output;\\n    }\\n}\\n```\n```\\npublic class Solution \\n{\\n    public int MinBitFlips(int start, int goal)\\n    {\\n        start = start^goal;\\n        goal = 0;\\n        while(start > 0)\\n        {\\n            if((start & 1) == 1) goal++;\\n            start = start>>1;\\n        }\\n        return goal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846834,
                "title": "easiest-solution-c-plus-plus-one-pass-100-ac-bitset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        string str = bitset<32>(start).to_string();\\n        string str2 = bitset<32>(goal).to_string();\\n        int count = 0;\\n        for(int i=0;i<32;i++) if(str[i]!=str2[i]) count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        string str = bitset<32>(start).to_string();\\n        string str2 = bitset<32>(goal).to_string();\\n        int count = 0;\\n        for(int i=0;i<32;i++) if(str[i]!=str2[i]) count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742496,
                "title": "xor-1-line-code",
                "content": "\\'\\'\\'\\nclass Solution \\n{\\n public:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n\\'\\'\\'\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution \\n{\\n public:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2689315,
                "title": "100-faster-javascript",
                "content": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(n, p) {\\n    let count = 0;\\nwhile (p != 0 || n!=0)\\n{\\n    let d = p & 1;\\n    let f = n & 1;\\n    if(d!=f)\\n    {\\n        count++;\\n    }\\n    n=n >> 1;\\n    p = p >> 1;\\n}\\n       return count; \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(n, p) {\\n    let count = 0;\\nwhile (p != 0 || n!=0)\\n{\\n    let d = p & 1;\\n    let f = n & 1;\\n    if(d!=f)\\n    {\\n        count++;\\n    }\\n    n=n >> 1;\\n    p = p >> 1;\\n}\\n       return count; \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2658238,
                "title": "most-efficient-c-solution-using-bitset-o-32-constant-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        bitset<32> bs1(start);\\n        bitset<32> bs2(goal);\\n        int cnt=0;\\n        for(int i=0;i<32;i++){\\n            if(bs1[i]!=bs2[i]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        bitset<32> bs1(start);\\n        bitset<32> bs2(goal);\\n        int cnt=0;\\n        for(int i=0;i<32;i++){\\n            if(bs1[i]!=bs2[i]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614337,
                "title": "xor-python",
                "content": "```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        n = start ^ goal \\n        count = 0\\n\\n        #counting set bits\\n        while n:\\n            n = n & (n-1) \\n            count += 1\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        n = start ^ goal \\n        count = 0\\n\\n        #counting set bits\\n        while n:\\n            n = n & (n-1) \\n            count += 1\\n\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2595426,
                "title": "java-bit-manipulation-1-line-code-simple-solution",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548154,
                "title": "3ms-space-95-beats-c-simple-easy-bit-count",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int &start, int &goal) {\\n        int ans = 0;\\n        start = start ^ goal;\\n        while(start){\\n            ans += (start&1);\\n            start = start >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int &start, int &goal) {\\n        int ans = 0;\\n        start = start ^ goal;\\n        while(start){\\n            ans += (start&1);\\n            start = start >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421145,
                "title": "minimum-bit-flips-to-convert-number",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int x=start^goal;\\n        return __builtin_popcount(x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int x=start^goal;\\n        return __builtin_popcount(x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053637,
                "title": "java-solution",
                "content": "```java class Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int c=0;\\n       while(start!=0||goal!=0)\\n       {\\n           if(start%2!=goal%2)\\n               c++;\\n           start/=2;\\n           goal/=2;\\n       }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int c=0;\\n       while(start!=0||goal!=0)\\n       {\\n           if(start%2!=goal%2)\\n               c++;\\n           start/=2;\\n           goal/=2;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1910645,
                "title": "here-is-my-solution-using-bitset-c-easy-to-understand",
                "content": "Using ```std::bitset``` Class to Convert Decimal Number to Binary in C++\\n\\n```\\nint minBitFlips(int start, int goal) {  // start=10 , goal=7 \\n\\t\\t\\n\\t\\t// binary representation of 10 is 1010\\n\\t\\t// binary representation of 7 is 0111\\n\\t\\tbitset<32> bs1(start);    // bs1 = 00000000000000000000000000001010 \\n\\t\\tbitset<32> bs2(goal);     // bs2 = 00000000000000000000000000000111\\n\\t\\t\\n\\t\\tint count=0;\\n\\t\\tfor(int i=0; i<32; i++){\\n\\t\\t\\tif(bs1[i]!=bs2[i]){  \\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}    \\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n}\\n```\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```std::bitset```\n```\\nint minBitFlips(int start, int goal) {  // start=10 , goal=7 \\n\\t\\t\\n\\t\\t// binary representation of 10 is 1010\\n\\t\\t// binary representation of 7 is 0111\\n\\t\\tbitset<32> bs1(start);    // bs1 = 00000000000000000000000000001010 \\n\\t\\tbitset<32> bs2(goal);     // bs2 = 00000000000000000000000000000111\\n\\t\\t\\n\\t\\tint count=0;\\n\\t\\tfor(int i=0; i<32; i++){\\n\\t\\t\\tif(bs1[i]!=bs2[i]){  \\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}    \\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909725,
                "title": "xor-bit-counting",
                "content": "**C++:**\\n**Brian Kernighan\\u2019s algorithm to count set bits:**\\n```\\nint minBitFlips(int n, int m)\\n{\\n\\tint out{};\\n\\tfor(n^=m; n; n=n&(n-1), out++);\\n\\treturn out;\\n}\\n```\\nor\\n**builtins:**\\n```\\nint minBitFlips(int n, int m)\\n{\\n\\treturn __builtin_popcount(n^m);            \\n}\\n```\\nsince `c++20` it would be possible to do this:\\n```\\nint minBitFlips(int n, int m)\\n{\\n\\treturn popcount(n^m);            \\n}\\n```\\n**Python3:**\\n```\\ndef minBitFlips(self, n, m):\\n\\treturn (n^m).bit_count()\\n```\\nor\\n**Python:**\\n```\\ndef minBitFlips(self, n, m):\\n\\treturn bin(n^m).count(\\'1\\')\\n```\\n**JS:**\\n```\\nvar minBitFlips = (n, m) => (n^m).toString(2).replace(/0/g,\"\").length;\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nint minBitFlips(int n, int m)\\n{\\n\\tint out{};\\n\\tfor(n^=m; n; n=n&(n-1), out++);\\n\\treturn out;\\n}\\n```\n```\\nint minBitFlips(int n, int m)\\n{\\n\\treturn __builtin_popcount(n^m);            \\n}\\n```\n```\\nint minBitFlips(int n, int m)\\n{\\n\\treturn popcount(n^m);            \\n}\\n```\n```\\ndef minBitFlips(self, n, m):\\n\\treturn (n^m).bit_count()\\n```\n```\\ndef minBitFlips(self, n, m):\\n\\treturn bin(n^m).count(\\'1\\')\\n```\n```\\nvar minBitFlips = (n, m) => (n^m).toString(2).replace(/0/g,\"\").length;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1909245,
                "title": "python-without-built-in-function-and-bit-manipulation",
                "content": "* convert integer to binary\\n* padding \\'0\\' for shorter binary\\n* compare every bits and count not matched cases\\n\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:       \\n        s = bin(start)[2:]\\n        g = bin(goal)[2:]\\n        \\n        if len(s) > len(g):\\n            g = (len(s) - len(g)) * \\'0\\' + g\\n        elif len(g) > len(s):\\n            s = (len(g) - len(s)) * \\'0\\' + s\\n        \\n        res = 0\\n        \\n        for i in range(len(s)):\\n            if s[i] != g[i]:\\n                res += 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:       \\n        s = bin(start)[2:]\\n        g = bin(goal)[2:]\\n        \\n        if len(s) > len(g):\\n            g = (len(s) - len(g)) * \\'0\\' + g\\n        elif len(g) > len(s):\\n            s = (len(g) - len(s)) * \\'0\\' + s\\n        \\n        res = 0\\n        \\n        for i in range(len(s)):\\n            if s[i] != g[i]:\\n                res += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907560,
                "title": "python-readable-long",
                "content": "when you dont know rjust , lol. At least i solved it myself\\n\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        binstart = bin(start)[2:]\\n        bingoal = bin(goal)[2:]\\n        \\n        count= 0\\n        \\n        mini = min(len(binstart), len(bingoal))\\n        \\n        if len(binstart) < len(bingoal):\\n            diff = abs(len(bingoal) - len(binstart))\\n            binstart = diff * \\'0\\' + binstart\\n        else:\\n            diff = abs(len(bingoal) - len(binstart))\\n            bingoal = diff * \\'0\\' + bingoal\\n            \\n            \\n        binstart = list(binstart)\\n        bingoal = list(bingoal)\\n        for i in range(len(binstart)-1,-1,-1):\\n            \\n            if binstart[i] != bingoal[i]:\\n                binstart[i] = str(int(binstart[i]) ^ int(bingoal[i]))\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        binstart = bin(start)[2:]\\n        bingoal = bin(goal)[2:]\\n        \\n        count= 0\\n        \\n        mini = min(len(binstart), len(bingoal))\\n        \\n        if len(binstart) < len(bingoal):\\n            diff = abs(len(bingoal) - len(binstart))\\n            binstart = diff * \\'0\\' + binstart\\n        else:\\n            diff = abs(len(bingoal) - len(binstart))\\n            bingoal = diff * \\'0\\' + bingoal\\n            \\n            \\n        binstart = list(binstart)\\n        bingoal = list(bingoal)\\n        for i in range(len(binstart)-1,-1,-1):\\n            \\n            if binstart[i] != bingoal[i]:\\n                binstart[i] = str(int(binstart[i]) ^ int(bingoal[i]))\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907201,
                "title": "very-easy-solution",
                "content": "class Solution {\\npublic:\\n    \\n    int countSetBits(int n)\\n{\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);\\n    }\\n    return count;\\n}\\n \\n\\n\\n    int minBitFlips(int start, int goal) {\\n            return countSetBits(start^goal);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int countSetBits(int n)\\n{\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1907079,
                "title": "using-xor-operation-4-lines-of-code-only-cpp-solution-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        bitset<32>str = start; //Converting into bits\\n \\xA0 \\xA0 \\xA0 \\xA0bitset<32>end= goal; \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 bitset<32>res = str^end; // Applying XOR operation\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return res.count(); // returning the number of flips\\n\\n    }\\n};\\n```\\n**Please upvote if you find this helpful**\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        bitset<32>str = start; //Converting into bits\\n \\xA0 \\xA0 \\xA0 \\xA0bitset<32>end= goal; \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 bitset<32>res = str^end; // Applying XOR operation\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return res.count(); // returning the number of flips\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907070,
                "title": "javascript-easy-solution-xor",
                "content": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(start, goal) {\\n    let orVal = start ^ goal;\\n    \\n    let cnt = 0;\\n    while (orVal > 0) {\\n        cnt++;\\n        orVal &= (orVal-1);\\n    }\\n    \\n    return cnt;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(start, goal) {\\n    let orVal = start ^ goal;\\n    \\n    let cnt = 0;\\n    while (orVal > 0) {\\n        cnt++;\\n        orVal &= (orVal-1);\\n    }\\n    \\n    return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907055,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(int a)\\n    {\\n    int count = 0;\\n    while (a > 0)\\n    {\\n        count++;\\n        a &= (n-1);\\n    }\\n    return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        return c(start^goal);\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int a)\\n    {\\n    int count = 0;\\n    while (a > 0)\\n    {\\n        count++;\\n        a &= (n-1);\\n    }\\n    return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        return c(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906973,
                "title": "java-one-line-with-math",
                "content": "Count diff of binary string, xor is for the work\\n\\n```\\n^ 0 1 \\n0 0 1\\n1 1 0\\n```\\n\\nTime: O(1)\\nSpace: O(1)\\n\\n```\\nclass Solution {\\n  public int minBitFlips(int start, int goal) {\\n    return Integer.bitCount(start ^ goal);\\n  }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n^ 0 1 \\n0 0 1\\n1 1 0\\n```\n```\\nclass Solution {\\n  public int minBitFlips(int start, int goal) {\\n    return Integer.bitCount(start ^ goal);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063019,
                "title": "1-line-solution-beats-100-0-ms",
                "content": "# Intuition\\nThe problem is asking to find the minimum number of bit flips required to convert one integer to another. The intuition here is that the bits that need to be flipped are exactly the ones that differ in the two numbers. \\n\\n# Approach\\nThe approach to solve this problem is as follows:\\n1. Compute the XOR of the two numbers. The XOR operation will give a binary number where each bit is 1 if the corresponding bits in the two numbers are different, and 0 if they are the same.\\n2. Count the number of set bits (bits that are 1) in the result. This can be done using the `__builtin_popcount` function in C++. Each set bit represents a position where the two numbers differ, so flipping this bit in one number will make it match the corresponding bit in the other number.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\nThe time complexity is constant because XOR and bit count operations take constant time for integers.\\n\\n- Space complexity: $$O(1)$$\\nThe space complexity is also constant because only a fixed amount of space is needed to store the input numbers and intermediate results.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923042,
                "title": "java-simple-solution-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        while(start != goal){\\n            if((goal & 1) != (start & 1)){\\n                start ^= 1;\\n                cnt++;\\n            }\\n            goal >>= 1;\\n           start >>= 1;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        while(start != goal){\\n            if((goal & 1) != (start & 1)){\\n                start ^= 1;\\n                cnt++;\\n            }\\n            goal >>= 1;\\n           start >>= 1;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810023,
                "title": "one-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we know that xor only returns 1 when both theb numbers have a differnce in their respective digits. Therefore we will simply XOR both the numbers and later count the number of set bits in the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755070,
                "title": "easy-o-1-space",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int count = 0;\\n\\n    while (a > 0 and b > 0)\\n    {\\n        if ((a & 1) != (b & 1))\\n        {\\n            count++;\\n        }\\n        a >>= 1;\\n        b >>= 1;\\n    }\\n\\n    while (a)\\n    {\\n        if (a & 1)\\n        {\\n            count++;\\n        }\\n        a >>= 1;\\n    }\\n\\n    while (b)\\n    {\\n        if (b & 1)\\n        {\\n            count++;\\n        }\\n        b >>= 1;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int count = 0;\\n\\n    while (a > 0 and b > 0)\\n    {\\n        if ((a & 1) != (b & 1))\\n        {\\n            count++;\\n        }\\n        a >>= 1;\\n        b >>= 1;\\n    }\\n\\n    while (a)\\n    {\\n        if (a & 1)\\n        {\\n            count++;\\n        }\\n        a >>= 1;\\n    }\\n\\n    while (b)\\n    {\\n        if (b & 1)\\n        {\\n            count++;\\n        }\\n        b >>= 1;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753222,
                "title": "simple-basic-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int count=0;\\n    while (a > 0 || b > 0) {\\n \\n        int t1 = (a & 1);\\n        int t2 = (b & 1);\\n \\n        if (t1 != t2) {\\n            count++;\\n        }\\n        // right shifting a and b\\n        a >>= 1;\\n        b >>= 1;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int count=0;\\n    while (a > 0 || b > 0) {\\n \\n        int t1 = (a & 1);\\n        int t2 = (b & 1);\\n \\n        if (t1 != t2) {\\n            count++;\\n        }\\n        // right shifting a and b\\n        a >>= 1;\\n        b >>= 1;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724804,
                "title": "one-of-the-most-easiest-solutions",
                "content": "# Intuition\\nWe need to just count to total number of different bits of `start` and `end`.\\n\\n# Approach\\nFind `XOR` of `start` and `end` and then count 1. Because after `XOR` any two value, we get 1 only when where the bit is different.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n\\n        long long diffBits = start ^ goal;\\n        while(diffBits != 0){\\n            if(diffBits & 1) count++;\\n            diffBits >>= 1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```\\n\\n**Please upvote if you really like the approach. \\uD83D\\uDC4D\\uD83C\\uDFFB**\\n\\nCheckout my GitHub repo: [GitHub](https://github.com/RiyaadHossain/LeetCode-Problem)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n\\n        long long diffBits = start ^ goal;\\n        while(diffBits != 0){\\n            if(diffBits & 1) count++;\\n            diffBits >>= 1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607182,
                "title": "100-c-most-easy-solution-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) \\n    {\\n        int ans=0;\\n        string s= bitset<32>(start).to_string();\\n        string str= bitset<32> (goal).to_string();\\n        for(int i=0;i<32;i++)\\n        {\\n            if(s[i]!=str[i]) \\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) \\n    {\\n        int ans=0;\\n        string s= bitset<32>(start).to_string();\\n        string str= bitset<32> (goal).to_string();\\n        for(int i=0;i<32;i++)\\n        {\\n            if(s[i]!=str[i]) \\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483816,
                "title": "c-100-beat-using-bit-manipulation-way",
                "content": "# Intuition\\nEasy way to play with bit Manipulation way.\\n\\n# Approach\\n- take a variable and store in it xor of start and goal ex\\n`int a=start ^ goal;`\\n- count number of 1 bit in this number `while(a)\\n{ if(a&1)ans++;\\na>>=1;}`\\n- return the count;\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Please upvote my work\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int a=start ^ goal;\\n        int ans=0;\\n        while(a)\\n       { if(a&1)ans++;\\n        a>>=1;}\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int a=start ^ goal;\\n        int ans=0;\\n        while(a)\\n       { if(a&1)ans++;\\n        a>>=1;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456503,
                "title": "bit-manipulation-using-rsb-mask-easiest-solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        int ans=start^goal;\\n        int cnt=0;\\n        while(ans){\\n            int rsb=ans&(-ans);\\n            ans=ans-rsb;\\n            cnt++;\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        int ans=start^goal;\\n        int cnt=0;\\n        while(ans){\\n            int rsb=ans&(-ans);\\n            ans=ans-rsb;\\n            cnt++;\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443196,
                "title": "java-easy-solution-beats-100-using-bit-manipulation-asked-in-persistent-systems",
                "content": "# Intuition\\nBasically we have to find the count of bits which are different in both given start and goal variables.\\nFor e.g. - start = 4 and goal = 7 \\nNow lets look at their Binary representation as we\\'ve to find the number of bits after all.\\nstart= 4 -> 1 0 0\\ngoal = 7 -> 1 1 1\\nxor  = ^ -> 0 1 1 ( Total set bits(1\\'s) represents the bit difference between the given two numbers)\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, we get the number of bits which are different in both the variables after xor.\\nHere we get xor = 3 .\\nSo, then we\\'ll just count the set bits of xor and return it as our answer.\\n\\nWe use one of the most effective method to count the set bits i.e.,\\n**n & (n-1)** \\nIn our case we have xor in place of n.\\nSo, **xor % (xor-1)**\\nE.g., 3&(3-1) = 3&2 = 2\\nthen 2&(2-1) = 2&1 = 0\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\nO(log N)\\n\\n- Space complexity:\\nO(1)\\n\\n---\\n\\n\\n**Hope it helps, Happy LeetCoding{^_^}**\\n\\n---\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor = (start^goal);\\n        int count = 0;\\n        while(xor!=0) {\\n            count++;\\n            xor = xor & (xor-1);\\n        }\\n        return count;\\n    }\\n}\\n```\\n---",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor = (start^goal);\\n        int count = 0;\\n        while(xor!=0) {\\n            count++;\\n            xor = xor & (xor-1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342937,
                "title": "0-ms-100-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n      int n=start^goal;\\n        int count=0;\\n        while(n){\\n            n=n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n      int n=start^goal;\\n        int count=0;\\n        while(n){\\n            n=n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299721,
                "title": "efficient-code-100-beats-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the start and goal are equal then no bit need to be converted.\\nIf start is greater than goal then it might take more bit than the goal \\nand if the goal is greater than start then it might take more bit than start.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\nIf you find it helpful then please upvote\\u2B06\\uFE0F\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        if(start==goal){\\n            return count;\\n        }\\n        else if(start>goal){\\n            while(start>0){\\n                if((start&1) != (goal&1)){\\n                    count++;\\n                }\\n                start>>=1;\\n                goal>>=1;\\n            }\\n        }else{\\n            while(goal>0){\\n                if((start&1) != (goal&1)){\\n                    count++;\\n                }\\n                start>>=1;\\n                goal>>=1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        if(start==goal){\\n            return count;\\n        }\\n        else if(start>goal){\\n            while(start>0){\\n                if((start&1) != (goal&1)){\\n                    count++;\\n                }\\n                start>>=1;\\n                goal>>=1;\\n            }\\n        }else{\\n            while(goal>0){\\n                if((start&1) != (goal&1)){\\n                    count++;\\n                }\\n                start>>=1;\\n                goal>>=1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280695,
                "title": "java-two-different-approaches",
                "content": "\\n\\n# Approach 1:\\nWe\\'ll first convert both the numbers into 32-bit binary string forms. Then, we will check the number of different bits (characters in the strings) among the two converted binary string forms.\\n\\n# Code:\\n```\\n    String startBinary = String.format(\"%32s\", Integer.toBinaryString(start)).replaceAll(\" \", \"0\");\\n    String goalBinary = String.format(\"%32s\", Integer.toBinaryString(goal)).replaceAll(\" \", \"0\");\\n\\n    int minFlip = 0;\\n    int pointer = 0;\\n    while (pointer < startBinary.length()) {\\n      if (startBinary.charAt(pointer) != goalBinary.charAt(pointer)) {\\n        minFlip += 1;\\n      }\\n      pointer += 1;\\n    }\\n    return minFlip;\\n```\\n\\n\\n# Approach 2:\\nWe can solve the problem easily using the XOR operation because XOR produces 1 for different bits between two numbers. We can thus create a new variable, which will be the XOR of the given two variables. Afterwards, we\\'ll loop through and find out the number of 1 bits (different bits) in the previously produced XOR value. To find out the number of 1 bits, we can use [Brian Kernighan\\'s](https://leeyoongti.medium.com/counting-set-bits-using-brian-kernighans-algorithm-14d5699244ae) algorithm.\\n\\n\\n# Code:\\n```\\n    int xorValue = start ^ goal;\\n    int minFlip = 0;\\n\\n    while (xorValue != 0) {\\n      minFlip += 1;\\n      xorValue = (xorValue - 1) & xorValue;\\n    }\\n    return minFlip;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    String startBinary = String.format(\"%32s\", Integer.toBinaryString(start)).replaceAll(\" \", \"0\");\\n    String goalBinary = String.format(\"%32s\", Integer.toBinaryString(goal)).replaceAll(\" \", \"0\");\\n\\n    int minFlip = 0;\\n    int pointer = 0;\\n    while (pointer < startBinary.length()) {\\n      if (startBinary.charAt(pointer) != goalBinary.charAt(pointer)) {\\n        minFlip += 1;\\n      }\\n      pointer += 1;\\n    }\\n    return minFlip;\\n```\n```\\n    int xorValue = start ^ goal;\\n    int minFlip = 0;\\n\\n    while (xorValue != 0) {\\n      minFlip += 1;\\n      xorValue = (xorValue - 1) & xorValue;\\n    }\\n    return minFlip;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3204972,
                "title": "bit-manupulation-basic-implementation-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n       vector<int>v1,v2;\\n//taking out bit form of both goal and start numbers\\n       while(start!=0||goal!=0){\\n//pushing last bit in vector by taking and with the num\\n           v1.push_back(start&1);\\n           v2.push_back(goal&1);\\n           start=start>>1;\\n           goal=goal>>1;\\n          \\n       }\\n//checking number of bits that are different and need to flip to make goal from start\\n       for(int i=0;i<v1.size();i++)\\n       {\\n           if(v1[i]!=v2[i])\\n           count++;\\n       }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n       vector<int>v1,v2;\\n//taking out bit form of both goal and start numbers\\n       while(start!=0||goal!=0){\\n//pushing last bit in vector by taking and with the num\\n           v1.push_back(start&1);\\n           v2.push_back(goal&1);\\n           start=start>>1;\\n           goal=goal>>1;\\n          \\n       }\\n//checking number of bits that are different and need to flip to make goal from start\\n       for(int i=0;i<v1.size();i++)\\n       {\\n           if(v1[i]!=v2[i])\\n           count++;\\n       }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991304,
                "title": "xor-count-the-set-bits",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int val = start^goal;\\n        int res=0;\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            if(val & 1<<i)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int val = start^goal;\\n        int res=0;\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            if(val & 1<<i)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759108,
                "title": "c-one-liner-code-faster-than-100",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start ^ goal); \\n    }      \\n};         \\n\\n\\n\\n\\n\\n***if helpful please upvote***\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start ^ goal); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2722569,
                "title": "java-one-liner-faster-than-100",
                "content": "The trick here is to perform xor (^) operation between the goal and the start, as it will get set bits for the places where bits of start and goal are different. For example,\\n\\t\\t\\tgoal = 00000100110110\\n\\t\\t\\tstart = 01001001100010\\nxor = 01001101010100\\nNow these set bits in xor result are the minimum bits that need to be flipped in order to convert start to goal. So, we count the number of set bits in xor using Integer.bitCount(x) in Java.\\n```\\n\\tpublic int minBitFlips(int start, int goal) {\\n\\t\\t\\treturn Integer.bitCount(start ^ goal);\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\tpublic int minBitFlips(int start, int goal) {\\n\\t\\t\\treturn Integer.bitCount(start ^ goal);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2720229,
                "title": "swift-start-goal-nonzerobitcount",
                "content": "```\\nclass Solution {\\n    func minBitFlips(_ start: Int, _ goal: Int) -> Int {\\n        (start ^ goal).nonzeroBitCount\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minBitFlips(_ start: Int, _ goal: Int) -> Int {\\n        (start ^ goal).nonzeroBitCount\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606608,
                "title": "easy-code-with-explanation",
                "content": "class Solution {\\npublic:\\n\\n    int minBitFlips(int start, int goal) {\\n        //the number of min bits will be total number of diff bits and we can count it by right shifting and comapre the 0th bit\\n        int ans=0;\\n        while(start!=0||goal!=0)\\n        {\\n            if((start&1)!=(goal&1))//0th bit different\\n                ans++;\\n            start=start>>1;\\n            goal=goal>>1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minBitFlips(int start, int goal) {\\n        //the number of min bits will be total number of diff bits and we can count it by right shifting and comapre the 0th bit\\n        int ans=0;\\n        while(start!=0||goal!=0)\\n        {\\n            if((start&1)!=(goal&1))//0th bit different\\n                ans++;\\n            start=start>>1;\\n            goal=goal>>1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2582111,
                "title": "simple-easy-and-clean-c-solution-using-bit-manipulation-xor-and",
                "content": "Store  **Bitwise XOR** operation between start and goal into an **integer named x**.\\n\\nThis helps us to count the number of the number of set bits in x that describes how many bits are need to be changed in start to convert it into goal.\\n\\n**Below steps count the number of set bits in x.**\\n\\n**Following steps are followed to solve the problem -:**\\n\\n1. Take a counter  **count** to count the number of 1\\'s in binary representation of the number.\\n2. Now use a while loop until the number becomes zero.\\n3. Perform **bitwise &** operation of **x** with **1**. If bit is 1 that means 1 is present in the representation and increase the count variable by 1.\\n4. Now shift the bit of x by 1 by doing a right shift **x>>1** so as to perform bitwise & operation on each bit of x .\\n5. Exit the while loop and **return the count** i.e number of 1 bits in the number.\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minBitFlips(int start, int goal) \\n\\t\\t\\t{\\n\\t\\t\\t\\tint x=start^goal;\\n\\t\\t\\t\\tint c=0;\\n\\t\\t\\t\\twhile(x)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(x&1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tx=x>>1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn c;  \\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minBitFlips(int start, int goal) \\n\\t\\t\\t{\\n\\t\\t\\t\\tint x=start^goal;\\n\\t\\t\\t\\tint c=0;\\n\\t\\t\\t\\twhile(x)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(x&1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2567972,
                "title": "runtime-0-ms-faster-than-100-00-submissions",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int minBitFlips(int start, int goal) {\\n        int n=start^goal;\\n        int cnt=0;\\n        for(int i=0;i<32;i++) {\\n            if(((n>>i)&1)==1) cnt++;\\n        } return cnt;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int minBitFlips(int start, int goal) {\\n        int n=start^goal;\\n        int cnt=0;\\n        for(int i=0;i<32;i++) {\\n            if(((n>>i)&1)==1) cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2509277,
                "title": "c-o-32-time-100-faster-easy-understanding",
                "content": "```\\nhere we are just checking the ith bit of each is same or not, if not same then operations increases\\nclass Solution {\\npublic:\\n    int minBitFlips(int s, int g) {\\n        int cnt=0;\\n        for(int i=0;i<32;i++){\\n            int j=(g>>i)&1, k=(s>>i)&1;\\n            if(j!=k){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nhere we are just checking the ith bit of each is same or not, if not same then operations increases\\nclass Solution {\\npublic:\\n    int minBitFlips(int s, int g) {\\n        int cnt=0;\\n        for(int i=0;i<32;i++){\\n            int j=(g>>i)&1, k=(s>>i)&1;\\n            if(j!=k){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488977,
                "title": "java-0ms-100-faster-using-bit-manipulation-using-xor-3-liner-solution",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        for(int i=0;i<31;i++) if(((start&(1<<i))^(goal&(1<<i))) == (1<<i)) ans++;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        for(int i=0;i<31;i++) if(((start&(1<<i))^(goal&(1<<i))) == (1<<i)) ans++;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477246,
                "title": "go-simple-solution-0ms",
                "content": "```go\\nfunc minBitFlips(start, goal int) int {\\n    // User XOR(^) for finding different bits\\n    // then count result bits\\n\\treturn bits.OnesCount32(uint32(start ^ goal))\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minBitFlips(start, goal int) int {\\n    // User XOR(^) for finding different bits\\n    // then count result bits\\n\\treturn bits.OnesCount32(uint32(start ^ goal))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2462345,
                "title": "java-solution-3ms-runtime-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        String b_start = Integer.toBinaryString(start);\\n        String b_goal = Integer.toBinaryString(goal);\\n        int sb = b_start.length(), gb = b_goal.length();\\n        if (sb > gb) {\\n            int l = sb - gb;\\n            String z = \"\";\\n            for (int i = 0; i < l; i++) {\\n                z += \"0\";\\n            }\\n            b_goal = (z + b_goal);\\n\\n            for (int i = 0; i < sb; i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        else if (sb < gb) {\\n            int l = gb - sb;\\n            String z = \"\";\\n            for (int i = 0; i < l; i++) {\\n                z += \"0\";\\n            }\\n            b_start = (z + b_start);\\n\\n            for (int i = 0; i < gb; i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < b_start.length(); i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        String b_start = Integer.toBinaryString(start);\\n        String b_goal = Integer.toBinaryString(goal);\\n        int sb = b_start.length(), gb = b_goal.length();\\n        if (sb > gb) {\\n            int l = sb - gb;\\n            String z = \"\";\\n            for (int i = 0; i < l; i++) {\\n                z += \"0\";\\n            }\\n            b_goal = (z + b_goal);\\n\\n            for (int i = 0; i < sb; i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        else if (sb < gb) {\\n            int l = gb - sb;\\n            String z = \"\";\\n            for (int i = 0; i < l; i++) {\\n                z += \"0\";\\n            }\\n            b_start = (z + b_start);\\n\\n            for (int i = 0; i < gb; i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < b_start.length(); i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461657,
                "title": "c-easy-solution-xor-count-set-bits",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    int countSetBits(int n){\\n        if (n == 0)\\n            return 0;\\n        else\\n            return 1 + countSetBits(n & (n - 1));\\n    }\\n    \\n    int minBitFlips(int start, int goal) {\\n        return countSetBits(start^goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSetBits(int n){\\n        if (n == 0)\\n            return 0;\\n        else\\n            return 1 + countSetBits(n & (n - 1));\\n    }\\n    \\n    int minBitFlips(int start, int goal) {\\n        return countSetBits(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447924,
                "title": "simple-java-solution-beats-100-bit-manipulation",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start!=0 || goal!=0){\\n            count += ((start & 1)^(goal & 1));\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start!=0 || goal!=0){\\n            count += ((start & 1)^(goal & 1));\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439587,
                "title": "unique-morse-code-words",
                "content": "\\n        vector<string> s= {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        char c=97;\\n        unordered_map<char,string> m;\\n       for(auto &i:s)\\n      {\\n           m[c]=i;\\n           c++;\\n       }\\n        set<string> st;\\n        for(int i=0;i<words.size();i++){\\n            string str=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                str+=m[words[i][j]];\\n                \\n            }\\n            st.insert(str);\\n        }\\n        return st.size();\\n",
                "solutionTags": [
                    "String",
                    "Ordered Set"
                ],
                "code": "\\n        vector<string> s= {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        char c=97;\\n        unordered_map<char,string> m;\\n       for(auto &i:s)\\n      {\\n           m[c]=i;\\n           c++;\\n       }\\n        set<string> st;\\n        for(int i=0;i<words.size();i++){\\n            string str=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                str+=m[words[i][j]];\\n                \\n            }\\n            st.insert(str);\\n        }\\n        return st.size();\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2399127,
                "title": "python-xor",
                "content": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        count = 0\\n        xor = start ^ goal\\n        while xor:\\n            count += 1\\n            xor &= xor - 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        count = 0\\n        xor = start ^ goal\\n        while xor:\\n            count += 1\\n            xor &= xor - 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333422,
                "title": "easy-faster-than-100-java-solution",
                "content": "class Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n       int num = start^goal;\\n        while(num!=0){\\n            if((num&1)==1){\\n                cnt++;\\n                num=num>>1;\\n            }else{\\n                num=num>>1;\\n            }\\n        }\\n        return cnt;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n       int num = start^goal;\\n        while(num!=0){\\n            if((num&1)==1){\\n                cnt++;\\n                num=num>>1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2328636,
                "title": "easy-solution-python",
                "content": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return bin(start ^ goal).count(\\'1\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return bin(start ^ goal).count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295957,
                "title": "simple-and-intuitive-solution-in-python-with-comments",
                "content": "```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n\\tstart = bin(start)[:1:-1]   # get the binary representations of numbers\\n    goal = bin(goal)[:1:-1]     # in backwards order\\n        \\n    len_st = len(start)         # lengths of the binary strings\\n    len_go = len(goal)\\n        \\n    if len_st < len_go:         # we need to supplement the shorter binary with leading zeros\\n\\t\\tstart += \\'0\\' * (len_go - len_st)\\n\\telif len_go < len_st:\\n\\t\\tgoal += \\'0\\' * (len_st - len_go)\\n        \\n\\tflips = sum([start[i] != goal[i] for i in range(len(start))])  # count the number of unequal bits at every i-th position\\n        \\n    return flips",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n\\tstart = bin(start)[:1:-1]   # get the binary representations of numbers\\n    goal = bin(goal)[:1:-1]     # in backwards order\\n        \\n    len_st = len(start)         # lengths of the binary strings\\n    len_go = len(goal)\\n        \\n    if len_st < len_go:         # we need to supplement the shorter binary with leading zeros\\n\\t\\tstart += \\'0\\' * (len_go - len_st)\\n\\telif len_go < len_st:\\n\\t\\tgoal += \\'0\\' * (len_st - len_go)\\n        \\n\\tflips = sum([start[i] != goal[i] for i in range(len(start))])  # count the number of unequal bits at every i-th position\\n        \\n    return flips",
                "codeTag": "Python3"
            },
            {
                "id": 2275840,
                "title": "easy-xor-method-solution-in-c",
                "content": "Xor will have bit\\'1\\' at positions where bits of both numbers are different and \\nwe need to flip only those bits which are different so number of bit\\'1\\' in xor \\nwill give us result;\\n```\\nclass Solution {\\npublic:\\n    int numberOfSetbits(int Xor){\\n        int count=0;\\n        while(Xor){\\n            if(Xor&1){\\n                count++;\\n            }\\n            \\n            Xor>>=1;\\n        }\\n        return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        \\n        int Xor=start^goal;\\n        return numberOfSetbits(Xor);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSetbits(int Xor){\\n        int count=0;\\n        while(Xor){\\n            if(Xor&1){\\n                count++;\\n            }\\n            \\n            Xor>>=1;\\n        }\\n        return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        \\n        int Xor=start^goal;\\n        return numberOfSetbits(Xor);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237452,
                "title": "using-xor-100-fast",
                "content": "```\\nint minBitFlips(int a, int b) {\\n         // Your logic here\\n        int XOR= a^b;\\n        int c=0;\\n        // 1010\\n        // 1000\\n        // xor\\n        // 0010 only to flip 1 & 0 at position 2 from left\\n        while(XOR){\\n            int bit=1;\\n            if(bit & XOR){\\n                c++;\\n            }\\n            XOR=XOR>>1;\\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minBitFlips(int a, int b) {\\n         // Your logic here\\n        int XOR= a^b;\\n        int c=0;\\n        // 1010\\n        // 1000\\n        // xor\\n        // 0010 only to flip 1 & 0 at position 2 from left\\n        while(XOR){\\n            int bit=1;\\n            if(bit & XOR){\\n                c++;\\n            }\\n            XOR=XOR>>1;\\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200461,
                "title": "java-simple-bitwise-solution",
                "content": "This is my simple somution via bitwise:\\n\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int flipCount = 0;\\n        \\n        while (start > 0 || goal > 0) {\\n            flipCount += ((start & 0x1) ^ (goal & 0x1));\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        \\n        return flipCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int flipCount = 0;\\n        \\n        while (start > 0 || goal > 0) {\\n            flipCount += ((start & 0x1) ^ (goal & 0x1));\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        \\n        return flipCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191453,
                "title": "c-0ms-faster-than-100-left-shift",
                "content": "\\n    int minBitFlips(int n, int g) {\\n     \\n        int count=0;\\n        unsigned int i=0;\\n        while(i!=31 && g!=n)\\n        {\\n            int flag=1<<i;\\n            int flag2=n&flag;\\n            int flag3=g&flag;\\n            if(flag2!=flag3)\\n            {\\n                count++;\\n                if(flag3==1)\\n                    n=n|flag3;\\n                else\\n                    n=n&(~flag2);\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    int minBitFlips(int n, int g) {\\n     \\n        int count=0;\\n        unsigned int i=0;\\n        while(i!=31 && g!=n)\\n        {\\n            int flag=1<<i;\\n            int flag2=n&flag;\\n            int flag3=g&flag;\\n            if(flag2!=flag3)\\n            {\\n                count++;\\n                if(flag3==1)\\n                    n=n|flag3;\\n                else\\n                    n=n&(~flag2);\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2185973,
                "title": "rust-faster-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_bit_flips(mut start: i32, mut goal: i32) -> i32 {\\n        let mut cnt = 0;\\n        // while start != goal {\\n        //     if start & 0x1 != goal & 0x1 {\\n        //         cnt += 1;\\n        //     }\\n        //     start >>= 1;\\n        //     goal >>= 1;\\n        // }\\n\\n        let mut n = start ^ goal;\\n        while n != 0 {\\n            n = n & (n - 1);\\n            cnt += 1;\\n        }\\n\\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_bit_flips(mut start: i32, mut goal: i32) -> i32 {\\n        let mut cnt = 0;\\n        // while start != goal {\\n        //     if start & 0x1 != goal & 0x1 {\\n        //         cnt += 1;\\n        //     }\\n        //     start >>= 1;\\n        //     goal >>= 1;\\n        // }\\n\\n        let mut n = start ^ goal;\\n        while n != 0 {\\n            n = n & (n - 1);\\n            cnt += 1;\\n        }\\n\\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2127699,
                "title": "c",
                "content": "```class Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int n=start^goal;\\n        unsigned int count = 0;\\n    while (n) {\\n        count += n & 1;\\n        n >>= 1;\\n    }\\n    return count;\\n    }\\n};```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```class Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int n=start^goal;\\n        unsigned int count = 0;\\n    while (n) {\\n        count += n & 1;\\n        n >>= 1;\\n    }\\n    return count;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2092213,
                "title": "python-1-line-xor-count-bits",
                "content": "```\\nclass Solution:\\n    def minBitFlips(self, start, goal):\\n        return (start^goal).bit_count()\\n```\\nexample:\\n10 : 1010\\n07 : 0111\\nxor: 1101 (3 bits == solution)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start, goal):\\n        return (start^goal).bit_count()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037974,
                "title": "swift-one-liner",
                "content": "Swift one-liner\\n```swift\\nclass Solution {\\n    func minBitFlips(_ start: Int, _ goal: Int) -> Int {\\n        (start ^ goal).nonzeroBitCount\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func minBitFlips(_ start: Int, _ goal: Int) -> Int {\\n        (start ^ goal).nonzeroBitCount\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028043,
                "title": "python3-easy-to-understand-solution",
                "content": "1. Initialise your return variable with 0.\\n2. Check if LSB of both are different. Increase your count.\\n3. Right shift both the numbers.\\n(Note - For while, we will take larger number as condition)\\n```\\nclass Solution:\\n    def count_flips(self, start, goal):\\n        count = 0\\n        while start != 0:\\n            if start & 1 != goal & 1:\\n                count += 1\\n            start >>= 1\\n            goal >>= 1\\n        return count\\n        \\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        if start > goal:\\n            return self.count_flips(start, goal)\\n        else:\\n            return self.count_flips(goal, start)\\n            \\n",
                "solutionTags": [],
                "code": "1. Initialise your return variable with 0.\\n2. Check if LSB of both are different. Increase your count.\\n3. Right shift both the numbers.\\n(Note - For while, we will take larger number as condition)\\n```\\nclass Solution:\\n    def count_flips(self, start, goal):\\n        count = 0\\n        while start != 0:\\n            if start & 1 != goal & 1:\\n                count += 1\\n            start >>= 1\\n            goal >>= 1\\n        return count\\n        \\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        if start > goal:\\n            return self.count_flips(start, goal)\\n        else:\\n            return self.count_flips(goal, start)\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2020000,
                "title": "fastest-java-1-line-solution-0-ms",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) \\n    {\\n       return Integer.bitCount(start^goal);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int minBitFlips(int start, int goal) \\n    {\\n       return Integer.bitCount(start^goal);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1949455,
                "title": "100-fast-bitmask-explained",
                "content": "class Solution {\\npublic:\\n\\t\\n\\t/*\\n\\t\\tYou have to check (for both the no. start and goal)that the ith bit is on of off if both are simultaneously on or off do nothing else increment ans\\n\\t\\tFor checking the ith bit is on or off make a bitmask and do the following logic:\\n\\t\\t\\t=>if n&mask==0 that means that bit was off\\n\\t\\t\\t=>otherwise that bit was on\\n\\t*/\\n\\t\\n\\n    int minBitFlips(int start, int goal) {\\n        int mask=1;\\n        int ans=0;\\n        while(mask<=max(goal,start)){\\n            int x1=(mask&start);\\n            int x2=(mask&goal);\\n            if(x1!=x2)ans++;\\n            mask=mask<<1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\t\\n\\t/*\\n\\t\\tYou have to check (for both the no. start and goal)that the ith bit is on of off if both are simultaneously on or off do nothing else increment ans\\n\\t\\tFor checking the ith bit is on or off make a bitmask and do the following logic:\\n\\t\\t\\t=>if n&mask==0 that means that bit was off\\n\\t\\t\\t=>otherwise that bit was on\\n\\t*/\\n\\t\\n\\n    int minBitFlips(int start, int goal) {\\n        int mask=1;\\n        int ans=0;\\n        while(mask<=max(goal,start)){\\n            int x1=(mask&start);\\n            int x2=(mask&goal);\\n            if(x1!=x2)ans++;\\n            mask=mask<<1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1926597,
                "title": "clear-c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count{0};\\n        \\n        while(start || goal){\\n            count += (start & 1) != (goal & 1);\\n            \\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        \\n        return count;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count{0};\\n        \\n        while(start || goal){\\n            count += (start & 1) != (goal & 1);\\n            \\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        \\n        return count;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915306,
                "title": "python-3-o-n-time-easy-solution",
                "content": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        def get( i):\\n            s=\"\"\\n            while i!=0:\\n                s+=\"0\"\\n                i-=1\\n            return s\\n        s=bin(start).replace(\"0b\",\\'\\')\\n        g=bin(goal).replace(\\'0b\\',\\'\\')\\n        if len(s)<len(g):\\n            s=get(len(g)-len(s))+s\\n        \\n        if len(g)<len(s):\\n            g=get(len(s)-len(g))+g\\n        c=0\\n        for i in range(len(s)):\\n            if s[i]!=g[i]:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        def get( i):\\n            s=\"\"\\n            while i!=0:\\n                s+=\"0\"\\n                i-=1\\n            return s\\n        s=bin(start).replace(\"0b\",\\'\\')\\n        g=bin(goal).replace(\\'0b\\',\\'\\')\\n        if len(s)<len(g):\\n            s=get(len(g)-len(s))+s\\n        \\n        if len(g)<len(s):\\n            g=get(len(s)-len(g))+g\\n        c=0\\n        for i in range(len(s)):\\n            if s[i]!=g[i]:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915196,
                "title": "minimum-bit-flips-to-convert-number-easy-learned-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int flipped = start ^ goal;\\n        \\n        int count = 0;\\n        while(flipped != 0) {\\n            int rsb = (flipped & -flipped);\\n            flipped -= rsb;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\nIf you understood the problem, kindly **UpVote**.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int flipped = start ^ goal;\\n        \\n        int count = 0;\\n        while(flipped != 0) {\\n            int rsb = (flipped & -flipped);\\n            flipped -= rsb;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915104,
                "title": "kotlin-solution-xor-then-count-set-bit",
                "content": "```\\nclass Solution {\\n    fun minBitFlips(start: Int, goal: Int): Int {\\n       var result = start xor goal\\n        var answer = 0\\n        while (result > 0) {\\n            if (result % 2 == 1) {\\n                answer++\\n            }\\n            result /= 2\\n        }\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minBitFlips(start: Int, goal: Int): Int {\\n       var result = start xor goal\\n        var answer = 0\\n        while (result > 0) {\\n            if (result % 2 == 1) {\\n                answer++\\n            }\\n            result /= 2\\n        }\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910452,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 : Brute Force***\\n\\n* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nint minBitFlips(int start, int goal) {\\n        \\n        vector<int> arr1;\\n        \\n        vector<int> arr2;\\n        \\n        while(start)\\n        {\\n            int r = (start & 1);\\n            \\n            arr1.push_back(r);\\n            \\n            start = start >> 1;\\n        }\\n        \\n        while(goal)\\n        {\\n            int r = (goal & 1);\\n            \\n            arr2.push_back(r);\\n            \\n            goal = goal >> 1;\\n        }\\n        \\n        int i = 0;\\n        \\n        int j = 0;\\n        \\n        int count = 0;\\n        \\n        while(i < arr1.size() && j < arr2.size())\\n        {\\n            if(arr1[i] != arr2[j])\\n            {\\n                count++;\\n            }\\n            \\n            i++;\\n            \\n            j++;\\n        }\\n        \\n        if(i < arr1.size())\\n        {\\n            int count_1 = 0;\\n            \\n            while(i < arr1.size())\\n            {\\n                if(arr1[i] == 1)\\n                {\\n                    count_1++;\\n                }\\n                \\n                i++;\\n            }\\n            \\n            count += count_1;\\n        }\\n        \\n        if(j < arr2.size())\\n        {\\n            int count_1 = 0;\\n            \\n            while(j < arr2.size())\\n            {\\n                if(arr2[j] == 1)\\n                {\\n                    count_1++;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            count += count_1;\\n        }\\n        \\n        return count;\\n    }\\n```\\n\\n* ***Approach 2 : Optimized***\\n\\n* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(1)***\\n\\n```\\nint minBitFlips(int start, int goal) {\\n        \\n        int count = 0;\\n        \\n        while(start || goal)\\n        {\\n            int x1 = (start & 1);\\n            \\n            int x2 = (goal & 1);\\n            \\n            if(x1 != x2)\\n            {\\n                count++;\\n            }\\n            \\n            start = start >> 1;\\n            \\n            goal = goal >> 1;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint minBitFlips(int start, int goal) {\\n        \\n        vector<int> arr1;\\n        \\n        vector<int> arr2;\\n        \\n        while(start)\\n        {\\n            int r = (start & 1);\\n            \\n            arr1.push_back(r);\\n            \\n            start = start >> 1;\\n        }\\n        \\n        while(goal)\\n        {\\n            int r = (goal & 1);\\n            \\n            arr2.push_back(r);\\n            \\n            goal = goal >> 1;\\n        }\\n        \\n        int i = 0;\\n        \\n        int j = 0;\\n        \\n        int count = 0;\\n        \\n        while(i < arr1.size() && j < arr2.size())\\n        {\\n            if(arr1[i] != arr2[j])\\n            {\\n                count++;\\n            }\\n            \\n            i++;\\n            \\n            j++;\\n        }\\n        \\n        if(i < arr1.size())\\n        {\\n            int count_1 = 0;\\n            \\n            while(i < arr1.size())\\n            {\\n                if(arr1[i] == 1)\\n                {\\n                    count_1++;\\n                }\\n                \\n                i++;\\n            }\\n            \\n            count += count_1;\\n        }\\n        \\n        if(j < arr2.size())\\n        {\\n            int count_1 = 0;\\n            \\n            while(j < arr2.size())\\n            {\\n                if(arr2[j] == 1)\\n                {\\n                    count_1++;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            count += count_1;\\n        }\\n        \\n        return count;\\n    }\\n```\n```\\nint minBitFlips(int start, int goal) {\\n        \\n        int count = 0;\\n        \\n        while(start || goal)\\n        {\\n            int x1 = (start & 1);\\n            \\n            int x2 = (goal & 1);\\n            \\n            if(x1 != x2)\\n            {\\n                count++;\\n            }\\n            \\n            start = start >> 1;\\n            \\n            goal = goal >> 1;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910193,
                "title": "java-one-liner",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909717,
                "title": "one-liner-python-c-using-xor",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        return __builtin_popcount(start^goal);\\n        \\n    }\\n};\\n```\\n**Python**\\n```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        return (start ^ goal).bit_count()\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        return __builtin_popcount(start^goal);\\n        \\n    }\\n};\\n```\n```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        return (start ^ goal).bit_count()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908989,
                "title": "simple-solution-using-xor-in-o-n",
                "content": "doing XOR and finding number on Ones in binary conversion of resultant\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> convert(int num){\\n       vector<int>ans;\\n        while(num>0){\\n           int c=(num%2);\\n            num/=2;\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n\\n    int minBitFlips(int start, int goal) {\\n        int x=start^goal;\\n        vector<int> ans=convert(x);\\n        int f=0;\\n        int n=ans.size();\\n        for(int i=0;i<n;i++){\\n            if(ans[i]==1)\\n                f++;\\n        }\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> convert(int num){\\n       vector<int>ans;\\n        while(num>0){\\n           int c=(num%2);\\n            num/=2;\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n\\n    int minBitFlips(int start, int goal) {\\n        int x=start^goal;\\n        vector<int> ans=convert(x);\\n        int f=0;\\n        int n=ans.size();\\n        for(int i=0;i<n;i++){\\n            if(ans[i]==1)\\n                f++;\\n        }\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908081,
                "title": "simple-java-intuitive-bit-manipulation-ttt",
                "content": "Lets take 10 and 7 as an example:\\nBinary rep of 10: 1010\\nBinary rep of 7 :   0111\\nIt is clear that if we are able to count the number of mis-matches OR the number of different bits, we can conclude the number of flips needed,\\n\\n**No of Flips = No of mis-matched btis in binary representation**\\n\\nThe easiest way to find mismatched bits is excecuting a XOR opeartion om start and goal, as in XOR the mis-matched bits generate 1. Hence, we can then count the number of 1s in the XOR result and find the number of flips needed.\\n\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n\\t//start = 10 (1010)\\n\\t//goal = 7    (0111)\\n\\t// start ^ goal = (1101) --> as there are 3 mis matched bits bw 10 and 7 \\n\\t//  we can easilt count no of 1s in the XOR result using th following snippet \\n        int res = start ^ goal;\\n        int count = 0;\\n        while( res > 0){\\n            if( (res & 1) % 2 == 1)count++;\\n            res = res >> 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n\\t//start = 10 (1010)\\n\\t//goal = 7    (0111)\\n\\t// start ^ goal = (1101) --> as there are 3 mis matched bits bw 10 and 7 \\n\\t//  we can easilt count no of 1s in the XOR result using th following snippet \\n        int res = start ^ goal;\\n        int count = 0;\\n        while( res > 0){\\n            if( (res & 1) % 2 == 1)count++;\\n            res = res >> 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907541,
                "title": "c-simple-easy-code-bit",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int flips = 0;\\n \\n      while(a > 0 || b > 0){\\n\\n        int t1 = (a&1);\\n        int t2 = (b&1);\\n\\n        if(t1!=t2){flips++;}\\n        a>>=1;\\n        b>>=1;\\n      }\\n\\n      return flips;\\n    }\\n};\\n```\\nDo upvote if it helped :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int flips = 0;\\n \\n      while(a > 0 || b > 0){\\n\\n        int t1 = (a&1);\\n        int t2 = (b&1);\\n\\n        if(t1!=t2){flips++;}\\n        a>>=1;\\n        b>>=1;\\n      }\\n\\n      return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907475,
                "title": "simple-explanation-c-0-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n\\t\\n\\t\\t//to take xor so that we can get all position where start and goal differ\\n        int temp = start ^ goal;    \\n        int cnt = 0;\\n\\t\\t\\n\\t\\t//count the set bits which will give the position where they differ and count them\\n        while(temp){ \\n            cnt += temp & 1;\\n            temp >>= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n\\t\\n\\t\\t//to take xor so that we can get all position where start and goal differ\\n        int temp = start ^ goal;    \\n        int cnt = 0;\\n\\t\\t\\n\\t\\t//count the set bits which will give the position where they differ and count them\\n        while(temp){ \\n            cnt += temp & 1;\\n            temp >>= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907289,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        return bin(start^goal).count(\"1\")\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        return bin(start^goal).count(\"1\")\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907192,
                "title": "bitset-stl-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n         bitset<32> num1(start);\\n         bitset<32> num2(goal);\\n        \\n         int n = num1.size();\\n        \\n        int counter = 0;\\n        for(int i = n-1;i>=0;i--){\\n            if(num1[i] != num2[i])\\n                counter++;\\n        }\\n        \\n        \\n        return counter;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n         bitset<32> num1(start);\\n         bitset<32> num2(goal);\\n        \\n         int n = num1.size();\\n        \\n        int counter = 0;\\n        for(int i = n-1;i>=0;i--){\\n            if(num1[i] != num2[i])\\n                counter++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1907158,
                "title": "c-easy-to-understand-commented",
                "content": "**Idea**\\n1. Convert decimal to its binary equivalent and then just compare both if they are differnt i.e if first is 0 and 2nd is 1 we need to flip.\\n2. for example 1010 and 0110, three bits differ so answer is 3\\n```\\nclass Solution {\\npublic:\\n    \\n    int minBitFlips(int start, int goal) {\\n        int flips = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int k = start >> i;\\n            int l = goal >> i;\\n            int m = k&1; //Check the bit of start\\n            int n = l&1; // Check the bit of target\\n            if (m != n) //If different\\n                flips++; //flip is required\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minBitFlips(int start, int goal) {\\n        int flips = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int k = start >> i;\\n            int l = goal >> i;\\n            int m = k&1; //Check the bit of start\\n            int n = l&1; // Check the bit of target\\n            if (m != n) //If different\\n                flips++; //flip is required\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907126,
                "title": "python-straightforward",
                "content": "```python\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        total = 0\\n\\n        for a, b in zip(bin(start)[2:].rjust(32, \\'0\\'), bin(goal)[2:].rjust(32, \\'0\\')):\\n            if a != b:\\n                total += 1\\n\\n        return total\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        total = 0\\n\\n        for a, b in zip(bin(start)[2:].rjust(32, \\'0\\'), bin(goal)[2:].rjust(32, \\'0\\')):\\n            if a != b:\\n                total += 1\\n\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907063,
                "title": "c-easy-solution-one-liner",
                "content": "```\\nThe logic is find the total number of set bits in xor of start no. and goal .\\nResult = set-bits( start ^ goal )\\n```\\n```\\nclass Solution {\\npublic:\\n    int countsetbits(int n){\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);    // Remove last set bit\\n    }\\n    return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        int c= countsetbits(start^goal);\\n        return c;\\n    }\\n};\\n```\\n```\\nOne liner:\\n\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);    //predefined method to find set bits in binary of a no.\\n    }\\n};\\n```\\nIf you like it, please upvote !!\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nThe logic is find the total number of set bits in xor of start no. and goal .\\nResult = set-bits( start ^ goal )\\n```\n```\\nclass Solution {\\npublic:\\n    int countsetbits(int n){\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);    // Remove last set bit\\n    }\\n    return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        int c= countsetbits(start^goal);\\n        return c;\\n    }\\n};\\n```\n```\\nOne liner:\\n\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);    //predefined method to find set bits in binary of a no.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907056,
                "title": "easy-understand",
                "content": "class Solution {\\npublic:\\n    int countSetBits(int n)\\n{\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);\\n    }\\n    return count;\\n}\\n    int minBitFlips(int a, int b) {\\n        return countSetBits(a^b);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countSetBits(int n)\\n{\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1906988,
                "title": "compare-bits-of-numbers-simply",
                "content": "```\\n    int minBitFlips(int start, int goal) {\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<32;i++){\\n            bool bit1=(start&(1<<i));\\n            bool bit2=(goal&(1<<i));\\n            \\n            if(bit1!=bit2){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n    int minBitFlips(int start, int goal) {\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<32;i++){\\n            bool bit1=(start&(1<<i));\\n            bool bit2=(goal&(1<<i));\\n            \\n            if(bit1!=bit2){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1906978,
                "title": "java-using-xor",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int x = start^goal;\\n        int c = 0;\\n        while(x>0){\\n            if((x&1)==1) c++;\\n            x = x>>1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int x = start^goal;\\n        int c = 0;\\n        while(x>0){\\n            if((x&1)==1) c++;\\n            x = x>>1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906977,
                "title": "c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int bit=0;\\n        int flip=0;\\n        while(bit<32){\\n            if((start&(1<<bit))!=((goal)&(1<<bit))){\\n                flip++;\\n            }\\n            bit++;\\n        }\\n        return flip;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int bit=0;\\n        int flip=0;\\n        while(bit<32){\\n            if((start&(1<<bit))!=((goal)&(1<<bit))){\\n                flip++;\\n            }\\n            bit++;\\n        }\\n        return flip;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906968,
                "title": "java-simple-solution-xor",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int new_num = start ^ goal,count = 0;\\n        while(new_num != 0){\\n            count += (1 & new_num);\\n            new_num = new_num >> 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int new_num = start ^ goal,count = 0;\\n        while(new_num != 0){\\n            count += (1 & new_num);\\n            new_num = new_num >> 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089068,
                "title": "c-code-easy-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        //initializing temp with start\\n        int temp=start,count = 0;\\n        //loop will end when the temp == goal\\n        for(int i = 0 ; temp != goal ; i++){\\n            int bit1 = ((temp >> i) & 1 ); // gets ith bit of temp\\n            int bit2 = ((goal >> i) & 1); // gets ith bit of goal\\n\\n            if(bit1 != bit2){ //if not equal increment count\\n                count++;\\n                temp = temp ^ (1 << i); //flip the ith bit\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\nxor operation result is 1 if corresponding bits are not equal so we can perform xor of start and goal and count the number of 1\\'s \\n# code\\n```\\n        int count = 0;\\n        int ans = start ^ goal;\\n        while(ans){\\n            ans = ans & (ans -1);\\n            count++;\\n        }\\n        return count;",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        //initializing temp with start\\n        int temp=start,count = 0;\\n        //loop will end when the temp == goal\\n        for(int i = 0 ; temp != goal ; i++){\\n            int bit1 = ((temp >> i) & 1 ); // gets ith bit of temp\\n            int bit2 = ((goal >> i) & 1); // gets ith bit of goal\\n\\n            if(bit1 != bit2){ //if not equal increment count\\n                count++;\\n                temp = temp ^ (1 << i); //flip the ith bit\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088696,
                "title": "beats100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        for(int i=0;i<31;++i){\\n            if((start&1) != (goal&1)) ++count;\\n            start >>=1;\\n            goal >>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        for(int i=0;i<31;++i){\\n            if((start&1) != (goal&1)) ++count;\\n            start >>=1;\\n            goal >>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088446,
                "title": "bit-flip-bit-compare-by-binary-conversion-of-digits",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n\\n    int BitFlip;\\n    int CountDiff;\\n    List<int> StartBit = new List<int>();\\n    List<int> GoalBit = new List<int>();\\n\\n    public int MinBitFlips(int start, int goal) {\\n        \\n        DigitToBinary(start,StartBit);\\n        DigitToBinary(goal,GoalBit);\\n\\nif(StartBit.Count > GoalBit.Count)\\n{\\n    CountDiff = StartBit.Count - GoalBit.Count;\\n\\n    for(int i = 1; i <= CountDiff; i++)\\n    {\\n        GoalBit.Add(0);\\n    }\\n}\\nelse if(StartBit.Count < GoalBit.Count)\\n{\\n    CountDiff = GoalBit.Count - StartBit.Count;\\n\\n    for (int i = 1; i <= CountDiff; i++)\\n    {\\n        StartBit.Add(0);\\n    }\\n}\\n\\nStartBit.Reverse();\\nGoalBit.Reverse();\\n\\nfor(int i = 0; i < GoalBit.Count; i++)\\n{\\n    if (GoalBit[i] != StartBit[i])\\n    {\\n        BitFlip++;\\n    }\\n}\\n\\n         return BitFlip;\\n}\\n\\npublic void DigitToBinary(int digit, List<int> bits)\\n{\\n\\n    if(digit == 0)\\n    {\\n        bits.Add(0);\\n    }\\n    else\\n    {\\n        while(digit > 0)\\n        {\\n            if(digit %2  == 0)\\n            {\\n                bits.Add(0);\\n                digit = digit /2;\\n            }\\n            else if(digit == 1)\\n            {\\n                bits.Add(1);\\n                digit = digit / 2;\\n            }\\n            else\\n            {\\n                bits.Add(1);\\n                digit = digit / 2;\\n            }\\n\\n        }\\n    }\\n\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    int BitFlip;\\n    int CountDiff;\\n    List<int> StartBit = new List<int>();\\n    List<int> GoalBit = new List<int>();\\n\\n    public int MinBitFlips(int start, int goal) {\\n        \\n        DigitToBinary(start,StartBit);\\n        DigitToBinary(goal,GoalBit);\\n\\nif(StartBit.Count > GoalBit.Count)\\n{\\n    CountDiff = StartBit.Count - GoalBit.Count;\\n\\n    for(int i = 1; i <= CountDiff; i++)\\n    {\\n        GoalBit.Add(0);\\n    }\\n}\\nelse if(StartBit.Count < GoalBit.Count)\\n{\\n    CountDiff = GoalBit.Count - StartBit.Count;\\n\\n    for (int i = 1; i <= CountDiff; i++)\\n    {\\n        StartBit.Add(0);\\n    }\\n}\\n\\nStartBit.Reverse();\\nGoalBit.Reverse();\\n\\nfor(int i = 0; i < GoalBit.Count; i++)\\n{\\n    if (GoalBit[i] != StartBit[i])\\n    {\\n        BitFlip++;\\n    }\\n}\\n\\n         return BitFlip;\\n}\\n\\npublic void DigitToBinary(int digit, List<int> bits)\\n{\\n\\n    if(digit == 0)\\n    {\\n        bits.Add(0);\\n    }\\n    else\\n    {\\n        while(digit > 0)\\n        {\\n            if(digit %2  == 0)\\n            {\\n                bits.Add(0);\\n                digit = digit /2;\\n            }\\n            else if(digit == 1)\\n            {\\n                bits.Add(1);\\n                digit = digit / 2;\\n            }\\n            else\\n            {\\n                bits.Add(1);\\n                digit = digit / 2;\\n            }\\n\\n        }\\n    }\\n\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083167,
                "title": "java-solution",
                "content": "Initialize a variable count to 0. This variable will be used to keep track of the number of bit differences between start and goal.\\n\\nEnter a while loop that continues as long as either start or goal has bits remaining to be processed (i.e., greater than 0).\\n\\nInside the loop:\\n\\nstart & 1 and goal & 1 are used to extract the least significant bit (LSB) of start and goal, respectively. This is done by performing a bitwise AND operation with 1, which effectively checks if the rightmost bit is set (equal to 1).\\n((start & 1) ^ (goal & 1)) checks if the LSBs of start and goal are different. If they are different (i.e., XOR operation results in 1), it means that a bit flip is needed to make them the same.\\nIf the LSBs are different (i.e., the XOR operation results in 1), increment the count variable by 1. This means that a bit flip is required for this position.\\n\\nRight-shift both start and goal by 1 bit. This effectively moves to the next bit position, preparing to compare the next pair of bits in the binary representation.\\n\\nRepeat steps 3-5 until both start and goal have been completely processed (i.e., they become 0).\\n\\nAfter processing all bits, the count variable will contain the total number of bit differences (i.e., the number of bits that need to be flipped) between the original start and goal values.\\n\\nReturn the count value as the result, indicating how many bit flips are required to transform start into goal.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        // String num1 = String.format(\"%32s\", Integer.toBinaryString(start)).replaceAll(\" \", \"0\");\\n        // String num2 = String.format(\"%32s\", Integer.toBinaryString(goal)).replaceAll(\" \", \"0\");\\n        // int count = 0;\\n        // for(int i = 0; i < num1.length(); i++){\\n        //     if(num1.charAt(i) != num2.charAt(i))\\n        //         count++;\\n        // }\\n        // return count;\\n\\n        int count = 0;\\n        while(start > 0 || goal > 0){\\n            if(((start & 1)^(goal & 1)) == 1)\\n                count++;\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        // String num1 = String.format(\"%32s\", Integer.toBinaryString(start)).replaceAll(\" \", \"0\");\\n        // String num2 = String.format(\"%32s\", Integer.toBinaryString(goal)).replaceAll(\" \", \"0\");\\n        // int count = 0;\\n        // for(int i = 0; i < num1.length(); i++){\\n        //     if(num1.charAt(i) != num2.charAt(i))\\n        //         count++;\\n        // }\\n        // return count;\\n\\n        int count = 0;\\n        while(start > 0 || goal > 0){\\n            if(((start & 1)^(goal & 1)) == 1)\\n                count++;\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076840,
                "title": "easy-solution-tc-o-1-sc-o-1-bit-checks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is essentially asking for the minimum number of bit flips needed to convert one binary number (start) into another binary number (goal).\\n\\nTo find the minimum number of bit flips, we can compare the bits of both numbers from right to left (least significant bit to most significant bit).Whenever we encounter two bits that are different, we increment a counter to keep track of the number of bit flips required.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize a variable c to 0 to count the number of bit flips.\\n\\nIterate through the bits of start and goal from the rightmost bit (least significant bit) to the leftmost bit (most significant bit).\\n\\nFor each bit position i, check if the i-th bit of start is different from the i-th bit of goal. If they are different, increment the c counter.\\n\\nContinue this process for all bits.\\n\\nFinally, return the value of c as the minimum number of bit flips required to convert start to goal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe correct time complexity of the given algorithm is O(32) or simply O(1). This is because we are dealing with 32 bits in a 32-bit integer, which is a constant number of bits. Therefore, the time complexity remains constant and does not depend on the actual values of start and goal.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) as we only use a constant amount of space to store the counter c.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int c=0;\\n        for(int i=0;i<32;i++){\\n            if(( (start & (1<<i)) ? 1:0) != ((goal & (1<<i)) ? 1:0) ){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int c=0;\\n        for(int i=0;i<32;i++){\\n            if(( (start & (1<<i)) ? 1:0) != ((goal & (1<<i)) ? 1:0) ){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075248,
                "title": "best-begginner-level-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        String str1 = Integer.toBinaryString(start);\\n        String str2 = Integer.toBinaryString(goal);\\n\\n        int lengthDifference = Math.abs(str1.length() - str2.length());\\n\\n        StringBuilder result = new StringBuilder();\\n\\n        for (int i = 0; i < lengthDifference; i++) {\\n            result.append(\\'0\\');\\n        }\\n        String temp = \"\";\\n        if (str1.length() < str2.length()) {\\n            result.append(str1);\\n            temp = str2;\\n\\n        } else {\\n            result.append(str2);\\n            temp = str1;\\n        }\\n        String str = result.toString();\\n        int differences = 0;\\n        for (int i = str.length() - 1; i >= 0; i--) {\\n            if (str.charAt(i) != temp.charAt(i)) {\\n   \\n                differences++;\\n            }\\n        }\\n\\n        return differences;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        String str1 = Integer.toBinaryString(start);\\n        String str2 = Integer.toBinaryString(goal);\\n\\n        int lengthDifference = Math.abs(str1.length() - str2.length());\\n\\n        StringBuilder result = new StringBuilder();\\n\\n        for (int i = 0; i < lengthDifference; i++) {\\n            result.append(\\'0\\');\\n        }\\n        String temp = \"\";\\n        if (str1.length() < str2.length()) {\\n            result.append(str1);\\n            temp = str2;\\n\\n        } else {\\n            result.append(str2);\\n            temp = str1;\\n        }\\n        String str = result.toString();\\n        int differences = 0;\\n        for (int i = str.length() - 1; i >= 0; i--) {\\n            if (str.charAt(i) != temp.charAt(i)) {\\n   \\n                differences++;\\n            }\\n        }\\n\\n        return differences;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071595,
                "title": "100-faster",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        res = start ^ goal\\n        s = int(str(bin(res))[2:])\\n        \\n        cnt = 0\\n        while s != 0:\\n            d = s%10\\n            if d == 1:\\n                cnt += 1\\n            s = s//10\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        res = start ^ goal\\n        s = int(str(bin(res))[2:])\\n        \\n        cnt = 0\\n        while s != 0:\\n            d = s%10\\n            if d == 1:\\n                cnt += 1\\n            s = s//10\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065881,
                "title": "php",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $start\\n     * @param Integer $goal\\n     * @return Integer\\n     */\\n    function minBitFlips($start, $goal) {\\n        return substr_count(decbin($start ^ $goal), \\'1\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $start\\n     * @param Integer $goal\\n     * @return Integer\\n     */\\n    function minBitFlips($start, $goal) {\\n        return substr_count(decbin($start ^ $goal), \\'1\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059693,
                "title": "bit-manipulation-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nXOR start and Goal  and check  how many bits are set of that value\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int n= start^goal;\\n        int res=0;\\n\\n        while(n>0){\\n            n=n&(n-1);\\n            res++;\\n\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int n= start^goal;\\n        int res=0;\\n\\n        while(n>0){\\n            n=n&(n-1);\\n            res++;\\n\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059680,
                "title": "simple-c-solution-with-xor",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int result = 0;\\n        int n = start ^ goal;\\n\\n        while (n != 0) {\\n            result += n % 2;\\n            n /= 2;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int result = 0;\\n        int n = start ^ goal;\\n\\n        while (n != 0) {\\n            result += n % 2;\\n            n /= 2;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059300,
                "title": "c-1-line-code-using-builtin-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int target=start^goal;\\n\\n        return __builtin_popcount(target);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int target=start^goal;\\n\\n        return __builtin_popcount(target);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054921,
                "title": "easy-bit-manipulation-beats-100-o-log-n-beginner-friendly-solution",
                "content": "# Approach\\nUsing **Bit Manipulation**:\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate XOR of **start** and **goal**: **result** = start ^ goal.\\n2. **Count** the number of set bits in the **result**.\\n3. Return the **count**.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log(N));\\n    Where N is the result;\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int flips = 0;\\n        int num = start ^ goal;\\n        while(num){\\n            if(num & 1){\\n                flips++;\\n            }\\n            num = num>>1;\\n        }\\n\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int flips = 0;\\n        int num = start ^ goal;\\n        while(num){\\n            if(num & 1){\\n                flips++;\\n            }\\n            num = num>>1;\\n        }\\n\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052715,
                "title": "beats-100-0ms-1-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       return Integer.bitCount(start^goal);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       return Integer.bitCount(start^goal);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047657,
                "title": "java-string-oneliner-xor",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return (int) Integer.toBinaryString(start^goal).chars().filter(ch -> ch == \\'1\\').count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return (int) Integer.toBinaryString(start^goal).chars().filter(ch -> ch == \\'1\\').count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045442,
                "title": "very-easy-solution-beats-100-using-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink about XOR operator\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1 XOR the given numbers.\\n2 If the bits in resultant number is 1 then it needs to be flipped as XOR of diff bits is 1.\\n3 Count the signed bits .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n    int ans=start^goal;\\n      int c=0;\\n       \\n    while(ans)\\n    {\\n        if((ans & 1)==1)\\n        c++;\\n        ans>>=1;\\n\\n    }\\n    return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n    int ans=start^goal;\\n      int c=0;\\n       \\n    while(ans)\\n    {\\n        if((ans & 1)==1)\\n        c++;\\n        ans>>=1;\\n\\n    }\\n    return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040332,
                "title": "solution-better",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        int a = start ^ goal;\\n        while(a){\\n            count += a & 1;\\n            a >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        int a = start ^ goal;\\n        while(a){\\n            count += a & 1;\\n            a >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040257,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        while (start != 0 || goal != 0) {\\n            if ((start & 1) != (goal & 1)) {\\n                count++;\\n            }\\n            \\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        while (start != 0 || goal != 0) {\\n            if ((start & 1) != (goal & 1)) {\\n                count++;\\n            }\\n            \\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039791,
                "title": "100-one-line-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n      return __builtin_popcount(start^goal);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n      return __builtin_popcount(start^goal);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036219,
                "title": "0ms-beats-all-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBtiwise difference bitween two integers is simply XOR.\\nLater just have to count one\\'s in bit representation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhttps://en.wikipedia.org/wiki/Hamming_weight\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc minBitFlips(start int, goal int) int {\\n    x:= start^goal\\n    count:=0\\n    for ; x!=0; count++{\\n        x &= x - 1;\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```\\nfunc minBitFlips(start int, goal int) int {\\n    x:= start^goal\\n    count:=0\\n    for ; x!=0; count++{\\n        x &= x - 1;\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032571,
                "title": "optimised-bit-manipulation-approch",
                "content": "bi\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        //Intution Jo same hoga use nhi change karna hai\\n        //xor will give where they differ \\n        // count the difference \\n\\n        //difference means 1 if they would be same \\n        //xor will give 0\\n        int n = start^goal;\\n\\n        int flip = 0;\\n        while(n != 0){\\n            if((n&1) == 1){\\n                flip++;\\n            }\\n            n = n>>1;\\n        }\\n        return flip;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        //Intution Jo same hoga use nhi change karna hai\\n        //xor will give where they differ \\n        // count the difference \\n\\n        //difference means 1 if they would be same \\n        //xor will give 0\\n        int n = start^goal;\\n\\n        int flip = 0;\\n        while(n != 0){\\n            if((n&1) == 1){\\n                flip++;\\n            }\\n            n = n>>1;\\n        }\\n        return flip;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024457,
                "title": "python-bit-count-from-scratch",
                "content": "# Intuition\\nUsing string or built-in methods is easy.\\n\\n# Approach\\nWe will implement the bit count from scratch.\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        x = start ^ goal\\n        res = 0\\n        while x:\\n            res += 1\\n            x -= x & -x\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        x = start ^ goal\\n        res = 0\\n        while x:\\n            res += 1\\n            x -= x & -x\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021510,
                "title": "easy-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       int n = start ^ goal;\\n       int count = 0;\\n       while(n!=0)\\n       {\\n           n = n & (n-1);\\n           count++;\\n       } \\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       int n = start ^ goal;\\n       int count = 0;\\n       while(n!=0)\\n       {\\n           n = n & (n-1);\\n           count++;\\n       } \\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005474,
                "title": "java-simple-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor = start ^ goal;\\n        int ans = 0;\\n        int rem = 0;\\n        while(xor != 0) {\\n            rem = xor % 2;\\n            if(rem == 1) {\\n                ans += 1;\\n            }\\n            xor /= 2;\\n        }        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor = start ^ goal;\\n        int ans = 0;\\n        int rem = 0;\\n        while(xor != 0) {\\n            rem = xor % 2;\\n            if(rem == 1) {\\n                ans += 1;\\n            }\\n            xor /= 2;\\n        }        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001113,
                "title": "1-line-solution-with-c-std-bitset-class",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nC++ proposes a bitset class for such operations.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nXOR here is to determine number of different bits. (0^1 = 1)\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n      return return std::bitset<32>(start ^ goal).count();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n      return return std::bitset<32>(start ^ goal).count();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3997675,
                "title": "harshi-s-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nto count number of bits differ in start and goal\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nused sile & to check last bit if both are diff inc cnt and did left shift repated this until both start and goal are 0\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n        while(goal>0 || start>0)\\n        {\\n            int a=start&1, b=goal&1;\\n           if(a!=b)\\n           {\\n            cnt++;\\n           }\\n           start=start>>1;\\n           goal=goal>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n        while(goal>0 || start>0)\\n        {\\n            int a=start&1, b=goal&1;\\n           if(a!=b)\\n           {\\n            cnt++;\\n           }\\n           start=start>>1;\\n           goal=goal>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993478,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEasy look\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nxor of the both and find the set bits on xor\\'ed value\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        y=start^goal\\n        c=0\\n        while(y>0):\\n            y=y&(y-1)\\n            c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        y=start^goal\\n        c=0\\n        while(y>0):\\n            y=y&(y-1)\\n            c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990329,
                "title": "simplest-and-fastest-solution-in-c-without-using-using-builtin-popcount-i",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int temp= start^goal;\\n        int count=0;\\n        while(temp){\\n            if(temp&1) count++;\\n            temp>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int temp= start^goal;\\n        int count=0;\\n        while(temp){\\n            if(temp&1) count++;\\n            temp>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989579,
                "title": "c-easy-to-understand-just-one-line-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989573,
                "title": "bit-flips-javascript-convert-to-string-2",
                "content": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(start, goal) {\\n    let a = start.toString(2)\\n    let b = goal.toString(2)\\n    let len = Math.max(a.length, b.length)\\n    let count = 0\\n    \\n    for (let i = 0; i < len; i++) {\\n        n = a.at(-1 - i)\\n        m = b.at(-1 - i)\\n        if (n == undefined) n = 0\\n        if (m == undefined) m = 0\\n        n != m && count ++\\n    }\\n    \\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(start, goal) {\\n    let a = start.toString(2)\\n    let b = goal.toString(2)\\n    let len = Math.max(a.length, b.length)\\n    let count = 0\\n    \\n    for (let i = 0; i < len; i++) {\\n        n = a.at(-1 - i)\\n        m = b.at(-1 - i)\\n        if (n == undefined) n = 0\\n        if (m == undefined) m = 0\\n        n != m && count ++\\n    }\\n    \\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3986545,
                "title": "begineers-friendly-c-beats100-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        string st1 = bitset<32> (start).to_string();\\n        string st2 = bitset<32> (goal).to_string();\\n        int cnt = 0;\\n\\n        for(int i = 0; i < st1.length(); i++){\\n            if(st1[i] != st2[i])\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        string st1 = bitset<32> (start).to_string();\\n        string st2 = bitset<32> (goal).to_string();\\n        int cnt = 0;\\n\\n        for(int i = 0; i < st1.length(); i++){\\n            if(st1[i] != st2[i])\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984764,
                "title": "using-and-bitwise-operator-tc-o-32-o-1-c",
                "content": "# Approach\\ncompare the bits of \\u2018A\\u2019 and \\u2018B\\u2019 at each position and count the number of differences \\n\\n# Complexity\\n- Time complexity: \\n    O(32) or O(k), where k = num of bits required to represent number\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int A, int B) {\\n        int count=0; \\n        for(int i=0; i<32; i++) {\\n            // bit mask to check the i-th bit position of \\'A\\' and \\'B\\'.\\n            int mask= 1<<i;\\n            \\n            // extract the i-th bit of \\'A\\' and \\'B\\' by performing a bitwise AND operation between \\'A\\' and \\'B\\' with the mask.\\n            int bitA= mask & A;\\n            int bitB= mask & B;\\n            \\n            // if the i-th bit of \\'A\\' and \\'B\\' differ, increment the counter \\'count\\' to track the number of bits that need to be flipped.\\n            if(bitA!=bitB)  count++;\\n        }\\n        return count;\\n\\n        // Time Complexity : O(K), where \\'K\\' = maximum number of bits required to represent a number\\n        // Space Complexity : O(1)\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int A, int B) {\\n        int count=0; \\n        for(int i=0; i<32; i++) {\\n            // bit mask to check the i-th bit position of \\'A\\' and \\'B\\'.\\n            int mask= 1<<i;\\n            \\n            // extract the i-th bit of \\'A\\' and \\'B\\' by performing a bitwise AND operation between \\'A\\' and \\'B\\' with the mask.\\n            int bitA= mask & A;\\n            int bitB= mask & B;\\n            \\n            // if the i-th bit of \\'A\\' and \\'B\\' differ, increment the counter \\'count\\' to track the number of bits that need to be flipped.\\n            if(bitA!=bitB)  count++;\\n        }\\n        return count;\\n\\n        // Time Complexity : O(K), where \\'K\\' = maximum number of bits required to represent a number\\n        // Space Complexity : O(1)\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984591,
                "title": "easy-4-line-cpp-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start>0 || goal>0){\\n            if((start&1==1)!=(goal&1==1))count++;\\n            start=start>>1;\\n            goal=goal>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start>0 || goal>0){\\n            if((start&1==1)!=(goal&1==1))count++;\\n            start=start>>1;\\n            goal=goal>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983029,
                "title": "c-minimum-bit-flips-to-convert-number-using-xor",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe calculate the XOR of A and B to find the differing bits between them.\\nWe then loop through the XOR result bit by bit (right to left) using bitwise operations.\\nFor each bit, we check if it\\'s set (1) and increment the count if it is.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal)\\n    {\\n        int count = 0;\\n        int XOR = start^goal;\\n        \\n        while(XOR!=0)\\n        {\\n            count = count+(XOR&1);\\n            XOR = XOR>>1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal)\\n    {\\n        int count = 0;\\n        int XOR = start^goal;\\n        \\n        while(XOR!=0)\\n        {\\n            count = count+(XOR&1);\\n            XOR = XOR>>1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981889,
                "title": "java-code-string-builder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       String s=Integer.toBinaryString(goal); \\n       String sa=Integer.toBinaryString(start); \\n       StringBuilder sb =new StringBuilder();\\n       int m=Math.max(sa.length(), s.length());\\n       int count=0;\\n       while (s.length() < m) {\\n            s = \"0\" + s;\\n        }\\n        while (sa.length() < m) {\\n            sa = \"0\" + sa;\\n        }\\n\\n       for(int i= m-1 ;i>=0;i--){\\n           if(s.charAt(i)!=sa.charAt(i)){\\n               sb.append(s.charAt(i));\\n               count++;\\n               if(sb.toString().equals(s)){\\n                   return count;\\n               }\\n           }\\n       }\\n       return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       String s=Integer.toBinaryString(goal); \\n       String sa=Integer.toBinaryString(start); \\n       StringBuilder sb =new StringBuilder();\\n       int m=Math.max(sa.length(), s.length());\\n       int count=0;\\n       while (s.length() < m) {\\n            s = \"0\" + s;\\n        }\\n        while (sa.length() < m) {\\n            sa = \"0\" + sa;\\n        }\\n\\n       for(int i= m-1 ;i>=0;i--){\\n           if(s.charAt(i)!=sa.charAt(i)){\\n               sb.append(s.charAt(i));\\n               count++;\\n               if(sb.toString().equals(s)){\\n                   return count;\\n               }\\n           }\\n       }\\n       return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1892286,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1711670,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1711381,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1782548,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1958122,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1806696,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1685889,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            }
        ]
    }
]