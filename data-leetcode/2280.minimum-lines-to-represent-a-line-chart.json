[
    {
        "title": "Minimum Lines to Represent a Line Chart",
        "question_content": "You are given a 2D integer array stockPrices where stockPrices[i] = [dayi, pricei] indicates the price of the stock on day dayi is pricei. A line chart is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis representing the price and connecting adjacent points. One such example is shown below:\nReturn the minimum number of lines needed to represent the line chart.\n&nbsp;\nExample 1:\n\nInput: stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]\nOutput: 3\nExplanation:\nThe diagram above represents the input, with the X-axis representing the day and Y-axis representing the price.\nThe following 3 lines can be drawn to represent the line chart:\n- Line 1 (in red) from (1,7) to (4,4) passing through (1,7), (2,6), (3,5), and (4,4).\n- Line 2 (in blue) from (4,4) to (5,4).\n- Line 3 (in green) from (5,4) to (8,1) passing through (5,4), (6,3), (7,2), and (8,1).\nIt can be shown that it is not possible to represent the line chart using less than 3 lines.\n\nExample 2:\n\nInput: stockPrices = [[3,4],[1,2],[7,8],[2,3]]\nOutput: 1\nExplanation:\nAs shown in the diagram above, the line chart can be represented with a single line.\n\n&nbsp;\nConstraints:\n\n\t1 <= stockPrices.length <= 105\n\tstockPrices[i].length == 2\n\t1 <= dayi, pricei <= 109\n\tAll dayi are distinct.",
        "solutions": [
            {
                "id": 2061910,
                "title": "easy-c-solution-using-math",
                "content": "\\n![image](https://assets.leetcode.com/users/images/baf86cb1-55ae-4b45-82a5-1a166eb81193_1653192139.8784533.png)\\n\\n**Now if we have to compare slopes of two different lines, we can do:**\\n\\n![image](https://assets.leetcode.com/users/images/b37fe38b-8012-407b-b418-6e6a2b6213a5_1653192147.702317.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stk) {\\n        sort(stk.begin(),stk.end());\\n        int n = stk.size();\\n        if(n==1)\\n            return 0;\\n        int cnt = 1;\\n        for(int i=2;i<n;i++){\\n            long x1 = stk[i][0],x2 = stk[i-1][0],x3 = stk[i-2][0];\\n            long y1 = stk[i][1],y2 = stk[i-1][1],y3 = stk[i-2][1];\\n            long diff1 = (y3-y2) * (x2-x1);\\n            long diff2 = (y2-y1) * (x3-x2);\\n            if(diff1 != diff2)\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stk) {\\n        sort(stk.begin(),stk.end());\\n        int n = stk.size();\\n        if(n==1)\\n            return 0;\\n        int cnt = 1;\\n        for(int i=2;i<n;i++){\\n            long x1 = stk[i][0],x2 = stk[i-1][0],x3 = stk[i-2][0];\\n            long y1 = stk[i][1],y2 = stk[i-1][1],y3 = stk[i-2][1];\\n            long diff1 = (y3-y2) * (x2-x1);\\n            long diff2 = (y2-y1) * (x3-x2);\\n            if(diff1 != diff2)\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061824,
                "title": "gcd-slope",
                "content": "Since the next line segment starts where the previous one ends, we can just use slope to check if two segments form a line.\\n\\n> Catch 1: we need to sort points first. I did not realize it and got WA.\\n> Catch 2: do not use `double` for the slope. I learnt it the hard way - from solving many other problems here.\\n\\nThe formula for the slope is: `(y2 - y1)  / (x2 - x1)`. We do not have to worry about division by zero as `x` (days) are unique.\\n\\nIf we store a slope as a `double`, we will get WA due to double rounding error. Instead, we should store delta `x` and delta `y`, normalized by GCD.\\n\\n**C++**\\n```cpp\\nint minimumLines(vector<vector<int>>& p) {\\n    int cnt = 0, dx = INT_MIN, dy = INT_MIN;\\n    sort(begin(p), end(p));\\n    for (int i = 1; i < p.size(); ++i) {\\n        int dx1 = p[i][0] - p[i - 1][0], dy1 = p[i][1] - p[i - 1][1], d = gcd(dx1, dy1);\\n        cnt += dx != dx1 / d || dy != dy1 / d;\\n        dx = dx1 / d;\\n        dy = dy1 / d;\\n    }\\n    return cnt;\\n} \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minimumLines(vector<vector<int>>& p) {\\n    int cnt = 0, dx = INT_MIN, dy = INT_MIN;\\n    sort(begin(p), end(p));\\n    for (int i = 1; i < p.size(); ++i) {\\n        int dx1 = p[i][0] - p[i - 1][0], dy1 = p[i][1] - p[i - 1][1], d = gcd(dx1, dy1);\\n        cnt += dx != dx1 / d || dy != dy1 / d;\\n        dx = dx1 / d;\\n        dy = dy1 / d;\\n    }\\n    return cnt;\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062141,
                "title": "java-c-python-compare-slopes-cross-product",
                "content": "# **Preword**\\nI think it expects a solution without decimal.\\nKnowing well the precision of algorithm is also difficulty of writting codes.\\nBut yes, it will be much more friendly if this case is not hidden.\\n\\n# **Explanation**\\nCalculate the slope (A[i-1], A[i]) and (A[i],A[i+1])\\nAvoid float calculation.\\n(Fun fact: 0.1 +0.2 != 0.3 in computer science)\\n\\nFrom `(y1 - y0) / (x1 - x0) /  == (y2 - y1) / (x2 - x1) ` in float division,\\nwe have `(y1 - y0) * (x2 - x1) ==  (y2 - y1) * (x1 - x0)` in integer multiplication.\\n<br>\\n\\n# **Complexity**\\nTime `O(sort)`\\nSpace `O(sort)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minimumLines(int[][] A) {\\n        int n = A.length, res = n - 1;\\n        Arrays.sort(A, (a, b) -> Integer.compare(a[0], b[0]));\\n        for (int i = 1; i < n - 1; ++i)\\n            if (1L * (A[i][0] - A[i - 1][0]) * (A[i + 1][1] - A[i][1]) == 1L * (A[i + 1][0] - A[i][0]) * (A[i][1] - A[i - 1][1]))\\n                res--;\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int minimumLines(vector<vector<int>>& A) {\\n        int n = A.size(), res = n - 1;\\n        sort(begin(A), end(A));\\n        for (int i = 1; i < n - 1; ++i)\\n            if (1LL * (A[i][0] - A[i-1][0]) * (A[i+1][1] - A[i][1]) == 1LL * (A[i+1][0] - A[i][0]) * (A[i][1] - A[i-1][1]))\\n                res--;\\n        return res;    \\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimumLines(self, A: List[List[int]]) -> int:\\n        n = len(A)\\n        res = n - 1\\n        A.sort()\\n        for i in range(1, n - 1):\\n            a, b, c = A[i-1], A[i], A[i+1]\\n            if (b[0] - a[0]) * (c[1] - b[1]) == (c[0] - b[0]) * (b[1] - a[1]):\\n                res -= 1\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimumLines(int[][] A) {\\n        int n = A.length, res = n - 1;\\n        Arrays.sort(A, (a, b) -> Integer.compare(a[0], b[0]));\\n        for (int i = 1; i < n - 1; ++i)\\n            if (1L * (A[i][0] - A[i - 1][0]) * (A[i + 1][1] - A[i][1]) == 1L * (A[i + 1][0] - A[i][0]) * (A[i][1] - A[i - 1][1]))\\n                res--;\\n        return res;\\n    }\\n```\n```cpp\\n    int minimumLines(vector<vector<int>>& A) {\\n        int n = A.size(), res = n - 1;\\n        sort(begin(A), end(A));\\n        for (int i = 1; i < n - 1; ++i)\\n            if (1LL * (A[i][0] - A[i-1][0]) * (A[i+1][1] - A[i][1]) == 1LL * (A[i+1][0] - A[i][0]) * (A[i][1] - A[i-1][1]))\\n                res--;\\n        return res;    \\n    }\\n```\n```py\\n    def minimumLines(self, A: List[List[int]]) -> int:\\n        n = len(A)\\n        res = n - 1\\n        A.sort()\\n        for i in range(1, n - 1):\\n            a, b, c = A[i-1], A[i], A[i+1]\\n            if (b[0] - a[0]) * (c[1] - b[1]) == (c[0] - b[0]) * (b[1] - a[1]):\\n                res -= 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2061868,
                "title": "c-easy-simple-solution-slope-equation",
                "content": "The approach is based on a fact that if slope of two lines are equal and they have a point in common , then it is the same line.\\n# use long double instead of double for storing slopes \\nPoint is that ,long double provides more precision than double, we can see that the value of a particular coordinate can go up to `1e9 `so , when we calculate slope, we may divide very small numbers with the large ones. In those casese we need better precision!\\n# Time Complexity : O(n logn)\\n# Space Complexity : O(1)\\n# \\n\\n```\\n\\nsort(stockPrices.begin(),stockPrices.end());  //** sorted daywise\\n        \\n        if(stockPrices.size()<=1)return 0;\\n        int lines = 1;\\n        for(int i =1;i<stockPrices.size()-1;i++){\\n           \\n            long double x1 = stockPrices[i-1][0];\\n            long double y1 = stockPrices[i-1][1];\\n                \\n            long double x2 = stockPrices[i][0];\\n            long double y2 = stockPrices[i][1];\\n            \\n            \\n            long double x3 = stockPrices[i+1][0];  \\n            long double y3 = stockPrices[i+1][1];\\n            \\n            \\n            \\n           long double a = (long double)(y2-y1)/(x2-x1);  // slope of line joining pts i , i-1\\n           long  double b = (long double)(y3-y2)/(x3-x2);  // slope of line joining pts i+1,i\\n            \\n            if(a!=b){\\n                              // since ith point is common , if slope a and b are equal then it is a straight line otherwise its not              \\n                lines ++;\\n            }\\n            \\n        }\\n        return lines;\\n\\n\\n```\\nHope it helped!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nsort(stockPrices.begin(),stockPrices.end());  //** sorted daywise\\n        \\n        if(stockPrices.size()<=1)return 0;\\n        int lines = 1;\\n        for(int i =1;i<stockPrices.size()-1;i++){\\n           \\n            long double x1 = stockPrices[i-1][0];\\n            long double y1 = stockPrices[i-1][1];\\n                \\n            long double x2 = stockPrices[i][0];\\n            long double y2 = stockPrices[i][1];\\n            \\n            \\n            long double x3 = stockPrices[i+1][0];  \\n            long double y3 = stockPrices[i+1][1];\\n            \\n            \\n            \\n           long double a = (long double)(y2-y1)/(x2-x1);  // slope of line joining pts i , i-1\\n           long  double b = (long double)(y3-y2)/(x3-x2);  // slope of line joining pts i+1,i\\n            \\n            if(a!=b){\\n                              // since ith point is common , if slope a and b are equal then it is a straight line otherwise its not              \\n                lines ++;\\n            }\\n            \\n        }\\n        return lines;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061888,
                "title": "java-o-nlogn-use-maths-slope",
                "content": "Please upvote if this helps.\\n\\n```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if (stockPrices.length == 1) return 0;\\n        // Sort by occurence of each day and then check the slope\\n        // Time: O(NLogN), Space: O(1) / O(N) which depends on the type of sort used\\n        Arrays.sort(stockPrices, (a, b) -> Integer.compare(a[0], b[0]));\\n        int count = 1;\\n        for (int i = 2; i < stockPrices.length; i++) {\\n            // Check if the slopes of three consecutive points are equal then continue\\n            // otherwise add another line to the count.\\n            // check (y2 - y1) / (x2 - x1) == (y1 - y0) / (x1 - x0) => (y2 - y1) * (x1 - x0) == (y1 - y0) * (x2 - x1)\\n            if ((stockPrices[i][1] - stockPrices[i - 1][1]) * (stockPrices[i - 1][0] - stockPrices[i - 2][0]) == \\n                (stockPrices[i - 1][1] - stockPrices[i - 2][1]) * (stockPrices[i][0] - stockPrices[i - 1][0])) continue;\\n            \\n            count += 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if (stockPrices.length == 1) return 0;\\n        // Sort by occurence of each day and then check the slope\\n        // Time: O(NLogN), Space: O(1) / O(N) which depends on the type of sort used\\n        Arrays.sort(stockPrices, (a, b) -> Integer.compare(a[0], b[0]));\\n        int count = 1;\\n        for (int i = 2; i < stockPrices.length; i++) {\\n            // Check if the slopes of three consecutive points are equal then continue\\n            // otherwise add another line to the count.\\n            // check (y2 - y1) / (x2 - x1) == (y1 - y0) / (x1 - x0) => (y2 - y1) * (x1 - x0) == (y1 - y0) * (x2 - x1)\\n            if ((stockPrices[i][1] - stockPrices[i - 1][1]) * (stockPrices[i - 1][0] - stockPrices[i - 2][0]) == \\n                (stockPrices[i - 1][1] - stockPrices[i - 2][1]) * (stockPrices[i][0] - stockPrices[i - 1][0])) continue;\\n            \\n            count += 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061791,
                "title": "how-to-fix-your-wrong-answer-for-the-hidden-test-case",
                "content": "**TL;DR: Use `fractions.Fraction`**\\n\\nBroken code:\\n\\n```python\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        stockPrices.sort()\\n        gradient = None\\n        res = 0\\n        for cur,nxt in pairwise(stockPrices):\\n            newGradient = (nxt[1]-cur[1])/(nxt[0]-cur[0]) # :(\\n            if newGradient != gradient:\\n                gradient = newGradient\\n                res += 1\\n        return res\\n```\\n`newGradient` is calculated as a **floating point**. It will be inaccurate for larger values in the test set.\\n\\nYou can use python\\'s `fractions.Fraction` class to avoid this:\\n\\n```python\\nfrom fractions import Fraction\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        stockPrices.sort()\\n        gradient = None\\n        res = 0\\n        for cur,nxt in pairwise(stockPrices):\\n            newGradient = Fraction(nxt[1]-cur[1],nxt[0]-cur[0]) # working! :)\\n            if newGradient != gradient:\\n                gradient = newGradient\\n                res += 1\\n        return res\\n```\\n\\nPlease **upvote** if this was helpful!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        stockPrices.sort()\\n        gradient = None\\n        res = 0\\n        for cur,nxt in pairwise(stockPrices):\\n            newGradient = (nxt[1]-cur[1])/(nxt[0]-cur[0]) # :(\\n            if newGradient != gradient:\\n                gradient = newGradient\\n                res += 1\\n        return res\\n```\n```python\\nfrom fractions import Fraction\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        stockPrices.sort()\\n        gradient = None\\n        res = 0\\n        for cur,nxt in pairwise(stockPrices):\\n            newGradient = Fraction(nxt[1]-cur[1],nxt[0]-cur[0]) # working! :)\\n            if newGradient != gradient:\\n                gradient = newGradient\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061786,
                "title": "python3-java-c-cross-product-gcd-explanation",
                "content": "**Note**: \\n* The maximum number of lines for `n` points in our question can be `n - 1`. So that is our starting value of `ans`\\n* Whenever we find that the slope of 2 adjacent lines is same, we decrease `ans` by 1 because the same line can pass through the 3 respective points\\n* We first sort the points by `x` to get points adjacent to each other\\n### *Solution 1: Cross Product*\\n`Slope(m) = y2 - y1 / x2 - x1`\\n**Explanation**: Instead of equating slope as `y2 - y1 / x2 - x1 == y1 - y0 / x1 - x0` use cross product as `(y2 - y1) * (x1 - x0) == (y1 - y0) * (x2 - x1)` \\n<iframe src=\"https://leetcode.com/playground/hXP5qfX7/shared\" frameBorder=\"0\" width=\"970\" height=\"210\"></iframe>\\n\\n### *Solution 2: GCD*\\n**Intuition**: To find points that can have the same line pass through them, they should be adjacent and the slope of the lines passing through them should be the same.\\n`Slope(m) = y2 - y1 / x2 - x1`\\n\\n**The problem**: When equating the slope in decimal format the computer may not be able to tell if the slope of 2 lines is same or not if the portion after the decimal is a large number.\\n\\n**Solution**: Our target is to equate slope: `y2 - y1 / x2 - x1 == y1 - y0 / x1 - x0`\\nDivide both sides by their respective greatest common divisiors. Now numerator of both sides should match and denominators of both sides should match if slope is same.\\n\\n<iframe src=\"https://leetcode.com/playground/P5Rvenuc/shared\" frameBorder=\"0\" width=\"550\" height=\"380\"></iframe>\\n\\n> Time Complexity: nlogn",
                "solutionTags": [],
                "code": "**Note**: \\n* The maximum number of lines for `n` points in our question can be `n - 1`. So that is our starting value of `ans`\\n* Whenever we find that the slope of 2 adjacent lines is same, we decrease `ans` by 1 because the same line can pass through the 3 respective points\\n* We first sort the points by `x` to get points adjacent to each other\\n### *Solution 1: Cross Product*\\n`Slope(m) = y2 - y1 / x2 - x1`\\n**Explanation**: Instead of equating slope as `y2 - y1 / x2 - x1 == y1 - y0 / x1 - x0` use cross product as `(y2 - y1) * (x1 - x0) == (y1 - y0) * (x2 - x1)` \\n<iframe src=\"https://leetcode.com/playground/hXP5qfX7/shared\" frameBorder=\"0\" width=\"970\" height=\"210\"></iframe>\\n\\n### *Solution 2: GCD*\\n**Intuition**: To find points that can have the same line pass through them, they should be adjacent and the slope of the lines passing through them should be the same.\\n`Slope(m) = y2 - y1 / x2 - x1`\\n\\n**The problem**: When equating the slope in decimal format the computer may not be able to tell if the slope of 2 lines is same or not if the portion after the decimal is a large number.\\n\\n**Solution**: Our target is to equate slope: `y2 - y1 / x2 - x1 == y1 - y0 / x1 - x0`\\nDivide both sides by their respective greatest common divisiors. Now numerator of both sides should match and denominators of both sides should match if slope is same.\\n\\n<iframe src=\"https://leetcode.com/playground/P5Rvenuc/shared\" frameBorder=\"0\" width=\"550\" height=\"380\"></iframe>\\n\\n> Time Complexity: nlogn",
                "codeTag": "Unknown"
            },
            {
                "id": 2061893,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        # key point: never use devision to judge whether 3 points are on a same line or not, use the multiplication instead !!\\n        \\n        n = len(stockPrices)\\n        stockPrices.sort(key = lambda x: (x[0], x[1]))\\n        \\n        if n == 1:\\n            return 0\\n        \\n        pre_delta_y = stockPrices[0][1] - stockPrices[1][1]\\n        pre_delta_x = stockPrices[0][0] - stockPrices[1][0]\\n        num = 1\\n        \\n        for i in range(1, n-1):\\n            cur_delta_y = stockPrices[i][1] - stockPrices[i+1][1]\\n            cur_delta_x = stockPrices[i][0] - stockPrices[i+1][0]\\n            \\n            if pre_delta_y * cur_delta_x != pre_delta_x * cur_delta_y:\\n                num += 1\\n                pre_delta_x = cur_delta_x\\n                pre_delta_y = cur_delta_y\\n        \\n        return num",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        # key point: never use devision to judge whether 3 points are on a same line or not, use the multiplication instead !!\\n        \\n        n = len(stockPrices)\\n        stockPrices.sort(key = lambda x: (x[0], x[1]))\\n        \\n        if n == 1:\\n            return 0\\n        \\n        pre_delta_y = stockPrices[0][1] - stockPrices[1][1]\\n        pre_delta_x = stockPrices[0][0] - stockPrices[1][0]\\n        num = 1\\n        \\n        for i in range(1, n-1):\\n            cur_delta_y = stockPrices[i][1] - stockPrices[i+1][1]\\n            cur_delta_x = stockPrices[i][0] - stockPrices[i+1][0]\\n            \\n            if pre_delta_y * cur_delta_x != pre_delta_x * cur_delta_y:\\n                num += 1\\n                pre_delta_x = cur_delta_x\\n                pre_delta_y = cur_delta_y\\n        \\n        return num",
                "codeTag": "Java"
            },
            {
                "id": 2061906,
                "title": "c-easy-to-understand-gcd-slope-t-c-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int,int>solve(vector<int>&a,vector<int>&b){\\n        int newx=a[0]-b[0];\\n        int newy=a[1]-b[1];\\n        if(newx<0){\\n            newx=-newx;\\n            newy=-newy;\\n        }\\n        int gcd=__gcd(newx,abs(newy));\\n        newx=newx/gcd;\\n        newy=newy/gcd;\\n        return {newx,newy};\\n    }\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int n=stockPrices.size();\\n        sort(stockPrices.begin(),stockPrices.end());\\n        if(n==1) return 0;\\n        int ans=1;\\n        pair<int,int> p=solve(stockPrices[0],stockPrices[1]);\\n        for(int i=2;i<n;i++){\\n            pair<int,int> cr=solve(stockPrices[i],stockPrices[i-1]);\\n            if(cr!=p){\\n                ans++;\\n            }\\n            p=cr;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int>solve(vector<int>&a,vector<int>&b){\\n        int newx=a[0]-b[0];\\n        int newy=a[1]-b[1];\\n        if(newx<0){\\n            newx=-newx;\\n            newy=-newy;\\n        }\\n        int gcd=__gcd(newx,abs(newy));\\n        newx=newx/gcd;\\n        newy=newy/gcd;\\n        return {newx,newy};\\n    }\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int n=stockPrices.size();\\n        sort(stockPrices.begin(),stockPrices.end());\\n        if(n==1) return 0;\\n        int ans=1;\\n        pair<int,int> p=solve(stockPrices[0],stockPrices[1]);\\n        for(int i=2;i<n;i++){\\n            pair<int,int> cr=solve(stockPrices[i],stockPrices[i-1]);\\n            if(cr!=p){\\n                ans++;\\n            }\\n            p=cr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061821,
                "title": "c-with-explanation-check-if-slope-is-equal",
                "content": "For all points to lie on a straight line the slope should be equal.  So if the slope between consecutive points is equal then it means that the point lies on the same straight line else it lies on another line.\\n\\nThe main problem in this question is that we cant store the slope in double and check whether the slope is equal for consecutive elements because there might be small differences in the quotient on dividing in c++. \\n\\nTherefore, we have to store them as fractions instead and check whether the fractions are equal.\\n\\nLet there be two fractions a,b\\nFor these two to be equal :-\\nnumerator_a * denominator_b = numerator_b * denominator_a \\n\\nHere\\'s the code.\\nPlease upvote if it helped, it really motivates me a lot.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> getSlope(vector<vector<int>>& stockPrices, int i) {\\n        return {stockPrices[i][1]-stockPrices[i-1][1], stockPrices[i][0]-stockPrices[i-1][0]};\\n    }\\n    \\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        if(stockPrices.size() == 1) \\n            return 0;\\n        \\n        sort(stockPrices.begin(),stockPrices.end());        \\n        vector<int> prev_slope = getSlope(stockPrices, 1);\\n        int ans = 1;\\n\\n        for(int i=2; i<stockPrices.size(); ++i) {\\n            vector<int> slope = getSlope(stockPrices, i);\\n            if((long long)slope[0]*prev_slope[1] != (long long)slope[1]*prev_slope[0]) {\\n                prev_slope = slope;\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> getSlope(vector<vector<int>>& stockPrices, int i) {\\n        return {stockPrices[i][1]-stockPrices[i-1][1], stockPrices[i][0]-stockPrices[i-1][0]};\\n    }\\n    \\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        if(stockPrices.size() == 1) \\n            return 0;\\n        \\n        sort(stockPrices.begin(),stockPrices.end());        \\n        vector<int> prev_slope = getSlope(stockPrices, 1);\\n        int ans = 1;\\n\\n        for(int i=2; i<stockPrices.size(); ++i) {\\n            vector<int> slope = getSlope(stockPrices, i);\\n            if((long long)slope[0]*prev_slope[1] != (long long)slope[1]*prev_slope[0]) {\\n                prev_slope = slope;\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063469,
                "title": "intuition-explain-maths-java-simple-solution-o-nlogn-sorting",
                "content": "\\nApplying the slope formula:\\nthe slopes of parallel lines are equal. Note that two lines are parallel if their slopes are equal and they have different y-intercepts. In other words, perpendicular slopes are negative reciprocals of each other.\\n(y2 - y1)/(x2-x1) = (y4 - y3)/(x4-x3)\\n\\nLet dy = y2 - y1\\nLet dx = x2 - x1\\n\\nLet dy1 = y4 - y3\\nLet dx1 = x4 - x3\\n\\nNow just check \\n(dx1*dy != dx*dy1)  if they are not equal then lines++\\n\\nand keep modifying there dx and dy\\ndy = dy1\\ndx = dx1\\n\\n// code\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        \\n        int n = stockPrices.length;\\n        if(n == 1 || n == 2) return n - 1;\\n        \\n       \\n        Arrays.sort(stockPrices,(a,b) ->{\\n              return a[0] - b[0];\\n        });\\n    \\n        \\n        int x2 = stockPrices[1][0];\\n        int x1 = stockPrices[0][0];\\n        \\n        int y2 = stockPrices[1][1];\\n        int y1 = stockPrices[0][1];\\n        \\n        \\n        int dx = x2 - x1;\\n        int dy = y2 - y1;\\n    \\n        int lines = 1;\\n        \\n        for(int i=2;i<n;i++){\\n            \\n            int x4 = stockPrices[i][0];\\n            int x3 = stockPrices[i-1][0];\\n            \\n            int y4 = stockPrices[i][1];\\n            int y3 = stockPrices[i-1][1];\\n             \\n            int dx1 = (x4 - x3);\\n            int dy1 = (y4 - y3);\\n            \\n            if(dx1*dy != dx*dy1) lines++;\\n            dy = dy1;\\n            dx = dx1;\\n        }\\n        return lines;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        \\n        int n = stockPrices.length;\\n        if(n == 1 || n == 2) return n - 1;\\n        \\n       \\n        Arrays.sort(stockPrices,(a,b) ->{\\n              return a[0] - b[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2062520,
                "title": "c-easy-intuition-with-basic-maths-and-maps",
                "content": "# This is simple maths problem\\nLets understand the maths behind it. We have studied that a line is represented in the form of \\n*  `y = mx + c, where m is the slope of the line and c is a constant`\\n\\nNow, we can find the slope between two points by using the definition of slope ie `(y2-y2)/(x2-x1)`\\nOne can think of using slope as a differentiating factor. But for two parallel lines, slope value is always same. So in such cases, this idea will not work.\\nInstead, we can use the constant c as a deciding factor whether two lines are same or not. \\nFrom the line equation, we have  `c = y - mx`\\n\\nNow, for a same line, c will not change but for different lines, value of c will differ and it will be unique for a line. Thus all we need to do is to count all the unique possible values of c. That will be our answer. \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& arr) {\\n\\t// We need to sort the prices array on the basis of days \\n        sort(arr.begin(),arr.end());\\n        \\n        unordered_map <double,int> mp;\\n        \\n\\t\\t// make sure to take the slope in long double to avoid the possible overflow in hidden cases(due to m*x). \\n        for(int i = 1; i<arr.size(); i++){\\n            long double x1 = arr[i-1][0], y1 = arr[i-1][1];\\n            long double x2 = arr[i][0], y2 = arr[i][1];\\n            \\n            long double m = double(y2-y1)/double(x2-x1);\\n            long double c = double(y2) - m*x2;\\n            mp[c]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& arr) {\\n\\t// We need to sort the prices array on the basis of days \\n        sort(arr.begin(),arr.end());\\n        \\n        unordered_map <double,int> mp;\\n        \\n\\t\\t// make sure to take the slope in long double to avoid the possible overflow in hidden cases(due to m*x). \\n        for(int i = 1; i<arr.size(); i++){\\n            long double x1 = arr[i-1][0], y1 = arr[i-1][1];\\n            long double x2 = arr[i][0], y2 = arr[i][1];\\n            \\n            long double m = double(y2-y1)/double(x2-x1);\\n            long double c = double(y2) - m*x2;\\n            mp[c]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061884,
                "title": "java-bigdecimal-solution",
                "content": "```\\nimport java.math.BigDecimal;\\nimport java.math.MathContext;\\nimport java.util.*;\\n\\n/*\\n    Find the gain between each point, if the gain changes, we need to add a line\\n    Time: O(n)\\n*/\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if (stockPrices.length == 1) { // case for single data point only, no line needed\\n            return 0;\\n        }\\n        Arrays.sort(stockPrices, (a, b) -> Integer.compare(a[0], b[0])); // sort by day (chronologically)\\n        List<BigDecimal> diff = new ArrayList<>();\\n        // calculate the gains\\n        for (int i = 1; i < stockPrices.length; i++) {\\n            BigDecimal price = new BigDecimal(stockPrices[i][1]-stockPrices[i-1][1]);\\n            BigDecimal time = new BigDecimal(stockPrices[i][0]-stockPrices[i-1][0]);\\n            BigDecimal gain = price.divide(time, MathContext.DECIMAL128);\\n            diff.add(gain);   \\n            // System.out.println(gain);\\n        }\\n \\n        int lines = 1; // need at least 1 line to plot a diff \\n        // if gain changes, add a line\\n        for (int i = 1; i < diff.size(); i++) {\\n            if (diff.get(i).compareTo(diff.get(i-1)) == 0) {\\n                continue;\\n            } else {\\n                lines++;\\n            }\\n        }\\n        \\n        return lines;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if (stockPrices.length == 1) { // case for single data point only, no line needed\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2062899,
                "title": "python-easy-4-liner-with-explanation",
                "content": "The problem asks us to find the minimum number of lines required to connect all points in the graph. In worst case, we need `n-1` lines to connect all points. \\n\\nThe code will try to find consecutive 3 points`(a, b, c)`which are in the same line. So our goal is to count all triples whihc are on same line and subtract them from `n-1`. \\n\\n\\nTo check if two points are on same line, we need to calculate the slope. The formula for the slope is: `(y2 - y1) / (x2 - x1)`. Three points are considered to be on same line if it matches the below condition:\\n> **slope(a,b)==slope(b,c)**\\n>**(x1 - x0) / (y1 - y0) == (x2 - x1) / (y2 - y1)** - This will result in floating points which is not desirable for comparison.\\n>**(x1 - x0) * (y2 - y1) == (x2 - x1) * (y1 - y0)** - Avoid floating points using multiplication.\\n\\nOnce you have counted all the triples that match the above condition, subtract them from `n-1` which will give you the desired result. \\n\\n```\\n\\nclass Solution:\\n    def minimumLines(self, A: List[List[int]]) -> int:\\n        A.sort() # to bring consecutive points on graph together\\n        n=len(A)\\n                \\n        # calculate if three points lie on the same line        \\n        is_same_line = lambda a,b,c: (b[0]-a[0])*(c[1] - b[1])==(c[0]-b[0])*(b[1] - a[1])\\n        \\n        return n - 1 - sum(is_same_line(A[i-1], A[i], A[i+1]) for i in range(1, n-1) )\\n```\\n\\n**Time = O(nlogn)** - required for sorting\\n**Space = O(1)**\\n\\n---\\n\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minimumLines(self, A: List[List[int]]) -> int:\\n        A.sort() # to bring consecutive points on graph together\\n        n=len(A)\\n                \\n        # calculate if three points lie on the same line        \\n        is_same_line = lambda a,b,c: (b[0]-a[0])*(c[1] - b[1])==(c[0]-b[0])*(b[1] - a[1])\\n        \\n        return n - 1 - sum(is_same_line(A[i-1], A[i], A[i+1]) for i in range(1, n-1) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062233,
                "title": "order-n-constant-space-3-pointer",
                "content": "This problem seems to be tricky, as we all know how to find out the slope, but there is catch, when we divide the numbers possibility is that double is normalised to int, which can cause error in counting lines via critical points.\\nSo it\\'s wise decision to find out slopes by 3 point form,\\n*(y2 - y1)(x3-x2) = (x2-x1)*(y3-y2)\\n```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if(stockPrices.length == 1) return 0;\\n        int count = 1;\\n        Arrays.sort(stockPrices,(o1,o2)->o1[0]-o2[0]);\\n        for(int i=1;i<stockPrices.length-1;i++){\\n            int x1 = stockPrices[i-1][0];\\n            int y1 = stockPrices[i-1][1];\\n            int x2 = stockPrices[i][0];\\n            int y2 = stockPrices[i][1];\\n            int x3 = stockPrices[i+1][0];\\n            int y3 = stockPrices[i+1][1];\\n            if(((x3-x2)*(y2-y1))==((y3-y2)*(x2-x1))) continue;\\n            \\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\nHappy LeetCoding",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if(stockPrices.length == 1) return 0;\\n        int count = 1;\\n        Arrays.sort(stockPrices,(o1,o2)->o1[0]-o2[0]);\\n        for(int i=1;i<stockPrices.length-1;i++){\\n            int x1 = stockPrices[i-1][0];\\n            int y1 = stockPrices[i-1][1];\\n            int x2 = stockPrices[i][0];\\n            int y2 = stockPrices[i][1];\\n            int x3 = stockPrices[i+1][0];\\n            int y3 = stockPrices[i+1][1];\\n            if(((x3-x2)*(y2-y1))==((y3-y2)*(x2-x1))) continue;\\n            \\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062057,
                "title": "brain-teaser-test-case",
                "content": "DANG! Please comment below and let me know what was your thought at that moment!\\n```\\n[[1,1],[500000000,499999999],[1000000000,999999998]]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n[[1,1],[500000000,499999999],[1000000000,999999998]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061973,
                "title": "java-easy-explanation-straightforward-solution",
                "content": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n        int count = 0;\\n        int i = 0;\\n        int j = 1;\\n        \\n        while(j < stockPrices.length) {\\n\\t\\t\\t//move up 2nd pointer while its collinear\\n            while(j + 1 < stockPrices.length &&coollinear(stockPrices[i], stockPrices[j], stockPrices[j+1])) {\\n                j++;\\n            }\\n\\t\\t\\t//restart for next calc\\n            i = j;\\n            j++;\\n            count++;\\n        }\\n        return count;\\n    }\\n    static boolean coollinear(int[] x, int[] y, int[] z) {\\n        int x1 = x[0];\\n        int y1 = x[1];\\n        int x2 = y[0];\\n        int y2 = y[1];\\n        int x3 = z[0];\\n        int y3 = z[1];\\n        if ((y3 - y2) * (x2 - x1) == (y2 - y1) * (x3 - x2))\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n        int count = 0;\\n        int i = 0;\\n        int j = 1;\\n        \\n        while(j < stockPrices.length) {\\n\\t\\t\\t//move up 2nd pointer while its collinear\\n            while(j + 1 < stockPrices.length &&coollinear(stockPrices[i], stockPrices[j], stockPrices[j+1])) {\\n                j++;\\n            }\\n\\t\\t\\t//restart for next calc\\n            i = j;\\n            j++;\\n            count++;\\n        }\\n        return count;\\n    }\\n    static boolean coollinear(int[] x, int[] y, int[] z) {\\n        int x1 = x[0];\\n        int y1 = x[1];\\n        int x2 = y[0];\\n        int y2 = y[1];\\n        int x3 = z[0];\\n        int y3 = z[1];\\n        if ((y3 - y2) * (x2 - x1) == (y2 - y1) * (x3 - x2))\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915313,
                "title": "c-solution",
                "content": "# Intuition\\nFirst thought was of finding the slope.\\n\\n# Approach\\nSorted the array in the terms of x axis value so that we can get the lines in the increasing order then one by one checked the slope if i get the new value of slope that means new line has been found and increment the counter.\\n\\n# Complexity\\n- Time complexity:\\n    O(n*log(n)) where n = total number of points\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(), stockPrices.end());\\n\\n\\n\\n\\n        int dx,dy, ans=1;\\n        long double slope;\\n\\n        if(stockPrices.size() < 2) {\\n            return 0;\\n        }\\n\\n        dx = stockPrices[1][0] - stockPrices[0][0];\\n        dy = stockPrices[1][1] - stockPrices[0][1];\\n        slope = (long double)dy/dx;\\n\\n        for(int i=1;i<stockPrices.size()-1;i++) {\\n            dx = stockPrices[i+1][0] - stockPrices[i][0];\\n            dy = stockPrices[i+1][1] - stockPrices[i][1];\\n            cout << dx << \" \" << dy << endl;\\n            if((long double)dy/dx != slope) {\\n                cout << (long double)slope << endl;\\n                ans++;\\n                slope = (long double)dy/dx;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(), stockPrices.end());\\n\\n\\n\\n\\n        int dx,dy, ans=1;\\n        long double slope;\\n\\n        if(stockPrices.size() < 2) {\\n            return 0;\\n        }\\n\\n        dx = stockPrices[1][0] - stockPrices[0][0];\\n        dy = stockPrices[1][1] - stockPrices[0][1];\\n        slope = (long double)dy/dx;\\n\\n        for(int i=1;i<stockPrices.size()-1;i++) {\\n            dx = stockPrices[i+1][0] - stockPrices[i][0];\\n            dy = stockPrices[i+1][1] - stockPrices[i][1];\\n            cout << dx << \" \" << dy << endl;\\n            if((long double)dy/dx != slope) {\\n                cout << (long double)slope << endl;\\n                ans++;\\n                slope = (long double)dy/dx;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2076870,
                "title": "c-easy-sloution-with-slope-o-nlogn-simple-math",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int cnt=1;\\n        if(arr.size()==1){\\n            return 0;\\n        }\\n        for(int i=2;i<arr.size();i++){\\n            long x1 = arr[i-2][0],y1 = arr[i-2][1];\\n            long x2 = arr[i-1][0],y2 = arr[i-1][1];\\n            long x3 = arr[i][0],y3 = arr[i][1];\\n            \\n            long diff1 = (y2-y1)*(x3-x2); //avoid finding individual slope with division to avoid floating point errors\\n            long diff2 = (y3-y2)*(x2-x1);\\n            if(diff1!=diff2){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int cnt=1;\\n        if(arr.size()==1){\\n            return 0;\\n        }\\n        for(int i=2;i<arr.size();i++){\\n            long x1 = arr[i-2][0],y1 = arr[i-2][1];\\n            long x2 = arr[i-1][0],y2 = arr[i-1][1];\\n            long x3 = arr[i][0],y3 = arr[i][1];\\n            \\n            long diff1 = (y2-y1)*(x3-x2); //avoid finding individual slope with division to avoid floating point errors\\n            long diff2 = (y3-y2)*(x2-x1);\\n            if(diff1!=diff2){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064752,
                "title": "python-don-t-calculate-the-entire-gradient-explained-with-diagram",
                "content": "Got stuck at the hidden case during the contest but learnt something new - and isnt that the goal :)\\n\\n![image](https://assets.leetcode.com/users/images/30d03eb8-e32e-4e40-8f69-72df41922126_1653247852.4456663.png)\\n\\n\\n```\\nclass Solution:\\n    \\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        n = len(stockPrices)\\n        if not stockPrices or len(stockPrices) <= 1:\\n            return 0\\n        stockPrices.sort()\\n        count = 1\\n        \\n        for i in range(1, len(stockPrices)-1):\\n            x0, y0 = stockPrices[i-1]\\n            x1, y1 = stockPrices[i]\\n            x2, y2 = stockPrices[i+1]\\n            \\n            if (y0-y1)*(x1-x2) != (y1-y2)*(x0-x1):\\n                count += 1\\n    \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        n = len(stockPrices)\\n        if not stockPrices or len(stockPrices) <= 1:\\n            return 0\\n        stockPrices.sort()\\n        count = 1\\n        \\n        for i in range(1, len(stockPrices)-1):\\n            x0, y0 = stockPrices[i-1]\\n            x1, y1 = stockPrices[i]\\n            x2, y2 = stockPrices[i+1]\\n            \\n            if (y0-y1)*(x1-x2) != (y1-y2)*(x0-x1):\\n                count += 1\\n    \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062526,
                "title": "java-solution-easy-to-understand-and-commented",
                "content": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        //this is a point\\n        if(stockPrices.length==1){\\n            return 0;\\n        }\\n        //sorting the stockPrices according to days\\n        Arrays.sort(stockPrices,(a,b)->a[0]-b[0]);\\n        //initial difference of day and prices\\n        long day=stockPrices[1][0]-stockPrices[0][0];\\n        long prices=stockPrices[1][1]-stockPrices[0][1];\\n        int lines=1;\\n        for(int i=2;i<stockPrices.length;i++){\\n            //calculating difference\\n            long tempDay=stockPrices[i][0]-stockPrices[i-1][0];\\n            long tempPrices=stockPrices[i][1]-stockPrices[i-1][1];\\n            //in division, approximation is done so some test cases are failing\\n            //so here we use multiplication for checking the slope\\n            if((tempDay!=day || tempPrices!=prices)&& tempPrices*day != prices*tempDay){\\n                lines++;\\n                day=tempDay;\\n                prices=tempPrices;\\n            }\\n        }\\n        return lines;\\n    }\\n}\\n```\\n\\nIf there is some doubt, then do comment....Happy Leetcoding!",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        //this is a point\\n        if(stockPrices.length==1){\\n            return 0;\\n        }\\n        //sorting the stockPrices according to days\\n        Arrays.sort(stockPrices,(a,b)->a[0]-b[0]);\\n        //initial difference of day and prices\\n        long day=stockPrices[1][0]-stockPrices[0][0];\\n        long prices=stockPrices[1][1]-stockPrices[0][1];\\n        int lines=1;\\n        for(int i=2;i<stockPrices.length;i++){\\n            //calculating difference\\n            long tempDay=stockPrices[i][0]-stockPrices[i-1][0];\\n            long tempPrices=stockPrices[i][1]-stockPrices[i-1][1];\\n            //in division, approximation is done so some test cases are failing\\n            //so here we use multiplication for checking the slope\\n            if((tempDay!=day || tempPrices!=prices)&& tempPrices*day != prices*tempDay){\\n                lines++;\\n                day=tempDay;\\n                prices=tempPrices;\\n            }\\n        }\\n        return lines;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062176,
                "title": "5-line-solution-very-easy-c-o-n-space-o-n",
                "content": "the main thing in this problem is we have to calculate slop but we cant use **float** .because float comparision gives wrong ans.\\n\\nso instead  of calculating slope by formula=(y2-y1)/(x2-x1)\\nwe will do this to prevent from getting float value in  slop comparison:\\nlet three point be (x1,y1) , (x2,y2) , (x3,y3)\\nslope1=(y2-y1)/(x2-x1)\\nslope2=(y3-y2)/(x3-x2)\\nnow cross multiplying both side to avoid getting float\\nso : slope1=slope2\\ntherefor: (y2-y1)*(x3-x2)==(y3-y2)*(x2-x1)     ..//this will prevent from getting float \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stock) {\\n       sort(stock.begin(),stock.end());\\n        if(stock.size()==1)\\n            return 0;\\n        if(stock.size()==2)\\n            return 1;\\n        long long res = 1;\\n        int n = stock.size();\\n        for(int i = 2; i<n; i++){\\n        if((1ll)*(stock[i-1][1]-stock[i-2][1])*(stock[i][0]-stock[i-1][0]) != (1ll)*(stock[i][1]-stock[i-1][1])*(stock[i-1][0]-stock[i-2][0])) res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE IF U LIKE THE SOLUTION**\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stock) {\\n       sort(stock.begin(),stock.end());\\n        if(stock.size()==1)\\n            return 0;\\n        if(stock.size()==2)\\n            return 1;\\n        long long res = 1;\\n        int n = stock.size();\\n        for(int i = 2; i<n; i++){\\n        if((1ll)*(stock[i-1][1]-stock[i-2][1])*(stock[i][0]-stock[i-1][0]) != (1ll)*(stock[i][1]-stock[i-1][1])*(stock[i-1][0]-stock[i-2][0])) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061850,
                "title": "cpp-gcd-time-o-nlogn-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& v,int ans=0) {\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        pair<int,int> p={1e9+7,1e9};\\n        for(int i=1;i<n;i++){\\n            int dx=v[i][0]-v[i-1][0],dy=v[i][1]-v[i-1][1];\\n            int gcd=__gcd(dx,dy);\\n            dx/=gcd,dy/=gcd;\\n            pair<int,int> pp={dx,dy};\\n            if(pp!=p)ans++,p=pp;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time O(nlogn)**\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long double ld;\\n    int minimumLines(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end());\\n        ld slope=1e9+7,n=v.size();\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            ld s=(v[i][1]-v[i-1][1])/(ld(v[i][0]-v[i-1][0]));\\n            if(s!=slope)ans++,slope=s;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time O(nlogn)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& v,int ans=0) {\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        pair<int,int> p={1e9+7,1e9};\\n        for(int i=1;i<n;i++){\\n            int dx=v[i][0]-v[i-1][0],dy=v[i][1]-v[i-1][1];\\n            int gcd=__gcd(dx,dy);\\n            dx/=gcd,dy/=gcd;\\n            pair<int,int> pp={dx,dy};\\n            if(pp!=p)ans++,p=pp;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    typedef long double ld;\\n    int minimumLines(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end());\\n        ld slope=1e9+7,n=v.size();\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            ld s=(v[i][1]-v[i-1][1])/(ld(v[i][0]-v[i-1][0]));\\n            if(s!=slope)ans++,slope=s;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897844,
                "title": "simple-using-slope-similarity-condition-beats-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a,vector<int> &b)\\n    {\\n        return (a[0]<b[0]);\\n    }\\n    pair<int,int> standard(vector<int> &a,vector<int> &b)\\n    {\\n        bool neg;\\n        int num = b[1]-a[1];\\n        int den = b[0]-a[0];\\n        if((num>=0 && den>0) || (num<=0 && den<0))neg = false;\\n        else\\n        {\\n            neg = true;\\n        }\\n\\n        int gcd = __gcd(abs(num),abs(den));\\n        num = num/gcd;\\n        den = den/gcd;\\n        den = abs(den);\\n        num = abs(num);\\n\\n        //pair<int,int> ans;\\n        (neg==true)?num=num*-1:num = num;\\n        return make_pair(num,den);\\n    }\\n    int minimumLines(vector<vector<int>>& stock) {\\n        int lines=1;\\n        int len = stock.size();\\n        if(len==1)return 0;\\n        if(len==2)return 1;\\n        sort(stock.begin(),stock.end(),comp);\\n        pair<int,int> currslope = standard(stock[0],stock[1]);\\n\\n        for(int i=2;i<stock.size();)\\n        {\\n            pair<int,int> slope = standard(stock[i-1],stock[i]);\\n            if((slope.first==currslope.first && slope.first==0)||(slope.first==currslope.first && slope.second==currslope.second))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                lines++;\\n                currslope.first = slope.first;\\n                currslope.second = slope.second;\\n                i++;\\n            }\\n        }\\n        return lines;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a,vector<int> &b)\\n    {\\n        return (a[0]<b[0]);\\n    }\\n    pair<int,int> standard(vector<int> &a,vector<int> &b)\\n    {\\n        bool neg;\\n        int num = b[1]-a[1];\\n        int den = b[0]-a[0];\\n        if((num>=0 && den>0) || (num<=0 && den<0))neg = false;\\n        else\\n        {\\n            neg = true;\\n        }\\n\\n        int gcd = __gcd(abs(num),abs(den));\\n        num = num/gcd;\\n        den = den/gcd;\\n        den = abs(den);\\n        num = abs(num);\\n\\n        //pair<int,int> ans;\\n        (neg==true)?num=num*-1:num = num;\\n        return make_pair(num,den);\\n    }\\n    int minimumLines(vector<vector<int>>& stock) {\\n        int lines=1;\\n        int len = stock.size();\\n        if(len==1)return 0;\\n        if(len==2)return 1;\\n        sort(stock.begin(),stock.end(),comp);\\n        pair<int,int> currslope = standard(stock[0],stock[1]);\\n\\n        for(int i=2;i<stock.size();)\\n        {\\n            pair<int,int> slope = standard(stock[i-1],stock[i]);\\n            if((slope.first==currslope.first && slope.first==0)||(slope.first==currslope.first && slope.second==currslope.second))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                lines++;\\n                currslope.first = slope.first;\\n                currslope.second = slope.second;\\n                i++;\\n            }\\n        }\\n        return lines;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428994,
                "title": "c-solution-using-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& arr) {\\n        if(arr.size()==1) return 0; \\n        sort(begin(arr),end(arr));\\n        int n = arr.size();\\n        int ct=1;\\n\\n        for(int i=1;i<n-1;i++){\\n            int x1=arr[i-1][0];\\n            int y1=arr[i-1][1];\\n            \\n            int x2=arr[i][0];\\n            int y2=arr[i][1];\\n            \\n            int x3=arr[i+1][0];\\n            int y3=arr[i+1][1];\\n            \\n            long long slope1 = 1ll*(y2-y1)*(x3-x2);\\n            long long slope2 = 1ll*(y3-y2)*(x2-x1);\\n            \\n            if(slope1!=slope2) ct++;\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& arr) {\\n        if(arr.size()==1) return 0; \\n        sort(begin(arr),end(arr));\\n        int n = arr.size();\\n        int ct=1;\\n\\n        for(int i=1;i<n-1;i++){\\n            int x1=arr[i-1][0];\\n            int y1=arr[i-1][1];\\n            \\n            int x2=arr[i][0];\\n            int y2=arr[i][1];\\n            \\n            int x3=arr[i+1][0];\\n            int y3=arr[i+1][1];\\n            \\n            long long slope1 = 1ll*(y2-y1)*(x3-x2);\\n            long long slope2 = 1ll*(y3-y2)*(x2-x1);\\n            \\n            if(slope1!=slope2) ct++;\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029769,
                "title": "java-solution",
                "content": "# Intuition\\nLine equation \\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        // Since on every day price will be different.\\n        Arrays.sort(stockPrices, (a,b) -> {\\n        return Integer.compare(a[0], b[0]);\\n        } );\\n        int x1 = stockPrices[0][0];\\n        int y1 = stockPrices[0][1];\\n        int lines = 0;\\n        int i = 1;\\n        int n = stockPrices.length;\\n        while(i < n){\\n            int x2 = stockPrices[i][0];\\n            int y2 = stockPrices[i][1];\\n            while(i+1 < n && (x2 - stockPrices[i+1][0])*(y2-y1) == (x2 - x1)*(y2 -stockPrices[i+1][1] )){\\n                i++;\\n            }\\n            x1 = stockPrices[i][0] ;\\n            y1 = stockPrices[i][1];\\n            i++;\\n            lines++;\\n        }\\n        return lines;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        // Since on every day price will be different.\\n        Arrays.sort(stockPrices, (a,b) -> {\\n        return Integer.compare(a[0], b[0]);\\n        } );\\n        int x1 = stockPrices[0][0];\\n        int y1 = stockPrices[0][1];\\n        int lines = 0;\\n        int i = 1;\\n        int n = stockPrices.length;\\n        while(i < n){\\n            int x2 = stockPrices[i][0];\\n            int y2 = stockPrices[i][1];\\n            while(i+1 < n && (x2 - stockPrices[i+1][0])*(y2-y1) == (x2 - x1)*(y2 -stockPrices[i+1][1] )){\\n                i++;\\n            }\\n            x1 = stockPrices[i][0] ;\\n            y1 = stockPrices[i][1];\\n            i++;\\n            lines++;\\n        }\\n        return lines;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218825,
                "title": "java-o-n-slope-check",
                "content": "```\\n public int minimumLines(int[][] sp) {\\n        /*            \\n             y3-y2    y2-y1\\n            ------- = -------\\n             x3-x2    x2-x1\\n        */\\n        Arrays.sort(sp, (a,b) -> a[0]-b[0]);\\n        int n = sp.length;\\n        if(n==1) return 0;\\n        int cnt = 1;\\n        for(int i = 0; i+2 < n ; i ++) {\\n            int dx2x1 =  sp[i+1][0] - sp[i][0];\\n            int dx3x2 =  sp[i+2][0] - sp[i+1][0];\\n            int dy2y1 =  sp[i+1][1] - sp[i][1];\\n            int dy3y2 =  sp[i+2][1] - sp[i+1][1];\\n            \\n            if(dy3y2 * dx2x1 != dy2y1 * dx3x2)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int minimumLines(int[][] sp) {\\n        /*            \\n             y3-y2    y2-y1\\n            ------- = -------\\n             x3-x2    x2-x1\\n        */\\n        Arrays.sort(sp, (a,b) -> a[0]-b[0]);\\n        int n = sp.length;\\n        if(n==1) return 0;\\n        int cnt = 1;\\n        for(int i = 0; i+2 < n ; i ++) {\\n            int dx2x1 =  sp[i+1][0] - sp[i][0];\\n            int dx3x2 =  sp[i+2][0] - sp[i+1][0];\\n            int dy2y1 =  sp[i+1][1] - sp[i][1];\\n            int dy3y2 =  sp[i+2][1] - sp[i+1][1];\\n            \\n            if(dy3y2 * dx2x1 != dy2y1 * dx3x2)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2167752,
                "title": "c-easy-solution-w-math-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int cnt=1;\\n        if(arr.size()==1){\\n            return 0;\\n        }\\n        for(int i=2;i<arr.size();i++){\\n            long x1 = arr[i-2][0],y1 = arr[i-2][1];\\n            long x2 = arr[i-1][0],y2 = arr[i-1][1];\\n            long x3 = arr[i][0],y3 = arr[i][1];\\n            \\n            long diff1 = (y2-y1)*(x3-x2); //avoid finding individual slope with division to avoid floating point errors\\n            long diff2 = (y3-y2)*(x2-x1);\\n            if(diff1!=diff2){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int cnt=1;\\n        if(arr.size()==1){\\n            return 0;\\n        }\\n        for(int i=2;i<arr.size();i++){\\n            long x1 = arr[i-2][0],y1 = arr[i-2][1];\\n            long x2 = arr[i-1][0],y2 = arr[i-1][1];\\n            long x3 = arr[i][0],y3 = arr[i][1];\\n            \\n            long diff1 = (y2-y1)*(x3-x2); //avoid finding individual slope with division to avoid floating point errors\\n            long diff2 = (y3-y2)*(x2-x1);\\n            if(diff1!=diff2){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068734,
                "title": "c-easy-solution-just-use-long-double",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& v) {\\n        vector<long double> a;\\n        sort(v.begin(),v.end());\\n        if(v.size()==1) return 0;\\n        if(v.size()==2) return 1;\\n        int n=v.size();\\n        for(int i=0;i<n-1;i++){\\n            long double d=v[i+1][0]-v[i][0];\\n            long double c=v[i+1][1]-v[i][1];\\n            a.push_back(c/d);\\n            //cout<<a[i]<<\" \";\\n        }\\n        int ct=1;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i]!=a[i-1])\\n                ct++;\\n        }\\n        return ct;\\n    }\\n};\\n** the culprit is [[1,1],[500000000,499999999],[1000000000,999999998]]**\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& v) {\\n        vector<long double> a;\\n        sort(v.begin(),v.end());\\n        if(v.size()==1) return 0;\\n        if(v.size()==2) return 1;\\n        int n=v.size();\\n        for(int i=0;i<n-1;i++){\\n            long double d=v[i+1][0]-v[i][0];\\n            long double c=v[i+1][1]-v[i][1];\\n            a.push_back(c/d);\\n            //cout<<a[i]<<\" \";\\n        }\\n        int ct=1;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i]!=a[i-1])\\n                ct++;\\n        }\\n        return ct;\\n    }\\n};\\n** the culprit is [[1,1],[500000000,499999999],[1000000000,999999998]]**\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2062398,
                "title": "very-annoying-math-problem",
                "content": "This problem is very much intuitive. Basically comparing the previous slope to the next point pair slope. [[1,1],[500000000,499999999],[1000000000,999999998]] this testcase was quite annoying T_T. Used long double for rectification.\\n\\n````\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& mat) {\\n        \\n        int n = mat.size();\\n        \\n        sort(begin(mat),end(mat),[](vector<int>& a,vector<int>& b)\\n             {\\n                 return a[0]<b[0];\\n             });\\n        \\n        int cnt = 0;\\n        long double prev;\\n        \\n        for(int i=1;i<n;i++)\\n        {    \\n            long double sl = (long double)(mat[i][1] - mat[i-1][1])/(long double)(mat[i][0] - mat[i-1][0]);\\n            \\n            if(i==1 or prev!=sl)\\n            {\\n                prev=sl;\\n                cnt++;\\n            }\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& mat) {\\n        \\n        int n = mat.size();\\n        \\n        sort(begin(mat),end(mat),[](vector<int>& a,vector<int>& b)\\n             {\\n                 return a[0]<b[0];\\n             });\\n        \\n        int cnt = 0;\\n        long double prev;\\n        \\n        for(int i=1;i<n;i++)\\n        {    \\n            long double sl = (long double)(mat[i][1] - mat[i-1][1])/(long double)(mat[i][0] - mat[i-1][0]);\\n            \\n            if(i==1 or prev!=sl)\\n            {\\n                prev=sl;\\n                cnt++;\\n            }\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062362,
                "title": "simple-c-solution",
                "content": "Check Slope for consecutive points and keep track of unequal slopes \\nSorting is done as we need min ans.\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& s) {\\n        if(s.size()==1)return 0;\\n        int ans = 1;\\n        int n = s.size();\\n        sort(s.begin(),s.end());\\n        double slope = (s[1][1]-s[0][1])/(s[1][0] - s[0][0]);\\n        for(int i = 2;i<n;i++){\\n            double m = s[i][1] - s[i-1][1];\\n            double p = s[i][0] - s[i-1][0];\\n            \\n            if(p!=0)m= m/p;\\n            if(m!=slope){\\n                ans++;\\n                slope = m;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& s) {\\n        if(s.size()==1)return 0;\\n        int ans = 1;\\n        int n = s.size();\\n        sort(s.begin(),s.end());\\n        double slope = (s[1][1]-s[0][1])/(s[1][0] - s[0][0]);\\n        for(int i = 2;i<n;i++){\\n            double m = s[i][1] - s[i-1][1];\\n            double p = s[i][0] - s[i-1][0];\\n            \\n            if(p!=0)m= m/p;\\n            if(m!=slope){\\n                ans++;\\n                slope = m;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062275,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} stockPrices\\n * @return {number}\\n */\\nvar minimumLines = function(stockPrices) {\\n    if(stockPrices.length===1){//its a dot (.) or point, so no line required\\n        return 0;\\n    }\\n    stockPrices.sort(function(a,b){return a[0]-b[0]});//Sorting is important becuase there can be 2 overlaping lines\\n    let count = 1;\\n    for(let i=2;i<stockPrices.length;i++){\\n        let x1 = BigInt(stockPrices[i-2][0]);\\n        let x2 = BigInt(stockPrices[i-1][0]);\\n        let x3 = BigInt(stockPrices[i][0]);\\n        let y1 = BigInt(stockPrices[i-2][1]);\\n        let y2 = BigInt(stockPrices[i-1][1]);\\n        let y3 = BigInt(stockPrices[i][1]);\\n        if((y2-y1)*(x3-x2)!==(y3-y2)*(x2-x1)){//as  (y3-y2)/(x3-x2) = (y2-y1)/(x2-x1) for same slope \\n            count ++;\\n        }\\n        \\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} stockPrices\\n * @return {number}\\n */\\nvar minimumLines = function(stockPrices) {\\n    if(stockPrices.length===1){//its a dot (.) or point, so no line required\\n        return 0;\\n    }\\n    stockPrices.sort(function(a,b){return a[0]-b[0]});//Sorting is important becuase there can be 2 overlaping lines\\n    let count = 1;\\n    for(let i=2;i<stockPrices.length;i++){\\n        let x1 = BigInt(stockPrices[i-2][0]);\\n        let x2 = BigInt(stockPrices[i-1][0]);\\n        let x3 = BigInt(stockPrices[i][0]);\\n        let y1 = BigInt(stockPrices[i-2][1]);\\n        let y2 = BigInt(stockPrices[i-1][1]);\\n        let y3 = BigInt(stockPrices[i][1]);\\n        if((y2-y1)*(x3-x2)!==(y3-y2)*(x2-x1)){//as  (y3-y2)/(x3-x2) = (y2-y1)/(x2-x1) for same slope \\n            count ++;\\n        }\\n        \\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062013,
                "title": "using-slope-and-use-of-long-double",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& st) {\\n        sort(st.begin(),st.end());\\n        long double z=2147483647;\\n        int ans=0;\\n        for(int i=0;i<st.size()-1;i++)\\n        {\\n            long double a=(long double)(st[i+1][1]-st[i][1]),b=(long double)(st[i+1][0]-st[i][0]);\\n            long double x=a/b;\\n            if(x!=z)\\n            {\\n                ans++;\\n                z=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& st) {\\n        sort(st.begin(),st.end());\\n        long double z=2147483647;\\n        int ans=0;\\n        for(int i=0;i<st.size()-1;i++)\\n        {\\n            long double a=(long double)(st[i+1][1]-st[i][1]),b=(long double)(st[i+1][0]-st[i][0]);\\n            long double x=a/b;\\n            if(x!=z)\\n            {\\n                ans++;\\n                z=x;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2061852,
                "title": "o-nlogn-solution-do-what-question-says",
                "content": "* Intuition is to just check if current point is on the same line as formed by last two points i.e. all 3 points lie on the same line.\\n* To check if they are on same line we can just compute and validate that they have same slope.\\n* If 3 points are (a,b),(c,d),(e,f), slope is same if `((f-d)/(e-c)) == ((d-b)/(c-a))`\\n* **Trick is not to get lost in the precision of double while computing slope.**\\n* How? - Same check can also be written as `((f-d)*(c-a))==((d-b)*(e-c))`\\n* **Next catch is to not let interger multiplication overflow. Hence use long long.**\\n* Answer would be how many points don\\'t have same slope as last 2 points.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        \\n        int n = stockPrices.size();\\n        \\n        //for a point there is no line.\\n        if(n==1) return 0;\\n        \\n        //for 2 points there can only be one line.\\n        if(n==2) return 1;\\n        \\n        //sort by X axis points.\\n        sort(stockPrices.begin(),stockPrices.end());\\n        \\n        //since number of points > 2, there will always be atleast one line.\\n        int ans = 1;\\n\\n        // check if 3 points lie on the same line. Slope should be the same.\\n        // trick is not to get lost in the precision of double.\\n        // If 3 points are (a,b),(c,d),(e,f) slope is same if ((f-d)/(e-c)) == ((d-b)/(c-a))\\n        // this can also be written as ((f-d)*(c-a))==((d-b)*(e-c))\\n        // next catch is to not overflow int hence use 1LL to multiply.\\n        // just count how many points don\\'t have same slope as last 2 points.\\n        for(int i=2;i<n;i++) {\\n            vector<int> xy3 = stockPrices[i],xy2 = stockPrices[i-1],xy1 = stockPrices[i-2];\\n            if((xy2[0]-xy1[0])*1LL*(xy3[1]-xy2[1])!=(xy3[0]-xy2[0])*1LL*(xy2[1]-xy1[1])) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        \\n        int n = stockPrices.size();\\n        \\n        //for a point there is no line.\\n        if(n==1) return 0;\\n        \\n        //for 2 points there can only be one line.\\n        if(n==2) return 1;\\n        \\n        //sort by X axis points.\\n        sort(stockPrices.begin(),stockPrices.end());\\n        \\n        //since number of points > 2, there will always be atleast one line.\\n        int ans = 1;\\n\\n        // check if 3 points lie on the same line. Slope should be the same.\\n        // trick is not to get lost in the precision of double.\\n        // If 3 points are (a,b),(c,d),(e,f) slope is same if ((f-d)/(e-c)) == ((d-b)/(c-a))\\n        // this can also be written as ((f-d)*(c-a))==((d-b)*(e-c))\\n        // next catch is to not overflow int hence use 1LL to multiply.\\n        // just count how many points don\\'t have same slope as last 2 points.\\n        for(int i=2;i<n;i++) {\\n            vector<int> xy3 = stockPrices[i],xy2 = stockPrices[i-1],xy1 = stockPrices[i-2];\\n            if((xy2[0]-xy1[0])*1LL*(xy3[1]-xy2[1])!=(xy3[0]-xy2[0])*1LL*(xy2[1]-xy1[1])) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061827,
                "title": "python-simple-solution-easy-to-understand-logic-sorting",
                "content": "```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        if len(stockPrices) == 1:\\n            return 0\\n        stockPrices.sort(key = lambda x: x[0])\\n        ans = 1\\n        for i in range(1,len(stockPrices)-1):\\n            if (stockPrices[i+1][1]-stockPrices[i][1])*(stockPrices[i][0]-stockPrices[i-1][0]) != (stockPrices[i+1][0]-stockPrices[i][0])*(stockPrices[i][1]-stockPrices[i-1][1]):\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        if len(stockPrices) == 1:\\n            return 0\\n        stockPrices.sort(key = lambda x: x[0])\\n        ans = 1\\n        for i in range(1,len(stockPrices)-1):\\n            if (stockPrices[i+1][1]-stockPrices[i][1])*(stockPrices[i][0]-stockPrices[i-1][0]) != (stockPrices[i+1][0]-stockPrices[i][0])*(stockPrices[i][1]-stockPrices[i-1][1]):\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061810,
                "title": "last-and-current-slope-simple-math",
                "content": "<br>\\n\\n**Idea:**\\n\\n* If a line has slope m, then for a new point to be in straight line as the line, it should have slope equal to m with that line.\\n* We need a new line each time when a point cannot be in straight line.\\n* So, we calculate last_slope (slope of the line) and cur_slope (slope if we add new point to the straight line) and if both are not equal then we need a new line.\\n<br>\\n\\n**Formula:**\\nslope = (y2 - y1) / (x2 - x1)\\n\\n\\n**C++ code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        \\n        int n = sp.size();\\n        sort(sp.begin(), sp.end());\\n        long double last_slope = LONG_MIN;\\n        int lines = 0;\\n        \\n        for(int i = 0; i < n-1; i++)\\n        {\\n            long double x = (sp[i+1][0] - sp[i][0]);\\n            long double y = (sp[i+1][1] - sp[i][1]);\\n            long double cur_slope = y / x;\\n            if(last_slope == cur_slope) continue;\\n            else {\\n                lines++;\\n                last_slope = cur_slope;\\n            }\\n        }\\n        \\n        return lines;\\n    }\\n};\\n```\\n\\n<br>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        \\n        int n = sp.size();\\n        sort(sp.begin(), sp.end());\\n        long double last_slope = LONG_MIN;\\n        int lines = 0;\\n        \\n        for(int i = 0; i < n-1; i++)\\n        {\\n            long double x = (sp[i+1][0] - sp[i][0]);\\n            long double y = (sp[i+1][1] - sp[i][1]);\\n            long double cur_slope = y / x;\\n            if(last_slope == cur_slope) continue;\\n            else {\\n                lines++;\\n                last_slope = cur_slope;\\n            }\\n        }\\n        \\n        return lines;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061785,
                "title": "java-check-all-three-ponits-pair",
                "content": "Point `a`, `b`, `c` on the same line iff point `a`, `b` and `b`, `c` with same slope.\\n\\n```\\nSlope of a and b: (b[1] - a[1]) / (b[0] - a[0])\\nSlope of b and c: (c[1] - b[1]) / (c[0] - b[0])\\n```\\n\\nTo avoid **float number precision loss**, we should use multiple.\\n```\\n(b[1] - a[1]) * (c[0] - b[0]) == (b[0] - a[0]) * (c[1] - b[1])\\n```\\n\\nTime: O(NlogN)\\nSpace: O(1)\\n\\n```\\nclass Solution {\\n  public int minimumLines(int[][] stockPrices) {\\n    final int n = stockPrices.length;\\n    if (n < 2) {\\n      return 0;\\n    }\\n    // sort by date\\n    Arrays.sort(stockPrices, Comparator.comparingInt(a -> a[0]));\\n    int count = 1;\\n    for (int i = 2; i < n; i++) {\\n      int[] a = stockPrices[i - 2];\\n      int[] b = stockPrices[i - 1];\\n      int[] c = stockPrices[i];\\n      // check three point on one line\\n      if ((long) (b[1] - a[1]) * (c[0] - b[0]) != (long) (b[0] - a[0]) * (c[1] - b[1])) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nSlope of a and b: (b[1] - a[1]) / (b[0] - a[0])\\nSlope of b and c: (c[1] - b[1]) / (c[0] - b[0])\\n```\n```\\n(b[1] - a[1]) * (c[0] - b[0]) == (b[0] - a[0]) * (c[1] - b[1])\\n```\n```\\nclass Solution {\\n  public int minimumLines(int[][] stockPrices) {\\n    final int n = stockPrices.length;\\n    if (n < 2) {\\n      return 0;\\n    }\\n    // sort by date\\n    Arrays.sort(stockPrices, Comparator.comparingInt(a -> a[0]));\\n    int count = 1;\\n    for (int i = 2; i < n; i++) {\\n      int[] a = stockPrices[i - 2];\\n      int[] b = stockPrices[i - 1];\\n      int[] c = stockPrices[i];\\n      // check three point on one line\\n      if ((long) (b[1] - a[1]) * (c[0] - b[0]) != (long) (b[0] - a[0]) * (c[1] - b[1])) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709501,
                "title": "sorting-and-slope",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>> &stockPrices)\\n{\\n    int n = stockPrices.size();\\n    if(n == 1) {\\n        return 0;\\n    }\\n    sort(stockPrices.begin(), stockPrices.end());\\n\\n    long double x1 = 1.0 * stockPrices[0][0];\\n    long double y1 = 1.0 * stockPrices[0][1];\\n    long double x2 = 1.0 * stockPrices[1][0];\\n    long double y2 = 1.0 * stockPrices[1][1];\\n    int count = 1;\\n    long double slope;\\n\\n    if (y2 - y1 == 0.0)\\n    {\\n        slope = 1e9;\\n    }\\n    else\\n    {\\n        slope = (y2 - y1) / (x2 - x1);\\n    }\\n\\n    for (int i = 2; i < n; i++)\\n    {\\n        long double x1 = 1.0 * stockPrices[i][0];\\n        long double y1 = 1.0 * stockPrices[i][1];\\n        long double x2 = 1.0 * stockPrices[i - 1][0];\\n        long double y2 = 1.0 * stockPrices[i - 1][1];\\n        long double currslope;\\n\\n        if (y2 - y1 == 0.0)\\n        {\\n            currslope = 1e9;\\n        }\\n        else\\n        {\\n            currslope = (y2 - y1) / (x2 - x1);\\n        }\\n\\n        if (currslope != slope)\\n        {\\n            count++;\\n            slope = currslope;\\n        }\\n    }\\n    return count;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>> &stockPrices)\\n{\\n    int n = stockPrices.size();\\n    if(n == 1) {\\n        return 0;\\n    }\\n    sort(stockPrices.begin(), stockPrices.end());\\n\\n    long double x1 = 1.0 * stockPrices[0][0];\\n    long double y1 = 1.0 * stockPrices[0][1];\\n    long double x2 = 1.0 * stockPrices[1][0];\\n    long double y2 = 1.0 * stockPrices[1][1];\\n    int count = 1;\\n    long double slope;\\n\\n    if (y2 - y1 == 0.0)\\n    {\\n        slope = 1e9;\\n    }\\n    else\\n    {\\n        slope = (y2 - y1) / (x2 - x1);\\n    }\\n\\n    for (int i = 2; i < n; i++)\\n    {\\n        long double x1 = 1.0 * stockPrices[i][0];\\n        long double y1 = 1.0 * stockPrices[i][1];\\n        long double x2 = 1.0 * stockPrices[i - 1][0];\\n        long double y2 = 1.0 * stockPrices[i - 1][1];\\n        long double currslope;\\n\\n        if (y2 - y1 == 0.0)\\n        {\\n            currslope = 1e9;\\n        }\\n        else\\n        {\\n            currslope = (y2 - y1) / (x2 - x1);\\n        }\\n\\n        if (currslope != slope)\\n        {\\n            count++;\\n            slope = currslope;\\n        }\\n    }\\n    return count;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644903,
                "title": "python-easy-solution-cross-product",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        stockPrices.sort()\\n        line=1\\n        if len(stockPrices)==1:\\n            return 0\\n        for i in range(1,len(stockPrices)-1):\\n            if (stockPrices[i][1]-stockPrices[i-1][1])*(stockPrices[i+1][0]-stockPrices[i][0])!=(stockPrices[i+1][1]-stockPrices[i][1])*(stockPrices[i][0]-stockPrices[i-1][0]):\\n                line+=1\\n        return line\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        stockPrices.sort()\\n        line=1\\n        if len(stockPrices)==1:\\n            return 0\\n        for i in range(1,len(stockPrices)-1):\\n            if (stockPrices[i][1]-stockPrices[i-1][1])*(stockPrices[i+1][0]-stockPrices[i][0])!=(stockPrices[i+1][1]-stockPrices[i][1])*(stockPrices[i][0]-stockPrices[i-1][0]):\\n                line+=1\\n        return line\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516639,
                "title": "c-easy-solution-math-geometry-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* Check Colinearity of two points. If two or more points are colinear then they must be existing in same slope, and the Slope count will be 1 for it.\\n\\n# Complexity\\n- Time complexity: $$O(NLogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Create a new Function to get the slope.\\n    vector<int> getSlope(vector<vector<int>>& stockPrices, int i){\\n        // Using the formula (y2-y1), (x2-x1) for getting the \\n        // numerator & denominator of the slope formula.\\n        return {stockPrices[i][1]-stockPrices[i-1][1], stockPrices[i][0]-stockPrices[i-1][0]};\\n    }\\n\\n    int minimumLines(vector<vector<int>>& stocks) {\\n        // for single stock.\\n        if(stocks.size() == 1){\\n            return 0;\\n        }\\n        // sort the stocks\\n        sort(stocks.begin(), stocks.end());\\n        \\n        // get previous slope using the 0th & 1st points.\\n        vector<int> prevSlope = getSlope(stocks, 1);\\n        int ans = 1;\\n        // now start from 3rd index i.e i=2.\\n        for(int i=2;i<stocks.size();i++){\\n            // get the slope of 1st & 2nd index.\\n            vector<int> slope = getSlope(stocks, i);\\n\\n            // check the equality of two slopes. If not equal then..\\n            if((long long int)slope[0] * prevSlope[1] != (long long int)slope[1] * prevSlope[0]){\\n                // update the prevSlope to current slope & \\n                // increment the answer by 1.\\n                prevSlope = slope;\\n                ans++;\\n            }\\n        }\\n        // return answer;\\n        return ans;\\n    }\\n};\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/574f1112-532e-4bdc-8f72-ba1bcc9a6b15_1683905064.8640454.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Geometry",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Create a new Function to get the slope.\\n    vector<int> getSlope(vector<vector<int>>& stockPrices, int i){\\n        // Using the formula (y2-y1), (x2-x1) for getting the \\n        // numerator & denominator of the slope formula.\\n        return {stockPrices[i][1]-stockPrices[i-1][1], stockPrices[i][0]-stockPrices[i-1][0]};\\n    }\\n\\n    int minimumLines(vector<vector<int>>& stocks) {\\n        // for single stock.\\n        if(stocks.size() == 1){\\n            return 0;\\n        }\\n        // sort the stocks\\n        sort(stocks.begin(), stocks.end());\\n        \\n        // get previous slope using the 0th & 1st points.\\n        vector<int> prevSlope = getSlope(stocks, 1);\\n        int ans = 1;\\n        // now start from 3rd index i.e i=2.\\n        for(int i=2;i<stocks.size();i++){\\n            // get the slope of 1st & 2nd index.\\n            vector<int> slope = getSlope(stocks, i);\\n\\n            // check the equality of two slopes. If not equal then..\\n            if((long long int)slope[0] * prevSlope[1] != (long long int)slope[1] * prevSlope[0]){\\n                // update the prevSlope to current slope & \\n                // increment the answer by 1.\\n                prevSlope = slope;\\n                ans++;\\n            }\\n        }\\n        // return answer;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045180,
                "title": "java-using-gcd-sorting",
                "content": "```Please upvote, if you find it useful```\\n\\n# Code\\n```\\npublic class Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if(stockPrices.length<=1) return 0;\\n        if(stockPrices.length==2) return 1;\\n\\n        int count = 1;\\n\\n        int[] prevPercent = new int[2];\\n        int[] currPercent = new int[2];\\n\\n        sortByXAxis(stockPrices);\\n\\n        prevPercent = getPercent(stockPrices[0], stockPrices[1]);\\n\\n        for (int i = 1; i < stockPrices.length - 1; i++) {\\n\\n            currPercent = getPercent(stockPrices[i], stockPrices[i + 1]);\\n            \\n            if (prevPercent[0] != currPercent[0]\\n                    || prevPercent[1] != currPercent[1]) {\\n                count++;\\n                prevPercent = currPercent;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    \\n    public int[] getPercent(int[] point1, int[] point2) {\\n        int gcd = gcd(point2[0] - point1[0], point2[1] - point1[1]);\\n        return new int[]{\\n                (point2[0] - point1[0]) / gcd,\\n                (point2[1] - point1[1]) / gcd\\n        };\\n    }\\n    \\n    //finds greatest common devisor of two number\\n    public int gcd(int x, int y) {\\n        if (x == 0)\\n            return y;\\n        return gcd(y % x, x);\\n    }\\n    \\n    //sorts 2D array by 0-index\\n    public void sortByXAxis(int[][] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            for (int j = i + 1; j < arr.length; j++) {\\n                int[] tmp = new int[2];\\n                if (arr[i][0] > arr[j][0]) {\\n                    tmp = arr[i];\\n                    arr[i] = arr[j];\\n                    arr[j] = tmp;\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Please upvote, if you find it useful```\n```\\npublic class Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if(stockPrices.length<=1) return 0;\\n        if(stockPrices.length==2) return 1;\\n\\n        int count = 1;\\n\\n        int[] prevPercent = new int[2];\\n        int[] currPercent = new int[2];\\n\\n        sortByXAxis(stockPrices);\\n\\n        prevPercent = getPercent(stockPrices[0], stockPrices[1]);\\n\\n        for (int i = 1; i < stockPrices.length - 1; i++) {\\n\\n            currPercent = getPercent(stockPrices[i], stockPrices[i + 1]);\\n            \\n            if (prevPercent[0] != currPercent[0]\\n                    || prevPercent[1] != currPercent[1]) {\\n                count++;\\n                prevPercent = currPercent;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    \\n    public int[] getPercent(int[] point1, int[] point2) {\\n        int gcd = gcd(point2[0] - point1[0], point2[1] - point1[1]);\\n        return new int[]{\\n                (point2[0] - point1[0]) / gcd,\\n                (point2[1] - point1[1]) / gcd\\n        };\\n    }\\n    \\n    //finds greatest common devisor of two number\\n    public int gcd(int x, int y) {\\n        if (x == 0)\\n            return y;\\n        return gcd(y % x, x);\\n    }\\n    \\n    //sorts 2D array by 0-index\\n    public void sortByXAxis(int[][] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            for (int j = i + 1; j < arr.length; j++) {\\n                int[] tmp = new int[2];\\n                if (arr[i][0] > arr[j][0]) {\\n                    tmp = arr[i];\\n                    arr[i] = arr[j];\\n                    arr[j] = tmp;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035112,
                "title": "simple-c-solution-using-slope",
                "content": "# Intuition\\nIF SLOPE OF LINE CHANGES MEANS THERE IS A NEW LINE\\n\\n# Complexity\\n- Time complexity:\\n$$O(Nlog(N))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int lines = 1;\\n        if(stockPrices.size()<2)\\n            return 0;\\n        sort(stockPrices.begin(),stockPrices.end());\\n        long dx = stockPrices[1][0]-stockPrices[0][0];\\n        long dy = stockPrices[1][1]-stockPrices[0][1];\\n\\n        for(int i=2;i<stockPrices.size();i++){\\n            long new_dx = stockPrices[i][0]-stockPrices[i-1][0];\\n            long new_dy = stockPrices[i][1]-stockPrices[i-1][1];\\n\\n            if(new_dy * dx != new_dx * dy){\\n                dx = new_dx;\\n                dy = new_dy;\\n                lines++;\\n            }\\n        }\\n        return lines;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int lines = 1;\\n        if(stockPrices.size()<2)\\n            return 0;\\n        sort(stockPrices.begin(),stockPrices.end());\\n        long dx = stockPrices[1][0]-stockPrices[0][0];\\n        long dy = stockPrices[1][1]-stockPrices[0][1];\\n\\n        for(int i=2;i<stockPrices.size();i++){\\n            long new_dx = stockPrices[i][0]-stockPrices[i-1][0];\\n            long new_dy = stockPrices[i][1]-stockPrices[i-1][1];\\n\\n            if(new_dy * dx != new_dx * dy){\\n                dx = new_dx;\\n                dy = new_dy;\\n                lines++;\\n            }\\n        }\\n        return lines;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959155,
                "title": "slope-of-a-line",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSlope of a line:- y2-y1/x2-x1\\nStore the value of slope in an array \\nIf size of array is less than or equal to one than ans is 0.\\nOtherwise-> Initialize the value of count=1,\\nIf two adjacent values of an array are equal than count++.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minimumLines(vector<vector<int>> &stockPrices)\\n    {\\n        sort(stockPrices.begin(), stockPrices.end());\\n        int n = stockPrices.size();\\n        if (stockPrices.size() <= 1)\\n        {\\n            return 0;\\n        }\\n        int count = 1;\\n        vector<long double> arr;\\n        for (int i = 1; i < n; i++)\\n        {\\n            long double x = stockPrices[i][0] - stockPrices[i - 1][0];\\n            long double y = stockPrices[i][1] - stockPrices[i - 1][1];\\n            arr.push_back(y / x);\\n        }\\n        for (int i = 0; i < arr.size() - 1; i++)\\n        {\\n            if (arr[i] != arr[i + 1])\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minimumLines(vector<vector<int>> &stockPrices)\\n    {\\n        sort(stockPrices.begin(), stockPrices.end());\\n        int n = stockPrices.size();\\n        if (stockPrices.size() <= 1)\\n        {\\n            return 0;\\n        }\\n        int count = 1;\\n        vector<long double> arr;\\n        for (int i = 1; i < n; i++)\\n        {\\n            long double x = stockPrices[i][0] - stockPrices[i - 1][0];\\n            long double y = stockPrices[i][1] - stockPrices[i - 1][1];\\n            arr.push_back(y / x);\\n        }\\n        for (int i = 0; i < arr.size() - 1; i++)\\n        {\\n            if (arr[i] != arr[i + 1])\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859386,
                "title": "c-o-nlogn",
                "content": "```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        if (stockPrices.Length == 1)\\n        {\\n            return 0;\\n        }\\n\\n        var result = 1;\\n\\n        Array.Sort(stockPrices, (a, b) => a[0].CompareTo(b[0]));\\n\\n        for (int i = 1; i < stockPrices.Length - 1; i++)\\n        {\\n           if ((stockPrices[i][0] - stockPrices[i - 1][0]) * (stockPrices[i+1][1] - stockPrices[i][1]) !=\\n           (stockPrices[i+1][0] - stockPrices[i][0]) * (stockPrices[i][1] - stockPrices[i-1][1]))\\n           {\\n                result++;\\n           }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        if (stockPrices.Length == 1)\\n        {\\n            return 0;\\n        }\\n\\n        var result = 1;\\n\\n        Array.Sort(stockPrices, (a, b) => a[0].CompareTo(b[0]));\\n\\n        for (int i = 1; i < stockPrices.Length - 1; i++)\\n        {\\n           if ((stockPrices[i][0] - stockPrices[i - 1][0]) * (stockPrices[i+1][1] - stockPrices[i][1]) !=\\n           (stockPrices[i+1][0] - stockPrices[i][0]) * (stockPrices[i][1] - stockPrices[i-1][1]))\\n           {\\n                result++;\\n           }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461195,
                "title": "c-using-slope-concept-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumLines(vector<vector<int>>& s) {\\n        \\n        int ans=0;\\n        pair<int,int> pre(0,0);\\n        sort( s.begin(),s.end());\\n            \\n        for( int j=0;j<s.size()-1;j++){\\n               \\n            int dy= s[j+1][1]-s[j][1];\\n            int dx= s[j+1][0]-s[j][0];\\n            \\n            int g=__gcd(dy,dx);                \\n            pair< int,int> p=make_pair(dy/g,dx/g);\\n            if( pre!=p){\\n                ans++;\\n                pre=p;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumLines(vector<vector<int>>& s) {\\n        \\n        int ans=0;\\n        pair<int,int> pre(0,0);\\n        sort( s.begin(),s.end());\\n            \\n        for( int j=0;j<s.size()-1;j++){\\n               \\n            int dy= s[j+1][1]-s[j][1];\\n            int dx= s[j+1][0]-s[j][0];\\n            \\n            int g=__gcd(dy,dx);                \\n            pair< int,int> p=make_pair(dy/g,dx/g);\\n            if( pre!=p){\\n                ans++;\\n                pre=p;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375386,
                "title": "solution-using-slopes",
                "content": "```\\nclass Solution {\\n    vector<pair<int, int>> s;   \\n    int n;\\npublic:\\n    int minimumLines(vector<vector<int>>& stock) {\\n        n = stock.size();\\n        if(n == 1) return 0;\\n        for(auto &i: stock) {\\n            s.push_back({i[0], i[1]});\\n        }\\n        sort(s.begin(), s.end(), [](pair<int, int> A, pair<int, int> B) {\\n            return A.first < B.first;\\n        });\\n        vector<long double> slopes(n - 1, 0.0);\\n        for(int i = 0; i < n - 1; i++) {\\n            slopes[i] = (long double)(s[i].second - s[i+1].second)/(s[i].first - s[i+1].first);\\n        }\\n        int ans = 1;\\n        for(int i = 0; i < n - 2; i++) {\\n            if(slopes[i] != slopes[i + 1]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n__Observation__: All the continuous pair of points having the same slope values will have belong in the straight line. This is just that, if A and B lie in the same line and B and C line in the same line __with the same slope value__ then A and C also lie in the same line",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    vector<pair<int, int>> s;   \\n    int n;\\npublic:\\n    int minimumLines(vector<vector<int>>& stock) {\\n        n = stock.size();\\n        if(n == 1) return 0;\\n        for(auto &i: stock) {\\n            s.push_back({i[0], i[1]});\\n        }\\n        sort(s.begin(), s.end(), [](pair<int, int> A, pair<int, int> B) {\\n            return A.first < B.first;\\n        });\\n        vector<long double> slopes(n - 1, 0.0);\\n        for(int i = 0; i < n - 1; i++) {\\n            slopes[i] = (long double)(s[i].second - s[i+1].second)/(s[i].first - s[i+1].first);\\n        }\\n        int ans = 1;\\n        for(int i = 0; i < n - 2; i++) {\\n            if(slopes[i] != slopes[i + 1]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300009,
                "title": "leetcode-the-hard-way-detailed-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int n = stockPrices.size();\\n        // one point = no line\\n        if (n == 1) return 0;\\n        // > 1 point means at least one line\\n        long long ans = 1;\\n        // sort it first as it doesn\\'t mention it\\'s sorted\\n        // and we want to compare adjacent points\\n        sort(stockPrices.begin(), stockPrices.end());\\n        // slope = (y1 - y0) / (x1 - x0)\\n        // a line is needed when the slope is different\\n        // to check if the slope is same \\n        // use integer multiplcation instead of float dvision to avoid precision problem\\n        // hence, \\n        // slope1 = (y1 - y0) / (x1 - x0)\\n        // slope2 = (y2 - y1) / (x2 - x1)\\n        // slope1 = slope2 \\n        // (y1 - y0) / (x1 - x0) = (y2 - y1) / (x2 - x1)\\n        // (y1 - y0) * (x2 - x1) = (y2 - y1) * (x1 - x0)\\n\\n        // the slope for the first line\\n        long long prev_x = (stockPrices[1][0] - stockPrices[0][0]);\\n        long long prev_y = (stockPrices[1][1] - stockPrices[0][1]);\\n        for (int i = 1; i < n; i++) {\\n            long long cur_x = (stockPrices[i][0] - stockPrices[i - 1][0]);\\n            long long cur_y = (stockPrices[i][1] - stockPrices[i - 1][1]);\\n            // different slope -> need a new line\\n            if (cur_x * prev_y != cur_y * prev_x) {\\n                ans += 1;\\n            }\\n            // update prev_x & prev_y\\n            prev_x = cur_x;\\n            prev_y = cur_y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int n = stockPrices.size();\\n        // one point = no line\\n        if (n == 1) return 0;\\n        // > 1 point means at least one line\\n        long long ans = 1;\\n        // sort it first as it doesn\\'t mention it\\'s sorted\\n        // and we want to compare adjacent points\\n        sort(stockPrices.begin(), stockPrices.end());\\n        // slope = (y1 - y0) / (x1 - x0)\\n        // a line is needed when the slope is different\\n        // to check if the slope is same \\n        // use integer multiplcation instead of float dvision to avoid precision problem\\n        // hence, \\n        // slope1 = (y1 - y0) / (x1 - x0)\\n        // slope2 = (y2 - y1) / (x2 - x1)\\n        // slope1 = slope2 \\n        // (y1 - y0) / (x1 - x0) = (y2 - y1) / (x2 - x1)\\n        // (y1 - y0) * (x2 - x1) = (y2 - y1) * (x1 - x0)\\n\\n        // the slope for the first line\\n        long long prev_x = (stockPrices[1][0] - stockPrices[0][0]);\\n        long long prev_y = (stockPrices[1][1] - stockPrices[0][1]);\\n        for (int i = 1; i < n; i++) {\\n            long long cur_x = (stockPrices[i][0] - stockPrices[i - 1][0]);\\n            long long cur_y = (stockPrices[i][1] - stockPrices[i - 1][1]);\\n            // different slope -> need a new line\\n            if (cur_x * prev_y != cur_y * prev_x) {\\n                ans += 1;\\n            }\\n            // update prev_x & prev_y\\n            prev_x = cur_x;\\n            prev_y = cur_y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277225,
                "title": "python-hint",
                "content": "Intuitively we should be getting gradients of three points and compare, by right should pass all but due to python lack of precision it will fail 1 or 2 test, (not cuz the code is wrong but python starts to show inaccuracy with floats), hence to overcome it we can still use the gradient equation but we tweak that equation so we can avoid dividing.",
                "solutionTags": [
                    "Python"
                ],
                "code": "Intuitively we should be getting gradients of three points and compare, by right should pass all but due to python lack of precision it will fail 1 or 2 test, (not cuz the code is wrong but python starts to show inaccuracy with floats), hence to overcome it we can still use the gradient equation but we tweak that equation so we can avoid dividing.",
                "codeTag": "Unknown"
            },
            {
                "id": 2216245,
                "title": "c-pretty-simple",
                "content": "I avoided any operations which were lossy and only used ints.  You could have probably avoided the aux class easily enough.  It was a quick addition when I noticed the data wasn\\'t in order.  Technically, I haven\\'t proven that the intercepts are unchanged, but integer math makes that pretty unlikely.  If this was a real world problem you would have to use doubles and stay within a certain tolerance, and even then this \"simplification\" would fail if you zoomed in, so it is probably best to avoid.\\n```\\npublic class Solution \\n{\\n    public struct Pair\\n    {\\n        public int x;\\n        public int y;\\n        public Pair(int x, int y)\\n        {\\n            this.x=x;\\n            this.y=y;\\n        }\\n    }\\n    \\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        if (stockPrices.Length==1) return 0;\\n        \\n        Pair [] pairs = new Pair[stockPrices.Length];\\n        for(int i=0;i<stockPrices.Length;i++)\\n        {\\n            int x = stockPrices[i][0];\\n            int y = stockPrices[i][1];\\n            pairs[i]=new Pair(x,y);\\n        }\\n        //Because of course we need to sort...\\n        pairs = pairs.OrderBy(a=>a.x).ToArray();\\n        \\n        int risePrev=0;\\n        int runPrev=0;\\n        //Start with one line, then every slope change is a line\\n        int lines=1;        \\n        for(int i=1;i<pairs.Length;i++)\\n        {\\n            int x1 = pairs[i-1].x;\\n            int y1 = pairs[i-1].y;\\n            int x2 = pairs[i  ].x;\\n            int y2 = pairs[i  ].y;\\n            int rise = y2-y1;\\n            int run= x2-x1;\\n            if (i>1)\\n            {\\n                //rise/run == risePrev/runPrev\\n                //rise*runPrev = risePrev*run\\n                if (rise*runPrev != risePrev*run)\\n                {\\n                    lines++;                    \\n                }\\n            }\\n            risePrev=rise;\\n            runPrev=run;\\n        }\\n        return lines;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public struct Pair\\n    {\\n        public int x;\\n        public int y;\\n        public Pair(int x, int y)\\n        {\\n            this.x=x;\\n            this.y=y;\\n        }\\n    }\\n    \\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        if (stockPrices.Length==1) return 0;\\n        \\n        Pair [] pairs = new Pair[stockPrices.Length];\\n        for(int i=0;i<stockPrices.Length;i++)\\n        {\\n            int x = stockPrices[i][0];\\n            int y = stockPrices[i][1];\\n            pairs[i]=new Pair(x,y);\\n        }\\n        //Because of course we need to sort...\\n        pairs = pairs.OrderBy(a=>a.x).ToArray();\\n        \\n        int risePrev=0;\\n        int runPrev=0;\\n        //Start with one line, then every slope change is a line\\n        int lines=1;        \\n        for(int i=1;i<pairs.Length;i++)\\n        {\\n            int x1 = pairs[i-1].x;\\n            int y1 = pairs[i-1].y;\\n            int x2 = pairs[i  ].x;\\n            int y2 = pairs[i  ].y;\\n            int rise = y2-y1;\\n            int run= x2-x1;\\n            if (i>1)\\n            {\\n                //rise/run == risePrev/runPrev\\n                //rise*runPrev = risePrev*run\\n                if (rise*runPrev != risePrev*run)\\n                {\\n                    lines++;                    \\n                }\\n            }\\n            risePrev=rise;\\n            runPrev=run;\\n        }\\n        return lines;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135385,
                "title": "python-straight-forward",
                "content": "\\tclass Solution:\\n\\t\\tdef minimumLines(self, stockPrices: List[List[int]]) -> int:\\n\\t\\t\\tn = len(stockPrices)\\n\\t\\t\\tif n == 2: return 1\\n\\t\\t\\tif n == 1: return 0\\n\\n\\t\\t\\tday, price = [],[]\\n\\t\\t\\tfor d, p in stockPrices:\\n\\t\\t\\t\\tday.append(d)\\n\\t\\t\\t\\tprice.append(p)\\n\\t\\t\\tstocks = sorted(zip(day,price))\\n\\t\\t\\tline = 1\\n\\t\\t\\tfor i in range(1,n-1):\\n\\t\\t\\t\\tp1, p2, p3 = stocks[i-1], stocks[i], stocks[i+1]        \\n\\t\\t\\t\\tif (p1[1]-p2[1])*(p2[0]-p3[0]) != (p2[1]-p3[1])*(p1[0]-p2[0]): \\n\\t\\t\\t\\t\\tline += 1\\n\\t\\t\\treturn line",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minimumLines(self, stockPrices: List[List[int]]) -> int:\\n\\t\\t\\tn = len(stockPrices)\\n\\t\\t\\tif n == 2: return 1\\n\\t\\t\\tif n == 1: return 0\\n\\n\\t\\t\\tday, price = [],[]\\n\\t\\t\\tfor d, p in stockPrices:\\n\\t\\t\\t\\tday.append(d)\\n\\t\\t\\t\\tprice.append(p)\\n\\t\\t\\tstocks = sorted(zip(day,price))\\n\\t\\t\\tline = 1\\n\\t\\t\\tfor i in range(1,n-1):\\n\\t\\t\\t\\tp1, p2, p3 = stocks[i-1], stocks[i], stocks[i+1]        \\n\\t\\t\\t\\tif (p1[1]-p2[1])*(p2[0]-p3[0]) != (p2[1]-p3[1])*(p1[0]-p2[0]): \\n\\t\\t\\t\\t\\tline += 1\\n\\t\\t\\treturn line",
                "codeTag": "Java"
            },
            {
                "id": 2101620,
                "title": "python3-easy-to-follow-solution-with-comment-lines",
                "content": "```\\nimport decimal\\n\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n\\n        ## Step 1: calculete the lenght of the array\\n        n = len(stockPrices)\\n        if n <= 1:\\n            return 0\\n\\n        ## Step 2 : sort the array based on X since we have atleast two points\\n        stockPrices = sorted(stockPrices, key=lambda x: x[0])\\n\\n        ## Calculate the slope of the first two points\\n        x0, y0 = stockPrices[0][0], stockPrices[0][1]\\n        x1, y1 = stockPrices[1][0], stockPrices[1][1]\\n\\n        prevSlope = (decimal.Decimal(y1 - y0) / decimal.Decimal(x1 - x0))  ## Slope of first two points\\n\\n        i = 1\\n        countoflines = 1  ## So far we have one line\\n        while i < n - 1:\\n\\n            ## for each i, calculate the slope between xi, yi and xi+1 , yi+1\\n            x0, y0 = stockPrices[i][0], stockPrices[i][1]\\n            x1, y1 = stockPrices[i + 1][0], stockPrices[i + 1][1]\\n\\n            currentSlope = (decimal.Decimal(y1 - y0) / decimal.Decimal(x1 - x0))  ## slope of the current two points\\n\\n            if currentSlope != prevSlope:  ## of the slopes are not matching then we need new line\\n                countoflines += 1\\n            prevSlope = currentSlope  ## current slope becomes the previous slope for the next iteration\\n            i += 1  ## increment i for considering the next points\\n\\n        return countoflines\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport decimal\\n\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n\\n        ## Step 1: calculete the lenght of the array\\n        n = len(stockPrices)\\n        if n <= 1:\\n            return 0\\n\\n        ## Step 2 : sort the array based on X since we have atleast two points\\n        stockPrices = sorted(stockPrices, key=lambda x: x[0])\\n\\n        ## Calculate the slope of the first two points\\n        x0, y0 = stockPrices[0][0], stockPrices[0][1]\\n        x1, y1 = stockPrices[1][0], stockPrices[1][1]\\n\\n        prevSlope = (decimal.Decimal(y1 - y0) / decimal.Decimal(x1 - x0))  ## Slope of first two points\\n\\n        i = 1\\n        countoflines = 1  ## So far we have one line\\n        while i < n - 1:\\n\\n            ## for each i, calculate the slope between xi, yi and xi+1 , yi+1\\n            x0, y0 = stockPrices[i][0], stockPrices[i][1]\\n            x1, y1 = stockPrices[i + 1][0], stockPrices[i + 1][1]\\n\\n            currentSlope = (decimal.Decimal(y1 - y0) / decimal.Decimal(x1 - x0))  ## slope of the current two points\\n\\n            if currentSlope != prevSlope:  ## of the slopes are not matching then we need new line\\n                countoflines += 1\\n            prevSlope = currentSlope  ## current slope becomes the previous slope for the next iteration\\n            i += 1  ## increment i for considering the next points\\n\\n        return countoflines\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097954,
                "title": "python-explained-easy",
                "content": "The problem can be solved using the **slope formula** for a line.\\n( y2 - y1 ) / ( x2 - x1 ) = ( y3 - y2 ) / ( x3 - x2 )\\n\\n**BUT ERROR OCCURS FOR** -> [ [1,1] , [500000000,499999999] , [1000000000,999999998] ]\\nBecause in division , fractions may be rounded off.\\n\\nTo prevent this , we multiply the denominator both side to get :\\n**( y2 - y1 ) * ( x3 - x2 ) = ( y3 - y2 ) * ( x2 - x1 )**\\n\\n\\n```\\nclass Solution:\\n    def minimumLines(self, a: List[List[int]]) -> int:\\n        if len(a)<=1:\\n            return 0\\n        a.sort()\\n        ans=1\\n        for i in range(2,len(a)):\\n            \\n            if ((a[i-1][1]-a[i-2][1])*(a[i][0]-a[i-1][0]))!=((a[i][1]-a[i-1][1])*(a[i-1][0]-a[i-2][0])):\\n                ans+=1\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimumLines(self, a: List[List[int]]) -> int:\\n        if len(a)<=1:\\n            return 0\\n        a.sort()\\n        ans=1\\n        for i in range(2,len(a)):\\n            \\n            if ((a[i-1][1]-a[i-2][1])*(a[i][0]-a[i-1][0]))!=((a[i][1]-a[i-1][1])*(a[i-1][0]-a[i-2][0])):\\n                ans+=1\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079118,
                "title": "python-merge-consecutive-line-segments-with-same-slope",
                "content": "Given points `(x1, y1)`, `(x2, y2)`, and `(x3, y3)`, where `x1 < x2 < x3`, the lines connecting `(x1, y1)` and `(x2, y2)`, and `(x2, y2)` and `(x3, y3)` are **the same line** if and only if their **slopes** are the **same**.\\n\\nThe slope of the line connecting `(x1, y1)` and `(x2, y2)` is `(y2 - y1) / (x2 - x1)`, and the slope of the line connecting `(x2, y2)` and `(x3, y3)` is `(y3 - y2) / (x3 - x2)`. These slopes are equal if and only if `(y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1)`.\\n\\n```\\nclass Solution:    \\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        if len(stockPrices) == 1:\\n            return 0\\n\\n        stockPrices.sort()\\n        \\n        lineCount = 1\\n        for (x1, y1), (x2, y2), (x3, y3) in zip(stockPrices[:-2], stockPrices[1:-1], stockPrices[2:]):            \\n            if (y2 - y1) * (x3 - x2) != (y3 - y2) * (x2 - x1):\\n                lineCount += 1\\n                \\n        return lineCount\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:    \\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        if len(stockPrices) == 1:\\n            return 0\\n\\n        stockPrices.sort()\\n        \\n        lineCount = 1\\n        for (x1, y1), (x2, y2), (x3, y3) in zip(stockPrices[:-2], stockPrices[1:-1], stockPrices[2:]):            \\n            if (y2 - y1) * (x3 - x2) != (y3 - y2) * (x2 - x1):\\n                lineCount += 1\\n                \\n        return lineCount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078657,
                "title": "python-with-zip",
                "content": "**Clean code**\\n```\\nclass Solution(object):\\n  def minimumLines(self, ss):\\n    ss.sort(key=lambda s: s[0])\\n    l = [float(\\'inf\\'),1]\\n    res = 0\\n    for a,b in zip(ss[:-1], ss[1:]):\\n      c = [bb-aa for aa,bb in zip(a,b)]\\n      if l[0]*c[1]!=l[1]*c[0]:\\n        l = c\\n        res += 1\\n    return res\\n```\\n\\n**3 lines**\\n```\\nclass Solution(object):\\n  def minimumLines(self, ss):\\n    if len(ss)<=2: return len(ss)-1\\n    ss.sort(key=lambda s: s[0])\\n    return 1 + sum([(a-i)*(j-y)!=(i-x)*(b-j) for a,b,i,j,x,y in zip(*(zip(*ss[:-2])+zip(*ss[1:-1])+zip(*ss[2:])))])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n  def minimumLines(self, ss):\\n    ss.sort(key=lambda s: s[0])\\n    l = [float(\\'inf\\'),1]\\n    res = 0\\n    for a,b in zip(ss[:-1], ss[1:]):\\n      c = [bb-aa for aa,bb in zip(a,b)]\\n      if l[0]*c[1]!=l[1]*c[0]:\\n        l = c\\n        res += 1\\n    return res\\n```\n```\\nclass Solution(object):\\n  def minimumLines(self, ss):\\n    if len(ss)<=2: return len(ss)-1\\n    ss.sort(key=lambda s: s[0])\\n    return 1 + sum([(a-i)*(j-y)!=(i-x)*(b-j) for a,b,i,j,x,y in zip(*(zip(*ss[:-2])+zip(*ss[1:-1])+zip(*ss[2:])))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077311,
                "title": "java-slope-of-line-with-two-points-y2-y1-x2-x1",
                "content": "\\n\\n```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if(stockPrices.length == 1){\\n            return 0;\\n        }\\n        Arrays.sort(stockPrices,(a,b)->a[0]-b[0]);\\n        double lastSlope = (stockPrices[1][1]-stockPrices[0][1])*100/((stockPrices[1][0]-stockPrices[0][0])*1.0);     // multiply with 1.0 to make it double and multiply with 100 for making it big so that difference won\\'t come out to be very less and after division it become 0. failing for one of the case without multiply 100\\n        int ans = 1;\\n        for(int i=2;i<stockPrices.length;i++){\\n            double curSlope = (stockPrices[i][1]-stockPrices[i-1][1])*100/((stockPrices[i][0]-stockPrices[i-1][0])*1.0);\\n            if(lastSlope != curSlope){\\n                lastSlope = curSlope;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if(stockPrices.length == 1){\\n            return 0;\\n        }\\n        Arrays.sort(stockPrices,(a,b)->a[0]-b[0]);\\n        double lastSlope = (stockPrices[1][1]-stockPrices[0][1])*100/((stockPrices[1][0]-stockPrices[0][0])*1.0);     // multiply with 1.0 to make it double and multiply with 100 for making it big so that difference won\\'t come out to be very less and after division it become 0. failing for one of the case without multiply 100\\n        int ans = 1;\\n        for(int i=2;i<stockPrices.length;i++){\\n            double curSlope = (stockPrices[i][1]-stockPrices[i-1][1])*100/((stockPrices[i][0]-stockPrices[i-1][0])*1.0);\\n            if(lastSlope != curSlope){\\n                lastSlope = curSlope;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074609,
                "title": "java-basic-approach-o-n-time-o-1-space",
                "content": "class Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        \\n            // if you like it #UP_VOTE for me..\\n        \\n        \\n      // Instead of  this Lambda Function Expression You can use full comparator implimentaion..\\n        \\n        // This Also work same as Array.sort(stockPrices,(int []a,int b[])->a[0]-b[0]);\\n        \\n        /*\\n            Arrasy.sort(stockPrices,new Comparator<int[]>(){\\n            \\n                public int compare(int []a,int []b){\\n                \\n                if(a[0]>b[0]) return 1;\\n                else return -1;\\n                }\\n            \\n            });\\n            \\n            compare function take one row at a time and compare with second row (with your given special column)\\n        \\n        */\\n        \\n        \\n        \\n        Arrays.sort(stockPrices,(int []a,int b[])->a[0]-b[0]);   // Soritng the 2d matric according to 0 index column..\\n        \\n        if(stockPrices.length==1) return 0;\\n        \\n        int ans=1;\\n     \\n        \\n        \\n   // When three points are Colinear..then its holdes \\n        // (y2-y1)*(x3-x2)==(y3-y2)*(x2-x1);\\n        \\n        for(int i=1;i<stockPrices.length-1;i++){\\n            \\n            int x1=stockPrices[i-1][0],y1=stockPrices[i-1][1];\\n            int x2=stockPrices[i][0],y2=stockPrices[i][1];\\n            int x3=stockPrices[i+1][0],y3=stockPrices[i+1][1];\\n            \\n            if((y2-y1)*(x3-x2)!=(y3-y2)*(x2-x1)) ans++;\\n            \\n            }\\n        \\n        return ans;\\n        \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        \\n            // if you like it #UP_VOTE for me..\\n        \\n        \\n      // Instead of  this Lambda Function Expression You can use full comparator implimentaion..\\n        \\n        // This Also work same as Array.sort(stockPrices,(int []a,int b[])->a[0]-b[0]);\\n        \\n        /*\\n            Arrasy.sort(stockPrices,new Comparator<int[]>(){\\n            \\n                public int compare(int []a,int []b){\\n                \\n                if(a[0]>b[0]) return 1;\\n                else return -1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2073320,
                "title": "c-float128",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stock) {\\n        if(stock.size()==1) return 0;\\n        \\n        sort(stock.begin(),stock.end());\\n        \\n        int count=1;\\n        __float128 slope=(__float128)(stock[1][1]-stock[0][1])/(__float128)(stock[1][0]-stock[0][0]);\\n        for(int i=2;i<stock.size();i++)\\n        {\\n            __float128 newslope=(__float128)(stock[i][1]-stock[i-1][1])/(__float128)(stock[i][0]-stock[i-1][0]);\\n            \\n            if(slope!=newslope)\\n            {\\n                count++;   \\n            }\\n            slope=newslope;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stock) {\\n        if(stock.size()==1) return 0;\\n        \\n        sort(stock.begin(),stock.end());\\n        \\n        int count=1;\\n        __float128 slope=(__float128)(stock[1][1]-stock[0][1])/(__float128)(stock[1][0]-stock[0][0]);\\n        for(int i=2;i<stock.size();i++)\\n        {\\n            __float128 newslope=(__float128)(stock[i][1]-stock[i-1][1])/(__float128)(stock[i][0]-stock[i-1][0]);\\n            \\n            if(slope!=newslope)\\n            {\\n                count++;   \\n            }\\n            slope=newslope;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070178,
                "title": "99-faster-o-nlogn-c-solution-using-math-and-long-double",
                "content": "**Just check if the slope array is empty or the back of the array is different than current slope. If yes then insert the current slope.** \\nReturn the size of the array. As simple as that.\\n(Long double is the catch here)\\n```\\n#define lld long double\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& SP) {\\n        sort(begin(SP),end(SP));\\n        int n = SP.size();\\n        vector<lld>sl;\\n        for(int i = 1 ; i < n ; i++){\\n            lld slope = (lld)(SP[i][1] - SP[i - 1][1]) / (SP[i][0] - SP[i - 1][0]);\\n            if(sl.size() == 0 || (sl.size() > 0 && sl.back() != slope)) sl.push_back(slope);\\n        }\\n        return sl.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Geometry"
                ],
                "code": "```\\n#define lld long double\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& SP) {\\n        sort(begin(SP),end(SP));\\n        int n = SP.size();\\n        vector<lld>sl;\\n        for(int i = 1 ; i < n ; i++){\\n            lld slope = (lld)(SP[i][1] - SP[i - 1][1]) / (SP[i][0] - SP[i - 1][0]);\\n            if(sl.size() == 0 || (sl.size() > 0 && sl.back() != slope)) sl.push_back(slope);\\n        }\\n        return sl.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067653,
                "title": "c-easy-explanation",
                "content": "**Math Concept** : If 3 points lie on same line, it conclude that slope of any 2 points will be equal.\\nUsing this concept, calculate slope for consecutive 2 points, if the are same, they lie on same line else not.\\n\\nIf you want to find the slope, we would store in double and compare that.\\n\\n**My Approach** I have not find slope in decimals, but actually i have evaluated fraction, num/den, and compare current slope in fraction form.\\n\\n**To find fraction** =>\\nslope = (y2 - y1)/(x2 - x1)\\n\\nnumerator = y2 - y1\\ndenominator = x2 - x1;\\n\\nwe will simplify numerator and denominator i.e. 6/4 = 3/2 using **GCD**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int findGCD(int a, int b) {\\n   if (b == 0)\\n      return a;\\n      return findGCD(b, a % b);\\n   }\\n   vector<int> lowestFraction(int num1, int num2){\\n      int denom;\\n      denom = findGCD(num1,num2);\\n      num1/=denom;\\n      num2/=denom;\\n      return {num1,num2};\\n}\\n    \\n    \\n    int minimumLines(vector<vector<int>>& sp) {\\n        sort(sp.begin(),sp.end());\\n     \\n       vector<vector<int>> slope;\\n        for(int i = 1; i < sp.size();i++){\\n            int y = sp[i][1] - sp[i-1][1];\\n            int x = sp[i][0] - sp[i-1][0];\\n            \\n            slope.push_back(lowestFraction(y,x));\\n        }\\n        int i = 0;\\n        int ans = 0;\\n        while(i < slope.size()){\\n            vector<int> k = slope[i];\\n           \\n            while(i < slope.size() && slope[i]==k){\\n                i++;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nUpvote if you like the solution :)\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findGCD(int a, int b) {\\n   if (b == 0)\\n      return a;\\n      return findGCD(b, a % b);\\n   }\\n   vector<int> lowestFraction(int num1, int num2){\\n      int denom;\\n      denom = findGCD(num1,num2);\\n      num1/=denom;\\n      num2/=denom;\\n      return {num1,num2};\\n}\\n    \\n    \\n    int minimumLines(vector<vector<int>>& sp) {\\n        sort(sp.begin(),sp.end());\\n     \\n       vector<vector<int>> slope;\\n        for(int i = 1; i < sp.size();i++){\\n            int y = sp[i][1] - sp[i-1][1];\\n            int x = sp[i][0] - sp[i-1][0];\\n            \\n            slope.push_back(lowestFraction(y,x));\\n        }\\n        int i = 0;\\n        int ans = 0;\\n        while(i < slope.size()){\\n            vector<int> k = slope[i];\\n           \\n            while(i < slope.size() && slope[i]==k){\\n                i++;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066235,
                "title": "easy-to-understand-basic-maths-c-solution-with-explanation",
                "content": "I hope you guys know the basic maths that if the slopes are equal , the line would remain the same.\\n\\nNow this question is basically testing our knowlege on floating numbers and its range, thats why many cases are failing. Check out the constraints, the range of numbers is too high that is why I\\'ve used long double.\\n\\nAnd the reason I have sorted it because if the array is un sorted, there might be some points where the slope was equal to one of the previous slopes. So to avoid that, I\\'ve sorted the array.\\n\\n```\\nclass Solution {\\npublic:\\n \\n    int minimumLines(vector<vector<int>>& sp) {\\n        int n = sp.size();\\n          \\n        sort(sp.begin(), sp.end());\\n        int lines = 0;\\n        double pm = DBL_MAX;\\n        for(int i = 1;i<n;i++){\\n             long double y1 = sp[i - 1][1];\\n        long double y2 = sp[i][1];\\n        long double x1 = sp[i - 1][0];\\n        long double x2 = sp[i][0];\\n\\n        long double a = y2 - y1;\\n        long double b = x2 - x1;\\n        long double m = a / b;\\n          \\n            if(m != pm){\\n                lines++;\\n                pm = m;\\n            }else continue;\\n        }\\n        return lines;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    int minimumLines(vector<vector<int>>& sp) {\\n        int n = sp.size();\\n          \\n        sort(sp.begin(), sp.end());\\n        int lines = 0;\\n        double pm = DBL_MAX;\\n        for(int i = 1;i<n;i++){\\n             long double y1 = sp[i - 1][1];\\n        long double y2 = sp[i][1];\\n        long double x1 = sp[i - 1][0];\\n        long double x2 = sp[i][0];\\n\\n        long double a = y2 - y1;\\n        long double b = x2 - x1;\\n        long double m = a / b;\\n          \\n            if(m != pm){\\n                lines++;\\n                pm = m;\\n            }else continue;\\n        }\\n        return lines;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064441,
                "title": "easy-java-solution-using-long-for-hidden-case",
                "content": "using slope conecpt i am checking current and previous slope if they are same then i don\\'t need a line else i will need a line for these point. i have used long rather than double for the first slope for the hidden case\\n```\\nclass Solution {\\n    public int minimumLines(int[][] a) {\\n        if(a.length == 1) return 0;\\n         Arrays.sort(a, (aa, bb) -> Integer.compare(aa[0], bb[0]));\\n        double slopeu =  Long.valueOf(a[1][1] - a[0][1]) /Long.valueOf(a[1][0] - a[0][0]) ;\\n        int count = 1;\\n       double arpit = 0.0;\\n        for(int i = 1; i < a.length-1 ; i++){\\n            arpit = Double.valueOf((a[i+1][1]) - (a[i][1])) / Double.valueOf((a[i+1][0]) - (a[i][0]));\\n            if(arpit != slopeu){\\n                count ++;\\n                slopeu = Double.valueOf((a[i+1][1]) - (a[i][1])) / Double.valueOf((a[i+1][0]) - (a[i][0]));\\n            }\\n        }\\n         return count;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] a) {\\n        if(a.length == 1) return 0;\\n         Arrays.sort(a, (aa, bb) -> Integer.compare(aa[0], bb[0]));\\n        double slopeu =  Long.valueOf(a[1][1] - a[0][1]) /Long.valueOf(a[1][0] - a[0][0]) ;\\n        int count = 1;\\n       double arpit = 0.0;\\n        for(int i = 1; i < a.length-1 ; i++){\\n            arpit = Double.valueOf((a[i+1][1]) - (a[i][1])) / Double.valueOf((a[i+1][0]) - (a[i][0]));\\n            if(arpit != slopeu){\\n                count ++;\\n                slopeu = Double.valueOf((a[i+1][1]) - (a[i][1])) / Double.valueOf((a[i+1][0]) - (a[i][0]));\\n            }\\n        }\\n         return count;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063946,
                "title": "using-simple-math-s-applications",
                "content": "class Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        int ans=1;\\n        int n=stockPrices.length;\\n        if(n==1){\\n            return 0;\\n        }\\n        int[] arr= new int [n];\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            arr[i]=stockPrices[i][0];\\n            hm.put(arr[i],stockPrices[i][1]);\\n        }\\n        Arrays.sort(arr);\\n        int dy=(hm.get(arr[1])-hm.get(arr[0])),dx=(arr[1]-arr[0]);\\n        int c=hcf(dy,dx);\\n        if(c>1){\\n            dy=dy/c;\\n            dx=dx/c;\\n        }\\n        for(int i=2;i<n;i++){\\n            int ny=(hm.get(arr[i])-hm.get(arr[i-1])),nx=(arr[i]-arr[i-1]);\\n            int nc=hcf(ny,nx);\\n            if(nc>1){\\n                ny=ny/nc;\\n                nx=nx/nc;\\n            }\\n            if(dy!=ny || dx!=nx){\\n                ans++;\\n            }\\n            dy=ny;\\n            dx=nx;\\n        }\\n        return ans;\\n    }\\n    public int hcf(int a,int b){\\n        if(b==0){\\n            return a;\\n        }\\n        return hcf(b,a%b);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        int ans=1;\\n        int n=stockPrices.length;\\n        if(n==1){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2063395,
                "title": "count-no-of-change-in-slopes",
                "content": "First we sort the given stockPrices array according to increasing no. of days.\\nThen we calculate the slope for first two points-\\n    1. If the slope does not change then no extra line required for next point.\\n    2. If the slope does change then we need a new line and so on....\\n```\\n\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int i=0,ans=1;\\n        long double slope1,slope2;\\n        if(stockPrices.size()==1)\\n            return 0;\\n        sort(stockPrices.begin(),stockPrices.end());\\n        slope1=(long double)(stockPrices[1][1]-stockPrices[0][1])/(stockPrices[1][0]-stockPrices[0][0]);\\n        for(i=1;i<stockPrices.size()-1;i++)\\n        {\\n            slope2=(long double)(stockPrices[i+1][1]-stockPrices[i][1])/(stockPrices[i+1][0]-stockPrices[i][0]);\\n            \\n            if(abs(slope1-slope2)>=1e-20)\\n            {\\n                ans++;\\n                slope1=slope2;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int i=0,ans=1;\\n        long double slope1,slope2;\\n        if(stockPrices.size()==1)\\n            return 0;\\n        sort(stockPrices.begin(),stockPrices.end());\\n        slope1=(long double)(stockPrices[1][1]-stockPrices[0][1])/(stockPrices[1][0]-stockPrices[0][0]);\\n        for(i=1;i<stockPrices.size()-1;i++)\\n        {\\n            slope2=(long double)(stockPrices[i+1][1]-stockPrices[i][1])/(stockPrices[i+1][0]-stockPrices[i][0]);\\n            \\n            if(abs(slope1-slope2)>=1e-20)\\n            {\\n                ans++;\\n                slope1=slope2;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062980,
                "title": "rust-multiplication",
                "content": "```rust\\nfn minimum_lines(mut stock_prices: Vec<Vec<i32>>) -> i32 {\\n    if stock_prices.len() == 1 {\\n        return 0;\\n    }\\n    if stock_prices.len() == 2 {\\n        return 1;\\n    }\\n    stock_prices.sort_unstable();\\n    let mut res = 1;\\n\\n    for i in stock_prices.windows(3) {\\n        let left = (i[1][1] - i[0][1]) as i64 * (i[2][0] - i[1][0]) as i64;\\n        let right = (i[1][0] - i[0][0]) as i64 * (i[2][1] - i[1][1]) as i64;\\n        if left != right {\\n            res += 1;\\n        }\\n    }\\n    res\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nfn minimum_lines(mut stock_prices: Vec<Vec<i32>>) -> i32 {\\n    if stock_prices.len() == 1 {\\n        return 0;\\n    }\\n    if stock_prices.len() == 2 {\\n        return 1;\\n    }\\n    stock_prices.sort_unstable();\\n    let mut res = 1;\\n\\n    for i in stock_prices.windows(3) {\\n        let left = (i[1][1] - i[0][1]) as i64 * (i[2][0] - i[1][0]) as i64;\\n        let right = (i[1][0] - i[0][0]) as i64 * (i[2][1] - i[1][1]) as i64;\\n        if left != right {\\n            res += 1;\\n        }\\n    }\\n    res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062977,
                "title": "kotlin-and-java-clean-and-simple-solution-without-division",
                "content": "The solution idea is to check if dots from three consecutive days lay on the same line. If they are, then you need only one line to connect them, if they are not you need two lines. To check if dots are on the same line we use the formula `(y1 - y2) / (x1 - x2) == (y1 - y3) / (x1 - x3)`, but to avoid division we rewrite the  formula as `(y1 - y2) * (x1 - x3) == (y1 - y3) * (x1 - x2)`, also we could rewrite it as `(y1 - y2) * (x1 - x3) - (y1 - y3) * (x1 - x3) == 0`.\\n\\n**Kotlin code:**\\n```\\nclass Solution {\\n    fun minimumLines(stockPrices: Array<IntArray>): Int {\\n        if (stockPrices.size < 2) return 0\\n        stockPrices.sortBy { it[0] }\\n        \\n        var count = 1\\n        for (i in 2 until stockPrices.size) {\\n            val (x1, y1) = stockPrices[i - 2]\\n            val (x2, y2) = stockPrices[i - 1]\\n            val (x3, y3) = stockPrices[i]\\n            \\n            if ((y1 - y2) * (x1 - x3) - (y1 - y3) * (x1 - x2) != 0) count++\\n        }\\n        return count\\n    }\\n}\\n```\\n\\n**Java code:**\\n```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if (stockPrices.length < 2) return 0;\\n        Arrays.sort(stockPrices, (first, second) -> (first[0] - second[0]));\\n        \\n        int count = 1;\\n        for (int i = 2; i < stockPrices.length; i++) {\\n            \\n            int x1 = stockPrices[i - 2][0];\\n            int x2 = stockPrices[i - 1][0];\\n            int x3 = stockPrices[i][0];\\n            \\n            int y1 = stockPrices[i - 2][1];\\n            int y2 = stockPrices[i - 1][1];\\n            int y3 = stockPrices[i][1];\\n            \\n            if ((y1 - y2) * (x1 - x3) - (y1 - y3) * (x1 - x2) != 0) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minimumLines(stockPrices: Array<IntArray>): Int {\\n        if (stockPrices.size < 2) return 0\\n        stockPrices.sortBy { it[0] }\\n        \\n        var count = 1\\n        for (i in 2 until stockPrices.size) {\\n            val (x1, y1) = stockPrices[i - 2]\\n            val (x2, y2) = stockPrices[i - 1]\\n            val (x3, y3) = stockPrices[i]\\n            \\n            if ((y1 - y2) * (x1 - x3) - (y1 - y3) * (x1 - x2) != 0) count++\\n        }\\n        return count\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if (stockPrices.length < 2) return 0;\\n        Arrays.sort(stockPrices, (first, second) -> (first[0] - second[0]));\\n        \\n        int count = 1;\\n        for (int i = 2; i < stockPrices.length; i++) {\\n            \\n            int x1 = stockPrices[i - 2][0];\\n            int x2 = stockPrices[i - 1][0];\\n            int x3 = stockPrices[i][0];\\n            \\n            int y1 = stockPrices[i - 2][1];\\n            int y2 = stockPrices[i - 1][1];\\n            int y3 = stockPrices[i][1];\\n            \\n            if ((y1 - y2) * (x1 - x3) - (y1 - y3) * (x1 - x2) != 0) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062976,
                "title": "how-to-avoid-the-division-decimals-java-with-and-without-bigdecimals",
                "content": "### Method 1\\n![](https://i.ibb.co/QbdS2M5/Whats-App-Image-2022-05-22-at-1-37-00-PM.jpg)\\nIt\\'s important to sort. We sort because we are comparing the slope of the points with the the points before it and after it. If we sort the points, we put similar slopes together with this method.\\n\\nIt\\'s cleaner easier to understand if we store the values in seperate Data Types.\\n\\n```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if (stockPrices.length == 1) \\n            return 0;\\n        Arrays.sort(stockPrices, (a, b) -> Integer.compare(a[0], b[0]));\\n        int count = 1;\\n        for (int i = 2; i < stockPrices.length; i++) {\\n            //AVOID DIVINDING AT ALL CASES BASICALLY IS A KEY LEARNING OF THIS QUESTION\\n            int x1 = stockPrices[i-2][0];\\n            int x2 = stockPrices[i-1][0];\\n            int x3 = stockPrices[i][0];\\n            int y1 = stockPrices[i-2][1];\\n            int y2 = stockPrices[i-1][1];\\n            int y3 = stockPrices[i][1];\\n            if ((y3-y2) * (x2-x1) == (y2-y1)*(x3-x2))\\n                continue;\\n            count++;;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nNOTE: If we do using calculating each slope and then comparing, it usually involves divison and this adds a lot of complications.\\n\\nWe can\\'t use Integer. We have to use something like decimal, even decimal doesn\\'t work due it it\\'s lack of size so we have to use BigDecimal.\\n\\n## Method 2 - BigDecimal\\nWithout Cross-Multiplication and using formula based division.\\n```\\nimport java.math.BigDecimal;\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\nint n = stockPrices.length,lines=1;\\n        if(n<3) return n-1;\\n        Arrays.sort(stockPrices, Comparator.comparingInt(a -> a[0]));\\n        for(int i=1;i<n-1;i++){\\n            BigDecimal x1 = BigDecimal.valueOf(stockPrices[i-1][0]), x2 = BigDecimal.valueOf(stockPrices[i][0]), x3 = BigDecimal.valueOf(stockPrices[i+1][0]);\\n            BigDecimal y1 = BigDecimal.valueOf(stockPrices[i-1][1]), y2 = BigDecimal.valueOf(stockPrices[i][1]), y3 = BigDecimal.valueOf(stockPrices[i+1][1]);\\n            BigDecimal d1 = (x2.subtract(x1)).multiply(y3.subtract(y2));\\n            BigDecimal d2 = (y2.subtract(y1)).multiply(x3.subtract(x2));\\n            if(!d1.equals(d2)) lines++;\\n        }\\n        return lines;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if (stockPrices.length == 1) \\n            return 0;\\n        Arrays.sort(stockPrices, (a, b) -> Integer.compare(a[0], b[0]));\\n        int count = 1;\\n        for (int i = 2; i < stockPrices.length; i++) {\\n            //AVOID DIVINDING AT ALL CASES BASICALLY IS A KEY LEARNING OF THIS QUESTION\\n            int x1 = stockPrices[i-2][0];\\n            int x2 = stockPrices[i-1][0];\\n            int x3 = stockPrices[i][0];\\n            int y1 = stockPrices[i-2][1];\\n            int y2 = stockPrices[i-1][1];\\n            int y3 = stockPrices[i][1];\\n            if ((y3-y2) * (x2-x1) == (y2-y1)*(x3-x2))\\n                continue;\\n            count++;;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nimport java.math.BigDecimal;\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\nint n = stockPrices.length,lines=1;\\n        if(n<3) return n-1;\\n        Arrays.sort(stockPrices, Comparator.comparingInt(a -> a[0]));\\n        for(int i=1;i<n-1;i++){\\n            BigDecimal x1 = BigDecimal.valueOf(stockPrices[i-1][0]), x2 = BigDecimal.valueOf(stockPrices[i][0]), x3 = BigDecimal.valueOf(stockPrices[i+1][0]);\\n            BigDecimal y1 = BigDecimal.valueOf(stockPrices[i-1][1]), y2 = BigDecimal.valueOf(stockPrices[i][1]), y3 = BigDecimal.valueOf(stockPrices[i+1][1]);\\n            BigDecimal d1 = (x2.subtract(x1)).multiply(y3.subtract(y2));\\n            BigDecimal d2 = (y2.subtract(y1)).multiply(x3.subtract(x2));\\n            if(!d1.equals(d2)) lines++;\\n        }\\n        return lines;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062841,
                "title": "java-cross-multiplication-simple-solution",
                "content": "Calculate the slope between two points. If the slope of this line is equal to the slope of line between next pair of points then they belong to the same line.\\n```\\nclass Solution {\\n    public int minimumLines(int[][] stock) {\\n        int n = stock.length,res = 0;\\n        Arrays.sort(stock,(a,b) -> a[0] - b[0]);\\n        \\n        for(int i=0;i<n-1;++i){\\n            if(i == n-2){res++; continue;} // it\\'s not part of previous line and there is no next line\\n                int x1 = stock[i+1][1] - stock[i][1] , x2 = stock[i+2][1] - stock[i+1][1];\\n                int y1 = stock[i+1][0] - stock[i][0] , y2 = stock[i+2][0] - stock[i+1][0];\\n\\t\\t\\t\\t// Cross Multiplication \\n\\t\\t\\t\\t// x1/y1 != x2/y2 can be written as x1 * y2 != x2 * y1\\n                if(x1 * y2 != x2 * y1) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] stock) {\\n        int n = stock.length,res = 0;\\n        Arrays.sort(stock,(a,b) -> a[0] - b[0]);\\n        \\n        for(int i=0;i<n-1;++i){\\n            if(i == n-2){res++; continue;} // it\\'s not part of previous line and there is no next line\\n                int x1 = stock[i+1][1] - stock[i][1] , x2 = stock[i+2][1] - stock[i+1][1];\\n                int y1 = stock[i+1][0] - stock[i][0] , y2 = stock[i+2][0] - stock[i+1][0];\\n\\t\\t\\t\\t// Cross Multiplication \\n\\t\\t\\t\\t// x1/y1 != x2/y2 can be written as x1 * y2 != x2 * y1\\n                if(x1 * y2 != x2 * y1) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062761,
                "title": "faster-easy-to-understand-c-code",
                "content": "\\n* ***Time Complexity : O(NlogN)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        if(n == 1)\\n            return 0;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int count = 1;\\n        \\n        vector<long double> slopes;\\n        \\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            long double diff_y = arr[i + 1][1] - arr[i][1];\\n            \\n            long double diff_x = arr[i + 1][0] - arr[i][0];\\n            \\n            long double slope = diff_y / diff_x;\\n            \\n            slopes.push_back(slope);\\n        }\\n        \\n        for(int i = 0; i < slopes.size() - 1; i++)\\n        {\\n            long double slope1 = slopes[i];\\n            \\n            long double slope2 = slopes[i + 1];\\n            \\n            if(slope1 != slope2)\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n* ***Space Optimized***\\n\\n* ***Time Complexity : O(NlogN)***\\n\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        if(n == 1)\\n            return 0;\\n        \\n        int right = 1;\\n        \\n        int count = 0;\\n        \\n        while(right < n)\\n        {\\n            long double diff_y = arr[right][1] - arr[right - 1][1];\\n            \\n            long double diff_x = arr[right][0] - arr[right - 1][0];\\n            \\n            long double slope = diff_y / diff_x;\\n            \\n            while(right < n)\\n            {\\n                long double diff_y = arr[right][1] - arr[right - 1][1];\\n            \\n                long double diff_x = arr[right][0] - arr[right - 1][0];\\n            \\n                long double slope1 = diff_y / diff_x;\\n                \\n                if(slope == slope1)\\n                {\\n                    right++;\\n                }\\n                \\n                else\\n                {\\n                    count++;\\n                    \\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return  count + 1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        if(n == 1)\\n            return 0;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int count = 1;\\n        \\n        vector<long double> slopes;\\n        \\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            long double diff_y = arr[i + 1][1] - arr[i][1];\\n            \\n            long double diff_x = arr[i + 1][0] - arr[i][0];\\n            \\n            long double slope = diff_y / diff_x;\\n            \\n            slopes.push_back(slope);\\n        }\\n        \\n        for(int i = 0; i < slopes.size() - 1; i++)\\n        {\\n            long double slope1 = slopes[i];\\n            \\n            long double slope2 = slopes[i + 1];\\n            \\n            if(slope1 != slope2)\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        if(n == 1)\\n            return 0;\\n        \\n        int right = 1;\\n        \\n        int count = 0;\\n        \\n        while(right < n)\\n        {\\n            long double diff_y = arr[right][1] - arr[right - 1][1];\\n            \\n            long double diff_x = arr[right][0] - arr[right - 1][0];\\n            \\n            long double slope = diff_y / diff_x;\\n            \\n            while(right < n)\\n            {\\n                long double diff_y = arr[right][1] - arr[right - 1][1];\\n            \\n                long double diff_x = arr[right][0] - arr[right - 1][0];\\n            \\n                long double slope1 = diff_y / diff_x;\\n                \\n                if(slope == slope1)\\n                {\\n                    right++;\\n                }\\n                \\n                else\\n                {\\n                    count++;\\n                    \\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return  count + 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062741,
                "title": "things-that-went-wrong-with-solution-c",
                "content": "### Things that went wrong:\\n\\n1. Not Sorting the stockPrices and assuming that they are already sorted by seeing the test case [Bro sample test case was sorted, but internal were not sorted]\\n\\n2. Using Division Operator: Because of division operation it may result in error because of rounding off, and to minimize the error we can use **long double** but using **Multiplication** is more prefered than it!! \\n   \\n   Use **<u>dy1 * dx2 = dy2 * dx1</u>** and not **<u>dy1/dx1 = dy2/dx2</u>**\\n   \\n   \\n\\n```cpp\\nint minimumLines(vector<vector<int>>& stockPrices) {\\n\\t// Checking for the base case\\n    if (stockPrices.size() == 1) return 0;\\n\\tif (stockPrices.size() == 2) return 1;\\n    \\n    // Sort the array before doing operation on it, when we sort this array it will be sorted depending on the x value of the point\\n\\tsort(stockPrices.begin(), stockPrices.end());\\n    \\n    // Count variable to keep track of the lines drawn\\n\\tint count = 0;\\n    \\n    // Calculate the diffX and diffY for the first line and also increment the line count\\n\\tlong long currDiffX = (stockPrices[1][0] - stockPrices[0][0]);\\n\\tlong long currDiffY = (stockPrices[1][1] - stockPrices[0][1]);\\n\\tcount++;\\n    \\n    // Loop through the second point till the second last point as we are find line from point to point + 1\\n\\tfor (int i = 1; i < stockPrices.size() - 1; ++i)\\n\\t{\\n\\n\\t\\tlong long diffX = (stockPrices[i + 1][0] - stockPrices[i][0]);\\n\\t\\tlong long diffY = (stockPrices[i + 1][1] - stockPrices[i][1]);\\n        \\n        // Check for the slope and compare it, if slope is different then we increment the count\\n\\t\\tif (currDiffY * diffX != currDiffX * diffY)\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t}\\n        \\n        // Change the currDiffX and currDiffY to the current diff\\n\\t\\tcurrDiffX = diffX;\\n\\t\\tcurrDiffY = diffY;\\n\\t}\\n    \\n    // Return the count\\n\\treturn count;\\n}\\n```\\n\\n**Time Complexity:** O(NLogN)\\n\\n**Space Complexity:** O(1)\\n\\n\\n\\n### **Feel free to leave a comment!!**\\n\\nKeep Coding, Keep Improving!!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```cpp\\nint minimumLines(vector<vector<int>>& stockPrices) {\\n\\t// Checking for the base case\\n    if (stockPrices.size() == 1) return 0;\\n\\tif (stockPrices.size() == 2) return 1;\\n    \\n    // Sort the array before doing operation on it, when we sort this array it will be sorted depending on the x value of the point\\n\\tsort(stockPrices.begin(), stockPrices.end());\\n    \\n    // Count variable to keep track of the lines drawn\\n\\tint count = 0;\\n    \\n    // Calculate the diffX and diffY for the first line and also increment the line count\\n\\tlong long currDiffX = (stockPrices[1][0] - stockPrices[0][0]);\\n\\tlong long currDiffY = (stockPrices[1][1] - stockPrices[0][1]);\\n\\tcount++;\\n    \\n    // Loop through the second point till the second last point as we are find line from point to point + 1\\n\\tfor (int i = 1; i < stockPrices.size() - 1; ++i)\\n\\t{\\n\\n\\t\\tlong long diffX = (stockPrices[i + 1][0] - stockPrices[i][0]);\\n\\t\\tlong long diffY = (stockPrices[i + 1][1] - stockPrices[i][1]);\\n        \\n        // Check for the slope and compare it, if slope is different then we increment the count\\n\\t\\tif (currDiffY * diffX != currDiffX * diffY)\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t}\\n        \\n        // Change the currDiffX and currDiffY to the current diff\\n\\t\\tcurrDiffX = diffX;\\n\\t\\tcurrDiffY = diffY;\\n\\t}\\n    \\n    // Return the count\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062510,
                "title": "python-solution-o-nlogn",
                "content": "```\\nfrom fractions import Fraction            # For larger values it will give accurate answer\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        l=[]\\n        stockPrices.sort()\\n        c=None\\n        k=0\\n        for i,j in pairwise(stockPrices):\\n            x=Fraction(j[1]-i[1],j[0]-i[0])      #(j[1]-i[1]) // (j[0]-i[0])\\n            if x!=c:\\n                k+=1\\n                c=x\\n        return k\\n```\\n\\n***Please Upvote if it helps.***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nfrom fractions import Fraction            # For larger values it will give accurate answer\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        l=[]\\n        stockPrices.sort()\\n        c=None\\n        k=0\\n        for i,j in pairwise(stockPrices):\\n            x=Fraction(j[1]-i[1],j[0]-i[0])      #(j[1]-i[1]) // (j[0]-i[0])\\n            if x!=c:\\n                k+=1\\n                c=x\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062353,
                "title": "simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n        bool check(vector<vector<int>>& coordinates) {\\n        long long x1=(coordinates[0][1]-coordinates[1][1]);\\n        long long y1=(coordinates[0][0]-coordinates[1][0]);\\n        for(int i=0;i<coordinates.size()-1;i++)\\n        {\\n            for(int j=0;j<2;j++)\\n            {\\n                long long x2=(coordinates[i][1]-coordinates[i+1][1]);\\n                long long y2=(coordinates[i][0]-coordinates[i+1][0]);\\n                if(x1*y2!=x2*y1)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n        }\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(),stockPrices.end());\\n        int c=0,n=stockPrices.size();\\n        if(n<=1) return 0;\\n        for(int i=0;i<n-2;i++)\\n        {\\n            vector<vector<int>>t={{stockPrices[i][0],stockPrices[i][1]},{stockPrices[i+1][0],stockPrices[i+1][1]},{stockPrices[i+2][0],stockPrices[i+2][1]}};\\n            if(!check(t))\\n            {\\n                c++;\\n            }\\n        }\\n        return c+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        bool check(vector<vector<int>>& coordinates) {\\n        long long x1=(coordinates[0][1]-coordinates[1][1]);\\n        long long y1=(coordinates[0][0]-coordinates[1][0]);\\n        for(int i=0;i<coordinates.size()-1;i++)\\n        {\\n            for(int j=0;j<2;j++)\\n            {\\n                long long x2=(coordinates[i][1]-coordinates[i+1][1]);\\n                long long y2=(coordinates[i][0]-coordinates[i+1][0]);\\n                if(x1*y2!=x2*y1)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n        }\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(),stockPrices.end());\\n        int c=0,n=stockPrices.size();\\n        if(n<=1) return 0;\\n        for(int i=0;i<n-2;i++)\\n        {\\n            vector<vector<int>>t={{stockPrices[i][0],stockPrices[i][1]},{stockPrices[i+1][0],stockPrices[i+1][1]},{stockPrices[i+2][0],stockPrices[i+2][1]}};\\n            if(!check(t))\\n            {\\n                c++;\\n            }\\n        }\\n        return c+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062277,
                "title": "multiplication-instead-of-division",
                "content": "I was trying to think how we can eliminate the need of division as two doubles can be very close and still not be equal even though they are a valid solution. How I got around this was multiplying. Sorting is mandatory which goes without mentioning.\\n \\n***Slope*** = (y2-y1)/(x2-x1)=(y3-y2)/(x3-x2)\\n\\nSo I cross-multiplied and checked whether the product is equal or not\\n***Condition*** :  (y3-y2)*(x2-x1)==(x3-x2)*(y2-y1)\\n\\n***P.S*** : Since we are dealing with 3 points, we need to explicitly define the case for 2 and 1 point test cases. I ignored this and got 1 wrong submission because of it.\\n\\nHere is the code in Java\\n\\n\\n```\\nclass Solution {\\n    public int minimumLines(int[][] s) {\\n        if(s.length==1)\\n            return 0;\\n        if(s.length==2)\\n            return 1;\\n        Arrays.sort(s, (a, b) -> Integer.compare(a[0], b[0]));\\n        long x=s[1][0]-s[0][0];\\n        long y=s[1][1]-s[0][1];\\n        int ans=1;\\n        for(int i=2;i<s.length;i++){\\n            System.out.println(ans+\" \"+i);\\n            long yy=s[i][1]-s[i-1][1];\\n            long xx=s[i][0]-s[i-1][0];\\n            if(x*yy-y*xx!=0){\\n                ans++;\\n                x=xx;\\n                y=yy;\\n            }\\n        }\\n        System.out.println();\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] s) {\\n        if(s.length==1)\\n            return 0;\\n        if(s.length==2)\\n            return 1;\\n        Arrays.sort(s, (a, b) -> Integer.compare(a[0], b[0]));\\n        long x=s[1][0]-s[0][0];\\n        long y=s[1][1]-s[0][1];\\n        int ans=1;\\n        for(int i=2;i<s.length;i++){\\n            System.out.println(ans+\" \"+i);\\n            long yy=s[i][1]-s[i-1][1];\\n            long xx=s[i][0]-s[i-1][0];\\n            if(x*yy-y*xx!=0){\\n                ans++;\\n                x=xx;\\n                y=yy;\\n            }\\n        }\\n        System.out.println();\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062232,
                "title": "c-slope-equation-easiest-approach-with-explanation",
                "content": "If slopes of the lines joining the previous and current points is not equal to the slopes of the lines joining the current and next points then increment lines.\\n\\nuse ***long double*** instead of ***double*** for storing the slopes for more accuracy\\n\\n**Time Complexity : O(n)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sP) {\\n        sort(sP.begin(),sP.end()); // sorted by daywise\\n        int n = sP.size(); // size of sP\\n        int lines = 1; // lines to be printed\\n        if(n<=1) return 0; // if size of sP is less than or equal to 1, return 0\\n        for(int i=1;i<n-1;i++){ // iterate through sP\\n            long double x1 = sP[i-1][0]; // x1 is the x-coordinate of the previous point\\n            long double y1 = sP[i-1][1]; // y1 is the y-coordinate of the previous point\\n            long double x2 = sP[i][0]; // x2 is the x-coordinate of the current point\\n            long double y2 = sP[i][1]; // y2 is the y-coordinate of the current point\\n            long double x3 = sP[i+1][0]; // x3 is the x-coordinate of the next point\\n            long double y3 = sP[i+1][1]; // y3 is the y-coordinate of the next point\\n            \\n            long double a = (long double)(y2-y1)/(x2-x1); // slope of the line joining the previous and current points\\n            long double b = (long double)(y3-y2)/(x3-x2); // slope of the line joining the current and next points\\n            \\n            if(a!=b) lines++; // if the slopes are not equal, increment lines\\n        }\\n        return lines; // return lines\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sP) {\\n        sort(sP.begin(),sP.end()); // sorted by daywise\\n        int n = sP.size(); // size of sP\\n        int lines = 1; // lines to be printed\\n        if(n<=1) return 0; // if size of sP is less than or equal to 1, return 0\\n        for(int i=1;i<n-1;i++){ // iterate through sP\\n            long double x1 = sP[i-1][0]; // x1 is the x-coordinate of the previous point\\n            long double y1 = sP[i-1][1]; // y1 is the y-coordinate of the previous point\\n            long double x2 = sP[i][0]; // x2 is the x-coordinate of the current point\\n            long double y2 = sP[i][1]; // y2 is the y-coordinate of the current point\\n            long double x3 = sP[i+1][0]; // x3 is the x-coordinate of the next point\\n            long double y3 = sP[i+1][1]; // y3 is the y-coordinate of the next point\\n            \\n            long double a = (long double)(y2-y1)/(x2-x1); // slope of the line joining the previous and current points\\n            long double b = (long double)(y3-y2)/(x3-x2); // slope of the line joining the current and next points\\n            \\n            if(a!=b) lines++; // if the slopes are not equal, increment lines\\n        }\\n        return lines; // return lines\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062159,
                "title": "stupidity-hidden-test-case-gcd-slope",
                "content": "```\\nlong double slope(long double x1, long double y1, long double x2, long double y2)\\n    {\\n        return (y2 - y1) /(x2 - x1);\\n    }\\n    int minimumLines(vector<vector<int>>& stockPrices) \\n    {\\n        sort(stockPrices.begin(),stockPrices.end());\\n        \\n        int n=stockPrices.size();\\n        \\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        \\n        int cnt=1;\\n        long double x1=stockPrices[0][0],y1=stockPrices[0][1],x2=stockPrices[1][0],y2=stockPrices[1][1];\\n        long double slo=slope(x1,y1,x2,y2);\\n        \\n        for(int i=2;i<n;i++)\\n        {\\n            x1=stockPrices[i-1][0],y1=stockPrices[i-1][1],x2=stockPrices[i][0],y2=stockPrices[i][1];\\n            long double s=slope(x1,y1,x2,y2);\\n            if(s==slo)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                cnt++;\\n                slo=s;\\n            }\\n        }\\n        \\n       \\n        return cnt;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nlong double slope(long double x1, long double y1, long double x2, long double y2)\\n    {\\n        return (y2 - y1) /(x2 - x1);\\n    }\\n    int minimumLines(vector<vector<int>>& stockPrices) \\n    {\\n        sort(stockPrices.begin(),stockPrices.end());\\n        \\n        int n=stockPrices.size();\\n        \\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        \\n        int cnt=1;\\n        long double x1=stockPrices[0][0],y1=stockPrices[0][1],x2=stockPrices[1][0],y2=stockPrices[1][1];\\n        long double slo=slope(x1,y1,x2,y2);\\n        \\n        for(int i=2;i<n;i++)\\n        {\\n            x1=stockPrices[i-1][0],y1=stockPrices[i-1][1],x2=stockPrices[i][0],y2=stockPrices[i][1];\\n            long double s=slope(x1,y1,x2,y2);\\n            if(s==slo)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                cnt++;\\n                slo=s;\\n            }\\n        }\\n        \\n       \\n        return cnt;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062125,
                "title": "clean-c-code",
                "content": "```\\nclass Solution {\\nprivate: \\n    long double slope(vector<int> &a, vector<int> &b) {\\n        int x1 = a[0], y1 = a[1];\\n        int x2 = b[0], y2 = b[1];\\n        \\n        //base cases\\n        if(x1 == x2) return INT_MAX;\\n        \\n        long double ans = (long double)(y2 - y1)/(long double)(x2 - x1);\\n        return ans;\\n    }\\npublic:\\n    int minimumLines(vector<vector<int>>& stocks) {\\n        int size = stocks.size();\\n        \\n        sort(stocks.begin(), stocks.end());\\n        \\n        //base cases\\n        if(size == 1) return 0;\\n        \\n        long double prev_slope = slope(stocks[0], stocks[1]);\\n        \\n        int i = 1, j = 2, count = 1;\\n        while(j < size) {\\n            long double curr_slope = slope(stocks[i], stocks[j]);\\n            if(prev_slope != curr_slope) {\\n                count++;\\n            }\\n            prev_slope = curr_slope;\\n            i++;j++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate: \\n    long double slope(vector<int> &a, vector<int> &b) {\\n        int x1 = a[0], y1 = a[1];\\n        int x2 = b[0], y2 = b[1];\\n        \\n        //base cases\\n        if(x1 == x2) return INT_MAX;\\n        \\n        long double ans = (long double)(y2 - y1)/(long double)(x2 - x1);\\n        return ans;\\n    }\\npublic:\\n    int minimumLines(vector<vector<int>>& stocks) {\\n        int size = stocks.size();\\n        \\n        sort(stocks.begin(), stocks.end());\\n        \\n        //base cases\\n        if(size == 1) return 0;\\n        \\n        long double prev_slope = slope(stocks[0], stocks[1]);\\n        \\n        int i = 1, j = 2, count = 1;\\n        while(j < size) {\\n            long double curr_slope = slope(stocks[i], stocks[j]);\\n            if(prev_slope != curr_slope) {\\n                count++;\\n            }\\n            prev_slope = curr_slope;\\n            i++;j++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062116,
                "title": "java-solution-y3-y2-x2-x1-y2-y1-x3-x2",
                "content": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        \\n        Arrays.sort(stockPrices, (a, b) -> (a[0] - b[0]));\\n        \\n        if(stockPrices.length == 1)\\n            return 0;\\n        \\n        if(stockPrices.length == 2) {\\n            return 1;\\n        }\\n        \\n        int count = 1;\\n        \\n        for(int i = 2; i < stockPrices.length; i++) {\\n            int x3 = stockPrices[i][0];\\n            int y3 = stockPrices[i][1];\\n            \\n            int x2 = stockPrices[i - 1][0];\\n            int y2 = stockPrices[i - 1][1];\\n            \\n            int x1 = stockPrices[i - 2][0];\\n            int y1 = stockPrices[i - 2][1];\\n            \\n            if((long)(y3 - y2)*(x2 - x1) != (long)(y2 - y1)*(x3 - x2))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        \\n        Arrays.sort(stockPrices, (a, b) -> (a[0] - b[0]));\\n        \\n        if(stockPrices.length == 1)\\n            return 0;\\n        \\n        if(stockPrices.length == 2) {\\n            return 1;\\n        }\\n        \\n        int count = 1;\\n        \\n        for(int i = 2; i < stockPrices.length; i++) {\\n            int x3 = stockPrices[i][0];\\n            int y3 = stockPrices[i][1];\\n            \\n            int x2 = stockPrices[i - 1][0];\\n            int y2 = stockPrices[i - 1][1];\\n            \\n            int x1 = stockPrices[i - 2][0];\\n            int y1 = stockPrices[i - 2][1];\\n            \\n            if((long)(y3 - y2)*(x2 - x1) != (long)(y2 - y1)*(x3 - x2))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062097,
                "title": "easiest-c-solution",
                "content": "I failed the hidden test case (added double instead of long double)\\nSimilar to: https://leetcode.com/problems/max-points-on-a-line/\\n```\\nWe calculate the slope and store it in an array then we calculate the number of changing slopes, can also be done in O(1) space (by comparing previous slope with current slope)\\n```\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& a) {\\n        int ans=0;\\n        sort(a.begin(), a.end());\\n        vector<long double> v;\\n        if(a.size() == 1)\\n            return 0;\\n        \\n        for(int i = 0; i < a.size() - 1; i++){\\n              int dy = a[i+1][1] - a[i][1];\\n              int dx = a[i+1][0] - a[i][0];\\n              \\n             long double x = (long double)dy / dx;\\n             v.push_back(x);\\n        }\\n        \\n        for(int i = 0; i < v.size()-1; ++i){\\n            if(v[i] != v[i+1])\\n                ans++;\\n        }\\n        return ans+=1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nWe calculate the slope and store it in an array then we calculate the number of changing slopes, can also be done in O(1) space (by comparing previous slope with current slope)\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& a) {\\n        int ans=0;\\n        sort(a.begin(), a.end());\\n        vector<long double> v;\\n        if(a.size() == 1)\\n            return 0;\\n        \\n        for(int i = 0; i < a.size() - 1; i++){\\n              int dy = a[i+1][1] - a[i][1];\\n              int dx = a[i+1][0] - a[i][0];\\n              \\n             long double x = (long double)dy / dx;\\n             v.push_back(x);\\n        }\\n        \\n        for(int i = 0; i < v.size()-1; ++i){\\n            if(v[i] != v[i+1])\\n                ans++;\\n        }\\n        return ans+=1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062090,
                "title": "matching-slopes-java",
                "content": "### Logic:\\nOne way to check if two points belong to the same line is to check if their slope is the same. We will run into precision issues if we calculate the slope simply through (rise/run) even when using doubles. Therefore, we will simply use the rise and run values themselves to find the slope.\\n\\nWe\\'re only concerned about adjacent points. So we will iterate for every two points (since you need at least two points to make a line). Therefore, we can conclude that if the previous slope is the same as the current, we\\'re still using the same line. All we need to do then is update our previous slope whenever there\\'s a change in slope and increment minLines when this happens.\\n\\nNote: we don\\'t need to worry about the +c (vertical displacement) in the slope equation since we\\'re comparing points with the same relative c value.\\n\\n### Greatest Common Divisor\\nWe\\'ll have some situations where two points are on the same line but have different rise and run values. Take these two slopes for example:\\n* rise/run = 2/6\\n* rise/run = 1/3\\n\\nHere, we have the same slope since as a decimal value, they are the same. The best way to check that these two are the same without dividing is to check their greatest common divisor (GCD). We can do this using the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm).\\n\\n### Code:\\nFeel free to ask any questions or suggest any improvements!\\n```java\\nclass Solution {\\n    public int minimumLines(int[][] points) {\\n\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0]));\\n        \\n        int minLines = 0;\\n        int n = points.length;\\n        if (n <= 1) return 0;\\n        if (n == 2) return 1;\\n        \\n        String prevSlope = \"\";\\n        for (int i=0; i<n-1; i++) {\\n            int[] pointI = points[i];\\n            int[] pointJ = points[i+1];\\n            \\n            int dx = pointJ[0] - pointI[0];\\n            int dy = pointJ[1] - pointI[1];\\n            \\n            String slope = getSlope(dx, dy);\\n            if (slope.equals(prevSlope)) continue;\\n            minLines++;\\n            prevSlope = slope;\\n        }\\n        \\n        return minLines;\\n    }\\n    \\n    private String getSlope(int dx, int dy) {\\n        if (dx != 0 && dy == 0) return \"0/1\";\\n        if (dx == 0 && dy != 0) return \"1/0\";\\n        \\n        int gcd = getGCD(dx, dy);\\n        dx /= gcd;\\n        dy /= gcd;\\n        return dy + \"/\" + dx;\\n    }\\n    \\n\\t// Euclidean algorithm\\n    private int getGCD(int a, int b) {\\n        if (b == 0) return a;\\n        return getGCD(b, a%b);\\n    }\\n}\\n```\\n**Time complexity:** `O(nlogn)` due to sorting and since we compare (n-1) slopes and check the GCD each time which takes log(n) time.\\n**Space complexity:** `O(1)`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minimumLines(int[][] points) {\\n\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0]));\\n        \\n        int minLines = 0;\\n        int n = points.length;\\n        if (n <= 1) return 0;\\n        if (n == 2) return 1;\\n        \\n        String prevSlope = \"\";\\n        for (int i=0; i<n-1; i++) {\\n            int[] pointI = points[i];\\n            int[] pointJ = points[i+1];\\n            \\n            int dx = pointJ[0] - pointI[0];\\n            int dy = pointJ[1] - pointI[1];\\n            \\n            String slope = getSlope(dx, dy);\\n            if (slope.equals(prevSlope)) continue;\\n            minLines++;\\n            prevSlope = slope;\\n        }\\n        \\n        return minLines;\\n    }\\n    \\n    private String getSlope(int dx, int dy) {\\n        if (dx != 0 && dy == 0) return \"0/1\";\\n        if (dx == 0 && dy != 0) return \"1/0\";\\n        \\n        int gcd = getGCD(dx, dy);\\n        dx /= gcd;\\n        dy /= gcd;\\n        return dy + \"/\" + dx;\\n    }\\n    \\n\\t// Euclidean algorithm\\n    private int getGCD(int a, int b) {\\n        if (b == 0) return a;\\n        return getGCD(b, a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062078,
                "title": "java-simple-explained-slope-equation",
                "content": "Approach followed is:\\nif we have only `1 point` - then no line required.\\nif we have only `2 points` - then 1 line is required.\\n\\nif more than 2 points, we can pick 3 points and check for collinearity.\\n**Slope is defined as (y2 - y1) / (x2 - x1)**\\n\\n**For points to be collinear, slope should be same.\\ni.e (y3 - y2) / (x3 - x2) == (y2 - y1) / (x2 - x1) **\\n\\nTo avoid `division by zero exception`, lets modify as:\\n(x2 - x1) * (y3 - y2) ==  (x3 - x2) * (y2 - y1)\\n\\nNow if points are not collinear, means new line is required so increase lines.\\n\\nNote: I started with lines = 1 since a first two points are always make a line.\\n\\n```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        int n = stockPrices.length;\\n        if (n == 1) {\\n            return 0;\\n        }\\n        if (n == 2) {\\n            return 1;\\n        }\\n        \\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n        int lines = 1;\\n        for (int i = 0; i < n - 2; ++i) {\\n            int x1 = stockPrices[i][0];\\n            int y1 = stockPrices[i][1];\\n            int x2 = stockPrices[i + 1][0];\\n            int y2 = stockPrices[i + 1][1];\\n            int x3 = stockPrices[i + 2][0];\\n            int y3 = stockPrices[i + 2][1];\\n            \\n            if (((long) (x2 - x1) * (y3 - y2)) != ((long) (x3 - x2) * (y2 - y1))) {\\n                ++lines;\\n            }\\n        }\\n        return lines;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        int n = stockPrices.length;\\n        if (n == 1) {\\n            return 0;\\n        }\\n        if (n == 2) {\\n            return 1;\\n        }\\n        \\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n        int lines = 1;\\n        for (int i = 0; i < n - 2; ++i) {\\n            int x1 = stockPrices[i][0];\\n            int y1 = stockPrices[i][1];\\n            int x2 = stockPrices[i + 1][0];\\n            int y2 = stockPrices[i + 1][1];\\n            int x3 = stockPrices[i + 2][0];\\n            int y3 = stockPrices[i + 2][1];\\n            \\n            if (((long) (x2 - x1) * (y3 - y2)) != ((long) (x3 - x2) * (y2 - y1))) {\\n                ++lines;\\n            }\\n        }\\n        return lines;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062061,
                "title": "c-easy-solution-slope-beginner-friendly",
                "content": "class Solution {\\npublic:\\n\\n    int minimumLines(vector<vector<int>>& s) {\\n        int n=s.size();\\n        int ans=1;\\n        if(s.size()<2){\\n            return 0;\\n        }\\n        sort(s.begin(),s.end());\\n        for(int i=1; i<n-1; i++){\\n            long double x1=s[i-1][0];\\n            long double y1=s[i-1][1];\\n            long double x2=s[i][0];\\n            long double y2=s[i][1];\\n            long double x3=s[i+1][0];\\n            long double y3=s[i+1][1];\\n            long double s1=(long double)((y2-y1)/(x2-x1));\\n            long double s2=(long double)((y3-y2)/(x3-x2));\\n            if(s1!=s2){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minimumLines(vector<vector<int>>& s) {\\n        int n=s.size();\\n        int ans=1;\\n        if(s.size()<2){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2062039,
                "title": "python-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minimumLines(self, stockPrices: List[List[int]]) -> int:\\n\\t\\t\\tif len(stockPrices) == 1:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tstockPrices.sort()\\n\\t\\t\\tx1, y1 = stockPrices[0]\\n\\t\\t\\tx2, y2 = stockPrices[1]\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(2, len(stockPrices)):\\n\\t\\t\\t\\tday, price = stockPrices[i]\\n\\t\\t\\t\\tif abs(price - y1) * abs(x2 - x1) == abs(day - x1) * abs(y2 - y1):\\n\\t\\t\\t\\t\\tx2, y2 = day, price\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tx1, y1, x2, y2 = x2, y2, day, price\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\treturn res + 1",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minimumLines(self, stockPrices: List[List[int]]) -> int:\\n\\t\\t\\tif len(stockPrices) == 1:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tstockPrices.sort()\\n\\t\\t\\tx1, y1 = stockPrices[0]\\n\\t\\t\\tx2, y2 = stockPrices[1]\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(2, len(stockPrices)):\\n\\t\\t\\t\\tday, price = stockPrices[i]\\n\\t\\t\\t\\tif abs(price - y1) * abs(x2 - x1) == abs(day - x1) * abs(y2 - y1):\\n\\t\\t\\t\\t\\tx2, y2 = day, price\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tx1, y1, x2, y2 = x2, y2, day, price\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\treturn res + 1",
                "codeTag": "Java"
            },
            {
                "id": 2062011,
                "title": "any-accepted-soln-for-javascript",
                "content": "This one is failing for hidden testcases\\n\\n```\\n/**\\n * @param {number[][]} stockPrices\\n * @return {number}\\n */\\nvar minimumLines = function(sP) {\\n    \\n    let n = sP.length;\\n    let prev , ans = 0;\\n    sP.sort((a,b)=>{\\n        return a[0] - b[0];\\n    })\\n    for(let i = 1; i < n; i++){\\n        let slope = (sP[i][1] - sP[i-1][1]) / (sP[i][0] - sP[i-1][0]);\\n        if(prev != slope)\\n            ans++;\\n        \\n        prev = slope;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} stockPrices\\n * @return {number}\\n */\\nvar minimumLines = function(sP) {\\n    \\n    let n = sP.length;\\n    let prev , ans = 0;\\n    sP.sort((a,b)=>{\\n        return a[0] - b[0];\\n    })\\n    for(let i = 1; i < n; i++){\\n        let slope = (sP[i][1] - sP[i-1][1]) / (sP[i][0] - sP[i-1][0]);\\n        if(prev != slope)\\n            ans++;\\n        \\n        prev = slope;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062006,
                "title": "very-easy-approach-sorting-simple-math",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        if(sp.size()==2)return 1;\\n        int n= sp.size();\\n       long double m=LONG_MIN;\\n        int count=0;\\n        sort(sp.begin(), sp.end());\\n       \\n        for(int i=0 ; i<n-1 ; i++){\\n            long double x= sp[i+1][0]-sp[i][0];\\n             long double y= sp[i+1][1]-sp[i][1];\\n            long double temp=y/x;\\n            if(temp!=m){\\n                count++;\\n            }\\n            m=temp;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        if(sp.size()==2)return 1;\\n        int n= sp.size();\\n       long double m=LONG_MIN;\\n        int count=0;\\n        sort(sp.begin(), sp.end());\\n       \\n        for(int i=0 ; i<n-1 ; i++){\\n            long double x= sp[i+1][0]-sp[i][0];\\n             long double y= sp[i+1][1]-sp[i][1];\\n            long double temp=y/x;\\n            if(temp!=m){\\n                count++;\\n            }\\n            m=temp;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061966,
                "title": "c-very-simple",
                "content": "```\\n#define INF 1.7976931348623157E+308\\n\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>> &stockPrices) {\\n        long double slope = INF;\\n        int totalLines = 0;\\n        sort(stockPrices.begin(), stockPrices.end(), [](vector<int> &a, vector<int> &b) {\\n            return a[0] < b[0];\\n        });\\n        for (int i = 1; i < stockPrices.size(); i++) {\\n            long double deno = stockPrices[i][1] - stockPrices[i - 1][1];\\n            long double num = stockPrices[i][0] - stockPrices[i - 1][0];\\n            long double cslope = num / deno;\\n            if (cslope != slope) {\\n                totalLines++;\\n                slope = cslope;\\n            }\\n        }\\n\\n        return totalLines;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define INF 1.7976931348623157E+308\\n\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>> &stockPrices) {\\n        long double slope = INF;\\n        int totalLines = 0;\\n        sort(stockPrices.begin(), stockPrices.end(), [](vector<int> &a, vector<int> &b) {\\n            return a[0] < b[0];\\n        });\\n        for (int i = 1; i < stockPrices.size(); i++) {\\n            long double deno = stockPrices[i][1] - stockPrices[i - 1][1];\\n            long double num = stockPrices[i][0] - stockPrices[i - 1][0];\\n            long double cslope = num / deno;\\n            if (cslope != slope) {\\n                totalLines++;\\n                slope = cslope;\\n            }\\n        }\\n\\n        return totalLines;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061943,
                "title": "c-easy-solution-check-slope",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        if(stockPrices.size()==1 || stockPrices.size()==0)\\n            return 0;\\n        sort(stockPrices.begin(),stockPrices.end());\\n        int count = 1;\\n        for(int i=2;i<stockPrices.size();i++)\\n        {\\n            long y1 = stockPrices[i][1];\\n            long x1 = stockPrices[i][0];\\n            long y2 = stockPrices[i-1][1];\\n            long x2 = stockPrices[i-1][0];\\n            long y3 = stockPrices[i-2][1];\\n            long x3 = stockPrices[i-2][0];\\n            if((y2-y1)*(x3-x1) != (y3-y1)*(x2-x1))\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        if(stockPrices.size()==1 || stockPrices.size()==0)\\n            return 0;\\n        sort(stockPrices.begin(),stockPrices.end());\\n        int count = 1;\\n        for(int i=2;i<stockPrices.size();i++)\\n        {\\n            long y1 = stockPrices[i][1];\\n            long x1 = stockPrices[i][0];\\n            long y2 = stockPrices[i-1][1];\\n            long x2 = stockPrices[i-1][0];\\n            long y3 = stockPrices[i-2][1];\\n            long x3 = stockPrices[i-2][0];\\n            if((y2-y1)*(x3-x1) != (y3-y1)*(x2-x1))\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061927,
                "title": "simple-maths-slope-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int n=stockPrices.size();\\n        int count=1;\\n        if(n<=1)\\n        {\\n            return 0;\\n        }\\n        \\n        sort(stockPrices.begin(),stockPrices.end());\\n      for(int i=0;i<n-2;i++)\\n      {\\n         long y1 = stockPrices[i][1];\\n            long x1 = stockPrices[i][0];\\n            long y2 = stockPrices[i+1][1];\\n            long x2 = stockPrices[i+1][0];\\n            long y3 = stockPrices[i+2][1];\\n            long x3 = stockPrices[i+2][0]; \\n          if((y2-y1)*(x3-x1) != (y3-y1)*(x2-x1))\\n                count++;\\n      }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int n=stockPrices.size();\\n        int count=1;\\n        if(n<=1)\\n        {\\n            return 0;\\n        }\\n        \\n        sort(stockPrices.begin(),stockPrices.end());\\n      for(int i=0;i<n-2;i++)\\n      {\\n         long y1 = stockPrices[i][1];\\n            long x1 = stockPrices[i][0];\\n            long y2 = stockPrices[i+1][1];\\n            long x2 = stockPrices[i+1][0];\\n            long y3 = stockPrices[i+2][1];\\n            long x3 = stockPrices[i+2][0]; \\n          if((y2-y1)*(x3-x1) != (y3-y1)*(x2-x1))\\n                count++;\\n      }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061925,
                "title": "python-geometry",
                "content": "\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\tif n == 1 : return 0\\n\\t\\t\\tarr.sort(key = lambda x:x[0]) \\n\\t\\t\\tx0 = arr[0][0]\\n\\t\\t\\ty0 = arr[0][1]\\n\\n\\t\\t\\tx1 = arr[1][0]\\n\\t\\t\\ty1 = arr[1][1]\\n\\n\\t\\t\\tdx = x1 - x0\\n\\t\\t\\tdy = y1 - y0\\n\\t\\t\\tres = 1\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tx = arr[i][0]\\n\\t\\t\\t\\ty = arr[i][1] \\n\\n\\t\\t\\t\\tif (dx * (y - y1) != dy * (x - x1)): \\n\\t\\t\\t\\t\\tres+=1\\n\\t\\t\\t\\t\\tx0 = arr[i-1][0]\\n\\t\\t\\t\\t\\ty0 = arr[i-1][1]\\n\\n\\t\\t\\t\\t\\tx1 = arr[i][0]\\n\\t\\t\\t\\t\\ty1 = arr[i][1]\\n\\n\\t\\t\\t\\t\\tdx = x1 - x0\\n\\t\\t\\t\\t\\tdy = y1 - y0\\n\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\tif n == 1 : return 0\\n\\t\\t\\tarr.sort(key = lambda x:x[0]) \\n\\t\\t\\tx0 = arr[0][0]\\n\\t\\t\\ty0 = arr[0][1]\\n\\n\\t\\t\\tx1 = arr[1][0]\\n\\t\\t\\ty1 = arr[1][1]\\n\\n\\t\\t\\tdx = x1 - x0\\n\\t\\t\\tdy = y1 - y0\\n\\t\\t\\tres = 1\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tx = arr[i][0]\\n\\t\\t\\t\\ty = arr[i][1] \\n\\n\\t\\t\\t\\tif (dx * (y - y1) != dy * (x - x1)): \\n\\t\\t\\t\\t\\tres+=1\\n\\t\\t\\t\\t\\tx0 = arr[i-1][0]\\n\\t\\t\\t\\t\\ty0 = arr[i-1][1]\\n\\n\\t\\t\\t\\t\\tx1 = arr[i][0]\\n\\t\\t\\t\\t\\ty1 = arr[i][1]\\n\\n\\t\\t\\t\\t\\tdx = x1 - x0\\n\\t\\t\\t\\t\\tdy = y1 - y0\\n\\n\\t\\t\\treturn res",
                "codeTag": "Unknown"
            },
            {
                "id": 2061899,
                "title": "long-double-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& s) {\\n        sort(s.begin(),s.end());\\n        int res = 0;\\n        if(s.size()==1) return 0;\\n        long double slope = INT_MIN;\\n        for(int i=1;i<s.size();i++){\\n           long double x = (long double)s[i][0]-s[i-1][0];\\n           long double y = (long double)s[i][1]-s[i-1][1];\\n             long double m = (long double)y/x;\\n            if(m!=slope){\\n                slope = m;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& s) {\\n        sort(s.begin(),s.end());\\n        int res = 0;\\n        if(s.size()==1) return 0;\\n        long double slope = INT_MIN;\\n        for(int i=1;i<s.size();i++){\\n           long double x = (long double)s[i][0]-s[i-1][0];\\n           long double y = (long double)s[i][1]-s[i-1][1];\\n             long double m = (long double)y/x;\\n            if(m!=slope){\\n                slope = m;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061872,
                "title": "slope-and-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int, int> fun(int y1, int x1)\\n    {\\n        int temp=gcd(abs(y1),abs(x1));\\n        bool x=(y1<0)^(x1<0);\\n        if (!x)\\n            return {abs(y1)/temp,abs(x1)/temp};\\n        return {-abs(y1)/temp,abs(x1)/temp};\\n            \\n    }\\n    int minimumLines(vector<vector<int>>& s) {\\n        if(s.size()==0||s.size()==1)\\n            return 0;\\n        if(s.size()==2)\\n            return 1;\\n        int result=1;\\n        sort(s.begin(),s.end(),\\n             [](auto &a, auto &b){\\n                 if(a[0]==b[0])\\n                     return a[1]<b[1];\\n                 return a[0]<b[0];\\n                 });\\n        pair<int, int> temp={s[1][1]-s[0][1],s[1][0]-s[0][0]},temp1;\\n        for(int i=2;i<s.size();i++)\\n        {\\n            temp1=fun(s[i][1]-s[i-1][1],s[i][0]-s[i-1][0]);\\n            if(temp.first!=temp1.first||temp.second!=temp1.second)\\n            {\\n                result++;\\n                temp=fun(s[i][1]-s[i-1][1],s[i][0]-s[i-1][0]);\\n            }\\n            \\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    pair<int, int> fun(int y1, int x1)\\n    {\\n        int temp=gcd(abs(y1),abs(x1));\\n        bool x=(y1<0)^(x1<0);\\n        if (!x)\\n            return {abs(y1)/temp,abs(x1)/temp}",
                "codeTag": "Java"
            },
            {
                "id": 2061864,
                "title": "sort-and-skip-points-with-the-same-slope",
                "content": "1) Sort all the points based on the x coordinate.\\n2) Iterate through all the points and skip the ones which are on the same line as the previous point. For three points (x1, y1), (x2, y2) and (x3, y3) to be on the same line we know the slope should be same, i.e. `(y2 - y1) / (x2 - x1) == (y3 - y2) / (x3 - x2)`. We can rewrite this as `(y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1)` to avoid comparing float values.\\n\\n```\\nfunc minimumLines(stockPrices [][]int) int {\\n    sort.Slice(stockPrices, func(i, j int) bool {\\n        return stockPrices[i][0] < stockPrices[j][0]\\n    })\\n    \\n    px, py := stockPrices[0][0], stockPrices[0][1]\\n    count, i := 0, 1\\n    for i < len(stockPrices) {\\n        x, y := stockPrices[i][0], stockPrices[i][1]\\n        i++\\n        // skip all points with same slope\\n        for ; i < len(stockPrices); i++ {\\n            ax, ay := stockPrices[i][0], stockPrices[i][1]\\n            if (ay - y) * (x - px) != (y - py) * (ax - x) {\\n                break\\n            }\\n        }\\n        px, py = stockPrices[i - 1][0], stockPrices[i - 1][1]\\n        count++\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```\\nfunc minimumLines(stockPrices [][]int) int {\\n    sort.Slice(stockPrices, func(i, j int) bool {\\n        return stockPrices[i][0] < stockPrices[j][0]\\n    })\\n    \\n    px, py := stockPrices[0][0], stockPrices[0][1]\\n    count, i := 0, 1\\n    for i < len(stockPrices) {\\n        x, y := stockPrices[i][0], stockPrices[i][1]\\n        i++\\n        // skip all points with same slope\\n        for ; i < len(stockPrices); i++ {\\n            ax, ay := stockPrices[i][0], stockPrices[i][1]\\n            if (ay - y) * (x - px) != (y - py) * (ax - x) {\\n                break\\n            }\\n        }\\n        px, py = stockPrices[i - 1][0], stockPrices[i - 1][1]\\n        count++\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061829,
                "title": "c-2280-minimum-lines-to-represent-a-line-chart",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(), stockPrices.end()); \\n        int ans = 0; \\n        for (int i = 1; i < stockPrices.size(); ++i) \\n            if (i == 1 || (long) (stockPrices[i][1] - stockPrices[i-1][1]) * (stockPrices[i-1][0] - stockPrices[i-2][0]) != (long) (stockPrices[i-1][1] - stockPrices[i-2][1]) * (stockPrices[i][0] - stockPrices[i-1][0]))\\n                ++ans; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(), stockPrices.end()); \\n        int ans = 0; \\n        for (int i = 1; i < stockPrices.size(); ++i) \\n            if (i == 1 || (long) (stockPrices[i][1] - stockPrices[i-1][1]) * (stockPrices[i-1][0] - stockPrices[i-2][0]) != (long) (stockPrices[i-1][1] - stockPrices[i-2][1]) * (stockPrices[i][0] - stockPrices[i-1][0]))\\n                ++ans; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061814,
                "title": "python-solution-slope-concept-o-nlogn-sorting",
                "content": "```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        if len(stockPrices) == 1:\\n            return 0\\n        stockPrices.sort(key = lambda x: x[0])\\n        ans = 1\\n        for i in range(1,len(stockPrices)-1):\\n            if (stockPrices[i+1][1]-stockPrices[i][1])*(stockPrices[i][0]-stockPrices[i-1][0]) != (stockPrices[i+1][0]-stockPrices[i][0])*(stockPrices[i][1]-stockPrices[i-1][1]):\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        if len(stockPrices) == 1:\\n            return 0\\n        stockPrices.sort(key = lambda x: x[0])\\n        ans = 1\\n        for i in range(1,len(stockPrices)-1):\\n            if (stockPrices[i+1][1]-stockPrices[i][1])*(stockPrices[i][0]-stockPrices[i-1][0]) != (stockPrices[i+1][0]-stockPrices[i][0])*(stockPrices[i][1]-stockPrices[i-1][1]):\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061790,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumLines(int[][] sp) {\\n        Arrays.sort(sp, (int[] a, int[] b) -> a[0] == b[0] ? a[1] - b[1] : a[0]-b[0]);\\n        Node prev = null;\\n        int count = 0;\\n        for(int i =1; i<sp.length; i++){\\n            int slopX = sp[i][0] - sp[i-1][0], slopY = sp[i][1] - sp[i-1][1], gcd = gcd(slopX, slopY);\\n            Node temp = new Node(slopX/gcd, slopY/gcd);\\n            if(!isSame(prev, temp))\\n            {\\n                count++;\\n                prev = temp;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int gcd(int a, int b)\\n    {\\n      if (b == 0)\\n        return a;\\n      return gcd(b, a % b);\\n    }\\n    \\n    boolean isSame(Node a, Node b){\\n        return a!= null && b!= null && a.x == b.x && a.y == b.y;\\n    }\\n    \\n    class Node{\\n        int x, y;\\n        Node(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] sp) {\\n        Arrays.sort(sp, (int[] a, int[] b) -> a[0] == b[0] ? a[1] - b[1] : a[0]-b[0]);\\n        Node prev = null;\\n        int count = 0;\\n        for(int i =1; i<sp.length; i++){\\n            int slopX = sp[i][0] - sp[i-1][0], slopY = sp[i][1] - sp[i-1][1], gcd = gcd(slopX, slopY);\\n            Node temp = new Node(slopX/gcd, slopY/gcd);\\n            if(!isSame(prev, temp))\\n            {\\n                count++;\\n                prev = temp;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int gcd(int a, int b)\\n    {\\n      if (b == 0)\\n        return a;\\n      return gcd(b, a % b);\\n    }\\n    \\n    boolean isSame(Node a, Node b){\\n        return a!= null && b!= null && a.x == b.x && a.y == b.y;\\n    }\\n    \\n    class Node{\\n        int x, y;\\n        Node(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919747,
                "title": "python-heap-with-explanation",
                "content": "# Intuition\\nWe first need to know what defines as a new line.\\n\\nIn order to do so, we have to compute the gradients between two points.\\n\\n# Approach\\nWe first initialize a value for the gradient (this can be `float(\\'inf\\')` or `float(\\'-inf\\')`).\\n\\nWe keep popping values from the heap compute the gradients.\\n\\n*Note that we need to use the function of `Fraction` here, otherwise certain test cases will fail for gradients with very large number of decimal places. Python rounds up the values which will not register as a different gradient.*\\n\\nAt the end of each loop, we update x1, y1 with x2, y2 to begin the next iteration.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom fractions import Fraction\\n\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n\\n        # as the stock prices for day is not in sorted order,\\n        # we can use a heap to automatically \\'sort\\' the values in the list of\\n        # stock prices\\n\\n        heapq.heapify(stockPrices)\\n\\n        # idea is to iterate through the minHeap and determine if the next subsequent point\\n        # can be on the \\'same line\\'\\n        # how to determine if it is on the \\'same line\\'\\n        # we can use the gradient of previous two points and check if next point is the same\\n\\n        res = 0\\n        startLine = True\\n        x1, y1 = heapq.heappop(stockPrices)\\n        gradient = float(\\'inf\\')\\n        while stockPrices:\\n\\n            x2, y2 = heapq.heappop(stockPrices)\\n            new_gradient = self.get_gradient(x1, y1, x2, y2)\\n            if new_gradient != gradient:\\n                res += 1\\n            gradient = new_gradient\\n            x1, y1 = x2, y2\\n\\n        return res\\n\\n    def get_gradient(self, x1, y1, x2, y2):\\n        if y2 == y1:\\n            return 0\\n        # use Fraction instead of (y2 - y1) / (x2 - x1)\\n        # python will round the numbers giving a wrong answer\\n        # for specific test cases\\n        return Fraction(y2 - y1, x2 - x1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom fractions import Fraction\\n\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n\\n        # as the stock prices for day is not in sorted order,\\n        # we can use a heap to automatically \\'sort\\' the values in the list of\\n        # stock prices\\n\\n        heapq.heapify(stockPrices)\\n\\n        # idea is to iterate through the minHeap and determine if the next subsequent point\\n        # can be on the \\'same line\\'\\n        # how to determine if it is on the \\'same line\\'\\n        # we can use the gradient of previous two points and check if next point is the same\\n\\n        res = 0\\n        startLine = True\\n        x1, y1 = heapq.heappop(stockPrices)\\n        gradient = float(\\'inf\\')\\n        while stockPrices:\\n\\n            x2, y2 = heapq.heappop(stockPrices)\\n            new_gradient = self.get_gradient(x1, y1, x2, y2)\\n            if new_gradient != gradient:\\n                res += 1\\n            gradient = new_gradient\\n            x1, y1 = x2, y2\\n\\n        return res\\n\\n    def get_gradient(self, x1, y1, x2, y2):\\n        if y2 == y1:\\n            return 0\\n        # use Fraction instead of (y2 - y1) / (x2 - x1)\\n        # python will round the numbers giving a wrong answer\\n        # for specific test cases\\n        return Fraction(y2 - y1, x2 - x1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684445,
                "title": "c-solution-o-n",
                "content": "class Solution {\\npublic:\\n   long double slope(int i,vector<vector<int>>& points)\\n    {\\n        long double num=points[i+1][1]-points[i][1];\\n         long double den=points[i+1][0]-points[i][0];\\n        return (num/den);\\n    }\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        if(stockPrices.size()==1)\\n        {\\n            return 0;\\n        }\\n        // else if(stockPrices.size()==3)\\n        // {\\n        //     return 2;\\n        // }\\n      long double new1;\\n        sort(stockPrices.begin(),stockPrices.end());\\n      long double check=slope(0,stockPrices);\\n        int count=1;\\n        for(int i=1;i<stockPrices.size()-1;i++)\\n        {\\n            new1=slope(i,stockPrices);\\n            if(new1==check)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                check=new1;\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n   long double slope(int i,vector<vector<int>>& points)\\n    {\\n        long double num=points[i+1][1]-points[i][1];\\n         long double den=points[i+1][0]-points[i][0];\\n        return (num/den);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3513542,
                "title": "java-same-like-leetcode-149-and-447-with-comments",
                "content": "// b <============2280. Minimum Lines to Represent a Line Chart ========>\\n    // https://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/description/\\n\\n    // # Logic is same as 149 below mentioned.\\n\\n```\\n    public int minimumLines(int[][] arr) {\\n\\n        int n = arr.length;\\n        Arrays.sort(arr, (a, b) -> {\\n            return a[0] - b[0];\\n        });\\n        String prev = \"$\";\\n        int count = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            int yDiff = arr[i + 1][1] - arr[i][1];\\n            int xDiff = arr[i + 1][0] - arr[i][0];\\n\\n            int gcd = getGcd(yDiff, xDiff);\\n            yDiff /= gcd;\\n            xDiff /= gcd;\\n\\n            String s = xDiff + \"@\" + yDiff;\\n            if (!s.equals(prev))\\n                count++;\\n            prev = s;\\n        }\\n\\n        return count;\\n    }\\n\\n    public static int getGcd(int a, int b) {\\n        if (b == 0)\\n            return a;\\n        return getGcd(b, a % b);\\n    }\\n```\\n\\n\\n// b <===========149. Max Points on a Line ============>\\n    // https://leetcode.com/problems/max-points-on-a-line/\\n\\n    // # For the points to lie on the same line, their must be same.\\n    // # Agar kinhi points ke beech ka slope same hai to sare points ek he line mai\\n    // # lie karte hain.\\n\\n    // To bas same uper wale question ki tarah kiya.\\n    // Ek point ko pick kiya aur har dusre points se slope nikala. Jin points ke\\n    // sath slope same aaya ,wo sab same he line mai exist karte hain.\\n\\n    // Aur aisa har ek points ke sath kiya. End mai max nikal ke return kar diya.\\n\\n    // # Formula for slope is m=(y2-y1)/(x2-x1);\\n    // What if the denominator becomes 0, so the slope will become infinite.\\n\\n    // Now this needs to be handled. One thing is to replace it with very large\\n    // number that can be stored in hashMap as key and do increase count as same.\\n\\n    // Another way is to calculate the gcd of both, y2 - y1, x2 -x1, and reduce it\\n    // to the lowest fraction possible of slope by dividing both with their\\n    // gcd(greatest common divisor)\\n\\n    // Now we will create a unique string using the lowest fraction.\\n    // Hence here we do not have to consider infinity part, although it could be\\n    // handled.\\n\\n    // For example y2 - y1 is 18 and x2 - x1 is 14.\\n    // For another points , y2 - y1 is 9 and x2 - x1 is 7.\\n\\n    // Since both the slope are same as 18/14 is also 9/7.\\n    // So therefore, their string will be same 9@7 as 18/14 gcd will be 2 reducing\\n    // it to 9/7\\n\\n```\\npublic int maxPoints(int[][] points) {\\n\\n        HashMap<String, Integer> map = new HashMap<>();\\n\\n        int n = points.length, ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            int max = 0;\\n            for (int j = i + 1; j < n; j++) {\\n\\n                int yDiff = points[j][1] - points[i][1];\\n                int xDiff = points[j][0] - points[i][0];\\n\\n                int gcd = getGcd(yDiff, xDiff);\\n                yDiff /= gcd;\\n                xDiff /= gcd;\\n\\n                String s = xDiff + \"@\" + yDiff;\\n                map.put(s, map.getOrDefault(s, 0) + 1);\\n                max = Math.max(max, map.get(s));\\n            }\\n            ans = Math.max(ans, max + 1); // max + 1, since I am also a point . Maine apne aap ko count he nhi kiya tha\\n                                          // sare points mai ek line ke.\\n            map.clear();\\n        }\\n\\n        return ans;\\n    }\\n\\n    public static int getGcd(int a, int b) {\\n        if (b == 0)\\n            return a;\\n        return getGcd(b, a % b);\\n    }\\n```\\n\\n// b <========== 447. Number of Boomerangs =========>\\n    // https://leetcode.com/problems/number-of-boomerangs/description/\\n\\n    // Humne kiya ye pehle ek point liya. Usse har ek remaining point ki distance\\n    // calculate ki aur use hashmap mai store kiya. To hume end tak same distance pe\\n    // jitne points hai unki frequency count mil jayega.\\n\\n    // ab question ye hai ki tuple kitne banenge.\\n    // So agar manle mujse 1 distance pe 4 log mile hain, to tuple formed will be 4\\n    // * (4-1)= 4 * 3 ====> i.e. (n * n-1).\\n\\n    // How ???\\n\\n    // Since we have to find the pairs with same distance from me and these pairs\\n    // can have arrangement as can be seen in the test case, at the end we have to\\n    // find permutation, which will be nP2. i.e. n!/(n-2)!\\n\\n    // ==> Solving the above will turn out to be n * n-1.\\n\\n    // At the end map ko clear kar denge aur next point ke liiye same check karenge.\\n\\n\\t\\n\\t\\n\\t\\n![image.png](https://assets.leetcode.com/users/images/201bd407-f980-481b-96a1-33e8696fffa6_1683772690.1260123.png)\\n\\n\\n```\\npublic int numberOfBoomerangs(int[][] points) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int n = points.length;\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == j)\\n                    continue;\\n\\n                int dis = getDistance(points, i, j);\\n                map.put(dis, map.getOrDefault(dis, 0) + 1);\\n            }\\n\\n            for (int value : map.values()) {\\n                count += value * (value - 1);\\n            }\\n\\n            map.clear();\\n        }\\n\\n        return count;\\n    }\\n\\n    public static int getDistance(int[][] points, int i, int j) {\\n        int x = points[i][0] - points[j][0];\\n        int y = points[i][1] - points[j][1];\\n\\n        return x * x + y * y;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int minimumLines(int[][] arr) {\\n\\n        int n = arr.length;\\n        Arrays.sort(arr, (a, b) -> {\\n            return a[0] - b[0];\\n        });\\n        String prev = \"$\";\\n        int count = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            int yDiff = arr[i + 1][1] - arr[i][1];\\n            int xDiff = arr[i + 1][0] - arr[i][0];\\n\\n            int gcd = getGcd(yDiff, xDiff);\\n            yDiff /= gcd;\\n            xDiff /= gcd;\\n\\n            String s = xDiff + \"@\" + yDiff;\\n            if (!s.equals(prev))\\n                count++;\\n            prev = s;\\n        }\\n\\n        return count;\\n    }\\n\\n    public static int getGcd(int a, int b) {\\n        if (b == 0)\\n            return a;\\n        return getGcd(b, a % b);\\n    }\\n```\n```\\npublic int maxPoints(int[][] points) {\\n\\n        HashMap<String, Integer> map = new HashMap<>();\\n\\n        int n = points.length, ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            int max = 0;\\n            for (int j = i + 1; j < n; j++) {\\n\\n                int yDiff = points[j][1] - points[i][1];\\n                int xDiff = points[j][0] - points[i][0];\\n\\n                int gcd = getGcd(yDiff, xDiff);\\n                yDiff /= gcd;\\n                xDiff /= gcd;\\n\\n                String s = xDiff + \"@\" + yDiff;\\n                map.put(s, map.getOrDefault(s, 0) + 1);\\n                max = Math.max(max, map.get(s));\\n            }\\n            ans = Math.max(ans, max + 1); // max + 1, since I am also a point . Maine apne aap ko count he nhi kiya tha\\n                                          // sare points mai ek line ke.\\n            map.clear();\\n        }\\n\\n        return ans;\\n    }\\n\\n    public static int getGcd(int a, int b) {\\n        if (b == 0)\\n            return a;\\n        return getGcd(b, a % b);\\n    }\\n```\n```\\npublic int numberOfBoomerangs(int[][] points) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int n = points.length;\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == j)\\n                    continue;\\n\\n                int dis = getDistance(points, i, j);\\n                map.put(dis, map.getOrDefault(dis, 0) + 1);\\n            }\\n\\n            for (int value : map.values()) {\\n                count += value * (value - 1);\\n            }\\n\\n            map.clear();\\n        }\\n\\n        return count;\\n    }\\n\\n    public static int getDistance(int[][] points, int i, int j) {\\n        int x = points[i][0] - points[j][0];\\n        int y = points[i][1] - points[j][1];\\n\\n        return x * x + y * y;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328878,
                "title": "c-code-o-n",
                "content": "# Intuition\\ninstead of equating slope we can use:\\ny1/x1 = y2/x2 => y1*x2 = y2*x1\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& SP) {\\n        if(SP.size() == 1)\\n            return 0;\\n        sort(SP.begin(), SP.end());\\n        int i = 0;\\n        long long prev_y = SP[i+1][1] - SP[i][1], prev_x = SP[i+1][0]-SP[i][0], cur_y, cur_x;\\n        i++;\\n        int count = 0;\\n        for(i ; i < SP.size() - 1; i++){\\n            cur_y = SP[i+1][1] - SP[i][1];\\n            cur_x = SP[i+1][0] - SP[i][0];\\n            if(SP[i+1] == SP[i] || prev_y * cur_x == cur_y * prev_x)\\n                continue;\\n            else{\\n                prev_y = cur_y;\\n                prev_x = cur_x;\\n                count++;\\n            }\\n        } \\n        return count+1;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& SP) {\\n        if(SP.size() == 1)\\n            return 0;\\n        sort(SP.begin(), SP.end());\\n        int i = 0;\\n        long long prev_y = SP[i+1][1] - SP[i][1], prev_x = SP[i+1][0]-SP[i][0], cur_y, cur_x;\\n        i++;\\n        int count = 0;\\n        for(i ; i < SP.size() - 1; i++){\\n            cur_y = SP[i+1][1] - SP[i][1];\\n            cur_x = SP[i+1][0] - SP[i][0];\\n            if(SP[i+1] == SP[i] || prev_y * cur_x == cur_y * prev_x)\\n                continue;\\n            else{\\n                prev_y = cur_y;\\n                prev_x = cur_x;\\n                count++;\\n            }\\n        } \\n        return count+1;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328205,
                "title": "c-golang-sorting-geometry-slope",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(), stockPrices.end());\\n        int n = stockPrices.size(), ans = 0, prevN = 0, prevD = 0;\\n        for(int i = 1; i < n; i++) {\\n            int N = stockPrices[i][1] - stockPrices[i - 1][1];\\n            int D = stockPrices[i][0] - stockPrices[i - 1][0];\\n            int G = gcd(N, D);\\n            N /= G;\\n            D /= G;  \\n            if(N == prevN && D == prevD) continue;\\n            prevN = N;\\n            prevD = D;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n//------------------------------------------------\\n\\n// Golang\\nfunc computeGcd(m, n int) int {\\n    if m % n == 0 {return n}\\n    return computeGcd(n, m % n)\\n}\\n\\nfunc minimumLines(stockPrices [][]int) int {\\n    sort.Slice(stockPrices, func(i, j int) bool {\\n        return stockPrices[i][0] < stockPrices[j][0] \\n    })\\n    var n, ans, prevN, prevD int = len(stockPrices), 0, 0, 0\\n    for i := 1; i < n; i++ {\\n        numerator := stockPrices[i][1] - stockPrices[i - 1][1]\\n        denominator := stockPrices[i][0] - stockPrices[i - 1][0]\\n        gcd := computeGcd(numerator, denominator)\\n        numerator /= gcd\\n        denominator /= gcd  \\n        if numerator == prevN && denominator == prevD {continue}\\n        prevN = numerator\\n        prevD = denominator\\n        ans++\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Geometry",
                    "Sorting",
                    "Number Theory"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(), stockPrices.end());\\n        int n = stockPrices.size(), ans = 0, prevN = 0, prevD = 0;\\n        for(int i = 1; i < n; i++) {\\n            int N = stockPrices[i][1] - stockPrices[i - 1][1];\\n            int D = stockPrices[i][0] - stockPrices[i - 1][0];\\n            int G = gcd(N, D);\\n            N /= G;\\n            D /= G;  \\n            if(N == prevN && D == prevD) continue;\\n            prevN = N;\\n            prevD = D;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n//------------------------------------------------\\n\\n// Golang\\nfunc computeGcd(m, n int) int {\\n    if m % n == 0 {return n}\\n    return computeGcd(n, m % n)\\n}\\n\\nfunc minimumLines(stockPrices [][]int) int {\\n    sort.Slice(stockPrices, func(i, j int) bool {\\n        return stockPrices[i][0] < stockPrices[j][0] \\n    })\\n    var n, ans, prevN, prevD int = len(stockPrices), 0, 0, 0\\n    for i := 1; i < n; i++ {\\n        numerator := stockPrices[i][1] - stockPrices[i - 1][1]\\n        denominator := stockPrices[i][0] - stockPrices[i - 1][0]\\n        gcd := computeGcd(numerator, denominator)\\n        numerator /= gcd\\n        denominator /= gcd  \\n        if numerator == prevN && denominator == prevD {continue}\\n        prevN = numerator\\n        prevD = denominator\\n        ans++\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210506,
                "title": "simple-easy-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSlope Matching Solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst sort the points according to the x-axis value then find the slope of the first two points and match it with the slope of the next two points in which has first point as the second point of the previous slope. \\n\\nIf the slope matches then carry on the same process without incrementing the count of lines but if the slope doesn\\'t matches then increment the value of the count of the lines and keep the process going on.\\n\\nCorner case :\\nWhen there is only one point present to plot then count of lines will be zero.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int c=1;\\n        sort(stockPrices.begin(),stockPrices.end());\\n\\n        int dy,dx;\\n        long double slope1,slope2;\\n\\n        if(stockPrices.size()<2)\\n            return 0;\\n\\n        dx = stockPrices[1][0] - stockPrices[0][0];\\n        dy = stockPrices[1][1] - stockPrices[0][1];\\n        slope1 = (long double)dy/dx;\\n\\n        for(int i=1;i<stockPrices.size()-1;i++)\\n        {\\n            dx = stockPrices[i+1][0] - stockPrices[i][0];\\n            dy = stockPrices[i+1][1] - stockPrices[i][1];\\n            slope2 = (long double)dy/dx;\\n\\n            if(slope2!=slope1)\\n            {\\n                 c++;\\n                 slope1=slope2;\\n            }\\n        }\\n\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sorting",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int c=1;\\n        sort(stockPrices.begin(),stockPrices.end());\\n\\n        int dy,dx;\\n        long double slope1,slope2;\\n\\n        if(stockPrices.size()<2)\\n            return 0;\\n\\n        dx = stockPrices[1][0] - stockPrices[0][0];\\n        dy = stockPrices[1][1] - stockPrices[0][1];\\n        slope1 = (long double)dy/dx;\\n\\n        for(int i=1;i<stockPrices.size()-1;i++)\\n        {\\n            dx = stockPrices[i+1][0] - stockPrices[i][0];\\n            dy = stockPrices[i+1][1] - stockPrices[i][1];\\n            slope2 = (long double)dy/dx;\\n\\n            if(slope2!=slope1)\\n            {\\n                 c++;\\n                 slope1=slope2;\\n            }\\n        }\\n\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189481,
                "title": "sorting-geometry-math-easy-python-python3",
                "content": "## Please Upvote if you find this useful \\uD83D\\uDE0A\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n### Solution: 1\\n```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        days = len(stockPrices)\\n\\n        if days == 1:\\n            return 0\\n        \\n        stockPrices.sort()\\n\\n        x = stockPrices[0][0] - stockPrices[1][0]\\n        y = stockPrices[0][1] - stockPrices[1][1]\\n        sol = 1\\n\\n        for day in range(1, days - 1, 1):\\n            if x * (stockPrices[day][1] - stockPrices[day + 1][1]) != y * (stockPrices[day][0] - stockPrices[day + 1][0]):\\n                 sol = sol + 1\\n                 x = stockPrices[day][0] - stockPrices[day + 1][0]\\n                 y = stockPrices[day][1] - stockPrices[day + 1][1]\\n        \\n        return sol\\n```\\n\\n### Solution: 2 (Better for edge cases)\\n\\n```\\n\\nclass Solution:\\n    MOD = 10**9+7\\n    \\n    def get_mode_mult(self, a, b):\\n        return ((a % self.MOD) * (b % self.MOD)) % self.MOD \\n\\n    def need_new_line(self, x, y, pointA, pointB):\\n        X = pointA[0] - pointB[0]\\n        Y = pointA[1] - pointB[1]\\n\\n        if self.get_mode_mult(x, Y) == self.get_mode_mult(y, X):\\n            return False\\n        else:\\n            return True\\n\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        days = len(stockPrices)\\n\\n        if days == 1:\\n            return 0\\n        \\n        stockPrices.sort()\\n\\n        x = stockPrices[0][0] - stockPrices[1][0]\\n        y = stockPrices[0][1] - stockPrices[1][1]\\n        sol = 1\\n\\n        for day in range(1, days - 1, 1):\\n            if self.need_new_line(x, y, stockPrices[day], stockPrices[day + 1]):\\n                 sol = sol + 1\\n                 x = stockPrices[day][0] - stockPrices[day + 1][0]\\n                 y = stockPrices[day][1] - stockPrices[day + 1][1]\\n        \\n        return sol\\n```\\n\\n## Please Upvote if you find this useful \\uD83D\\uDE0A\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Geometry",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        days = len(stockPrices)\\n\\n        if days == 1:\\n            return 0\\n        \\n        stockPrices.sort()\\n\\n        x = stockPrices[0][0] - stockPrices[1][0]\\n        y = stockPrices[0][1] - stockPrices[1][1]\\n        sol = 1\\n\\n        for day in range(1, days - 1, 1):\\n            if x * (stockPrices[day][1] - stockPrices[day + 1][1]) != y * (stockPrices[day][0] - stockPrices[day + 1][0]):\\n                 sol = sol + 1\\n                 x = stockPrices[day][0] - stockPrices[day + 1][0]\\n                 y = stockPrices[day][1] - stockPrices[day + 1][1]\\n        \\n        return sol\\n```\n```\\n\\nclass Solution:\\n    MOD = 10**9+7\\n    \\n    def get_mode_mult(self, a, b):\\n        return ((a % self.MOD) * (b % self.MOD)) % self.MOD \\n\\n    def need_new_line(self, x, y, pointA, pointB):\\n        X = pointA[0] - pointB[0]\\n        Y = pointA[1] - pointB[1]\\n\\n        if self.get_mode_mult(x, Y) == self.get_mode_mult(y, X):\\n            return False\\n        else:\\n            return True\\n\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        days = len(stockPrices)\\n\\n        if days == 1:\\n            return 0\\n        \\n        stockPrices.sort()\\n\\n        x = stockPrices[0][0] - stockPrices[1][0]\\n        y = stockPrices[0][1] - stockPrices[1][1]\\n        sol = 1\\n\\n        for day in range(1, days - 1, 1):\\n            if self.need_new_line(x, y, stockPrices[day], stockPrices[day + 1]):\\n                 sol = sol + 1\\n                 x = stockPrices[day][0] - stockPrices[day + 1][0]\\n                 y = stockPrices[day][1] - stockPrices[day + 1][1]\\n        \\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170254,
                "title": "c-easy-fast-using-slope",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        // unordered_set<double> s;\\n        int n=stockPrices.size();\\n        if(n==1)\\n        return 0;\\n        \\n        vector<pair<int,int>> temp;\\n        long double curr;\\n        int ans=0;\\n        bool flag=false;\\n        \\n\\n        for(int i=0;i<n;i++)\\n            temp.push_back({stockPrices[i][0],stockPrices[i][1]});\\n        sort(temp.begin(),temp.end());\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            long double slope=(((long double)temp[i].second-temp[i-1].second)/((long double)temp[i].first-temp[i-1].first));\\n            if(flag==false)\\n            {\\n                flag=true;\\n                curr=slope;\\n                ans++;\\n            }\\n            else\\n            {\\n                if(curr!=slope)\\n                {\\n                    curr=slope;\\n                    ans++;\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        // unordered_set<double> s;\\n        int n=stockPrices.size();\\n        if(n==1)\\n        return 0;\\n        \\n        vector<pair<int,int>> temp;\\n        long double curr;\\n        int ans=0;\\n        bool flag=false;\\n        \\n\\n        for(int i=0;i<n;i++)\\n            temp.push_back({stockPrices[i][0],stockPrices[i][1]});\\n        sort(temp.begin(),temp.end());\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            long double slope=(((long double)temp[i].second-temp[i-1].second)/((long double)temp[i].first-temp[i-1].first));\\n            if(flag==false)\\n            {\\n                flag=true;\\n                curr=slope;\\n                ans++;\\n            }\\n            else\\n            {\\n                if(curr!=slope)\\n                {\\n                    curr=slope;\\n                    ans++;\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141123,
                "title": "java-cross-multiplication-easy-read-o-n",
                "content": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        Arrays.sort(stockPrices, (A, B) -> A[0] - B[0]);\\n        Integer currXdelta = null, currYdelta = null, prevXdelta = null, prevYdelta = null;\\n        int count = 0;\\n        for (int i = 1; i < stockPrices.length; i++) {\\n            currYdelta = stockPrices[i][1] - stockPrices[i - 1][1];\\n            currXdelta  = stockPrices[i][0] - stockPrices[i - 1][0];\\n            if (prevXdelta != null && prevYdelta != null) {\\n                if (currYdelta * prevXdelta != currXdelta * prevYdelta) count++;\\n            } else {\\n                count++;\\n            }\\n            prevXdelta = currXdelta;\\n            prevYdelta = currYdelta;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        Arrays.sort(stockPrices, (A, B) -> A[0] - B[0]);\\n        Integer currXdelta = null, currYdelta = null, prevXdelta = null, prevYdelta = null;\\n        int count = 0;\\n        for (int i = 1; i < stockPrices.length; i++) {\\n            currYdelta = stockPrices[i][1] - stockPrices[i - 1][1];\\n            currXdelta  = stockPrices[i][0] - stockPrices[i - 1][0];\\n            if (prevXdelta != null && prevYdelta != null) {\\n                if (currYdelta * prevXdelta != currXdelta * prevYdelta) count++;\\n            } else {\\n                count++;\\n            }\\n            prevXdelta = currXdelta;\\n            prevYdelta = currYdelta;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109415,
                "title": "just-store-previous-slope-and-then-check-if-matching-or-not",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        using ll=long long int;\\n        sort(stockPrices.begin(),stockPrices.end());\\n        pair<int,int>p;\\n        if(stockPrices.size()==1)\\n        return 0;\\n         ll dy=stockPrices[1][1]-stockPrices[0][1];\\n        ll dx=stockPrices[1][0]-stockPrices[0][0];\\n        p.first=dx;\\n        p.second=dy;\\n        int ans=1;\\n        for(int i=2;i<stockPrices.size();i++)\\n        {\\n            if( ((ll )(stockPrices[i][1]-stockPrices[i-1][1])*(p.first))!=(ll )(stockPrices[i][0]-stockPrices[i-1][0])*(p.second))\\n            {\\n            p.first=stockPrices[i][0]-stockPrices[i-1][0];\\n            p.second=stockPrices[i][1]-stockPrices[i-1][1];\\n            ans++;\\n        }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        using ll=long long int;\\n        sort(stockPrices.begin(),stockPrices.end());\\n        pair<int,int>p;\\n        if(stockPrices.size()==1)\\n        return 0;\\n         ll dy=stockPrices[1][1]-stockPrices[0][1];\\n        ll dx=stockPrices[1][0]-stockPrices[0][0];\\n        p.first=dx;\\n        p.second=dy;\\n        int ans=1;\\n        for(int i=2;i<stockPrices.size();i++)\\n        {\\n            if( ((ll )(stockPrices[i][1]-stockPrices[i-1][1])*(p.first))!=(ll )(stockPrices[i][0]-stockPrices[i-1][0])*(p.second))\\n            {\\n            p.first=stockPrices[i][0]-stockPrices[i-1][0];\\n            p.second=stockPrices[i][1]-stockPrices[i-1][1];\\n            ans++;\\n        }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085510,
                "title": "python-tc-o-nlogn-sc-o-1",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        if len(stockPrices) == 1: return 0\\n        if len(stockPrices) == 2: return 1\\n        stockPrices = sorted(stockPrices)\\n        turningPoints = 0\\n        for i in range(len(stockPrices)-2):\\n            if (stockPrices[i+1][1] - stockPrices[i][1]) * (stockPrices[i+2][0] - stockPrices[i+1][0]) != (stockPrices[i+2][1] - stockPrices[i+1][1]) * (stockPrices[i+1][0] - stockPrices[i][0]):\\n                turningPoints += 1\\n        return turningPoints + 1\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        if len(stockPrices) == 1: return 0\\n        if len(stockPrices) == 2: return 1\\n        stockPrices = sorted(stockPrices)\\n        turningPoints = 0\\n        for i in range(len(stockPrices)-2):\\n            if (stockPrices[i+1][1] - stockPrices[i][1]) * (stockPrices[i+2][0] - stockPrices[i+1][0]) != (stockPrices[i+2][1] - stockPrices[i+1][1]) * (stockPrices[i+1][0] - stockPrices[i][0]):\\n                turningPoints += 1\\n        return turningPoints + 1\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042811,
                "title": "c-o-nlogn-geometry-slope",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockprices) {\\n        \\n        if(stockprices.size()<=1){\\n            return 0;\\n        }\\n        sort(stockprices.begin(),stockprices.end());\\n        long long x1=stockprices[0][0];\\n        long long y1=stockprices[0][1];\\n        long long x2=stockprices[1][0];\\n        long long y2=stockprices[1][1];\\n        long double prevslope;\\n        if(x2==x1){\\n            prevslope=1e9;\\n        }\\n        else if(y2==y1){\\n            prevslope=0;\\n        }\\n        else{\\n            prevslope=(long double)(y2-y1)/(long double)(x2-x1);\\n        }\\n        long long count=1;\\n        for(int i=1;i<stockprices.size()-1;i++){\\n            \\n            long long x1=stockprices[i][0];\\n            long long y1=stockprices[i][1];\\n            long long x2=stockprices[i+1][0];\\n            long long y2=stockprices[i+1][1];\\n            long double slope;\\n             if(x2==x1){\\n                 slope=1e9;\\n             }\\n             else if(y2==y1){\\n                 slope=0;\\n             }\\n             else{\\n                 slope=(long double)(y2-y1)/(long double)(x2-x1);\\n             }\\n             if(slope!=prevslope){\\n                 count++;\\n                 prevslope=slope;\\n             }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockprices) {\\n        \\n        if(stockprices.size()<=1){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3026318,
                "title": "c-using-slope-o-n-log-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(),stockPrices.end());\\n        long long n=stockPrices.size();\\n        if(n==1){\\n            return 0;\\n        }\\n        if(n==2){\\n            return 1;\\n        }\\n        \\n        int count=1;\\n        long long x1=stockPrices[0][0];\\n        long long y1=stockPrices[0][1];\\n        long long x2=stockPrices[1][0];\\n        long long y2=stockPrices[1][1];\\n        long double slope1=((long double)(y2-y1))/(long double)(x2-x1);\\n        for(long long i=2;i<n;i++){\\n            long long p=stockPrices[i][0];\\n            long long q=stockPrices[i][1];\\n            long double slope=((long double)(q-y2))/((long double)(p-x2));\\n            if(slope!=slope1){\\n                count++;\\n                slope1=slope;\\n            }\\n            x2=p;\\n            y2=q;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(),stockPrices.end());\\n        long long n=stockPrices.size();\\n        if(n==1){\\n            return 0;\\n        }\\n        if(n==2){\\n            return 1;\\n        }\\n        \\n        int count=1;\\n        long long x1=stockPrices[0][0];\\n        long long y1=stockPrices[0][1];\\n        long long x2=stockPrices[1][0];\\n        long long y2=stockPrices[1][1];\\n        long double slope1=((long double)(y2-y1))/(long double)(x2-x1);\\n        for(long long i=2;i<n;i++){\\n            long long p=stockPrices[i][0];\\n            long long q=stockPrices[i][1];\\n            long double slope=((long double)(q-y2))/((long double)(p-x2));\\n            if(slope!=slope1){\\n                count++;\\n                slope1=slope;\\n            }\\n            x2=p;\\n            y2=q;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021793,
                "title": "scala-recursion",
                "content": "# Intuition\\nCompare neighbour slopes, avoid Float/Double overflow.\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$ due to sorting\\n- Space complexity: $$O(1)$$\\n# Code\\n```\\nobject Solution {\\n  def minimumLines(stockPrices: Array[Array[Int]]): Int = {\\n    def checkSlope(i: Int): Boolean =\\n      (stockPrices(i-1)(1) - stockPrices(i-2)(1)) * (stockPrices(i)(0) - stockPrices(i-1)(0)) == \\n      (stockPrices(i)(1) - stockPrices(i-1)(1)) * (stockPrices(i-1)(0) - stockPrices(i-2)(0))\\n    def impl(i: Int, acc: Int): Int =\\n      if(i>=stockPrices.size) acc \\n      else if(checkSlope(i)) impl(i+1, acc)\\n      else impl(i+1, acc+1)\\n\\n    scala.util.Sorting.quickSort(stockPrices)(Ordering[Int].on(x => x(0)))\\n    if(stockPrices.size<=2) (stockPrices.size-1)\\n    else impl(2, 1)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Geometry"
                ],
                "code": "```\\nobject Solution {\\n  def minimumLines(stockPrices: Array[Array[Int]]): Int = {\\n    def checkSlope(i: Int): Boolean =\\n      (stockPrices(i-1)(1) - stockPrices(i-2)(1)) * (stockPrices(i)(0) - stockPrices(i-1)(0)) == \\n      (stockPrices(i)(1) - stockPrices(i-1)(1)) * (stockPrices(i-1)(0) - stockPrices(i-2)(0))\\n    def impl(i: Int, acc: Int): Int =\\n      if(i>=stockPrices.size) acc \\n      else if(checkSlope(i)) impl(i+1, acc)\\n      else impl(i+1, acc+1)\\n\\n    scala.util.Sorting.quickSort(stockPrices)(Ordering[Int].on(x => x(0)))\\n    if(stockPrices.size<=2) (stockPrices.size-1)\\n    else impl(2, 1)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3021364,
                "title": "simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& nums) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1)return 0;\\n      \\n        long double prev=LONG_MAX;\\n        int count=0;\\n   \\n        for(int i=1;i<nums.size();i++){\\n            long double a=(long double)(nums[i][1]-nums[i-1][1])/(nums[i][0]-nums[i-1][0]);\\n            if(prev!=a and nums[i][0]!=nums[i-1][0]){\\n                count++;\\n                prev=a;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& nums) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1)return 0;\\n      \\n        long double prev=LONG_MAX;\\n        int count=0;\\n   \\n        for(int i=1;i<nums.size();i++){\\n            long double a=(long double)(nums[i][1]-nums[i-1][1])/(nums[i][0]-nums[i-1][0]);\\n            if(prev!=a and nums[i][0]!=nums[i-1][0]){\\n                count++;\\n                prev=a;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020901,
                "title": "easy-peasy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(),stockPrices.end());\\n        if (stockPrices.size()<=1)\\n            return 0;\\n        \\n        int num=stockPrices[1][1]-stockPrices[0][1];\\n        int denom=stockPrices[1][0]-stockPrices[0][0];\\n        int g=__gcd(num,denom); // gcd(k,0)=k;\\n        num/=g;\\n        denom/=g;\\n        int ans=1;\\n        int i=2;\\n        while(i<stockPrices.size())\\n        {\\n            int newn=stockPrices[i][1]-stockPrices[i-1][1];\\n            int newd=stockPrices[i][0]-stockPrices[i-1][0];\\n            int g=__gcd(newn,newd);\\n            newn=newn/g;\\n            newd=newd/g;\\n            if (newn==num && newd==denom)\\n            {\\n               // do nothing\\n            }\\n            else\\n            {\\n                ans++;\\n                num=newn;\\n                denom=newd;\\n            }\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(),stockPrices.end());\\n        if (stockPrices.size()<=1)\\n            return 0;\\n        \\n        int num=stockPrices[1][1]-stockPrices[0][1];\\n        int denom=stockPrices[1][0]-stockPrices[0][0];\\n        int g=__gcd(num,denom); // gcd(k,0)=k;\\n        num/=g;\\n        denom/=g;\\n        int ans=1;\\n        int i=2;\\n        while(i<stockPrices.size())\\n        {\\n            int newn=stockPrices[i][1]-stockPrices[i-1][1];\\n            int newd=stockPrices[i][0]-stockPrices[i-1][0];\\n            int g=__gcd(newn,newd);\\n            newn=newn/g;\\n            newd=newd/g;\\n            if (newn==num && newd==denom)\\n            {\\n               // do nothing\\n            }\\n            else\\n            {\\n                ans++;\\n                num=newn;\\n                denom=newd;\\n            }\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020418,
                "title": "c-math-n0-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        sort(sp.begin(),sp.end());\\n        long long n = sp.size(), ans = 0, sx = INT_MIN, sy = INT_MAX,tx,ty;\\n        for(int i = 1;i<n;i++){\\n            tx = sp[i-1][0] - sp[i][0] , ty = sp[i-1][1] - sp[i][1];\\n            ans+=(tx*sy != ty*sx), sx = tx , sy = ty;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        sort(sp.begin(),sp.end());\\n        long long n = sp.size(), ans = 0, sx = INT_MIN, sy = INT_MAX,tx,ty;\\n        for(int i = 1;i<n;i++){\\n            tx = sp[i-1][0] - sp[i][0] , ty = sp[i-1][1] - sp[i][1];\\n            ans+=(tx*sy != ty*sx), sx = tx , sy = ty;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020205,
                "title": "typescript-tricky-well-commented-solution-avoid-division",
                "content": "# Code\\n```\\nfunction minimumLines(stockPrices: number[][]): number {\\n    if (stockPrices.length <= 2) return stockPrices.length - 1;\\n\\n    // sort stocks by days\\n    stockPrices.sort((p1, p2) => {return p1[0] - p2[0]});\\n    \\n    // Main thing -> y = mx + c\\n    let min: number = 0;\\n    let dy_prev: bigint,\\n        dx_prev: bigint;\\n\\n    for (let i = 0; i < stockPrices.length - 1; i++) {\\n        const [[x0, y0], [x1, y1]] = [stockPrices[i], stockPrices[i + 1]];\\n\\n        const dy_cur = BigInt(y0 - y1), \\n              dx_cur = BigInt(x0 - x1);\\n\\n        // d_cur = (y0 - y1) / (x0 - x1) => dy_cur / dx_cur\\n        // d_cur should be equals d_prev => dy_cur / dx_cur == dy_prev / dx_prev \\n        // ==> dy_cur * dx_prev == dy_prev * dx_cur\\n        if ((! dy_prev && ! dx_prev) || (dy_prev * dx_cur != dy_cur * dx_prev)) {\\n            dy_prev = dy_cur;\\n            dx_prev = dx_cur;\\n            min += 1;\\n        }\\n    }\\n\\n    return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction minimumLines(stockPrices: number[][]): number {\\n    if (stockPrices.length <= 2) return stockPrices.length - 1;\\n\\n    // sort stocks by days\\n    stockPrices.sort((p1, p2) => {return p1[0] - p2[0]});\\n    \\n    // Main thing -> y = mx + c\\n    let min: number = 0;\\n    let dy_prev: bigint,\\n        dx_prev: bigint;\\n\\n    for (let i = 0; i < stockPrices.length - 1; i++) {\\n        const [[x0, y0], [x1, y1]] = [stockPrices[i], stockPrices[i + 1]];\\n\\n        const dy_cur = BigInt(y0 - y1), \\n              dx_cur = BigInt(x0 - x1);\\n\\n        // d_cur = (y0 - y1) / (x0 - x1) => dy_cur / dx_cur\\n        // d_cur should be equals d_prev => dy_cur / dx_cur == dy_prev / dx_prev \\n        // ==> dy_cur * dx_prev == dy_prev * dx_cur\\n        if ((! dy_prev && ! dx_prev) || (dy_prev * dx_cur != dy_cur * dx_prev)) {\\n            dy_prev = dy_cur;\\n            dx_prev = dx_cur;\\n            min += 1;\\n        }\\n    }\\n\\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3020071,
                "title": "c-solution-with-explanation-gcd-slope",
                "content": "// Do Upvote if you find this post Helpful !!!\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        if(sp.size() == 1){\\n            return 0;\\n        }\\n        sort(sp.begin(), sp.end());\\n        // Don\\'t Use division while using slope alert!! \\n        // int x1 = stockPrices[0][0];\\n        // int y1 = stockPrices[0][1];\\n        // int x2 = stockPrices[1][0];\\n        // int y2 = stockPrices[1][1];\\n        // int ans = 0;\\n        // long double m1 = (double)(y1 - y2)/(x1 - x2);\\n        // for(int i = 2; i < stockPrices.size(); i++){\\n        //     int x3 = stockPrices[i][0];\\n        //     int y3 = stockPrices[i][1];\\n        //     int x4 = stockPrices[i-1][0];\\n        //     int y4 = stockPrices[i-1][1];\\n        //     double m2 = (long double)(y4 - y3)/(x4 - x3);\\n        //     // System.out.println(m1+\" \"+m2);\\n        //     if(m1 == m2){\\n        //         continue;\\n        //     }else{\\n        //         ans++;\\n        //         m1 = m2;\\n        //     }\\n        // }\\n        \\n        // Rather than using division. we can find dx and dy. \\n        // then we can compare the current dx and dxnew similarly dy and dynew.\\n        // If any of them is mismatched, then we have a new line.\\n        int dx = INT_MIN, dy = INT_MIN;\\n        int cnt = 0;\\n        \\n        for(int i = 1;i < sp.size();i++){\\n            // Calculate dx1 and dy1. and now calculate the gcd and divide and compare it.\\n            int dx1 = sp[i][0] - sp[i - 1][0], dy1 = sp[i][1] - sp[i - 1][1];\\n            // calculating gcd for dx1 and dy1.\\n            int d = gcd(dx1, dy1);\\n            cnt += ((dx != dx1/d) || (dy != dy1/d));\\n            // store the dxnew and dynew for the next iteration.\\n            dx = dx1/d;\\n            dy = dy1/d;\\n        }\\n        \\n        return cnt; // count of minimum lines.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        if(sp.size() == 1){\\n            return 0;\\n        }\\n        sort(sp.begin(), sp.end());\\n        // Don\\'t Use division while using slope alert!! \\n        // int x1 = stockPrices[0][0];\\n        // int y1 = stockPrices[0][1];\\n        // int x2 = stockPrices[1][0];\\n        // int y2 = stockPrices[1][1];\\n        // int ans = 0;\\n        // long double m1 = (double)(y1 - y2)/(x1 - x2);\\n        // for(int i = 2; i < stockPrices.size(); i++){\\n        //     int x3 = stockPrices[i][0];\\n        //     int y3 = stockPrices[i][1];\\n        //     int x4 = stockPrices[i-1][0];\\n        //     int y4 = stockPrices[i-1][1];\\n        //     double m2 = (long double)(y4 - y3)/(x4 - x3);\\n        //     // System.out.println(m1+\" \"+m2);\\n        //     if(m1 == m2){\\n        //         continue;\\n        //     }else{\\n        //         ans++;\\n        //         m1 = m2;\\n        //     }\\n        // }\\n        \\n        // Rather than using division. we can find dx and dy. \\n        // then we can compare the current dx and dxnew similarly dy and dynew.\\n        // If any of them is mismatched, then we have a new line.\\n        int dx = INT_MIN, dy = INT_MIN;\\n        int cnt = 0;\\n        \\n        for(int i = 1;i < sp.size();i++){\\n            // Calculate dx1 and dy1. and now calculate the gcd and divide and compare it.\\n            int dx1 = sp[i][0] - sp[i - 1][0], dy1 = sp[i][1] - sp[i - 1][1];\\n            // calculating gcd for dx1 and dy1.\\n            int d = gcd(dx1, dy1);\\n            cnt += ((dx != dx1/d) || (dy != dy1/d));\\n            // store the dxnew and dynew for the next iteration.\\n            dx = dx1/d;\\n            dy = dy1/d;\\n        }\\n        \\n        return cnt; // count of minimum lines.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020032,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if(stockPrices.length == 1){\\n            return 0;\\n        }\\n        Arrays.sort(stockPrices, Comparator.comparingInt(o -> o[0]));\\n        int ans = 0;\\n        for(int i = 2; i < stockPrices.length; i++){\\n            int x2 = stockPrices[i-2][0];\\n            int y2 = stockPrices[i-2][1];\\n            int x3 = stockPrices[i-1][0];\\n            int y3 = stockPrices[i-1][1];\\n            int x4 = stockPrices[i][0];\\n            int y4 = stockPrices[i][1];\\n            long m1 = ((long)y3 - (long)y2)*((long)x4 - (long)x3);\\n            long m2 = ((long)y4 - (long)y3)*((long)x3 - (long)x2);\\n            if(m1 == m2){\\n                continue;\\n            }else{\\n                ans++;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if(stockPrices.length == 1){\\n            return 0;\\n        }\\n        Arrays.sort(stockPrices, Comparator.comparingInt(o -> o[0]));\\n        int ans = 0;\\n        for(int i = 2; i < stockPrices.length; i++){\\n            int x2 = stockPrices[i-2][0];\\n            int y2 = stockPrices[i-2][1];\\n            int x3 = stockPrices[i-1][0];\\n            int y3 = stockPrices[i-1][1];\\n            int x4 = stockPrices[i][0];\\n            int y4 = stockPrices[i][1];\\n            long m1 = ((long)y3 - (long)y2)*((long)x4 - (long)x3);\\n            long m2 = ((long)y4 - (long)y3)*((long)x3 - (long)x2);\\n            if(m1 == m2){\\n                continue;\\n            }else{\\n                ans++;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020014,
                "title": "simplified-solution-c-o-nlog-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n* If number of points = 1, then we don\\'t need any line\\n* If number of points = 2, then we **exactly** need one line\\n\\nFor remaining case we proceed as follows:\\n1. We first sort the array (wrto days)\\n2. Then, we initialize ans=1 as first two points will lie of a line\\n3. Then we iterate over stockPrices to check if ith point lies on line formed by (i-1)th and (i-2)th points\\n4. If it lies on the line, then we simply ignore as we don\\'t need any extra line\\n5. Else we increase our answer by 1 as one extra line is needed now\\n6. We continue iteration for (i+1)th point.\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Returns true if ith point lies on line formed by (i-1)th and (i-2)th points\\n    // Else returns false\\n    bool liesOnLineByPrevTwoPoints(int i, vector<vector<int>>& stockPrices){\\n        long long x2 = stockPrices[i-2][0],   y2 = stockPrices[i-2][1];\\n        long long x1 = stockPrices[i-1][0],   y1 = stockPrices[i-1][1];\\n        long long x = stockPrices[i][0],      y = stockPrices[i][1];\\n\\n        return (y2-y1)*(x1-x) == (y1-y)*(x2-x1);\\n    }\\n\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        if(stockPrices.size()<=2) return stockPrices.size()-1;\\n\\n        // Sort according to day number\\n        sort(stockPrices.begin(), stockPrices.end());\\n\\n        // Since first two points will lie of a line\\n        int ans = 1;\\n        for(int i=2; i<stockPrices.size(); i++)\\n            if(!liesOnLineByPrevTwoPoints(i, stockPrices))\\n                ans++;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Returns true if ith point lies on line formed by (i-1)th and (i-2)th points\\n    // Else returns false\\n    bool liesOnLineByPrevTwoPoints(int i, vector<vector<int>>& stockPrices){\\n        long long x2 = stockPrices[i-2][0],   y2 = stockPrices[i-2][1];\\n        long long x1 = stockPrices[i-1][0],   y1 = stockPrices[i-1][1];\\n        long long x = stockPrices[i][0],      y = stockPrices[i][1];\\n\\n        return (y2-y1)*(x1-x) == (y1-y)*(x2-x1);\\n    }\\n\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        if(stockPrices.size()<=2) return stockPrices.size()-1;\\n\\n        // Sort according to day number\\n        sort(stockPrices.begin(), stockPrices.end());\\n\\n        // Since first two points will lie of a line\\n        int ans = 1;\\n        for(int i=2; i<stockPrices.size(); i++)\\n            if(!liesOnLineByPrevTwoPoints(i, stockPrices))\\n                ans++;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019743,
                "title": "hashset-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\nArrays.sort(stockPrices, (int[] a, int[] b) -> a[0] == b[0] ? a[1] - b[1] : a[0]-b[0]);  \\n       if(stockPrices.length==1) return 0;\\n       HashSet<Double>set=new HashSet<>();\\n       int cnt=1;\\n       if(stockPrices.length==2) return cnt;\\n       double sl=(stockPrices[0][1]-stockPrices[1][1])*(1000000)/(double)(stockPrices[0][0]-stockPrices[1][0]);\\n       set.add(sl);\\n       for(int i=2;i<stockPrices.length;i++){\\ndouble slope=(stockPrices[i-1][1]-stockPrices[i][1])*(1000000)/(double)(stockPrices[i-1][0]-stockPrices[i][0]);\\n           if(set.contains(slope)) continue;\\n           else{\\n               set.clear();\\n               cnt++;\\n               set.add(slope);\\n           }\\n       }\\n       return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\nArrays.sort(stockPrices, (int[] a, int[] b) -> a[0] == b[0] ? a[1] - b[1] : a[0]-b[0]);  \\n       if(stockPrices.length==1) return 0;\\n       HashSet<Double>set=new HashSet<>();\\n       int cnt=1;\\n       if(stockPrices.length==2) return cnt;\\n       double sl=(stockPrices[0][1]-stockPrices[1][1])*(1000000)/(double)(stockPrices[0][0]-stockPrices[1][0]);\\n       set.add(sl);\\n       for(int i=2;i<stockPrices.length;i++){\\ndouble slope=(stockPrices[i-1][1]-stockPrices[i][1])*(1000000)/(double)(stockPrices[i-1][0]-stockPrices[i][0]);\\n           if(set.contains(slope)) continue;\\n           else{\\n               set.clear();\\n               cnt++;\\n               set.add(slope);\\n           }\\n       }\\n       return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019620,
                "title": "c-slopes-o-n-log-n",
                "content": "#### Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int n = stockPrices.size(), count = 1;\\n        if(n == 1)\\n            return 0;\\n        \\n        sort(stockPrices.begin(), stockPrices.end());\\n        long double prevSlope = findSlope(stockPrices[0], stockPrices[1]), slope;\\n\\n        for(int i=2; i<n; i++) {\\n            slope = findSlope(stockPrices[i-1], stockPrices[i]);\\n            count += (slope != prevSlope);\\n            prevSlope = slope;\\n        }\\n\\n        return count;\\n    }\\n\\n    // Function to find slope of 2 points\\n    long double findSlope(vector<int>& a, vector<int>& b) {\\n        return ((long double)(b[1] - a[1])) / ((long double)(b[0] - a[0]));\\n    }\\n};\\n```\\n\\n#### Complexity\\n- Time complexity: $$O(n * log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Geometry",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int n = stockPrices.size(), count = 1;\\n        if(n == 1)\\n            return 0;\\n        \\n        sort(stockPrices.begin(), stockPrices.end());\\n        long double prevSlope = findSlope(stockPrices[0], stockPrices[1]), slope;\\n\\n        for(int i=2; i<n; i++) {\\n            slope = findSlope(stockPrices[i-1], stockPrices[i]);\\n            count += (slope != prevSlope);\\n            prevSlope = slope;\\n        }\\n\\n        return count;\\n    }\\n\\n    // Function to find slope of 2 points\\n    long double findSlope(vector<int>& a, vector<int>& b) {\\n        return ((long double)(b[1] - a[1])) / ((long double)(b[0] - a[0]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019082,
                "title": "my-easiest-fastest-solution",
                "content": "I know you must have got stuck at the case when test case is [[1,1],[500000000,499999999],[1000000000,999999998]] don\\'t get scared its just that slope between the points is too close so different lines will exist so use long double instead of float or double.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int b = stockPrices.size();\\n        long double slope= INT_MIN;\\n        int count = 0;\\n     \\n        sort(stockPrices.begin(),stockPrices.end());\\n        for(int i=0;i<b-1;i++)\\n        {\\n            long double s = slope;\\n            int d = stockPrices[i+1][1]-stockPrices[i][1];\\n            int e = stockPrices[i+1][0]-stockPrices[i][0];\\n           \\n            slope = (long double)d/e;\\n   \\n        if(s!=slope)\\n        count++;\\n        }\\n        \\n        \\n        \\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int b = stockPrices.size();\\n        long double slope= INT_MIN;\\n        int count = 0;\\n     \\n        sort(stockPrices.begin(),stockPrices.end());\\n        for(int i=0;i<b-1;i++)\\n        {\\n            long double s = slope;\\n            int d = stockPrices[i+1][1]-stockPrices[i][1];\\n            int e = stockPrices[i+1][0]-stockPrices[i][0];\\n           \\n            slope = (long double)d/e;\\n   \\n        if(s!=slope)\\n        count++;\\n        }\\n        \\n        \\n        \\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019024,
                "title": "java-slope-calculation",
                "content": "# Intuition\\nTo check if 3 points are collinear, we need to calculate the slope between them.\\n\\n# Approach\\nIterate through the ```[][]stockPrices``` array and calculate slopes between set of every 3 points on the x-y plane.\\nIf the slopes differ, that means another line segment is required.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumLines(int[][] sp) {\\n        int n = sp.length;\\n        if(n == 1) return 0;\\n        Arrays.sort(sp, (a,b) -> a[0]-b[0]);\\n        int lines = 1;\\n        for(int i = 0; i+2 < n; ++i) {\\n            if(!equalSlopes(i, i+1, i+2, sp)) ++lines;\\n        }\\n        return lines;\\n    }\\n    \\n    private boolean equalSlopes(int p1, int p2, int p3, int[][] sp) {\\n        /*            \\n             y3-y2      y2-y1\\n            ------- == -------\\n             x3-x2      x2-x1\\n        */\\n        int d_x2x1 = sp[p2][0] - sp[p1][0];\\n        int d_x3x2 = sp[p3][0] - sp[p2][0];\\n        int d_y2y1 = sp[p2][1] - sp[p1][1];\\n        int d_y3y2 = sp[p3][1] - sp[p2][1];\\n        int slope1 = d_y3y2 * d_x2x1;\\n        int slope2 = d_y2y1 * d_x3x2;\\n        return slope1 == slope2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```[][]stockPrices```\n```\\nclass Solution {\\n    public int minimumLines(int[][] sp) {\\n        int n = sp.length;\\n        if(n == 1) return 0;\\n        Arrays.sort(sp, (a,b) -> a[0]-b[0]);\\n        int lines = 1;\\n        for(int i = 0; i+2 < n; ++i) {\\n            if(!equalSlopes(i, i+1, i+2, sp)) ++lines;\\n        }\\n        return lines;\\n    }\\n    \\n    private boolean equalSlopes(int p1, int p2, int p3, int[][] sp) {\\n        /*            \\n             y3-y2      y2-y1\\n            ------- == -------\\n             x3-x2      x2-x1\\n        */\\n        int d_x2x1 = sp[p2][0] - sp[p1][0];\\n        int d_x3x2 = sp[p3][0] - sp[p2][0];\\n        int d_y2y1 = sp[p2][1] - sp[p1][1];\\n        int d_y3y2 = sp[p3][1] - sp[p2][1];\\n        int slope1 = d_y3y2 * d_x2x1;\\n        int slope2 = d_y2y1 * d_x3x2;\\n        return slope1 == slope2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018877,
                "title": "c-most-detailed-solution-with-full-approach-tc-o-nlogn-sc-o-1",
                "content": "# Approach\\n-> If size of stockPrices is equal to 1, it means there is only one point and by one point no line can be made, so return 0.\\n-> If size of stockPrices is greater than 1, then sort the stockPrices in ascending order on the basis of day number.\\n-> Note-> Any Two points always form a straight line.\\n-> Slope of a straight line joining two points (x1,y1) and (x2,y2) is equal to (y2-y1)/(x2-x1).\\n   - Use \\'long double\\' datatype while calculating slope, instead of double or float because long double has highest precision. \\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n- O( NlogN + N )\\n- // Just ignoring lower degree terms i.e N\\n- So overall time complexity is O( NlogN )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## *If you found this solution helpful then please upvote it, and give your valuable feedback in the comments.*\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int rows=stockPrices.size();\\n        int columns=stockPrices[0].size();\\n\\n        // rows=1 means that there is only a single point, and by single point no line can be made\\n        if(rows==1) return 0;\\n       \\n        sort(stockPrices.begin(),stockPrices.end());\\n\\n        // If we have reached till this line then it is sure that there are more than 1 points in a stockPrices.\\n        // Two points always lie on the same straight line\\n        int lines=1;   \\n       \\n        // Slope of a straight line joining two points (x1,y1) & (x2,y2) = (y2-y1)/(x2-x1)\\n        long double slope= (long double)(stockPrices[1][1]-stockPrices[0][1])/(stockPrices[1][0]-stockPrices[0][0]);\\n           \\n        for(int i=2;i<rows;i++){\\n            long double newSlope= (long double)(stockPrices[i][1]-stockPrices[i-1][1])/(stockPrices[i][0]-stockPrices[i-1][0]);\\n            if(newSlope!=slope){\\n                lines++;\\n                slope=newSlope;\\n            }\\n        }\\n        return lines;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int rows=stockPrices.size();\\n        int columns=stockPrices[0].size();\\n\\n        // rows=1 means that there is only a single point, and by single point no line can be made\\n        if(rows==1) return 0;\\n       \\n        sort(stockPrices.begin(),stockPrices.end());\\n\\n        // If we have reached till this line then it is sure that there are more than 1 points in a stockPrices.\\n        // Two points always lie on the same straight line\\n        int lines=1;   \\n       \\n        // Slope of a straight line joining two points (x1,y1) & (x2,y2) = (y2-y1)/(x2-x1)\\n        long double slope= (long double)(stockPrices[1][1]-stockPrices[0][1])/(stockPrices[1][0]-stockPrices[0][0]);\\n           \\n        for(int i=2;i<rows;i++){\\n            long double newSlope= (long double)(stockPrices[i][1]-stockPrices[i-1][1])/(stockPrices[i][0]-stockPrices[i-1][0]);\\n            if(newSlope!=slope){\\n                lines++;\\n                slope=newSlope;\\n            }\\n        }\\n        return lines;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018775,
                "title": "simple-slope-compare-easy-c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If there is only 1 point present then no lines can be drawn therefore return 0.\\n1. If (n > 1) : Comparing the slopes of adjacent points after sorting.\\n2. If slope is different then new line is needed, hence ```ans++```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        sort(sp.begin(), sp.end());\\n        int n = sp.size(), ans = 1;\\n        if(n == 1) { return 0; }\\n        for(int i = 0; i < n - 2; i++){\\n            long dy = (long)sp[i][1] - (long)sp[i + 1][1];\\n            long dx = (long)sp[i][0] - (long)sp[i + 1][0];\\n\\n            long dy_ = (long)sp[i + 1][1] - (long)sp[i + 2][1];\\n            long dx_ = (long)sp[i + 1][0] - (long)sp[i + 2][0];\\n\\n            if(dy * dx_ != dy_ * dx) { ans++; }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Geometry",
                    "Sorting"
                ],
                "code": "```ans++```\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        sort(sp.begin(), sp.end());\\n        int n = sp.size(), ans = 1;\\n        if(n == 1) { return 0; }\\n        for(int i = 0; i < n - 2; i++){\\n            long dy = (long)sp[i][1] - (long)sp[i + 1][1];\\n            long dx = (long)sp[i][0] - (long)sp[i + 1][0];\\n\\n            long dy_ = (long)sp[i + 1][1] - (long)sp[i + 2][1];\\n            long dx_ = (long)sp[i + 1][0] - (long)sp[i + 2][0];\\n\\n            if(dy * dx_ != dy_ * dx) { ans++; }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018731,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& s) {\\n        int n = s.size();\\n        if( n==1)return 0;\\n        if( n==2)return 1;\\n        sort( s.begin(), s.end());\\n        int ans=1;\\n        for( int i =2; i< n ; i++)\\n        {\\n            long long  x1 = s[i][0], x2 = s[i-1 ][0], x3 = s[i-2][0];\\n            long long y1 = s[i][1], y2= s[i-1][1], y3= s[i-2][1];\\n            if( ( x1-x2)*(y2-y3)!=(y1-y2)*(x2-x3))ans++;\\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Geometry",
                    "Sorting",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& s) {\\n        int n = s.size();\\n        if( n==1)return 0;\\n        if( n==2)return 1;\\n        sort( s.begin(), s.end());\\n        int ans=1;\\n        for( int i =2; i< n ; i++)\\n        {\\n            long long  x1 = s[i][0], x2 = s[i-1 ][0], x3 = s[i-2][0];\\n            long long y1 = s[i][1], y2= s[i-1][1], y3= s[i-2][1];\\n            if( ( x1-x2)*(y2-y3)!=(y1-y2)*(x2-x3))ans++;\\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017579,
                "title": "easy-c-solution",
                "content": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& a) {\\n        if(a.size()==1)\\n            return 0;\\n        if(a.size()==2)\\n            return 1;\\n        sort(a.begin(),a.end());\\n        int c=0;\\n        int dx=INT_MIN,dy=INT_MIN;\\n        for(int i=1;i<a.size();i++)\\n        {\\n            int x=(a[i][0]-a[i-1][0]),y=a[i][1]-a[i-1][1],g=__gcd(x,y);\\n            if(dx != x / g || dy != y / g)\\n                c++;\\n            dx = x / g;\\n            dy = y / g;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& a) {\\n        if(a.size()==1)\\n            return 0;\\n        if(a.size()==2)\\n            return 1;\\n        sort(a.begin(),a.end());\\n        int c=0;\\n        int dx=INT_MIN,dy=INT_MIN;\\n        for(int i=1;i<a.size();i++)\\n        {\\n            int x=(a[i][0]-a[i-1][0]),y=a[i][1]-a[i-1][1],g=__gcd(x,y);\\n            if(dx != x / g || dy != y / g)\\n                c++;\\n            dx = x / g;\\n            dy = y / g;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3017509,
                "title": "python-two-solutions-fraction-module-and-cross-product-solutions",
                "content": "```\\nfrom fractions import Fraction\\nfrom itertools import pairwise\\nfrom math import inf\\nfrom operator import itemgetter\\n\\nPoint = tuple[int, int]\\n\\n\\nclass Solution:\\n    def minimumLines(self, prices: list[Point]) -> int:\\n        if len(prices) == 1:\\n            return 0\\n        else:\\n            prices.sort(key=itemgetter(0))\\n\\n            return self.using_slope(prices)\\n            # return self.using_cross_product(prices)\\n\\n    @staticmethod\\n    def using_slope(prices: list[Point]) -> int:\\n        output, slope = 1, Solution.dy_by_dx\\n\\n        ab = next(pairs := pairwise(prices))\\n\\n        for bc in pairs:\\n            if slope(ab) != slope(bc):\\n                output += 1\\n\\n            ab = bc\\n\\n        return output\\n\\n    @staticmethod\\n    def dy_by_dx(ab: tuple[Point, Point]) -> float | Fraction:\\n        (x1, y1), (x2, y2) = ab\\n\\n        dx, dy = x2 - x1, y2 - y1\\n\\n        if dx == 0:\\n            # 1. dx is 0, it means we have a vertical line going from (x1, y1). So whether dy is positive or\\n            #    negative, it does not matter\\n            # 2. infinity can not be represented by fraction module so returning it directly from math module\\n            return inf\\n        else:\\n            # To avoid floating point error, we use fraction module.\\n\\n            # (Simple divisions can give same results for example (apparently one of the test cases),\\n            # 499999998/499999999 and 499999999/500000000 gives same result, and that is where Fraction\\n            # class shines)\\n            return Fraction(dy, dx)\\n\\n    @staticmethod\\n    def using_cross_product(prices: list[Point]) -> int:\\n        output, on_line = 1, Solution.lie_on_same_line\\n\\n        a = next(itr := iter(prices))\\n\\n        for b, c in pairwise(itr):\\n            if not on_line(a, b, c):\\n                output += 1\\n\\n            a = b\\n\\n        return output\\n\\n    @staticmethod\\n    def lie_on_same_line(a: Point, b: Point, c: Point) -> bool:\\n        (x1, y1), (x2, y2), (x3, y3) = a, b, c\\n\\n        return (y2 - y1) * (x3 - x2) == (x2 - x1) * (y3 - y2)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nfrom fractions import Fraction\\nfrom itertools import pairwise\\nfrom math import inf\\nfrom operator import itemgetter\\n\\nPoint = tuple[int, int]\\n\\n\\nclass Solution:\\n    def minimumLines(self, prices: list[Point]) -> int:\\n        if len(prices) == 1:\\n            return 0\\n        else:\\n            prices.sort(key=itemgetter(0))\\n\\n            return self.using_slope(prices)\\n            # return self.using_cross_product(prices)\\n\\n    @staticmethod\\n    def using_slope(prices: list[Point]) -> int:\\n        output, slope = 1, Solution.dy_by_dx\\n\\n        ab = next(pairs := pairwise(prices))\\n\\n        for bc in pairs:\\n            if slope(ab) != slope(bc):\\n                output += 1\\n\\n            ab = bc\\n\\n        return output\\n\\n    @staticmethod\\n    def dy_by_dx(ab: tuple[Point, Point]) -> float | Fraction:\\n        (x1, y1), (x2, y2) = ab\\n\\n        dx, dy = x2 - x1, y2 - y1\\n\\n        if dx == 0:\\n            # 1. dx is 0, it means we have a vertical line going from (x1, y1). So whether dy is positive or\\n            #    negative, it does not matter\\n            # 2. infinity can not be represented by fraction module so returning it directly from math module\\n            return inf\\n        else:\\n            # To avoid floating point error, we use fraction module.\\n\\n            # (Simple divisions can give same results for example (apparently one of the test cases),\\n            # 499999998/499999999 and 499999999/500000000 gives same result, and that is where Fraction\\n            # class shines)\\n            return Fraction(dy, dx)\\n\\n    @staticmethod\\n    def using_cross_product(prices: list[Point]) -> int:\\n        output, on_line = 1, Solution.lie_on_same_line\\n\\n        a = next(itr := iter(prices))\\n\\n        for b, c in pairwise(itr):\\n            if not on_line(a, b, c):\\n                output += 1\\n\\n            a = b\\n\\n        return output\\n\\n    @staticmethod\\n    def lie_on_same_line(a: Point, b: Point, c: Point) -> bool:\\n        (x1, y1), (x2, y2), (x3, y3) = a, b, c\\n\\n        return (y2 - y1) * (x3 - x2) == (x2 - x1) * (y3 - y2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017431,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n      if (stockPrices.size() == 1)\\n        return 0;\\n      sort(stockPrices.begin(), stockPrices.end(), [](vector<int>& lhs, vector<int>& rhs) {\\n            return lhs[0] < rhs[0];\\n          });\\n      int ans = 1;\\n      vector<int> p1 = stockPrices[0], p2 = stockPrices[1];\\n      for (int i = 2; i < stockPrices.size(); i++) {\\n        vector<int>& c = stockPrices[i];\\n        if (int64_t(p2[1]-p1[1])*(c[0]-p2[0])  != int64_t(p2[0]-p1[0])*(c[1]-p2[1]))\\n          ans++;\\n        p1 = p2, p2 = c;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n      if (stockPrices.size() == 1)\\n        return 0;\\n      sort(stockPrices.begin(), stockPrices.end(), [](vector<int>& lhs, vector<int>& rhs) {\\n            return lhs[0] < rhs[0];\\n          });\\n      int ans = 1;\\n      vector<int> p1 = stockPrices[0], p2 = stockPrices[1];\\n      for (int i = 2; i < stockPrices.size(); i++) {\\n        vector<int>& c = stockPrices[i];\\n        if (int64_t(p2[1]-p1[1])*(c[0]-p2[0])  != int64_t(p2[0]-p1[0])*(c[1]-p2[1]))\\n          ans++;\\n        p1 = p2, p2 = c;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016835,
                "title": "easy-java-solution-beat-90-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing vector v = (x, y) to distinguish between lines. \\nA=(xa, ya); B=(xb, yb);\\nvector AB = (xb - xa, yb - ya);\\nIf the vector of the following lines does not have the same direction (x1/y1 = x2/y2 <=> x1*y2=y1*x2) as its previous, there is a new line.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, sorting the stockPrices using Arrays.sort so all points are placed in the x-axis respectively.\\n\\nThen, initialize the vector of the 1st and 2nd points and iterating though stockPrices. \\n\\nWhenever currentVector and vector (x, y) doesn\\'t not have the same direction, we know that there is a new line to add up and we change the currentVector to (x, y)\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if(stockPrices.length <= 2) return stockPrices.length - 1;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n        int count = 1;\\n        int[] currentVector = new int[2];\\n        currentVector[0] = stockPrices[1][0] - stockPrices[0][0];\\n        currentVector[1] = stockPrices[1][1] - stockPrices[0][1];\\n        for(int i = 1; i < stockPrices.length - 1; i++){\\n            int x = stockPrices[i + 1][0] - stockPrices[i][0];\\n            int y = stockPrices[i + 1][1] - stockPrices[i][1];\\n            if(currentVector[0] * y - currentVector[1] * x != 0){\\n                count++;\\n                currentVector[0] = x;\\n                currentVector[1] = y;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] stockPrices) {\\n        if(stockPrices.length <= 2) return stockPrices.length - 1;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n        int count = 1;\\n        int[] currentVector = new int[2];\\n        currentVector[0] = stockPrices[1][0] - stockPrices[0][0];\\n        currentVector[1] = stockPrices[1][1] - stockPrices[0][1];\\n        for(int i = 1; i < stockPrices.length - 1; i++){\\n            int x = stockPrices[i + 1][0] - stockPrices[i][0];\\n            int y = stockPrices[i + 1][1] - stockPrices[i][1];\\n            if(currentVector[0] * y - currentVector[1] * x != 0){\\n                count++;\\n                currentVector[0] = x;\\n                currentVector[1] = y;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004590,
                "title": "easy-c-consecutive-slopes",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the slope of consecutive points the array.\\nIf the slope is same, pass, else increase the number of lines by 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        sort(sp.begin(), sp.end());\\n        if(sp.size()==1) return 0;\\n        int ans = 1;\\n        int n = sp.size();\\n        for(int i=1;i<n-1;i++){\\n            long double x0 = sp[i-1][0];\\n            long double x1 = sp[i][0];\\n            long double x2 = sp[i+1][0];\\n            long double y0 = sp[i-1][1];\\n            long double y1 = sp[i][1];\\n            long double y2 = sp[i+1][1];\\n\\n            long double slope1 = (y1-y0)/(x1-x0);\\n            long double slope2 = (y2-y1)/(x2-x1);\\n\\n            if(slope1!=slope2) ans++;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        sort(sp.begin(), sp.end());\\n        if(sp.size()==1) return 0;\\n        int ans = 1;\\n        int n = sp.size();\\n        for(int i=1;i<n-1;i++){\\n            long double x0 = sp[i-1][0];\\n            long double x1 = sp[i][0];\\n            long double x2 = sp[i+1][0];\\n            long double y0 = sp[i-1][1];\\n            long double y1 = sp[i][1];\\n            long double y2 = sp[i+1][1];\\n\\n            long double slope1 = (y1-y0)/(x1-x0);\\n            long double slope2 = (y2-y1)/(x2-x1);\\n\\n            if(slope1!=slope2) ans++;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977073,
                "title": "python3-find-the-slope",
                "content": "# Code\\n```\\nfrom decimal import *\\n\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        res = 0\\n        stockPrices = sorted(stockPrices, key=lambda x: x[0])\\n\\n        def slope(x1, y1, x2, y2):\\n            return Decimal(y2 - y1) / Decimal(x2 - x1)\\n\\n        pre = None\\n        for i in range(1, len(stockPrices)):\\n            print(slope(stockPrices[i - 1][0], stockPrices[i - 1][1], stockPrices[i][0], stockPrices[i][1]))\\n            if pre != slope(stockPrices[i - 1][0], stockPrices[i - 1][1], stockPrices[i][0], stockPrices[i][1]):\\n                res += 1\\n            pre = slope(stockPrices[i - 1][0], stockPrices[i - 1][1], stockPrices[i][0], stockPrices[i][1])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom decimal import *\\n\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        res = 0\\n        stockPrices = sorted(stockPrices, key=lambda x: x[0])\\n\\n        def slope(x1, y1, x2, y2):\\n            return Decimal(y2 - y1) / Decimal(x2 - x1)\\n\\n        pre = None\\n        for i in range(1, len(stockPrices)):\\n            print(slope(stockPrices[i - 1][0], stockPrices[i - 1][1], stockPrices[i][0], stockPrices[i][1]))\\n            if pre != slope(stockPrices[i - 1][0], stockPrices[i - 1][1], stockPrices[i][0], stockPrices[i][1]):\\n                res += 1\\n            pre = slope(stockPrices[i - 1][0], stockPrices[i - 1][1], stockPrices[i][0], stockPrices[i][1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965573,
                "title": "easy-to-understand-c-solution-slope-comparison-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Simplest approach is to take 2 lines at a time and check if their slope is same.\\n- If the slope is same than it can be considered as a single line else we can increment the count of lines.\\n- Let\\'s solve this problem using this approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Inorder to compare slopes of 2 lines, take 3 coordinates\\n- Get slopes of the two lines and compare them  $$(y3-y2)*(x2-x1) = (x3-x2)(y2-y1)$$\\n- if the above equation is not equal than it\\'s not a line hence count of lines required can be incremeneted by 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        int res = 1;\\n        sort(sp.begin(), sp.end());\\n\\n        if(sp.size() < 2)\\n            return 0;\\n\\n        for(int i=2;i<sp.size();i++){\\n            long y3 = sp[i][1];\\n            long y2 = sp[i-1][1];\\n            long y1 = sp[i-2][1];\\n\\n            long x3 = sp[i][0];\\n            long x2 = sp[i-1][0];\\n            long x1 = sp[i-2][0];\\n\\n            if(  (y3-y2) * (x2-x1)  !=  (x3-x2) * (y2-y1)  )\\n                res++;\\n            else\\n                continue;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        int res = 1;\\n        sort(sp.begin(), sp.end());\\n\\n        if(sp.size() < 2)\\n            return 0;\\n\\n        for(int i=2;i<sp.size();i++){\\n            long y3 = sp[i][1];\\n            long y2 = sp[i-1][1];\\n            long y1 = sp[i-2][1];\\n\\n            long x3 = sp[i][0];\\n            long x2 = sp[i-1][0];\\n            long x1 = sp[i-2][0];\\n\\n            if(  (y3-y2) * (x2-x1)  !=  (x3-x2) * (y2-y1)  )\\n                res++;\\n            else\\n                continue;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961104,
                "title": "using-long-double",
                "content": "# \\n\\n# Approach\\nlong double can be used to precisely handle the slope values.\\nNow since you have vector and sorting it would take more time than having an array of pairs,just copy elements of vectors as pair. Sort them with first as preference and then find previous slope and slope comapare them and count if not same.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    bool static cla(pair<int,int>p1,pair<int,int>p2){\\n       return p1.first<p2.first;\\n    }\\n    int minimumLines(vector<vector<int>>& st) {\\n        int n=st.size();\\n        if(n<=1)return 0;\\n        pair<int,int> p[n];\\n        for(int i=0;i<n;i++){\\n            p[i].first=st[i][0];\\n            p[i].second=st[i][1];\\n        }\\n        sort(p,p+n,cla);\\n        long double prevslope=(long double)(p[0].second-p[1].second)/( long double)(p[0].first-p[1].first);\\n       int count=1;\\n        for(int i=1;i<n-1;i++){\\n           long double slope=(long double)(p[i].second-p[i+1].second)/(long double)(p[i].first-p[i+1].first);\\n            if(slope==prevslope)continue;\\n            else{\\n                count++;\\n                prevslope=slope;\\n            }\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    bool static cla(pair<int,int>p1,pair<int,int>p2){\\n       return p1.first<p2.first;\\n    }\\n    int minimumLines(vector<vector<int>>& st) {\\n        int n=st.size();\\n        if(n<=1)return 0;\\n        pair<int,int> p[n];\\n        for(int i=0;i<n;i++){\\n            p[i].first=st[i][0];\\n            p[i].second=st[i][1];\\n        }\\n        sort(p,p+n,cla);\\n        long double prevslope=(long double)(p[0].second-p[1].second)/( long double)(p[0].first-p[1].first);\\n       int count=1;\\n        for(int i=1;i<n-1;i++){\\n           long double slope=(long double)(p[i].second-p[i+1].second)/(long double)(p[i].first-p[i+1].first);\\n            if(slope==prevslope)continue;\\n            else{\\n                count++;\\n                prevslope=slope;\\n            }\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2960342,
                "title": "c-o-nlog-n",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        if(stockPrices.size()<2){\\n            return 0;\\n        }\\n        std::sort(stockPrices.begin(),stockPrices.end());\\n        int s = 1;\\n        long long dxPrev = stockPrices[1][0] - stockPrices[0][0];\\n        long long dyPrev = stockPrices[1][1] - stockPrices[0][1]; \\n\\n        for(int i = 1;i<stockPrices.size()-1;++i){\\n            long long dx = stockPrices[i+1][0] - stockPrices[i][0];\\n            long long dy = stockPrices[i+1][1] - stockPrices[i][1];\\n            if(dy*dxPrev==dx*dyPrev){ //continue;\\n                //cout<<dy*dxPrev<<endl;\\n            }\\n            else{\\n                dxPrev = dx;\\n                dyPrev = dy;\\n                ++s;\\n            }\\n        }\\n        //int y1Prev = stockPrices[0][1];\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        if(stockPrices.size()<2){\\n            return 0;\\n        }\\n        std::sort(stockPrices.begin(),stockPrices.end());\\n        int s = 1;\\n        long long dxPrev = stockPrices[1][0] - stockPrices[0][0];\\n        long long dyPrev = stockPrices[1][1] - stockPrices[0][1]; \\n\\n        for(int i = 1;i<stockPrices.size()-1;++i){\\n            long long dx = stockPrices[i+1][0] - stockPrices[i][0];\\n            long long dy = stockPrices[i+1][1] - stockPrices[i][1];\\n            if(dy*dxPrev==dx*dyPrev){ //continue;\\n                //cout<<dy*dxPrev<<endl;\\n            }\\n            else{\\n                dxPrev = dx;\\n                dyPrev = dy;\\n                ++s;\\n            }\\n        }\\n        //int y1Prev = stockPrices[0][1];\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2960125,
                "title": "c-simple-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(),stockPrices.end());\\n        int n=stockPrices.size();\\n        if(n==1)return 0;\\n             //previous slope;\\n           double slope=INT_MAX;\\n               int cnt=1; \\n        for(int i=2;i<n;i++){\\n            //point A\\n            long long x1=stockPrices[i-2][0];\\n            long long y1=stockPrices[i-2][1];\\n            //point B\\n            long long x2=stockPrices[i-1][0];\\n            long long y2=stockPrices[i-1][1];\\n             //point C\\n            long long x3=stockPrices[i][0];\\n            long long y3=stockPrices[i][1];\\n             if(((x3-x2)*(y2-y1))!=((x2-x1)*(y3-y2))){\\n                 cnt++;\\n             }\\n             else{\\n                continue;\\n             }\\n           \\n\\n             }\\n         return cnt;\\n\\n       \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(),stockPrices.end());\\n        int n=stockPrices.size();\\n        if(n==1)return 0;\\n             //previous slope;\\n           double slope=INT_MAX;\\n               int cnt=1; \\n        for(int i=2;i<n;i++){\\n            //point A\\n            long long x1=stockPrices[i-2][0];\\n            long long y1=stockPrices[i-2][1];\\n            //point B\\n            long long x2=stockPrices[i-1][0];\\n            long long y2=stockPrices[i-1][1];\\n             //point C\\n            long long x3=stockPrices[i][0];\\n            long long y3=stockPrices[i][1];\\n             if(((x3-x2)*(y2-y1))!=((x2-x1)*(y3-y2))){\\n                 cnt++;\\n             }\\n             else{\\n                continue;\\n             }\\n           \\n\\n             }\\n         return cnt;\\n\\n       \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959019,
                "title": "easy-solution-using-slope-o-nlogn-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time Complexity\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stk) {\\n        sort(stk.begin(),stk.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]==b[0]?a[1]<b[1]:a[0]<b[0];\\n        });\\n        int n=stk.size();\\n        if(n==1) return 0;\\n        if(n==2) return 1;\\n        long double x1=stk[0][0],y1=stk[0][1],x2=stk[1][0],y2=stk[1][1];\\n        long double xdif=x2-x1,ydif=y2-y1;\\n        long double slope=0.0;\\n        if(xdif==0) slope=INT_MAX;\\n        else slope=ydif/(xdif*1.0);\\n        int c=1;\\n        for(int i=2;i<n;i++)\\n        {\\n            x1=x2;y1=y2;\\n            x2=stk[i][0];y2=stk[i][1];\\n            xdif=x2-x1,ydif=y2-y1;\\n            long double newslope=0.0;\\n            if(xdif==0) newslope=INT_MAX;\\n            else newslope=ydif/xdif*1.0;\\n\\n            if(slope!=newslope)\\n            c++;\\n            slope=newslope;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stk) {\\n        sort(stk.begin(),stk.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]==b[0]?a[1]<b[1]:a[0]<b[0];\\n        });\\n        int n=stk.size();\\n        if(n==1) return 0;\\n        if(n==2) return 1;\\n        long double x1=stk[0][0],y1=stk[0][1],x2=stk[1][0],y2=stk[1][1];\\n        long double xdif=x2-x1,ydif=y2-y1;\\n        long double slope=0.0;\\n        if(xdif==0) slope=INT_MAX;\\n        else slope=ydif/(xdif*1.0);\\n        int c=1;\\n        for(int i=2;i<n;i++)\\n        {\\n            x1=x2;y1=y2;\\n            x2=stk[i][0];y2=stk[i][1];\\n            xdif=x2-x1,ydif=y2-y1;\\n            long double newslope=0.0;\\n            if(xdif==0) newslope=INT_MAX;\\n            else newslope=ydif/xdif*1.0;\\n\\n            if(slope!=newslope)\\n            c++;\\n            slope=newslope;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958163,
                "title": "easy-approach-c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& s) {\\n        if(s.size()==1){\\n            return 0;\\n        }\\n        sort(s.begin(),s.end());\\n        long long x0=0,x1=0;\\n        long long y0=0,y1=0;\\n        x0 = (s[1][0]-s[0][0]);\\n        y0 = (s[1][1]-s[0][1]);\\n        int ans = 1;\\n        for(int i = 2;i<s.size();i++){\\n            x1 = (s[i][0]-s[i-1][0]);\\n            y1 = (s[i][1]-s[i-1][1]);\\n            if((x0*y1) != (x1*y0)){\\n                ans++;\\n            }\\n            x0=x1,y0=y1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& s) {\\n        if(s.size()==1){\\n            return 0;\\n        }\\n        sort(s.begin(),s.end());\\n        long long x0=0,x1=0;\\n        long long y0=0,y1=0;\\n        x0 = (s[1][0]-s[0][0]);\\n        y0 = (s[1][1]-s[0][1]);\\n        int ans = 1;\\n        for(int i = 2;i<s.size();i++){\\n            x1 = (s[i][0]-s[i-1][0]);\\n            y1 = (s[i][1]-s[i-1][1]);\\n            if((x0*y1) != (x1*y0)){\\n                ans++;\\n            }\\n            x0=x1,y0=y1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958104,
                "title": "easy-approach-using-slope-of-a-line-with-explanation-faster-than-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given various points across a x-y plane that connect to form a line chart. As it is a line chart, it can be broken down into several line segments.\\nEvery line has a slope which is calculated using 2 points $$(x1,x2)$$ and $$(y1,y2)$$ anywhere on the line using the formula $$Slope=(y2-y1)/(x2-x1)$$.\\nWe just have to find the slope of all line segments and the **consecutive** line segments on the line chart which have the same slope lie on the same line. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all i started by sorting the array by calling the sort() function of STL, it makes the points sorted in a left to right order w.r.t to the x-y plane.\\nThen we have to store all the values of slope of every line segment formed by 2 consecutive points in the array.\\nIf the 2 consecutive slopes are different, it means a different line has started. Hence, we will increment the variable that stores our final answer.\\n**NOTE:** long double has to be used here to avoid rounding off the decimal part of the slopes.\\n# Complexity\\n- Time complexity: $$O(nlogn)$$(because of using the sort() function)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$(used a extra array to store slopes)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int n=stockPrices.size();\\n        if(n==1)\\n            return 0;\\n        sort(stockPrices.begin(),stockPrices.end());\\n        int ans=1;\\n        vector<long double> slope(n-1);\\n        slope[0]=(long double)(stockPrices[1][1]-stockPrices[0][1])/(stockPrices[1][0]-stockPrices[0][0]);\\n        for(int i=1;i<n-1;i++)\\n        {\\n            long double s=(long double)(stockPrices[i+1][1]-stockPrices[i][1])/(stockPrices[i+1][0]-stockPrices[i][0]);\\n            slope[i]=s;\\n            if(slope[i]!=slope[i-1])\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nHope, it helps :)",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int n=stockPrices.size();\\n        if(n==1)\\n            return 0;\\n        sort(stockPrices.begin(),stockPrices.end());\\n        int ans=1;\\n        vector<long double> slope(n-1);\\n        slope[0]=(long double)(stockPrices[1][1]-stockPrices[0][1])/(stockPrices[1][0]-stockPrices[0][0]);\\n        for(int i=1;i<n-1;i++)\\n        {\\n            long double s=(long double)(stockPrices[i+1][1]-stockPrices[i][1])/(stockPrices[i+1][0]-stockPrices[i][0]);\\n            slope[i]=s;\\n            if(slope[i]!=slope[i-1])\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958006,
                "title": "using-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool is_equal_slopes(vector<int>& p1,vector<int>& p2,vector<int>& p3)\\n    {\\n        int x1=p1[0];\\n        int y1=p1[1];\\n        int x2=p2[0];\\n        int y2=p2[1];\\n        int x3=p3[0];\\n        int y3=p3[1];\\n\\n         long double a=(((long double)y2-y1)/(x2-x1));\\n        long double b=(((long double)y3-y2)/(x3-x2));\\n\\n        return a==b;\\n    }\\n    int minimumLines(vector<vector<int>>& stockPrices)\\n    {\\n       sort(stockPrices.begin(),stockPrices.end());\\n\\n       int i=0;\\n       int n=stockPrices.size();\\n   \\n\\n       if(n==2)\\n       return 1;\\n       if(n<2)\\n       return 0;\\n\\n       int cnt=0;\\n       while(i<n)\\n       {\\n           while(i<n && i+1<n && i+2<n && is_equal_slopes(stockPrices[i],stockPrices[i+1],stockPrices[i+2]))\\n           {\\n               i++;\\n           } \\n           i++;\\n           cnt++;\\n\\n\\n       }      \\n       return cnt-1;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_equal_slopes(vector<int>& p1,vector<int>& p2,vector<int>& p3)\\n    {\\n        int x1=p1[0];\\n        int y1=p1[1];\\n        int x2=p2[0];\\n        int y2=p2[1];\\n        int x3=p3[0];\\n        int y3=p3[1];\\n\\n         long double a=(((long double)y2-y1)/(x2-x1));\\n        long double b=(((long double)y3-y2)/(x3-x2));\\n\\n        return a==b;\\n    }\\n    int minimumLines(vector<vector<int>>& stockPrices)\\n    {\\n       sort(stockPrices.begin(),stockPrices.end());\\n\\n       int i=0;\\n       int n=stockPrices.size();\\n   \\n\\n       if(n==2)\\n       return 1;\\n       if(n<2)\\n       return 0;\\n\\n       int cnt=0;\\n       while(i<n)\\n       {\\n           while(i<n && i+1<n && i+2<n && is_equal_slopes(stockPrices[i],stockPrices[i+1],stockPrices[i+2]))\\n           {\\n               i++;\\n           } \\n           i++;\\n           cnt++;\\n\\n\\n       }      \\n       return cnt-1;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957774,
                "title": "c-clean-simple-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int c=1;\\n        vector<vector<int>> v=stockPrices;\\n        sort(v.begin(),v.end());\\n        long double p;\\n        if(v.size()==1)\\n        return 0;\\n        if(v[1][1]-v[0][1]==0)\\n        p=INT_MAX;\\n        else\\n        p=(long double)(v[1][1]-v[0][1])/(v[1][0]-v[0][0]);\\n\\n        for(int i=1;i<v.size();i++)\\n        {\\n            long double m;\\n        if(v[i][1]-v[i-1][1]==0)\\n        m=INT_MAX;\\n        else\\n        m=(long double)(v[i][1]-v[i-1][1])/(v[i][0]-v[i-1][0]);\\n       \\n        if(m!=p)\\n         {\\n            c++;\\n            p=m;\\n         }\\n        }\\nreturn c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int c=1;\\n        vector<vector<int>> v=stockPrices;\\n        sort(v.begin(),v.end());\\n        long double p;\\n        if(v.size()==1)\\n        return 0;\\n        if(v[1][1]-v[0][1]==0)\\n        p=INT_MAX;\\n        else\\n        p=(long double)(v[1][1]-v[0][1])/(v[1][0]-v[0][0]);\\n\\n        for(int i=1;i<v.size();i++)\\n        {\\n            long double m;\\n        if(v[i][1]-v[i-1][1]==0)\\n        m=INT_MAX;\\n        else\\n        m=(long double)(v[i][1]-v[i-1][1])/(v[i][0]-v[i-1][0]);\\n       \\n        if(m!=p)\\n         {\\n            c++;\\n            p=m;\\n         }\\n        }\\nreturn c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957620,
                "title": "everything-explained-with-followup-question-and-my-notes",
                "content": "# My notes\\n![minimum number of lines.jpg](https://assets.leetcode.com/users/images/f6f18c1f-01bf-4915-abaa-d4fa17001793_1672134664.0734503.jpeg)\\n\\n\\n# Intuition\\nJust like, minimum intervals, standard problem this problem can be summed up\\nput 1 line for all lines with same slope. \\n\\n# Problems and ways to solve them\\n1. slope => you don\\'t want to missout on decimals but `Double Precison error` might cost you\\n    - i) instead comparing `DY1/DX1 == DY2/DX2`, compare as `DY1*DX2 == DY2*DX1`\\n    - ii)  use `long double` datatype\\n    - iii) use gcd of numbers for slope.\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: (1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        int n = sp.size();\\n        int lines =0 ;\\n        long double prev = LONG_MIN;\\n        sort(sp.begin(), sp.end());\\n        for(int i = 0;i<n-1;i++){\\n            long double dx = sp[i][0] - sp[i+1][0] ;\\n            long double dy = sp[i][1] - sp[i+1][1];                         \\n            long double curr = dy / dx;\\n            if(prev == curr ) continue;\\n            else{\\n                prev = curr;\\n                lines++;\\n            }\\n        }\\n        return lines;\\n    }\\n};\\n```\\n\\n# Follow up\\nhttps://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/discussion/comments/1730121 \\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& sp) {\\n        int n = sp.size();\\n        int lines =0 ;\\n        long double prev = LONG_MIN;\\n        sort(sp.begin(), sp.end());\\n        for(int i = 0;i<n-1;i++){\\n            long double dx = sp[i][0] - sp[i+1][0] ;\\n            long double dy = sp[i][1] - sp[i+1][1];                         \\n            long double curr = dy / dx;\\n            if(prev == curr ) continue;\\n            else{\\n                prev = curr;\\n                lines++;\\n            }\\n        }\\n        return lines;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957389,
                "title": "minimumlines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun minimumLines(stockPrices: Array<IntArray>): Int {\\n        var lineCount = 1\\n\\n        if (stockPrices.size == 1) {\\n            return 0\\n        }\\n\\n        val s = stockPrices.sortedBy { it[0] }\\n\\n        for (i in 2 until s.size) {\\n            val x1 = s[i][0]\\n            val x2 = s[i - 1][0]\\n            val x3 = s[i - 2][0]\\n            val y1 = s[i][1]\\n            val y2 = s[i - 1][1]\\n            val y3 = s[i - 2][1]\\n            val n1 = (y3 - y2) * (x2 - x1)\\n            val n2 = (y2 - y1) * (x3 - x2)\\n            if (n1 != n2) {\\n                lineCount += 1\\n            }\\n        }\\n\\n        return lineCount\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minimumLines(stockPrices: Array<IntArray>): Int {\\n        var lineCount = 1\\n\\n        if (stockPrices.size == 1) {\\n            return 0\\n        }\\n\\n        val s = stockPrices.sortedBy { it[0] }\\n\\n        for (i in 2 until s.size) {\\n            val x1 = s[i][0]\\n            val x2 = s[i - 1][0]\\n            val x3 = s[i - 2][0]\\n            val y1 = s[i][1]\\n            val y2 = s[i - 1][1]\\n            val y3 = s[i - 2][1]\\n            val n1 = (y3 - y2) * (x2 - x1)\\n            val n2 = (y2 - y1) * (x3 - x2)\\n            if (n1 != n2) {\\n                lineCount += 1\\n            }\\n        }\\n\\n        return lineCount\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956783,
                "title": "simple-c-solution-sorting-precision-by-long-double",
                "content": "# Complexity\\n- Time complexity:\\n    $$O(nlog(n))$$ for sorting and iterating.\\n\\n- Space complexity:\\n    $$O(1)$$\\n\\n# Code\\n```\\n#define double long double\\nclass Solution {\\n    double getSlope(vector<int>a,vector<int>b){\\n        return (double)((double)a[1]-(double)b[1])/((double)a[0]-(double)b[0]);\\n    }\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int n=stockPrices.size();\\n        if(n==1)return 0;\\n        if(n==2)return 1;\\n        sort(stockPrices.begin(),stockPrices.end());\\n        // Get the initial slope of 1st 2 points\\n        double init_slope=getSlope(stockPrices[0],stockPrices[1]);\\n        // Set the intital slope to prevSlope\\n        double prevSlope=init_slope;\\n        // Set the slope count as ans to 1\\n        int ans=1;\\n        // Iterate from 2 to n-1\\n        for(int i=2;i<n;i++){\\n            // Get the slope of current point and prev point\\n            double slope=getSlope(stockPrices[i],stockPrices[i-1]);\\n            // If this slope doesn\\'t match prevSlope\\n            // Then set the prevSlope to slope and increase count(ans) by 1\\n            if(slope!=prevSlope){\\n                prevSlope=slope;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\n#define double long double\\nclass Solution {\\n    double getSlope(vector<int>a,vector<int>b){\\n        return (double)((double)a[1]-(double)b[1])/((double)a[0]-(double)b[0]);\\n    }\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int n=stockPrices.size();\\n        if(n==1)return 0;\\n        if(n==2)return 1;\\n        sort(stockPrices.begin(),stockPrices.end());\\n        // Get the initial slope of 1st 2 points\\n        double init_slope=getSlope(stockPrices[0],stockPrices[1]);\\n        // Set the intital slope to prevSlope\\n        double prevSlope=init_slope;\\n        // Set the slope count as ans to 1\\n        int ans=1;\\n        // Iterate from 2 to n-1\\n        for(int i=2;i<n;i++){\\n            // Get the slope of current point and prev point\\n            double slope=getSlope(stockPrices[i],stockPrices[i-1]);\\n            // If this slope doesn\\'t match prevSlope\\n            // Then set the prevSlope to slope and increase count(ans) by 1\\n            if(slope!=prevSlope){\\n                prevSlope=slope;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956518,
                "title": "readable-c-solution-sorting-nlog-n",
                "content": "# Intuition\\njust check collinear points\\n# Approach\\n(y2 - y1)*(x1 - x0) == (x2 - x1)*(y1 - y0).This is the condition for three points to be collinear, Keep cheking this condition, if if fails, add 1, else continue.\\n# Complexity\\n- Time complexity:\\nNlog(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        \\n        sort(stockPrices.begin(), stockPrices.end());\\n        for(auto it : stockPrices) cout << it[0]<< \",\" << it[1] << \" \";\\n        int ans = 1;\\n        int n = stockPrices.size();\\n\\n        if(n == 1) return 0;\\n        else if(n == 2) return 1;\\n\\n        for(int i = 2; i < n; i++){\\n            auto p0 = stockPrices[i - 2];\\n            auto p1 = stockPrices[i - 1];\\n            auto p2 = stockPrices[i];\\n            long long x0 = p0[0];\\n            long long x1 = p1[0];\\n            long long x2 = p2[0];\\n            long long y0 = p0[1];\\n            long long y1 = p1[1];\\n            long long y2 = p2[1];\\n\\n            if((y2 - y1)*(x1 - x0) != (x2 - x1)*(y1 - y0)) ans += 1;\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        \\n        sort(stockPrices.begin(), stockPrices.end());\\n        for(auto it : stockPrices) cout << it[0]<< \",\" << it[1] << \" \";\\n        int ans = 1;\\n        int n = stockPrices.size();\\n\\n        if(n == 1) return 0;\\n        else if(n == 2) return 1;\\n\\n        for(int i = 2; i < n; i++){\\n            auto p0 = stockPrices[i - 2];\\n            auto p1 = stockPrices[i - 1];\\n            auto p2 = stockPrices[i];\\n            long long x0 = p0[0];\\n            long long x1 = p1[0];\\n            long long x2 = p2[0];\\n            long long y0 = p0[1];\\n            long long y1 = p1[1];\\n            long long y2 = p2[1];\\n\\n            if((y2 - y1)*(x1 - x0) != (x2 - x1)*(y1 - y0)) ans += 1;\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2956285,
                "title": "reasons-for-the-error-and-correction-code-java",
                "content": "# Intuition\\nSort the array based on days, means 0th column wise.\\nTake the slop and compare with previous slop, if these are equal means same slop no need of new line.\\nOtherwise need a new line.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code with error and reasons for the error\\n```class Solution {\\n    public int minimumLines(int[][] stkPrc) {\\n        int n=stkPrc.length;\\n        if(n==1)return 0;\\n        if(n==2)return 1;\\n        Arrays.sort(stkPrc,Comparator.comparing((int[]a)->a[0]));\\n        double c=stkPrc[1][1]-stkPrc[0][1];\\n        double d=stkPrc[1][0]-stkPrc[0][0];\\n        double m=c/d;\\n        System.out.println(m);\\n        double temp;\\n        int cnt=1;\\n        for(int i=2;i<n;i++){\\n            double a=stkPrc[i][1]-stkPrc[i-1][1];\\n            double b=stkPrc[i][0]-stkPrc[i-1][0];\\n            temp=(a)/(b);\\n            \\n            System.out.println(temp);\\n            if(temp!=m){\\n                cnt++;\\n                m=temp;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\\nIn the above code, division is done for double values.\\nBut it will give presion error.\\nfor example: \\n- [[1,1],[500000000,499999999],[1000000000,999999998]]\\n\\nwill give the same slope for both different lines, beacuse of precision error.\\n\\nstdout:\\n0.999999998\\n0.999999998\\n\\nSo, to avoid such division error we do multiplication following the line equation rule.\\n\\nAs we are going with the multiplication integer overflow can occur, so we store the values in long data type.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumLines(int[][] stkPrc) {\\n        int n=stkPrc.length;\\n        if(n==1)return 0;\\n        if(n==2)return 1;\\n        Arrays.sort(stkPrc,Comparator.comparing((int[]a)->a[0]));\\n        \\n        int cnt=1;\\n        for(int i=2;i<n;i++){\\n            long a=(stkPrc[i-1][1]-stkPrc[i-2][1])*(stkPrc[i][0]-stkPrc[i-1][0]);\\n            long b=(stkPrc[i][1]-stkPrc[i-1][1])*(stkPrc[i-1][0]-stkPrc[i-2][0]);\\n            if(a!=b){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\\nIf you find anything to add, feel free to add.\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public int minimumLines(int[][] stkPrc) {\\n        int n=stkPrc.length;\\n        if(n==1)return 0;\\n        if(n==2)return 1;\\n        Arrays.sort(stkPrc,Comparator.comparing((int[]a)->a[0]));\\n        double c=stkPrc[1][1]-stkPrc[0][1];\\n        double d=stkPrc[1][0]-stkPrc[0][0];\\n        double m=c/d;\\n        System.out.println(m);\\n        double temp;\\n        int cnt=1;\\n        for(int i=2;i<n;i++){\\n            double a=stkPrc[i][1]-stkPrc[i-1][1];\\n            double b=stkPrc[i][0]-stkPrc[i-1][0];\\n            temp=(a)/(b);\\n            \\n            System.out.println(temp);\\n            if(temp!=m){\\n                cnt++;\\n                m=temp;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumLines(int[][] stkPrc) {\\n        int n=stkPrc.length;\\n        if(n==1)return 0;\\n        if(n==2)return 1;\\n        Arrays.sort(stkPrc,Comparator.comparing((int[]a)->a[0]));\\n        \\n        int cnt=1;\\n        for(int i=2;i<n;i++){\\n            long a=(stkPrc[i-1][1]-stkPrc[i-2][1])*(stkPrc[i][0]-stkPrc[i-1][0]);\\n            long b=(stkPrc[i][1]-stkPrc[i-1][1])*(stkPrc[i-1][0]-stkPrc[i-2][0]);\\n            if(a!=b){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956233,
                "title": "sort-and-calculate-slope",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(), stockPrices.end());\\n        int n = stockPrices.size(), i, ans = 1, g, N, D, n1, d1;\\n        if (n == 1)\\n        return 0;\\n        i = 1;\\n        N = stockPrices[i][1] - stockPrices[i-1][1];\\n        D = stockPrices[i][0] - stockPrices[i-1][0];\\n        g = __gcd(N, D);\\n        N /= g;\\n        D /= g;\\n        while (i < n) {\\n            n1 = stockPrices[i][1] - stockPrices[i-1][1];\\n            d1 = stockPrices[i][0] - stockPrices[i-1][0];\\n            g = __gcd(n1, d1);\\n            n1 /= g;\\n            d1 /= g;\\n            if (n1 != N || d1 != D) {\\n                ans++;\\n                N = n1;\\n                D = d1;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        sort(stockPrices.begin(), stockPrices.end());\\n        int n = stockPrices.size(), i, ans = 1, g, N, D, n1, d1;\\n        if (n == 1)\\n        return 0;\\n        i = 1;\\n        N = stockPrices[i][1] - stockPrices[i-1][1];\\n        D = stockPrices[i][0] - stockPrices[i-1][0];\\n        g = __gcd(N, D);\\n        N /= g;\\n        D /= g;\\n        while (i < n) {\\n            n1 = stockPrices[i][1] - stockPrices[i-1][1];\\n            d1 = stockPrices[i][0] - stockPrices[i-1][0];\\n            g = __gcd(n1, d1);\\n            n1 /= g;\\n            d1 /= g;\\n            if (n1 != N || d1 != D) {\\n                ans++;\\n                N = n1;\\n                D = d1;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956097,
                "title": "accepted-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minimumLines(int[][] sp) {\\n        Arrays.sort(sp, (int[] a, int[] b) -> a[0] == b[0] ? a[1] - b[1] : a[0]-b[0]);\\n        Node prev = null;\\n        int count = 0;\\n        for(int i =1; i<sp.length; i++){\\n            int slopX = sp[i][0] - sp[i-1][0], slopY = sp[i][1] - sp[i-1][1], gcd = gcd(slopX, slopY);\\n            Node temp = new Node(slopX/gcd, slopY/gcd);\\n            if(!isSame(prev, temp))\\n            {\\n                count++;\\n                prev = temp;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int gcd(int a, int b)\\n    {\\n      if (b == 0)\\n        return a;\\n      return gcd(b, a % b);\\n    }\\n    \\n    boolean isSame(Node a, Node b){\\n        return a!= null && b!= null && a.x == b.x && a.y == b.y;\\n    }\\n    \\n    class Node{\\n        int x, y;\\n        Node(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumLines(int[][] sp) {\\n        Arrays.sort(sp, (int[] a, int[] b) -> a[0] == b[0] ? a[1] - b[1] : a[0]-b[0]);\\n        Node prev = null;\\n        int count = 0;\\n        for(int i =1; i<sp.length; i++){\\n            int slopX = sp[i][0] - sp[i-1][0], slopY = sp[i][1] - sp[i-1][1], gcd = gcd(slopX, slopY);\\n            Node temp = new Node(slopX/gcd, slopY/gcd);\\n            if(!isSame(prev, temp))\\n            {\\n                count++;\\n                prev = temp;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int gcd(int a, int b)\\n    {\\n      if (b == 0)\\n        return a;\\n      return gcd(b, a % b);\\n    }\\n    \\n    boolean isSame(Node a, Node b){\\n        return a!= null && b!= null && a.x == b.x && a.y == b.y;\\n    }\\n    \\n    class Node{\\n        int x, y;\\n        Node(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955851,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&v1 , vector<int>&v2){\\n        return v1[0] < v2[0];\\n    }\\n    int minimumLines(vector<vector<int>>& stocks) {\\n        sort(stocks.begin(), stocks.end() , cmp);\\n        int n = stocks.size();\\n        if(n==1) return 0;\\n        if(n==2)return 1;\\n\\n        long long u = (stocks[0][1]-stocks[1][1]);\\n        long long d = stocks[0][0] -stocks[1][0];\\n        long long u1,d1;\\n        long long ans =1;\\n        for(int i= 2;i<n;i++){\\n           u1 =  stocks[i-1][1]-stocks[i][1];\\n           d1 =  stocks[i-1][0] -stocks[i][0];\\n           if(u * d1 ==  u1 * d){\\n               continue;\\n           }else{\\n               ans++;\\n           }\\n           u=u1;\\n           d=d1;\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&v1 , vector<int>&v2){\\n        return v1[0] < v2[0];\\n    }\\n    int minimumLines(vector<vector<int>>& stocks) {\\n        sort(stocks.begin(), stocks.end() , cmp);\\n        int n = stocks.size();\\n        if(n==1) return 0;\\n        if(n==2)return 1;\\n\\n        long long u = (stocks[0][1]-stocks[1][1]);\\n        long long d = stocks[0][0] -stocks[1][0];\\n        long long u1,d1;\\n        long long ans =1;\\n        for(int i= 2;i<n;i++){\\n           u1 =  stocks[i-1][1]-stocks[i][1];\\n           d1 =  stocks[i-1][0] -stocks[i][0];\\n           if(u * d1 ==  u1 * d){\\n               continue;\\n           }else{\\n               ans++;\\n           }\\n           u=u1;\\n           d=d1;\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941788,
                "title": "greedy-beats-96-python",
                "content": "```\\nimport math\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        # Sort by x so we can just go through it greedily\\n        stockPrices = sorted(stockPrices, key=lambda xy: xy[0])\\n\\n        num_lines = 0\\n        curr_line = None\\n        for i in range(1, len(stockPrices)):\\n            x1, y1 = stockPrices[i]\\n            if curr_line is None:\\n                # If there is no line then we need to create (our first) line\\n                x0, y0 = stockPrices[i-1]\\n                dx = x1 - x0\\n                dy = y1 - y0\\n\\n                curr_line = (dx, dy, x0, y0)\\n                num_lines += 1\\n            else:\\n                dxl, dyl, xl, yl = curr_line\\n                dxl0 = x1 - xl\\n                dyl0 = y1 - yl\\n                # If we are not on the line we need to form a new line with the previous point\\n                if dxl0 * dyl != dyl0 * dxl:\\n                    x0, y0 = stockPrices[i-1]\\n                    dx = x1 - x0\\n                    dy = y1 - y0\\n\\n                    curr_line = (dx, dy, x0, y0)\\n                    num_lines += 1\\n\\n        return num_lines\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        # Sort by x so we can just go through it greedily\\n        stockPrices = sorted(stockPrices, key=lambda xy: xy[0])\\n\\n        num_lines = 0\\n        curr_line = None\\n        for i in range(1, len(stockPrices)):\\n            x1, y1 = stockPrices[i]\\n            if curr_line is None:\\n                # If there is no line then we need to create (our first) line\\n                x0, y0 = stockPrices[i-1]\\n                dx = x1 - x0\\n                dy = y1 - y0\\n\\n                curr_line = (dx, dy, x0, y0)\\n                num_lines += 1\\n            else:\\n                dxl, dyl, xl, yl = curr_line\\n                dxl0 = x1 - xl\\n                dyl0 = y1 - yl\\n                # If we are not on the line we need to form a new line with the previous point\\n                if dxl0 * dyl != dyl0 * dxl:\\n                    x0, y0 = stockPrices[i-1]\\n                    dx = x1 - x0\\n                    dy = y1 - y0\\n\\n                    curr_line = (dx, dy, x0, y0)\\n                    num_lines += 1\\n\\n        return num_lines\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935737,
                "title": "c-solution",
                "content": "USING SLOPE FORMULA\\n\\n#### Code\\n```\\npublic class Solution {\\n    public int MinimumLines(int[][] stockPrices) {\\n        if(stockPrices.Length==1){\\n            return 0;\\n        }\\n        if(stockPrices.Length==2){\\n            return 1;\\n        }\\n        else{\\n            //decimal used for max precision\\n            Array.Sort(stockPrices,(x,y)=>x[0].CompareTo(y[0]));            // sort acc to first element x[0] and y[0]\\n            decimal fslope=(decimal)(stockPrices[1][1]-stockPrices[0][1])/(stockPrices[1][0]-stockPrices[0][0]);\\n            //slope of first two points\\n\\n            decimal tslope=0;                    //temp slope ton compare\\n            int step=1;                         // 1 step as 1st slope exist\\n            for(int i=1;i<stockPrices.Length-1;i++){\\n                tslope=(decimal)(stockPrices[i+1][1]-stockPrices[i][1])/(stockPrices[i+1][0]-stockPrices[i][0]);\\n                if(tslope==fslope){\\n                    tslope=fslope;             //Console.Write(\"  NO change\");           \\n                }\\n                else{\\n                    fslope=tslope;             \\n                    step++;                  \\n                }\\n            }\\n            return step;  \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumLines(int[][] stockPrices) {\\n        if(stockPrices.Length==1){\\n            return 0;\\n        }\\n        if(stockPrices.Length==2){\\n            return 1;\\n        }\\n        else{\\n            //decimal used for max precision\\n            Array.Sort(stockPrices,(x,y)=>x[0].CompareTo(y[0]));            // sort acc to first element x[0] and y[0]\\n            decimal fslope=(decimal)(stockPrices[1][1]-stockPrices[0][1])/(stockPrices[1][0]-stockPrices[0][0]);\\n            //slope of first two points\\n\\n            decimal tslope=0;                    //temp slope ton compare\\n            int step=1;                         // 1 step as 1st slope exist\\n            for(int i=1;i<stockPrices.Length-1;i++){\\n                tslope=(decimal)(stockPrices[i+1][1]-stockPrices[i][1])/(stockPrices[i+1][0]-stockPrices[i][0]);\\n                if(tslope==fslope){\\n                    tslope=fslope;             //Console.Write(\"  NO change\");           \\n                }\\n                else{\\n                    fslope=tslope;             \\n                    step++;                  \\n                }\\n            }\\n            return step;  \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892642,
                "title": "p3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        if len(stockPrices) == 1 :\\n            return 0\\n            \\n        if len(stockPrices) == 2 :\\n            return 1\\n\\n        stockPrices.sort(key = lambda x : x[0])\\n        \\n        pair1 = stockPrices[0]\\n        pair2 = stockPrices[1]\\n\\n        a = pair2[0] - pair1[0]\\n        b = pair2[1] - pair1[1]\\n\\n        cnt = 0\\n        prev = pair2\\n\\n        for x,y in stockPrices[2:]:\\n            if ( x - pair1[0] ) * b  == ( y - pair1[1] ) * a  :\\n                prev = x,y\\n            else :\\n                cnt+=1\\n                pair1 = prev \\n                pair2 = x,y \\n                a = pair2[0] - pair1[0]\\n                b = pair2[1] - pair1[1]\\n                prev = pair2 \\n               \\n        return cnt + 1 \\n                \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        if len(stockPrices) == 1 :\\n            return 0\\n            \\n        if len(stockPrices) == 2 :\\n            return 1\\n\\n        stockPrices.sort(key = lambda x : x[0])\\n        \\n        pair1 = stockPrices[0]\\n        pair2 = stockPrices[1]\\n\\n        a = pair2[0] - pair1[0]\\n        b = pair2[1] - pair1[1]\\n\\n        cnt = 0\\n        prev = pair2\\n\\n        for x,y in stockPrices[2:]:\\n            if ( x - pair1[0] ) * b  == ( y - pair1[1] ) * a  :\\n                prev = x,y\\n            else :\\n                cnt+=1\\n                pair1 = prev \\n                pair2 = x,y \\n                a = pair2[0] - pair1[0]\\n                b = pair2[1] - pair1[1]\\n                prev = pair2 \\n               \\n        return cnt + 1 \\n                \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891993,
                "title": "slope-python3",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        n = len(stockPrices)\\n        if n < 3:\\n            return n - 1\\n        stockPrices = sorted(stockPrices, key=lambda x: x[0])\\n        cnt = 1\\n        for i in range(1, n - 1):\\n            x1, y1 = stockPrices[i - 1]\\n            x2, y2 = stockPrices[i]\\n            x3, y3 = stockPrices[i + 1]\\n            if (y2 - y1) * (x3 - x2) == (x2 - x1) * (y3 - y2):\\n                continue\\n            cnt += 1\\n        return cnt\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        n = len(stockPrices)\\n        if n < 3:\\n            return n - 1\\n        stockPrices = sorted(stockPrices, key=lambda x: x[0])\\n        cnt = 1\\n        for i in range(1, n - 1):\\n            x1, y1 = stockPrices[i - 1]\\n            x2, y2 = stockPrices[i]\\n            x3, y3 = stockPrices[i + 1]\\n            if (y2 - y1) * (x3 - x2) == (x2 - x1) * (y3 - y2):\\n                continue\\n            cnt += 1\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847715,
                "title": "was-this-problem-feasible-without-sorting",
                "content": "Could you solve this problem without sorting the stocks by day ?\\nIt doesn\\'t have to be more efficient but I\\'d be curious to see such a solution",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2810398,
                "title": "c-slope-solution-and-the-80th-test-case-is-annoying",
                "content": "The 80th test case : [[1,1],[500000000,499999999],[1000000000,999999998]]\\n\\nTheir slopes are \"the same\". But the level of precision required is very high (-_-)?\\n\\nBut that\\'s totally unnecessary (-_-) (because the slopes are the same down to at least 10 digits) \\n\\nAnyway, it depends on the requirements, but for this question... (-_-) I replaced double with long double.\\n\\n```cpp\\nbool com (vector<int>& l, vector<int>& r) {\\n    return l[0] < r[0];\\n}\\nclass Solution {\\npublic:\\n    long double s(vector<int>& a, vector<int>& b) {\\n        return (long double)(a[1] - b[1]) / (long double)(a[0] - b[0]);\\n    }\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int len = stockPrices.size();\\n        if (len == 1)\\n            return 0;\\n        if (len == 2)\\n            return 1;\\n        std::sort(stockPrices.begin(), stockPrices.end(), com);\\n        int i = 0;\\n        int st;\\n        int res = 0;\\n        while (i < len) {\\n            st = i;\\n            i++;\\n            if (i >= len) {\\n                return res;\\n            }\\n            long double sl = s(stockPrices[st], stockPrices[i]);\\n            i++;\\n            if (i >= len) {\\n                return (res + 1);\\n            }\\n            while (i < len && sl == s(stockPrices[i-1], stockPrices[i])) {\\n                i++;\\n            }\\n            i--;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool com (vector<int>& l, vector<int>& r) {\\n    return l[0] < r[0];\\n}\\nclass Solution {\\npublic:\\n    long double s(vector<int>& a, vector<int>& b) {\\n        return (long double)(a[1] - b[1]) / (long double)(a[0] - b[0]);\\n    }\\n    int minimumLines(vector<vector<int>>& stockPrices) {\\n        int len = stockPrices.size();\\n        if (len == 1)\\n            return 0;\\n        if (len == 2)\\n            return 1;\\n        std::sort(stockPrices.begin(), stockPrices.end(), com);\\n        int i = 0;\\n        int st;\\n        int res = 0;\\n        while (i < len) {\\n            st = i;\\n            i++;\\n            if (i >= len) {\\n                return res;\\n            }\\n            long double sl = s(stockPrices[st], stockPrices[i]);\\n            i++;\\n            if (i >= len) {\\n                return (res + 1);\\n            }\\n            while (i < len && sl == s(stockPrices[i-1], stockPrices[i])) {\\n                i++;\\n            }\\n            i--;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564908,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1564852,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1576789,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1730017,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1730008,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1576880,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 2025581,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1928803,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1871004,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1749601,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1564908,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1564852,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1576789,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1730017,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1730008,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1576880,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 2025581,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1928803,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1871004,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            },
            {
                "id": 1749601,
                "content": [
                    {
                        "username": "derozay",
                        "content": "Simple cross multiplication :|\\n\\nx0 / y0 = x1 / y1\\n.. *instead use*\\nx0 * y1 = x1 * y0\\n\\nTo be fair I didn\\'t imagine the issue was with the float point precision."
                    },
                    {
                        "username": "user2285TI",
                        "content": "life saver "
                    },
                    {
                        "username": "derozay",
                        "content": "Who else got f** d by the hidden test case ?"
                    },
                    {
                        "username": "Rising_legend_infinity",
                        "content": "[[1,1],[500000000,499999999],[1000000000,999999998]]"
                    },
                    {
                        "username": "gnohgnij",
                        "content": "I am getting an error for the test case of stockPrices =\\n[[93,6],[87,11],[26,58],[28,1],[69,87],[45,59],[29,3],[5,58],[60,94],[46,54],[38,58],[88,10],[94,7],[72,96],[2,93],[63,54],[74,22],[77,84],[33,64],[13,71],[78,59],[76,93],[3,31],[7,95],[68,32],[27,61],[96,31],[4,67],[75,36],[67,21],[8,66],[83,66],[71,58],[6,36],[34,7],[86,78]]\\n\\nCan anyone help?\\n```\\npublic int minimumLines(int[][] stockPrices) {\\n        int count = 0;\\n        double grad = 0;\\n        Arrays.sort(stockPrices, (a, b) -> a[0] - b[0]);\\n\\n        for(int i=0; i<stockPrices.length-1; i++) {\\n            int[] p1 = stockPrices[i], p2 = stockPrices[i+1];\\n            double newGrad = gradient(p1, p2);\\n            if(newGrad == grad) {\\n                continue;\\n            } else {\\n                count++;\\n                grad = newGrad;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public double gradient(int[] p1, int[] p2) {\\n        double xDiff = (double) Math.abs(p1[0] - p2[0]);\\n        double yDiff = (double) Math.abs(p1[1] - p2[1]);\\n        double res = yDiff/xDiff;\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "classic with floats comparison. never do that thing: newGrad == grad (because float is not precise value)"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "I am using a different approach Multiplying the difference of x and y. (such that I can deal with integers and longs only and avoid the floats, doubles). But I am also stuck on the 80th testcase.\n\n```\nclass Solution {\n    public int minimumLines(int[][] stockPrices) {\n        \n        if(stockPrices.length <=1) return 0;\n\n        int countLines = 1, n = stockPrices.length;\n\n        for(int i=n-3; i>=0; i--){\n            \n            long t1 = (stockPrices[i][0] - stockPrices[i+1][0]);\n            long t2 = (stockPrices[i][1] - stockPrices[i+1][1]);\n\n            long s1 = (stockPrices[i+1][0] - stockPrices[i+2][0]);\n            long s2 = (stockPrices[i+1][1] - stockPrices[i+2][1]);\n\n            if( ! (t2 * s1 == s2 * t1) )\n                countLines ++;\n        }\n\n        return countLines;\n\n    }\n}\n\n```\n\n\n\nUpdate: Just realized that I forgot to sort the given 2d array."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys use the area of triangle formula , or cross product formula !!\\nif area of triangle == 0 , cross product == 0  they are collinear "
                    },
                    {
                        "username": "haveaniceday",
                        "content": "is this a spec errorr?"
                    },
                    {
                        "username": "sav20011962",
                        "content": "\n[[1,1],[500000000,499999999],[1000000000,999999998]]\nCan't get expected response due to precision issues DOUBLE/ Both the first and second pair of points in DOUBLE give the same slope (X/Y)\ndelta_x=499999999,delta_y=499999998\ndelta_x=500000000,delta_y=499999999\nangle_prev=1.000000002,angle=1.000000002"
                    },
                    {
                        "username": "code__HARD",
                        "content": "floating point precession with recurring decimals"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many down vote for this one? It just requires a little middle school geometry."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Upon attempting this question i am getting wrong answer in 78 test case.\\nHere is my code \\n```\\npublic class Solution \\n{\\n    public int MinimumLines(int[][] stockPrices) \\n    {\\n        double prevM =360;\\n        int ans = 0;\\n\\n        for (int i = 1; i < stockPrices.Length; i++)\\n        {\\n            var p = stockPrices[i][1] - stockPrices[i - 1][1];\\n            var q = (double)(stockPrices[i][0] - stockPrices[i - 1][0]);\\n            if(prevM!=(p/q))\\n            {\\n                prevM = p/q;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nAnd i looked other solution but they  are sorting.\\nMy Question is why they are sorting"
                    }
                ]
            }
        ]
    }
]