[
    {
        "title": "Longest Subarray With Maximum Bitwise AND",
        "question_content": "You are given an integer array nums of size n.\nConsider a non-empty subarray from nums that has the maximum possible bitwise AND.\n\n\tIn other words, let k be the maximum value of the bitwise AND of any subarray of nums. Then, only subarrays with a bitwise AND equal to k should be considered.\n\nReturn the length of the longest such subarray.\nThe bitwise AND of an array is the bitwise AND of all the numbers in it.\nA subarray is a contiguous sequence of elements within an array.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3,3,2,2]\nOutput: 2\nExplanation:\nThe maximum possible bitwise AND of a subarray is 3.\nThe longest subarray with that value is [3,3], so we return 2.\n\nExample 2:\n\nInput: nums = [1,2,3,4]\nOutput: 1\nExplanation:\nThe maximum possible bitwise AND of a subarray is 4.\nThe longest subarray with that value is [4], so we return 1.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 106",
        "solutions": [
            {
                "id": 2620481,
                "title": "count-longest-subarray-with-max-element-meme",
                "content": "* The **Bitwise AND** of two different numbers will **always** be **strictly less** than the **maximum** of those **two numbers**\\n* so the longest subarray with max bitwise AND would be the **subarray containing only the max numbers**\\n\\n**Example :**\\n1.   count length of the subarray where **only** maximum number is **included**\\n\\n1.  Example Testcase : [1,3,4,5,5,5,6,7, **8,8,8,8** ]\\n \\n1.  Ans : **`4 `**\\n\\n\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int result = 0, length = 0, max = 0;\\n        for (int ele : nums) {\\n            max = Math.max(max, ele);\\n        }\\n\\n        for (int ele : nums) {\\n            if (ele == max) {\\n                result = Math.max(result, ++length);\\n            } else length = 0;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nC++:\\n```\\nclass Solution\\n{\\n    public:\\n        int longestSubarray(vector<int> &nums)\\n        {\\n            int x = *max_element(nums.begin(), nums.end());\\n            int ans = 0, len = 0;\\n            for (int ele: nums)\\n            {\\n                if (ele == x)\\n                {\\n                    ans = max(ans, ++len);\\n                }\\n                else len = 0;\\n            }\\n            return ans;\\n        }\\n};\\n```\\n\\nPython3:\\n\\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        max_n = max(nums)\\n        return max(len(list(it)) for n, it in groupby(nums) if n == max_n)\\n```\\n\\n**Meme :**\\n\\n![image](https://assets.leetcode.com/users/images/16466c87-b316-42f3-bc54-6c6b93e8ee60_1664079631.8968446.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int result = 0, length = 0, max = 0;\\n        for (int ele : nums) {\\n            max = Math.max(max, ele);\\n        }\\n\\n        for (int ele : nums) {\\n            if (ele == max) {\\n                result = Math.max(result, ++length);\\n            } else length = 0;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public:\\n        int longestSubarray(vector<int> &nums)\\n        {\\n            int x = *max_element(nums.begin(), nums.end());\\n            int ans = 0, len = 0;\\n            for (int ele: nums)\\n            {\\n                if (ele == x)\\n                {\\n                    ans = max(ans, ++len);\\n                }\\n                else len = 0;\\n            }\\n            return ans;\\n        }\\n};\\n```\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        max_n = max(nums)\\n        return max(len(list(it)) for n, it in groupby(nums) if n == max_n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620582,
                "title": "python3-longest-subarray-with-all-values-max-o-n",
                "content": "The problem is actually asking for the longest subarray with all values = max(nums)\\nThe maximum possible bitwise AND is the maximum number in nums, in order to have a subarray with the maximum possible bitwise AND the subarray can only contain the maximum number otherwise the bitwise AND will decrease.\\n\\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        MAX = max(nums) ### Find the largest number in nums.\\n        res = 0\\t\\t\\t \\n        count = 0\\t\\t### Used to count the length of the continues subarray that only contains MAX\\n        for n in nums:\\n        \\t### If the current number is MAX, increase count\\n            if n==MAX:\\n                count +=1\\n            ### Otherwise, reset count.\\n            else:\\n                count = 0\\n            ### store the maximum count as result.\\n            res = max(res, count)\\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        MAX = max(nums) ### Find the largest number in nums.\\n        res = 0\\t\\t\\t \\n        count = 0\\t\\t### Used to count the length of the continues subarray that only contains MAX\\n        for n in nums:\\n        \\t### If the current number is MAX, increase count\\n            if n==MAX:\\n                count +=1\\n            ### Otherwise, reset count.\\n            else:\\n                count = 0\\n            ### store the maximum count as result.\\n            res = max(res, count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620515,
                "title": "java-python-3-longest-consecutive-max-subarray",
                "content": "Max bitwise `AND` subarray must include maximum element(s) **ONLY**. Therefore, we only need to find the longest subarray including max only.\\n\\n**Method1: Two Pass:**\\n\\n```java\\n    public int longestSubarray(int[] nums) {\\n        int max = 0, longest = 1, cur = 0;\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n        }\\n        for (int num : nums) {\\n            if (num == max) {\\n                longest = Math.max(longest, ++cur);\\n            }else {\\n                cur = 0;\\n            }\\n        }\\n        return longest;\\n    }\\n```\\n```python\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        mx = max(nums)\\n        longest = cur = 0\\n        for num in nums:\\n            if num == mx:\\n                cur += 1\\n                longest = max(longest, cur)\\n            else:\\n                cur = 0\\n        return longest\\n```\\n\\n----\\n\\n\\n**Method 2: 1 Pass** - inspired by **@conchwu**\\n\\n```java\\n    public int longestSubarray(int[] nums) {\\n        int max = 0, longest = 0, cur = 0;\\n        for (int num : nums) {\\n            if (num == max) {\\n                longest = Math.max(longest, ++cur);\\n            }else if (num > max) {\\n                max = num;\\n                cur = longest = 1;\\n            }else {\\n                cur = 0;\\n            }\\n        }\\n        return longest;\\n    }\\n```\\nor \\n```java\\n    public int longestSubarray(int[] nums) {\\n        int max = 0, longest = 0, cur = 0;\\n        for (int num : nums) {\\n            if  (num > max) {\\n                max = num;\\n                longest = cur = 0;\\n            }\\n            cur = num == max ? ++cur : 0;\\n            longest = Math.max(longest, cur);\\n        }\\n        return longest;\\n    }\\n```\\n\\n----\\n\\n```python\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        longest = cur = mx = 0\\n        for num in nums:\\n            if num > mx:\\n                mx = num\\n                longest = cur = 1\\n            elif num == mx:\\n                cur += 1\\n                longest = max(longest, cur)\\n            else:\\n                cur = 0    \\n        return longest\\n```\\nor\\n\\n```python\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        longest = cur = mx = 0\\n        for num in nums:\\n            if num > mx:\\n                mx = num\\n                longest = cur = 0\\n            cur = cur + 1 if num == mx else 0\\n            longest = max(longest, cur)\\n        return longest\\n```\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```java\\n    public int longestSubarray(int[] nums) {\\n        int max = 0, longest = 1, cur = 0;\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n        }\\n        for (int num : nums) {\\n            if (num == max) {\\n                longest = Math.max(longest, ++cur);\\n            }else {\\n                cur = 0;\\n            }\\n        }\\n        return longest;\\n    }\\n```\n```python\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        mx = max(nums)\\n        longest = cur = 0\\n        for num in nums:\\n            if num == mx:\\n                cur += 1\\n                longest = max(longest, cur)\\n            else:\\n                cur = 0\\n        return longest\\n```\n```java\\n    public int longestSubarray(int[] nums) {\\n        int max = 0, longest = 0, cur = 0;\\n        for (int num : nums) {\\n            if (num == max) {\\n                longest = Math.max(longest, ++cur);\\n            }else if (num > max) {\\n                max = num;\\n                cur = longest = 1;\\n            }else {\\n                cur = 0;\\n            }\\n        }\\n        return longest;\\n    }\\n```\n```java\\n    public int longestSubarray(int[] nums) {\\n        int max = 0, longest = 0, cur = 0;\\n        for (int num : nums) {\\n            if  (num > max) {\\n                max = num;\\n                longest = cur = 0;\\n            }\\n            cur = num == max ? ++cur : 0;\\n            longest = Math.max(longest, cur);\\n        }\\n        return longest;\\n    }\\n```\n```python\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        longest = cur = mx = 0\\n        for num in nums:\\n            if num > mx:\\n                mx = num\\n                longest = cur = 1\\n            elif num == mx:\\n                cur += 1\\n                longest = max(longest, cur)\\n            else:\\n                cur = 0    \\n        return longest\\n```\n```python\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        longest = cur = mx = 0\\n        for num in nums:\\n            if num > mx:\\n                mx = num\\n                longest = cur = 0\\n            cur = cur + 1 if num == mx else 0\\n            longest = max(longest, cur)\\n        return longest\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2620524,
                "title": "c-subarray-with-all-maximum-elements",
                "content": "**Approach**\\n- Find maximum element in vector.\\n- Find the length of longest subarray (contiguous) which contains only maximum element.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int N = nums.size();\\n        int maxEle = *max_element(nums.begin(), nums.end());\\n        int subarrayLen = 0, ans = 1;\\n        \\n        for(int i = 0; i < N; i++) {\\n            if (nums[i] == maxEle) {\\n                subarrayLen++;\\n                ans = max(ans, subarrayLen);\\n            } else {\\n                subarrayLen = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int N = nums.size();\\n        int maxEle = *max_element(nums.begin(), nums.end());\\n        int subarrayLen = 0, ans = 1;\\n        \\n        for(int i = 0; i < N; i++) {\\n            if (nums[i] == maxEle) {\\n                subarrayLen++;\\n                ans = max(ans, subarrayLen);\\n            } else {\\n                subarrayLen = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648255,
                "title": "group-by-and-one-pass",
                "content": "The maximum possible bitwise AND should not be less than a largest element.\\n\\nTherefore, the subarray must only include one or more largest elements.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        max_n = max(nums)\\n        return max(len(list(it)) for n, it in groupby(nums) if n == max_n)\\n```\\n\\n**C++**\\nOne-pass solution.\\n```cpp\\nint longestSubarray(vector<int>& nums) {\\n    int max_n = 0, cnt = 0, res = 0;\\n    for (int n : nums) {\\n        if (max_n < n) {\\n            max_n = n;\\n            res = cnt = 0;\\n        }\\n        cnt = n == max_n ? cnt + 1 : 0;\\n        res = max(res, cnt);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        max_n = max(nums)\\n        return max(len(list(it)) for n, it in groupby(nums) if n == max_n)\\n```\n```cpp\\nint longestSubarray(vector<int>& nums) {\\n    int max_n = 0, cnt = 0, res = 0;\\n    for (int n : nums) {\\n        if (max_n < n) {\\n            max_n = n;\\n            res = cnt = 0;\\n        }\\n        cnt = n == max_n ? cnt + 1 : 0;\\n        res = max(res, cnt);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620462,
                "title": "c-count-max-value-easy-and-efficient-approach",
                "content": "***Please upvote if it helps :)***\\n\\n**Approach** : In this problem, we just need to find the maximum value and count its maximum contiguous occurences that will be the answer\\n\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int longestSubarray(vector<int>& nums) \\n    {\\n        int maxi_val=0;\\n        \\n        for(auto it:nums)\\n            maxi_val = max(maxi_val, it);\\n        \\n        int cnt=1, maxi=1;\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            if(nums[i]==maxi_val && nums[i]==nums[i+1])\\n                cnt++;          \\n            else \\n                cnt=1;\\n            \\n            maxi = max(maxi, cnt);\\n                \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int longestSubarray(vector<int>& nums) \\n    {\\n        int maxi_val=0;\\n        \\n        for(auto it:nums)\\n            maxi_val = max(maxi_val, it);\\n        \\n        int cnt=1, maxi=1;\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            if(nums[i]==maxi_val && nums[i]==nums[i+1])\\n                cnt++;          \\n            else \\n                cnt=1;\\n            \\n            maxi = max(maxi, cnt);\\n                \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623659,
                "title": "c-single-pass-fast-100-114ms",
                "content": "### Approach 1: single pass, update max as we go\\n\\nThe first idea would be to find the largest number and then look for the longest streak of that number. We can actually do this in a single pass.\\n\\n```cpp\\n    static int longestSubarray(const vector<int>& nums) {\\n        int k = 1;  // instead of k = *max_element(begin(nums), end(nums));\\n        int ans = 0;\\n        int curr = 0;\\n        for (int n : nums) {\\n            if (n == k) {\\n                ++curr;\\n                ans = max(ans, curr);\\n            } else if (n > k) {\\n                // We found a bigger number. Start all over.\\n                k = n;\\n                curr = 1;\\n                ans = 1;\\n            } else {\\n                curr = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n)$$\\n  * Space complexity: $$O(1)$$\\n\\n_As always feedback, comments and questions are welcome._\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static int longestSubarray(const vector<int>& nums) {\\n        int k = 1;  // instead of k = *max_element(begin(nums), end(nums));\\n        int ans = 0;\\n        int curr = 0;\\n        for (int n : nums) {\\n            if (n == k) {\\n                ++curr;\\n                ans = max(ans, curr);\\n            } else if (n > k) {\\n                // We found a bigger number. Start all over.\\n                k = n;\\n                curr = 1;\\n                ans = 1;\\n            } else {\\n                curr = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620965,
                "title": "python-easy-logic-linear-o-n-solution-explained",
                "content": "AND operation can\\'t  go beyond max value in the array. So basically we check for number of continuous max values in the array. \\n\\nWhy continuous? Because once a bit becomes 0 it stays zero forever. So we need only continuous max values.\\n\\n**Upvote if you understood the solution :)**\\n\\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        val = max(nums)\\n        i = j = res = 0\\n        \\n        while j < len(nums):\\n            if nums[j] == val:\\n                while j < len(nums) and nums[j] == val: j += 1 # increment j pointer until the current value == max val\\n                \\n                res = max(res, j - i)\\n            \\n            i = j = j + 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        val = max(nums)\\n        i = j = res = 0\\n        \\n        while j < len(nums):\\n            if nums[j] == val:\\n                while j < len(nums) and nums[j] == val: j += 1 # increment j pointer until the current value == max val\\n                \\n                res = max(res, j - i)\\n            \\n            i = j = j + 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620849,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        // the bitwise AND of two different numbers will always be strictly less than the maximum of those two numbers\\n        // so the longest subarray with max bitwise AND would be the subarray containing only the max numbers\\n        int mx = *max_element(nums.begin(), nums.end());\\n        int ans, cnt = 0;\\n        for (auto &x : nums) {\\n            // increase the count by 1 if it is same as the max number\\n            if (x == mx) cnt += 1;\\n            // else reset it\\n            else cnt = 0;\\n            // update ans\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        // the bitwise AND of two different numbers will always be strictly less than the maximum of those two numbers\\n        // so the longest subarray with max bitwise AND would be the subarray containing only the max numbers\\n        int mx = *max_element(nums.begin(), nums.end());\\n        int ans, cnt = 0;\\n        for (auto &x : nums) {\\n            // increase the count by 1 if it is same as the max number\\n            if (x == mx) cnt += 1;\\n            // else reset it\\n            else cnt = 0;\\n            // update ans\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620473,
                "title": "simple-greedy-method",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int maximum=0;\\n        int n=nums.length;\\n        //finding the max value in thr array\\n        for(int i=0;i<n;i++)maximum=Math.max(maximum,nums[i]);\\n        ArrayList<Integer> l=new ArrayList<>();\\n        //putting the indices of all max of nums\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==maximum)l.add(i);\\n        }\\n       \\n        int r=1;\\n        int maxlen=0;\\n        //checking from the length of the maximum value present as subarray \\n        for(int i=1;i<l.size();i++){\\n            if(l.get(i)-l.get(i-1)==1)r++;\\n            else{\\n                maxlen=Math.max(maxlen,r);  \\n                r=1;\\n            } \\n        }\\n        maxlen=Math.max(maxlen,r);\\n        return maxlen;      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int maximum=0;\\n        int n=nums.length;\\n        //finding the max value in thr array\\n        for(int i=0;i<n;i++)maximum=Math.max(maximum,nums[i]);\\n        ArrayList<Integer> l=new ArrayList<>();\\n        //putting the indices of all max of nums\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==maximum)l.add(i);\\n        }\\n       \\n        int r=1;\\n        int maxlen=0;\\n        //checking from the length of the maximum value present as subarray \\n        for(int i=1;i<l.size();i++){\\n            if(l.get(i)-l.get(i-1)==1)r++;\\n            else{\\n                maxlen=Math.max(maxlen,r);  \\n                r=1;\\n            } \\n        }\\n        maxlen=Math.max(maxlen,r);\\n        return maxlen;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620701,
                "title": "explanation-java-max-subarray-length-with-only-max-element-o-n",
                "content": "```bitwise and``` of a subarray <= Max element in the subarray. \\n\\nTherefore the max ```bitwise and``` will be of the max element in the array.  Then the problem is simply to find the longest subarray length of the max element repeated(each element is equal to the max element) in the array , since the ```bitwise and``` of a and b, when ```a == b ``` is a.\\n\\nIf the element we encounter is greater than the previous one then we simply set the length to 1 and find the number of consecutive such element. Otherwise, if the element is equal to the max element, we check if the current subarray length is greater than the previous.\\n ```\\npublic int longestSubarray(int[] nums) {\\n        int max = 0;\\n        int len = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n                len = 1;\\n                while(i < nums.length - 1 && nums[i] == nums[i+1] ){\\n                    i++; len++;\\n                }\\n            }else if(nums[i] == max){\\n                int tempLen = 1;\\n                while(i < nums.length - 1 && nums[i] == nums[i+1] ){\\n                    i++; tempLen++;\\n                }\\n                len = Math.max(len, tempLen);\\n            }\\n        }\\n        \\n        return len;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```bitwise and```\n```bitwise and```\n```bitwise and```\n```a == b ```\n```\\npublic int longestSubarray(int[] nums) {\\n        int max = 0;\\n        int len = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n                len = 1;\\n                while(i < nums.length - 1 && nums[i] == nums[i+1] ){\\n                    i++; len++;\\n                }\\n            }else if(nums[i] == max){\\n                int tempLen = 1;\\n                while(i < nums.length - 1 && nums[i] == nums[i+1] ){\\n                    i++; tempLen++;\\n                }\\n                len = Math.max(len, tempLen);\\n            }\\n        }\\n        \\n        return len;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621498,
                "title": "java-solution-and-trick-explained-easy-to-understand",
                "content": "### *Please Upvote !!!* **(\\u25E0\\u203F\\u25E0)**\\nWe need the maximum bitwise AND. \\n\\nThe bitwise AND of the maximum element with itself is going to give us the maximum bitwise AND possible in the array.\\n\\nSo in first pass, we find the maximum element in the array and in another pass we find the length of the longest subarray containing all max elements. \\n\\nBecause all AND operations in ```[x, x, x, x]``` will give us ```x``` itself and that is the maximum AND possible. \\n\\nSay we have a subarray ```[x, y, x, x]``` and ```y < x```, Our AND value will decrease therefore our desired subarray becomes ```[x, x]``` which lies after the element ```y```.\\n\\nThis is the whole intuition, I hope you understood it.\\n\\nBelow is the solution:\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int max = 0;\\n        for (int i : nums) {\\n            if (i > max) max = i;\\n        }\\n        \\n        int maxLen = 0, currLen = 0;\\n        \\n        for (int n : nums) {\\n            if (n == max) currLen++;\\n            else currLen = 0;\\n            maxLen = Math.max(maxLen, currLen);\\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n\\n// TC: O(n) + O(n) => O(n)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```[x, x, x, x]```\n```x```\n```[x, y, x, x]```\n```y < x```\n```[x, x]```\n```y```\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int max = 0;\\n        for (int i : nums) {\\n            if (i > max) max = i;\\n        }\\n        \\n        int maxLen = 0, currLen = 0;\\n        \\n        for (int n : nums) {\\n            if (n == max) currLen++;\\n            else currLen = 0;\\n            maxLen = Math.max(maxLen, currLen);\\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n\\n// TC: O(n) + O(n) => O(n)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621030,
                "title": "count-maxelement-c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        \\n       int x=max_element(nums.begin(),nums.end())-nums.begin();\\n        int c=1;\\n        int ans=1;\\n        for(int i=x;i<nums.size();i++)\\n        {\\n            if(i<nums.size()-1 && nums[i]==nums[i+1] && nums[i]==nums[x] && nums[i+1]==nums[x])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n               ans=max(ans,c);\\n                c=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        \\n       int x=max_element(nums.begin(),nums.end())-nums.begin();\\n        int c=1;\\n        int ans=1;\\n        for(int i=x;i<nums.size();i++)\\n        {\\n            if(i<nums.size()-1 && nums[i]==nums[i+1] && nums[i]==nums[x] && nums[i+1]==nums[x])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n               ans=max(ans,c);\\n                c=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620641,
                "title": "c-o-n",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach**: \\n1. Max. AND opeartion value = max. element in array\\n2. Calculating lonhgest sub-array of max. element\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& a) {\\n        int n=a.size();\\n        int maxe = *max_element(a.begin(),a.end());\\n        \\n        int len=0;\\n        int maxlen=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(a[i]==maxe){\\n                len++;\\n            }else{\\n                len=0;\\n            }\\n\\t\\t\\tmaxlen=max(maxlen,len);\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& a) {\\n        int n=a.size();\\n        int maxe = *max_element(a.begin(),a.end());\\n        \\n        int len=0;\\n        int maxlen=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(a[i]==maxe){\\n                len++;\\n            }else{\\n                len=0;\\n            }\\n\\t\\t\\tmaxlen=max(maxlen,len);\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620460,
                "title": "number-of-max-element",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int k = 0, maxi = INT_MIN, mn = *max_element(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==mn)     k++;\\n            else{\\n                maxi = max(maxi,k);\\n                k = 0;\\n            }\\n        }\\n        return max(maxi,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int k = 0, maxi = INT_MIN, mn = *max_element(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==mn)     k++;\\n            else{\\n                maxi = max(maxi,k);\\n                k = 0;\\n            }\\n        }\\n        return max(maxi,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628092,
                "title": "python3-5-lines-w-explanation-t-m-897ms-28-1mb",
                "content": "```\\nclass Solution:     # The problem reduces to finding the longest subarray with only \\n                    # elements = max(nums). So here\\'s the plan:\\n                    #  1) Determine max(nums).\\n                    #  2) Iterate through nums and keep track of the lengths of such \\n                    #     max subarrays. \\n                    #  3) When a max subarray ends, update the max length. \\n                    #  4) Return the max length of those subarrays. (Note the\\n                    #     last update in the return)\\n    def longestSubarray(self, nums: List[int]) -> int:\\n\\n        ans, tally, mx = 0, 0, max(nums)            # <-- 1)\\n\\n        for n in nums:\\n            if n == mx: tally += 1                  # <-- 2)\\n            else: ans, tally = max(ans, tally), 0   # <-- 3)\\n\\n        return max(ans, tally)                      # <-- 4)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:     # The problem reduces to finding the longest subarray with only \\n                    # elements = max(nums). So here\\'s the plan:\\n                    #  1) Determine max(nums).\\n                    #  2) Iterate through nums and keep track of the lengths of such \\n                    #     max subarrays. \\n                    #  3) When a max subarray ends, update the max length. \\n                    #  4) Return the max length of those subarrays. (Note the\\n                    #     last update in the return)\\n    def longestSubarray(self, nums: List[int]) -> int:\\n\\n        ans, tally, mx = 0, 0, max(nums)            # <-- 1)\\n\\n        for n in nums:\\n            if n == mx: tally += 1                  # <-- 2)\\n            else: ans, tally = max(ans, tally), 0   # <-- 3)\\n\\n        return max(ans, tally)                      # <-- 4)",
                "codeTag": "Java"
            },
            {
                "id": 2621001,
                "title": "c-easy-solution-passed-all-testcases",
                "content": "**Logic** - If you will take and of any number with the maximum number present in the array, it will decrease it\\'s value. \\n\\n1, 2, 3, 5, 4 -> For this case the output would be 1 as the largest subarray is [5].\\n\\n**The maximum and of the array would be the largest element present in the array. So all you need to find is maximum of the lengths of subarray with all number equal to maximum numbers.**\\n\\n1, 2, 3, 5, 5, 4 -> For this case the output would be 2 as the largest subarray is [5,5].\\n1, 2, 5, 5, 5, 3, 5, 5, 4 -> For this case the output would be 3 as the largest subarray is [5,5,5].\\n\\n```\\n\\t\\t// Finding the index of maximum element\\n\\t\\tint indmax = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] > nums[indmax]){\\n                indmax = i;\\n            }\\n        }\\n\\t\\t// Storing indexes of maximum element in the vector indexes.\\n        vector<int> indexes;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i]==nums[indmax]){\\n                indexes.push_back(i);\\n            }\\n        }\\n\\t\\t// Visited will help us in knowing if we have visited the element already.\\n        vector<int> visited(nums.size(), false);\\n        int ans = 0;\\n        for(auto index : indexes){\\n\\t\\t// For every index we will count the number of indexes after that index that have same value as the maximum element.\\n            if(visited[index]==false){\\n                int cnt =0;\\n                for(int i = index; i < nums.size(); i++){\\n                    visited[i]= true;\\n                    if(nums[index]==nums[i]){\\n                        cnt++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                ans = max(cnt, ans);\\n            }\\n        }\\n        return ans;\\n```\\n**Do upvote if you liked the solution.**\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\t\\t// Finding the index of maximum element\\n\\t\\tint indmax = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] > nums[indmax]){\\n                indmax = i;\\n            }\\n        }\\n\\t\\t// Storing indexes of maximum element in the vector indexes.\\n        vector<int> indexes;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i]==nums[indmax]){\\n                indexes.push_back(i);\\n            }\\n        }\\n\\t\\t// Visited will help us in knowing if we have visited the element already.\\n        vector<int> visited(nums.size(), false);\\n        int ans = 0;\\n        for(auto index : indexes){\\n\\t\\t// For every index we will count the number of indexes after that index that have same value as the maximum element.\\n            if(visited[index]==false){\\n                int cnt =0;\\n                for(int i = index; i < nums.size(); i++){\\n                    visited[i]= true;\\n                    if(nums[index]==nums[i]){\\n                        cnt++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                ans = max(cnt, ans);\\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620657,
                "title": "simple-bitwise-and-property-to-solve-this-problem-easily",
                "content": "We need to return length of the longest subarray with maximum bitwise and.\\n\\nIntuition:\\nA/C. to bitwise AND property, if both bits are 1 then it is 1 else 0, means if numbers are same then this subarray of numbers are our answer if that number is maximum in the array.\\nSo, we need to find the maximum value of number in nums array and return it\\'s maximum continuous occurence.\\n\\ncode:\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int mxm=0;       \\n        for(int i=0;i<nums.size();i++)           //finding maximum value\\n            mxm=max(mxm,nums[i]);\\n        int cnt=0,i,ans=1;                           \\n        for(i=0;i<nums.size();i++){             //finding continuous occurences of mxm number \\n            if(nums[i]==mxm){\\n                cnt++;\\n            }\\n            else\\n                cnt=0;\\n            ans=max(ans,cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTC: O(N)\\nSC: O(1) (auxiliary space)\\nwhere N is size of num array.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int mxm=0;       \\n        for(int i=0;i<nums.size();i++)           //finding maximum value\\n            mxm=max(mxm,nums[i]);\\n        int cnt=0,i,ans=1;                           \\n        for(i=0;i<nums.size();i++){             //finding continuous occurences of mxm number \\n            if(nums[i]==mxm){\\n                cnt++;\\n            }\\n            else\\n                cnt=0;\\n            ans=max(ans,cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620490,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n         int n;\\n    int longestSubarray(vector<int>& nums) {\\n         n = nums.size();\\n        int val=*max_element(nums.begin(),nums.end());\\n        int len=0;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==val)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                len=max(count,len);\\n                count=0;\\n            }\\n        }\\n        return max(len,count);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n         int n;\\n    int longestSubarray(vector<int>& nums) {\\n         n = nums.size();\\n        int val=*max_element(nums.begin(),nums.end());\\n        int len=0;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==val)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                len=max(count,len);\\n                count=0;\\n            }\\n        }\\n        return max(len,count);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620465,
                "title": "c-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) \\n    {\\n        // 1. find out the max value of nums\\n        // 2. count the appreances of max value for subarrays and return max one\\n        int n = nums.size();\\n        \\n        int mx_val = INT_MIN;\\n        for(auto it : nums) \\n            mx_val = max(mx_val,it);\\n        \\n        int cnt = 1;\\n        int ans = 1;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i]==mx_val && nums[i]==nums[i+1])\\n                cnt++;\\n            else\\n                cnt=1;\\n            \\n            ans = max(ans,cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) \\n    {\\n        // 1. find out the max value of nums\\n        // 2. count the appreances of max value for subarrays and return max one\\n        int n = nums.size();\\n        \\n        int mx_val = INT_MIN;\\n        for(auto it : nums) \\n            mx_val = max(mx_val,it);\\n        \\n        int cnt = 1;\\n        int ans = 1;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i]==mx_val && nums[i]==nums[i+1])\\n                cnt++;\\n            else\\n                cnt=1;\\n            \\n            ans = max(ans,cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411989,
                "title": "time-o-n-space-o-1-95-faster-c-short-sweet",
                "content": "````\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int ans = 0, i = 0, j = 0, n = nums.size(),k=-1;\\n        while(i<n){\\n            j = i;\\n            while(j<n&&nums[i]==nums[j]){\\n                j++;\\n            }\\n            if(k==-1 || nums[i]>k){\\n                k = nums[i];\\n                ans = j-i;\\n            }\\n            else if(nums[i]==k){\\n                ans = max(ans,j-i);\\n            }\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int ans = 0, i = 0, j = 0, n = nums.size(),k=-1;\\n        while(i<n){\\n            j = i;\\n            while(j<n&&nums[i]==nums[j]){\\n                j++;\\n            }\\n            if(k==-1 || nums[i]>k){\\n                k = nums[i];\\n                ans = j-i;\\n            }\\n            else if(nums[i]==k){\\n                ans = max(ans,j-i);\\n            }\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334881,
                "title": "c-simple-solution",
                "content": "# Intuition\\nBitwise **AND** of 2 numbers is less than the maximum of the two numbers.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxAnd = *max_element(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int cnt=0;\\n            while(i<n && nums[i]==maxAnd)\\n            {\\n                cnt++;\\n                i++;\\n            }\\n            ans = max(ans,cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxAnd = *max_element(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int cnt=0;\\n            while(i<n && nums[i]==maxAnd)\\n            {\\n                cnt++;\\n                i++;\\n            }\\n            ans = max(ans,cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762866,
                "title": "c-observation-based-well-commented-easy-to-understand-explanation",
                "content": "```\\n// Bitwise AND of two numbers is always less than or equal to the max. of no.s.\\n// To maximise the AND operation of a subarray, try to take the maximum no.s only.\\n// Just find out the maximum no., the longest occurence of it and thats your answer :)\\nint longestSubarray(vector<int>& nums) {\\n        \\n        int x = *max_element(nums.begin(),nums.end());\\n        int c = 0, ans = 0;\\n        // ans to store longest occurence and c to count adjacent occurence\\n        for(int i=0;i<nums.size()-1;i++) {\\n            if(nums[i]==x && nums[i+1]==x) {\\n                c++; \\n            }else {\\n                c = 0;\\n            }\\n            ans = max(ans,c);\\n        }\\n        // (ans+1) bcoz for 5 consecutive elements, ans has stored 4.\\n        return ans+1;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Bitwise AND of two numbers is always less than or equal to the max. of no.s.\\n// To maximise the AND operation of a subarray, try to take the maximum no.s only.\\n// Just find out the maximum no., the longest occurence of it and thats your answer :)\\nint longestSubarray(vector<int>& nums) {\\n        \\n        int x = *max_element(nums.begin(),nums.end());\\n        int c = 0, ans = 0;\\n        // ans to store longest occurence and c to count adjacent occurence\\n        for(int i=0;i<nums.size()-1;i++) {\\n            if(nums[i]==x && nums[i+1]==x) {\\n                c++; \\n            }else {\\n                c = 0;\\n            }\\n            ans = max(ans,c);\\n        }\\n        // (ans+1) bcoz for 5 consecutive elements, ans has stored 4.\\n        return ans+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2634738,
                "title": "one-pass-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int n=Integer.MIN_VALUE;\\n        for(int i:nums)\\n        {\\n            n=Math.max(i,n);    // find the max value\\n        }\\n        int c=0,p=0;\\n        for(int i:nums)\\n        {\\n            if(i==n)\\n            {\\n                c++;     //find the length of the array holding the largest elements only\\n            }\\n            else\\n            {\\n                c=0;\\n            }\\n            p=Math.max(p,c);\\n        }\\n        return p;      // return the maximum subarray size\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int longestSubarray(int[] nums) {\\n        int n=Integer.MIN_VALUE;\\n        for(int i:nums)\\n        {\\n            n=Math.max(i,n);    // find the max value\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2626100,
                "title": "2419-longest-subarray-with-maximum-bitwise-and",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        // int len=1;\\n        // int maxLen=0;\\n        // int i=0;\\n        // while(i<nums.size()-1){\\n        //     if(nums[i]==nums[i+1]){\\n        //         len++;\\n        //     }\\n        //     else len=1;\\n        //     maxLen=max(maxLen,len);\\n        //     i++;\\n        // }\\n        // int ans=0;\\n        // map<int,int> mp;\\n        // for(auto it:nums) mp[it]++;\\n        // for(auto it:mp){\\n        //     if(it.second==maxLen) ans=it.first;\\n        // }\\n        // int res=0;\\n        // for(auto it:nums) if(it==ans) res++;\\n        // return res;\\n        int maxi=INT_MIN;\\n        int count=1;\\n        /*Intiution- The & of two elements is strictly lesser than the maximu number in case of \\n        both different numbers and is same as that of the number in case of both same number.\\n        So basically find the largest subarray of the maximum elements.*/\\n        //count the maximum element of the array\\n        for(auto it:nums){\\n            maxi=max(maxi,it);\\n        }\\n        int i=0;\\n        int maxCount=1;\\n        /*traverse through the array. if we found that the present element is equal to the \\n        maximum element and the next element is also equal to the maximum element, i.e, it is a\\n        subarray of maximum element then increase the count and find the maximum count  \\n        simultaneously*/\\n        while(i<nums.size()-1){\\n            if(nums[i]==maxi && nums[i]==nums[i+1]) count++;\\n            else count=1;\\n            maxCount=max(maxCount,count);\\n            i++;\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        // int len=1;\\n        // int maxLen=0;\\n        // int i=0;\\n        // while(i<nums.size()-1){\\n        //     if(nums[i]==nums[i+1]){\\n        //         len++;\\n        //     }\\n        //     else len=1;\\n        //     maxLen=max(maxLen,len);\\n        //     i++;\\n        // }\\n        // int ans=0;\\n        // map<int,int> mp;\\n        // for(auto it:nums) mp[it]++;\\n        // for(auto it:mp){\\n        //     if(it.second==maxLen) ans=it.first;\\n        // }\\n        // int res=0;\\n        // for(auto it:nums) if(it==ans) res++;\\n        // return res;\\n        int maxi=INT_MIN;\\n        int count=1;\\n        /*Intiution- The & of two elements is strictly lesser than the maximu number in case of \\n        both different numbers and is same as that of the number in case of both same number.\\n        So basically find the largest subarray of the maximum elements.*/\\n        //count the maximum element of the array\\n        for(auto it:nums){\\n            maxi=max(maxi,it);\\n        }\\n        int i=0;\\n        int maxCount=1;\\n        /*traverse through the array. if we found that the present element is equal to the \\n        maximum element and the next element is also equal to the maximum element, i.e, it is a\\n        subarray of maximum element then increase the count and find the maximum count  \\n        simultaneously*/\\n        while(i<nums.size()-1){\\n            if(nums[i]==maxi && nums[i]==nums[i+1]) count++;\\n            else count=1;\\n            maxCount=max(maxCount,count);\\n            i++;\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624031,
                "title": "easy-small-and-well-explained-solution",
                "content": "```\\n// As we notice, the bitwise AND operation on two numbers will be maximum only when both numbers will be same.\\n// We can also conclude that the AND operator will give the same value equal to operand when done with the same operands.\\n// eg. 1011                   1011\\n//    +1011(same)             1101(some different number)\\n//    ------                 ------\\n//     1011(max)              1001(lesser)\\n//\\n// in all other cases it will be lesser.\\n// Hence we need to find the longest subarray consisting of only the highest number in the array.\\n\\n\\nclass Solution {\\n    public int longestSubarray(int[] nums) \\n    {\\n        // First we need to find the highest number in the array.\\n        int highest = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(highest < nums[i])\\n            {\\n                highest = nums[i];\\n            }\\n        }\\n        // now we need to find the highest subarray of the given array having only highest number.\\n        int Count = 0;\\n        int maximum = 0;\\n        int i= 0;\\n        while( i<nums.length)\\n        {\\n            if(nums[i] == highest)                  //finding how many consecutive \\n            {\\n                Count++;\\n                maximum = Math.max(Count,maximum);\\n            }\\n            else                                  \\n            {\\n                Count = 0;                          //restarting the count\\n            }\\n            i++;\\n        }\\n        \\n        return maximum;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n// As we notice, the bitwise AND operation on two numbers will be maximum only when both numbers will be same.\\n// We can also conclude that the AND operator will give the same value equal to operand when done with the same operands.\\n// eg. 1011                   1011\\n//    +1011(same)             1101(some different number)\\n//    ------                 ------\\n//     1011(max)              1001(lesser)\\n//\\n// in all other cases it will be lesser.\\n// Hence we need to find the longest subarray consisting of only the highest number in the array.\\n\\n\\nclass Solution {\\n    public int longestSubarray(int[] nums) \\n    {\\n        // First we need to find the highest number in the array.\\n        int highest = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(highest < nums[i])\\n            {\\n                highest = nums[i];\\n            }\\n        }\\n        // now we need to find the highest subarray of the given array having only highest number.\\n        int Count = 0;\\n        int maximum = 0;\\n        int i= 0;\\n        while( i<nums.length)\\n        {\\n            if(nums[i] == highest)                  //finding how many consecutive \\n            {\\n                Count++;\\n                maximum = Math.max(Count,maximum);\\n            }\\n            else                                  \\n            {\\n                Count = 0;                          //restarting the count\\n            }\\n            i++;\\n        }\\n        \\n        return maximum;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623784,
                "title": "c-simple-fastest-maximum-element",
                "content": "```\\n\\tFind maximum element in the array \\n\\tFind longest subarray  which contain only maximum element.\\n```\\n```\\n int longestSubarray(vector<int>& arr) {\\n        int mx=INT_MIN, ans=0, temp=0;\\n        for(int i=0;i<arr.size();i++){ \\n            mx=max(mx, arr[i]);\\n        }\\n\\t\\t\\n        for(int i=0;i<arr.size();i++){ \\n            if(arr[i]==mx) temp++;\\n            else  temp=0;\\n            ans=max(ans, temp);\\n        }\\n        return ans;\\n    }\\n```\\n\\uD83D\\uDE42 ***why you guys always forget to upvote, it motivates me to make such post.***",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\tFind maximum element in the array \\n\\tFind longest subarray  which contain only maximum element.\\n```\n```\\n int longestSubarray(vector<int>& arr) {\\n        int mx=INT_MIN, ans=0, temp=0;\\n        for(int i=0;i<arr.size();i++){ \\n            mx=max(mx, arr[i]);\\n        }\\n\\t\\t\\n        for(int i=0;i<arr.size();i++){ \\n            if(arr[i]==mx) temp++;\\n            else  temp=0;\\n            ans=max(ans, temp);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621411,
                "title": "weekly-contest-312-java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int longestSubarray(int[] nums) {\\n\\t\\t\\tint max=0;\\n\\t\\t\\tfor(int i:nums){\\n\\t\\t\\t\\tmax=Math.max(max,i);\\n\\t\\t\\t}\\n\\t\\t\\tif(nums.length==1)return 1;\\n\\t\\t\\tint count=1,ans=1;\\n\\t\\t\\tfor(int i=0;i<nums.length-1;i++){\\n\\t\\t\\t\\tif(nums[i]==nums[i+1]&&nums[i]==max){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t ans=Math.max(ans,count);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse{\\n\\n\\t\\t\\t\\t\\tcount=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int longestSubarray(int[] nums) {\\n\\t\\t\\tint max=0;\\n\\t\\t\\tfor(int i:nums){\\n\\t\\t\\t\\tmax=Math.max(max,i);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2621135,
                "title": "longest-subarray-with-maximum-bitwise-and-c-python",
                "content": "**Approach**\\n1. Find the maximum element from the array\\n2. Iterating over the loop again check for the elements which are equal to maximum element, \\n    if condition is true then update the length of the subarray\\n\\t\\n**C++ Solution : **\\nint longestSubarray(vector<int>& nums) {\\n        \\n        int maxNum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            maxNum=max(maxNum,nums[i]);\\n        }\\n        \\n        int length=1,temp=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==maxNum){\\n                length=max(length,++temp);\\n            }\\n            else{\\n                temp=0;\\n            }\\n        }\\n        \\n        return length;\\n        \\n    }\\n\\t\\n****\\tPython Solution : ****\\n\\t\\n\\tdef longestSubarray(self, nums: List[int]) -> int:\\n        maxNum=0\\n        for i in range(0,len(nums)):\\n            maxNum=max(maxNum,nums[i])\\n        \\n        length=1\\n        temp=0\\n        \\n        for i in range(0,len(nums)):\\n            if maxNum==nums[i]:\\n                temp+=1\\n                length=max(length,temp)\\n            else:\\n                temp=0\\n        \\n        return length\\n\\t",
                "solutionTags": [],
                "code": "**Approach**\\n1. Find the maximum element from the array\\n2. Iterating over the loop again check for the elements which are equal to maximum element, \\n    if condition is true then update the length of the subarray\\n\\t\\n**C++ Solution : **\\nint longestSubarray(vector<int>& nums) {\\n        \\n        int maxNum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            maxNum=max(maxNum,nums[i]);\\n        }\\n        \\n        int length=1,temp=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==maxNum){\\n                length=max(length,++temp);\\n            }\\n            else{\\n                temp=0;\\n            }\\n        }\\n        \\n        return length;\\n        \\n    }\\n\\t\\n****\\tPython Solution : ****\\n\\t\\n\\tdef longestSubarray(self, nums: List[int]) -> int:\\n        maxNum=0\\n        for i in range(0,len(nums)):\\n            maxNum=max(maxNum,nums[i])\\n        \\n        length=1\\n        temp=0\\n        \\n        for i in range(0,len(nums)):\\n            if maxNum==nums[i]:\\n                temp+=1\\n                length=max(length,temp)\\n            else:\\n                temp=0\\n        \\n        return length\\n\\t",
                "codeTag": "Python3"
            },
            {
                "id": 2620562,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int longestSubarray(vector<int>&v) {\\n        ll n=v.size(), ans=0, mx=*max_element(v.begin(), v.end());\\n        for(ll i=0;i<n;++i){\\n            if(v[i]<mx){\\n                continue;\\n            }\\n            ll j=i+1;\\n            for(;j<n && v[j]==v[j-1];++j);\\n            --j;\\n            ans=max(ans, j-i+1);\\n            i=j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int longestSubarray(vector<int>&v) {\\n        ll n=v.size(), ans=0, mx=*max_element(v.begin(), v.end());\\n        for(ll i=0;i<n;++i){\\n            if(v[i]<mx){\\n                continue;\\n            }\\n            ll j=i+1;\\n            for(;j<n && v[j]==v[j-1];++j);\\n            --j;\\n            ans=max(ans, j-i+1);\\n            i=j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620509,
                "title": "longest-subarray-of-max-number-java",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int ans = 0;\\n        int n = nums.length;\\n        \\n        // find max number in array\\n        int maxNumber = 0;\\n        for(int num : nums) maxNumber = Math.max(maxNumber, num);\\n        \\n        int len = 0;\\n        for(int num : nums) {\\n            if(num == maxNumber) len++;\\n            else len = 0;\\n            ans = Math.max(ans, len);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int ans = 0;\\n        int n = nums.length;\\n        \\n        // find max number in array\\n        int maxNumber = 0;\\n        for(int num : nums) maxNumber = Math.max(maxNumber, num);\\n        \\n        int len = 0;\\n        for(int num : nums) {\\n            if(num == maxNumber) len++;\\n            else len = 0;\\n            ans = Math.max(ans, len);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620461,
                "title": "javascript-maximum-bitwise-and-maximum-number",
                "content": "**Solution: Longest Consecutive Max Number**\\n\\nThe maximum bitwise AND is the maximum number in the array.\\nFind the length of the longest subarray consisting of the max number.\\n\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(1)`\\n```\\nvar longestSubarray = function(nums) {\\n  let n = nums.length, max = Math.max(...nums);\\n  let len = 0, maxLen = 0;\\n  for (let i = 0; i < n; i++) {\\n    if (nums[i] === max) len++;\\n    else len = 0;\\n    maxLen = Math.max(maxLen, len);\\n  }\\n  return maxLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestSubarray = function(nums) {\\n  let n = nums.length, max = Math.max(...nums);\\n  let len = 0, maxLen = 0;\\n  for (let i = 0; i < n; i++) {\\n    if (nums[i] === max) len++;\\n    else len = 0;\\n    maxLen = Math.max(maxLen, len);\\n  }\\n  return maxLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3343042,
                "title": "c-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n   int longestSubarray(vector<int> &nums)\\n{\\n    int mx = *max_element(nums.begin(), nums.end());\\n    int ans = 1;\\n    int count = 0;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        if (nums[i] == mx)\\n        {\\n            count++;\\n            ans = max(ans, count);\\n        }\\n        else\\n        {\\n            count = 0;\\n        }\\n    }\\n    ans = max(ans, count);\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int longestSubarray(vector<int> &nums)\\n{\\n    int mx = *max_element(nums.begin(), nums.end());\\n    int ans = 1;\\n    int count = 0;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        if (nums[i] == mx)\\n        {\\n            count++;\\n            ans = max(ans, count);\\n        }\\n        else\\n        {\\n            count = 0;\\n        }\\n    }\\n    ans = max(ans, count);\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957980,
                "title": "javascript-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Bitwise AND of two different numbers will always be strictly less than the maximum of those two numbers. So the longest subarray with max bitwise AND would be the subarray containing only the max numbers.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSubarray = function(nums) {\\n    let ans = 0, count = 0;\\n    let max = Math.max(...nums);\\n    \\n    for (const num of nums) {\\n        if (num === max) {\\n            ans = Math.max(ans, ++count);\\n        } else {\\n            count = 0;\\n        }\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Bit Manipulation",
                    "Brainteaser"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSubarray = function(nums) {\\n    let ans = 0, count = 0;\\n    let max = Math.max(...nums);\\n    \\n    for (const num of nums) {\\n        if (num === max) {\\n            ans = Math.max(ans, ++count);\\n        } else {\\n            count = 0;\\n        }\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2704908,
                "title": "c-easy-apporach",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int maxnum = nums[0];\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            maxnum = max(maxnum,nums[i]);\\n        }\\n        int cnt = 0,maxcnt=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == maxnum){\\n                while(i<n && nums[i]==maxnum){\\n                    i++;\\n                    cnt++;\\n                }\\n                maxcnt = max(maxcnt,cnt);\\n                cnt=0;\\n            }\\n        }\\n        return maxcnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int maxnum = nums[0];\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            maxnum = max(maxnum,nums[i]);\\n        }\\n        int cnt = 0,maxcnt=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == maxnum){\\n                while(i<n && nums[i]==maxnum){\\n                    i++;\\n                    cnt++;\\n                }\\n                maxcnt = max(maxcnt,cnt);\\n                cnt=0;\\n            }\\n        }\\n        return maxcnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659415,
                "title": "bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>&a) {\\n        \\n        int n=a.size();\\n        \\n        int x=0;\\n        \\n        for(int i=31;i>=0;i--)\\n        {\\n            int cnt=0;\\n            int ans=(x|(1<<i));\\n            for(int j=0;j<n;j++)\\n            {\\n                if(((a[j]&(ans)))==ans)\\n                {\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>=1)\\n            {\\n                x|=(1<<i);\\n            }\\n        }\\n       \\n        int cnt=0,ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(x==(a[i]))\\n            {\\n                cnt++;\\n                continue;\\n            }\\n            else\\n            {\\n                ans=max(ans,cnt);\\n                cnt=0;\\n            }\\n        }\\n        ans=max(ans,cnt);\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>&a) {\\n        \\n        int n=a.size();\\n        \\n        int x=0;\\n        \\n        for(int i=31;i>=0;i--)\\n        {\\n            int cnt=0;\\n            int ans=(x|(1<<i));\\n            for(int j=0;j<n;j++)\\n            {\\n                if(((a[j]&(ans)))==ans)\\n                {\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>=1)\\n            {\\n                x|=(1<<i);\\n            }\\n        }\\n       \\n        int cnt=0,ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(x==(a[i]))\\n            {\\n                cnt++;\\n                continue;\\n            }\\n            else\\n            {\\n                ans=max(ans,cnt);\\n                cnt=0;\\n            }\\n        }\\n        ans=max(ans,cnt);\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632314,
                "title": "linear-time-o-n-solution-very-fast-no-bitwise-operator-used",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int max=0,i,n=nums.length,len=0,maxLen=1;\\n        for(i=0;i<n;i++){\\n            if(max<nums[i]){\\n                max=nums[i];\\n                len=1;\\n                maxLen=1;\\n            }else if(max==nums[i]){\\n                len++;\\n                maxLen=Math.max(len,maxLen);\\n            }else len=0;\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int max=0,i,n=nums.length,len=0,maxLen=1;\\n        for(i=0;i<n;i++){\\n            if(max<nums[i]){\\n                max=nums[i];\\n                len=1;\\n                maxLen=1;\\n            }else if(max==nums[i]){\\n                len++;\\n                maxLen=Math.max(len,maxLen);\\n            }else len=0;\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629944,
                "title": "rust-8-ms-fastest-100-solution-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/809647161/) employs a simple counting inside a loop. It demonstrated **8 ms runtime (100.00%)** and used **4.2 MB memory (13.79%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn longest_subarray(nums: Vec<i32>) -> i32 \\n    {\\n        // [1] the answer to the problem is the length of \\n        //     the longest subarray with all elemets equal \\n        //     to the maximum value of \\'nums\\'\\n        let max_num     = *nums.iter().max().unwrap();\\n        \\n        let mut max_len = 0;\\n        let mut cur_len = 0;\\n                \\n        // [2] iterate and update the maximum length\\n        for n in nums.into_iter()\\n        {           \\n            if n == max_num { cur_len += 1; }\\n            else            { max_len = max_len.max(cur_len); cur_len = 0; }\\n        }\\n        \\n        max_len.max(cur_len)\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn longest_subarray(nums: Vec<i32>) -> i32 \\n    {\\n        // [1] the answer to the problem is the length of \\n        //     the longest subarray with all elemets equal \\n        //     to the maximum value of \\'nums\\'\\n        let max_num     = *nums.iter().max().unwrap();\\n        \\n        let mut max_len = 0;\\n        let mut cur_len = 0;\\n                \\n        // [2] iterate and update the maximum length\\n        for n in nums.into_iter()\\n        {           \\n            if n == max_num { cur_len += 1; }\\n            else            { max_len = max_len.max(cur_len); cur_len = 0; }\\n        }\\n        \\n        max_len.max(cur_len)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2627398,
                "title": "c-kadane-s-algorithm-short-and-fast-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n\\t\\t int longestSubarray(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tint maxel = 0;\\n\\t\\t\\tfor (int i = 0; i<n; i++){\\n\\t\\t\\t\\tmaxel = max(maxel, nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\tint count=0,m=0;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(nums[i] == maxel){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tm=max(count,m);\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tcount=0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn m;\\n    }\\n};\\n```\\n\\nplease upvote first publish, happy coding :)",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t\\t int longestSubarray(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tint maxel = 0;\\n\\t\\t\\tfor (int i = 0; i<n; i++){\\n\\t\\t\\t\\tmaxel = max(maxel, nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\tint count=0,m=0;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(nums[i] == maxel){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tm=max(count,m);\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tcount=0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622497,
                "title": "swift-solution-o-n",
                "content": "Bitwise AND of two different numbers will always be strictly less than the maximum of those two numbers, so we should find maximum element and length of contiguous subarray, containing this element.\\n\\n```\\nclass Solution {\\n    func longestSubarray(_ nums: [Int]) -> Int {\\n        guard let maxElement = nums.max() else {\\n            return 0\\n        }\\n        \\n        var subarraylength = 0\\n        var counter = 0\\n        \\n        for num in nums {\\n            if num == maxElement {\\n                counter += 1\\n                subarraylength = max(counter, subarraylength)\\n            } else {\\n                counter = 0\\n            }\\n        }\\n        \\n        \\n        return max(counter, subarraylength)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestSubarray(_ nums: [Int]) -> Int {\\n        guard let maxElement = nums.max() else {\\n            return 0\\n        }\\n        \\n        var subarraylength = 0\\n        var counter = 0\\n        \\n        for num in nums {\\n            if num == maxElement {\\n                counter += 1\\n                subarraylength = max(counter, subarraylength)\\n            } else {\\n                counter = 0\\n            }\\n        }\\n        \\n        \\n        return max(counter, subarraylength)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622172,
                "title": "python-solution-explained-beginner-friendly",
                "content": "# APPROACH:\\n* Bitwise AND of two numbers is non zero only if both the numbers are same - in this ques we have to find those numbers which are same , so those numbers be having the BITWISE AND = that number\\n\\neg: [3,3,3,3] bitwise and of these array elements is 3\\n\\n* Different numbers BITWISE AND is 0\\n\\neg: [1,2,3]  bitwise AND of these array elements is 0 , but if considering the single element from this array such as either [1] or [2] or [3] then the maximum bitwise will be considered as 3 i.e, 3 is max of array\\n\\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n\\t\\t## if all the elements are different then ans will be the max of th array which means \\n\\t\\t## the single element , so length of subarray will be 1\\n        if len(set(nums))==len(nums):\\n            return 1\\n\\t\\t\\t\\n\\t\\t## if only one element present in nums then thats the ans, so length of subarray will be 1\\n        if len(nums)==1:\\n            return 1\\n\\t\\t\\t\\n\\t\\t## now we have excluded conditions of all differnet elements , means the below condition will \\n\\t\\t## be defenitely having duplicates elements in the nums \\n\\t\\t\\n\\t\\t## always the max of nums will be having the maximum BITWISE AND\\n        m=max(nums)\\n        c=0\\n        ma=0\\n\\t\\t\\n\\t\\t## we will search for m here, means the maximum length subarray making by same number as m\\n        for i in nums: \\n\\t\\t\\t## if found the same as m , calculate the count as its length of subarray\\n            if i==m:\\n                c+=1\\n\\t\\t\\t\\t\\n\\t\\t\\t## if anywhere the subarray is broken (not finding the element as m)\\n\\t\\t\\t## then store the max count in ma and refresh the count c to 0 (which will \\n\\t\\t\\t## then going to calculate the count of new subarray if forming)\\n            else:\\n                ma=max(c,ma)\\n                c=0\\n\\t\\t## return the max count (max length of subarray)\\n        return max(c,ma)\\n        \\n```\\n**PLEASE UPVOTE IF YOU FOUND THE SOLUTION HELPFUL**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n\\t\\t## if all the elements are different then ans will be the max of th array which means \\n\\t\\t## the single element , so length of subarray will be 1\\n        if len(set(nums))==len(nums):\\n            return 1\\n\\t\\t\\t\\n\\t\\t## if only one element present in nums then thats the ans, so length of subarray will be 1\\n        if len(nums)==1:\\n            return 1\\n\\t\\t\\t\\n\\t\\t## now we have excluded conditions of all differnet elements , means the below condition will \\n\\t\\t## be defenitely having duplicates elements in the nums \\n\\t\\t\\n\\t\\t## always the max of nums will be having the maximum BITWISE AND\\n        m=max(nums)\\n        c=0\\n        ma=0\\n\\t\\t\\n\\t\\t## we will search for m here, means the maximum length subarray making by same number as m\\n        for i in nums: \\n\\t\\t\\t## if found the same as m , calculate the count as its length of subarray\\n            if i==m:\\n                c+=1\\n\\t\\t\\t\\t\\n\\t\\t\\t## if anywhere the subarray is broken (not finding the element as m)\\n\\t\\t\\t## then store the max count in ma and refresh the count c to 0 (which will \\n\\t\\t\\t## then going to calculate the count of new subarray if forming)\\n            else:\\n                ma=max(c,ma)\\n                c=0\\n\\t\\t## return the max count (max length of subarray)\\n        return max(c,ma)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621561,
                "title": "c-o-n-30-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        vector<int> dp(32,0); \\n        int re = 0,k = 0;\\n        for(int i = 0; i<nums.size();++i){\\n            int n = nums[i];\\n            for(int j = 0; j<31;++j){\\n                if(bool(n&(1<<j))) dp[j]++;\\n                else dp[j] = 0;\\n            }\\n            int temp = 0, m = INT_MAX;\\n            for(int j = 31; j>=0;--j){\\n                if(dp[j]){\\n                    temp = temp^(1<<j);\\n                    m = min(m,dp[j]);\\n                }\\n            }\\n            if(temp>=k){\\n                if(temp==k) re = max(re,m);\\n                else { k = temp; re = m; }\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        vector<int> dp(32,0); \\n        int re = 0,k = 0;\\n        for(int i = 0; i<nums.size();++i){\\n            int n = nums[i];\\n            for(int j = 0; j<31;++j){\\n                if(bool(n&(1<<j))) dp[j]++;\\n                else dp[j] = 0;\\n            }\\n            int temp = 0, m = INT_MAX;\\n            for(int j = 31; j>=0;--j){\\n                if(dp[j]){\\n                    temp = temp^(1<<j);\\n                    m = min(m,dp[j]);\\n                }\\n            }\\n            if(temp>=k){\\n                if(temp==k) re = max(re,m);\\n                else { k = temp; re = m; }\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621515,
                "title": "find-the-maximum-length-of-largest-element",
                "content": "LOGIC: AND of any two number is never greater than the numbers itself, infact it\\'s always lesser than than greater element out of both.\\n\\n\\t// 2 & 1 = 0, 7 & 3 = 3, 2 & 2 = 2, 5 & 5 = 5\\n\\t\\n**REPHRASING THE QUESTION:**\\nfind the maximum length of subarray of largest element!\\n\\n\\t\\n```\\nint longestSubarray(vector<int>& nums) {\\n\\n\\tint maxi = 0;\\n\\n\\tfor (int i = 0; i < nums.size(); i++)\\n\\t\\tmaxi = max(nums[i], maxi);\\n\\n\\tint maxLen = 1;\\n\\tint cnt = 0;\\n\\n\\tfor (int i = 0; i < nums.size(); i++)\\n\\t{\\n\\t\\tif (nums[i] == maxi)\\n\\t\\t{\\n\\t\\t\\tcnt++;\\n\\t\\t\\tmaxLen = max(maxLen, cnt);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tcnt = 0;\\n\\t}\\n\\treturn maxLen;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint longestSubarray(vector<int>& nums) {\\n\\n\\tint maxi = 0;\\n\\n\\tfor (int i = 0; i < nums.size(); i++)\\n\\t\\tmaxi = max(nums[i], maxi);\\n\\n\\tint maxLen = 1;\\n\\tint cnt = 0;\\n\\n\\tfor (int i = 0; i < nums.size(); i++)\\n\\t{\\n\\t\\tif (nums[i] == maxi)\\n\\t\\t{\\n\\t\\t\\tcnt++;\\n\\t\\t\\tmaxLen = max(maxLen, cnt);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tcnt = 0;\\n\\t}\\n\\treturn maxLen;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621470,
                "title": "c-code-easy-and-well-explained",
                "content": "**\\u2B06\\uFE0F UPVOTE \\u2B06\\uFE0F**\\n\\nExplanation of the Approach:\\n\\n**Important AND property used in the approach**: \\n        The max value possible of the AND of two number is the minimum of the two numbers.\\n\\t\\t\\nFirst we take the maximum value present in the array.\\nThen we check if the value is repeated consecutively in the array, if so, we take the whole length of the subarray containing the max value, else the answer would be simply 1 if the frequency of maximum value is only 1 in the array.\\n\\nBelow is the full code for the approach:\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        // sort(begin(nums),end(nums));\\n        int n=nums.size(),i=0,ans=INT_MIN;\\n        int mx=*max_element(nums.begin(),nums.end());\\n        \\n        while(i<n and nums[i]!=mx)i++;\\n        \\n        while(i<n)\\n        {\\n            int j=i;\\n            while(j<n and nums[j]==nums[i])j++;\\n            \\n            ans=max(ans,j-i);\\n            i=j;\\n            while(i<n and nums[i]!=nums[j-1])i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please, please do \\u2B06\\uFE0F upvote \\u2B06\\uFE0F if you found it helpful, it keeps me motivated to post more of such solutions :) and feel free to ask in comments if you have any queries/doubts :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        // sort(begin(nums),end(nums));\\n        int n=nums.size(),i=0,ans=INT_MIN;\\n        int mx=*max_element(nums.begin(),nums.end());\\n        \\n        while(i<n and nums[i]!=mx)i++;\\n        \\n        while(i<n)\\n        {\\n            int j=i;\\n            while(j<n and nums[j]==nums[i])j++;\\n            \\n            ans=max(ans,j-i);\\n            i=j;\\n            while(i<n and nums[i]!=nums[j-1])i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621420,
                "title": "very-very-easy-c-5-line-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n       int count=0;\\n        int ans=0;\\n        int maxx=*max_element(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<nums.size();i++){\\n             if(nums[i]==maxx){\\n                 count++;\\n             }    \\n            else{\\n                ans=max(ans,count);\\n                count=0;\\n            }\\n        }\\n        return max(ans,count);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n       int count=0;\\n        int ans=0;\\n        int maxx=*max_element(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<nums.size();i++){\\n             if(nums[i]==maxx){\\n                 count++;\\n             }    \\n            else{\\n                ans=max(ans,count);\\n                count=0;\\n            }\\n        }\\n        return max(ans,count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621413,
                "title": "java-weekly-312-contest-simple-solution",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int max = 0;\\n        int count = 1;\\n      //  if(nums.length == 1) return 0;\\n        for( int i = 0; i< nums.length ; i++){\\n            max = Math.max(max , nums[i]);\\n        }\\n        int ans = 1;\\n        for(int i = 0; i< nums.length -1; i++){\\n            if( nums[i] == nums[i+1] && max == nums[i]){\\n                count++;\\n                ans = Math.max(ans , count);\\n            }\\n            else{\\n                ans = Math.max(ans , count);\\n                count = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int longestSubarray(int[] nums) {\\n        int max = 0;\\n        int count = 1;\\n      //  if(nums.length == 1) return 0;\\n        for( int i = 0; i< nums.length ; i++){\\n            max = Math.max(max , nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2621329,
                "title": "c-solution-with-explanation-beginners-code",
                "content": "**Step1 - First we will find the maximum element in the array**\\n**Step2 - Then we wil compare if any element and its consequetive element are equal to maximum element (we finded in first step)**\\n**Step3 - If second step will follow the condition then increase count by 1 \\nelse set count to 1**\\n**Step4 -check after every iteration which one is max**\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int maxi = -1,len=1;\\n        if(nums.size()==1){\\n            return 1;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            maxi = max(maxi,nums[i]);\\n        }\\n        int k=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==maxi && nums[i]==nums[i+1]){\\n                len++;\\n            }\\n            else{\\n                len=1;\\n            }\\n            k = max(len,k);\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int maxi = -1,len=1;\\n        if(nums.size()==1){\\n            return 1;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            maxi = max(maxi,nums[i]);\\n        }\\n        int k=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==maxi && nums[i]==nums[i+1]){\\n                len++;\\n            }\\n            else{\\n                len=1;\\n            }\\n            k = max(len,k);\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621091,
                "title": "java-easiest-explanation-bitwise",
                "content": "Hi Family,\\n\\nI put the proper comment in the code, If you didn\\'t understand anything Please feel free to revert back\\n\\n```\\n\\tpublic int longestSubarray(int[] nums) {\\n        int n = nums.length;\\n        int max_elem = 0;\\n        //we have to find the maximum Bitwise AND\\n        // first we will find the maximum number in the array because max number has maximum bitwise AND\\n        /*\\n        *   4 -> 100\\n        *   5 -> 101\\n        *   8 -> 1000\\n        *   if we do bitwise AND with different num, it will give us stricly decreasing number\\n        *   so we need to find the same element  which is equal to max_elem\\n        */\\n        for (int i=0;i<n;i++){\\n            max_elem = Math.max(max_elem,nums[i]);\\n        }\\n        \\n        int len_cnt = 1;\\n        int max_len = 1;\\n        for (int i=1;i<n;i++){\\n            // if the numbers are same and number is equal to max\\n            if (max_elem == nums[i] && nums[i] == nums[i-1])  len_cnt++;\\n            else len_cnt = 1;\\n            \\n            \\n            max_len = Math.max(max_len,len_cnt);\\n            \\n        }\\n        \\n        return max_len;\\n    }\\n```\\n\\nIf you liked the code, Please Please Please Upvote the code\\n\\nThanks!!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int longestSubarray(int[] nums) {\\n        int n = nums.length;\\n        int max_elem = 0;\\n        //we have to find the maximum Bitwise AND\\n        // first we will find the maximum number in the array because max number has maximum bitwise AND\\n        /*\\n        *   4 -> 100\\n        *   5 -> 101\\n        *   8 -> 1000\\n        *   if we do bitwise AND with different num, it will give us stricly decreasing number\\n        *   so we need to find the same element  which is equal to max_elem\\n        */\\n        for (int i=0;i<n;i++){\\n            max_elem = Math.max(max_elem,nums[i]);\\n        }\\n        \\n        int len_cnt = 1;\\n        int max_len = 1;\\n        for (int i=1;i<n;i++){\\n            // if the numbers are same and number is equal to max\\n            if (max_elem == nums[i] && nums[i] == nums[i-1])  len_cnt++;\\n            else len_cnt = 1;\\n            \\n            \\n            max_len = Math.max(max_len,len_cnt);\\n            \\n        }\\n        \\n        return max_len;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621084,
                "title": "clean-c-solution",
                "content": "\\nThe maximum AND of subarrray would be the maximum element in the array.\\n\\n**Logic:**\\n\\n* Find the maximum element in array.\\n* Find the length of longest subarray which contains only the maximum element.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int mx = *max_element(nums.begin(), nums.end());\\n        int ans = 0, cnt = 0;\\n        for(auto num : nums)\\n        {\\n            if(num == mx)\\n                cnt += 1;\\n            else\\n                cnt = 0;\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int mx = *max_element(nums.begin(), nums.end());\\n        int ans = 0, cnt = 0;\\n        for(auto num : nums)\\n        {\\n            if(num == mx)\\n                cnt += 1;\\n            else\\n                cnt = 0;\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621037,
                "title": "clean-easy-100-faster-code-intuition-steps-explained",
                "content": "**Intuition :**\\nLets take an array [ 12, 50, 45, 20, 64, 15]\\n\\nNow lets take AND of `all` elements\\nNumber | Binary | \\n--- | --- | \\n12  |           1 1 0 0\\n50  |     1 1 0 0 1 0\\n45  |     1 0 1 1 0 1\\n20  |        1 0 1 0 0\\n64  |  1 0 0 0 0 0 0\\n15  |           1 1 1 1\\nAND of all |\\t\\t1 0 0 0 0 0 0\\n\\nTry rearranging them, you will still get max AND as the largest element.\\n*No matter what subarray you make, everytime the `largest element` will be the max AND of `all` subarrays.*\\n\\n**Steps:** \\n* Find the max element\\n* Find the maximum length of subarray with all elements == `max`\\n\\n```java\\nclass Solution {\\n    public int longestSubarray(int[] arr) {\\n        int max = arr[0];\\n        for (int n : arr) {\\n            max = Math.max(n, max);\\n        }\\n        \\n        int ans = 0;\\n        int len = 0;\\n        for (int n : arr) {\\n            if (n == max) {\\n                len++;\\n                ans = Math.max(ans, len);\\n            }\\n            else {\\n                len = 0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n*Time Complexity* : `O(N)`\\n*Space Complexity* : `O(1)`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestSubarray(int[] arr) {\\n        int max = arr[0];\\n        for (int n : arr) {\\n            max = Math.max(n, max);\\n        }\\n        \\n        int ans = 0;\\n        int len = 0;\\n        for (int n : arr) {\\n            if (n == max) {\\n                len++;\\n                ans = Math.max(ans, len);\\n            }\\n            else {\\n                len = 0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621006,
                "title": "c-easy-understanding-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int maxElem = 0;\\n        int ans = 1;\\n        for(int i:nums) maxElem=max(i, maxElem);\\n        \\n        int lctemp=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==maxElem){\\n                lctemp+=1;\\n                ans=max(ans,lctemp);\\n            }\\n            else lctemp=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int maxElem = 0;\\n        int ans = 1;\\n        for(int i:nums) maxElem=max(i, maxElem);\\n        \\n        int lctemp=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==maxElem){\\n                lctemp+=1;\\n                ans=max(ans,lctemp);\\n            }\\n            else lctemp=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620947,
                "title": "longest-subarray-with-max-bitwise-and",
                "content": "AND of a greater value is always higher.\\nExample :  4 & 4 = 4\\nwhereas,   4 & 3 = 0\\nTaking lower values will always decrease the AND value.\\nSo , We need to find the longest subarray of consecutive MAX value.\\n\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        //1. find the maximum value\\n        int n = nums.length;\\n        int maxEle = 0;\\n        for(int e : nums){\\n            maxEle = Math.max(maxEle , e);\\n        }\\n        \\n        //2. finding longest subarray containing max element\\n        int ans = 1;\\n        for(int i=0; i<n ; i++){\\n            if(nums[i] == maxEle){\\n                int cnt = 1;\\n                while(i+1<n && nums[i+1]==maxEle){\\n                    cnt++;\\n                    i++;\\n                }\\n                ans = Math.max(ans, cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        //1. find the maximum value\\n        int n = nums.length;\\n        int maxEle = 0;\\n        for(int e : nums){\\n            maxEle = Math.max(maxEle , e);\\n        }\\n        \\n        //2. finding longest subarray containing max element\\n        int ans = 1;\\n        for(int i=0; i<n ; i++){\\n            if(nums[i] == maxEle){\\n                int cnt = 1;\\n                while(i+1<n && nums[i+1]==maxEle){\\n                    cnt++;\\n                    i++;\\n                }\\n                ans = Math.max(ans, cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620928,
                "title": "c-simple-iterative-approach-o-n-time-l",
                "content": "Here in this solution , there is a simple observation that **largest element** in the array will have the maximum bitwise **AND** ;\\nand ,we have to return number of **subarray** that have maximum BItwise AND ;\\n\\n\\t\\tint h = -1;\\n        int cnt =0;\\n        int maxi = 0;\\n\\t\\t\\n\\t\\t// for maxi element into the array  and here h will hold the lagest element of array\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]>h) h= nums[i];\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == h) cnt++;\\n            else \\n                maxi = max(maxi,cnt); cnt = 0;\\n        }\\n        maxi = max(maxi,cnt);\\n        return maxi;\\n\\t\\t\\n\\t\\t\\n**upvote if you find helpful this approach** \\n\\n**this was asked in 25/09 sunday contest**\\n\\n**upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "Here in this solution , there is a simple observation that **largest element** in the array will have the maximum bitwise **AND** ;\\nand ,we have to return number of **subarray** that have maximum BItwise AND ;\\n\\n\\t\\tint h = -1;\\n        int cnt =0;\\n        int maxi = 0;\\n\\t\\t\\n\\t\\t// for maxi element into the array  and here h will hold the lagest element of array\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]>h) h= nums[i];\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == h) cnt++;\\n            else \\n                maxi = max(maxi,cnt); cnt = 0;\\n        }\\n        maxi = max(maxi,cnt);\\n        return maxi;\\n\\t\\t\\n\\t\\t\\n**upvote if you find helpful this approach** \\n\\n**this was asked in 25/09 sunday contest**\\n\\n**upvote**",
                "codeTag": "Unknown"
            },
            {
                "id": 2620880,
                "title": "java-solution",
                "content": "The problem is asking for the maximum bitwise AND subarray and that can be achieved with the maximum number in the array as bitwise AND will either decrease or remains same but it will never be greater than the given number so we are just finding the occurrences of maximum number which are conitguous.\\n\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) \\n    {\\n        int i,and=0,count=0,maxi=0;\\n        \\n        for(i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]>and)\\n                and = nums[i];\\n        }\\n        \\n        \\n        for(i=0;i<nums.length;i++)\\n        {\\n            if(nums[i] == and)\\n            {\\n                count++;\\n                maxi = Math.max(maxi,count);   \\n            }\\n            else\\n                count=0;\\n        }\\n        \\n        return maxi;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) \\n    {\\n        int i,and=0,count=0,maxi=0;\\n        \\n        for(i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]>and)\\n                and = nums[i];\\n        }\\n        \\n        \\n        for(i=0;i<nums.length;i++)\\n        {\\n            if(nums[i] == and)\\n            {\\n                count++;\\n                maxi = Math.max(maxi,count);   \\n            }\\n            else\\n                count=0;\\n        }\\n        \\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620870,
                "title": "longest-subarray-with-maximum-bitwise-and-solution-with-comment",
                "content": "The largest subarray containing the maximum element of the array , maximum number of times is the answer \\nDp approach O(n) time complexity\\n1. find the maximum element of the array \\n2. create vector index push the index of appearance \\n3. In the indexes find the longest consecutive increasing subsequence \\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxelement = 0;\\n        //get the maximum element \\n        for(int i = 0; i < nums.size(); i++) {\\n            maxelement = max(maxelement,nums[i]);\\n        }\\n        //creating vector of index of maximum element\\n        vector<int> index;\\n        for(int i =0 ; i < nums.size();i++) {\\n            if(nums[i] == maxelement) {\\n                index.push_back(i);\\n            }\\n        }\\n        //find the size of longest consecutive increasing subsequence in the index\\n        int ans  =0;\\n        int size = index.size();\\n        vector<int> dp(size,0);\\n        for(int i =1 ;i < index.size();i++){\\n            if(index[i] - index[i-1] == 1) {\\n                dp[i] = dp[i-1] + 1;\\n                ans = max(ans,dp[i]);\\n            }\\n        }\\n        \\n        return ans+1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxelement = 0;\\n        //get the maximum element \\n        for(int i = 0; i < nums.size(); i++) {\\n            maxelement = max(maxelement,nums[i]);\\n        }\\n        //creating vector of index of maximum element\\n        vector<int> index;\\n        for(int i =0 ; i < nums.size();i++) {\\n            if(nums[i] == maxelement) {\\n                index.push_back(i);\\n            }\\n        }\\n        //find the size of longest consecutive increasing subsequence in the index\\n        int ans  =0;\\n        int size = index.size();\\n        vector<int> dp(size,0);\\n        for(int i =1 ;i < index.size();i++){\\n            if(index[i] - index[i-1] == 1) {\\n                dp[i] = dp[i-1] + 1;\\n                ans = max(ans,dp[i]);\\n            }\\n        }\\n        \\n        return ans+1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620859,
                "title": "hindi-video-editorial-intuition-explained",
                "content": "Please refer video to understand intuition of solution: https://youtu.be/uyEz3Qi_TK4\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n      int n = nums.size(), mx = -1;\\n      for (int i = 0; i < n; ++i) mx = max(nums[i], mx);\\n      \\n      int count = 0, ans = 0;\\n      for (int i = 0; i < n; ++i) {\\n        if (nums[i] == mx) ++count;\\n        else count = 0;\\n        ans = max(ans, count);\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n      int n = nums.size(), mx = -1;\\n      for (int i = 0; i < n; ++i) mx = max(nums[i], mx);\\n      \\n      int count = 0, ans = 0;\\n      for (int i = 0; i < n; ++i) {\\n        if (nums[i] == mx) ++count;\\n        else count = 0;\\n        ans = max(ans, count);\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620795,
                "title": "java-simple-solution",
                "content": "Get the highest number in the array.\\nOf that highest number find the longest subarray length\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(maxi<nums[i])\\n            {\\n                maxi=nums[i];\\n            }\\n        }\\n      int len =0,curr=0;\\n        for(int num:nums)\\n        {\\n            if(num==maxi)\\n            {\\n                curr++;\\n            }\\n            else{\\n                len=Math.max(len,curr);\\n                curr=0;\\n            }\\n        }\\n        len=Math.max(curr,len);\\n        return len;\\n       }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(maxi<nums[i])\\n            {\\n                maxi=nums[i];\\n            }\\n        }\\n      int len =0,curr=0;\\n        for(int num:nums)\\n        {\\n            if(num==maxi)\\n            {\\n                curr++;\\n            }\\n            else{\\n                len=Math.max(len,curr);\\n                curr=0;\\n            }\\n        }\\n        len=Math.max(curr,len);\\n        return len;\\n       }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620760,
                "title": "c-easy-understanding-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int findmax(vector<int> &nums){\\n        \\n        int maxi = INT_MIN;\\n        for(auto i:nums) maxi = max(maxi, i);\\n        return maxi;\\n        \\n    }\\n    \\n    int longestSubarray(vector<int>& nums) {\\n        \\n        int maxi = findmax(nums);\\n        \\n        int cur_count=0;\\n        int max_count = 0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            \\n            if(nums[i]==nums[i+1] && nums[i]==maxi){\\n                cur_count++;\\n            }\\n            else{\\n                cur_count = 0;\\n            }\\n            max_count = max(max_count, cur_count);\\n\\n        }\\n        return max_count+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findmax(vector<int> &nums){\\n        \\n        int maxi = INT_MIN;\\n        for(auto i:nums) maxi = max(maxi, i);\\n        return maxi;\\n        \\n    }\\n    \\n    int longestSubarray(vector<int>& nums) {\\n        \\n        int maxi = findmax(nums);\\n        \\n        int cur_count=0;\\n        int max_count = 0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            \\n            if(nums[i]==nums[i+1] && nums[i]==maxi){\\n                cur_count++;\\n            }\\n            else{\\n                cur_count = 0;\\n            }\\n            max_count = max(max_count, cur_count);\\n\\n        }\\n        return max_count+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620722,
                "title": "simple-c-well-explained-let-s-boil-down-logic",
                "content": "\\n       int longestSubarray(vector<int>& nums) {\\n        int max_val=-1;\\n        for(int i=0;i<nums.size();i++){\\n            max_val=max(nums[i], max_val);\\n        }\\n        int curr_count=0;\\n        int max_count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==max_val)\\n                curr_count+=1;\\n            else\\n                curr_count=0;\\n            max_count=max(max_count, curr_count);\\n        }\\n        return max_count;\\n    }\\n\\t***/\\n\\t\\n\\t\\n\\tFirstly, understand that the maximum bitwise AND should be equal to to the maximum number of array. Let us see how \\n[1,2,3,4,56,7,8,6,4,3]\\nthe bitwise AND of the maximum number of array with any other number can never be greater than 56 beacause in all other numbers since they are smaller than or equal to 56 some bit which in on(1) in 56 will be off (0). \\nand 0&1 we know is equal =0\\nso we understand that the subarray with maximum bitwise AND would be a subaray with all values 56 or all values equal to the greatest element of array \\n=> we need to find the subarray with all values = the maximum element \\n\\t",
                "solutionTags": [],
                "code": "\\n       int longestSubarray(vector<int>& nums) {\\n        int max_val=-1;\\n        for(int i=0;i<nums.size();i++){\\n            max_val=max(nums[i], max_val);\\n        }\\n        int curr_count=0;\\n        int max_count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==max_val)\\n                curr_count+=1;\\n            else\\n                curr_count=0;\\n            max_count=max(max_count, curr_count);\\n        }\\n        return max_count;\\n    }\\n\\t***/\\n\\t\\n\\t\\n\\tFirstly, understand that the maximum bitwise AND should be equal to to the maximum number of array. Let us see how \\n[1,2,3,4,56,7,8,6,4,3]\\nthe bitwise AND of the maximum number of array with any other number can never be greater than 56 beacause in all other numbers since they are smaller than or equal to 56 some bit which in on(1) in 56 will be off (0). \\nand 0&1 we know is equal =0\\nso we understand that the subarray with maximum bitwise AND would be a subaray with all values 56 or all values equal to the greatest element of array \\n=> we need to find the subarray with all values = the maximum element \\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2620718,
                "title": "simply-count-maximum-element-clean-c-solution",
                "content": "**Approach:** We just need to count the maximum continuos frequency of the maximum element present in the array.\\n```\\nint longestSubarray(vector<int>& nums) {\\n        int mx = 0, res = 0, cnt = 0;\\n        \\n        for(int num:nums)\\n            mx = max(num, mx);\\n        \\n        for(int num:nums){\\n            if(num == mx) cnt++;\\n            else cnt = 0;\\n            res = max(res, cnt);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint longestSubarray(vector<int>& nums) {\\n        int mx = 0, res = 0, cnt = 0;\\n        \\n        for(int num:nums)\\n            mx = max(num, mx);\\n        \\n        for(int num:nums){\\n            if(num == mx) cnt++;\\n            else cnt = 0;\\n            res = max(res, cnt);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620710,
                "title": "maximum-window-of-max-element-sliding-window-java",
                "content": "It is actually a problem to find maximum window size for a maximum element of the array because :\\nwhen you and any element of the array the maximum and will always be the one that has maximum integer value \\nsuppose arr=[1,2,3,4,5] here max bitwise and will be 5 because max value is 5 \\nsimilarly for arr=[1,2,2,2,2,1]\\nmax and=2 but since 2 is occuring 4 times so length of subarray with and value 2 will be = 4 \\n\\nHere is the code \\n```\\n        int i=0;\\n        int j=0;\\n        int sz=1;\\n        int ans=0;\\n        int nd=nums[0];\\n        int mxi=-1;\\n        for(int k=0;k<nums.length;k++){\\n            mxi=Math.max(mxi,nums[k]);\\n        }\\n        while(j<nums.length){\\n            if(nums[j]!=mxi){\\n                i=j;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                sz=Math.max(sz,j-i+1);\\n                j++;\\n            }\\n        \\n        }\\n        return sz;",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "It is actually a problem to find maximum window size for a maximum element of the array because :\\nwhen you and any element of the array the maximum and will always be the one that has maximum integer value \\nsuppose arr=[1,2,3,4,5] here max bitwise and will be 5 because max value is 5 \\nsimilarly for arr=[1,2,2,2,2,1]\\nmax and=2 but since 2 is occuring 4 times so length of subarray with and value 2 will be = 4 \\n\\nHere is the code \\n```\\n        int i=0;\\n        int j=0;\\n        int sz=1;\\n        int ans=0;\\n        int nd=nums[0];\\n        int mxi=-1;\\n        for(int k=0;k<nums.length;k++){\\n            mxi=Math.max(mxi,nums[k]);\\n        }\\n        while(j<nums.length){\\n            if(nums[j]!=mxi){\\n                i=j;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                sz=Math.max(sz,j-i+1);\\n                j++;\\n            }\\n        \\n        }\\n        return sz;",
                "codeTag": "Unknown"
            },
            {
                "id": 2620606,
                "title": "python-easy-solution",
                "content": "```\\n    def longestSubarray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        maxV = max(nums)\\n        cnt = 0\\n        res = 0\\n        for n in nums + [-1]:\\n            if n == maxV:\\n                cnt += 1\\n            else:\\n                res = max(res, cnt)\\n                cnt = 0\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def longestSubarray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        maxV = max(nums)\\n        cnt = 0\\n        res = 0\\n        for n in nums + [-1]:\\n            if n == maxV:\\n                cnt += 1\\n            else:\\n                res = max(res, cnt)\\n                cnt = 0\\n        return res\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2620581,
                "title": "c-easy-solution",
                "content": "```\\n  int longestSubarray(vector<int>& nums) {\\n       int maxi=*max_element(begin(nums),end(nums));\\n        int len=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==maxi){\\n                int temp=1;\\n                while(i+1<nums.size() and nums[i+1]==maxi){\\n                    temp++;\\n                    len=max(temp,len);\\n                    i++;\\n                }\\n            }\\n        }\\n        return len;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  int longestSubarray(vector<int>& nums) {\\n       int maxi=*max_element(begin(nums),end(nums));\\n        int len=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==maxi){\\n                int temp=1;\\n                while(i+1<nums.size() and nums[i+1]==maxi){\\n                    temp++;\\n                    len=max(temp,len);\\n                    i++;\\n                }\\n            }\\n        }\\n        return len;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620545,
                "title": "c-solution-in-6-lines",
                "content": "**Approach :** I am just finding max_element and after that looking for maximum consecutive subarray with max_value of array. AND of two number nums will decrease the numbers so the maximum and can be the subarray with max_value of array\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums,int len = 0,int ans = 0) {\\n        int res = *max_element(nums.begin(),nums.end());\\n        for(auto ele:nums){\\n            len = ele==res?(len+1):0;\\n            ans = max(ans,len);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums,int len = 0,int ans = 0) {\\n        int res = *max_element(nums.begin(),nums.end());\\n        for(auto ele:nums){\\n            len = ele==res?(len+1):0;\\n            ans = max(ans,len);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620517,
                "title": "python-c-o-n-detailed-explanation",
                "content": "1. We can notice that maximum value of the bitwise AND will be **the maximum number in the array**.\\n\\n\\tTake for example `5`  and `13`. If we try to do `5 & 13`, we will set all the bits to `0` except for those bits, which are equal to `1` in both numbers. So we cannot increase the current number by doing AND with another number. The best we can do is to use AND on the same numbers - in this case  the number will remain the same. So just pick the maximum value of the array.\\n\\n\\t```\\n\\t1. Case with two different numbers. The higher number (1100) will decrease\\n\\t0101\\n\\t1101\\n\\t_____\\n\\t0101\\n\\n\\t2. Best case - the same numbers. The number will remain the same\\n\\t1100\\n\\t1100\\n\\t_____\\n\\t1100\\n\\t```\\n\\n2. Therefore, problem changes to **finding the longest subarray of consecutive numbers (equal to the maximum value of the array)**.\\n\\n\\t**Python**\\n\\n\\t```\\n\\tclass Solution:\\n\\t\\tdef longestSubarray(self, nums: List[int]) -> int:\\n\\t\\t\\tmaxVal = max(nums)\\n\\t\\t\\tres, i, j, n = 0, 0, 0, len(nums)\\n\\n\\t\\t\\twhile i < n and j < n:\\n\\t\\t\\t\\tif nums[i] == maxVal:\\n\\t\\t\\t\\t\\tj = i\\n\\t\\t\\t\\t\\twhile j < n and nums[j] == maxVal:\\n\\t\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tres = max(res, j - i)\\n\\t\\t\\t\\t\\ti = j\\n\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\treturn res\\n\\t```\\n\\t\\n\\t**C++**\\n\\t\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint longestSubarray(vector<int>& nums) {\\n\\t\\t\\tint maxVal = *max_element(nums.begin(), nums.end());\\n\\t\\t\\tint res = 0, i = 0, j = 0, n = (int) nums.size();\\n\\n\\t\\t\\twhile (i < n && j < n) {\\n\\t\\t\\t\\tif (nums[i] == maxVal) {\\n\\t\\t\\t\\t\\tj = i;\\n\\t\\t\\t\\t\\twhile (j < n && nums[j] == maxVal) {\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tres = max(res, j - i);\\n\\t\\t\\t\\t\\ti = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\t1. Case with two different numbers. The higher number (1100) will decrease\\n\\t0101\\n\\t1101\\n\\t_____\\n\\t0101\\n\\n\\t2. Best case - the same numbers. The number will remain the same\\n\\t1100\\n\\t1100\\n\\t_____\\n\\t1100\\n\\t```\n```\\n\\tclass Solution:\\n\\t\\tdef longestSubarray(self, nums: List[int]) -> int:\\n\\t\\t\\tmaxVal = max(nums)\\n\\t\\t\\tres, i, j, n = 0, 0, 0, len(nums)\\n\\n\\t\\t\\twhile i < n and j < n:\\n\\t\\t\\t\\tif nums[i] == maxVal:\\n\\t\\t\\t\\t\\tj = i\\n\\t\\t\\t\\t\\twhile j < n and nums[j] == maxVal:\\n\\t\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tres = max(res, j - i)\\n\\t\\t\\t\\t\\ti = j\\n\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\treturn res\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint longestSubarray(vector<int>& nums) {\\n\\t\\t\\tint maxVal = *max_element(nums.begin(), nums.end());\\n\\t\\t\\tint res = 0, i = 0, j = 0, n = (int) nums.size();\\n\\n\\t\\t\\twhile (i < n && j < n) {\\n\\t\\t\\t\\tif (nums[i] == maxVal) {\\n\\t\\t\\t\\t\\tj = i;\\n\\t\\t\\t\\t\\twhile (j < n && nums[j] == maxVal) {\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tres = max(res, j - i);\\n\\t\\t\\t\\t\\ti = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2620493,
                "title": "bitwise-and-easy-soluntion",
                "content": "\\t**The Idea is very simple if we take the and of two numbers then the result will be decreased if numbers are different otherwise will be same as number if both the numbers are equal.**\\n\\t\\n\\tSo, the our result will contain the maximum number in the array and we have to calculate the longest subarray with all elements equals to the maximum element\\n\\t\\n\\t`class Solution {\\n\\tpublic:\\n\\t\\tint longestSubarray(vector<int>& nums) {\\n\\t\\t\\tint ma = *max_element(nums.begin(), nums.end());\\n\\t\\t\\tint  Max_len = 0;\\n\\t\\t\\tint cnt = 0;\\n\\t\\t\\tfor(int num : nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(num == ma){\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tMax_len = max(cnt, Max_len);\\n\\t\\t\\t\\t\\tcnt = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tMax_len = max(cnt, Max_len);\\n\\t\\t\\treturn Max_len;\\n\\t\\t}\\n};`",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint longestSubarray(vector<int>& nums) {\\n\\t\\t\\tint ma = *max_element(nums.begin(), nums.end());\\n\\t\\t\\tint  Max_len = 0;\\n\\t\\t\\tint cnt = 0;\\n\\t\\t\\tfor(int num : nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(num == ma){\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4076957,
                "title": "easy-simple-solution-using-only-counting",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int maxVal = INT_MIN;\\n        for( auto x : nums) maxVal = max( maxVal, x);\\n\\n        int ct =0, ans =0;\\n        for( auto x : nums){\\n\\n            if( x==maxVal)\\n            {\\n                ct++;\\n                ans= max( ct, ans );\\n            }\\n            else \\n            {\\n                ct=0;\\n            }\\n        }\\n\\n\\n        return ans ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int maxVal = INT_MIN;\\n        for( auto x : nums) maxVal = max( maxVal, x);\\n\\n        int ct =0, ans =0;\\n        for( auto x : nums){\\n\\n            if( x==maxVal)\\n            {\\n                ct++;\\n                ans= max( ct, ans );\\n            }\\n            else \\n            {\\n                ct=0;\\n            }\\n        }\\n\\n\\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978342,
                "title": "simple-python-sol-finding-max",
                "content": "# Intuition\\nbasically find max number of consequent occurence of max element\\n\\n# Approach\\nmax bitand is the max number\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)\\n\\n- Space complexity:\\n$$O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSubarray(self, A: List[int]) -> int:\\n        m= max(A)\\n\\n        res=[]\\n        c=0\\n        for i in range(0, len(A)):\\n            if A[i]==m:\\n                c=c+1\\n            else:\\n                res.append(c)\\n                c=0\\n        res.append(c)\\n        return max(res)\\n\\n\\n\\n        # from functools import reduce\\n        # from collections import defaultdict\\n        # d= defaultdict(set)\\n        # for i in range(0, len(A)+1):\\n        #     for j in range(i+1, len(A)+1):\\n        #         res = reduce(lambda x, y: x & y, A[i:j])\\n        #         d[res].add(len(A[i:j]))\\n        # ds= sorted(d.items(), key= lambda x : x[0])\\n        # l= list(ds[-1][1])\\n        # l.sort()\\n        # return (l[-1])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, A: List[int]) -> int:\\n        m= max(A)\\n\\n        res=[]\\n        c=0\\n        for i in range(0, len(A)):\\n            if A[i]==m:\\n                c=c+1\\n            else:\\n                res.append(c)\\n                c=0\\n        res.append(c)\\n        return max(res)\\n\\n\\n\\n        # from functools import reduce\\n        # from collections import defaultdict\\n        # d= defaultdict(set)\\n        # for i in range(0, len(A)+1):\\n        #     for j in range(i+1, len(A)+1):\\n        #         res = reduce(lambda x, y: x & y, A[i:j])\\n        #         d[res].add(len(A[i:j]))\\n        # ds= sorted(d.items(), key= lambda x : x[0])\\n        # l= list(ds[-1][1])\\n        # l.sort()\\n        # return (l[-1])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961125,
                "title": "find-maximum-element-and-search-subarray-with-maximum-of-this-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) \\n    {\\n        int maxi=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=max(maxi,nums[i]);\\n            }\\n        }\\n        int j=0,l=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==maxi)\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                j=0;\\n            }\\n            l=max(j,l);\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) \\n    {\\n        int maxi=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=max(maxi,nums[i]);\\n            }\\n        }\\n        int j=0,l=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==maxi)\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                j=0;\\n            }\\n            l=max(j,l);\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892832,
                "title": "golang-simple-solution-find-longest-subarray-of-max-values",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nfunc longestSubarray(nums []int) int {\\n  var max int\\n  // The max bitwise AND of a subarray is going to be the maximum value\\n  // in the array. We can only get a sub array of length > 1 if all values in the\\n  // subarray equals the max value. All we need to do is to find the longest\\n  // subarray of max values\\n  for i := 0; i < len(nums); i++ {\\n    if nums[i] > max {\\n      max = nums[i]\\n    }\\n  }\\n  res := 1\\n  i := 0\\n  for i < len(nums) {\\n    for i < len(nums) && nums[i] != max {\\n      i++\\n    }\\n    var count int\\n    for i < len(nums) && nums[i] == max {\\n      count++\\n      i++\\n    }\\n    if count > res {\\n      res = count\\n    }\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestSubarray(nums []int) int {\\n  var max int\\n  // The max bitwise AND of a subarray is going to be the maximum value\\n  // in the array. We can only get a sub array of length > 1 if all values in the\\n  // subarray equals the max value. All we need to do is to find the longest\\n  // subarray of max values\\n  for i := 0; i < len(nums); i++ {\\n    if nums[i] > max {\\n      max = nums[i]\\n    }\\n  }\\n  res := 1\\n  i := 0\\n  for i < len(nums) {\\n    for i < len(nums) && nums[i] != max {\\n      i++\\n    }\\n    var count int\\n    for i < len(nums) && nums[i] == max {\\n      count++\\n      i++\\n    }\\n    if count > res {\\n      res = count\\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879986,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int maxi=*max_element(nums.begin(),nums.end());\\n        int res=INT_MIN;\\n        int maximum=0;\\n        for(int i=0; i<nums.size();i++){\\n            if (nums[i] == maxi){\\n                maximum++;\\n                res=max(res,maximum);\\n            }\\n            else{\\n                maximum=0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int maxi=*max_element(nums.begin(),nums.end());\\n        int res=INT_MIN;\\n        int maximum=0;\\n        for(int i=0; i<nums.size();i++){\\n            if (nums[i] == maxi){\\n                maximum++;\\n                res=max(res,maximum);\\n            }\\n            else{\\n                maximum=0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874039,
                "title": "beats-100-00-of-users-with-dart-direct-approach-using-java-and-dart",
                "content": "\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int count = 0, max = 0,ans = 0;\\n        for(int i =0;i<nums.length;i++)\\n            if(max<nums[i])\\n                max = nums[i];\\n        for(int i =1;i<nums.length;i++){\\n            if(max==nums[i] && nums[i-1]==nums[i])\\n                count++;\\n            else{\\n                if(ans<count)\\n                    ans=count;\\n                count= 0;\\n            }\\n        }\\n        if(ans<count)\\n            ans = count;\\n        return ans+1;\\n    }\\n}\\n```\\n\\n# Dart Code\\n```class Solution {\\n  int longestSubarray(List<int> nums) {\\n      int count = 0, max = 0,ans = 0;\\n        for(int i =0;i<nums.length;i++)\\n            if(max<nums[i])\\n                max = nums[i];\\n        for(int i =1;i<nums.length;i++){\\n            if(max==nums[i] && nums[i-1]==nums[i])\\n                count++;\\n            else{\\n                if(ans<count)\\n                    ans=count;\\n                count= 0;\\n            }\\n        }\\n        if(ans<count)\\n            ans = count;\\n        return ans+1;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dart",
                    "Array",
                    "Bit Manipulation",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int count = 0, max = 0,ans = 0;\\n        for(int i =0;i<nums.length;i++)\\n            if(max<nums[i])\\n                max = nums[i];\\n        for(int i =1;i<nums.length;i++){\\n            if(max==nums[i] && nums[i-1]==nums[i])\\n                count++;\\n            else{\\n                if(ans<count)\\n                    ans=count;\\n                count= 0;\\n            }\\n        }\\n        if(ans<count)\\n            ans = count;\\n        return ans+1;\\n    }\\n}\\n```\n```class Solution {\\n  int longestSubarray(List<int> nums) {\\n      int count = 0, max = 0,ans = 0;\\n        for(int i =0;i<nums.length;i++)\\n            if(max<nums[i])\\n                max = nums[i];\\n        for(int i =1;i<nums.length;i++){\\n            if(max==nums[i] && nums[i-1]==nums[i])\\n                count++;\\n            else{\\n                if(ans<count)\\n                    ans=count;\\n                count= 0;\\n            }\\n        }\\n        if(ans<count)\\n            ans = count;\\n        return ans+1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842786,
                "title": "c-easy-max-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) \\n    {\\n        int maxi =*max_element(nums.begin(), nums.end());  \\n        int maximum = 0;\\n        int cnt = 0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i] == maxi)\\n            {\\n                cnt++;\\n                maximum = max(cnt, maximum);\\n            }\\n            else cnt = 0;\\n        }     \\n        return maximum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) \\n    {\\n        int maxi =*max_element(nums.begin(), nums.end());  \\n        int maximum = 0;\\n        int cnt = 0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i] == maxi)\\n            {\\n                cnt++;\\n                maximum = max(cnt, maximum);\\n            }\\n            else cnt = 0;\\n        }     \\n        return maximum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812062,
                "title": "my-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint longestSubarray(int* nums, int numsSize){\\n    int k = 1;\\n    int ret = 0;\\n    int curr = 0;\\n    for(int i = 0;i<numsSize;i++){\\n        if(nums[i] == k){\\n            curr++;\\n            ret = ret > curr? ret : curr;\\n        }\\n        else if(nums[i] > k ){\\n            k=nums[i];\\n            curr = 1;\\n            ret = 1;\\n        }\\n        else{\\n            curr = 0;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint longestSubarray(int* nums, int numsSize){\\n    int k = 1;\\n    int ret = 0;\\n    int curr = 0;\\n    for(int i = 0;i<numsSize;i++){\\n        if(nums[i] == k){\\n            curr++;\\n            ret = ret > curr? ret : curr;\\n        }\\n        else if(nums[i] > k ){\\n            k=nums[i];\\n            curr = 1;\\n            ret = 1;\\n        }\\n        else{\\n            curr = 0;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3798436,
                "title": "2419-longest-subarray-with-maximum-bitwise-and",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*\\n    - Observe that, largest element of array is the largest possible bitwise\\n      AND value that can be achieved\\n    - For a subarray to have this as bitwise AND value, it must contain\\n      consecutive occurrences of the largest element of the array\\n    - So the problem is converted into finding length of the longest \\n      consecutive occurence of the largest element in the array\\n*/\\n\\n\\n    int longestSubarray(vector<int>& nums) {\\n\\n        int maxAnd = *max_element(nums.begin(), nums.end());\\n\\n        int len = 0;\\n        int res = 1;\\n\\n        int n = nums.size();\\n\\n        int i = 0;\\n        while(i < n){\\n\\n            len = 0;\\n            while(i < n && nums[i] == maxAnd){\\n\\n                res = max(res, ++len);\\n                i++;\\n            }\\n            i++;\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*\\n    - Observe that, largest element of array is the largest possible bitwise\\n      AND value that can be achieved\\n    - For a subarray to have this as bitwise AND value, it must contain\\n      consecutive occurrences of the largest element of the array\\n    - So the problem is converted into finding length of the longest \\n      consecutive occurence of the largest element in the array\\n*/\\n\\n\\n    int longestSubarray(vector<int>& nums) {\\n\\n        int maxAnd = *max_element(nums.begin(), nums.end());\\n\\n        int len = 0;\\n        int res = 1;\\n\\n        int n = nums.size();\\n\\n        int i = 0;\\n        while(i < n){\\n\\n            len = 0;\\n            while(i < n && nums[i] == maxAnd){\\n\\n                res = max(res, ++len);\\n                i++;\\n            }\\n            i++;\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734121,
                "title": "memey-question-find-the-longest-subarray-with-max-element-of-the-array",
                "content": "class Solution(object):\\n    def longestSubarray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        max_num = max(nums)\\n        \\n        count = 0\\n        res = 0\\n        \\n        for n in nums:\\n            if n == max_num:\\n                count += 1\\n                res = max(count, res)\\n            else:\\n                count = 0\\n            \\n        \\n        \\n        return max(res, count)",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution(object):\\n    def longestSubarray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        max_num = max(nums)\\n        \\n        count = 0\\n        res = 0\\n        \\n        for n in nums:\\n            if n == max_num:\\n                count += 1\\n                res = max(count, res)\\n            else:\\n                count = 0\\n            \\n        \\n        \\n        return max(res, count)",
                "codeTag": "Java"
            },
            {
                "id": 3683843,
                "title": "o-n-time-c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int i = 0, j = 0;\\n        int n = nums.size();\\n        int ans = 1;\\n        int maxAnd = nums[0];\\n        while(j < n) {\\n            int currAnd = nums[j];\\n            j++;\\n            while(j < n && (nums[j] <= currAnd) && (nums[j] & currAnd) >= currAnd) {\\n                currAnd &= nums[j];\\n                j++;\\n            }\\n            if(currAnd > maxAnd) {\\n                maxAnd = currAnd;\\n                ans = j - i;\\n            } else if(currAnd == maxAnd) {\\n                ans = max(ans, j - i);\\n            }\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int i = 0, j = 0;\\n        int n = nums.size();\\n        int ans = 1;\\n        int maxAnd = nums[0];\\n        while(j < n) {\\n            int currAnd = nums[j];\\n            j++;\\n            while(j < n && (nums[j] <= currAnd) && (nums[j] & currAnd) >= currAnd) {\\n                currAnd &= nums[j];\\n                j++;\\n            }\\n            if(currAnd > maxAnd) {\\n                maxAnd = currAnd;\\n                ans = j - i;\\n            } else if(currAnd == maxAnd) {\\n                ans = max(ans, j - i);\\n            }\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637926,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int maxi=*max_element(nums.begin(),nums.end());\\n        int ans=0;\\n        int anuj=0;\\n        for(int i=0;i<nums.size();i++){\\n           if(maxi&&nums[i]==maxi){\\n\\n           ans++;\\n           }\\n           else ans=0;\\n           anuj=max(ans,anuj);\\n\\n        //  ans=max();\\n        }\\n        return anuj;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int maxi=*max_element(nums.begin(),nums.end());\\n        int ans=0;\\n        int anuj=0;\\n        for(int i=0;i<nums.size();i++){\\n           if(maxi&&nums[i]==maxi){\\n\\n           ans++;\\n           }\\n           else ans=0;\\n           anuj=max(ans,anuj);\\n\\n        //  ans=max();\\n        }\\n        return anuj;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596682,
                "title": "c-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int ans = 0, c = 0, l = *max_element(nums.begin(), nums.end());\\n        for (auto& n : nums)\\n            if (n == l) ans = max(++c, ans);\\n            else c = 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int ans = 0, c = 0, l = *max_element(nums.begin(), nums.end());\\n        for (auto& n : nums)\\n            if (n == l) ans = max(++c, ans);\\n            else c = 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565890,
                "title": "simple-python-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind maximum, and then search for longest subarray length\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        \\n        nums+=[0]\\n        subarray_max = max(nums)\\n\\n        prev = -1\\n        max_ = 0\\n        for num in nums:\\n            \\n            if prev!=subarray_max and num==subarray_max:\\n                prev = subarray_max\\n                count = 1\\n            elif prev==subarray_max and num==subarray_max:\\n                count+=1            \\n            elif prev==subarray_max and num!=subarray_max:\\n\\n                if count>max_:\\n                    max_ = count\\n                count = 0\\n\\n\\n\\n        return max_\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        \\n        nums+=[0]\\n        subarray_max = max(nums)\\n\\n        prev = -1\\n        max_ = 0\\n        for num in nums:\\n            \\n            if prev!=subarray_max and num==subarray_max:\\n                prev = subarray_max\\n                count = 1\\n            elif prev==subarray_max and num==subarray_max:\\n                count+=1            \\n            elif prev==subarray_max and num!=subarray_max:\\n\\n                if count>max_:\\n                    max_ = count\\n                count = 0\\n\\n\\n\\n        return max_\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546577,
                "title": "100-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe AND speech is a disguise, and will just produce the largest number\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the subarray of longest numbers by iterating once\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n) - we do one pass (there are faster options)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n) - 3 locals and the original array (beats 100%)\\n\\n# Code\\n```\\nint longestSubarray(int* nums, int numsSize){\\n    unsigned int max = 0;\\n    unsigned int maxCount = 0;\\n    unsigned int count = 0;\\n\\n    for (unsigned int i = 0; i < numsSize; i++) {\\n        if (nums[i] == max) {\\n            count++;\\n        } else if (nums[i] > max) {\\n            max = nums[i];\\n            count = 1;\\n            maxCount = 0;\\n        } else {\\n            count = 0;\\n        }\\n\\n        if (count > maxCount) {\\n            maxCount = count;\\n        }\\n    }\\n\\n    return maxCount;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint longestSubarray(int* nums, int numsSize){\\n    unsigned int max = 0;\\n    unsigned int maxCount = 0;\\n    unsigned int count = 0;\\n\\n    for (unsigned int i = 0; i < numsSize; i++) {\\n        if (nums[i] == max) {\\n            count++;\\n        } else if (nums[i] > max) {\\n            max = nums[i];\\n            count = 1;\\n            maxCount = 0;\\n        } else {\\n            count = 0;\\n        }\\n\\n        if (count > maxCount) {\\n            maxCount = count;\\n        }\\n    }\\n\\n    return maxCount;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530040,
                "title": "go-one-loop-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nfunc longestSubarray(nums []int) int {\\n\\tres, curVal, curCount := 1, nums[0], 1\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tif curVal > nums[i] {\\n\\t\\t\\tcurCount = 0\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif curVal == nums[i] {\\n\\t\\t\\tcurCount++\\n\\t\\t\\tres = max(res, curCount)\\n\\t\\t} else {\\n\\t\\t\\tcurVal = nums[i]\\n\\t\\t\\tcurCount = 1\\n\\t\\t\\tres = 1\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestSubarray(nums []int) int {\\n\\tres, curVal, curCount := 1, nums[0], 1\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tif curVal > nums[i] {\\n\\t\\t\\tcurCount = 0\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif curVal == nums[i] {\\n\\t\\t\\tcurCount++\\n\\t\\t\\tres = max(res, curCount)\\n\\t\\t} else {\\n\\t\\t\\tcurVal = nums[i]\\n\\t\\t\\tcurCount = 1\\n\\t\\t\\tres = 1\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3508447,
                "title": "kadane-s-alg-js-linear-time-constant-space",
                "content": "# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSubarray = function (nums) {\\n    let max = 0\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] > max) {\\n            max = nums[i]\\n        }\\n    }\\n\\n    let ans = 1\\n    let sum = nums[0]\\n    let lastInd = 0\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        sum &= nums[i]\\n\\n        if (sum === max) {\\n            ans = Math.max(ans, i - lastInd + 1)\\n        } else if (sum > max) {\\n            max = sum\\n            ans = i - lastInd + 1\\n        }\\n\\n        if (sum < nums[i]) {\\n            sum = nums[i]\\n            lastInd = i\\n        }\\n    }\\n\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSubarray = function (nums) {\\n    let max = 0\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] > max) {\\n            max = nums[i]\\n        }\\n    }\\n\\n    let ans = 1\\n    let sum = nums[0]\\n    let lastInd = 0\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        sum &= nums[i]\\n\\n        if (sum === max) {\\n            ans = Math.max(ans, i - lastInd + 1)\\n        } else if (sum > max) {\\n            max = sum\\n            ans = i - lastInd + 1\\n        }\\n\\n        if (sum < nums[i]) {\\n            sum = nums[i]\\n            lastInd = i\\n        }\\n    }\\n\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3427291,
                "title": "python-super-easy-kadane-s-algorithm-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n\\n        dp = [[1, i] for i in nums]\\n        max_or = dp[0][1]\\n        for i in range(1, len(nums)):\\n            if nums[i] & dp[i-1][1] >= dp[i][1]:\\n                dp[i][1] =  nums[i] & dp[i-1][1]\\n                dp[i][0] = 1 + dp[i-1][0]\\n            max_or = max(max_or, dp[i][1])\\n  \\n        max_count = 0\\n        for i in range(len(dp)):\\n            if dp[i][1] == max_or:\\n                max_count = max(max_count, dp[i][0])\\n        return max_count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n\\n        dp = [[1, i] for i in nums]\\n        max_or = dp[0][1]\\n        for i in range(1, len(nums)):\\n            if nums[i] & dp[i-1][1] >= dp[i][1]:\\n                dp[i][1] =  nums[i] & dp[i-1][1]\\n                dp[i][0] = 1 + dp[i-1][0]\\n            max_or = max(max_or, dp[i][1])\\n  \\n        max_count = 0\\n        for i in range(len(dp)):\\n            if dp[i][1] == max_or:\\n                max_count = max(max_count, dp[i][0])\\n        return max_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409504,
                "title": "easy-beginner-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int n=0;\\n        for(int i =0;i<nums.length;i++){\\n            n=Math.max(n,nums[i]);\\n        }\\n        int count=0;\\n        int ans=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==n){\\n                count=count+1;\\n            }\\n            else{\\n                count=0;\\n            }\\n             ans=Math.max(count,ans);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int n=0;\\n        for(int i =0;i<nums.length;i++){\\n            n=Math.max(n,nums[i]);\\n        }\\n        int count=0;\\n        int ans=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==n){\\n                count=count+1;\\n            }\\n            else{\\n                count=0;\\n            }\\n             ans=Math.max(count,ans);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381756,
                "title": "o-n-simple-c-solution-beats-97-53",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int res=0, p_count=0, cr_max=0;\\n        for(int no: nums){\\n            if(no>cr_max){\\n                cr_max=no;\\n                p_count=1;\\n                res=1;\\n            }\\n            else if(no==cr_max){\\n                p_count++;\\n            }\\n            else{\\n                res=max(res, p_count);\\n                p_count=0;\\n            }\\n        }\\n        return max(res, p_count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int res=0, p_count=0, cr_max=0;\\n        for(int no: nums){\\n            if(no>cr_max){\\n                cr_max=no;\\n                p_count=1;\\n                res=1;\\n            }\\n            else if(no==cr_max){\\n                p_count++;\\n            }\\n            else{\\n                res=max(res, p_count);\\n                p_count=0;\\n            }\\n        }\\n        return max(res, p_count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306007,
                "title": "c-very-easy-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=1;\\n        int maxi=*max_element(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            if(nums[i]==maxi){\\n                while(i<n and nums[i]==maxi) count++,i++;\\n            }\\n            ans=max(ans , count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=1;\\n        int maxi=*max_element(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            if(nums[i]==maxi){\\n                while(i<n and nums[i]==maxi) count++,i++;\\n            }\\n            ans=max(ans , count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298296,
                "title": "easy-java-solution-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        for(int num:nums){\\n            max=Math.max(max,num);\\n        }\\n        int maxlen=0;\\n        int len=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==max){\\n                len+=1;\\n                maxlen=Math.max(maxlen,len);\\n            }\\n            else{\\n                len=0;\\n            }\\n        }\\n        return maxlen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        for(int num:nums){\\n            max=Math.max(max,num);\\n        }\\n        int maxlen=0;\\n        int len=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==max){\\n                len+=1;\\n                maxlen=Math.max(maxlen,len);\\n            }\\n            else{\\n                len=0;\\n            }\\n        }\\n        return maxlen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293416,
                "title": "simple-c-solution-explained",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        // And(&) Of Two Numbers can have max value as the max number in between two numbers\\n        int maxe=*max_element(nums.begin(), nums.end());\\n        // it will always give the first index//\\n        int maxi=max_element(nums.begin(), nums.end())-nums.begin();\\n        int ans=1;\\n        int cc=1;\\n        for(int i=maxi;i<nums.size();i++){\\n            if(nums[i]==maxe) ans=max(ans, cc++);\\n            else cc=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        // And(&) Of Two Numbers can have max value as the max number in between two numbers\\n        int maxe=*max_element(nums.begin(), nums.end());\\n        // it will always give the first index//\\n        int maxi=max_element(nums.begin(), nums.end())-nums.begin();\\n        int ans=1;\\n        int cc=1;\\n        for(int i=maxi;i<nums.size();i++){\\n            if(nums[i]==maxe) ans=max(ans, cc++);\\n            else cc=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280679,
                "title": "basic-java",
                "content": "# Intuition\\nfinding maximum in subarray\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfinding maximum length using Math.max;\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int len = 0;\\n        int count =0;\\n        int max = nums[0];\\n        for(int i = 0;i<nums.length;i++){\\n            max = Math.max(max,nums[i]);\\n        }\\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]==max) count++;\\n            else count = 0;\\n            len = Math.max(len,count);\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int len = 0;\\n        int count =0;\\n        int max = nums[0];\\n        for(int i = 0;i<nums.length;i++){\\n            max = Math.max(max,nums[i]);\\n        }\\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]==max) count++;\\n            else count = 0;\\n            len = Math.max(len,count);\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269761,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestSubarray(int[] nums) {\\n\\n            int result = 0;\\n            int subArrLength = 0;            \\n            int max = nums.Max();\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (max == nums[i]){\\n                    subArrLength++;\\n                }\\n                else\\n                    subArrLength = 0;\\n                result = Math.Max(subArrLength, result);\\n            }\\n            return result;\\n    }\\n\\n    \\n\\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestSubarray(int[] nums) {\\n\\n            int result = 0;\\n            int subArrLength = 0;            \\n            int max = nums.Max();\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (max == nums[i]){\\n                    subArrLength++;\\n                }\\n                else\\n                    subArrLength = 0;\\n                result = Math.Max(subArrLength, result);\\n            }\\n            return result;\\n    }\\n\\n    \\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246090,
                "title": "c-easy-fast",
                "content": "\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int longestSubarray(vector<int>& nums) \\n    {\\n        int maxi_val=0;\\n        \\n        for(auto it:nums)\\n            maxi_val = max(maxi_val, it);\\n        \\n        int cnt=1, maxi=1;\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            if(nums[i]==maxi_val && nums[i]==nums[i+1])\\n                cnt++;          \\n            else \\n                cnt=1;\\n            \\n            maxi = max(maxi, cnt);\\n                \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int longestSubarray(vector<int>& nums) \\n    {\\n        int maxi_val=0;\\n        \\n        for(auto it:nums)\\n            maxi_val = max(maxi_val, it);\\n        \\n        int cnt=1, maxi=1;\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            if(nums[i]==maxi_val && nums[i]==nums[i+1])\\n                cnt++;          \\n            else \\n                cnt=1;\\n            \\n            maxi = max(maxi, cnt);\\n                \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211395,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) \\n    {\\n        int c=0,t=0;\\n        int m=*max_element(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==m)\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                t=max(t,c);\\n                c=0;\\n            }\\n        }\\n        return max(t,c);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) \\n    {\\n        int c=0,t=0;\\n        int m=*max_element(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==m)\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                t=max(t,c);\\n                c=0;\\n            }\\n        }\\n        return max(t,c);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168826,
                "title": "easy-0ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n       int n=nums.size();\\n        int ans=0,l=0;\\n        int m=*max_element(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==m)l++;\\n            else l=0;\\n            ans=max(ans,l);\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n       int n=nums.size();\\n        int ans=0,l=0;\\n        int m=*max_element(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==m)l++;\\n            else l=0;\\n            ans=max(ans,l);\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154658,
                "title": "o-n-c-easy-explain-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n###plzzz upvote it if it help you ;-)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n### In this problem, we just need to find the maximum value and count its maximum contiguous occurences that will be the answer\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n+n)and beats 66.25%\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int x=0;\\n        for(int i:nums){\\n            x=max(x,i);// here we find max element in array and store it on x.\\n        }\\n        int y=0,a=1;\\n        for(int i:nums){\\n            if(i==x){ // here we count the element which equal to x \\n            y++;\\n            a=max(a,y); // finding the max subarray basically we count max element which have max subarray and store it on a;\\n        }\\n        else\\n        y=0; to brack array in subarray to find max.\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int x=0;\\n        for(int i:nums){\\n            x=max(x,i);// here we find max element in array and store it on x.\\n        }\\n        int y=0,a=1;\\n        for(int i:nums){\\n            if(i==x){ // here we count the element which equal to x \\n            y++;\\n            a=max(a,y); // finding the max subarray basically we count max element which have max subarray and store it on a;\\n        }\\n        else\\n        y=0; to brack array in subarray to find max.\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153224,
                "title": "c-golang-brainteaser",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int target = *max_element(nums.begin(), nums.end());\\n        int count = 0, n = nums.size(), ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == target) count++;\\n            else {\\n                ans = max(ans, count);\\n                count = 0;\\n            }\\n        }\\n        ans = max(ans, count);\\n        return ans;\\n    }\\n};\\n\\n// Golang\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\nfunc longestSubarray(nums []int) int {\\n    var count, n, ans, target = 0, len(nums), 0, 0\\n    for _, num := range nums {\\n        target = max(target, num)\\n    }\\n    for i := 0; i < n; i++ {\\n        if nums[i] == target{\\n            count++\\n        } else {\\n            ans = max(ans, count)\\n            count = 0\\n        }\\n    }\\n    ans = max(ans, count)\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Bit Manipulation",
                    "Brainteaser"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int target = *max_element(nums.begin(), nums.end());\\n        int count = 0, n = nums.size(), ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == target) count++;\\n            else {\\n                ans = max(ans, count);\\n                count = 0;\\n            }\\n        }\\n        ans = max(ans, count);\\n        return ans;\\n    }\\n};\\n\\n// Golang\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\nfunc longestSubarray(nums []int) int {\\n    var count, n, ans, target = 0, len(nums), 0, 0\\n    for _, num := range nums {\\n        target = max(target, num)\\n    }\\n    for i := 0; i < n; i++ {\\n        if nums[i] == target{\\n            count++\\n        } else {\\n            ans = max(ans, count)\\n            count = 0\\n        }\\n    }\\n    ans = max(ans, count)\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139350,
                "title": "c-clean-short-code-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int n=nums.size(),c=0,m=0;\\n        int p=*max_element(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n          {\\n                if(nums[i]==p)\\n                {c++;m=max(m,c);}\\n                else \\n                c=0;\\n          }\\n          return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int n=nums.size(),c=0,m=0;\\n        int p=*max_element(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n          {\\n                if(nums[i]==p)\\n                {c++;m=max(m,c);}\\n                else \\n                c=0;\\n          }\\n          return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137670,
                "title": "c-easy-code-with-efficient-approach-dp-approach-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse cadane\\'s theorem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmake a another vector to store \\'&\\' operation current max value.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& v) {\\n        int res=1,maxi = v[0],ct=1;\\n        int n = v.size();\\n        vector<int> v2(n,0);\\n        v2[0] = v[0];\\n        for(int i=1;i<n;++i)\\n        {\\n            if( (v2[i-1]&v[i]) > v[i])\\n            {\\n                v2[i] = (v2[i-1]&v[i]);\\n                if(maxi<v2[i])\\n                {\\n                    maxi = v2[i]; ct=1;\\n                    res=ct;\\n                }\\n                else\\n                {\\n                    if(ct>1)\\n                    {\\n                        if(ct>res)\\n                        res = ct;\\n                        ct=1;\\n                    }\\n                }\\n            }\\n            else if( (v2[i-1]&v[i]) == v[i])\\n            {\\n                v2[i] = v[i];\\n                if(v2[i-1]==v2[i] && v2[i]==maxi)\\n                ct++;\\n            }   \\n            else\\n            {\\n                v2[i] = v[i];\\n                if(maxi<v2[i])\\n                {\\n                    maxi = v2[i]; ct=1; res=ct;\\n                }\\n                else\\n                {\\n                    if(ct>1)\\n                    {\\n                        if(ct>res) res = ct;\\n                        ct=1;\\n                    }\\n                }\\n               \\n            }\\n        }\\n        if(ct>res) res = ct;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& v) {\\n        int res=1,maxi = v[0],ct=1;\\n        int n = v.size();\\n        vector<int> v2(n,0);\\n        v2[0] = v[0];\\n        for(int i=1;i<n;++i)\\n        {\\n            if( (v2[i-1]&v[i]) > v[i])\\n            {\\n                v2[i] = (v2[i-1]&v[i]);\\n                if(maxi<v2[i])\\n                {\\n                    maxi = v2[i]; ct=1;\\n                    res=ct;\\n                }\\n                else\\n                {\\n                    if(ct>1)\\n                    {\\n                        if(ct>res)\\n                        res = ct;\\n                        ct=1;\\n                    }\\n                }\\n            }\\n            else if( (v2[i-1]&v[i]) == v[i])\\n            {\\n                v2[i] = v[i];\\n                if(v2[i-1]==v2[i] && v2[i]==maxi)\\n                ct++;\\n            }   \\n            else\\n            {\\n                v2[i] = v[i];\\n                if(maxi<v2[i])\\n                {\\n                    maxi = v2[i]; ct=1; res=ct;\\n                }\\n                else\\n                {\\n                    if(ct>1)\\n                    {\\n                        if(ct>res) res = ct;\\n                        ct=1;\\n                    }\\n                }\\n               \\n            }\\n        }\\n        if(ct>res) res = ct;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108360,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int res=0;\\n        for(int i=0;i<nums.length;i++){\\n           res=Math.max(res,nums[i]);\\n        }\\n        // System.out.println(res);\\n        int len=0;\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==res){\\n                len++;\\n                ans=Math.max(len,ans);\\n            }\\n            else{\\n                len=0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int res=0;\\n        for(int i=0;i<nums.length;i++){\\n           res=Math.max(res,nums[i]);\\n        }\\n        // System.out.println(res);\\n        int len=0;\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==res){\\n                len++;\\n                ans=Math.max(len,ans);\\n            }\\n            else{\\n                len=0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056738,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int max_val = -1;\\n        for(int ele: nums) {\\n            max_val = max(max_val, ele);\\n        }\\n\\n        int res = 1;\\n        int j = 0;\\n        for(int i=0;i<nums.size();i++) {\\n            if(nums[i]!=max_val) {\\n                    continue;\\n            }\\n\\n            j = i;\\n            while(j<nums.size() && nums[j] == max_val) {\\n                j++;\\n            }\\n            res = max(res, j-i);\\n            i = j-1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int max_val = -1;\\n        for(int ele: nums) {\\n            max_val = max(max_val, ele);\\n        }\\n\\n        int res = 1;\\n        int j = 0;\\n        for(int i=0;i<nums.size();i++) {\\n            if(nums[i]!=max_val) {\\n                    continue;\\n            }\\n\\n            j = i;\\n            while(j<nums.size() && nums[j] == max_val) {\\n                j++;\\n            }\\n            res = max(res, j-i);\\n            i = j-1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043202,
                "title": "a-simple-java-solution-runtime-beats-97",
                "content": "# Approach\\nThe first if statement will check if the current loop value is greater than our last known maximum (num). If it is all our values are wiped as we need to focus on the greatest value only. The if else will count the length of the subarray using val. The else statement tells if a smaller number is hit. We then know that the subarray is over, so the current val is stored in max and set to 0 incase it finds the same number. Returning the greater value between max and val is our answer.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int val = 0, num = 0, max = 0;\\n        for (int i: nums) {\\n            if (num < i) {\\n                num = i;\\n                val = 1;\\n                max = 0;\\n            }\\n            else if (num == i) {\\n                val++;\\n            }\\n            else {\\n                if (val > max)\\n                    max = val;\\n                val = 0;\\n            }\\n        }\\n        return Math.max(max, val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int val = 0, num = 0, max = 0;\\n        for (int i: nums) {\\n            if (num < i) {\\n                num = i;\\n                val = 1;\\n                max = 0;\\n            }\\n            else if (num == i) {\\n                val++;\\n            }\\n            else {\\n                if (val > max)\\n                    max = val;\\n                val = 0;\\n            }\\n        }\\n        return Math.max(max, val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042072,
                "title": "c-simple-soution-using-logic-a-b-max-a-b-clean-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The funda is a &b <= max(a,b)\\n- From this u need to think in reverse that \\n- in order the AND Val to be max we need to choose max element of arr\\n- MAX VAL & any other = leads to smaller guy \\n- so MAX VAL & MAX VAL only, so find how many are togther.\\n- OVER.\\n\\nTo find the funda logic - thats why its medium or else its EASY Lvl only.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int N = nums.size();\\n        int maxval = *max_element(nums.begin(), nums.end());\\n\\n        int ctr = 0;\\n        int ans = 0;\\n\\n        for(int i=0; i<N; i++){\\n            if(nums[i]==maxval){\\n                ctr++; // consecutive means simply add +1 to len\\n            }\\n            else{\\n                ctr=0; //breaks the chain of consecutive\\n            }\\n            ans = max(ans, ctr);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int N = nums.size();\\n        int maxval = *max_element(nums.begin(), nums.end());\\n\\n        int ctr = 0;\\n        int ans = 0;\\n\\n        for(int i=0; i<N; i++){\\n            if(nums[i]==maxval){\\n                ctr++; // consecutive means simply add +1 to len\\n            }\\n            else{\\n                ctr=0; //breaks the chain of consecutive\\n            }\\n            ans = max(ans, ctr);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030954,
                "title": "c-easy",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int count = 0;\\n        int ans = 0;\\n        int maxele = *max_element(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == maxele){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int count = 0;\\n        int ans = 0;\\n        int maxele = *max_element(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == maxele){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018851,
                "title": "short-and-simple",
                "content": "# Intuition\\nBasics of and operation the largest will be the largest and value\\n# Approach\\nget the largest number and find the longest consequitive largest number\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& A) {\\n        int target = 0;\\n        int count = 0;\\n        int res = 0;\\n        int n = A.size();\\n        for(int a : A)\\n            target = max(target,a);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(A[i] == target)\\n                count++;\\n            else\\n                count = 0;\\n            res = max(count,res);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& A) {\\n        int target = 0;\\n        int count = 0;\\n        int res = 0;\\n        int n = A.size();\\n        for(int a : A)\\n            target = max(target,a);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(A[i] == target)\\n                count++;\\n            else\\n                count = 0;\\n            res = max(count,res);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008670,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public:\\n    int longestSubarray(vector<int>& nums) {\\n      int l = 0, i = 0, ans = 0, v = *max_element(nums.begin(), nums.end());\\n      while (i < nums.size()) {\\n        if (nums[i] == v) {\\n          l = i;\\n          while (i < nums.size() && nums[i] == v) {\\n            i++;\\n          }\\n          ans = max(ans, i-l);\\n        } else\\n          i++;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    int longestSubarray(vector<int>& nums) {\\n      int l = 0, i = 0, ans = 0, v = *max_element(nums.begin(), nums.end());\\n      while (i < nums.size()) {\\n        if (nums[i] == v) {\\n          l = i;\\n          while (i < nums.size() && nums[i] == v) {\\n            i++;\\n          }\\n          ans = max(ans, i-l);\\n        } else\\n          i++;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998573,
                "title": "c-simple-well-commented",
                "content": "\\n# Approach\\n first find max number in array and then find longest length of that max element\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        //first find max number in array\\n        int maxi=INT_MIN;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]>maxi) maxi=nums[i];\\n        }\\n\\n        //now find longest length of that max element\\n        int res=1, cnt=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==maxi) cnt++;\\n            else{\\n                if(cnt>res) res=cnt;\\n                cnt=0;\\n            }\\n        }\\n        if(cnt>res) res=cnt;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        //first find max number in array\\n        int maxi=INT_MIN;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]>maxi) maxi=nums[i];\\n        }\\n\\n        //now find longest length of that max element\\n        int res=1, cnt=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==maxi) cnt++;\\n            else{\\n                if(cnt>res) res=cnt;\\n                cnt=0;\\n            }\\n        }\\n        if(cnt>res) res=cnt;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987372,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int maxi = *max_element(nums.begin(), nums.end());\\n        int ans = 0;\\n        for(int i = 0; i<nums.size(); ++i){\\n            if(nums[i] == maxi){\\n                int ct = 0;\\n                while(i<nums.size() && nums[i] == maxi){\\n                    ct++;\\n                    i++;\\n                }\\n                ans = max(ct, ans);\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int maxi = *max_element(nums.begin(), nums.end());\\n        int ans = 0;\\n        for(int i = 0; i<nums.size(); ++i){\\n            if(nums[i] == maxi){\\n                int ct = 0;\\n                while(i<nums.size() && nums[i] == maxi){\\n                    ct++;\\n                    i++;\\n                }\\n                ans = max(ct, ans);\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977742,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestSubarray(int[] nums) {\\n        if(nums.Length == 0){\\n            return 0;\\n        }\\n        int numsMax = 0;\\n        int max = 0;\\n        int result = 1;\\n        for(int i = 0; i < nums.Length; i++){\\n            if(nums[i] > numsMax){\\n                numsMax = nums[i];\\n            }\\n        }\\n        for(int j = 0; j < nums.Length; j++){\\n            if(nums[j] == numsMax){\\n                max++;\\n            }else{\\n                max = 0;\\n            }\\n            result = Math.Max(max, result);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestSubarray(int[] nums) {\\n        if(nums.Length == 0){\\n            return 0;\\n        }\\n        int numsMax = 0;\\n        int max = 0;\\n        int result = 1;\\n        for(int i = 0; i < nums.Length; i++){\\n            if(nums[i] > numsMax){\\n                numsMax = nums[i];\\n            }\\n        }\\n        for(int j = 0; j < nums.Length; j++){\\n            if(nums[j] == numsMax){\\n                max++;\\n            }else{\\n                max = 0;\\n            }\\n            result = Math.Max(max, result);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970514,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int max=0,len=1,maxlen=1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            max=Math.max(max,nums[i]);\\n        }\\n        for(int i=1;i<nums.length;i++)\\n        {\\n                if(nums[i]==nums[i-1]&&nums[i]==max)\\n                {\\n                    ++len;\\n                }\\n                else\\n                {\\n                        maxlen=Math.max(maxlen,len);\\n                        len=1;\\n                        \\n                }\\n        }\\n        maxlen=Math.max(maxlen,len);\\n            return maxlen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int max=0,len=1,maxlen=1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            max=Math.max(max,nums[i]);\\n        }\\n        for(int i=1;i<nums.length;i++)\\n        {\\n                if(nums[i]==nums[i-1]&&nums[i]==max)\\n                {\\n                    ++len;\\n                }\\n                else\\n                {\\n                        maxlen=Math.max(maxlen,len);\\n                        len=1;\\n                        \\n                }\\n        }\\n        maxlen=Math.max(maxlen,len);\\n            return maxlen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969466,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        \\n        int max = 0, c = 0, res = 0;\\n\\n        for (int i: nums){\\n            max = Math.max(i, max);\\n        }\\n\\n        for (int i: nums){\\n            if (i == max){\\n                c++;\\n            }else {\\n                res = Math.max(c, res);\\n                c = 0;\\n            }\\n        }\\n        res = Math.max(c, res);\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        \\n        int max = 0, c = 0, res = 0;\\n\\n        for (int i: nums){\\n            max = Math.max(i, max);\\n        }\\n\\n        for (int i: nums){\\n            if (i == max){\\n                c++;\\n            }else {\\n                res = Math.max(c, res);\\n                c = 0;\\n            }\\n        }\\n        res = Math.max(c, res);\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958042,
                "title": "easy-o-n-solution-using-cpp-faster-then-98",
                "content": "\\n# Approach\\nAND will be maximum only of max element present in array so check any contiguous subarray of that max element and return respective max length\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0,l=0;\\n        int m=*max_element(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==m)l++;\\n            else l=0;\\n            ans=max(ans,l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0,l=0;\\n        int m=*max_element(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==m)l++;\\n            else l=0;\\n            ans=max(ans,l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957973,
                "title": "c-simple-5-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSince we are looking for maximum possible bitwise AND, we should find the maximum element in the given vector. Next step is to check if there are more occurances of given element in vector which can form subarray.\\n\\n(Reason: Bitwise AND of two elemets is always less than the given elements provided elements are not equal. Since we have to find the maximum element, maximum possible bitwise AND should be equal to this number. It is not possible to have a bitwise AND, greater than the maximum element) . \\n\\n# Complexity\\n- Time complexity:\\nO(n) to compute the max element and traversing the vector once.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int max_l = *max_element(nums.begin(), nums.end());\\n        int ctr = 1, ans = 1;\\n        for (int i=0; i<nums.size()-1; i++) {\\n            ctr = (nums[i] == max_l && nums[i+1] == max_l) ? ++ctr: 1;\\n            ans = max(ctr, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int max_l = *max_element(nums.begin(), nums.end());\\n        int ctr = 1, ans = 1;\\n        for (int i=0; i<nums.size()-1; i++) {\\n            ctr = (nums[i] == max_l && nums[i+1] == max_l) ? ++ctr: 1;\\n            ans = max(ctr, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955191,
                "title": "javascript-longest-subarray-problem-solved",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSubarray = function(nums) {\\n    let {maxLen} = nums.reduce((acc, num) => {\\n        if(acc.max < num) {\\n            return {\\n                max: num,\\n                maxLen: 1,\\n                len: 1\\n            }\\n        }else if(acc.max == num){\\n            acc.len += 1;\\n            \\n            if(acc.maxLen < acc.len) {\\n                acc.maxLen += 1;\\n            }\\n        }else {\\n            acc.len = 0;\\n        }\\n\\n        return acc\\n    }, {max: 0, maxLen: 0, len: 0});\\n\\n    return maxLen\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSubarray = function(nums) {\\n    let {maxLen} = nums.reduce((acc, num) => {\\n        if(acc.max < num) {\\n            return {\\n                max: num,\\n                maxLen: 1,\\n                len: 1\\n            }\\n        }else if(acc.max == num){\\n            acc.len += 1;\\n            \\n            if(acc.maxLen < acc.len) {\\n                acc.maxLen += 1;\\n            }\\n        }else {\\n            acc.len = 0;\\n        }\\n\\n        return acc\\n    }, {max: 0, maxLen: 0, len: 0});\\n\\n    return maxLen\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2937313,
                "title": "longest-subarray-with-max-bitwise-and-c",
                "content": "int longestSubarray(vector<int>& nums) {\\n      int ans=*max_element(nums.begin(),nums.end());\\n        int cnt=0;\\n        int maxx=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==ans)\\n            {\\n                cnt++;\\n                \\n            }\\n            else\\n            {\\n              maxx=max(cnt,maxx);cnt=0;  \\n            }\\n             maxx=max(cnt,maxx);\\n        }\\n        return maxx;\\n    }\\n};",
                "solutionTags": [],
                "code": "int longestSubarray(vector<int>& nums) {\\n      int ans=*max_element(nums.begin(),nums.end());\\n        int cnt=0;\\n        int maxx=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==ans)\\n            {\\n                cnt++;\\n                \\n            }\\n            else\\n            {\\n              maxx=max(cnt,maxx);cnt=0;  \\n            }\\n             maxx=max(cnt,maxx);\\n        }\\n        return maxx;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2880332,
                "title": "very-easy-java-solution-with-intuition-o-n",
                "content": "**Intuition** : When we take **bitwise and** of a number with another number then its result cannot exceed both numbers\\n\\ni.e. if c=a & b then c<=min(a,b)\\nTherefore the subarray having **maximum bitwise and** result is a subarray containing only max(Maximum element) of array\\n\\nHence, solution consists of two steps:\\ni) Find maximum of thee array\\nii) Find the maximum number of times this max element occurs in series\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int max=-1;\\n        //Finding max element\\n        for(int i=0;i<nums.length;i++){\\n            max=Math.max(max,nums[i]);\\n        }\\n        //Finding maximum number of times max element occurs consecutively\\n        int maxTimesInSeries=0;\\n        for(int i=0;i<nums.length;i++){\\n            int count=0;\\n            while(i<nums.length && nums[i]==max){\\n                count++;\\n                i++;\\n            }\\n            maxTimesInSeries=Math.max(maxTimesInSeries,count);\\n        }\\n        return maxTimesInSeries;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int max=-1;\\n        //Finding max element\\n        for(int i=0;i<nums.length;i++){\\n            max=Math.max(max,nums[i]);\\n        }\\n        //Finding maximum number of times max element occurs consecutively\\n        int maxTimesInSeries=0;\\n        for(int i=0;i<nums.length;i++){\\n            int count=0;\\n            while(i<nums.length && nums[i]==max){\\n                count++;\\n                i++;\\n            }\\n            maxTimesInSeries=Math.max(maxTimesInSeries,count);\\n        }\\n        return maxTimesInSeries;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812887,
                "title": "python3-counting-of-consecutive-appearances-of-maximum",
                "content": "class Solution:\\n\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        res = curr = 0\\n        maximum = max(nums)\\n        for num in nums:\\n            if num == maximum:\\n                curr+=1\\n                res = max(res,curr)\\n            else:\\n                curr = 0\\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        res = curr = 0\\n        maximum = max(nums)\\n        for num in nums:\\n            if num == maximum:\\n                curr+=1\\n                res = max(res,curr)\\n            else:\\n                curr = 0\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2793661,
                "title": "simle-java-solution",
                "content": "Approch:\\n    maximum number of continues occrence of max element in array is ans \\n time=>O(N)\\n space=>O(1)\\n\\nclass Solution {\\n\\n    public int longestSubarray(int[] nums) {\\n        int max=Integer.MIN_VALUE,n=nums.length,cnt=0,ans=1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>max){\\n                max=nums[i];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==max){\\n                cnt++;\\n            }\\n            else{\\n                ans=Math.max(ans,cnt);\\n                cnt=0;\\n            }\\n        }\\n        ans=Math.max(ans,cnt);\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\n    public int longestSubarray(int[] nums) {\\n        int max=Integer.MIN_VALUE,n=nums.length,cnt=0,ans=1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>max){\\n                max=nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2777463,
                "title": "rust-solution",
                "content": "\\n# Code\\n```\\nimpl Solution {\\n  pub fn longest_subarray(nums: Vec<i32>) -> i32 {\\n      let mut max = 0;\\n      let mut result = 1;\\n      let mut count = 0;\\n\\n      for v in nums {\\n        if max < v {\\n          result = 1;\\n          max = v;\\n          count = 1;\\n        } else if max == v {\\n          count += 1;\\n        } else {\\n          result = result.max(count);\\n          count = 0;\\n        }\\n      }\\n      result = result.max(count);\\n\\n      result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn longest_subarray(nums: Vec<i32>) -> i32 {\\n      let mut max = 0;\\n      let mut result = 1;\\n      let mut count = 0;\\n\\n      for v in nums {\\n        if max < v {\\n          result = 1;\\n          max = v;\\n          count = 1;\\n        } else if max == v {\\n          count += 1;\\n        } else {\\n          result = result.max(count);\\n          count = 0;\\n        }\\n      }\\n      result = result.max(count);\\n\\n      result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2773411,
                "title": "easy-c",
                "content": "**Maximum**  possible AND value is equal to the largest element in array.\\nSo, we just need to find the length of such segements and take max of these lengths.\\n\\nFor example:\\n                 array:  [1,2,3,3,2,2,3,1,3,3,3,3]\\n\\t\\t\\t\\t max element =3\\n\\t\\t\\t\\t segments length having 3= 2,1,4\\n\\t\\t\\t\\t max len=4  **ANSWER**\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums)\\n    {\\n        int mx=*max_element(nums.begin(),nums.end());  // storing max element\\n            cout<<mx<<endl;\\n            int len=0;                                                            // for storing curr len of segment\\n            int ans=0;                                                           // for storing max length \\n            for(auto it:nums)\\n            {\\n                    if(it==mx)\\n                    {\\n                            ++len;                                             // if curr element is equal to mx then increase len\\n                    }   \\n                    else\\n                    {\\n                            ans=max(ans,len);                         // update ans as max of ans and len\\n                            len=0;                                           // set len as 0 for storing next segment len\\n                    }\\n            }\\n            ans=max(ans,len);\\n            return ans;                                               // return ans\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums)\\n    {\\n        int mx=*max_element(nums.begin(),nums.end());  // storing max element\\n            cout<<mx<<endl;\\n            int len=0;                                                            // for storing curr len of segment\\n            int ans=0;                                                           // for storing max length \\n            for(auto it:nums)\\n            {\\n                    if(it==mx)\\n                    {\\n                            ++len;                                             // if curr element is equal to mx then increase len\\n                    }   \\n                    else\\n                    {\\n                            ans=max(ans,len);                         // update ans as max of ans and len\\n                            len=0;                                           // set len as 0 for storing next segment len\\n                    }\\n            }\\n            ans=max(ans,len);\\n            return ans;                                               // return ans\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2742595,
                "title": "c-tc-o-n-simple-solution-well-commented",
                "content": "```\\n/*\\n\\tApproach : \\n\\t1-> First find max value in nums\\n\\t2-> Then find max streak of max value in nums\\n\\t\\n\\t**----How it works----**\\n\\tExmaple : \\n\\t1. [5]\\n\\t5 : 1 0 1\\n\\tmax val = 5   max streak = 1\\n\\t\\n\\t2.  [5,5]\\n\\t5 : 1 0 1\\n\\t5 : 1 0 1\\n\\t5&5 = 5 (1 0 1)\\n\\tmax val = 5   max streak = 2\\n\\t\\n\\t3. [5,3]\\n\\t5 : 1 0 1\\n\\t3 : 0 1 1\\n\\t5&3 = 1 (0 0 1)\\n\\t\\n\\tHere we Observe : \\n\\tfor single no. and(&) is same like 5 \\n\\tfor 2 same no. and(&) is same (5&5) = 5\\n\\tbut for 2 different no. and(&) is always less than or equal to smaller no (5&3) = 1\\n\\t\\n\\tConclusion : so we are not going to and(&) 2 different no (because it always makes our no. smaller) instead \\n\\twe take maximum of both 2 no. Example : 5&3 instead taking 5&3 we take 5 because we have option to \\n\\ttake single subarray also\\n\\t\\n\\tFinally : We Find max value in nums then find max streak of max value that\\'s our max possible ans\\n\\t\\n\\tEx : [1,2,3,3,2,2]\\n\\tHere max val = 3 \\n\\tmax streak of 3 is 2 \\n\\t\\n\\tEx : [1,2,3,4]\\n\\tHere max val is = 4 \\n\\tmax streak of 4 is 1\\n*/\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int mx_val = 0; \\n        int ans = 0; \\n        for(auto &x:nums) mx_val = max(mx_val,x);\\n        int cur = 0;\\n        for(auto &x:nums){\\n            if(x==mx_val) {\\n                cur++;\\n                ans = max(cur,ans);\\n            }\\n            else cur = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIF YOU LIKE SOLUTION PLEASE UPVOTE :)\\nHAPPY CODING :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n\\tApproach : \\n\\t1-> First find max value in nums\\n\\t2-> Then find max streak of max value in nums\\n\\t\\n\\t**----How it works----**\\n\\tExmaple : \\n\\t1. [5]\\n\\t5 : 1 0 1\\n\\tmax val = 5   max streak = 1\\n\\t\\n\\t2.  [5,5]\\n\\t5 : 1 0 1\\n\\t5 : 1 0 1\\n\\t5&5 = 5 (1 0 1)\\n\\tmax val = 5   max streak = 2\\n\\t\\n\\t3. [5,3]\\n\\t5 : 1 0 1\\n\\t3 : 0 1 1\\n\\t5&3 = 1 (0 0 1)\\n\\t\\n\\tHere we Observe : \\n\\tfor single no. and(&) is same like 5 \\n\\tfor 2 same no. and(&) is same (5&5) = 5\\n\\tbut for 2 different no. and(&) is always less than or equal to smaller no (5&3) = 1\\n\\t\\n\\tConclusion : so we are not going to and(&) 2 different no (because it always makes our no. smaller) instead \\n\\twe take maximum of both 2 no. Example : 5&3 instead taking 5&3 we take 5 because we have option to \\n\\ttake single subarray also\\n\\t\\n\\tFinally : We Find max value in nums then find max streak of max value that\\'s our max possible ans\\n\\t\\n\\tEx : [1,2,3,3,2,2]\\n\\tHere max val = 3 \\n\\tmax streak of 3 is 2 \\n\\t\\n\\tEx : [1,2,3,4]\\n\\tHere max val is = 4 \\n\\tmax streak of 4 is 1\\n*/\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int mx_val = 0; \\n        int ans = 0; \\n        for(auto &x:nums) mx_val = max(mx_val,x);\\n        int cur = 0;\\n        for(auto &x:nums){\\n            if(x==mx_val) {\\n                cur++;\\n                ans = max(cur,ans);\\n            }\\n            else cur = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741891,
                "title": "python-o-n-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe key to simplify this question is this statement\\n\\n> maximum possible bitwise AND\\n\\nAnd given `X`, the maximum possible bitwise AND value of that number is going to be `X` (no matter what other integers are you going to pair it up with)\\n\\nThis means the value of the maximum possible bitwise AND of a given array is going to be the **maximum number** in that array.\\n\\nNow you just have to find the longest subarray of such element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Get the maximum number in the array. Let\\'s call it `maxim`\\n2. Iterate from 0..length of array\\n3. If current element equals to `maxim`, start counting the subarray length\\n4. If the current element is no longer equal to `maxim` restart the count\\n5. Track the maximum subarray length\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        maxim = max(nums)\\n        result = 1\\n        current = 0\\n        for num in nums:\\n            if (num == maxim):\\n                current = current + 1\\n                result = max(result, current)\\n            else:\\n                current = 0\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        maxim = max(nums)\\n        result = 1\\n        current = 0\\n        for num in nums:\\n            if (num == maxim):\\n                current = current + 1\\n                result = max(result, current)\\n            else:\\n                current = 0\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727146,
                "title": "ruby-one-liner",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef longest_subarray(nums)\\n  nums.max.yield_self { |m| nums.chunk { 1 if _1 == m }.map { _2.size }.max }  \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef longest_subarray(nums)\\n  nums.max.yield_self { |m| nums.chunk { 1 if _1 == m }.map { _2.size }.max }  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2725419,
                "title": "c-java-sliding-window-greedy-approach",
                "content": "# Please Upvote if Usefull\\n\\n**Intution**\\n\\n* Just think Before Seeing next line , What  will be the Maximum **BITWISE AND** of Any Number.\\n\\n* I assuming u didn\\'t See this Line Before Thinking ......\\n\\t* If U THink the maximum **BITWISE AND** of any Number is Maximum Number itself ,Corect.\\n\\t\\n\\t* So, this Question is Just finding Maximum lenght of Window containg maxnumber only.\\n\\t* just basic Sliding Window Question , find Maximum sliding Window  containing Only Max Number n it.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& a) {\\n        \\n        int MAX=*max_element(a.begin(),a.end());   // Finding Maximum Element in my array\\n        int len=1;                                //  Let max len Subarray of and =1\\n        for( int i=0;i<a.size();i++){            //  we r just finding a subarray containg all element with max_element.\\n           \\n            if( a[i]==MAX){                     \\n                int c=1;\\n                while( i+1< a.size() &&  a[i]==a[i+1] ){\\n                    c++;\\n                    i++;\\n                }\\n                len=max( len, c);\\n            }\\n        }\\n        return len;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& a) {\\n        \\n        int MAX=*max_element(a.begin(),a.end());   // Finding Maximum Element in my array\\n        int len=1;                                //  Let max len Subarray of and =1\\n        for( int i=0;i<a.size();i++){            //  we r just finding a subarray containg all element with max_element.\\n           \\n            if( a[i]==MAX){                     \\n                int c=1;\\n                while( i+1< a.size() &&  a[i]==a[i+1] ){\\n                    c++;\\n                    i++;\\n                }\\n                len=max( len, c);\\n            }\\n        }\\n        return len;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725193,
                "title": "javascript-o-n",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSubarray = function(nums) {\\n    const maxVal = Math.max(...nums)\\n    let result = 1\\n    \\n    \\n    let outcome = 0\\n    for (const val of nums.values()) {\\n        if (val === maxVal) {\\n            outcome++\\n            result = Math.max(result, outcome)\\n        } else {\\n            outcome = 0\\n        }\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSubarray = function(nums) {\\n    const maxVal = Math.max(...nums)\\n    let result = 1\\n    \\n    \\n    let outcome = 0\\n    for (const val of nums.values()) {\\n        if (val === maxVal) {\\n            outcome++\\n            result = Math.max(result, outcome)\\n        } else {\\n            outcome = 0\\n        }\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2722898,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int len = 1;\\n        int maxnum=nums[0];\\n        \\n        for(int i=0;i<n;i++) {\\n            maxnum = max(maxnum, nums[i]);\\n            \\n        }\\n        int temp=0;\\n        \\n        for(int i=0;i<n;i++) {\\n            \\n            if(nums[i]==maxnum) {\\n                temp++;\\n                len = max(temp, len);\\n            }\\n            else {\\n                temp=0;\\n            }\\n        }\\n        \\n        return len;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int len = 1;\\n        int maxnum=nums[0];\\n        \\n        for(int i=0;i<n;i++) {\\n            maxnum = max(maxnum, nums[i]);\\n            \\n        }\\n        int temp=0;\\n        \\n        for(int i=0;i<n;i++) {\\n            \\n            if(nums[i]==maxnum) {\\n                temp++;\\n                len = max(temp, len);\\n            }\\n            else {\\n                temp=0;\\n            }\\n        }\\n        \\n        return len;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721751,
                "title": "python-1-run-o-n",
                "content": "At the time of writing it was 99% faster.\\n\\nO(n) time complexity\\nO(1) Space complexity\\n\\nWe will greedily keep all the longest subarray.\\n\\nNote: when we find the biggest element, that\\'s when we start counting it\\'s length.\\nIf a_i is the largest element, note that,\\n\\nAs, a_i & a_(i+x) <= a_i, where x is any x>=1\\n\\nif  a_i & a_(i+1) = a_i, we will increase the count by 1.\\n\\nIf a_i & a_(i+1) != a_i, we stop counting and reset the count to 0, saving the current longest as max count.\\n\\nIf we find a number bigger, we must reset the current count + max count\\n\\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        m = 0\\n        c = 0\\n        maxc = 0\\n        \\n        for n in nums:\\n            if n > m:\\n                m = n\\n                c = 1\\n                maxc = 1\\n                \\n            elif m&n == m:\\n                c +=1\\n                \\n            else:\\n                maxc = max(c, maxc)\\n                c = 0\\n                \\n        return max(c, maxc)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        m = 0\\n        c = 0\\n        maxc = 0\\n        \\n        for n in nums:\\n            if n > m:\\n                m = n\\n                c = 1\\n                maxc = 1\\n                \\n            elif m&n == m:\\n                c +=1\\n                \\n            else:\\n                maxc = max(c, maxc)\\n                c = 0\\n                \\n        return max(c, maxc)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719762,
                "title": "python-simple-maths",
                "content": "\\n    def longestSubarray(self, nums):\\n        max_val, max_length, length = max(nums), 0, 0\\n        \\n        for i in range(len(nums)):\\n            if nums[i] == max_val:\\n                length += 1\\n                max_length = max(max_length,length)\\n            else:\\n                length = 0\\n                \\n        return max_length\\n        \\n",
                "solutionTags": [],
                "code": "\\n    def longestSubarray(self, nums):\\n        max_val, max_length, length = max(nums), 0, 0\\n        \\n        for i in range(len(nums)):\\n            if nums[i] == max_val:\\n                length += 1\\n                max_length = max(max_length,length)\\n            else:\\n                length = 0\\n                \\n        return max_length\\n        \\n",
                "codeTag": "Python3"
            },
            {
                "id": 2715773,
                "title": "python-3-two-lines-o-n",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        mx = max(nums)\\n        return max(map(len, \\'\\'.join(map(lambda y: (\\'0\\', \\'1\\')[mx == y], nums)).split(\\'0\\')))\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        mx = max(nums)\\n        return max(map(len, \\'\\'.join(map(lambda y: (\\'0\\', \\'1\\')[mx == y], nums)).split(\\'0\\')))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711955,
                "title": "c-5-line",
                "content": "```\\n    int longestSubarray(vector<int>& nums) {\\n        int res = 0, len = 0, xmax = *max_element(nums.begin(), nums.end());\\n        for(auto x:nums){\\n            x == xmax ? len++ : len = 0;\\n            res = max(res, len);            \\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int longestSubarray(vector<int>& nums) {\\n        int res = 0, len = 0, xmax = *max_element(nums.begin(), nums.end());\\n        for(auto x:nums){\\n            x == xmax ? len++ : len = 0;\\n            res = max(res, len);            \\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2708465,
                "title": "c",
                "content": "```\\nint longestSubarray(int* nums, int numsSize){\\n    int max = 0;\\n    int cn = 0;\\n    int MaxCn = 0;\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] > max){\\n            max = nums[i];\\n            MaxCn = 1;\\n            cn = 1;\\n        }\\n        else if(nums[i] == max)\\n            cn++;\\n        else{\\n            MaxCn = fmax(MaxCn, cn);\\n            cn = 0;\\n        }\\n    }\\n    MaxCn = fmax(MaxCn, cn);\\n    return MaxCn;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint longestSubarray(int* nums, int numsSize){\\n    int max = 0;\\n    int cn = 0;\\n    int MaxCn = 0;\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] > max){\\n            max = nums[i];\\n            MaxCn = 1;\\n            cn = 1;\\n        }\\n        else if(nums[i] == max)\\n            cn++;\\n        else{\\n            MaxCn = fmax(MaxCn, cn);\\n            cn = 0;\\n        }\\n    }\\n    MaxCn = fmax(MaxCn, cn);\\n    return MaxCn;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2705170,
                "title": "c-beware-of-little-trap",
                "content": "Bitwise AND --> value must be <= original max value if you perform bitwise AND with another other number.\\n\\nSo that\\'s it.\\n```cpp\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int i = 0; \\n        int len = nums.size();\\n        int res = 1;\\n        int target = nums[0];\\n        for (int v : nums) {\\n            target = max(target, v);\\n        }\\n        while (i < len) {\\n            int cur = nums[i];\\n            int st = i;\\n            i++;\\n            while (i < len && nums[i] == cur) {\\n                i++;\\n            }\\n            if (cur == target)\\n                res = max(res, (i - st));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int i = 0; \\n        int len = nums.size();\\n        int res = 1;\\n        int target = nums[0];\\n        for (int v : nums) {\\n            target = max(target, v);\\n        }\\n        while (i < len) {\\n            int cur = nums[i];\\n            int st = i;\\n            i++;\\n            while (i < len && nums[i] == cur) {\\n                i++;\\n            }\\n            if (cur == target)\\n                res = max(res, (i - st));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702257,
                "title": "get-the-maximum-value-of-the-array-and-try-to-find-the-longest-window-with-all-maximum-values",
                "content": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n                        \\n        length = 0\\n        max_   = max(nums)\\n        start  = 0\\n        \\n        for end in range(len(nums)):\\n            \\n            if nums[end] == max_:\\n                length = max(length,end-start+1)\\n            else:\\n                start = end + 1\\n        \\n        return length\\n                                        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n                        \\n        length = 0\\n        max_   = max(nums)\\n        start  = 0\\n        \\n        for end in range(len(nums)):\\n            \\n            if nums[end] == max_:\\n                length = max(length,end-start+1)\\n            else:\\n                start = end + 1\\n        \\n        return length\\n                                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695382,
                "title": "c-90-faster-short-and-simple",
                "content": "Just find the **longest substring** length containing the **maximum** value in the array.\\nPlease upvote if you find the solution good and concise.\\n**Thank You!!**\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int res = 0, currmax = 0, n= nums.size(), idx = 0;\\n        while(idx < n) {\\n            if(nums[idx] >= currmax) {\\n                int currlen = 1; idx++;\\n                while(idx< n and nums[idx] == nums[idx -1]) idx++, currlen++;\\n                if(nums[idx-1] > currmax) res = currlen;\\n                else res = max(res, currlen);\\n                currmax = nums[idx - 1];\\n            }\\n            else idx++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int res = 0, currmax = 0, n= nums.size(), idx = 0;\\n        while(idx < n) {\\n            if(nums[idx] >= currmax) {\\n                int currlen = 1; idx++;\\n                while(idx< n and nums[idx] == nums[idx -1]) idx++, currlen++;\\n                if(nums[idx-1] > currmax) res = currlen;\\n                else res = max(res, currlen);\\n                currmax = nums[idx - 1];\\n            }\\n            else idx++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669704,
                "title": "python3-one-liner-using-itertools-groupby",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen using the bitwise AND, any number that is in the subarray that is not the maximum of the list will decrease the result, so we are looking for the length of the longest subarray that contain only the maximum number in the list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse the groupby function from itertools to get number and streak_of_number, and then get the length of the list of that group. Find the max of the output, prioritizing the number, then the length of the group.  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        x = max(nums)\\n        res = 1\\n        for c, g in itertools.groupby(nums): \\n            if c == x: \\n                res = max(res, len(list(g)))\\n        return res\\n```\\n# One liner\\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        return max([(n, len(list(g))) for n, g in itertools.groupby(nums)])[1]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int]) -> int:\\n        x = max(nums)\\n        res = 1\\n        for c, g in itertools.groupby(nums): \\n            if c == x: \\n                res = max(res, len(list(g)))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663843,
                "title": "c-one-pass-time-o-n-space-o-1",
                "content": "# Intuition\\nThis problem is asking for the longest length of the subarray that contains the largest number.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**Two-Pass approach:**\\nFind the largest number first.\\nIterate through the array and use a counter to record the consecutive length of the largest number.\\n\\n**One-Pass approach:**\\nIterate through the array, find the largest number in the course of the iteration, and use a counter to record the consecutive length of the largest number.\\n\\nReset the counter when we meet a number != largest\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Solution 1**\\n```\\nclass Solution {\\npublic:\\n  int longestSubarray(vector<int>& nums) {\\n    int result = 0, len = 0, largest = 0;\\n    for (const int& num : nums) {\\n      if (num > largest) {\\n        largest = num;\\n        len = 1;\\n        result = 1; // since we find a new largest \\'num\\', we have to reset \\'result\\' back to 1\\n      }\\n      else if (num == largest) {\\n        len++;\\n      }\\n      else {\\n        len = 0;\\n      }\\n      result = max(result, len);\\n    }\\n    return result;\\n  }\\n};\\n```\\n**Solution 2**\\n```\\nclass Solution {\\npublic:\\n  int longestSubarray(vector<int>& nums) {\\n    int result = 0, len = 0, largest = 0;\\n    for (const int& num : nums) {\\n      if (num > largest) {\\n        largest = num;\\n        len = result = 0;\\n      }\\n      len = num == largest ? len + 1 : 0;\\n      result = max(result, len);\\n    }\\n    return result;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int longestSubarray(vector<int>& nums) {\\n    int result = 0, len = 0, largest = 0;\\n    for (const int& num : nums) {\\n      if (num > largest) {\\n        largest = num;\\n        len = 1;\\n        result = 1; // since we find a new largest \\'num\\', we have to reset \\'result\\' back to 1\\n      }\\n      else if (num == largest) {\\n        len++;\\n      }\\n      else {\\n        len = 0;\\n      }\\n      result = max(result, len);\\n    }\\n    return result;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  int longestSubarray(vector<int>& nums) {\\n    int result = 0, len = 0, largest = 0;\\n    for (const int& num : nums) {\\n      if (num > largest) {\\n        largest = num;\\n        len = result = 0;\\n      }\\n      len = num == largest ? len + 1 : 0;\\n      result = max(result, len);\\n    }\\n    return result;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662554,
                "title": "javascript-longest-max-value-subarray",
                "content": "Hard to understand the meaning, waste a lot of time on the bitwise AND operation:\\n```\\nvar longestSubarray = function(nums) {\\n    let max = nums[0];\\n    let cur = 1;\\n    let len = 1;\\n    for(let i = 1; i<nums.length; i++) {\\n\\n        if(nums[i] > max) {\\n            max = nums[i]; \\n            cur = 1;\\n            len = 1;\\n        }\\n        else if(nums[i] === max) {\\n           cur++;\\n            len = Math.max(cur, len);\\n        } \\n        else {\\n           cur = 0; \\n        }\\n       \\n    }\\n    \\n    return len;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestSubarray = function(nums) {\\n    let max = nums[0];\\n    let cur = 1;\\n    let len = 1;\\n    for(let i = 1; i<nums.length; i++) {\\n\\n        if(nums[i] > max) {\\n            max = nums[i]; \\n            cur = 1;\\n            len = 1;\\n        }\\n        else if(nums[i] === max) {\\n           cur++;\\n            len = Math.max(cur, len);\\n        } \\n        else {\\n           cur = 0; \\n        }\\n       \\n    }\\n    \\n    return len;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2660428,
                "title": "working-solution-by-two-pointers-intuition",
                "content": "int longestSubarray(vector<int>& nums) {\\n        \\n        int maxLen = INT_MIN;\\n        \\n        \\n        int i = 1;\\n        int j = 0;\\n        \\n        int maxAnd = nums[0];\\n        maxLen = max(maxLen, i-j);\\n        int tempAnd = nums[0];\\n        \\n        for(; i<nums.size(); i++){\\n            \\n            tempAnd = nums[i];\\n            \\n            while(i < nums.size() && nums[i] == nums[i-1]){\\n                i++;\\n            }\\n            \\n            if(tempAnd == maxAnd){\\n                maxAnd = max(maxAnd, tempAnd);\\n                maxLen = max(maxLen,i-j);\\n            }\\n            \\n            if(tempAnd > maxAnd){\\n                 maxAnd = max(maxAnd, tempAnd);\\n                maxLen = i-j;               \\n            }\\n            \\n            \\n            \\n            if(i == nums.size())\\n                break;\\n            \\n            tempAnd = nums[i];\\n            j = i;\\n            \\n        }\\n        \\n\\n        if(tempAnd > maxAnd){\\n            maxAnd = tempAnd;\\n            maxLen = i-j;\\n        }\\n        \\n        \\n        return maxLen;\\n        \\n    }",
                "solutionTags": [],
                "code": "int longestSubarray(vector<int>& nums) {\\n        \\n        int maxLen = INT_MIN;\\n        \\n        \\n        int i = 1;\\n        int j = 0;\\n        \\n        int maxAnd = nums[0];\\n        maxLen = max(maxLen, i-j);\\n        int tempAnd = nums[0];\\n        \\n        for(; i<nums.size(); i++){\\n            \\n            tempAnd = nums[i];\\n            \\n            while(i < nums.size() && nums[i] == nums[i-1]){\\n                i++;\\n            }\\n            \\n            if(tempAnd == maxAnd){\\n                maxAnd = max(maxAnd, tempAnd);\\n                maxLen = max(maxLen,i-j);\\n            }\\n            \\n            if(tempAnd > maxAnd){\\n                 maxAnd = max(maxAnd, tempAnd);\\n                maxLen = i-j;               \\n            }\\n            \\n            \\n            \\n            if(i == nums.size())\\n                break;\\n            \\n            tempAnd = nums[i];\\n            j = i;\\n            \\n        }\\n        \\n\\n        if(tempAnd > maxAnd){\\n            maxAnd = tempAnd;\\n            maxLen = i-j;\\n        }\\n        \\n        \\n        return maxLen;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2660399,
                "title": "longest-subarray-with-maximum-bitwise-and",
                "content": "```\\n/*Maximum Bitwise AND of any two numbers will be less then the maximum of two numbers so to get the maximum bitwise AND the elements should be only maximum elements, so find the longest subarray which contains only the maximum elements*/.\\nint longestSubarray(vector<int>& nums) {\\n        int mx=*max_element(nums.begin(),nums.end());\\n        \\n        int ans=1,c=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==mx){\\n                c++;\\n                ans=max(ans,c);\\n            }\\n            else{\\n                c=0;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*Maximum Bitwise AND of any two numbers will be less then the maximum of two numbers so to get the maximum bitwise AND the elements should be only maximum elements, so find the longest subarray which contains only the maximum elements*/.\\nint longestSubarray(vector<int>& nums) {\\n        int mx=*max_element(nums.begin(),nums.end());\\n        \\n        int ans=1,c=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==mx){\\n                c++;\\n                ans=max(ans,c);\\n            }\\n            else{\\n                c=0;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2659820,
                "title": "rust-intuitive",
                "content": "```\\nimpl Solution {\\n    pub fn longest_subarray(nums: Vec<i32>) -> i32 {\\n        let mut ele = *nums.iter().next().unwrap();\\n        let mut len = 0;\\n        let mut ret = 0;\\n        \\n        for val in nums {\\n            if val == ele {\\n                len += 1;\\n                ret = std::cmp::max(len, ret);\\n            } else if val > ele {\\n                ele = val;\\n                len = 1;\\n                ret = 1;\\n            } else {\\n                len = 0;\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_subarray(nums: Vec<i32>) -> i32 {\\n        let mut ele = *nums.iter().next().unwrap();\\n        let mut len = 0;\\n        let mut ret = 0;\\n        \\n        for val in nums {\\n            if val == ele {\\n                len += 1;\\n                ret = std::cmp::max(len, ret);\\n            } else if val > ele {\\n                ele = val;\\n                len = 1;\\n                ret = 1;\\n            } else {\\n                len = 0;\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2657692,
                "title": "one-pass-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe  maximum possible bitwise AND is nothing but the number with maximum  1\\'s(i.e largest number given in the array)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince Given operation is AND, we need to find the number which have more 1\\'s \\ne.g. \\n> 32767 -  0111111111111111\\n32768 -  1000000000000000\\nAND  -   1000000000000000\\n\\nWe can infer that maximum number will always be the result of bitwise(&) highest value.\\n\\nIf there are consecutive maximum numbers then that would be the largest sub array. \\n\\nSo Let maximum be first number(nums[0]) and then update it at every step \\nif the next consecutive numbers are also maximum increment the counter\\nelse:\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int max_num = nums[0]; \\n        int max_cnt = 1; \\n        int cnt = 1;\\n        for(int i=1;i<nums.size(); i++){\\n            if(nums[i] == max_num)\\n                cnt++;\\n            else{\\n                if(nums[i]>max_num){\\n                    max_num = nums[i];\\n                    max_cnt = 1;\\n                    cnt = 1;\\n                }else{\\n                    cnt = 0;      // to prevent unnecessary increment\\n                }\\n    \\n            }   \\n            max_cnt = max(max_cnt, cnt);\\n        }\\n        return max_cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int max_num = nums[0]; \\n        int max_cnt = 1; \\n        int cnt = 1;\\n        for(int i=1;i<nums.size(); i++){\\n            if(nums[i] == max_num)\\n                cnt++;\\n            else{\\n                if(nums[i]>max_num){\\n                    max_num = nums[i];\\n                    max_cnt = 1;\\n                    cnt = 1;\\n                }else{\\n                    cnt = 0;      // to prevent unnecessary increment\\n                }\\n    \\n            }   \\n            max_cnt = max(max_cnt, cnt);\\n        }\\n        return max_cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648350,
                "title": "scala-one-line-solution",
                "content": "```\\n\\n  def longestSubarray(nums: Array[Int]): Int = \\n    nums.mkString.replaceAll(nums.max.toString, \"#\").split(\"[0-9]\").map(_.size).max\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n\\n  def longestSubarray(nums: Array[Int]): Int = \\n    nums.mkString.replaceAll(nums.max.toString, \"#\").split(\"[0-9]\").map(_.size).max\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2645284,
                "title": "java-simple-approach",
                "content": "A simple approach...\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        \\n        int max = nums[0];\\n        int index = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n                index = i;\\n            }\\n        }\\n        \\n        int maxLength = 0;\\n        int length = 1;\\n        for(int i = index + 1; i < nums.length; i++){\\n            if(nums[i] != max ){\\n                maxLength = Math.max(maxLength, length);\\n                length = 0;\\n                continue;\\n            }\\n            \\n            length++;\\n        }\\n        maxLength = Math.max(maxLength, length);\\n        \\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        \\n        int max = nums[0];\\n        int index = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n                index = i;\\n            }\\n        }\\n        \\n        int maxLength = 0;\\n        int length = 1;\\n        for(int i = index + 1; i < nums.length; i++){\\n            if(nums[i] != max ){\\n                maxLength = Math.max(maxLength, length);\\n                length = 0;\\n                continue;\\n            }\\n            \\n            length++;\\n        }\\n        maxLength = Math.max(maxLength, length);\\n        \\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644421,
                "title": "golang-o-n",
                "content": "```\\nfunc longestSubarray(nums []int) int {\\n    result, length, maxNum := 0, 0, 0\\n    for _, num := range nums {\\n        if num > maxNum {\\n            maxNum = num\\n        }\\n    }\\n    \\n    for _, num := range nums {\\n        if num == maxNum {\\n            length++\\n        } else {\\n            length = 0\\n        }\\n        result = max(result, length)\\n    }\\n    return result\\n}\\n\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestSubarray(nums []int) int {\\n    result, length, maxNum := 0, 0, 0\\n    for _, num := range nums {\\n        if num > maxNum {\\n            maxNum = num\\n        }\\n    }\\n    \\n    for _, num := range nums {\\n        if num == maxNum {\\n            length++\\n        } else {\\n            length = 0\\n        }\\n        result = max(result, length)\\n    }\\n    return result\\n}\\n\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2643613,
                "title": "bit-operation-properties-finding-the-longest-consecutive-m-s-where-m-max-nums-python",
                "content": "1- Some solution formats\\n```\\nclass Solution:\\n    def longestSubarray_v1(self, nums: List[int]) -> int:\\n        \"\"\"\\n        two-pass\\n        \"\"\"\\n        M = max(nums)\\n        res = 0\\n        cur = 0\\n        for y in nums:\\n            if y == M:\\n                cur += 1\\n            else:\\n                cur = 0\\n            res = max(res, cur)\\n        return res\\n    \\n    def longestSubarray_v2(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        M = max(nums)\\n        res = 0\\n        cur = 0\\n        for i in range(n):\\n            if i == 0:\\n                if nums[i] == M:\\n                    cur = 1\\n            else:\\n                if nums[i] == M:\\n                    if nums[i-1] == M:\\n                        cur += 1\\n                    else:\\n                        res = max(res, cur)\\n                        cur = 1\\n                else:\\n                    res = max(res, cur)\\n                    cur = 0\\n            if i == n - 1:\\n                res = max(res, cur)\\n        return res\\n    \\n    \\n    def longestSubarray(self, nums: List[int]) -> int:\\n        res = 0\\n        cur = 0 # length of consecutive cur_max elements when we examine a number y in nums \\n        cur_max = 0\\n        \\n        for y in nums:\\n            if y > cur_max:\\n                cur_max = y\\n                cur = 1\\n                res = 1\\n            elif y == cur_max:\\n                cur += 1\\n            else:\\n                cur = 0\\n            res = max(res, cur)\\n        return res              \\n```\\n2- Video Explanation: [Click Here](https://youtu.be/4M56dVWaejw;)\\n\\n3- Analysis or summary, and comparison\\n\\n-1. Method: find largest subarray array with elements value being max(nums).\\n\\n-2. Observation: for two nonnegative integers a, b, there holds: a & b <= min(a, b).\\n\\nDigest: at each bit position, bitwise AND will pick the smaller bit.\\n\\nE.g. 10 = 1010\\n     12 = 1100\\n\\n10 & 12 = 1000 = 8 <= min(10, 12); here strictly less.\\n\\nIn fact, if a == b, certaily a & b == a == b;\\nif a != b, a & b <= min(a, b) < max(a, b); i.e., a & b is strictly less than the larger.\\n\\n-3. Recap of the task: let M = max(nums)\\nfind longest subarray with all elements being M.\\n\\nThis is a routine task.\\n\\nIn Example 1, nums = [1,2,3,3,2,2], [3, 3] is the subarray which has length 2.\\n\\n-4. Extension:\\n\\nCompare with Leetcode 2411. Smallest Subarrays With Maximum Bitwise OR\\nFind an analysis in our channel for this \"Bitwise OR\" variant.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestSubarray_v1(self, nums: List[int]) -> int:\\n        \"\"\"\\n        two-pass\\n        \"\"\"\\n        M = max(nums)\\n        res = 0\\n        cur = 0\\n        for y in nums:\\n            if y == M:\\n                cur += 1\\n            else:\\n                cur = 0\\n            res = max(res, cur)\\n        return res\\n    \\n    def longestSubarray_v2(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        M = max(nums)\\n        res = 0\\n        cur = 0\\n        for i in range(n):\\n            if i == 0:\\n                if nums[i] == M:\\n                    cur = 1\\n            else:\\n                if nums[i] == M:\\n                    if nums[i-1] == M:\\n                        cur += 1\\n                    else:\\n                        res = max(res, cur)\\n                        cur = 1\\n                else:\\n                    res = max(res, cur)\\n                    cur = 0\\n            if i == n - 1:\\n                res = max(res, cur)\\n        return res\\n    \\n    \\n    def longestSubarray(self, nums: List[int]) -> int:\\n        res = 0\\n        cur = 0 # length of consecutive cur_max elements when we examine a number y in nums \\n        cur_max = 0\\n        \\n        for y in nums:\\n            if y > cur_max:\\n                cur_max = y\\n                cur = 1\\n                res = 1\\n            elif y == cur_max:\\n                cur += 1\\n            else:\\n                cur = 0\\n            res = max(res, cur)\\n        return res              \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643313,
                "title": "java-99-o-n-o-1",
                "content": "You just need to find maximum length of subarray containing maximum element of given array.  \\n\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        \\n        int maxLen = 0;\\n        int maxEle = 0;\\n        \\n        int tempLen = 1;\\n        int prev = nums[0];\\n        \\n        for(int i=1;i<nums.length;i++){\\n            \\n            if(nums[i]==prev){\\n                tempLen++;\\n            }else{\\n                \\n                if(prev>maxEle){\\n                    maxEle = prev;\\n                    maxLen = tempLen;\\n                }else if (prev==maxEle && tempLen>=maxLen){\\n                    maxLen = tempLen;\\n                }\\n                tempLen=1;\\n                prev=nums[i];\\n            }\\n            \\n        }\\n        \\n        if(prev>maxEle){\\n            maxLen = tempLen;\\n        }else if (prev==maxEle && tempLen>maxLen){\\n            maxLen = tempLen;\\n        }\\n        \\n        return maxLen;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        \\n        int maxLen = 0;\\n        int maxEle = 0;\\n        \\n        int tempLen = 1;\\n        int prev = nums[0];\\n        \\n        for(int i=1;i<nums.length;i++){\\n            \\n            if(nums[i]==prev){\\n                tempLen++;\\n            }else{\\n                \\n                if(prev>maxEle){\\n                    maxEle = prev;\\n                    maxLen = tempLen;\\n                }else if (prev==maxEle && tempLen>=maxLen){\\n                    maxLen = tempLen;\\n                }\\n                tempLen=1;\\n                prev=nums[i];\\n            }\\n            \\n        }\\n        \\n        if(prev>maxEle){\\n            maxLen = tempLen;\\n        }else if (prev==maxEle && tempLen>maxLen){\\n            maxLen = tempLen;\\n        }\\n        \\n        return maxLen;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643192,
                "title": "simple-c-solution-by-nishant-singh",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first we have to look at how we can approach for the problem. The maximum bitwise And we would get only if we have a subarray of only the largest number in the array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow we know what subarray we have to consider, we would simply find the maximum number using max_element function. Now make a for loop for i=0 to i<n. if nums[i]==max_element make cnt++; and also store the max length of such array and if the nums[i]!=max_element then set cnt=0;\\nreturn the max_length .\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        //sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int mx = *max_element(nums.begin(),nums.end());\\n        int cnt=0;\\n        int m=1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==mx){\\n                cnt++;\\n                m = max(cnt,m);\\n            }\\n            else{\\n                cnt =0;\\n            }\\n        }\\n        return m;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        //sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int mx = *max_element(nums.begin(),nums.end());\\n        int cnt=0;\\n        int m=1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==mx){\\n                cnt++;\\n                m = max(cnt,m);\\n            }\\n            else{\\n                cnt =0;\\n            }\\n        }\\n        return m;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643009,
                "title": "java-easy-intuitive-simple-method-explained",
                "content": "# Intuition\\nwe have to find the max element and then return length of consecutive \\nmax element subarray because max value of and can be obtained by max element so length of subarray consisting only max element is our answer\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int num : nums){\\n            max = Math.max(max,num);\\n        }\\n        int len = nums[0]==max ? 1 : 0;\\n        int olen = len;\\n        int prev = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            if(nums[i]==max){\\n                len++;\\n            }else{\\n                len = 0;\\n            }\\n            olen = Math.max(olen,len);\\n        }\\n        return olen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation",
                    "Brainteaser",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int num : nums){\\n            max = Math.max(max,num);\\n        }\\n        int len = nums[0]==max ? 1 : 0;\\n        int olen = len;\\n        int prev = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            if(nums[i]==max){\\n                len++;\\n            }else{\\n                len = 0;\\n            }\\n            olen = Math.max(olen,len);\\n        }\\n        return olen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642715,
                "title": "javascript-single-pass-sliding-window-greedy",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSubarray = function(nums) {\\n    let curWindow = {\\n        size: 0,\\n        tot: 0,\\n    }\\n    let maxWindow = {\\n        size: 0,\\n        tot: 0,\\n    }\\n    nums.map(num => {\\n        if(num > curWindow.tot) {\\n            curWindow.tot = num;\\n            curWindow.size = 1;\\n        } else {\\n            curWindow.tot &= num;\\n            curWindow.size += 1;\\n        }\\n        \\n        if(curWindow.tot > maxWindow.tot) {\\n            maxWindow.tot = curWindow.tot\\n            maxWindow.size = curWindow.size\\n        } else if(curWindow.tot === maxWindow.tot) {\\n            maxWindow.size = Math.max(maxWindow.size, curWindow.size)\\n        }\\n        \\n    })\\n    return maxWindow.size\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSubarray = function(nums) {\\n    let curWindow = {\\n        size: 0,\\n        tot: 0,\\n    }\\n    let maxWindow = {\\n        size: 0,\\n        tot: 0,\\n    }\\n    nums.map(num => {\\n        if(num > curWindow.tot) {\\n            curWindow.tot = num;\\n            curWindow.size = 1;\\n        } else {\\n            curWindow.tot &= num;\\n            curWindow.size += 1;\\n        }\\n        \\n        if(curWindow.tot > maxWindow.tot) {\\n            maxWindow.tot = curWindow.tot\\n            maxWindow.size = curWindow.size\\n        } else if(curWindow.tot === maxWindow.tot) {\\n            maxWindow.size = Math.max(maxWindow.size, curWindow.size)\\n        }\\n        \\n    })\\n    return maxWindow.size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2642124,
                "title": "c-simple-and-intuitive-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxi = *max_element(nums.begin(),nums.end());\\n        int lenSubarray = 0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] == maxi)\\n            {\\n                lenSubarray++;\\n                ans = max(ans,lenSubarray);\\n            }\\n            else\\n            {\\n                lenSubarray = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxi = *max_element(nums.begin(),nums.end());\\n        int lenSubarray = 0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] == maxi)\\n            {\\n                lenSubarray++;\\n                ans = max(ans,lenSubarray);\\n            }\\n            else\\n            {\\n                lenSubarray = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641470,
                "title": "simple-c-solution-beats-94-12",
                "content": "```\\nint longestSubarray(int* nums, int numsSize){\\n    int max = 0;\\n    for(int i=0; i<numsSize; i++){\\n        if(nums[i] > max){\\n            max = nums[i];\\n        }\\n    }\\n    \\n    int maxL = 0;\\n    int length = 0;\\n    \\n    for(int i=0; i<numsSize; i++){\\n        if(nums[i] == max || (nums[i] & max) == max) length++;\\n        else{\\n            if(length > maxL){\\n                maxL = length;\\n            }\\n            length = 0;\\n        }\\n    }\\n    \\n    if(length > maxL){\\n        return length;\\n    }\\n    return maxL;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint longestSubarray(int* nums, int numsSize){\\n    int max = 0;\\n    for(int i=0; i<numsSize; i++){\\n        if(nums[i] > max){\\n            max = nums[i];\\n        }\\n    }\\n    \\n    int maxL = 0;\\n    int length = 0;\\n    \\n    for(int i=0; i<numsSize; i++){\\n        if(nums[i] == max || (nums[i] & max) == max) length++;\\n        else{\\n            if(length > maxL){\\n                maxL = length;\\n            }\\n            length = 0;\\n        }\\n    }\\n    \\n    if(length > maxL){\\n        return length;\\n    }\\n    return maxL;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1730256,
                "content": [
                    {
                        "username": "adisinghal1506",
                        "content": "My observation of this question was-\nthe question said that we need to find that subarray which has a maximum AND sum out of all subarrays.\nso from this we can infer that max element in the whole array is the only 1 element whose subarray can give maximum AND ,which indicates that subarray can only have that maximum number in it or else alone it will be forming a subarray of size 1.\nso we can find maximum element in the array and check if it occur in a continuous subarray and return the respective length.\n\nhttps://leetcode.com/problems/longest-subarray-with-maximum-bitwise-and/solutions/2958042/easy-o-n-solution-using-cpp-faster-then-98/"
                    }
                ]
            }
        ]
    }
]