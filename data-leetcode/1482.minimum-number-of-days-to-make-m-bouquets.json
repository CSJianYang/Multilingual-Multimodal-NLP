[
    {
        "title": "Sum of Root To Leaf Binary Numbers",
        "question_content": "You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit.\n\n\tFor example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.\n\nFor all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers.\nThe test cases are generated so that the answer fits in a 32-bits integer.\n&nbsp;\nExample 1:\n\nInput: root = [1,0,1,0,1,0,1]\nOutput: 22\nExplanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n\nExample 2:\n\nInput: root = [0]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 1000].\n\tNode.val is 0 or 1.",
        "solutions": [
            {
                "id": 270025,
                "title": "java-c-python-recursive-solution",
                "content": "## **Intuition**\\nEasily decompose this problem into 2 sub-problem:\\n1. Find all path from root to leaves. DFS recursion should help do that.\\n2. Transform a path from base to base 10.\\n\\nYou can do this separately, and it will be a `O(N^2)` solution.\\nIn my solution, I combine them together.\\n\\n\\n## **Explanation**:\\nWe recursively pass the current value of path to the children.\\nIf `root == null`, no value, return 0.\\nIf `root != null`,\\nwe double the value from its parent and add the node\\'s value,\\nlike the process of transforming base 2 to base 10.\\n\\nIn the end of recursion,\\nif `root.left == root.right == null`,\\nreturn the current `val`.\\n<br>\\n\\n## **Complexity**:\\nTime `O(N)`\\nSpace `O(H)` for recursion.\\n<br>\\n\\n**Java:**\\n```\\n    public int sumRootToLeaf(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n\\n    public int dfs(TreeNode root, int val) {\\n        if (root == null) return 0;\\n        val = val * 2 + root.val;\\n        return root.left == root.right ? val : dfs(root.left, val) + dfs(root.right, val);\\n    }\\n```\\n\\n**C++:**\\n```\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (!root) return 0;\\n        val = (val * 2 + root->val);\\n        return root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));\\n    }\\n```\\n\\n**Python:**\\n```\\n    def sumRootToLeaf(self, root, val=0):\\n        if not root: return 0\\n        val = val * 2 + root.val\\n        if root.left == root.right: return val\\n        return self.sumRootToLeaf(root.left, val) + self.sumRootToLeaf(root.right, val)\\n```\\n\\n**Update 2019-04-08**\\nIn the previous version of problem,\\nthe length of path may exceed 32 and it will be a huge integer.\\nSo it request to return the number mod by 10^9+7.\\nNow it notes that The \"answer will not exceed 2^31 - 1.\"\\nNow it removes this condition to keep this problem as a easy one.",
                "solutionTags": [],
                "code": "```\\n    public int sumRootToLeaf(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n\\n    public int dfs(TreeNode root, int val) {\\n        if (root == null) return 0;\\n        val = val * 2 + root.val;\\n        return root.left == root.right ? val : dfs(root.left, val) + dfs(root.right, val);\\n    }\\n```\n```\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (!root) return 0;\\n        val = (val * 2 + root->val);\\n        return root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));\\n    }\\n```\n```\\n    def sumRootToLeaf(self, root, val=0):\\n        if not root: return 0\\n        val = val * 2 + root.val\\n        if root.left == root.right: return val\\n        return self.sumRootToLeaf(root.left, val) + self.sumRootToLeaf(root.right, val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1681682,
                "title": "well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it",
                "content": "Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\n\\n\\n\\n**So Ladies n Gentlemen without any further due let\\'s start,**\\nSo, here in this problem what we have to do all the nodes will have either **0** or **1**. So, starting from **root node** and traverse the tree, when you traverse the tree and you reach **leaf node** return the **sum** in binary from root to leaf in & return in **decimal numbers**\\n\\n**Approach Explained :**\\n\\n**Summary :**\\nLet us traverse our tree and change values of nodes, so when we reach leaf we will have in this leaf exactly the number we need to add to total sum. Imagine, we have path 10110, then let us look at sequence: 1, 10, 101, 1011, 10110, which is equivalent to 1, 2, 5, 11, 22.\\n\\n* If we reached leaf, add value of this leaf to total sum.\\n* Check left and right children and if they exist, update their values; run dfs for these children.\\n\\n**Detailed Explanation :**\\nLet\\'s understand with an example tree,\\n\\n![image](https://assets.leetcode.com/users/images/29584bd5-5449-4147-92d3-18ec1067f27a_1641864447.0021555.png)\\n\\n\\nIf we go from **1 to 0** i.e **left child** & similar for **1 to 1** i.e. **right child** and similar till leaf node. Overall there are 4 leafs path. So, we will have **4 root to leaf path**. So, one is **1 -> 0 -> 0** this left most path, second is **1 -> 0 -> 1** this is 2nd path, then **1 -> 1 -> 0** this is 3rd path & the last **1 -> 1 -> 1** 4th path. \\nSo, these all are the root to leaf path we have and these are **binary representation**. So, if we **convert** them to **decimal** they will become **4, 5, 6, 7**. And **sum** them up which is **22**. and we have to **return 22** as the answer.\\n\\nSo,  first of all when we are converting **binary** no **to** the **decimal**, what we will do we will start from the least significant bit & multiply it with **2^0** with **whatever** **no**. present there, then **2^1 with whatever no**. there & then **2^2** **with whatever no** and **add** them. So, this is how it become **1 * 4 + 2 * 0 + 1 * 0** which is equals to **4** and similar for other as well. So, this is the basic idea what we  have & we use this idea over here.\\n`Let me show you in a diagram, what i mean`\\n![image](https://assets.leetcode.com/users/images/29517c99-2b04-4ebc-b707-89a37c56e335_1641865327.2959735.png)\\n\\n\\nOne of the **brute force idea to solve this** is like, 1st generate all the binary representation root to leaf path. Either store it as a list of list of integer or list of string & then convert after finding all the root to leaf path & convert each path to the decimal and then accumulate the sum and return. So, this is like a brute force solution.\\n\\nBut, we will make use of **recursion** to solve this problem.\\nAnd for traversing on each nodes we will use help of **PreOrder traversal**. Which states **\"n l r\"** i.e. **node - left - right**\\n\\nI hope all point\\'s are clear,\\n**Now let\\'s code it:**\\n\\n*code each n every line explain :* `Similar for C++. Java. Python` **{Only Syntax Difference}** approach same\\n\\nStep 1 :\\n```\\n{// call to a preorder traversal function & passing the value root node & sum variable intialize with 0;\\n        return sumRootToLeaf(root, 0); \\n```\\nStep 2 :\\n```\\nint sumRootToLeaf(TreeNode root, int sum){ // calling the helper method\\n        // base condition\\n        if(root == null) return 0; // first we will check if root is null, then there is no node, simply return 0;\\n        sum = (2 * sum) + root.val; // calculate sum of binary no.s into decimal no.s\\n        // checking if, current node we are processing is leaf & both left & right child node are null, if that\\'s the case return sum;\\n        if(root.left == null && root.right == null) return sum;\\n        // and finally we will call both left subtree & right subtree and add them up\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n```\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n    public int sumRootToLeaf(TreeNode root, int sum){\\n        if(root == null) return 0;\\n        sum = (2 * sum) + root.val;\\n        if(root.left == null && root.right == null) return sum;\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\n    int sumRootToLeaf(TreeNode* root, int sum){\\n        if(!root) return 0;\\n        sum = (2 * sum) + root->val;\\n        if(!root->left && !root->right) return sum;\\n        return sumRootToLeaf(root->left, sum) + sumRootToLeaf(root->right, sum);\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n    \\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        def sumRootToLeaf(root, res): # here; \"res\" is \"sum\"\\n            if root == None: return 0\\n            res = (2 * res) + root.val\\n            if root.left == None and root.right == None: return res\\n            return sumRootToLeaf(root.left, res) + sumRootToLeaf(root.right, res)\\n        \\n        return sumRootToLeaf(root, 0)\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N) where N is a number of nodes, since one has to visit each node.\\n\\n* **Space Complexity :-** BigO(H) where H is height of tree, Considering recursion stack it in O(H), if we dont consider it. Then O(1)\\n\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n{// call to a preorder traversal function & passing the value root node & sum variable intialize with 0;\\n        return sumRootToLeaf(root, 0); \\n```\n```\\nint sumRootToLeaf(TreeNode root, int sum){ // calling the helper method\\n        // base condition\\n        if(root == null) return 0; // first we will check if root is null, then there is no node, simply return 0;\\n        sum = (2 * sum) + root.val; // calculate sum of binary no.s into decimal no.s\\n        // checking if, current node we are processing is leaf & both left & right child node are null, if that\\'s the case return sum;\\n        if(root.left == null && root.right == null) return sum;\\n        // and finally we will call both left subtree & right subtree and add them up\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n```\n```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n    public int sumRootToLeaf(TreeNode root, int sum){\\n        if(root == null) return 0;\\n        sum = (2 * sum) + root.val;\\n        if(root.left == null && root.right == null) return sum;\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int sumRootToLeaf(TreeNode* root, int sum){\\n        if(!root) return 0;\\n        sum = (2 * sum) + root->val;\\n        if(!root->left && !root->right) return sum;\\n        return sumRootToLeaf(root->left, sum) + sumRootToLeaf(root->right, sum);\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n    \\n};\\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        def sumRootToLeaf(root, res): # here; \"res\" is \"sum\"\\n            if root == None: return 0\\n            res = (2 * res) + root.val\\n            if root.left == None and root.right == None: return res\\n            return sumRootToLeaf(root.left, res) + sumRootToLeaf(root.right, res)\\n        \\n        return sumRootToLeaf(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270600,
                "title": "java-simple-dfs",
                "content": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        dfs(root, 0);\\n        return ans;\\n    }\\n    \\n    int ans = 0;\\n    void dfs(TreeNode root, int val){\\n        if(root == null) return;\\n        val = val << 1 | root.val;\\n        if(root.left == null && root.right == null) ans += val;\\n        dfs(root.left, val);\\n        dfs(root.right, val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        dfs(root, 0);\\n        return ans;\\n    }\\n    \\n    int ans = 0;\\n    void dfs(TreeNode root, int val){\\n        if(root == null) return;\\n        val = val << 1 | root.val;\\n        if(root.left == null && root.right == null) ans += val;\\n        dfs(root.left, val);\\n        dfs(root.right, val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835906,
                "title": "c-2-solutions-recursive-iterative-dfs-explained-left-shift-and-simple-math",
                "content": "**Explanation**\\nThe key here is tree traversal and generating the numbers as we go from the root towards the leaves.\\nUsing shift operators, we can always keep the current value, `cur_val` in base 10 and as soon as we reach any leaf, we add this current value to the running answer.\\n\\n`cur_val = (cur_val << 1) | rt->val;`\\n`cur_val << 1` means we\\'re shifting the bits of `cur_val` to the left by 1 place, which is equivalent to multiplying `cur_val` by 2 (in base 10). Bitwise OR is used to set a particular bit. Let\\'s take an example!\\nSuppose, the root-to-leaf path is `1->0->1`.\\nThen, at the root, initially `cur_val` is 0. We multiply it by 2 and perform bitwise OR with 1 which makes `cur_val` 1.\\nNext, `cur_val` is 1. We multiply it by 2 and perform bitwise OR with 0 which makes `cur_val` 2.\\nLast, at the leaf, `cur_val` is 2. We multiply it by 2 and perform bitwise OR with 1 which makes `cur_val` 5.\\n101 (base 2) is 5 (base 10).\\n\\n----------------------------------------------\\n\\n**Recursive Code (using Left Shift operator)**\\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeafHelper(TreeNode* rt, int cur_val) {\\n        if(! rt) return 0;\\n        \\n        cur_val = (cur_val << 1) | rt->val;\\n        \\n        if(!rt->left && !rt->right)\\n\\t\\t\\treturn cur_val;\\n\\t\\t\\t\\n        return sumRootToLeafHelper(rt->left, cur_val) + sumRootToLeafHelper(rt->right, cur_val);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* rt) {\\n        return sumRootToLeafHelper(rt, 0);\\n    }\\n};\\n```\\n\\n-------------\\n\\nWe can also combine these two functions in the same given function using a default argument to get an even more compact solution (Credits to [@guybrush2323](https://leetcode.com/guybrush2323/ )):\\n\\n```\\nstatic int sumRootToLeaf(const TreeNode* r, uint32_t sum = 0) {\\n        if (!r) return 0;\\n        sum |= r->val;\\n        if (!r->left && !r->right) return sum; // leaf\\n        sum <<= 1;\\n        return sumRootToLeaf(r->left, sum) + sumRootToLeaf(r->right, sum);\\n}\\n```\\n\\n------------------------------------------------------\\n\\n**Iterative Code (using Simple Math)**\\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* rt) {\\n        if(! rt) return 0;\\n        \\n        int ans = 0;\\n        stack<pair<TreeNode*,int>> st;\\n        st.push({rt,0});\\n        \\n        while(! st.empty()) {\\n            auto curp = st.top(); st.pop();\\n            TreeNode* cur = curp.first;\\n            int cur_val = curp.second;\\n            \\n            // Equivalent to left shift by 1 and then ORing by cur->val.\\n            cur_val = cur_val*2 + cur->val;\\n            \\n            if(!cur->left && !cur->right)\\n                ans += cur_val;\\n            \\n            if(cur->left) st.push({cur->left, cur_val});\\n            if(cur->right) st.push({cur->right, cur_val});\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n----------------------------------------\\nPlease feel free to ask your doubts in the comments. Please **Upvote** to help others!\\nHave a great day!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeafHelper(TreeNode* rt, int cur_val) {\\n        if(! rt) return 0;\\n        \\n        cur_val = (cur_val << 1) | rt->val;\\n        \\n        if(!rt->left && !rt->right)\\n\\t\\t\\treturn cur_val;\\n\\t\\t\\t\\n        return sumRootToLeafHelper(rt->left, cur_val) + sumRootToLeafHelper(rt->right, cur_val);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* rt) {\\n        return sumRootToLeafHelper(rt, 0);\\n    }\\n};\\n```\n```\\nstatic int sumRootToLeaf(const TreeNode* r, uint32_t sum = 0) {\\n        if (!r) return 0;\\n        sum |= r->val;\\n        if (!r->left && !r->right) return sum; // leaf\\n        sum <<= 1;\\n        return sumRootToLeaf(r->left, sum) + sumRootToLeaf(r->right, sum);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* rt) {\\n        if(! rt) return 0;\\n        \\n        int ans = 0;\\n        stack<pair<TreeNode*,int>> st;\\n        st.push({rt,0});\\n        \\n        while(! st.empty()) {\\n            auto curp = st.top(); st.pop();\\n            TreeNode* cur = curp.first;\\n            int cur_val = curp.second;\\n            \\n            // Equivalent to left shift by 1 and then ORing by cur->val.\\n            cur_val = cur_val*2 + cur->val;\\n            \\n            if(!cur->left && !cur->right)\\n                ans += cur_val;\\n            \\n            if(cur->left) st.push({cur->left, cur_val});\\n            if(cur->right) st.push({cur->right, cur_val});\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681811,
                "title": "c-simple-intuitive-dfs-solution-w-explanation",
                "content": "* We are given a binary tree with all node values as ```0```s and ```1```s.\\n* For all leaves in the tree, we need to sum the numbers represented by the path from the root to that leaf and return the sum of these numbers.\\n\\n**Explanation :**\\nIf we\\'re given a binary number, say ```num = 11010```, we know how to convert it into decimal form while traversing from right to left.\\nWe can do this while traversing from left to right also. \\nWe start with  x=0, as long as we have bits left, repeat the following : \\n      1. Double the number  x . Remove the first bit (most significant) and add it to x . \\n      2. When this ends, return  x .\\nExample : \\n```\\nn = \\'100110\\',    x = 0\\nn =  \\'00110\\',    x = 0*2 + 1 = 1\\nn =   \\'0110\\',    x = 1*2 + 0 = 2\\nn =    \\'110\\',    x = 2*2 + 0 = 4\\nn =     \\'10\\',    x = 4*2 + 1 = 9\\nn =      \\'0\\',    x = 9*2 + 1 = 19\\nn =      \\' \\',    x = 19*2 +0 = 38\\n```\\n\\nKnowing this, this problem can be solved using simple DFS.\\n\\n**ALGORITHM :**\\n* Initialize ```ans = 0``` and ```buff=0```.\\n* The integer ```buff``` is passed as an argument to the function ```bfs(root, buff)``` and whenever we reach a leaf node, the decimal number stored by buffer is added to ```ans``` and we traverse for the next node (ie., parent\\'s right node).\\n* After we\\'ve traversed the whole tree, we return the ```ans```.\\n\\nTime Complexity : O(N) (Each node is visited at most 3 times, one while calling the method on the root and 2 visits when returning from the root\\u2019s left and right recursion calls. So overall time complexity will be linear only.)\\n\\nSpace Complexity : O(1) (Exclusing the recursive stack space)\\n\\n**Code :**\\n```\\nclass Solution {\\n    int ans=0;\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int buff = 0;\\n        dfs(root, buff);\\n        return ans;    \\n    }\\n    \\n    void dfs(TreeNode *root, int buff){\\n        buff = buff*2 + root->val;\\n        if(!root->left && !root->right){\\n            ans += buff;\\n            return;\\n        }\\n        if(root->left) dfs(root->left, buff);\\n        if(root->right) dfs(root->right, buff);\\n    }\\n};\\n```\\n\\n**If you like my solution & explanation, please upvote my post :)**\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```0```\n```1```\n```num = 11010```\n```\\nn = \\'100110\\',    x = 0\\nn =  \\'00110\\',    x = 0*2 + 1 = 1\\nn =   \\'0110\\',    x = 1*2 + 0 = 2\\nn =    \\'110\\',    x = 2*2 + 0 = 4\\nn =     \\'10\\',    x = 4*2 + 1 = 9\\nn =      \\'0\\',    x = 9*2 + 1 = 19\\nn =      \\' \\',    x = 19*2 +0 = 38\\n```\n```ans = 0```\n```buff=0```\n```buff```\n```bfs(root, buff)```\n```ans```\n```ans```\n```\\nclass Solution {\\n    int ans=0;\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int buff = 0;\\n        dfs(root, buff);\\n        return ans;    \\n    }\\n    \\n    void dfs(TreeNode *root, int buff){\\n        buff = buff*2 + root->val;\\n        if(!root->left && !root->right){\\n            ans += buff;\\n            return;\\n        }\\n        if(root->left) dfs(root->left, buff);\\n        if(root->right) dfs(root->right, buff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339306,
                "title": "python-iterative-and-recursive-with-comments",
                "content": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def sumRootToLeaf(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        # Logic 1: Recursive traverse - 100 pass 63% faster\\n        \\n        # Collect all the path in binary in a list\\n        self.path_to_leaf = []\\n        # Track total binary sum and return result\\n        self.total_binary_sum = 0\\n        \\n        # Traverse tree function\\n        def traverse(node, path):\\n            # If not leaf node, record the path left or right\\n            if node.left:\\n                traverse(node.left, path+str(node.val))\\n            if node.right:\\n                traverse(node.right, path+str(node.val))\\n            \\n            # Leaf node detect and record path\\n            if not node.left and not node.right:\\n                path += str(node.val)\\n                self.path_to_leaf.append(path)\\n                self.total_binary_sum += int(path, 2)\\n        \\n        traverse(root, \"\")\\n        print(self.path_to_leaf)\\n        return self.total_binary_sum\\n```\\n\\n```python\\n        # Logic 2: Iterative method - 100 pass 83 percent faster\\n        # * Each element of the list has the node and the path to it\\n        \\n        stack = [[root, \"\"]] # iteration to keep track\\n        result = 0 # result holder\\n        \\n        # Traverse nodes by stacking them\\n        while stack:\\n            # current node and path tracking\\n            current, path = stack.pop(0)\\n            \\n            # traverse with path \\n            if current.left:\\n                stack.append([current.left, path+str(current.val)])\\n            if current.right:\\n                stack.append([current.right, path+str(current.val)])\\n            \\n            # leaf node condition when we update result\\n            if not current.left and not current.right:\\n                path += str(current.val)\\n                result += int(path, 2)\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def sumRootToLeaf(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        # Logic 1: Recursive traverse - 100 pass 63% faster\\n        \\n        # Collect all the path in binary in a list\\n        self.path_to_leaf = []\\n        # Track total binary sum and return result\\n        self.total_binary_sum = 0\\n        \\n        # Traverse tree function\\n        def traverse(node, path):\\n            # If not leaf node, record the path left or right\\n            if node.left:\\n                traverse(node.left, path+str(node.val))\\n            if node.right:\\n                traverse(node.right, path+str(node.val))\\n            \\n            # Leaf node detect and record path\\n            if not node.left and not node.right:\\n                path += str(node.val)\\n                self.path_to_leaf.append(path)\\n                self.total_binary_sum += int(path, 2)\\n        \\n        traverse(root, \"\")\\n        print(self.path_to_leaf)\\n        return self.total_binary_sum\\n```\n```python\\n        # Logic 2: Iterative method - 100 pass 83 percent faster\\n        # * Each element of the list has the node and the path to it\\n        \\n        stack = [[root, \"\"]] # iteration to keep track\\n        result = 0 # result holder\\n        \\n        # Traverse nodes by stacking them\\n        while stack:\\n            # current node and path tracking\\n            current, path = stack.pop(0)\\n            \\n            # traverse with path \\n            if current.left:\\n                stack.append([current.left, path+str(current.val)])\\n            if current.right:\\n                stack.append([current.right, path+str(current.val)])\\n            \\n            # leaf node condition when we update result\\n            if not current.left and not current.right:\\n                path += str(current.val)\\n                result += int(path, 2)\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628160,
                "title": "c-solution-with-detailed-explanation",
                "content": "```\\nFirst for this question u should be able to print all paths from root to leaf\\nCuz only after this do we convert it to decimal and proceed\\nI would suggest u guys to solve this first and then jump into gfg and try print root to leaf paths\\n\\nSo instead of printing the solution we call a funcion called convert to decimal.\\nNote that when u have been pushing elements into ur array the one with 0 index is ur most significant bit.\\n\\nSo to covert it all we have to do is n=n*2+v[i] where i is from 0 to v.size()-1\\n\\nCode:-\\n\\n    int ans=0;\\n    int convert_decimal(vector<int> v)\\n    {\\n        int n=0;\\n        for(int i=0;i<v.size();i++)\\n            n=n*2+v[i];\\n        return n;\\n    }\\n    void findpath(TreeNode* root,vector<int> t)\\n    {\\n        if(!root)return;\\n        t.push_back(root->val);\\n        if(!root->left && !root->right)ans+=convert_decimal(t);\\n        findpath(root->left,t);\\n        findpath(root->right,t);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        if(!root)return 0;\\n        vector<int> t;\\n        findpath(root,t);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nFirst for this question u should be able to print all paths from root to leaf\\nCuz only after this do we convert it to decimal and proceed\\nI would suggest u guys to solve this first and then jump into gfg and try print root to leaf paths\\n\\nSo instead of printing the solution we call a funcion called convert to decimal.\\nNote that when u have been pushing elements into ur array the one with 0 index is ur most significant bit.\\n\\nSo to covert it all we have to do is n=n*2+v[i] where i is from 0 to v.size()-1\\n\\nCode:-\\n\\n    int ans=0;\\n    int convert_decimal(vector<int> v)\\n    {\\n        int n=0;\\n        for(int i=0;i<v.size();i++)\\n            n=n*2+v[i];\\n        return n;\\n    }\\n    void findpath(TreeNode* root,vector<int> t)\\n    {\\n        if(!root)return;\\n        t.push_back(root->val);\\n        if(!root->left && !root->right)ans+=convert_decimal(t);\\n        findpath(root->left,t);\\n        findpath(root->right,t);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        if(!root)return 0;\\n        vector<int> t;\\n        findpath(root,t);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681647,
                "title": "python3-5-lines-explained",
                "content": "We use the recursive Depth First Search here to build all binary numbers from the root-to-leaf path and sum them together. When a leaf node is reached, the function returns the built number. For the rest of the nodes, the function simply sums results from recursive calls. For building the binary number in the path we use a binary operation `(path << 1)` which shifts all bits to the left by one bit to free space for the current bit which we simply add to the path. Example:\\n\\n`path=0  => (path<<1) + 1 = 01`\\n`path=01 => (path<<1) + 1 = 11`\\n`path=11 => (path<<1) + 0 = 110`\\n`path=110 => (path<<1) + 1 = 1101`\\n\\nTime: **O(N)** - for DFS\\nSpace: **O(N)** - recursive stack for binary tree is equal to the tree height\\n\\nRuntime: 36 ms, faster than **80.51%** of Python3 online submissions for Sum of Root To Leaf Binary Numbers.\\nMemory Usage: 14.4 MB, less than **96.20%** of Python3 online submissions for Sum of Root To Leaf Binary Numbers.\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node, path):\\n            if not node: return 0\\n\\n            path = (path << 1) + node.val\\n\\t\\t\\t\\n            if not node.left and not node.right:\\n                return path\\n            \\n            return dfs(node.left, path) + dfs(node.right, path)\\n            \\n        return dfs(root, 0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node, path):\\n            if not node: return 0\\n\\n            path = (path << 1) + node.val\\n\\t\\t\\t\\n            if not node.left and not node.right:\\n                return path\\n            \\n            return dfs(node.left, path) + dfs(node.right, path)\\n            \\n        return dfs(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835958,
                "title": "python-2-easy-recursion-solutions-explained",
                "content": "Let us traverse our tree and change values of nodes, so when we reach leaf we will have in this leaf exactly the number we need to add to total sum. Imagine, we have path `10110`, then let us look at sequence: `1, 10, 101, 1011, 10110`, which is equivalent to `1, 2, 5, 11, 22`. \\n\\n1. If we reached leaf, add value of this leaf to total sum.\\n2. Check left and right children and if they exist, update their values; run dfs for these children.\\n\\n**Complexity**: time complexity is `O(n)`: to traverse our tree. Space complexity is `O(h)` for dfs stack. Note, that we change our tree in process, but it can be easily avoided: instead of changing values we can return value for `dfs` function.\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root):\\n        def dfs(node):\\n            if not node.left and not node.right: self.sum += node.val\\n            for child in filter(None, [node.left, node.right]):\\n                child.val += node.val * 2\\n                dfs(child)\\n          \\n        self.sum = 0\\n        dfs(root)\\n        return self.sum\\n```\\n\\n### Solution 2: without changing tree\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root):\\n        def dfs(node, Q):\\n            if not node.left and not node.right: self.sum += Q\\n            for child in filter(None, [node.left, node.right]):\\n                dfs(child, Q*2 + child.val)\\n          \\n        self.sum = 0\\n        dfs(root, root.val)\\n        return self.sum\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root):\\n        def dfs(node):\\n            if not node.left and not node.right: self.sum += node.val\\n            for child in filter(None, [node.left, node.right]):\\n                child.val += node.val * 2\\n                dfs(child)\\n          \\n        self.sum = 0\\n        dfs(root)\\n        return self.sum\\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root):\\n        def dfs(node, Q):\\n            if not node.left and not node.right: self.sum += Q\\n            for child in filter(None, [node.left, node.right]):\\n                dfs(child, Q*2 + child.val)\\n          \\n        self.sum = 0\\n        dfs(root, root.val)\\n        return self.sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387149,
                "title": "java-100-beats-time-and-space-detailed-explanation",
                "content": "The key insight (or the AHA moment!) to this problem lies in the fact that the path shares nodes and so computation required to calculate the sum can be shared. By avoiding repeated computation, we can significantly bring down the runtime *O(n)* and space time *O(h)* complexity of this solution, where n is the number of total nodes in the tree and h is the height of the tree.\\n\\nThe computation we are optimizing is the conversion of base-2 number to base-10 number. The way you would usually convert a base-2 to base-10 number is with the formula below:\\n\\n` \\n2^n * nth bit + 2^n-1 * n-1th bit + ... + 2^0 * 0th bit\\n`\\n\\nSo in a brute force solution, we would calculate the path from root to leaf and then apply the formula above. Then we would sum up all the results to reach the final sum. BUT WE ARE SMARTER THAN THAT, SO WE CAN DO BETTER!\\n\\nIf you observe the formula above, we are multiplying the Most Significant Bit, i.e. n, n times by 2 and the Least Significant Bit 0 times by 2. If we are to share this computation as we iterate through the tree paths from Most Significant Bit to the Least Significant Bit, we can multiply each bit by 2 on every call of this function. This means that when we have reached a leaf, which will contain the 0th bit, we would\\'ve have multiplied each preceding bit (n,n-1,n-2)th times by 2, respectively. The result will be equivalent to the formula we have described above. \\n\\n**VOILA**! We have optimized the solution!\\n\\nThe code below uses `parentNodeSum` to keep track of the sum calculated until the `nth node` and then multiplies that sum by 2. Then it adds the value of the current node (i.e. `n-1th node` ) to the product of that.\\n\\nIn conclusion:\\n\\n` \\n2^n * nth bit + 2^n-1 * n-1th bit + ... + 2^0 * 0th bit\\n`\\n\\nWill be equivalent to \\n\\n`[2 * (parentSumNode) + Current Bit] //executed every time the function iterates from root to leaf.`\\n\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return pathSumRootToLeaf(root, 0);\\n    }\\n    \\n    private int pathSumRootToLeaf(TreeNode root, int parentNodeSum){\\n        if(root == null) return 0;\\n        \\n        parentNodeSum = 2 * parentNodeSum + root.val;\\n        if(root.left == null && root.right == null){\\n            return parentNodeSum;\\n        }\\n        \\n        return pathSumRootToLeaf(root.left, parentNodeSum) + pathSumRootToLeaf(root.right, parentNodeSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return pathSumRootToLeaf(root, 0);\\n    }\\n    \\n    private int pathSumRootToLeaf(TreeNode root, int parentNodeSum){\\n        if(root == null) return 0;\\n        \\n        parentNodeSum = 2 * parentNodeSum + root.val;\\n        if(root.left == null && root.right == null){\\n            return parentNodeSum;\\n        }\\n        \\n        return pathSumRootToLeaf(root.left, parentNodeSum) + pathSumRootToLeaf(root.right, parentNodeSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420459,
                "title": "java-simple-dfs-solution",
                "content": "```\\nint sum = 0;\\npublic int sumRootToLeaf(TreeNode root) {\\n\\tdfs(root,\"\");\\n\\treturn sum;\\n}\\n\\npublic void dfs(TreeNode root, String curr) {\\n\\tif(root==null) return;\\n\\tif(root.right==null && root.left==null)\\n\\t\\tsum += Integer.parseInt(curr+root.val,2);\\n\\tdfs(root.right, curr+root.val);\\n\\tdfs(root.left, curr+root.val);    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint sum = 0;\\npublic int sumRootToLeaf(TreeNode root) {\\n\\tdfs(root,\"\");\\n\\treturn sum;\\n}\\n\\npublic void dfs(TreeNode root, String curr) {\\n\\tif(root==null) return;\\n\\tif(root.right==null && root.left==null)\\n\\t\\tsum += Integer.parseInt(curr+root.val,2);\\n\\tdfs(root.right, curr+root.val);\\n\\tdfs(root.left, curr+root.val);    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681710,
                "title": "c-java-python-1-line-2-solutions-image-explanation-top-down-and-bottom-up",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* Key Point\\n\\t* `pre` is the sum of prefix of path from root to current node **NOT Inclusive**\\n* Top-Down\\n\\t* DFS Traverse the tree from root to every leaf, once we arrived at a leaf, add the sum of path from root to leaf to the final answer\\n* Bottom-Up\\n\\t* After arriving at a leaf, return the sum of path bottom-up to the root.\\n\\n![image](https://assets.leetcode.com/users/images/2686b5d7-bc15-42c6-96ac-55d95119c67e_1641884337.480884.png)\\n\\n\\n\\n**Top-Down**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void search(TreeNode* node, int pre=0) {    \\n        if (!node->left and !node->right) // node is a leaf node, return the sum of path from root to node\\n            // this->ans += pre << 1 | node->val; // also work\\n            this->ans += pre * 2 + node->val;\\n        if (node->left) // node.left is not None, recursively find the sum node to leaf\\n            // search(node->left, pre << 1 | node->val); // also work\\n            search(node->left, pre * 2 + node->val);\\n        if (node->right) // node.right is not None, recursively find the sum node to leaf\\n            // search(node->right, pre << 1 | node->val); // also work\\n            search(node->right, pre * 2 + node->val);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        search(root);\\n        return this->ans;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.ans = 0\\n\\n    def search(self, node, pre=0):  # pre is sum of path from root to parent of node\\n        if node.left is None and node.right is None:  # node is a leaf node, add the path sum to final answer\\n            # self.ans += pre << 1 | node.val  # also work\\n            self.ans += pre * 2 + node.val\\n            \\n        if node.left:  # node.left is not None, recursively find the sum node to leaf\\n            # self.search(node.left, pre << 1 | node.val)  # also work\\n            self.search(node.left, pre * 2 + node.val)\\n        if node.right:  # node.right is not None, recursively find the sum node to leaf\\n            # self.search(node.right, pre << 1 | node.val)  # also work\\n            self.search(node.right, pre * 2 + node.val)\\n\\n    def sumRootToLeaf(self, root):\\n        self.search(root, 0)\\n        return self.ans\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int ans = 0;\\n    \\n    public void search(TreeNode node, int pre) {\\n        if (node.left == null && node.right == null) // node is a leaf node, return the sum of path from root to node\\n            // this.ans += pre << 1 | node.val; // also work\\n            this.ans += pre * 2 + node.val; \\n            \\n        if (node.left != null) // node.left is not None, recursively find the sum node to leaf\\n            // search(node.left, pre << 1 | node.val); // also work\\n            search(node.left, pre * 2 + node.val);\\n        \\n        if (node.right != null) // node.right is not None, recursively find the sum node to leaf\\n            // search(node.right, pre << 1 | node.val); // also work\\n            search(node.right, pre * 2 + node.val);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        search(root, 0);\\n        return this.ans;\\n    }\\n}\\n```\\n**Bottom-Up**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* node, int pre=0) { // pre is sum of path from root to parent of node\\n        if (!node->left and !node->right) // node is a leaf node, return the sum of path from root to node\\n            // return pre << 1 | node->val; // also work\\n\\t\\t\\treturn pre * 2 + node->val;\\n        int ans = 0;\\n        if (node->left) // node.left is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node->left, pre << 1 | node->val); // also work\\n\\t\\t\\tans += sumRootToLeaf(node->left, pre * 2 + node->val);\\n        if (node->right) // node.right is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node->right, pre << 1 | node->val); // also work\\n\\t\\t\\tans += sumRootToLeaf(node->right, pre * 2 + node->val);\\n        return ans;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, node, pre=0):  # pre is sum of path from root to parent of node\\n        if node.left is None and node.right is None:  # node is a leaf node, return the sum of path from root to node\\n            # return pre << 1 | node.val  # also work\\n\\t\\t\\treturn pre * 2 + node.val\\n        ans = 0\\n        if node.left:  # node.left is not None, recursively find the sum node to leaf\\n            # ans += self.sumRootToLeaf(node.left, pre << 1 | node.val)  # also work\\n\\t\\t\\tans += self.sumRootToLeaf(node.left, pre * 2 + node.val)\\n        if node.right:  # node.right is not None, recursively find the sum node to leaf\\n            # ans += self.sumRootToLeaf(node.right, pre << 1 | node.val)  # also work\\n\\t\\t\\tans += self.sumRootToLeaf(node.right, pre * 2 + node.val) \\n        return ans\\n```\\n\\n**Python One-liner**\\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, node, pre=0):  # modified from the above one, don\\'t take it seriously\\n        return pre * 2 + node.val if node.left is None and node.right is None else (\\n                    self.sumRootToLeaf(node.left, pre * 2 + node.val) if node.left else 0\\n                                                                                   ) + (\\n                            self.sumRootToLeaf(node.right, pre * 2 + node.val) if node.right else 0\\n                                                                                       )\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode node, int pre) { // pre is sum of path from root to parent of node\\n        if (node.left == null && node.right == null) // node is a leaf node, return the sum of path from root to node\\n            // return pre << 1 | node.val; // also work\\n            return pre * 2 + node.val;\\n        int ans = 0;\\n        if (node.left != null) // node.left is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node.left, pre << 1 | node.val); // also work\\n            ans += sumRootToLeaf(node.left, pre * 2 + node.val);\\n        if (node.right != null) // node.right is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node.right, pre << 1 | node.val); // also work\\n            ans += sumRootToLeaf(node.right, pre * 2 + node.val);\\n        return ans;\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n}\\n```\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void search(TreeNode* node, int pre=0) {    \\n        if (!node->left and !node->right) // node is a leaf node, return the sum of path from root to node\\n            // this->ans += pre << 1 | node->val; // also work\\n            this->ans += pre * 2 + node->val;\\n        if (node->left) // node.left is not None, recursively find the sum node to leaf\\n            // search(node->left, pre << 1 | node->val); // also work\\n            search(node->left, pre * 2 + node->val);\\n        if (node->right) // node.right is not None, recursively find the sum node to leaf\\n            // search(node->right, pre << 1 | node->val); // also work\\n            search(node->right, pre * 2 + node->val);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        search(root);\\n        return this->ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.ans = 0\\n\\n    def search(self, node, pre=0):  # pre is sum of path from root to parent of node\\n        if node.left is None and node.right is None:  # node is a leaf node, add the path sum to final answer\\n            # self.ans += pre << 1 | node.val  # also work\\n            self.ans += pre * 2 + node.val\\n            \\n        if node.left:  # node.left is not None, recursively find the sum node to leaf\\n            # self.search(node.left, pre << 1 | node.val)  # also work\\n            self.search(node.left, pre * 2 + node.val)\\n        if node.right:  # node.right is not None, recursively find the sum node to leaf\\n            # self.search(node.right, pre << 1 | node.val)  # also work\\n            self.search(node.right, pre * 2 + node.val)\\n\\n    def sumRootToLeaf(self, root):\\n        self.search(root, 0)\\n        return self.ans\\n```\n```\\nclass Solution {\\n    public int ans = 0;\\n    \\n    public void search(TreeNode node, int pre) {\\n        if (node.left == null && node.right == null) // node is a leaf node, return the sum of path from root to node\\n            // this.ans += pre << 1 | node.val; // also work\\n            this.ans += pre * 2 + node.val; \\n            \\n        if (node.left != null) // node.left is not None, recursively find the sum node to leaf\\n            // search(node.left, pre << 1 | node.val); // also work\\n            search(node.left, pre * 2 + node.val);\\n        \\n        if (node.right != null) // node.right is not None, recursively find the sum node to leaf\\n            // search(node.right, pre << 1 | node.val); // also work\\n            search(node.right, pre * 2 + node.val);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        search(root, 0);\\n        return this.ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* node, int pre=0) { // pre is sum of path from root to parent of node\\n        if (!node->left and !node->right) // node is a leaf node, return the sum of path from root to node\\n            // return pre << 1 | node->val; // also work\\n\\t\\t\\treturn pre * 2 + node->val;\\n        int ans = 0;\\n        if (node->left) // node.left is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node->left, pre << 1 | node->val); // also work\\n\\t\\t\\tans += sumRootToLeaf(node->left, pre * 2 + node->val);\\n        if (node->right) // node.right is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node->right, pre << 1 | node->val); // also work\\n\\t\\t\\tans += sumRootToLeaf(node->right, pre * 2 + node->val);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, node, pre=0):  # pre is sum of path from root to parent of node\\n        if node.left is None and node.right is None:  # node is a leaf node, return the sum of path from root to node\\n            # return pre << 1 | node.val  # also work\\n\\t\\t\\treturn pre * 2 + node.val\\n        ans = 0\\n        if node.left:  # node.left is not None, recursively find the sum node to leaf\\n            # ans += self.sumRootToLeaf(node.left, pre << 1 | node.val)  # also work\\n\\t\\t\\tans += self.sumRootToLeaf(node.left, pre * 2 + node.val)\\n        if node.right:  # node.right is not None, recursively find the sum node to leaf\\n            # ans += self.sumRootToLeaf(node.right, pre << 1 | node.val)  # also work\\n\\t\\t\\tans += self.sumRootToLeaf(node.right, pre * 2 + node.val) \\n        return ans\\n```\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, node, pre=0):  # modified from the above one, don\\'t take it seriously\\n        return pre * 2 + node.val if node.left is None and node.right is None else (\\n                    self.sumRootToLeaf(node.left, pre * 2 + node.val) if node.left else 0\\n                                                                                   ) + (\\n                            self.sumRootToLeaf(node.right, pre * 2 + node.val) if node.right else 0\\n                                                                                       )\\n```\n```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode node, int pre) { // pre is sum of path from root to parent of node\\n        if (node.left == null && node.right == null) // node is a leaf node, return the sum of path from root to node\\n            // return pre << 1 | node.val; // also work\\n            return pre * 2 + node.val;\\n        int ans = 0;\\n        if (node.left != null) // node.left is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node.left, pre << 1 | node.val); // also work\\n            ans += sumRootToLeaf(node.left, pre * 2 + node.val);\\n        if (node.right != null) // node.right is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node.right, pre << 1 | node.val); // also work\\n            ans += sumRootToLeaf(node.right, pre * 2 + node.val);\\n        return ans;\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500851,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar sumRootToLeaf = function(root) {\\n    const binaries = [];\\n    const traverse = (node, str) => {\\n        if (node === null) {\\n            return;\\n        }\\n        // compose the binary string for the next node\\n        const binary = `${str}${node.val}`;\\n        // when visiting a leaf, add binary string to the array\\n        if (node.left === null && node.right === null) {\\n            binaries.push(binary);\\n        }\\n        \\n        traverse(node.left, binary);\\n        traverse(node.right, binary);\\n    }\\n    \\n    traverse(root, \\'\\');\\n    \\n    return binaries.reduce((sum, binary) => {\\n        sum += parseInt(binary, 2);\\n        return sum;\\n    }, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar sumRootToLeaf = function(root) {\\n    const binaries = [];\\n    const traverse = (node, str) => {\\n        if (node === null) {\\n            return;\\n        }\\n        // compose the binary string for the next node\\n        const binary = `${str}${node.val}`;\\n        // when visiting a leaf, add binary string to the array\\n        if (node.left === null && node.right === null) {\\n            binaries.push(binary);\\n        }\\n        \\n        traverse(node.left, binary);\\n        traverse(node.right, binary);\\n    }\\n    \\n    traverse(root, \\'\\');\\n    \\n    return binaries.reduce((sum, binary) => {\\n        sum += parseInt(binary, 2);\\n        return sum;\\n    }, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681770,
                "title": "c-python-easy-to-solve-with-different-approaches",
                "content": "Hello Everyone !! \\n**let\\'s get the question rolling ...**\\n***\\nSo we are given the root of a binary tree where every node has a value of `0 or 1`. We need to travel each path from root to leaf and convert it to decimal from binary and do summation of all paths .\\n\\n* Just a small detail given in the question **we all should remember :)**\\n> Each root-to-leaf path represents a binary number **starting with the most significant bit.**\\n***\\n**Intuition:-**\\n* So the majority of us got the intuition to find every path of binary tree by dfs and convert that path to decimal base from binary base but wait, is that a feasible way ?\\n* Nope, don\\'t thinks so. why ? Becuase, To make so many travels to find path and then take separate time to convert to Binary. Hence we are *compromsing both time and space* i.e `time complexity will be O(n^2) and space O(n) !!!!!`\\n**So lesss go and understand an optimal solution :)**\\n* So what if we traverse each node... convert..... and at the same time form its binary! While you are making a recursive call when traversing each node, You form the binary number by adding to previously found binary of that number and at the end which is when the node is a leaf node i.e both left and right are NULL then we know that our number has successfully formed and we add it to our ans. Booom!!! we got the optimization.\\n* **Let\\'s see how the space and time is reduced ^_^ :-** The recursion call is done for all nodes in `O(n)` both number formation and binary conversion are done in `O(1)`. and the space used will be `O(h)` for recursion ,where `h` is the height of the tree. \\n***\\n**Code:-**\\n*DFS call will be like :0*\\n```\\nif(root->left == root->right) \\n    val ;\\nelse\\n    sumRootToLeaf(root->left, val) + sumRootToleaf(root->right, val) ;\\n```\\n*Wan\\'t to do some fun?!! let\\'s do this using ternary operator ~0~*\\n```\\nreturn (root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));\\n```\\n\\n**C++ Final Code:-**\\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (!root) return 0;//base condition\\n        //val = val << 1 | root->val; //Both are same it\\'s just the bit manipulation way  \\n        val = (val * 2 + root->val); //using Normal math\\n        return (root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));//dfs call\\n    }\\n};\\n```\\n**Python Final Code:-**\\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, root, val=0):\\n        if not root: return 0  #base case\\n        val = val * 2 + root.val  #val = val << 1 | root->val; //Both are same it\\'s just the bit manipulation way  \\n        if not root.left and not root.right: return val \\n        return self.sumRootToLeaf(root.left, val) + self.sumRootToLeaf(root.right, val) #dfs call\\n```\\n**Time Complexity :** *`O(n)`*\\n**Space Complexity:** *`O(1)`*\\n***\\n***\\n**Not a pro in coding just doing it for the fun because I like it ;)) , If I can improve anywhere please comment below or if you have any doubt feel free to ask.**\\n***",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nif(root->left == root->right) \\n    val ;\\nelse\\n    sumRootToLeaf(root->left, val) + sumRootToleaf(root->right, val) ;\\n```\n```\\nreturn (root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));\\n```\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (!root) return 0;//base condition\\n        //val = val << 1 | root->val; //Both are same it\\'s just the bit manipulation way  \\n        val = (val * 2 + root->val); //using Normal math\\n        return (root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));//dfs call\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, root, val=0):\\n        if not root: return 0  #base case\\n        val = val * 2 + root.val  #val = val << 1 | root->val; //Both are same it\\'s just the bit manipulation way  \\n        if not root.left and not root.right: return val \\n        return self.sumRootToLeaf(root.left, val) + self.sumRootToLeaf(root.right, val) #dfs call\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340184,
                "title": "c-dfs-solution-super-op-to-understand-descriptive",
                "content": "\\uD83D\\uDC49 Most solutions have directly done using BITS, Which makes it more difficult to understand. So, I will explain simply using Maths both logic and code. \\n\\n\\u274C Someone can simply think to first find the path and make a string to form the number and then convert it to Binary, **But is it feasible ? No !** Becuase, To make so many travels to find path and then take separate time to convert to Binary. Compromsing both time and space !\\n\\n\\u2714 What if we traverse each node covert and at the same time form its binary! While you are making a recursive call when traversing each node, You form the binary number by adding to previously found binary of that number and at the end which is when the **node is a leaf node** i.e both left and right are NULL then we know that our number **has successfully formed and we add it to our ans**.\\n\\n\\u2716\\u2795 Refer to below diagram for reference. At each level you pass the binary formed. But how is it formed ?\\nSee, Imagine a path 1->0->0 , Its decimal equivalent is 4. So you just take that digit multiply it with 2 and add the previous known bit, Since we dont know thw prev. bit here we add 0 *(Passed in func call)*. Once, we get the digit we add to our next digit and keep it doing recursively and once its a leaf node, **We add it our number. \\nAnd the same in recursion call is done for all nodes in O(n) both number formation and binary conversion are done in O(1).**\\n\\n![image](https://assets.leetcode.com/users/images/d2b292f7-7e8b-48c0-9ad9-0a831301ea51_1626371835.6485362.png)\\n\\n**\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB Now here is the code, For the sake of explanation I have made another function and done some extra work. You can just optimise a little more like combining statements, etc**\\n\\n```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void readTree(TreeNode* root, int val)\\n    {\\n        if(!root)\\n            return;\\n\\n        // val = val^2 + root->val;     // Normal Math\\n        val = val << 1 | root->val;     // Same thing in BITS\\n\\t\\t\\n\\t\\t// You can study this concept of bits from GFG ! Internal working of bitwise shift left and OR Operator.\\n        \\n        readTree(root->left, val);\\n        readTree(root->right, val);\\n        \\n        if(root->left == NULL && root->right == NULL)   //When leaf Node then add to Sum\\n            sum += val;\\n    }\\n\\n    int sumRootToLeaf(TreeNode* root) \\n    {\\n        readTree(root, 0);\\n        return sum;\\n    }\\n};\\n```\\n\\n\\u2728 I am not a pro just a begineer, If I can improve anywhere please comment below or if you have any doubt feel free to ask.\\n\\n[Github](http://github.com/winoffrg) \\u2022 Jai Shree Ram !",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void readTree(TreeNode* root, int val)\\n    {\\n        if(!root)\\n            return;\\n\\n        // val = val^2 + root->val;     // Normal Math\\n        val = val << 1 | root->val;     // Same thing in BITS\\n\\t\\t\\n\\t\\t// You can study this concept of bits from GFG ! Internal working of bitwise shift left and OR Operator.\\n        \\n        readTree(root->left, val);\\n        readTree(root->right, val);\\n        \\n        if(root->left == NULL && root->right == NULL)   //When leaf Node then add to Sum\\n            sum += val;\\n    }\\n\\n    int sumRootToLeaf(TreeNode* root) \\n    {\\n        readTree(root, 0);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332712,
                "title": "java-easy-approach-with-explanation-recursive",
                "content": "```\\nclass Solution \\n{//Revise left and right shift operator from GFG (recommended)\\n    public int sumRootToLeaf(TreeNode root)\\n    {\\n        if(root == null)//base case for null graph \\n            return 0;\\n        \\n        return sum(root, 0);//sum is passed because it has a cyclic dependency  in Recursion for calculating the sum \\n    }\\n    public int sum(TreeNode root, int sum)\\n    {\\n        if(root == null)//base case 1//we we reach an null node we return 0, no shifting operation is done \\n            return 0;\\n        \\n        sum= (sum<<1) + root.val;//in binary addition 0 + 1= 1 && 0 + 0= 0, so only the last place will change by 0 or 1//doing left shift will append zero at the end \\n        \\n        if(root.left == null && root.right == null)//base case 2\\n            return sum;//when we got the desired result(Binary Number in integer) at the leaf node returning it to get the total sum and the traverse if any subtree is left \\n        return sum(root.left, sum) + sum(root.right, sum);//calculating the left and right sum recursively //bactracking helps a lot in leaf node sum \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{//Revise left and right shift operator from GFG (recommended)\\n    public int sumRootToLeaf(TreeNode root)\\n    {\\n        if(root == null)//base case for null graph \\n            return 0;\\n        \\n        return sum(root, 0);//sum is passed because it has a cyclic dependency  in Recursion for calculating the sum \\n    }\\n    public int sum(TreeNode root, int sum)\\n    {\\n        if(root == null)//base case 1//we we reach an null node we return 0, no shifting operation is done \\n            return 0;\\n        \\n        sum= (sum<<1) + root.val;//in binary addition 0 + 1= 1 && 0 + 0= 0, so only the last place will change by 0 or 1//doing left shift will append zero at the end \\n        \\n        if(root.left == null && root.right == null)//base case 2\\n            return sum;//when we got the desired result(Binary Number in integer) at the leaf node returning it to get the total sum and the traverse if any subtree is left \\n        return sum(root.left, sum) + sum(root.right, sum);//calculating the left and right sum recursively //bactracking helps a lot in leaf node sum \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552531,
                "title": "c-simple-solution-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int sol=0;\\n    int sumRootToLeaf(TreeNode* root,int num=0) {\\n        if(!root)return 0;\\n        num *= 2;\\n        num+=root->val;\\n        if(!root->left&&!root->right)sol+=num;\\n        sumRootToLeaf(root->left,num);\\n        sumRootToLeaf(root->right,num);\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sol=0;\\n    int sumRootToLeaf(TreeNode* root,int num=0) {\\n        if(!root)return 0;\\n        num *= 2;\\n        num+=root->val;\\n        if(!root->left&&!root->right)sol+=num;\\n        sumRootToLeaf(root->left,num);\\n        sumRootToLeaf(root->right,num);\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836946,
                "title": "very-easy-dfs-python-solution",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        total=0\\n        \\n        stack=[(root,str(root.val))]\\n        \\n        while stack:\\n            node,binVal=stack.pop()\\n            \\n            if node.left:\\n                stack.append((node.left,binVal+str(node.left.val)))\\n                \\n            if node.right:\\n                stack.append((node.right,binVal+str(node.right.val)))\\n\\n            if not node.left and not node.right:\\n                total+=int(binVal,2)\\n        return total     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        total=0\\n        \\n        stack=[(root,str(root.val))]\\n        \\n        while stack:\\n            node,binVal=stack.pop()\\n            \\n            if node.left:\\n                stack.append((node.left,binVal+str(node.left.val)))\\n                \\n            if node.right:\\n                stack.append((node.right,binVal+str(node.right.val)))\\n\\n            if not node.left and not node.right:\\n                total+=int(binVal,2)\\n        return total     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 328033,
                "title": "simple-python-solution-top-down-dfs",
                "content": "Please see and vote for my solutions for these similar problems.\\n\\n[257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/discuss/309004/Different-DFS-Python-solutions)\\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\\n\\n[129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/328123/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[1022. Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/discuss/328033/Top-down-Python-DFS-Solution)\\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[988. Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/discuss/328119/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\\n\\n[112. Path Sum](https://leetcode.com/problems/path-sum/discuss/328124/Simple-Python-Solution%3A-top-down-DFS)\\n\\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\\n\\n[113. Path Sum II](https://leetcode.com/problems/path-sum-ii/discuss/328125/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\\n\\n[437. Path Sum III](https://leetcode.com/problems/path-sum-iii/discuss/328128/Simple-Python-Solution%3A-top-down-DFS-%2B-DP) (Similar problem: 560. Subarray Sum Equals K)\\n\\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1681890,
                "title": "c-recursive-solution-with-backtracking",
                "content": "The main idea of Backtracting:\\n\\n**1. choose\\n2. explore\\n3. unchoose**\\n\\nThe approach is almost straight forward.  Just explore the nodes using dfs, we choosing the current node and push to the BinaryVector.  After processing(while returning back) we unchoose the node by poping from the BinaryVector.\\n\\nWhen we reach the leaf node, we get a BinaryVector(from root to leaf) then we convert the BinaryVector to an Decimal Equivalent and adding to the Total, then we backtract again, and repeat the same process.\\n\\n**C++:**\\n```\\nclass Solution {\\nprivate:\\n    int binaToDeci(vector<int> s){\\n        int res = 0, p = 1;\\n        for (int i = s.size()-1; i >= 0; i--)\\n        {\\n            int c = s[i];\\n            if(c == 1) res += p;\\n            p <<= 1;\\n        }\\n        return res;\\n    }\\n    void dfs(TreeNode* root, vector<int>&BinaryVector, int& Total){\\n        if(root == NULL) return;\\n        if(root->left == NULL && root-> right == NULL){ // left node\\n            BinaryVector.push_back(root->val);  // choose\\n            Total += binaToDeci(BinaryVector); // Converts the Binary to Decimal and add it. \\n            BinaryVector.pop_back();  // unchoose\\n            return ;\\n        }\\n\\n        BinaryVector.push_back(root->val);   // choose \\n        dfs(root->left, BinaryVector, Total); // explore\\n        dfs(root->right, BinaryVector, Total);\\n        BinaryVector.pop_back();             // unchoose\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int Total = 0;\\n        vector<int> BinaryVector;\\n        dfs(root, BinaryVector, Total);\\n        return Total;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int binaToDeci(vector<int> s){\\n        int res = 0, p = 1;\\n        for (int i = s.size()-1; i >= 0; i--)\\n        {\\n            int c = s[i];\\n            if(c == 1) res += p;\\n            p <<= 1;\\n        }\\n        return res;\\n    }\\n    void dfs(TreeNode* root, vector<int>&BinaryVector, int& Total){\\n        if(root == NULL) return;\\n        if(root->left == NULL && root-> right == NULL){ // left node\\n            BinaryVector.push_back(root->val);  // choose\\n            Total += binaToDeci(BinaryVector); // Converts the Binary to Decimal and add it. \\n            BinaryVector.pop_back();  // unchoose\\n            return ;\\n        }\\n\\n        BinaryVector.push_back(root->val);   // choose \\n        dfs(root->left, BinaryVector, Total); // explore\\n        dfs(root->right, BinaryVector, Total);\\n        BinaryVector.pop_back();             // unchoose\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int Total = 0;\\n        vector<int> BinaryVector;\\n        dfs(root, BinaryVector, Total);\\n        return Total;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936585,
                "title": "dfs-easy-js-solution",
                "content": "```\\n/*\\nUse DFS to find every possible path\\nKeep track of binary number in path. When leaf is reached, convert it to an integer and add it\\nto a global variable.\\n*/\\nvar sumRootToLeaf = function(root) {\\n    let sum = 0;\\n    dfs(root, \"\");\\n    return sum;\\n    function dfs(root, path) {\\n        if (!root) {\\n            return;\\n        }\\n        if (!root.left && !root.right) {\\n            sum += parseInt(path + root.val, 2);\\n            return;\\n        }\\n        dfs(root.left, path + root.val);\\n        dfs(root.right, path + root.val);\\n    }\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nUse DFS to find every possible path\\nKeep track of binary number in path. When leaf is reached, convert it to an integer and add it\\nto a global variable.\\n*/\\nvar sumRootToLeaf = function(root) {\\n    let sum = 0;\\n    dfs(root, \"\");\\n    return sum;\\n    function dfs(root, path) {\\n        if (!root) {\\n            return;\\n        }\\n        if (!root.left && !root.right) {\\n            sum += parseInt(path + root.val, 2);\\n            return;\\n        }\\n        dfs(root.left, path + root.val);\\n        dfs(root.right, path + root.val);\\n    }\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681998,
                "title": "java-0ms-with-explanation",
                "content": "We declare sum=0 as global variable.\\n\\nNow in main method we make a check method which computes sumRoottoLeaf calculation.\\n\\nHere preorder traversal will work. As we need root first.\\n\\nMy logic is that if root.val==0 then the computed value earlier will become`` x * 2 else x*2+1;\\n\\nHow???\\nlike first take example with 110=6;\\nNow if next node is 0 which make (1100) =12\\nAnd if next node is 1 which make (1101)=13\\n\\nUsing this approach i recursive called root.left and root.right .\\nAnd included one condtion which is if it is leaf Node then add in global variable sum.\\n\\n**Please Upvote if found UsefuL**\\nComments if any doubts or any more good approach.**Thank You!!**\\n\\n```\\nclass Solution {\\n    int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        check(root,0);\\n        return sum;\\n    }\\n    void check(TreeNode root,int x)\\n    {\\n        if(root==null)\\n        {\\n            return;\\n        }\\n        if(root.left==null && root.right==null)\\n        {\\n            sum+=root.val==0?x*2:x*2+1;\\n            return;\\n        }\\n        check(root.left,root.val==0?x*2:x*2+1);\\n        check(root.right,root.val==0?x*2:x*2+1);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        check(root,0);\\n        return sum;\\n    }\\n    void check(TreeNode root,int x)\\n    {\\n        if(root==null)\\n        {\\n            return;\\n        }\\n        if(root.left==null && root.right==null)\\n        {\\n            sum+=root.val==0?x*2:x*2+1;\\n            return;\\n        }\\n        check(root.left,root.val==0?x*2:x*2+1);\\n        check(root.right,root.val==0?x*2:x*2+1);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836834,
                "title": "python-easy-to-understand-dfs",
                "content": "\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.total = 0\\n        def helper(root,nums):\\n            if not root.left and not root.right:\\n                nums += str(root.val)\\n                self.total += int(nums,2)\\n                return    \\n            \\n            nums += str(root.val)\\n            if root.left:\\n                helper(root.left,nums)\\n            if root.right:\\n                helper(root.right,nums)\\n\\n        helper(root, \"\")\\n        return self.total",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.total = 0\\n        def helper(root,nums):\\n            if not root.left and not root.right:\\n                nums += str(root.val)\\n                self.total += int(nums,2)\\n                return    \\n            \\n            nums += str(root.val)\\n            if root.left:\\n                helper(root.left,nums)\\n            if root.right:\\n                helper(root.right,nums)\\n\\n        helper(root, \"\")\\n        return self.total",
                "codeTag": "Python3"
            },
            {
                "id": 836179,
                "title": "java-easy-to-understand-w-explanation-dfs-solution-beats-100",
                "content": "Every level of the tree describes the weight as we do in the Base-10.\\nFor example, 123 can be represented as 123 = 1 * 100 + 2 * 10 + 3\\nSimilarly\\n\\n              1 ----- Level 0 represents weight 2 raise to power 0\\n             / \\\\\\n           0    1 ----- Level 1 represents weight 2 raise to power 1\\n         /  \\\\\\n        1    0 ----- Level 2 represents weight 2 raise to power 2\\nRoot to Leaf Paths - 1 0 1 = 1 * (2^2) + 0 * (2^1) + 1 * (2^0) = 4 + 0 + 1 = 5,\\nSimilarly for 1 0 0 and 1 1.\\n\\nIn Short words, with every level down, we are shifting bits to the left and thereby increasing their weight by k (where k is the base in which we\\'re in, in this case k = 2)\\n\\nFor Path -> 1 0 1\\nAt Level 0, curr = 0 + 1 = 1\\nAt Level 1, curr = (0 + 1) * 2 + 0 = 2\\nAt Level 2, curr = ((0 + 1) * 2 + 0) * 2 + 1 = 2 * 2 + 1 = 5\\n\\nHope it helps!!\\n\\n\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    \\n    private void dfs(TreeNode root, int curr) {\\n        if (root == null) return;\\n        \\n        curr = curr * 2 + root.val;\\n        \\n        if (root.left == null && root.right == null) {\\n            sum += curr;\\n        }\\n        \\n        dfs(root.left, curr);\\n        dfs(root.right, curr);\\n        \\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root, 0);\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    \\n    private void dfs(TreeNode root, int curr) {\\n        if (root == null) return;\\n        \\n        curr = curr * 2 + root.val;\\n        \\n        if (root.left == null && root.right == null) {\\n            sum += curr;\\n        }\\n        \\n        dfs(root.left, curr);\\n        dfs(root.right, curr);\\n        \\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root, 0);\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835894,
                "title": "c-simple-recursive-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution {\\npublic:\\n    // recursive helper function to add to vector all binary numbers\\n    void traverse(TreeNode* node, string sum) {\\n        if (!node)\\n            return;\\n        sum = sum + to_string(node->val);\\n        if (!node->left && !node->right)\\n        {\\n            vec.push_back(sum);\\n        }\\n        traverse(node->left, sum);\\n        traverse(node->right, sum); \\n        \\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        traverse(root, \"\");\\n        int res = 0;\\n        for(auto x:vec)\\n            res += stoi(x, nullptr, 2);\\n        return res;\\n    }\\n    vector<string> vec;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // recursive helper function to add to vector all binary numbers\\n    void traverse(TreeNode* node, string sum) {\\n        if (!node)\\n            return;\\n        sum = sum + to_string(node->val);\\n        if (!node->left && !node->right)\\n        {\\n            vec.push_back(sum);\\n        }\\n        traverse(node->left, sum);\\n        traverse(node->right, sum); \\n        \\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        traverse(root, \"\");\\n        int res = 0;\\n        for(auto x:vec)\\n            res += stoi(x, nullptr, 2);\\n        return res;\\n    }\\n    vector<string> vec;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270895,
                "title": "python-happy-dfs-solution",
                "content": "DFS with preorder trasvering\\n# method 1\\n        # it\\'s quite similar to find and return all the root-to-leaf paths\\n        # But this time we just need to return the decimal\\n\\t\\t# O(logn) for time\\n\\t\\t# and without taking the recursion space into account\\n\\t\\t# we will have O(n) for additional space\\n        def dfs(node, path=None):\\n            if path == None:\\n                path = \\'\\'\\n            if node:\\n                path += str(node.val)\\n                if node.left or node.right:\\n                    return dfs(node.left, path) + dfs(node.right, path)\\n                else:\\n                    return int(path, 2)\\n            else:\\n                return 0\\n\\t\\t\\t\\t\\n# method 2 (recommended)\\n        # very similar to the implementation of method 1\\n\\t\\t# but this time, we directly pass the parent sum instead of \\n\\t\\t# only calculate the decimal presentation in the leaf\\n\\t\\t# O(logn) for time\\n\\t\\t# and without taking the recursion space into account\\n\\t\\t# we will have O(1) for additional space\\n        def dfs2(node, parent_sum=None):\\n            if parent_sum == None:\\n                parent_sum = 0\\n            if node:\\n                parent_sum = parent_sum * 2 + node.val\\n                if node.left or node.right:\\n                    return dfs2(node.left, parent_sum) + dfs2(node.right, parent_sum)\\n                else:\\n                    return parent_sum\\n            else:\\n                return 0",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "DFS with preorder trasvering\\n# method 1\\n        # it\\'s quite similar to find and return all the root-to-leaf paths\\n        # But this time we just need to return the decimal\\n\\t\\t# O(logn) for time\\n\\t\\t# and without taking the recursion space into account\\n\\t\\t# we will have O(n) for additional space\\n        def dfs(node, path=None):\\n            if path == None:\\n                path = \\'\\'\\n            if node:\\n                path += str(node.val)\\n                if node.left or node.right:\\n                    return dfs(node.left, path) + dfs(node.right, path)\\n                else:\\n                    return int(path, 2)\\n            else:\\n                return 0\\n\\t\\t\\t\\t\\n# method 2 (recommended)\\n        # very similar to the implementation of method 1\\n\\t\\t# but this time, we directly pass the parent sum instead of \\n\\t\\t# only calculate the decimal presentation in the leaf\\n\\t\\t# O(logn) for time\\n\\t\\t# and without taking the recursion space into account\\n\\t\\t# we will have O(1) for additional space\\n        def dfs2(node, parent_sum=None):\\n            if parent_sum == None:\\n                parent_sum = 0\\n            if node:\\n                parent_sum = parent_sum * 2 + node.val\\n                if node.left or node.right:\\n                    return dfs2(node.left, parent_sum) + dfs2(node.right, parent_sum)\\n                else:\\n                    return parent_sum\\n            else:\\n                return 0",
                "codeTag": "Python3"
            },
            {
                "id": 695744,
                "title": "simplest-recursive-solution-o-n-and-100-time-with-explaination",
                "content": "Idea is simple, do normal traversal, at every step just store the value from previous to current node,\\nexample : traversing 1->0->1 :-\\nwhen we start with 1(1 is root), then value 1 to binary is 2^0 * 1 === 1,\\nwhen we traverses to 1->0 (from 1 to 0), then it is 2^1 * 1 + 2^0 * 0 == 2   note : the previous node value just get doubled and we just the current node since 2\\'s power 0 is 1 only, so 1*2 + 1 * 0 = 2\\nwhen we traverses to 1->0->1, then ->  2 * (value of 1->0) + 1 = (2 * 2 )+ 1\\nso 1->0->1 = 5\\n we uses same thing in our logic\\n\\n```\\nint sum = 0;  // final sum\\n    public int sumRootToLeaf(TreeNode root) {\\n        recur(root,0);\\n        return sum;\\n    }\\n   void recur(TreeNode root, int num) {\\n        if(root == null) {\\n            return;\\n        }\\n        num = num*2 + root.val;  // at every node it will return the value of binary in decimal from root \\n        recur(root.left,num);  \\n        recur(root.right,num);\\n        if(root.left == null && root.right == null) {\\n            sum +=num;   // when every time we reaches the leaf node, we add the num to sum\\n        }\\n    }\\n```\\n\\n**I hope this helps!!**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nint sum = 0;  // final sum\\n    public int sumRootToLeaf(TreeNode root) {\\n        recur(root,0);\\n        return sum;\\n    }\\n   void recur(TreeNode root, int num) {\\n        if(root == null) {\\n            return;\\n        }\\n        num = num*2 + root.val;  // at every node it will return the value of binary in decimal from root \\n        recur(root.left,num);  \\n        recur(root.right,num);\\n        if(root.left == null && root.right == null) {\\n            sum +=num;   // when every time we reaches the leaf node, we add the num to sum\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308071,
                "title": "python-99-depth-first-search",
                "content": "\\n\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def dfs(node, prefix):\\n            if node:\\n                new_prefix = node.val + (prefix << 1)\\n                \\n                if node.left or node.right:\\n                    return dfs(node.left, new_prefix) + dfs(node.right, new_prefix)\\n                else:\\n                    return new_prefix\\n            else:\\n                return 0\\n            \\n        return dfs(root, 0)",
                "solutionTags": [],
                "code": "\\n\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def dfs(node, prefix):\\n            if node:\\n                new_prefix = node.val + (prefix << 1)\\n                \\n                if node.left or node.right:\\n                    return dfs(node.left, new_prefix) + dfs(node.right, new_prefix)\\n                else:\\n                    return new_prefix\\n            else:\\n                return 0\\n            \\n        return dfs(root, 0)",
                "codeTag": "Python3"
            },
            {
                "id": 269967,
                "title": "c-3-lines",
                "content": "# Solution\\nCalculate the number top-to-bottom, stop at the leaf and return the result.\\n\\nSum results for all leaves; make sure we handle parents with only one child (return 0 for the missing child).\\n```\\nint sumRootToLeaf(TreeNode* r, int val = 0) {\\n  if (r == nullptr) return 0;\\n  val = ((val << 1) + r->val) % 1000000007;\\n  return (r->left == r->right ? val : sumRootToLeaf(r->left, val) + sumRootToLeaf(r->right, val)) % 1000000007;\\n}\\n```\\n# Complexity Analysis\\nRuntime: *O(n)*; we process each node once. \\nMemory: *O(h)*, where *h* is the height of the tree.",
                "solutionTags": [],
                "code": "```\\nint sumRootToLeaf(TreeNode* r, int val = 0) {\\n  if (r == nullptr) return 0;\\n  val = ((val << 1) + r->val) % 1000000007;\\n  return (r->left == r->right ? val : sumRootToLeaf(r->left, val) + sumRootToLeaf(r->right, val)) % 1000000007;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1682476,
                "title": "c-java-simple-and-clean-recursive-solutions-explained",
                "content": "**Idea:**\\nWe treaverse the tree, and concatenate the binary numbers to one string in `sum`.\\nWhen we reach a leaf node, we calculate the value of the binary string and add to `res`.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1) without considering recursive stack, O(height) with recursive call stack.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    \\n    void traverse(TreeNode* node, string sum) {\\n        if (!node) return;\\n        \\n        sum = sum + to_string(node->val);\\n        \\n        if (!node->left && !node->right) res += stoi(sum, nullptr, 2);\\n        \\n        traverse(node->left, sum);\\n        traverse(node->right, sum); \\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        traverse(root, \"\");\\n        return res;\\n    }\\n};\\n```\\n****\\n**Java:**\\n```\\nclass Solution {\\n    int res = 0;\\n    \\n    void traverse(TreeNode node, String sum) {\\n        if (node == null) return;\\n        \\n        sum = sum + String.valueOf(node.val);\\n        \\n        if (node.left == null && node.right == null) \\n            res += Integer.parseInt(sum, 2);\\n   \\n        traverse(node.left, sum);\\n        traverse(node.right, sum); \\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        traverse(root, \"\");\\n        return res;\\n    }\\n}\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    \\n    void traverse(TreeNode* node, string sum) {\\n        if (!node) return;\\n        \\n        sum = sum + to_string(node->val);\\n        \\n        if (!node->left && !node->right) res += stoi(sum, nullptr, 2);\\n        \\n        traverse(node->left, sum);\\n        traverse(node->right, sum); \\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        traverse(root, \"\");\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int res = 0;\\n    \\n    void traverse(TreeNode node, String sum) {\\n        if (node == null) return;\\n        \\n        sum = sum + String.valueOf(node.val);\\n        \\n        if (node.left == null && node.right == null) \\n            res += Integer.parseInt(sum, 2);\\n   \\n        traverse(node.left, sum);\\n        traverse(node.right, sum); \\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        traverse(root, \"\");\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481832,
                "title": "recursive-dfs-soln-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void helper(TreeNode* root , int num = 0)\\n    {\\n        num = num*2 + root->val;\\n        if(root->left)helper(root->left , num);\\n        if(root->right)helper(root->right , num);\\n        \\n        if(!root->left && !root->right)\\n        {  sum += num;\\n           return;\\n        }\\n        \\n        return;\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```\\n\\nsimilar question https://leetcode.com/problems/sum-root-to-leaf-numbers/\\nwith answer https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/1481784/c%2B%2B-soln-faster-than-100",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void helper(TreeNode* root , int num = 0)\\n    {\\n        num = num*2 + root->val;\\n        if(root->left)helper(root->left , num);\\n        if(root->right)helper(root->right , num);\\n        \\n        if(!root->left && !root->right)\\n        {  sum += num;\\n           return;\\n        }\\n        \\n        return;\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990406,
                "title": "c-no-bitwise-operators-recursive-simple",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, ll num){\\n        if(!root)\\n            return 0;\\n        if(!root->left && !root->right)\\n            return num + root->val;\\n        num += root->val;\\n        return solve(root->left, num * 2) + solve(root->right, num * 2);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        return solve(root,0);\\n    }\\n};\\n```\\n\\nThe reason for using long long instead of int is there could be a potential overflow since I am multiplying the numbers rather than shifting bits.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, ll num){\\n        if(!root)\\n            return 0;\\n        if(!root->left && !root->right)\\n            return num + root->val;\\n        num += root->val;\\n        return solve(root->left, num * 2) + solve(root->right, num * 2);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        return solve(root,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843907,
                "title": "java-recursion-dfs-and-iteration-morris-traversal-with-video-explaination",
                "content": "DFS version\\n[https://www.youtube.com/watch?v=HBAJqf5cRis](https://www.youtube.com/watch?v=HBAJqf5cRis)\\n```java\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return helper(root, 0);\\n    }\\n    \\n    private int helper(TreeNode node, int value){\\n        if(node == null) return 0;\\n        \\n        value = value * 2 + node.val;\\n        if(node.left == null && node.right == null){\\n            return value;\\n        }\\n        return helper(node.left, value) + helper(node.right, value);\\n    }\\n}\\n\\n```\\n\\nMorris Traversal Version\\n[https://www.youtube.com/watch?v=2zGxbvIqDGI](https://www.youtube.com/watch?v=2zGxbvIqDGI)\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        int result = 0;\\n        int carry = 0;\\n        while(root != null){\\n            if(root.left != null){\\n                TreeNode predecessor = root.left;\\n                int level = 1;\\n                \\n                while(predecessor.right != null && predecessor.right != root){\\n                    predecessor = predecessor.right;\\n                    level++;\\n                }\\n                \\n                if(predecessor.right == null){\\n                    carry = carry * 2 + root.val;\\n                    predecessor.right = root;\\n                    root = root.left;\\n                }else{\\n                    if(predecessor.left == null){\\n                        result += carry;\\n                    }\\n                    \\n                    for(int i = 0; i < level; i++){\\n                        carry = carry / 2;\\n                    }\\n                    \\n                    predecessor.right = null;\\n                    root = root.right;\\n                }\\n            }else{\\n                // root.left == null\\n                carry = carry * 2 + root.val;\\n                \\n                // right-most leaf node\\n                if(root.right == null){\\n                    result += carry;\\n                }\\n                root = root.right;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return helper(root, 0);\\n    }\\n    \\n    private int helper(TreeNode node, int value){\\n        if(node == null) return 0;\\n        \\n        value = value * 2 + node.val;\\n        if(node.left == null && node.right == null){\\n            return value;\\n        }\\n        return helper(node.left, value) + helper(node.right, value);\\n    }\\n}\\n\\n```\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        int result = 0;\\n        int carry = 0;\\n        while(root != null){\\n            if(root.left != null){\\n                TreeNode predecessor = root.left;\\n                int level = 1;\\n                \\n                while(predecessor.right != null && predecessor.right != root){\\n                    predecessor = predecessor.right;\\n                    level++;\\n                }\\n                \\n                if(predecessor.right == null){\\n                    carry = carry * 2 + root.val;\\n                    predecessor.right = root;\\n                    root = root.left;\\n                }else{\\n                    if(predecessor.left == null){\\n                        result += carry;\\n                    }\\n                    \\n                    for(int i = 0; i < level; i++){\\n                        carry = carry / 2;\\n                    }\\n                    \\n                    predecessor.right = null;\\n                    root = root.right;\\n                }\\n            }else{\\n                // root.left == null\\n                carry = carry * 2 + root.val;\\n                \\n                // right-most leaf node\\n                if(root.right == null){\\n                    result += carry;\\n                }\\n                root = root.right;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836211,
                "title": "javascript-clean-recursive-solution",
                "content": "```javascript\\nvar sumRootToLeaf = function(root) {\\n    \\n    function callDFS(node, str) {\\n        if(!node) return 0;\\n        str += node.val\\n        if(!node.left && !node.right) return parseInt(str, 2);\\n        return callDFS(node.right, str) + callDFS(node.left, str);\\n    }\\n    return callDFS(root, \\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar sumRootToLeaf = function(root) {\\n    \\n    function callDFS(node, str) {\\n        if(!node) return 0;\\n        str += node.val\\n        if(!node.left && !node.right) return parseInt(str, 2);\\n        return callDFS(node.right, str) + callDFS(node.left, str);\\n    }\\n    return callDFS(root, \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 836047,
                "title": "java-dfs-video-solution-with-complexity-as-o-n",
                "content": "<iframe width=\"650\" height=\"450\" src=\"https://www.youtube.com/embed/7zNNdbeSz-I\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n```\\nLink https://www.youtube.com/embed/7zNNdbeSz-I\\n\\nAlgorithm DFS /Post order traversal\\n1) At each level multiply the running sum with 2 and add the node val. \\n2) At leaves add running sum to your result\\n\\nclass Solution { \\nint totalSum = 0; // For storing the result\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        \\n        preOrderTraversal(root, 0);\\n        return totalSum;\\n    }\\n    // O(n), where n is the no of nodes in the tree\\n    private void preOrderTraversal(TreeNode root, int currVal){\\n        if(root==null){\\n            return ;\\n        }\\n        currVal = currVal + root.val;\\n        \\n        // leaf node or not\\n        if(root.left == null && root.right==null){\\n            totalSum += currVal;\\n            return ;\\n        }\\n        preOrderTraversal(root.left , currVal* 2);\\n        preOrderTraversal(root.right , currVal* 2);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nLink https://www.youtube.com/embed/7zNNdbeSz-I\\n\\nAlgorithm DFS /Post order traversal\\n1) At each level multiply the running sum with 2 and add the node val. \\n2) At leaves add running sum to your result\\n\\nclass Solution { \\nint totalSum = 0; // For storing the result\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        \\n        preOrderTraversal(root, 0);\\n        return totalSum;\\n    }\\n    // O(n), where n is the no of nodes in the tree\\n    private void preOrderTraversal(TreeNode root, int currVal){\\n        if(root==null){\\n            return ;\\n        }\\n        currVal = currVal + root.val;\\n        \\n        // leaf node or not\\n        if(root.left == null && root.right==null){\\n            totalSum += currVal;\\n            return ;\\n        }\\n        preOrderTraversal(root.left , currVal* 2);\\n        preOrderTraversal(root.right , currVal* 2);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835950,
                "title": "sum-of-root-to-leaf-binary-numbers-c-o-n-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    static int count(TreeNode* node, int path = 0) { // save path as bits in int\\n        if (!node) return 0;\\n\\t\\t// update path by adding new point to the right to get answer quickly\\n        path <<= 1;\\n \\xA0 \\xA0 \\xA0 \\xA0path += node->val;\\n\\t\\t// if leaf return answer\\n        if (!node->left && !node->right) {\\n            return path;\\n        } else { // if not leaf continue pathing\\n            return count(node->left, path) + count(node->right, path);\\n        }\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        return count(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int count(TreeNode* node, int path = 0) { // save path as bits in int\\n        if (!node) return 0;\\n\\t\\t// update path by adding new point to the right to get answer quickly\\n        path <<= 1;\\n \\xA0 \\xA0 \\xA0 \\xA0path += node->val;\\n\\t\\t// if leaf return answer\\n        if (!node->left && !node->right) {\\n            return path;\\n        } else { // if not leaf continue pathing\\n            return count(node->left, path) + count(node->right, path);\\n        }\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        return count(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760466,
                "title": "go-recursive-solution",
                "content": "You\\'ve got to press it on you, you\\'ve just been thinking.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc sumRootToLeaf(root *TreeNode) int {\\n    return dfs(root, 0)\\n}\\n\\nfunc dfs(root *TreeNode, currSum int) int {\\n    currSum = (currSum << 1) | root.Val\\n    \\n    if root.Left == nil && root.Right == nil {\\n        return currSum\\n    }\\n    \\n    total := 0\\n    if root.Left != nil {\\n        total += dfs(root.Left, currSum)\\n    }\\n    \\n    if root.Right != nil {\\n        total += dfs(root.Right, currSum)\\n    }\\n    \\n    return total\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc sumRootToLeaf(root *TreeNode) int {\\n    return dfs(root, 0)\\n}\\n\\nfunc dfs(root *TreeNode, currSum int) int {\\n    currSum = (currSum << 1) | root.Val\\n    \\n    if root.Left == nil && root.Right == nil {\\n        return currSum\\n    }\\n    \\n    total := 0\\n    if root.Left != nil {\\n        total += dfs(root.Left, currSum)\\n    }\\n    \\n    if root.Right != nil {\\n        total += dfs(root.Right, currSum)\\n    }\\n    \\n    return total\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 455682,
                "title": "java-100-time-and-memory-bit-operations-concise",
                "content": "``` \\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        return dfs(root, 0);\\n    }\\n    \\n    public int dfs(TreeNode n, int x) {\\n        if (n == null) return 0;\\n        x = (x << 1) | n.val;\\n        if (n.left == null && n.right == null) return x;\\n        return dfs(n.left, x) + dfs(n.right, x);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        return dfs(root, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2246488,
                "title": "fast-and-easy-c-solution-using-preorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    void getsum(TreeNode* root,long long data){\\n        if(root==NULL){\\n            return;\\n        }\\n        data=2*data+root->val;\\n        if(root->left==NULL && root->right==NULL){\\n            ans+=data;\\n        }\\n        getsum(root->left,data);\\n        getsum(root->right,data);\\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        getsum(root,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    void getsum(TreeNode* root,long long data){\\n        if(root==NULL){\\n            return;\\n        }\\n        data=2*data+root->val;\\n        if(root->left==NULL && root->right==NULL){\\n            ans+=data;\\n        }\\n        getsum(root->left,data);\\n        getsum(root->right,data);\\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        getsum(root,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737312,
                "title": "simple-beginner-friendly-approach",
                "content": "```\\nclass Solution {\\n    int sum = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        findRootToLeaf(root,\"\");\\n        return sum;\\n    }\\n    void findRootToLeaf(TreeNode root,String prev){\\n        if(root==null)\\n            return;\\n            prev=prev+String.valueOf(root.val);\\n        if(root.left==null && root.right==null)\\n            sum+=Integer.parseInt(prev,2);\\n        findRootToLeaf(root.left,prev);\\n        findRootToLeaf(root.right,prev);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        findRootToLeaf(root,\"\");\\n        return sum;\\n    }\\n    void findRootToLeaf(TreeNode root,String prev){\\n        if(root==null)\\n            return;\\n            prev=prev+String.valueOf(root.val);\\n        if(root.left==null && root.right==null)\\n            sum+=Integer.parseInt(prev,2);\\n        findRootToLeaf(root.left,prev);\\n        findRootToLeaf(root.right,prev);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682840,
                "title": "c-recursion-backtracking-using-string-o-n-time",
                "content": "```\\nclass Solution {\\nprivate:\\n    void dfs(TreeNode* root, string &s, int &ans){\\n        if(!root) return;\\n        s+=to_string(root->val);\\n        if(!root->left && !root->right) ans+=stoi(s, 0, 2);\\n        dfs(root->left, s, ans);\\n        dfs(root->right, s, ans);\\n        s.pop_back();\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        string s = \"\";\\n        int ans = 0;\\n        dfs(root, s, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(TreeNode* root, string &s, int &ans){\\n        if(!root) return;\\n        s+=to_string(root->val);\\n        if(!root->left && !root->right) ans+=stoi(s, 0, 2);\\n        dfs(root->left, s, ans);\\n        dfs(root->right, s, ans);\\n        s.pop_back();\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        string s = \"\";\\n        int ans = 0;\\n        dfs(root, s, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681921,
                "title": "c-short-code-8-lines-fast-easy-to-understand-recursion",
                "content": "**Please Upvote If You Like**\\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (root==NULL) return 0;//base case\\n        val=val*2+(root->val);\\n        if(root->left==root->right)  return val;\\n        return sumRootToLeaf(root->left,val)+sumRootToLeaf(root->right,val); //DFS Calls\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (root==NULL) return 0;//base case\\n        val=val*2+(root->val);\\n        if(root->left==root->right)  return val;\\n        return sumRootToLeaf(root->left,val)+sumRootToLeaf(root->right,val); //DFS Calls\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681814,
                "title": "python-simple-dfs-approach",
                "content": "This problem is pretty straight forward. Do a Depth first search (DFS) traversal and keep track of the pervious bits values. \\n\\n**Approach  1: Conversion on the go**\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        def dfs(node, soFar):\\n            soFar = soFar * 2 + node.val\\n            if not node.left and not node.right: self.ans += soFar\\n            if node.left: dfs(node.left, soFar)\\n            if node.right: dfs(node.right, soFar)\\n        \\n        dfs(root, 0)\\n        return self.ans\\n```\\n\\n**Approach 2: Convert when you reach the leaf**\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        def dfs(node, soFar):\\n            soFar += str(node.val)\\n            if not node.left and not node.right: self.ans += int(soFar, 2)\\n            if node.left: dfs(node.left, soFar)\\n            if node.right: dfs(node.right, soFar)\\n        \\n        dfs(root, \"\")\\n        return self.ans\\n```\\n\\n***Time Complexity: O(N) \\nSpace Complexity: O(H)  - for recursive stack***",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        def dfs(node, soFar):\\n            soFar = soFar * 2 + node.val\\n            if not node.left and not node.right: self.ans += soFar\\n            if node.left: dfs(node.left, soFar)\\n            if node.right: dfs(node.right, soFar)\\n        \\n        dfs(root, 0)\\n        return self.ans\\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        def dfs(node, soFar):\\n            soFar += str(node.val)\\n            if not node.left and not node.right: self.ans += int(soFar, 2)\\n            if node.left: dfs(node.left, soFar)\\n            if node.right: dfs(node.right, soFar)\\n        \\n        dfs(root, \"\")\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681609,
                "title": "c-simple-and-sweet",
                "content": "Simple Recursion:\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    void Ans(TreeNode *R, int cur, int &ret)\\n    {\\n            cur=cur*2+R->val;\\n            if(R->left!=NULL) Ans(R->left,cur,ret);\\n            if(R->right!=NULL) Ans(R->right,cur,ret);\\n            if(R->left==NULL && R->right==NULL) ret+=cur;\\n    }        \\n    int sumRootToLeaf(TreeNode* R) {\\n        int ret=0,cur=0;\\n        Ans(R,cur,ret);\\n        return(ret);\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void Ans(TreeNode *R, int cur, int &ret)\\n    {\\n            cur=cur*2+R->val;\\n            if(R->left!=NULL) Ans(R->left,cur,ret);\\n            if(R->right!=NULL) Ans(R->right,cur,ret);\\n            if(R->left==NULL && R->right==NULL) ret+=cur;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1399748,
                "title": "c-recursion-well-commented",
                "content": "**Do upvote if found useful**\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void topdown(TreeNode* node,int path){\\n        if(!node)\\n            return;\\n        path*=2;    //multiplying with 2 adds 0 to the binary number\\n        path+=node->val;    //adding whatever value is there in node ie, 0 or 1\\n        if(!node->left && !node->right){    //node is a leaf node\\n            sum+=path;  //add path to the sum\\n        }\\n        if(node->left)  //if left subtree exists\\n            topdown(node->left,path);\\n        \\n        if(node->right)  //if right subtree exists\\n            topdown(node->right,path);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        topdown(root,0);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void topdown(TreeNode* node,int path){\\n        if(!node)\\n            return;\\n        path*=2;    //multiplying with 2 adds 0 to the binary number\\n        path+=node->val;    //adding whatever value is there in node ie, 0 or 1\\n        if(!node->left && !node->right){    //node is a leaf node\\n            sum+=path;  //add path to the sum\\n        }\\n        if(node->left)  //if left subtree exists\\n            topdown(node->left,path);\\n        \\n        if(node->right)  //if right subtree exists\\n            topdown(node->right,path);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        topdown(root,0);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043156,
                "title": "python3-simple-solution-using-bfs-traversal",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        bfs = [root]\\n        l = []\\n        while bfs:\\n            node = bfs.pop(0)\\n            if node.left:\\n                x = node.left.val\\n                node.left.val = str(node.val) + str(x)\\n                bfs.append(node.left)\\n            if node.right:\\n                x = node.right.val\\n                node.right.val = str(node.val) + str(x)\\n                bfs.append(node.right)\\n            if not node.left and not node.right:\\n                l.append(str(node.val))\\n        return sum([int(i,2) for i in l])\\n```\\nIf you like the solution, please vote for this.",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        bfs = [root]\\n        l = []\\n        while bfs:\\n            node = bfs.pop(0)\\n            if node.left:\\n                x = node.left.val\\n                node.left.val = str(node.val) + str(x)\\n                bfs.append(node.left)\\n            if node.right:\\n                x = node.right.val\\n                node.right.val = str(node.val) + str(x)\\n                bfs.append(node.right)\\n            if not node.left and not node.right:\\n                l.append(str(node.val))\\n        return sum([int(i,2) for i in l])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837027,
                "title": "python-w-explanation",
                "content": "This question is identical to [Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/). The only difference is that we construct a decimal number while traversing the tree while here, we construct a binary number. \\n([Solution](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/706013/Python-Recursion-w-Explanation) to  [Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/))\\n\\nThe idea is to recurse in a somewhat \\'preorder\\' manner such that at each valid node, we update the value and then recurse on left subtree and then on right.\\n\\n```\\nclass Solution:\\n        \\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return self._helper(root, 0)\\n    \\n    def _helper(self, node: TreeNode, val: int):\\n        if node is None:\\n            return 0\\n\\n        # Keep building the \\'binary number\\' along the way\\n        # Identical to building \\'decimal number\\' : number_till_now * 10 + current_number\\n        val = val * 2 + node.val\\n        \\n        if not node.left and not node.right:\\n            return val\\n        \\n        return self._helper(node.left, val) + self._helper(node.right, val)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n        \\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return self._helper(root, 0)\\n    \\n    def _helper(self, node: TreeNode, val: int):\\n        if node is None:\\n            return 0\\n\\n        # Keep building the \\'binary number\\' along the way\\n        # Identical to building \\'decimal number\\' : number_till_now * 10 + current_number\\n        val = val * 2 + node.val\\n        \\n        if not node.left and not node.right:\\n            return val\\n        \\n        return self._helper(node.left, val) + self._helper(node.right, val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836978,
                "title": "c-oneliner-dfs-solution-explained-100-time-85-space",
                "content": "And today too I enjoyed giving myself the extra challenge of solving it in one line, recursively.\\n\\nOur function has basically 3 conditions:\\n* empty tree (`!root`) => we return `res` (set to its default value, `0`);\\n* the node is a leaf (`!root->left && !root->right`) => we return the updated value in `res` with the current value in the node (`res * 2 + root->val`);\\n* at least one branch is still present, so we call recursively the function on that branch with updated value of `res` (see above), or return `0` is the branch is not there.\\n\\nThe code, first iteration:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return !root ? res : !root->left && !root->right ? res * 2 + root->val : (root->left ? sumRootToLeaf(root->left, res * 2 + root->val) : 0) + (root->right ? sumRootToLeaf(root->right, res * 2 + root->val) : 0); \\n    }\\n};\\n```\\n\\nFurther ninjaed version, using the comma operator to compute `res` only once:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return (res = res * 2 + (root ? root->val : 0), !root || !root->left && !root->right ? res : (root->left ? sumRootToLeaf(root->left, res) : 0) + (root->right ? sumRootToLeaf(root->right, res) : 0)); \\n    }\\n};\\n```\\n\\nThird iteration, swapping the conditionals from the above, to save at least a couple of boolean negations (would the compiler do that for me?):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return (res = res * 2 + (root ? root->val : 0), root && (root->left || root->right) ?  (root->left ? sumRootToLeaf(root->left, res) : 0) + (root->right ? sumRootToLeaf(root->right, res) : 0) : res); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return !root ? res : !root->left && !root->right ? res * 2 + root->val : (root->left ? sumRootToLeaf(root->left, res * 2 + root->val) : 0) + (root->right ? sumRootToLeaf(root->right, res * 2 + root->val) : 0); \\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return (res = res * 2 + (root ? root->val : 0), !root || !root->left && !root->right ? res : (root->left ? sumRootToLeaf(root->left, res) : 0) + (root->right ? sumRootToLeaf(root->right, res) : 0)); \\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return (res = res * 2 + (root ? root->val : 0), root && (root->left || root->right) ?  (root->left ? sumRootToLeaf(root->left, res) : 0) + (root->right ? sumRootToLeaf(root->right, res) : 0) : res); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450928,
                "title": "python-3-dfs-clean-version",
                "content": "\\tclass Solution:\\n\\t\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n\\n\\t\\t\\tdef dfs(node, previous):\\n\\t\\t\\t\\tif not node.left and not node.right:\\n\\t\\t\\t\\t\\tyield 2*previous+node.val\\n\\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tyield from dfs(node.left, 2*previous+node.val)\\n\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tyield from dfs(node.right, 2*previous+node.val)\\n\\n\\t\\t\\treturn sum(dfs(root, 0))",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n\\n\\t\\t\\tdef dfs(node, previous):\\n\\t\\t\\t\\tif not node.left and not node.right:\\n\\t\\t\\t\\t\\tyield 2*previous+node.val\\n\\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tyield from dfs(node.left, 2*previous+node.val)\\n\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tyield from dfs(node.right, 2*previous+node.val)\\n\\n\\t\\t\\treturn sum(dfs(root, 0))",
                "codeTag": "Java"
            },
            {
                "id": 270055,
                "title": "easy-to-understand-python",
                "content": "```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.total = 0\\n        def rec(node,cbuf = \"\"):\\n            if not node:\\n                return \\n            if not node.left and not node.right:\\n                cval = cbuf + str(node.val)\\n                self.total+=int(cval,2)\\n            else:\\n                tmp = cbuf + str(node.val)\\n                rec(node.left,tmp)\\n                rec(node.right,tmp)        \\n        rec(root)\\n        return self.total % (10**9 +7)\\n```",
                "solutionTags": [],
                "code": "```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.total = 0\\n        def rec(node,cbuf = \"\"):\\n            if not node:\\n                return \\n            if not node.left and not node.right:\\n                cval = cbuf + str(node.val)\\n                self.total+=int(cval,2)\\n            else:\\n                tmp = cbuf + str(node.val)\\n                rec(node.left,tmp)\\n                rec(node.right,tmp)        \\n        rec(root)\\n        return self.total % (10**9 +7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3209144,
                "title": "simple-easy-to-understand-beat-100",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, string s, vector<string>&num){\\n        if(root->left==NULL && root->right==NULL){\\n            s.push_back(root->val + \\'0\\');\\n            num.push_back(s);\\n            s.pop_back();\\n            return;\\n        }\\n        s.push_back(root->val + \\'0\\');\\n        if(root->left)\\n            solve(root->left,s,num);\\n        if(root->right)\\n            solve(root->right,s,num);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int sum=0;\\n        vector<string>num;\\n        string s=\"\";\\n        solve(root,s,num);\\n        for(int i=0;i<num.size();i++){\\n            sum+= stoi(num[i],0,2);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, string s, vector<string>&num){\\n        if(root->left==NULL && root->right==NULL){\\n            s.push_back(root->val + \\'0\\');\\n            num.push_back(s);\\n            s.pop_back();\\n            return;\\n        }\\n        s.push_back(root->val + \\'0\\');\\n        if(root->left)\\n            solve(root->left,s,num);\\n        if(root->right)\\n            solve(root->right,s,num);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int sum=0;\\n        vector<string>num;\\n        string s=\"\";\\n        solve(root,s,num);\\n        for(int i=0;i<num.size();i++){\\n            sum+= stoi(num[i],0,2);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031949,
                "title": "c-easy-recursive-approach-dfs",
                "content": "TC: O(N)\\nSC: Auxiliary Stack Space O(N)\\n```\\nclass Solution {\\npublic:\\n    long sum=0;\\n    void solve(TreeNode* &root,long val){\\n        //base case\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            sum+= (val*2 + root->val);\\n            return;\\n        }\\n        solve(root->left,val*2+root->val);\\n        solve(root->right,val*2+root->val);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        solve(root,0);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long sum=0;\\n    void solve(TreeNode* &root,long val){\\n        //base case\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            sum+= (val*2 + root->val);\\n            return;\\n        }\\n        solve(root->left,val*2+root->val);\\n        solve(root->right,val*2+root->val);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        solve(root,0);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467041,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint ans = 0;\\n\\t\\tvoid solve(TreeNode *root, int buff){\\n\\n\\t\\t\\tbuff = buff*2 + root->val;\\n\\n\\t\\t\\tif(!root->left && !root->right){\\n\\n\\t\\t\\t\\tans += buff;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(root->left) solve(root->left, buff);\\n\\t\\t\\tif(root->right) solve(root->right, buff);\\n\\t\\t}\\n\\n\\t\\tint sumRootToLeaf(TreeNode* root) {\\n\\n\\t\\t\\tint buff = 0;\\n\\t\\t\\tsolve(root, buff);\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint ans = 0;\\n\\t\\tvoid solve(TreeNode *root, int buff){\\n\\n\\t\\t\\tbuff = buff*2 + root->val;\\n\\n\\t\\t\\tif(!root->left && !root->right){\\n\\n\\t\\t\\t\\tans += buff;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2345249,
                "title": "dfs",
                "content": "```\\nclass Solution {\\n  int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        traverse(root,\"\");\\n        return sum;\\n        }\\n    public void traverse(TreeNode root,String prev)\\n    {\\n        if(root==null)\\n            return;\\n        if(root.left==null&&root.right==null)\\n        {\\n             prev=Integer.toString(root.val)+prev;\\n            ANS(prev);\\n            return;\\n        }\\n        prev=Integer.toString(root.val)+prev;\\n        traverse(root.left,prev);\\n        traverse(root.right,prev);\\n        return;\\n        \\n    }\\n    public void ANS(String s)\\n    {\\n        int res=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            String s1= Character.toString(s.charAt(i));\\n            res=res+(1<<i)*Integer.parseInt(s1);\\n        }\\n        sum=sum+res;\\n    }\\n    \\n}",
                "solutionTags": [
                    "String",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n  int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        traverse(root,\"\");\\n        return sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1682249,
                "title": "c-using-vectors",
                "content": "\\n\\t\\tvoid getPath(TreeNode* root,vector<vector<int>> &allpath,vector<int> path){\\n        if(!root) return;\\n        \\n        path.push_back(root->val);\\n\\t\\t\\n        if(root->left==NULL && root->right==NULL){\\n            allpath.push_back(path);\\n        }\\n        getPath(root->left,allpath,path);\\n        getPath(root->right,allpath,path);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<vector<int>> allpath;\\n        vector<int> path;\\n        getPath(root,allpath,path);\\n        int sum=0;\\n        for(int i=0;i<allpath.size();i++){\\n            int cur=0;\\n            int n=allpath[i].size()-1;\\n            for(int j=allpath[i].size()-1;j>=0;j--){\\n                if(allpath[i][j]==0) continue;\\n                cur+=pow(2,n-j);\\n            }\\n            sum+=cur;\\n        }\\n        \\n        return sum;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n\\t\\tvoid getPath(TreeNode* root,vector<vector<int>> &allpath,vector<int> path){\\n        if(!root) return;\\n        \\n        path.push_back(root->val);\\n\\t\\t\\n        if(root->left==NULL && root->right==NULL){\\n            allpath.push_back(path);\\n        }\\n        getPath(root->left,allpath,path);\\n        getPath(root->right,allpath,path);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<vector<int>> allpath;\\n        vector<int> path;\\n        getPath(root,allpath,path);\\n        int sum=0;\\n        for(int i=0;i<allpath.size();i++){\\n            int cur=0;\\n            int n=allpath[i].size()-1;\\n            for(int j=allpath[i].size()-1;j>=0;j--){\\n                if(allpath[i][j]==0) continue;\\n                cur+=pow(2,n-j);\\n            }\\n            sum+=cur;\\n        }\\n        \\n        return sum;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1626645,
                "title": "c-single-pass-solution-0-n-less-than-5-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(TreeNode* root,int val){\\n        if(!root)\\n            return(0);\\n        if(!root->right&&!root->left){\\n            return((root->val)+val*2);\\n        }\\n        val=(root->val)+val*2;\\n        return(f(root->left,val)+f(root->right,val));\\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n    return(f(root,0));\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(TreeNode* root,int val){\\n        if(!root)\\n            return(0);\\n        if(!root->right&&!root->left){\\n            return((root->val)+val*2);\\n        }\\n        val=(root->val)+val*2;\\n        return(f(root->left,val)+f(root->right,val));\\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n    return(f(root,0));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586855,
                "title": "easy-to-learn-for-beginer-c",
                "content": "```\\nclass Solution {\\n    int ri=0; //define a universal   variable\\n\\npublic: \\n    \\n    void util(TreeNode* root,int ans){\\n        if(!root)\\n        {\\n            return;\\n        }\\n        //converting binary to real number\\n        ans=ans*2+root->val;\\n        \\n        if(!root->left && !root->right)\\n        {\\n            ri+=ans;\\n        }\\n        util(root->left,ans);\\n        util(root->right,ans);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans=0;\\n        util(root,ans);\\n        return ri;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int ri=0; //define a universal   variable\\n\\npublic: \\n    \\n    void util(TreeNode* root,int ans){\\n        if(!root)\\n        {\\n            return;\\n        }\\n        //converting binary to real number\\n        ans=ans*2+root->val;\\n        \\n        if(!root->left && !root->right)\\n        {\\n            ri+=ans;\\n        }\\n        util(root->left,ans);\\n        util(root->right,ans);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans=0;\\n        util(root,ans);\\n        return ri;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431470,
                "title": "c-easy-solution-with-explanation",
                "content": "Firstly I am using preOrder traverslal to get the nodes and pushing them in a vector. As a leaf node is reached the vector is being sent to the function \\'add\\' where its bieng converted to the Decimal equivalent. Through backtracking we are storing each value according into the vector. PLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\npublic:\\n   int res;\\n    int add(vector<int>s)\\n    {\\n        int c=0;int k=0;\\n        while(!s.empty())\\n        {\\n            k=k+(s.back()*pow(2,c));\\n            c++;\\n            s.pop_back();\\n        }\\n        return k;\\n    }\\n    void calc(TreeNode *root,vector<int>s,int c)\\n    {\\n      \\n         if(root==nullptr)\\n             return;\\n       // cout<<root->val<<\" \";\\n       s.push_back(root->val);\\n        calc(root->left,s,c);\\n         calc(root->right,s,c);\\n    \\n        if(root->left==nullptr&&root->right==nullptr)\\n        {\\n          int m=add(s);\\n        res=res+m;\\n        }\\n             \\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int>s;\\n        calc(root,s,0);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   int res;\\n    int add(vector<int>s)\\n    {\\n        int c=0;int k=0;\\n        while(!s.empty())\\n        {\\n            k=k+(s.back()*pow(2,c));\\n            c++;\\n            s.pop_back();\\n        }\\n        return k;\\n    }\\n    void calc(TreeNode *root,vector<int>s,int c)\\n    {\\n      \\n         if(root==nullptr)\\n             return;\\n       // cout<<root->val<<\" \";\\n       s.push_back(root->val);\\n        calc(root->left,s,c);\\n         calc(root->right,s,c);\\n    \\n        if(root->left==nullptr&&root->right==nullptr)\\n        {\\n          int m=add(s);\\n        res=res+m;\\n        }\\n             \\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int>s;\\n        calc(root,s,0);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1191997,
                "title": "python-python3-sum-of-root-to-leaf-binary-numbers",
                "content": "***ShamelessSelfPromotion***: My other leetcode [solutions](https://leetcode.com/discuss/general-discussion/1112952/Collection-of-my-leetcode-solution-posts) to various questions can be found [here](https://leetcode.com/discuss/general-discussion/1112952/Collection-of-my-leetcode-solution-posts)\\n\\nTime: O(N)\\nSpace: O(1)\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def calc(node, temp):\\n            if not node:\\n                return 0\\n            \\n            temp = temp*2 + node.val\\n            if (node.left is None) and (node.right is None):\\n                return temp\\n            \\n            return (calc(node.left, temp) + calc(node.right, temp))\\n        \\n        return calc(root, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def calc(node, temp):\\n            if not node:\\n                return 0\\n            \\n            temp = temp*2 + node.val\\n            if (node.left is None) and (node.right is None):\\n                return temp\\n            \\n            return (calc(node.left, temp) + calc(node.right, temp))\\n        \\n        return calc(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835986,
                "title": "easy-cpp-basic-dfs-o-n-beats-100",
                "content": "The idea is simple, keep adding the current node\\'s value in our temporary sum all the while left shifting it (multiplying by 2).\\nThen we run dfs for its left and right children. When we are done with this node\\'s children, then subtract the node\\'s value from our temporary sum and then right shift it (divide by 2). \\nWhen we reach a leaf node, we add this temporary sum obtained so far to our answer variable. This way, whenever we reach a leaf node, we have found the (temporary) sum of that line of numbers in base 10.\\nTime Complexity - O(N)\\nSpace Complexity - O(1) ~ excluding the recursion stack\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long ans=0;\\n    long sum=0;\\n    void dfs(TreeNode* root){\\n        if(root==NULL){\\n            // ans+=sum;\\n            return;\\n        }\\n        sum=(sum*2)+root->val; //left shift and add current node\\'s value\\n        if(!root->left&&!root->right){ // if leaf add temporary sum in ans\\n            ans+=sum;\\n            \\n            sum-=root->val; //subtract current node\\'s value\\n            sum=sum/2; //right shift\\n            return;\\n        }\\n        //if not leaf then continue dfs for its children\\n        dfs(root->left);\\n        dfs(root->right);\\n        sum-=root->val;\\n        sum=sum/2;\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        ans=0;\\n        sum=0;\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long ans=0;\\n    long sum=0;\\n    void dfs(TreeNode* root){\\n        if(root==NULL){\\n            // ans+=sum;\\n            return;\\n        }\\n        sum=(sum*2)+root->val; //left shift and add current node\\'s value\\n        if(!root->left&&!root->right){ // if leaf add temporary sum in ans\\n            ans+=sum;\\n            \\n            sum-=root->val; //subtract current node\\'s value\\n            sum=sum/2; //right shift\\n            return;\\n        }\\n        //if not leaf then continue dfs for its children\\n        dfs(root->left);\\n        dfs(root->right);\\n        sum-=root->val;\\n        sum=sum/2;\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        ans=0;\\n        sum=0;\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679980,
                "title": "scala-solution",
                "content": "```\\ndef sumRootToLeaf(root: TreeNode): Int = {\\n        def dfs(root: TreeNode, v: Int):Int = {\\n          if(root == null) return 0;\\n          val ret= v*2 + root.value\\n          if(root.left == null && root.right == null) return ret\\n          return dfs(root.left, ret) + dfs(root.right, ret)\\n        }\\n        return dfs(root, 0)\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\ndef sumRootToLeaf(root: TreeNode): Int = {\\n        def dfs(root: TreeNode, v: Int):Int = {\\n          if(root == null) return 0;\\n          val ret= v*2 + root.value\\n          if(root.left == null && root.right == null) return ret\\n          return dfs(root.left, ret) + dfs(root.right, ret)\\n        }\\n        return dfs(root, 0)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 475737,
                "title": "easy-c-dfs",
                "content": "```\\npublic class Solution\\n{\\n    private void Helper(TreeNode node, ref int sum, int current)\\n    {\\n        if (node == null)\\n        {\\n            return;\\n        }\\n\\n        current *= 2;\\n        current += node.val;\\n\\n        if (node.left == null && node.right == null)\\n        {\\n            sum += current;\\n            return;\\n        }\\n\\n        Helper(node.left, ref sum, current);\\n        Helper(node.right, ref sum, current);\\n    }\\n\\n    public int SumRootToLeaf(TreeNode root)\\n    {\\n        int sum = 0;\\n        Helper(root, ref sum, 0);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    private void Helper(TreeNode node, ref int sum, int current)\\n    {\\n        if (node == null)\\n        {\\n            return;\\n        }\\n\\n        current *= 2;\\n        current += node.val;\\n\\n        if (node.left == null && node.right == null)\\n        {\\n            sum += current;\\n            return;\\n        }\\n\\n        Helper(node.left, ref sum, current);\\n        Helper(node.right, ref sum, current);\\n    }\\n\\n    public int SumRootToLeaf(TreeNode root)\\n    {\\n        int sum = 0;\\n        Helper(root, ref sum, 0);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433129,
                "title": "javascript-recursive-99",
                "content": "```\\nvar sumRootToLeaf = function(root) {\\n    const numbers = [];\\n    \\n    const bst = (node, binary) => {\\n        if (!node.left && !node.right) {\\n            numbers.push(binary + node.val);\\n        } else if (!node.left || !node.right) {\\n            if (node.left)\\n                bst(node.left, binary + node.val);\\n            else\\n                bst(node.right, binary + node.val);\\n        } else {\\n            bst(node.left, binary + node.val);\\n            bst(node.right, binary + node.val);\\n        }\\n    };\\n    \\n    bst(root, \\'\\');\\n    \\n    let answer = 0;\\n    for (const num of numbers) {\\n        let parsed = parseInt(num, 2);\\n        answer += parsed;\\n    }\\n    \\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar sumRootToLeaf = function(root) {\\n    const numbers = [];\\n    \\n    const bst = (node, binary) => {\\n        if (!node.left && !node.right) {\\n            numbers.push(binary + node.val);\\n        } else if (!node.left || !node.right) {\\n            if (node.left)\\n                bst(node.left, binary + node.val);\\n            else\\n                bst(node.right, binary + node.val);\\n        } else {\\n            bst(node.left, binary + node.val);\\n            bst(node.right, binary + node.val);\\n        }\\n    };\\n    \\n    bst(root, \\'\\');\\n    \\n    let answer = 0;\\n    for (const num of numbers) {\\n        let parsed = parseInt(num, 2);\\n        answer += parsed;\\n    }\\n    \\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350078,
                "title": "c-binary-to-decimal-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint res = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n    \\tvector<int> bin;\\n        dfs(root, bin);\\n        return res;\\n    }\\n    \\n    void dfs(TreeNode *curr, vector<int> &bin) {\\n    \\tif(!curr) return;\\n    \\tbin.push_back(curr->val);\\n    \\tif(!curr->left && !curr->right) res += binaryToDecimal(bin);\\n    \\tdfs(curr->left, bin);\\n    \\tdfs(curr->right, bin);\\n\\t\\tbin.pop_back();\\t\\n\\t}\\n\\t\\n\\tint binaryToDecimal(vector<int> &bin) {\\n\\t\\tint sum = 0;\\n\\t\\tfor(int i=0; i<bin.size(); i++) sum += (bin[i])*(pow(2, bin.size()-1-i));\\n\\t\\treturn sum;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint res = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n    \\tvector<int> bin;\\n        dfs(root, bin);\\n        return res;\\n    }\\n    \\n    void dfs(TreeNode *curr, vector<int> &bin) {\\n    \\tif(!curr) return;\\n    \\tbin.push_back(curr->val);\\n    \\tif(!curr->left && !curr->right) res += binaryToDecimal(bin);\\n    \\tdfs(curr->left, bin);\\n    \\tdfs(curr->right, bin);\\n\\t\\tbin.pop_back();\\t\\n\\t}\\n\\t\\n\\tint binaryToDecimal(vector<int> &bin) {\\n\\t\\tint sum = 0;\\n\\t\\tfor(int i=0; i<bin.size(); i++) sum += (bin[i])*(pow(2, bin.size()-1-i));\\n\\t\\treturn sum;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273229,
                "title": "java-runtime-0-ms-faster-than-100-00-memory-usage-37-4-mb-less-than-100-00",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Sum of Root To Leaf Binary Numbers.\\nMemory Usage: 37.4 MB, less than 100.00% of Java online submissions for Sum of Root To Leaf Binary Numbers.\\n```class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return getSumForAllRootToLeaf(root, 0, 0);\\n\\n    }\\n    public int getSumForAllRootToLeaf(TreeNode root, int total, int curSum) {\\n        if (root == null) return total;\\n\\t\\t\\n        curSum = curSum * 2  + root.val;\\n        if (root.left == null && root.right == null) {\\n            total += curSum;\\n            return total;\\n        }\\n        total = getSumForAllRootToLeaf(root.left, total, curSum);\\n        return getSumForAllRootToLeaf(root.right, total, curSum);\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return getSumForAllRootToLeaf(root, 0, 0);\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3489755,
                "title": "java-beats-100-recursive-shifting-bits-with-deep-explanation",
                "content": "Dont forget to upvote if you like the content below. \\uD83D\\uDE43\\n\\n# Intuition\\nThe problem asks for the sum of all root-to-leaf binary numbers in a binary tree. A key insight is that the binary number represented by the path from the root to any node is simply the binary number of its parent shifted left by one bit, plus the value of the current node. \\n\\n# Approach\\nWe perform a depth-first search (DFS) traversal on the binary tree, passing the binary number represented by the path from the root to the current node to each recursive call. At each node, we calculate the total sum by shifting the current sum to the left by one bit and adding the value of the current node.\\n\\nIf the current node is a leaf node (both left and right subtrees are `null`), we return the total sum calculated at this node. Otherwise, we return the sum of the sums calculated from the left and right subtrees.\\n\\n# Complexity Analysis\\n- Time complexity: The time complexity is $$O(n)$$, where n is the number of nodes in the binary tree. This is because we visit each node exactly once.\\n- Space complexity: The space complexity is $$O(h)$$, where h is the height of the binary tree. This is because the maximum amount of space is utilized by the recursion stack in the case of a skewed binary tree, which could be $$h$$ levels deep.\\n\\n# Code\\n```java\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return calculateSum(root, 0);\\n    }\\n\\n    private static int calculateSum(TreeNode node, int currentSum) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        int totalSum = (currentSum << 1) + node.val;\\n        int leftSubTreeSum = calculateSum(node.left, totalSum);\\n        int rightSubTreeSum = calculateSum(node.right, totalSum);\\n        if (leftSubTreeSum == 0 && rightSubTreeSum == 0) {\\n            return totalSum;\\n        } else {\\n            return leftSubTreeSum + rightSubTreeSum;\\n        }\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return calculateSum(root, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3483729,
                "title": "simple-recursive-solution-using-stoi",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* root,string a){\\n        if(!root)return;\\n        a.push_back(\\'0\\'+(root->val));\\n        if(!root->left && !root->right) solve(a);\\n        dfs(root->left,a);\\n        dfs(root->right,a);\\n    }\\n    void solve(string a){\\n        int dec = stoi(a, nullptr, 2);\\n        ans=ans+dec;\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string a=\"\";\\n        dfs(root,a);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* root,string a){\\n        if(!root)return;\\n        a.push_back(\\'0\\'+(root->val));\\n        if(!root->left && !root->right) solve(a);\\n        dfs(root->left,a);\\n        dfs(root->right,a);\\n    }\\n    void solve(string a){\\n        int dec = stoi(a, nullptr, 2);\\n        ans=ans+dec;\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string a=\"\";\\n        dfs(root,a);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340817,
                "title": "recursive-preorder-traversal-complexity-analysis",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe traverse the Tree, And keep a Global Answer Variable. We keep a current empty number and traverse the tree, incrementing it accordingly as we traverse the tree. When we reach the leaf node, it indicates end of the current number and needs to be added into the final answer variable. We just do this process for the entire tree and return the answer. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity Analysis\\n# Time Complexity : O(N)\\nHere N is the Number of Nodes in the Binary Tree.\\n(Since we traverse all the Nodes in the Binary Tree)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Space Complexity : O(H)\\nHere, H is the height of the Binary Tree.\\n(Since Recursion Stack Space used is of the order of the height of tree).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    long number = 0;\\n    void traverse(TreeNode* root, int curr)\\n    {\\n        if(root==NULL) return;\\n        curr = (curr<<1) | root->val;\\n        if(root->left == NULL && root->right ==NULL)\\n        {\\n            number += curr;\\n        }\\n        traverse(root->left,curr);\\n        traverse(root->right,curr);\\n    }\\n    long long int sumRootToLeaf(TreeNode* root) \\n    {\\n        if(root == NULL) return 0;\\n        traverse(root,0);\\n        return number;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    long number = 0;\\n    void traverse(TreeNode* root, int curr)\\n    {\\n        if(root==NULL) return;\\n        curr = (curr<<1) | root->val;\\n        if(root->left == NULL && root->right ==NULL)\\n        {\\n            number += curr;\\n        }\\n        traverse(root->left,curr);\\n        traverse(root->right,curr);\\n    }\\n    long long int sumRootToLeaf(TreeNode* root) \\n    {\\n        if(root == NULL) return 0;\\n        traverse(root,0);\\n        return number;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167220,
                "title": "c-backtrack-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically, we can always take backTrack solution into consideration while encountering N-ary tree problems.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\neach node would be traversaled only once, so O(n);\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int> res;\\n        backTrack(root, res);\\n        return ans;\\n    }\\n    void backTrack(TreeNode* root, vector<int>& res) {\\n        if (!root) return;\\n        // if leaf node now, we calculate the pathSum\\n        if (!root->left && !root->right) {  \\n            res.push_back(root->val);\\n            int N = res.size();\\n            for (int i = N-1; i >= 0; --i) {\\n                ans += res[i] * std::pow(2, N-1-i);\\n            }\\n            res.pop_back();\\n            return;\\n        }\\n        // backTrack\\n        res.push_back(root->val);\\n        backTrack(root->left, res);\\n        backTrack(root->right, res);\\n        res.pop_back();\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int> res;\\n        backTrack(root, res);\\n        return ans;\\n    }\\n    void backTrack(TreeNode* root, vector<int>& res) {\\n        if (!root) return;\\n        // if leaf node now, we calculate the pathSum\\n        if (!root->left && !root->right) {  \\n            res.push_back(root->val);\\n            int N = res.size();\\n            for (int i = N-1; i >= 0; --i) {\\n                ans += res[i] * std::pow(2, N-1-i);\\n            }\\n            res.pop_back();\\n            return;\\n        }\\n        // backTrack\\n        res.push_back(root->val);\\n        backTrack(root->left, res);\\n        backTrack(root->right, res);\\n        res.pop_back();\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868440,
                "title": "without-using-mod-20line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust add each path value to the list as we reach at end of path and each value is converted to decimal number and added to total sum;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdd each path value to the list as we reach at end of path\\nbut while adding if we reached at root which is null it will add to list value getting from both left and right path as we this will make duplicate addition to tackle this just add value before reaching null which is when left and right is null which avoids duplicates.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        _sum(root, \"\");\\n        int count = 0;\\n        for(String s : res){\\n            System.out.println(s);\\n            count+=Integer.parseInt(s, 2);\\n        }\\n        \\n        return count;\\n    }\\n    private void _sum(TreeNode root, String str){\\n        if(root == null){\\n            \\n            return;\\n        }\\n        if(root.left == null && root.right == null) {\\n            str += root.val;\\n            res.add(str);\\n            return;\\n        }\\n        str += \"\"+ root.val;\\n        _sum(root.left, str);\\n        _sum(root.right, str);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        _sum(root, \"\");\\n        int count = 0;\\n        for(String s : res){\\n            System.out.println(s);\\n            count+=Integer.parseInt(s, 2);\\n        }\\n        \\n        return count;\\n    }\\n    private void _sum(TreeNode root, String str){\\n        if(root == null){\\n            \\n            return;\\n        }\\n        if(root.left == null && root.right == null) {\\n            str += root.val;\\n            res.add(str);\\n            return;\\n        }\\n        str += \"\"+ root.val;\\n        _sum(root.left, str);\\n        _sum(root.right, str);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675357,
                "title": "top-down-approach-dfs-beats-100",
                "content": "//Top down approach, similar to  leetcode problem [https://leetcode.com/problems/sum-root-to-leaf-numbers/]()\\n\\n```\\nclass Solution {\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        return dfs(root,0);\\n    }\\n    public int dfs(TreeNode root,int s)\\n    {\\n        if(root==null)\\n            return 0;\\n        if(root.left==null && root.right==null)\\n            return root.val+s*2;\\n        else\\n            return dfs(root.left,root.val+s*2)+\\n                   dfs(root.right,root.val+s*2);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        return dfs(root,0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2666573,
                "title": "c-solution-sum-of-root-to-leaf-binary-numbers",
                "content": "```\\nclass Solution {\\nprivate:\\n    int binarytoInteger(vector<int> bin){\\n        int ans = 0;\\n        int size = bin.size()-1;\\n        for(int i = 0 ; i < bin.size() ; i++){\\n            if(bin[i] == 1){\\n            ans += pow(2,size);\\n            }\\n            size--;\\n        }\\n        return ans;\\n    }\\n    \\n    void solve(TreeNode* root , vector<int> path , int &sum){\\n        //base case\\n        if(root == NULL)\\n            return;\\n        \\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            int x = binarytoInteger(path);\\n            sum += x;\\n        }\\n        \\n        solve(root->left , path , sum);\\n        solve(root->right , path , sum);\\n        \\n        path.pop_back();\\n    }\\n    \\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int> path;\\n        int sum = 0;\\n        solve(root , path , sum);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int binarytoInteger(vector<int> bin){\\n        int ans = 0;\\n        int size = bin.size()-1;\\n        for(int i = 0 ; i < bin.size() ; i++){\\n            if(bin[i] == 1){\\n            ans += pow(2,size);\\n            }\\n            size--;\\n        }\\n        return ans;\\n    }\\n    \\n    void solve(TreeNode* root , vector<int> path , int &sum){\\n        //base case\\n        if(root == NULL)\\n            return;\\n        \\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            int x = binarytoInteger(path);\\n            sum += x;\\n        }\\n        \\n        solve(root->left , path , sum);\\n        solve(root->right , path , sum);\\n        \\n        path.pop_back();\\n    }\\n    \\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int> path;\\n        int sum = 0;\\n        solve(root , path , sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635118,
                "title": "python-iterative-dfs-solution",
                "content": "\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n  \\n        res  = 0\\n        stack = [(root, \"\")]\\n        \\n        while(stack):\\n            node, path = stack.pop()\\n            if node:\\n                path += str(node.val)\\n\\n                if not(node.left or node.right):\\n                    res += int(path, 2)\\n                else:\\n                    stack.append((node.left, path))\\n                    stack.append((node.right,path))\\n        return res",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n  \\n        res  = 0\\n        stack = [(root, \"\")]\\n        \\n        while(stack):\\n            node, path = stack.pop()\\n            if node:\\n                path += str(node.val)\\n\\n                if not(node.left or node.right):\\n                    res += int(path, 2)\\n                else:\\n                    stack.append((node.left, path))\\n                    stack.append((node.right,path))\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2555788,
                "title": "everything-explained-using-comment-java-c-tree",
                "content": "```\\n/* Java Solution */\\nclass Solution {\\n    \\n    public int sumRootToLeaf(TreeNode root,int sum)\\n    {\\n\\t\\t// Base Cases Think only root is present and construct the base cases.Recursion will handle the other cases.\\n        if(root == null) return 0;\\n        \\n        sum = (2*sum) + root.val;      // To convert binary to decimal.\\n        \\n        if(root.left == null && root.right == null) return sum;   // If only root is present.\\n        \\n        return sumRootToLeaf(root.left,sum) + sumRootToLeaf(root.right,sum);\\n    }\\n    \\n    \\n    public int sumRootToLeaf(TreeNode root) \\n    {\\n        return sumRootToLeaf(root,0);\\n    }\\n}\\n\\n\\n\\n/* C++ Solution */\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode *root,int sum)\\n    {\\n        // Base Cases Think only root is present and construct the base cases.Recursion will handle the other cases.\\n        if(!root) return 0;\\n        \\n        sum = (2*sum) + root->val;  // To convert binary to decimal.\\n        \\n        if(!root->left && !root->right) return sum;  // If only root is present.\\n        \\n        return sumRootToLeaf(root->left,sum) + sumRootToLeaf(root->right,sum);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        return sumRootToLeaf(root,0);\\n    }\\n    \\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/* Java Solution */\\nclass Solution {\\n    \\n    public int sumRootToLeaf(TreeNode root,int sum)\\n    {\\n\\t\\t// Base Cases Think only root is present and construct the base cases.Recursion will handle the other cases.\\n        if(root == null) return 0;\\n        \\n        sum = (2*sum) + root.val;      // To convert binary to decimal.\\n        \\n        if(root.left == null && root.right == null) return sum;   // If only root is present.\\n        \\n        return sumRootToLeaf(root.left,sum) + sumRootToLeaf(root.right,sum);\\n    }\\n    \\n    \\n    public int sumRootToLeaf(TreeNode root) \\n    {\\n        return sumRootToLeaf(root,0);\\n    }\\n}\\n\\n\\n\\n/* C++ Solution */\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode *root,int sum)\\n    {\\n        // Base Cases Think only root is present and construct the base cases.Recursion will handle the other cases.\\n        if(!root) return 0;\\n        \\n        sum = (2*sum) + root->val;  // To convert binary to decimal.\\n        \\n        if(!root->left && !root->right) return sum;  // If only root is present.\\n        \\n        return sumRootToLeaf(root->left,sum) + sumRootToLeaf(root->right,sum);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        return sumRootToLeaf(root,0);\\n    }\\n    \\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549506,
                "title": "100-t-c-90-s-c-easy-short-fast-solutions",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n    public int sumRootToLeaf(TreeNode root) {\\n        sumRootToLeafRecur(root, 0);\\n        return ans;\\n    }\\n    int ans = 0;\\n    private void sumRootToLeafRecur(TreeNode root, int b){\\n        if (root == null) return;\\n        b = (b *= 2) + root.val;\\n        if (root.left == null && root.right == null) ans += b;\\n\\n        sumRootToLeafRecur(root.left, b);\\n        sumRootToLeafRecur(root.right, b);\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2317936,
                "title": "beginner-friendly-c-with-simple-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n  int sum=0;\\n\\n \\n  void rec(TreeNode* root,string s)\\n    \\n  {\\n if(root==NULL )\\n {\\n   return ;\\n }\\n    \\n    if(root->right==NULL && root->left==NULL)\\n      \\n    {\\n     \\n      s+=to_string(root->val);\\n       \\n      //sum=sum+stoi(s);\\n      sum=sum+stoi(s,nullptr,2);\\n  }\\n      \\n      \\n    \\n    s+=to_string(root->val);\\n    rec(root->left,s);\\n    rec(root->right,s);\\n    \\n  }\\n  \\n    \\n    \\n    \\n  \\n    int sumRootToLeaf(TreeNode* root) {\\n      //int n;\\n    string s=\"\";\\n      rec(root,s);\\n      return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int sum=0;\\n\\n \\n  void rec(TreeNode* root,string s)\\n    \\n  {\\n if(root==NULL )\\n {\\n   return ;\\n }\\n    \\n    if(root->right==NULL && root->left==NULL)\\n      \\n    {\\n     \\n      s+=to_string(root->val);\\n       \\n      //sum=sum+stoi(s);\\n      sum=sum+stoi(s,nullptr,2);\\n  }\\n      \\n      \\n    \\n    s+=to_string(root->val);\\n    rec(root->left,s);\\n    rec(root->right,s);\\n    \\n  }\\n  \\n    \\n    \\n    \\n  \\n    int sumRootToLeaf(TreeNode* root) {\\n      //int n;\\n    string s=\"\";\\n      rec(root,s);\\n      return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297499,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        ArrayList<String> arr = new ArrayList<String>();\\n        sumRootToLeafAux(root, \"\", arr);\\n        int ans = 0;\\n        for(int i = 0; i<arr.size(); i++){\\n            ans+=Integer.parseInt(arr.get(i), 2);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void sumRootToLeafAux(TreeNode node, String temp, List<String> arr) {\\n        if(node!=null){\\n            temp += node.val;\\n            if(node.left == null && node.right == null){\\n                arr.add(temp);\\n            }\\n            else{\\n                sumRootToLeafAux( node.left,  temp,  arr);\\n                sumRootToLeafAux( node.right,  temp,  arr);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        ArrayList<String> arr = new ArrayList<String>();\\n        sumRootToLeafAux(root, \"\", arr);\\n        int ans = 0;\\n        for(int i = 0; i<arr.size(); i++){\\n            ans+=Integer.parseInt(arr.get(i), 2);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void sumRootToLeafAux(TreeNode node, String temp, List<String> arr) {\\n        if(node!=null){\\n            temp += node.val;\\n            if(node.left == null && node.right == null){\\n                arr.add(temp);\\n            }\\n            else{\\n                sumRootToLeafAux( node.left,  temp,  arr);\\n                sumRootToLeafAux( node.right,  temp,  arr);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227161,
                "title": "c-easy-dfs-preorder-approach",
                "content": "**APPROACH :**\\n* In order to track path from root to leaf we ne to transverse using DFS-Preorder method.\\n* And instead of using string we can use shift operator.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\t// Recurssive function\\n    void helper(TreeNode*root, int &ans, int p){\\n        // If root is a NULL\\n\\t\\tif(!root) return;\\n        \\n\\t\\t// Update the path value\\n        p = (p<<1)+root->val;\\n\\t\\t\\n\\t\\t// update the ans if the root is a leaf.\\n        if(root->left == NULL && root->right == NULL)\\n            ans += p;\\n        \\n\\t\\t// DFS Preorder transversal\\n        helper(root->left, ans, p);\\n        helper(root->right, ans, p);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n\\t\\tint ans=0;\\n        helper(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you  find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\t// Recurssive function\\n    void helper(TreeNode*root, int &ans, int p){\\n        // If root is a NULL\\n\\t\\tif(!root) return;\\n        \\n\\t\\t// Update the path value\\n        p = (p<<1)+root->val;\\n\\t\\t\\n\\t\\t// update the ans if the root is a leaf.\\n        if(root->left == NULL && root->right == NULL)\\n            ans += p;\\n        \\n\\t\\t// DFS Preorder transversal\\n        helper(root->left, ans, p);\\n        helper(root->right, ans, p);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n\\t\\tint ans=0;\\n        helper(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148522,
                "title": "python-3-easy-solution",
                "content": "```\\ndef sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        \\n        stack = []\\n        def dfs(root, s):\\n            \\n            if not root:\\n                return\\n            each_val = str(root.val)\\n            if not root.left and not root.right:\\n                stack.append(int(s+each_val, 2))\\n                return\\n            \\n            dfs(root.left, s+each_val) \\n            \\n            dfs(root.right, s+each_val) \\n\\n        dfs(root, \"\")\\n        return(sum(stack))\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\ndef sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        \\n        stack = []\\n        def dfs(root, s):\\n            \\n            if not root:\\n                return\\n            each_val = str(root.val)\\n            if not root.left and not root.right:\\n                stack.append(int(s+each_val, 2))\\n                return\\n            \\n            dfs(root.left, s+each_val) \\n            \\n            dfs(root.right, s+each_val) \\n\\n        dfs(root, \"\")\\n        return(sum(stack))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2093508,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    ArrayList<ArrayList<Integer>>ans=new ArrayList<>();\\n    ArrayList<Integer>temp=new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        createlist(root);\\n        int tsum = 0;\\n        for(int i=0;i<ans.size();i++){\\n            tsum= tsum + sum(ans.get(i));\\n        }\\n        return tsum;\\n    }\\n    public static int sum(ArrayList<Integer>temp){\\n        int sum = 0;\\n        int x = 0;\\n        for(int i=temp.size()-1;i>=0;i--){\\n            sum+=temp.get(i)*Math.pow(2,x);\\n            x++;\\n        }\\n        return sum;\\n    }\\n    \\n     public void createlist(TreeNode root){\\n        if(root == null ){\\n            return ;\\n        }\\n        temp.add(root.val);\\n        if(root.left==null && root.right == null){\\n            ans.add(new ArrayList<Integer>(temp));\\n        }\\n        createlist(root.left);\\n        createlist(root.right);\\n        temp.remove(temp.size()-1);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    ArrayList<ArrayList<Integer>>ans=new ArrayList<>();\\n    ArrayList<Integer>temp=new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        createlist(root);\\n        int tsum = 0;\\n        for(int i=0;i<ans.size();i++){\\n            tsum= tsum + sum(ans.get(i));\\n        }\\n        return tsum;\\n    }\\n    public static int sum(ArrayList<Integer>temp){\\n        int sum = 0;\\n        int x = 0;\\n        for(int i=temp.size()-1;i>=0;i--){\\n            sum+=temp.get(i)*Math.pow(2,x);\\n            x++;\\n        }\\n        return sum;\\n    }\\n    \\n     public void createlist(TreeNode root){\\n        if(root == null ){\\n            return ;\\n        }\\n        temp.add(root.val);\\n        if(root.left==null && root.right == null){\\n            ans.add(new ArrayList<Integer>(temp));\\n        }\\n        createlist(root.left);\\n        createlist(root.right);\\n        temp.remove(temp.size()-1);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958546,
                "title": "python-eli5-a-solution-that-used-dfs-and-backtracing",
                "content": "A lot of the solutions for this question use something other than DFS or Backtracking. I guarantee that if you pull bitwise operators during an interview in which the interviewer is looking for your knowledge of DFS / Backtracking, you won\\'t get the job. so lets look at how this is supposed to be solved, even if it\\'s not the fastest way to do it.\\n\\nThe problem states that we need to get the binary number from the root to **all** the leaves in the tree. This phrase alone tells us that we need DFS with Backtracking. \\n\\nFor general reference, any problem that needs Backtracking will have a solution that looks like the following pseudocode:\\n\\n```python\\ndef dfs(node, state):\\n\\tif state is a solution:\\n\\t\\trecord(state)\\n\\t\\treturn\\n\\t\\n\\tfor child in children:\\n\\t\\tif child is part of solution:\\n\\t\\t\\tstate.add(child)\\n\\t\\t\\tdfs(child, state)\\n\\t\\t\\tstate.remove(child)\\n```\\n\\nFollow this format for permutation questions.\\n\\nLet\\'s look at the first part: If the current state is a solution. We\\'ll know we\\'ve got a solution for this problem once we\\'ve reached a leaf node. Therefore our if statement should look like this:\\n\\n```python\\n\\tif node.left is None and node.right is None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tanswer.append(\\'\\'.join(path))\\n\\t\\tpath.pop()\\n\\t\\treturn\\n```\\n\\nWe will add the current node to our current state, then save it to our collection of answers, then pop it before backtracking.\\n\\nNow we need to think about what to do if we\\'re not currently at a leaf node. Well, we need to append to the current state and go down both left and right until we reach a leaf node! So the second part of our format will look like this:\\n\\n```python\\n\\tif node.left is not None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tdfs(node.left, path)\\n\\t\\tpath.pop()\\n\\t\\n\\tif node.right is not None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tdfs(node.right, path)\\n\\t\\tpath.pop()\\n```\\n\\nNow we just put it all together and add a data structure to keep our potential answers with:\\n\\n```python\\ndef sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        answer = []\\n        def dfs(node, path):\\n            if node.left is None and node.right is None:\\n                path.append(str(node.val))\\n                answer.append(\\'\\'.join(path))\\n                path.pop()\\n                return\\n\\n            if node.left is not None:\\n                path.append(str(node.val))\\n                dfs(node.left, path)\\n                path.pop()\\n            if node.right is not None:\\n                path.append(str(node.val))\\n                dfs(node.right, path)\\n                path.pop()\\n                \\n        dfs(root, [])\\n```\\n\\nNow our `answer` array has the string representations of each root-to-leaf branch in our tree. It\\'s a simple matter of converting these binary strings to integers and adding them up:\\n\\n```python\\n\\tvalue = 0\\n\\tfor digits in answer:\\n\\t\\tvalue += int(digits, 2)\\n\\treturn value\\n```\\n\\nThis is not the fastest answer, but if you\\'re actually doing an interview, this is at least closer to what they will expect from you, and it is also much easier to explain during your interview.",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```python\\ndef dfs(node, state):\\n\\tif state is a solution:\\n\\t\\trecord(state)\\n\\t\\treturn\\n\\t\\n\\tfor child in children:\\n\\t\\tif child is part of solution:\\n\\t\\t\\tstate.add(child)\\n\\t\\t\\tdfs(child, state)\\n\\t\\t\\tstate.remove(child)\\n```\n```python\\n\\tif node.left is None and node.right is None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tanswer.append(\\'\\'.join(path))\\n\\t\\tpath.pop()\\n\\t\\treturn\\n```\n```python\\n\\tif node.left is not None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tdfs(node.left, path)\\n\\t\\tpath.pop()\\n\\t\\n\\tif node.right is not None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tdfs(node.right, path)\\n\\t\\tpath.pop()\\n```\n```python\\ndef sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        answer = []\\n        def dfs(node, path):\\n            if node.left is None and node.right is None:\\n                path.append(str(node.val))\\n                answer.append(\\'\\'.join(path))\\n                path.pop()\\n                return\\n\\n            if node.left is not None:\\n                path.append(str(node.val))\\n                dfs(node.left, path)\\n                path.pop()\\n            if node.right is not None:\\n                path.append(str(node.val))\\n                dfs(node.right, path)\\n                path.pop()\\n                \\n        dfs(root, [])\\n```\n```python\\n\\tvalue = 0\\n\\tfor digits in answer:\\n\\t\\tvalue += int(digits, 2)\\n\\treturn value\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1951065,
                "title": "simplest-solution-easiest-to-understand-0ms-runtime-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        \\n        return preorder(root,0);\\n\\n    }\\n    \\n    public int preorder(TreeNode root, int sum) {\\n    \\n        if(root==null)\\n            return 0;\\n        \\n        sum= (2*sum) + root.val;\\n        \\n        if(root.left==null && root.right==null)\\n            return sum;\\n        \\n       return preorder(root.left,sum) + preorder(root.right,sum); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        \\n        return preorder(root,0);\\n\\n    }\\n    \\n    public int preorder(TreeNode root, int sum) {\\n    \\n        if(root==null)\\n            return 0;\\n        \\n        sum= (2*sum) + root.val;\\n        \\n        if(root.left==null && root.right==null)\\n            return sum;\\n        \\n       return preorder(root.left,sum) + preorder(root.right,sum); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682872,
                "title": "recursive-approach-o-n-optimized",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root , int val = 0) {\\n        // recursive approach\\n        // TC-> O(N)  SC-> O(H)\\n        if (!root) return 0;\\n        val = (val * 2 + root->val);\\n        return root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root , int val = 0) {\\n        // recursive approach\\n        // TC-> O(N)  SC-> O(H)\\n        if (!root) return 0;\\n        val = (val * 2 + root->val);\\n        return root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682782,
                "title": "c-solution-beginner-friendly-recursion-backtracking",
                "content": "*Please upvote if you find helpful :)*\\n```\\nclass Solution {\\npublic:\\n    int bintodecimal(string s) {\\n        int len = s.length(), ans=0;\\n        for(int i=0;s[i];i++)\\n            ans += (s[i]-\\'0\\')*pow(2, len-i-1);\\n        return ans;\\n    }\\n    void allPaths(TreeNode* root, string &v1, vector<string> &v) {\\n        if(root==NULL)\\n            return;\\n        if(root->left==NULL && root->right==NULL) {\\n            v1+=(to_string(root->val));\\n            v.push_back(v1);\\n            v1.pop_back();\\n            return;\\n        }\\n        v1+=(to_string(root->val));\\n        allPaths(root->left, v1, v);\\n        allPaths(root->right, v1, v);\\n        v1.pop_back();\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string v1=\"\";\\n        vector<string> v;\\n        allPaths(root, v1, v);\\n        int ans=0;\\n        for(auto x: v) {\\n            int d = bintodecimal(x);\\n            ans += d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bintodecimal(string s) {\\n        int len = s.length(), ans=0;\\n        for(int i=0;s[i];i++)\\n            ans += (s[i]-\\'0\\')*pow(2, len-i-1);\\n        return ans;\\n    }\\n    void allPaths(TreeNode* root, string &v1, vector<string> &v) {\\n        if(root==NULL)\\n            return;\\n        if(root->left==NULL && root->right==NULL) {\\n            v1+=(to_string(root->val));\\n            v.push_back(v1);\\n            v1.pop_back();\\n            return;\\n        }\\n        v1+=(to_string(root->val));\\n        allPaths(root->left, v1, v);\\n        allPaths(root->right, v1, v);\\n        v1.pop_back();\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string v1=\"\";\\n        vector<string> v;\\n        allPaths(root, v1, v);\\n        int ans=0;\\n        for(auto x: v) {\\n            int d = bintodecimal(x);\\n            ans += d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681853,
                "title": "recursion-java-code",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int sumRootToLeaf(TreeNode root, int sum) {\\n        if(root == null) return 0;\\n        sum = (sum << 1) + root.val;\\n        if(root.left == null && root.right == null) return sum;\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root){\\n        return sumRootToLeaf(root, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int sumRootToLeaf(TreeNode root, int sum) {\\n        if(root == null) return 0;\\n        sum = (sum << 1) + root.val;\\n        if(root.left == null && root.right == null) return sum;\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root){\\n        return sumRootToLeaf(root, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681847,
                "title": "javascript-bitwise-operation",
                "content": "```js\\nfunction sumRootToLeaf(node, cur = 0) {\\n  if (!node) {\\n    return 0;\\n  }\\n  cur = (cur << 1) | node.val;\\n  return node.left === node.right ? cur : sumRootToLeaf(node.left, cur) + sumRootToLeaf(node.right, cur);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction sumRootToLeaf(node, cur = 0) {\\n  if (!node) {\\n    return 0;\\n  }\\n  cur = (cur << 1) | node.val;\\n  return node.left === node.right ? cur : sumRootToLeaf(node.left, cur) + sumRootToLeaf(node.right, cur);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681578,
                "title": "python3-dfs-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        \\n        # defining a global variable for recursive helper to modify\\n        ret = [0]\\n        def helper(curr, currpath):\\n            if curr is None:\\n                return\\n            \\n            # case where leaf node has been reached\\n            if curr.left is None and curr.right is None:\\n                currpath.append(curr.val)\\n                bin_str = \"\".join(map(str, currpath))\\n                ret[0] += int(bin_str, 2)\\n                currpath.pop()\\n                return\\n            \\n            # append the current node\\'s value to the array before processing children\\n            currpath.append(curr.val)\\n            helper(curr.left, currpath)\\n            helper(curr.right, currpath)\\n            \\n            # remove the current node\\'s value before returning to callee\\n            currpath.pop()\\n            \\n        helper(root, [])\\n        return ret[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        \\n        # defining a global variable for recursive helper to modify\\n        ret = [0]\\n        def helper(curr, currpath):\\n            if curr is None:\\n                return\\n            \\n            # case where leaf node has been reached\\n            if curr.left is None and curr.right is None:\\n                currpath.append(curr.val)\\n                bin_str = \"\".join(map(str, currpath))\\n                ret[0] += int(bin_str, 2)\\n                currpath.pop()\\n                return\\n            \\n            # append the current node\\'s value to the array before processing children\\n            currpath.append(curr.val)\\n            helper(curr.left, currpath)\\n            helper(curr.right, currpath)\\n            \\n            # remove the current node\\'s value before returning to callee\\n            currpath.pop()\\n            \\n        helper(root, [])\\n        return ret[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664685,
                "title": "c-recursion",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void fun(TreeNode *root, int sum){\\n        if(!root) return;\\n        if(!root->left && !root->right){\\n            sum=sum*2+root->val;\\n            ans+=sum;\\n            return;\\n        }\\n        if(root) sum=sum*2+(root->val);\\n        fun(root->left, sum);\\n        fun(root->right, sum);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int sum=0;\\n        fun(root, sum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void fun(TreeNode *root, int sum){\\n        if(!root) return;\\n        if(!root->left && !root->right){\\n            sum=sum*2+root->val;\\n            ans+=sum;\\n            return;\\n        }\\n        if(root) sum=sum*2+(root->val);\\n        fun(root->left, sum);\\n        fun(root->right, sum);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int sum=0;\\n        fun(root, sum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514309,
                "title": "python-recursive",
                "content": "```\\n\\tdef sumRootToLeaf(self, root):\\n        return self.recursive(root, \"\")\\n        \\n    def recursive(self, root, binary_str):\\n        left = right = 0\\n        binary_str += str(root.val)\\n        \\n        if not root.left and not root.right:\\n            return int(binary_str, 2)\\n        \\n        if root.left:\\n            left = self.recursive(root.left, binary_str)\\n        if root.right:\\n            right = self.recursive(root.right, binary_str)\\n        \\n        return left + right",
                "solutionTags": [],
                "code": "```\\n\\tdef sumRootToLeaf(self, root):\\n        return self.recursive(root, \"\")\\n        \\n    def recursive(self, root, binary_str):\\n        left = right = 0\\n        binary_str += str(root.val)\\n        \\n        if not root.left and not root.right:\\n            return int(binary_str, 2)\\n        \\n        if root.left:\\n            left = self.recursive(root.left, binary_str)\\n        if root.right:\\n            right = self.recursive(root.right, binary_str)\\n        \\n        return left + right",
                "codeTag": "Python3"
            },
            {
                "id": 1506898,
                "title": "java-basic-approach",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        helper(root, new ArrayList<>());\\n        return ans;\\n    }\\n    public void helper(TreeNode root, List<Integer> ls) {\\n        if (root == null) return;\\n        ls.add(root.val);\\n        \\n        if (root.left == null && root.right == null) {\\n            int size = ls.size();\\n            int i = 0;\\n            for (int j = size - 1; j >= 0; j--) {\\n                ans += ls.get(j) * Math.pow(2, i);\\n                i++;\\n            }\\n        } else {\\n            helper(root.left, ls);\\n            helper(root.right, ls);\\n        }\\n        ls.remove(ls.size() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        helper(root, new ArrayList<>());\\n        return ans;\\n    }\\n    public void helper(TreeNode root, List<Integer> ls) {\\n        if (root == null) return;\\n        ls.add(root.val);\\n        \\n        if (root.left == null && root.right == null) {\\n            int size = ls.size();\\n            int i = 0;\\n            for (int j = size - 1; j >= 0; j--) {\\n                ans += ls.get(j) * Math.pow(2, i);\\n                i++;\\n            }\\n        } else {\\n            helper(root.left, ls);\\n            helper(root.right, ls);\\n        }\\n        ls.remove(ls.size() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381894,
                "title": "explained-code-c-dfs",
                "content": "we are adding the value of the path in a variable named t. for every new node we are multiplying the **t** with 2 and adding the value of that particular node. (why multiplying it by 2?)\\nlets say we have a number in decimal say :5678\\nwe can write it as num=5 * 10+6;\\nnum+=num * 10+7;\\nnum+=num*10+8\\n\\nin the same way we can write the binary value say \"10110\" as\\nbin=bin * 2+1;\\nbin+=bin * 2+0;\\nbin+=bin * 2+1;\\nbin+=bin * 2+1;\\nbin+=bin * 2+0;\\n\\nand when even i am encountering a leaf node i am just adding the value in sum.\\n\\n**I hope i made you understand my approach.\\nplease upvote if you liked my solution**\\n\\n\\n#happy_coding\\n\\n```\\nint sum=0;\\n    void helper(TreeNode* root,int t)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        t*=2;\\n        t+=root->val;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            sum+=t;\\n        }\\n        if(root->left)\\n        {\\n            helper(root->left,t);\\n        }\\n        if(root->right)\\n        {\\n            helper(root->right,t);\\n        }\\n        return;\\n    }\\n    \\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        helper(root,0);\\n        return sum; \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint sum=0;\\n    void helper(TreeNode* root,int t)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        t*=2;\\n        t+=root->val;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            sum+=t;\\n        }\\n        if(root->left)\\n        {\\n            helper(root->left,t);\\n        }\\n        if(root->right)\\n        {\\n            helper(root->right,t);\\n        }\\n        return;\\n    }\\n    \\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        helper(root,0);\\n        return sum; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343704,
                "title": "python-solution-using-strings-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\ndef sum_root(root, parent_string):\\n    total = 0\\n    \\n    if root is None:\\n        return total\\n\\n    if root.left is None and root.right is None:\\n        total += int(parent_string + str(root.val), 2)\\n\\n    else:\\n        if root.right:\\n            total += sum_root(root.right, parent_string + str(root.val))\\n\\n        if root.left:\\n            total += sum_root(root.left, parent_string + str(root.val))\\n    \\n    return total\\n    \\n    \\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return sum_root(root, \\'\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\ndef sum_root(root, parent_string):\\n    total = 0\\n    \\n    if root is None:\\n        return total\\n\\n    if root.left is None and root.right is None:\\n        total += int(parent_string + str(root.val), 2)\\n\\n    else:\\n        if root.right:\\n            total += sum_root(root.right, parent_string + str(root.val))\\n\\n        if root.left:\\n            total += sum_root(root.left, parent_string + str(root.val))\\n    \\n    return total\\n    \\n    \\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return sum_root(root, \\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256676,
                "title": "easy-to-understand-c-code",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int sum=0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n        if(!root)\\n            return 0;\\n        inorder(root);\\n        return sum;\\n        \\n    }\\n    \\n    void inorder(TreeNode* node){\\n        if(!node)\\n            return;\\n        \\n        v.push_back(node->val);\\n        \\n        inorder(node->left);\\n        inorder(node->right);\\n        if(!node->left && !node->right){\\n         int r=v.size();\\n        for(int i=0;i<v.size();i++){\\n            sum+=v[i]*pow(2,r-1);\\n            r--;\\n          }\\n        }\\n        v.pop_back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int sum=0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n        if(!root)\\n            return 0;\\n        inorder(root);\\n        return sum;\\n        \\n    }\\n    \\n    void inorder(TreeNode* node){\\n        if(!node)\\n            return;\\n        \\n        v.push_back(node->val);\\n        \\n        inorder(node->left);\\n        inorder(node->right);\\n        if(!node->left && !node->right){\\n         int r=v.size();\\n        for(int i=0;i<v.size();i++){\\n            sum+=v[i]*pow(2,r-1);\\n            r--;\\n          }\\n        }\\n        v.pop_back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230775,
                "title": "c-simple-and-easily-understandable-solution",
                "content": "```\\nstring s=\"\";\\n    int Supersum = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        help(root, 0);\\n        return Supersum;\\n    }\\n    void help(TreeNode* root, int sum)\\n    {\\n        if(root == NULL) { return; }\\n        s += to_string(root->val);\\n        if(root->left == NULL && root->right == NULL)\\n        {\\n            Supersum += stoi(s, 0, 2);\\n            // cout<<\"Sum added\"<<endl;\\n        }\\n        if(root->left) { help(root->left, Supersum); }\\n        if(root->right) { help(root->right, Supersum); }\\n        s.erase(s.end()-1);\\n    }\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nstring s=\"\";\\n    int Supersum = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        help(root, 0);\\n        return Supersum;\\n    }\\n    void help(TreeNode* root, int sum)\\n    {\\n        if(root == NULL) { return; }\\n        s += to_string(root->val);\\n        if(root->left == NULL && root->right == NULL)\\n        {\\n            Supersum += stoi(s, 0, 2);\\n            // cout<<\"Sum added\"<<endl;\\n        }\\n        if(root->left) { help(root->left, Supersum); }\\n        if(root->right) { help(root->right, Supersum); }\\n        s.erase(s.end()-1);\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1211525,
                "title": "java-recursion-0ms-beats-100-t-c-o-n-s-c-o-n",
                "content": "\\n    // O(n) O(n)\\n\\tpublic int sumRootToLeaf(TreeNode root) {\\n\\t\\treturn sumRootToLeafHelper(root, 0);\\n\\t}\\n\\n\\t// O(n) O(n)\\n\\tpublic int sumRootToLeafHelper(TreeNode root, int dec) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (root.left == null && root.right == null)\\n\\t\\t\\treturn (dec << 1) | root.val;\\n\\n\\t\\tint temp = dec;\\n\\t\\ttemp = (temp << 1) | root.val;\\n\\t\\tint left = sumRootToLeafHelper(root.left, temp);\\n\\t\\tint right = sumRootToLeafHelper(root.right, temp);\\n\\n\\t\\treturn left + right;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(n) O(n)\\n\\tpublic int sumRootToLeaf(TreeNode root) {\\n\\t\\treturn sumRootToLeafHelper(root, 0);\\n\\t}\\n\\n\\t// O(n) O(n)\\n\\tpublic int sumRootToLeafHelper(TreeNode root, int dec) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (root.left == null && root.right == null)\\n\\t\\t\\treturn (dec << 1) | root.val;\\n\\n\\t\\tint temp = dec;\\n\\t\\ttemp = (temp << 1) | root.val;\\n\\t\\tint left = sumRootToLeafHelper(root.left, temp);\\n\\t\\tint right = sumRootToLeafHelper(root.right, temp);\\n\\n\\t\\treturn left + right;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1164720,
                "title": "weeb-does-python-bfs",
                "content": "Step 1: use bfs to get from root to leaf\\nStep 2: use the curpath to get the sum of each binary digit\\n\\nPlease note that my solution requires a basic understanding of how to get the value of a binary digit\\nif u dont know then here is an example:\\n\\nlet curpath == [1, 0, 0]. This means my binary digit is 100 according to my code below\\nSo, to convert it to a value it should be done like this:\\n100 == 2 ** 2 + 0 + 0 == 4  so 100 binary digit is 4 in integer value\\n\\nif binary digit is 0 then we ignore it\\nif binary digit is 1 then we 2 ** of current position of digit(0 indexed btw).\\n\\nanother example: let curpath == [1, 0, 1, 0, 1] so binary digit is 10101\\n10101 == 2 ** 4 + 0 + 2 ** 2 + 0 + 2 ** 0 == 21 so 10101 in binary digit is 21 in integer value\\n\\nhope u understand it cuz if u dont then u probably wont understand my code\\n\\n\\tclass Solution:\\n\\t\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n\\t\\t\\tqueue, total = deque([(root, [root.val], 0)]), 0\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tcurNode, curpath, length = queue.popleft()\\n\\n\\t\\t\\t\\tif not curNode.left and not curNode.right:\\n\\t\\t\\t\\t\\tfor val in curpath:\\n\\t\\t\\t\\t\\t\\tif val == 1: \\n\\t\\t\\t\\t\\t\\t\\ttotal += 2 ** length \\n\\t\\t\\t\\t\\t\\tlength -= 1\\n\\n\\t\\t\\t\\tif curNode.left:\\n\\t\\t\\t\\t\\tqueue.append((curNode.left, curpath + [curNode.left.val], length + 1))\\n\\n\\t\\t\\t\\tif curNode.right:\\n\\t\\t\\t\\t\\tqueue.append((curNode.right, curpath + [curNode.right.val], length + 1))\\n\\n\\t\\t\\treturn total\\n\\nAnyways, now its time for some anime recommendations\\n# Hurry up and watch ***Golden Time***\\n\\n## Genre: Romantic comedy\\n## Episodes: 24\\n\\n**Best romcom of all time**, The plot was good and the character development in this show is amazing.\\nI highly recommend you to watch it\\nNow stop coding, get a snicker, a sprite and slack off cuz its anime time.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "Step 1: use bfs to get from root to leaf\\nStep 2: use the curpath to get the sum of each binary digit\\n\\nPlease note that my solution requires a basic understanding of how to get the value of a binary digit\\nif u dont know then here is an example:\\n\\nlet curpath == [1, 0, 0]. This means my binary digit is 100 according to my code below\\nSo, to convert it to a value it should be done like this:\\n100 == 2 ** 2 + 0 + 0 == 4  so 100 binary digit is 4 in integer value\\n\\nif binary digit is 0 then we ignore it\\nif binary digit is 1 then we 2 ** of current position of digit(0 indexed btw).\\n\\nanother example: let curpath == [1, 0, 1, 0, 1] so binary digit is 10101\\n10101 == 2 ** 4 + 0 + 2 ** 2 + 0 + 2 ** 0 == 21 so 10101 in binary digit is 21 in integer value\\n\\nhope u understand it cuz if u dont then u probably wont understand my code\\n\\n\\tclass Solution:\\n\\t\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n\\t\\t\\tqueue, total = deque([(root, [root.val], 0)]), 0\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tcurNode, curpath, length = queue.popleft()\\n\\n\\t\\t\\t\\tif not curNode.left and not curNode.right:\\n\\t\\t\\t\\t\\tfor val in curpath:\\n\\t\\t\\t\\t\\t\\tif val == 1: \\n\\t\\t\\t\\t\\t\\t\\ttotal += 2 ** length \\n\\t\\t\\t\\t\\t\\tlength -= 1\\n\\n\\t\\t\\t\\tif curNode.left:\\n\\t\\t\\t\\t\\tqueue.append((curNode.left, curpath + [curNode.left.val], length + 1))\\n\\n\\t\\t\\t\\tif curNode.right:\\n\\t\\t\\t\\t\\tqueue.append((curNode.right, curpath + [curNode.right.val], length + 1))\\n\\n\\t\\t\\treturn total\\n\\nAnyways, now its time for some anime recommendations\\n# Hurry up and watch ***Golden Time***\\n\\n## Genre: Romantic comedy\\n## Episodes: 24\\n\\n**Best romcom of all time**, The plot was good and the character development in this show is amazing.\\nI highly recommend you to watch it\\nNow stop coding, get a snicker, a sprite and slack off cuz its anime time.\\n",
                "codeTag": "Java"
            },
            {
                "id": 1052127,
                "title": "simple-java-solution-100-recursion",
                "content": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        List<Integer> nums = new ArrayList<>();\\n        return search(root, 0);\\n    }\\n\\n    public int search(TreeNode root, int sum) {\\n        if(root == null) return 0;\\n\\n        sum = sum*2 + root.val;\\n        if(root.left == null && root.right == null) return sum; // reached out leaf node.\\n        return search(root.left, sum) + search(root.right, sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        List<Integer> nums = new ArrayList<>();\\n        return search(root, 0);\\n    }\\n\\n    public int search(TreeNode root, int sum) {\\n        if(root == null) return 0;\\n\\n        sum = sum*2 + root.val;\\n        if(root.left == null && root.right == null) return sum; // reached out leaf node.\\n        return search(root.left, sum) + search(root.right, sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024541,
                "title": "python-recursive-preorder-with-binary-string-to-decimal-conversion",
                "content": "##### Implementing a simple recursive pre-order function with an array for strings made by traversing till each leaf-node.\\nWith each recursion-call check if current-node is a leaf:\\n\\tIf yes, then append currently created string value to the res-array.\\n\\tIf no, then push left and right child nodes onto the stack.\\n\\nFinally just convert your string arrays into decimal using the int function and sum up the res-array.\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(root: TreeNode, res: str):\\n            if root:\\n                if root.left is None and root.right is None:\\n                    arr.append(res+str(root.val))\\n                else:\\n                    dfs(root.left, res+str(root.val))\\n                    dfs(root.right, res+str(root.val))\\n\\n        arr=[]\\n        dfs(root, \\'\\')\\n        return sum([int(i,2) for i in arr])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(root: TreeNode, res: str):\\n            if root:\\n                if root.left is None and root.right is None:\\n                    arr.append(res+str(root.val))\\n                else:\\n                    dfs(root.left, res+str(root.val))\\n                    dfs(root.right, res+str(root.val))\\n\\n        arr=[]\\n        dfs(root, \\'\\')\\n        return sum([int(i,2) for i in arr])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888559,
                "title": "python-a-clear-and-simple-dfs-implementation-time-o-n-space-o-h",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, num):\\n            if not node:\\n                return\\n            \\n            num = 2*num + node.val                        \\n            if not node.left and not node.right:\\n                self.sum_ += num\\n                return            \\n            dfs(node.left, num)                \\n            dfs(node.right, num)\\n            \\n        self.sum_ = 0\\n        dfs(root, 0)\\n        return self.sum_\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, num):\\n            if not node:\\n                return\\n            \\n            num = 2*num + node.val                        \\n            if not node.left and not node.right:\\n                self.sum_ += num\\n                return            \\n            dfs(node.left, num)                \\n            dfs(node.right, num)\\n            \\n        self.sum_ = 0\\n        dfs(root, 0)\\n        return self.sum_\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836878,
                "title": "rust-dfs-100-bitshift-and-bitwise-or",
                "content": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn sum_root_to_leaf(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let int = 0;\\n        let mut sum = 0;\\n        if let Some(n) = root {\\n            Self::dfs(n, int, &mut sum);\\n        }\\n        sum\\n    }\\n    fn dfs(n: Rc<RefCell<TreeNode>>, int: i32, sum: &mut i32) {\\n        let next_int = (int << 1) | n.borrow().val;\\n        if n.borrow().left.is_none() && n.borrow().right.is_none() {\\n            *sum += next_int;\\n        } else {\\n            if let Some(l) = n.borrow().left.clone() {\\n                Self::dfs(l, next_int, sum);\\n            }\\n            if let Some(r) = n.borrow().right.clone() {\\n                Self::dfs(r, next_int, sum);           \\n            }          \\n        }\\n\\n    }\\n}\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn sum_root_to_leaf(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let int = 0;\\n        let mut sum = 0;\\n        if let Some(n) = root {\\n            Self::dfs(n, int, &mut sum);\\n        }\\n        sum\\n    }\\n    fn dfs(n: Rc<RefCell<TreeNode>>, int: i32, sum: &mut i32) {\\n        let next_int = (int << 1) | n.borrow().val;\\n        if n.borrow().left.is_none() && n.borrow().right.is_none() {\\n            *sum += next_int;\\n        } else {\\n            if let Some(l) = n.borrow().left.clone() {\\n                Self::dfs(l, next_int, sum);\\n            }\\n            if let Some(r) = n.borrow().right.clone() {\\n                Self::dfs(r, next_int, sum);           \\n            }          \\n        }\\n\\n    }\\n}\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 836445,
                "title": "sum-of-root-to-leaf-binary-numbers",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n\\n        def sum_leafs(node, path=[]):\\n            if node is None:\\n                return 0\\n            if node.left is None and node.right is None:\\n                path.append(node.val)\\n                return int(\\'\\'.join(map(str, path)), 2) \\n            return (\\n                sum_leafs(node.right, path + [node.val]) +\\n                sum_leafs(node.left, path + [node.val]))\\n\\n        return sum_leafs(root)\\n```\\n\\nEdit:\\nBasicaly the idea is memoizing path (a list of integers) while travesing the tree and detect when we reach a leaf node and then sum up all of them.\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n\\n        def sum_leafs(node, path=[]):\\n            if node is None:\\n                return 0\\n            if node.left is None and node.right is None:\\n                path.append(node.val)\\n                return int(\\'\\'.join(map(str, path)), 2) \\n            return (\\n                sum_leafs(node.right, path + [node.val]) +\\n                sum_leafs(node.left, path + [node.val]))\\n\\n        return sum_leafs(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836385,
                "title": "c-dfs-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int &ans, int k) {\\n        if(root==NULL) {\\n            return ;\\n        }\\n        k = (k<<1)|(root->val);\\n        if(!root->left && !root->right) {\\n            ans+=k;\\n            return;\\n        }\\n        solve(root->left,ans, k);\\n        solve(root->right, ans, k);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        if(root==NULL) {\\n            return 0;\\n        }\\n        int ans=0,k=0;\\n        solve(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int &ans, int k) {\\n        if(root==NULL) {\\n            return ;\\n        }\\n        k = (k<<1)|(root->val);\\n        if(!root->left && !root->right) {\\n            ans+=k;\\n            return;\\n        }\\n        solve(root->left,ans, k);\\n        solve(root->right, ans, k);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        if(root==NULL) {\\n            return 0;\\n        }\\n        int ans=0,k=0;\\n        solve(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836246,
                "title": "python-easy-solution",
                "content": "```\\ndef sumRootToLeaf(self, root):\\n\\t\"\"\"\\n\\t:type root: TreeNode\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tnums = []\\n\\tdef dfs(node, s):\\n\\t\\ts += str(node.val)\\n\\t\\tif node.left:\\n\\t\\t\\tdfs(node.left, s)\\n\\t\\tif node.right:\\n\\t\\t\\tdfs(node.right, s)\\n\\t\\tif not node.left and not node.right:\\n\\t\\t\\tnums.append(s)\\n\\tdfs(root, \\'\\')\\n\\treturn sum(int(s, 2) for s in nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef sumRootToLeaf(self, root):\\n\\t\"\"\"\\n\\t:type root: TreeNode\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tnums = []\\n\\tdef dfs(node, s):\\n\\t\\ts += str(node.val)\\n\\t\\tif node.left:\\n\\t\\t\\tdfs(node.left, s)\\n\\t\\tif node.right:\\n\\t\\t\\tdfs(node.right, s)\\n\\t\\tif not node.left and not node.right:\\n\\t\\t\\tnums.append(s)\\n\\tdfs(root, \\'\\')\\n\\treturn sum(int(s, 2) for s in nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 836224,
                "title": "python-solution-explanation-o-n-4-lines-only",
                "content": "In order to solve the problem we traverse the tree in a **Preorder Traversal** i.e. Root -> Left ->Right. We first calculate sum value calaculate upto the given node and then traverse for the subsequent left and right sub tree and then add them\\n\\n**Basic Formula Used:** \\nn << 1 | root.value\\nWhen we left shift a binary number say 11, the result is 110 and then OR the root value, we get our required sum for the given node. Time Complexity is O(N) since all nodes are visted only once.\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return self.calcSum(root, 0)\\n    \\n    def calcSum(self, root: TreeNode, n: int) -> int:\\n        \\n        if(root == None): return 0\\n        n = n << 1 | root.val\\n        if(root.left == None and root.right == None): return n\\n        return ( self.calcSum(root.left,n) + self.calcSum(root.right,n) )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return self.calcSum(root, 0)\\n    \\n    def calcSum(self, root: TreeNode, n: int) -> int:\\n        \\n        if(root == None): return 0\\n        n = n << 1 | root.val\\n        if(root.left == None and root.right == None): return n\\n        return ( self.calcSum(root.left,n) + self.calcSum(root.right,n) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835893,
                "title": "python-very-easy-to-understand-runtime-beats-94-python-submissions",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.res = 0\\n        def traverse(root,s):\\n            if root:\\n                s += str(root.val)\\n                if not root.left and not root.right:\\n                    self.res += int(s,2)    #Binary to Decimal Conversion and value addition\\n                    return\\n                traverse(root.left,s)\\n                traverse(root.right,s)\\n            return\\n        traverse(root,\\'\\')\\n        return(self.res)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please Upvote!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.res = 0\\n        def traverse(root,s):\\n            if root:\\n                s += str(root.val)\\n                if not root.left and not root.right:\\n                    self.res += int(s,2)    #Binary to Decimal Conversion and value addition\\n                    return\\n                traverse(root.left,s)\\n                traverse(root.right,s)\\n            return\\n        traverse(root,\\'\\')\\n        return(self.res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754275,
                "title": "kotlin-shift-left-of-bits",
                "content": "```\\n    private var sum = 0\\n    fun sumRootToLeaf(root: TreeNode?): Int {\\n        if (root == null) return sum\\n        paths(root, root.`val`)\\n        return sum\\n    }\\n    \\n    private fun paths(root: TreeNode, path: Int) {\\n        if (root.left == null && root.right == null) { // we have reached a leaf\\n            sum += path\\n            return\\n        }\\n        root.left?.let {\\n            val leftPath = (path shl 1) + it.`val` // shift left the current path and add the left node value\\n            paths(it, leftPath)\\n        }\\n        root.right?.let {\\n            val rightPath = (path shl 1) + it.`val`\\n            paths(it, rightPath)\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    private var sum = 0\\n    fun sumRootToLeaf(root: TreeNode?): Int {\\n        if (root == null) return sum\\n        paths(root, root.`val`)\\n        return sum\\n    }\\n    \\n    private fun paths(root: TreeNode, path: Int) {\\n        if (root.left == null && root.right == null) { // we have reached a leaf\\n            sum += path\\n            return\\n        }\\n        root.left?.let {\\n            val leftPath = (path shl 1) + it.`val` // shift left the current path and add the left node value\\n            paths(it, leftPath)\\n        }\\n        root.right?.let {\\n            val rightPath = (path shl 1) + it.`val`\\n            paths(it, rightPath)\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751960,
                "title": "java-bfs-solution",
                "content": "Not as good as DFS due to space complexity.\\n\\n```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        int sum = 0;\\n        \\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(root, root.val));\\n        int newValue = 0;\\n        while (!q.isEmpty()) {\\n            Pair<TreeNode, Integer> current = q.poll();\\n            TreeNode node = current.getKey();\\n            int value = current.getValue();\\n            if (node.left == null && node.right == null) {\\n                sum = sum + value;\\n                continue;\\n            }\\n            \\n            if (node.left != null) {\\n                newValue = (value << 1) + node.left.val;\\n                q.add(new Pair(node.left, newValue));\\n            }\\n            \\n            if (node.right != null) {\\n                newValue = (value << 1) + node.right.val;\\n                q.add(new Pair(node.right, newValue));\\n            }            \\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        int sum = 0;\\n        \\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(root, root.val));\\n        int newValue = 0;\\n        while (!q.isEmpty()) {\\n            Pair<TreeNode, Integer> current = q.poll();\\n            TreeNode node = current.getKey();\\n            int value = current.getValue();\\n            if (node.left == null && node.right == null) {\\n                sum = sum + value;\\n                continue;\\n            }\\n            \\n            if (node.left != null) {\\n                newValue = (value << 1) + node.left.val;\\n                q.add(new Pair(node.left, newValue));\\n            }\\n            \\n            if (node.right != null) {\\n                newValue = (value << 1) + node.right.val;\\n                q.add(new Pair(node.right, newValue));\\n            }            \\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729767,
                "title": "c-simple-n-short-bit-twiddling",
                "content": "```\\nvoid trav(struct TreeNode *root, int *i, int *s){\\n    if (root) {\\n        *i = (*i << 1) | root->val;\\n        !root->left && !root->right ? *s += *i : 0;\\n        trav(root->left, i, s);\\n        trav(root->right, i, s);\\n        *i >>= 1;        \\n    }\\n}\\n\\nint sumRootToLeaf(struct TreeNode* root){\\n    int i = 0, s = 0;\\n    trav(root, &i, &s);\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid trav(struct TreeNode *root, int *i, int *s){\\n    if (root) {\\n        *i = (*i << 1) | root->val;\\n        !root->left && !root->right ? *s += *i : 0;\\n        trav(root->left, i, s);\\n        trav(root->right, i, s);\\n        *i >>= 1;        \\n    }\\n}\\n\\nint sumRootToLeaf(struct TreeNode* root){\\n    int i = 0, s = 0;\\n    trav(root, &i, &s);\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 668687,
                "title": "java-100-efficient-solution-and-easy-to-understand",
                "content": "```\\nint sum = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        sumRootToLeaf(root, 0);\\n        return sum;\\n    }\\n\\n    public void sumRootToLeaf(TreeNode root, int sum) {\\n        if (root == null) return;\\n\\n        sum = (sum * 2) + root.val;\\n        sumRootToLeaf(root.left, sum);\\n        sumRootToLeaf(root.right, sum);\\n        if (root.left == null && root.right == null) {\\n            this.sum += sum;\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\nint sum = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        sumRootToLeaf(root, 0);\\n        return sum;\\n    }\\n\\n    public void sumRootToLeaf(TreeNode root, int sum) {\\n        if (root == null) return;\\n\\n        sum = (sum * 2) + root.val;\\n        sumRootToLeaf(root.left, sum);\\n        sumRootToLeaf(root.right, sum);\\n        if (root.left == null && root.right == null) {\\n            this.sum += sum;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 640967,
                "title": "python-2-recursive-methods",
                "content": "### Method 1: Build a string of \\'1\\' and \\'0\\' for each root to leaf path\\n\\n1) Start at root node with a string of \\'0b\\' denoting the start of a binary string.  At every node, add the node value to the end of the string.  \\n\\n2) When a leaf node is reached add the path to reach that node (i.e. \\'1010\\') to self.res\\n\\n3) Convert each path from binary to an integer using int(path, 2) and return the sum.  \\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        if not root:\\n            return 0\\n        \\n        self.res = []\\n        \\n        def helper(node, path):\\n            \\n            if not node.left and not node.right: #2\\n                self.res.append(path + str(node.val))\\n                return\\n            \\n            if node.left: #1\\n                helper(node.left, path + str(node.val))\\n            \\n            if node.right: #1\\n                helper(node.right, path + str(node.val))\\n            \\n        \\n        helper(root, \\'0b\\')\\n        \\n        return sum([int(path,2) for path in self.res]) #3\\n```\\n\\n### Method 2: Manually increase result at at each leaf\\n\\n1) Start with a path of []\\n2) At every node append the node value to the beginning of the path\\n    * So the path (root = 1, to leaf = 0, [1,0,1,0]) looks like [0,1,0,1]\\n3) When a leaf node is reached, increase the result by value * (2 ** index) for each index in the reversed path.  This is equivalent to calculating the integer that the binary number represents.  For the example above this is 0 * 2 ** 0 + 1 * 2 ** 1 + 0 * 2 ** 2 + 1 * 2 ** 3 = 0 + 2 + 0 + 8 = 10\\n4) Once the helper function finishes the final node, res will be the sum of all of the root to leaf paths.  \\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        if not root:\\n            return 0\\n        \\n        self.res = 0\\n        \\n        def helper(node, path):\\n            \\n            if not node.left and not node.right: #3\\n                self.res += node.val\\n                for idx,val in enumerate(path):\\n                    self.res += val*(2**(idx+1))\\n                return\\n            \\n            if node.left:\\n                helper(node.left, [node.val] + path) #2\\n            \\n            if node.right:\\n                helper(node.right, [node.val] + path) #2 \\n            \\n        \\n        helper(root, []) #1\\n        \\n        return self.res #4\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        if not root:\\n            return 0\\n        \\n        self.res = []\\n        \\n        def helper(node, path):\\n            \\n            if not node.left and not node.right: #2\\n                self.res.append(path + str(node.val))\\n                return\\n            \\n            if node.left: #1\\n                helper(node.left, path + str(node.val))\\n            \\n            if node.right: #1\\n                helper(node.right, path + str(node.val))\\n            \\n        \\n        helper(root, \\'0b\\')\\n        \\n        return sum([int(path,2) for path in self.res]) #3\\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        if not root:\\n            return 0\\n        \\n        self.res = 0\\n        \\n        def helper(node, path):\\n            \\n            if not node.left and not node.right: #3\\n                self.res += node.val\\n                for idx,val in enumerate(path):\\n                    self.res += val*(2**(idx+1))\\n                return\\n            \\n            if node.left:\\n                helper(node.left, [node.val] + path) #2\\n            \\n            if node.right:\\n                helper(node.right, [node.val] + path) #2 \\n            \\n        \\n        helper(root, []) #1\\n        \\n        return self.res #4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609443,
                "title": "java-iterative-solution",
                "content": "use two stacks pop and push synchronously. one stack store node, another stack store value\\n```java\\npublic int sumRootToLeaf(TreeNode root) {\\n    if (root == null) {\\n        return 0;\\n    }\\n\\n    int result = 0;\\n    Stack<TreeNode> nodeStack = new Stack<TreeNode>();\\n    Stack<Integer> valueStack = new Stack<Integer>();\\n    nodeStack.push(root);\\n    valueStack.push(root.val);\\n    while (!nodeStack.isEmpty()) {\\n        TreeNode node = nodeStack.pop();\\n        int value = valueStack.pop();\\n        if (node.left == null && node.right == null) {\\n            result += value;\\n        }\\n        if (node.left != null) {\\n            nodeStack.push(node.left);\\n            valueStack.push(value * 2 + node.left.val);\\n        } \\n        if (node.right != null) {\\n            nodeStack.push(node.right);\\n            valueStack.push(value * 2 + node.right.val);\\n        }\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int sumRootToLeaf(TreeNode root) {\\n    if (root == null) {\\n        return 0;\\n    }\\n\\n    int result = 0;\\n    Stack<TreeNode> nodeStack = new Stack<TreeNode>();\\n    Stack<Integer> valueStack = new Stack<Integer>();\\n    nodeStack.push(root);\\n    valueStack.push(root.val);\\n    while (!nodeStack.isEmpty()) {\\n        TreeNode node = nodeStack.pop();\\n        int value = valueStack.pop();\\n        if (node.left == null && node.right == null) {\\n            result += value;\\n        }\\n        if (node.left != null) {\\n            nodeStack.push(node.left);\\n            valueStack.push(value * 2 + node.left.val);\\n        } \\n        if (node.right != null) {\\n            nodeStack.push(node.right);\\n            valueStack.push(value * 2 + node.right.val);\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594779,
                "title": "javascript-99-5-time-100-space",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar sumRootToLeaf = function(root) {\\nlet sum=[];\\n     sumRoot(root,sum,0);\\n    return sum.reduce((acc,curr)=>acc+ curr,0)\\n};\\n\\n function sumRoot(root,sum,curr){\\n     curr=curr*2+root.val;\\nif(!root.left&&!root.right)sum.push(curr)\\n     \\n     if (root.left)sumRoot(root.left,sum,curr) ;\\n     if (root.right) sumRoot(root.right,sum,curr);\\n     \\n     \\n }\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar sumRootToLeaf = function(root) {\\nlet sum=[];\\n     sumRoot(root,sum,0);\\n    return sum.reduce((acc,curr)=>acc+ curr,0)\\n};\\n\\n function sumRoot(root,sum,curr){\\n     curr=curr*2+root.val;\\nif(!root.left&&!root.right)sum.push(curr)\\n     \\n     if (root.left)sumRoot(root.left,sum,curr) ;\\n     if (root.right) sumRoot(root.right,sum,curr);\\n     \\n     \\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 550735,
                "title": "python-99-32-recursive-explained-with-tips",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:       \\n        self.s = 0\\n        def preOrder(r,v):                      \\n            if r:           \\n                v = (v << 1) + r.val            \\n                if(r.left or r.right):\\n                    preOrder(r.left,v)\\n                    preOrder(r.right,v)\\n                else:\\n                    self.s += v    \\n                \\n        preOrder(root,0)\\n        return self.s \\n```\\n\\nThe idea is simple. We traverse the tree and every time we go lower, we push the current value down. Once we hit a leaf with no childred, we add the current value to a globa variable self.s.\\n\\nSo the tips part.\\n\\nVisually it is easier to see the value as a string with 0s and 1s, but to avoid unnessesary conversion, it\\'s better to keep everything as integers. A simple way to add the current value to the existing number is `v = (v << 1) + r.val ` - we shift bits to the left to free up space for the current bit. If you don\\'t like bit logic, you can do `v = v*2 + r.val` . \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:       \\n        self.s = 0\\n        def preOrder(r,v):                      \\n            if r:           \\n                v = (v << 1) + r.val            \\n                if(r.left or r.right):\\n                    preOrder(r.left,v)\\n                    preOrder(r.right,v)\\n                else:\\n                    self.s += v    \\n                \\n        preOrder(root,0)\\n        return self.s \\n```",
                "codeTag": "Java"
            },
            {
                "id": 543666,
                "title": "100-fast-and-memory",
                "content": "````\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    int ans = 0;\\n\\n    void helper(TreeNode *root, int pSum)\\n    {\\n        if (!root) return;\\n        int t = pSum * 2 + root->val;\\n        if (root->left == nullptr && root->right == nullptr)\\n        {\\n            ans += t;\\n            return;\\n        }\\n        helper(root->left, t);\\n        helper(root->right, t);\\n    }\\n\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        helper(root, 0);\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    int ans = 0;\\n\\n    void helper(TreeNode *root, int pSum)\\n    {\\n        if (!root) return;\\n        int t = pSum * 2 + root->val;\\n        if (root->left == nullptr && root->right == nullptr)\\n        {\\n            ans += t;\\n            return;\\n        }\\n        helper(root->left, t);\\n        helper(root->right, t);\\n    }\\n\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        helper(root, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493622,
                "title": "c-faster-than-94-05-less-than-100-mem-o-n",
                "content": "Runtime: 88 ms\\nMemory Usage: 24.8 MB\\n\\n```\\n    public int SumRootToLeaf(TreeNode root) {        \\n        return Traverse(root, 0);\\n    }\\n    \\n    private int Traverse(TreeNode root, int number)\\n    {\\n        if (root == null) { return 0; }\\n              \\n        number <<= 1; \\n        number += root.val;\\n        \\n        if (root.left == null && root.right == null) {  return number; }\\n        \\n        return Traverse(root.left, number) + Traverse(root.right, number);\\n    }\\n```\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n    public int SumRootToLeaf(TreeNode root) {        \\n        return Traverse(root, 0);\\n    }\\n    \\n    private int Traverse(TreeNode root, int number)\\n    {\\n        if (root == null) { return 0; }\\n              \\n        number <<= 1; \\n        number += root.val;\\n        \\n        if (root.left == null && root.right == null) {  return number; }\\n        \\n        return Traverse(root.left, number) + Traverse(root.right, number);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 483603,
                "title": "rust",
                "content": "```rust\\nimpl Solution {\\n    pub fn sum_root_to_leaf(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut res = 0;\\n        Self::h(&root, &mut res, &mut vec![]);\\n        res\\n    }\\n\\n    fn h(t: &Option<Rc<RefCell<TreeNode>>>, res: &mut i32, p: &mut Vec<i32>) {\\n        if let Some(t) = t {\\n            let t = t.borrow();\\n            p.push(t.val);\\n            if t.left.is_none() && t.right.is_none() {\\n                let mut c = 0;\\n                p.iter().for_each(|x| c = (c << 1) | x);\\n                *res += c;\\n            } else {\\n                Self::h(&t.left, res, &mut p.clone());\\n                Self::h(&t.right, res, &mut p.clone());\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn sum_root_to_leaf(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut res = 0;\\n        Self::h(&root, &mut res, &mut vec![]);\\n        res\\n    }\\n\\n    fn h(t: &Option<Rc<RefCell<TreeNode>>>, res: &mut i32, p: &mut Vec<i32>) {\\n        if let Some(t) = t {\\n            let t = t.borrow();\\n            p.push(t.val);\\n            if t.left.is_none() && t.right.is_none() {\\n                let mut c = 0;\\n                p.iter().for_each(|x| c = (c << 1) | x);\\n                *res += c;\\n            } else {\\n                Self::h(&t.left, res, &mut p.clone());\\n                Self::h(&t.right, res, &mut p.clone());\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 460062,
                "title": "c-0ms-dfs",
                "content": "```\\ntypedef struct TreeNode TreeNode;\\n\\nint dfs(TreeNode* root, int val) {\\n    if (root == NULL)\\n        return 0;\\n    \\n    val = (val << 1) + root->val;\\n    \\n    if (root->left == NULL && root->right == NULL) \\n        return val;\\n    \\n    return dfs(root->left,  val) + \\n           dfs(root->right, val);\\n}\\n\\nint sumRootToLeaf(struct TreeNode* root){\\n    return dfs(root, 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct TreeNode TreeNode;\\n\\nint dfs(TreeNode* root, int val) {\\n    if (root == NULL)\\n        return 0;\\n    \\n    val = (val << 1) + root->val;\\n    \\n    if (root->left == NULL && root->right == NULL) \\n        return val;\\n    \\n    return dfs(root->left,  val) + \\n           dfs(root->right, val);\\n}\\n\\nint sumRootToLeaf(struct TreeNode* root){\\n    return dfs(root, 0);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 443666,
                "title": "java-iterating-method",
                "content": "\\t//   iterating method\\n\\t\\tpublic int sumRootToLeaf(TreeNode root) { \\n\\t\\t\\tif ( root == null ) return 0 ;\\n\\t\\t\\tStack<TreeNode> s = new Stack<>();\\n\\t\\t\\ts.push(root);\\n\\t\\t\\tint res = 0 ;\\n\\t\\t\\twhile( !s.empty() ){\\n\\t\\t\\t\\tTreeNode tmp = s.pop();\\n\\t\\t\\t\\tif (tmp.left != null) {\\n\\t\\t\\t\\t\\ttmp.left.val += 2 * tmp.val;\\n\\t\\t\\t\\t\\ts.push(tmp.left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (tmp.right != null) {\\n\\t\\t\\t\\t\\ttmp.right.val += 2 * tmp.val;\\n\\t\\t\\t\\t\\ts.push(tmp.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( tmp.left  == null && tmp.right == null ) res += tmp.val;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\t//   iterating method\\n\\t\\tpublic int sumRootToLeaf(TreeNode root) { \\n\\t\\t\\tif ( root == null ) return 0 ;\\n\\t\\t\\tStack<TreeNode> s = new Stack<>();\\n\\t\\t\\ts.push(root);\\n\\t\\t\\tint res = 0 ;\\n\\t\\t\\twhile( !s.empty() ){\\n\\t\\t\\t\\tTreeNode tmp = s.pop();\\n\\t\\t\\t\\tif (tmp.left != null) {\\n\\t\\t\\t\\t\\ttmp.left.val += 2 * tmp.val;\\n\\t\\t\\t\\t\\ts.push(tmp.left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (tmp.right != null) {\\n\\t\\t\\t\\t\\ttmp.right.val += 2 * tmp.val;\\n\\t\\t\\t\\t\\ts.push(tmp.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( tmp.left  == null && tmp.right == null ) res += tmp.val;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 411429,
                "title": "python-iterative-dfs-98-19",
                "content": "This is a typical tree traversal problem. Both DFS and BFS should work in this setting. The only trick is that one needs to keep track of the value (binary value) up to the node that is being traversed. Below is a iterative implementation of DFS. \\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        ans = 0 \\n        stack = [(root, 0)]\\n        while stack: \\n            node, val = stack.pop()\\n            val = 2*val + node.val \\n            if node.left is node.right: ans += val \\n            if node.left: stack.append((node.left, val))\\n            if node.right: stack.append((node.right, val))\\n        return ans \\n```\\n\\nEdited on 9/8/2020\\nAdding a recursive solution \\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def fn(node): \\n            \"\"\"Pre-order traverse the tree and add root-to-leaf numbers.\"\"\"\\n            nonlocal ans\\n            if not node: return \\n            stack.append(node.val)\\n            if node.left is node.right is None: ans += int(\"\".join(map(str, stack)), 2)\\n            fn(node.left) or fn(node.right)\\n            stack.pop()\\n        \\n        ans, stack = 0, []\\n        fn(root)\\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def fn(node, x=0): \\n            \"\"\"Post-order traverse the tree and add root-to-leaf numbers.\"\"\"\\n            if not node: return 0 \\n            x = 2*x + node.val \\n            if node.left is node.right: return x\\n            return fn(node.left, x) + fn(node.right, x)\\n        \\n        return fn(root)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        ans = 0 \\n        stack = [(root, 0)]\\n        while stack: \\n            node, val = stack.pop()\\n            val = 2*val + node.val \\n            if node.left is node.right: ans += val \\n            if node.left: stack.append((node.left, val))\\n            if node.right: stack.append((node.right, val))\\n        return ans \\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def fn(node): \\n            \"\"\"Pre-order traverse the tree and add root-to-leaf numbers.\"\"\"\\n            nonlocal ans\\n            if not node: return \\n            stack.append(node.val)\\n            if node.left is node.right is None: ans += int(\"\".join(map(str, stack)), 2)\\n            fn(node.left) or fn(node.right)\\n            stack.pop()\\n        \\n        ans, stack = 0, []\\n        fn(root)\\n        return ans \\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def fn(node, x=0): \\n            \"\"\"Post-order traverse the tree and add root-to-leaf numbers.\"\"\"\\n            if not node: return 0 \\n            x = 2*x + node.val \\n            if node.left is node.right: return x\\n            return fn(node.left, x) + fn(node.right, x)\\n        \\n        return fn(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399469,
                "title": "easy-c-solution-4ms-beats-94",
                "content": "Runtime: 4 ms, faster than 94.22% of C++ online submissions for Sum of Root To Leaf Binary Numbers.\\nMemory Usage: 17 MB, less than 100.00% of C++ online submissions for Sum of Root To Leaf Binary Numbers.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n        return sum(root, 0);\\n    }\\n    \\n    int sum(TreeNode* root, int parentSum)\\n    {\\n        int doubleParent = parentSum*2;\\n        \\n        if(root->left == nullptr && root->right == nullptr)\\n            return doubleParent + root->val;\\n        \\n        int leftSum = (root->left != nullptr) ? sum(root->left, doubleParent+root->val) : 0;\\n        int rightSum = (root->right != nullptr) ? sum(root->right, doubleParent+root->val) : 0;\\n        \\n        return leftSum+rightSum;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n        return sum(root, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 392519,
                "title": "c-84-ms",
                "content": "\\tpublic class Solution\\n    {\\n        public int SumRootToLeaf(TreeNode root)\\n            => Sum(root, 0);\\n\\n        private int Sum(TreeNode node, int number)\\n        {\\n            if (node == null)\\n            {\\n                return 0;\\n            }\\n            number = number * 2 + node.val;\\n            return\\n                node.left == null && node.right == null ?\\n                number :\\n                Sum(node.left, number) + Sum(node.right, number);\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public int SumRootToLeaf(TreeNode root)\\n            => Sum(root, 0);\\n\\n        private int Sum(TreeNode node, int number)\\n        {\\n            if (node == null)\\n            {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 367391,
                "title": "java-100-100",
                "content": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root,0);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root , int sum){\\n        sum=sum*2+root.val;\\n        if(root.left==null&&root.right==null){\\n            return sum;\\n        }else if(root.left==null){\\n            return sumRootToLeaf(root.right,sum);\\n        }else if(root.right==null){\\n            return sumRootToLeaf(root.left,sum);\\n        }else{\\n            return sumRootToLeaf(root.right,sum)+sumRootToLeaf(root.left,sum);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root,0);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root , int sum){\\n        sum=sum*2+root.val;\\n        if(root.left==null&&root.right==null){\\n            return sum;\\n        }else if(root.left==null){\\n            return sumRootToLeaf(root.right,sum);\\n        }else if(root.right==null){\\n            return sumRootToLeaf(root.left,sum);\\n        }else{\\n            return sumRootToLeaf(root.right,sum)+sumRootToLeaf(root.left,sum);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354667,
                "title": "python-quick-recursive-1-way-down-no-shifting",
                "content": "```\\ndef sumRootToLeaf(self, root):\\n\\tdef dfe(root, binary):\\n\\t\\tif root == None:\\n\\t\\t\\treturn 0\\n\\t\\tbinary = binary+str(root.val)\\n\\t\\tif root.left == None and root.right == None:\\n\\t\\t\\ta.append(binary)\\n\\t\\t\\treturn 0\\n\\t\\tdfe(root.left, binary)\\n\\t\\tdfe(root.right, binary)\\n\\n\\n\\ta = []\\n\\tbinary = \\'\\'\\n\\tdfe(root, binary)\\n\\tres = 0\\n\\tfor b in a:\\n\\t\\tres = res + int(b, 2)\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```\\ndef sumRootToLeaf(self, root):\\n\\tdef dfe(root, binary):\\n\\t\\tif root == None:\\n\\t\\t\\treturn 0\\n\\t\\tbinary = binary+str(root.val)\\n\\t\\tif root.left == None and root.right == None:\\n\\t\\t\\ta.append(binary)\\n\\t\\t\\treturn 0\\n\\t\\tdfe(root.left, binary)\\n\\t\\tdfe(root.right, binary)\\n\\n\\n\\ta = []\\n\\tbinary = \\'\\'\\n\\tdfe(root, binary)\\n\\tres = 0\\n\\tfor b in a:\\n\\t\\tres = res + int(b, 2)\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 321139,
                "title": "java-2-methods-reuse-lc-129",
                "content": "**Idea:** Swap 10 with 2 (base of digits) in [LC 129: Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/1555892/Java-or-DFS-or-Time-beats-100)\\n>**T/S:** O(n)/O(d), n = number of nodes, d = depth\\n ```\\npublic int sumRootToLeaf(TreeNode root) {\\n\\treturn sumRootToLeaf(root, 0);\\n}\\n\\npublic int sumRootToLeaf(TreeNode root, int sum) {\\n\\tif (root == null)\\n\\t\\treturn 0;\\n\\t\\t\\n\\tsum = (sum * 2) + root.val;\\n\\t\\n\\treturn (root.left == null && root.right == null) ? \\n\\t\\t\\t   sum : \\n\\t\\t\\t   sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n}\\n```\\n\\n**Method 2:** Build the number\\n>**T/S:** O(n)/O(d), n = number of nodes, d = depth\\n```\\npublic int sumRootToLeaf(TreeNode root) {\\n\\tint[] sum = {0};\\n\\tsumRootToLeaf(root, new StringBuffer(), sum);\\n\\treturn sum[0];\\n}\\n\\nprivate void sumRootToLeaf(TreeNode root, StringBuffer sb, int[] sum) {\\n\\tif (root == null)\\n\\t\\treturn;\\n\\n\\tsb.append(root.val);\\n\\n\\tif (root.left == null && root.right == null) { // leaf node\\n\\t\\tsum[0] += Integer.parseInt(sb.toString(), 2);\\n\\t\\tsb.deleteCharAt(sb.length() - 1);\\n\\t} else {\\n\\t\\tsumRootToLeaf(root.left, sb, sum);\\n\\t\\tsumRootToLeaf(root.right, sb, sum);\\n\\t\\tif (sb.length() != 0)\\n\\t\\t\\tsb.deleteCharAt(sb.length() - 1);\\n\\t}\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic int sumRootToLeaf(TreeNode root) {\\n\\treturn sumRootToLeaf(root, 0);\\n}\\n\\npublic int sumRootToLeaf(TreeNode root, int sum) {\\n\\tif (root == null)\\n\\t\\treturn 0;\\n\\t\\t\\n\\tsum = (sum * 2) + root.val;\\n\\t\\n\\treturn (root.left == null && root.right == null) ? \\n\\t\\t\\t   sum : \\n\\t\\t\\t   sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n}\\n```\n```\\npublic int sumRootToLeaf(TreeNode root) {\\n\\tint[] sum = {0};\\n\\tsumRootToLeaf(root, new StringBuffer(), sum);\\n\\treturn sum[0];\\n}\\n\\nprivate void sumRootToLeaf(TreeNode root, StringBuffer sb, int[] sum) {\\n\\tif (root == null)\\n\\t\\treturn;\\n\\n\\tsb.append(root.val);\\n\\n\\tif (root.left == null && root.right == null) { // leaf node\\n\\t\\tsum[0] += Integer.parseInt(sb.toString(), 2);\\n\\t\\tsb.deleteCharAt(sb.length() - 1);\\n\\t} else {\\n\\t\\tsumRootToLeaf(root.left, sb, sum);\\n\\t\\tsumRootToLeaf(root.right, sb, sum);\\n\\t\\tif (sb.length() != 0)\\n\\t\\t\\tsb.deleteCharAt(sb.length() - 1);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311653,
                "title": "javascript",
                "content": "```\\nvar sumRootToLeaf = function(root) {\\n    let res = 0;\\n    let DFS = (root, S) => {\\n        if(!root) return;\\n        S += root.val;\\n        if(!root.left && !root.right) {\\n            res += parseInt(S, 2);\\n            return;\\n        }\\n        DFS(root.left, S);\\n        DFS(root.right, S);\\n    }\\n    DFS(root, \\'\\');\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar sumRootToLeaf = function(root) {\\n    let res = 0;\\n    let DFS = (root, S) => {\\n        if(!root) return;\\n        S += root.val;\\n        if(!root.left && !root.right) {\\n            res += parseInt(S, 2);\\n            return;\\n        }\\n        DFS(root.left, S);\\n        DFS(root.right, S);\\n    }\\n    DFS(root, \\'\\');\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 271127,
                "title": "java-recursion-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        return dfs(root, 0);\\n    }\\n    \\n    private int dfs(TreeNode root, int sum) {\\n        sum = sum * 2 + root.val;\\n        if(root.left == null && root.right == null) {\\n            return sum;\\n        }\\n        int leftSum = root.left != null ? dfs(root.left, sum) : 0;\\n        int rightSum = root.right != null ? dfs(root.right, sum) : 0;\\n        return leftSum + rightSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        return dfs(root, 0);\\n    }\\n    \\n    private int dfs(TreeNode root, int sum) {\\n        sum = sum * 2 + root.val;\\n        if(root.left == null && root.right == null) {\\n            return sum;\\n        }\\n        int leftSum = root.left != null ? dfs(root.left, sum) : 0;\\n        int rightSum = root.right != null ? dfs(root.right, sum) : 0;\\n        return leftSum + rightSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680091,
                "title": "easy-java-100-global-variables-method-pre-order-traversal-dfs-explained",
                "content": "# Approach\\n- There are two approaches to this question - one with a numerical variable that stores the current bit values and the other one is a string variable that stores the bit values at a particular leaf node.\\n- The problem with the numerical variable is that, there\\'s a limit to how many bit values it can store and thus gives an error after the critical value. Hence we use the String variable to record the bit values.\\n- The problem is divided into two classes - main and helper\\n\\n# Global Variables\\n- number (String type)\\n- arr (Arraylist String type)\\n\\n# Helper Class\\n- The helper class takes a node as an input\\n- if node is null, returns to the parent node\\n- adds the node bit value to number\\n- checks if the node is leaf node, if yes, the current number value is appended in arr\\n- calls itself on current node left child\\n- calls itself on current node right child\\n- deletes the last character of number\\n\\n# Main class\\n- calls the helper class on root node\\n- arr is created and full of leaf node bit values but in string format\\n- create int variable sum = 0\\n- set a for loop to iterate thorugh the array\\n- convert each string bit value to integer and add it to the sum.\\n- return sum\\n\\n# Complexity\\n- Time complexity: O(V) V  is the number of nodes\\n\\n- Space complexity: O(L) L is the number of leaf nodes\\n\\n# Code\\n```\\n\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public String number = \"\";\\n\\n    public List<String> arr = new ArrayList<>();\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        tree(root);\\n        int sum = 0;\\n        for(String i: arr){\\n            int a = Integer.parseInt(i, 2);\\n            System.out.println(a);\\n            sum += a;\\n        }\\n        return sum;\\n    }\\n\\n    public void tree(TreeNode x){\\n        if(x == null){\\n            return;\\n        }\\n\\n        number = number + String.valueOf(x.val);\\n\\n        if(x.left == null && x.right == null){\\n            arr.add(number);\\n        }\\n\\n        tree(x.left);\\n        tree(x.right);\\n\\n        number = number.substring(0,number.length()-1);\\n\\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/4c993713-be95-4251-b6b5-2bfbd911fbac_1687678864.5214777.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public String number = \"\";\\n\\n    public List<String> arr = new ArrayList<>();\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        tree(root);\\n        int sum = 0;\\n        for(String i: arr){\\n            int a = Integer.parseInt(i, 2);\\n            System.out.println(a);\\n            sum += a;\\n        }\\n        return sum;\\n    }\\n\\n    public void tree(TreeNode x){\\n        if(x == null){\\n            return;\\n        }\\n\\n        number = number + String.valueOf(x.val);\\n\\n        if(x.left == null && x.right == null){\\n            arr.add(number);\\n        }\\n\\n        tree(x.left);\\n        tree(x.right);\\n\\n        number = number.substring(0,number.length()-1);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594435,
                "title": "c-very-rare-solution-super-easy-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int solver(TreeNode* root, int value){\\n        if(root == nullptr) return 0;\\n        \\n        value = value * 2 + root->val;\\n        if(root->left == nullptr && root->right == nullptr){\\n            return value;\\n        }\\n        return solver(root->left,value) + solver(root->right,value);\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        return solver(root,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int solver(TreeNode* root, int value){\\n        if(root == nullptr) return 0;\\n        \\n        value = value * 2 + root->val;\\n        if(root->left == nullptr && root->right == nullptr){\\n            return value;\\n        }\\n        return solver(root->left,value) + solver(root->right,value);\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        return solver(root,0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3551124,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\nvoid helper(TreeNode* root, int val, int& res){\\n    if(!root) return;\\n\\n    val = val | root->val;\\n    if(!root->left && !root->right){\\n        res+=val;\\n        return;\\n    }\\n    helper(root->left,  val<<1, res);\\n    helper(root->right, val<<1, res);\\n}\\nvoid helper1(TreeNode* root,  int out, int& res){\\n    if(!root) return;\\n\\n    out = (out<<1) + root->val;\\n    if(!root->left && !root->right){\\n        res+=out;\\n        return;\\n    }\\n    helper1(root->left,out,res);\\n    helper1(root->right,out,res);\\n}\\nint sumRootToLeaf(TreeNode* root) {\\n        int res = 0;\\n        helper1(root,0,res);\\n        return res;    \\n}\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        result = 0\\n        if not root:\\n            return 0\\n        def dfs(node, slate):\\n            nonlocal result\\n            if not node.left and not node.right:\\n                slate.append(str(node.val))\\n                result += int(\"\".join(slate), 2)\\n            \\n            if node.left: dfs(node.left, slate + [str(node.val)])\\n            if node.right: dfs(node.right, slate + [str(node.val)])\\n        \\n        dfs(root, [])\\n        return result\\n```\\n\\n```Java []\\nclass Solution {\\n     private int pathSumRootToLeaf(TreeNode root, int parentNodeSum){\\n        if(root == null) return 0;\\n        \\n        parentNodeSum = 2 * parentNodeSum + root.val;\\n        if(root.left == null && root.right == null){\\n            return parentNodeSum;\\n        }\\n        return pathSumRootToLeaf(root.left, parentNodeSum) +            pathSumRootToLeaf(root.right, parentNodeSum);\\n    }\\n    public int sumRootToLeaf(TreeNode root) {\\n          return pathSumRootToLeaf(root, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\nvoid helper(TreeNode* root, int val, int& res){\\n    if(!root) return;\\n\\n    val = val | root->val;\\n    if(!root->left && !root->right){\\n        res+=val;\\n        return;\\n    }\\n    helper(root->left,  val<<1, res);\\n    helper(root->right, val<<1, res);\\n}\\nvoid helper1(TreeNode* root,  int out, int& res){\\n    if(!root) return;\\n\\n    out = (out<<1) + root->val;\\n    if(!root->left && !root->right){\\n        res+=out;\\n        return;\\n    }\\n    helper1(root->left,out,res);\\n    helper1(root->right,out,res);\\n}\\nint sumRootToLeaf(TreeNode* root) {\\n        int res = 0;\\n        helper1(root,0,res);\\n        return res;    \\n}\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        result = 0\\n        if not root:\\n            return 0\\n        def dfs(node, slate):\\n            nonlocal result\\n            if not node.left and not node.right:\\n                slate.append(str(node.val))\\n                result += int(\"\".join(slate), 2)\\n            \\n            if node.left: dfs(node.left, slate + [str(node.val)])\\n            if node.right: dfs(node.right, slate + [str(node.val)])\\n        \\n        dfs(root, [])\\n        return result\\n```\n```Java []\\nclass Solution {\\n     private int pathSumRootToLeaf(TreeNode root, int parentNodeSum){\\n        if(root == null) return 0;\\n        \\n        parentNodeSum = 2 * parentNodeSum + root.val;\\n        if(root.left == null && root.right == null){\\n            return parentNodeSum;\\n        }\\n        return pathSumRootToLeaf(root.left, parentNodeSum) +            pathSumRootToLeaf(root.right, parentNodeSum);\\n    }\\n    public int sumRootToLeaf(TreeNode root) {\\n          return pathSumRootToLeaf(root, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507123,
                "title": "faster-than-100-of-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n\\n    void bin(string s) {\\n        int ans = 0;\\n        int n = s.size() - 1;\\n        for (auto i: s) {\\n            ans += (i - 48) * pow(2, n);\\n            n--;\\n        }\\n        sum += ans;\\n    }\\n\\n    void func(TreeNode *root, string s) {\\n        if (root == nullptr) {\\n            return bin(s);\\n        }\\n        s += std::to_string(root->val);\\n        if (root->right == nullptr && root->left == nullptr){\\n            return bin(s);\\n        } else {\\n            if (root->left == nullptr || root->right == nullptr){\\n                if (root->left != nullptr){\\n                    return func(root->left, s);\\n                } else {\\n                    return func(root->right, s);\\n                }\\n            } else {\\n                func(root->left, s);\\n                func(root->right, s);\\n            }\\n        }\\n\\n    }\\n\\n    int sumRootToLeaf(TreeNode *root) {\\n        func(root, \"\");\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n\\n    void bin(string s) {\\n        int ans = 0;\\n        int n = s.size() - 1;\\n        for (auto i: s) {\\n            ans += (i - 48) * pow(2, n);\\n            n--;\\n        }\\n        sum += ans;\\n    }\\n\\n    void func(TreeNode *root, string s) {\\n        if (root == nullptr) {\\n            return bin(s);\\n        }\\n        s += std::to_string(root->val);\\n        if (root->right == nullptr && root->left == nullptr){\\n            return bin(s);\\n        } else {\\n            if (root->left == nullptr || root->right == nullptr){\\n                if (root->left != nullptr){\\n                    return func(root->left, s);\\n                } else {\\n                    return func(root->right, s);\\n                }\\n            } else {\\n                func(root->left, s);\\n                func(root->right, s);\\n            }\\n        }\\n\\n    }\\n\\n    int sumRootToLeaf(TreeNode *root) {\\n        func(root, \"\");\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443812,
                "title": "multiple-cpp-solution-using-preorder-traversal-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void sum(TreeNode* root, int ans, set<int>& s){\\n        if(root == nullptr) {\\n            s.insert(ans);\\n            return;\\n        };\\n        int elem = root -> val;\\n        ans = ans * 10 + elem;\\n\\n        sum(root -> left, ans, s);\\n        sum(root -> right, ans, s);\\n    }\\n\\n    int sumOne(TreeNode* root, int ans){\\n\\n        if(root == nullptr) return 0;\\n\\n        int elem = root -> val;\\n        ans = ans * 2 + elem;\\n\\n        if(root -> left == NULL && root -> right == NULL){\\n            return ans;\\n        }\\n\\n        int leftSum = sumOne(root -> left, ans);\\n        int rightSum = sumOne(root -> right, ans);\\n\\n        return leftSum + rightSum;\\n\\n    }\\n \\n  \\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        // set<int> s;\\n        // sum(root, 0, s);\\n\\n        // int ans = 0;\\n\\n        // for(auto& i: s){\\n        //     ans += binaryToDecimal(i);\\n        // }\\n\\n        // return ans;\\n\\n        return sumOne(root, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void sum(TreeNode* root, int ans, set<int>& s){\\n        if(root == nullptr) {\\n            s.insert(ans);\\n            return;\\n        };\\n        int elem = root -> val;\\n        ans = ans * 10 + elem;\\n\\n        sum(root -> left, ans, s);\\n        sum(root -> right, ans, s);\\n    }\\n\\n    int sumOne(TreeNode* root, int ans){\\n\\n        if(root == nullptr) return 0;\\n\\n        int elem = root -> val;\\n        ans = ans * 2 + elem;\\n\\n        if(root -> left == NULL && root -> right == NULL){\\n            return ans;\\n        }\\n\\n        int leftSum = sumOne(root -> left, ans);\\n        int rightSum = sumOne(root -> right, ans);\\n\\n        return leftSum + rightSum;\\n\\n    }\\n \\n  \\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        // set<int> s;\\n        // sum(root, 0, s);\\n\\n        // int ans = 0;\\n\\n        // for(auto& i: s){\\n        //     ans += binaryToDecimal(i);\\n        // }\\n\\n        // return ans;\\n\\n        return sumOne(root, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089328,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int solve(string a)\\n    {\\n        int ans=0;\\n        int t=a.length()-1;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(a[i]==\\'1\\')\\n            {\\n                ans+=pow(2,t);\\n            }\\n            t--;\\n        }\\n        return ans;\\n    }\\n    void helper(TreeNode* root,string x,vector<string>&s)\\n    {\\n        if(root==NULL)return;\\n        if(root->left==NULL &&root->right==NULL)\\n        {\\n            x+=to_string(root->val);\\n            s.push_back(x);\\n        }\\n        x+=to_string(root->val);\\n        helper(root->left,x,s);\\n        helper(root->right,x,s);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<string>s;\\n        string x=\"\";\\n        helper(root,x,s);\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ans+=solve(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int solve(string a)\\n    {\\n        int ans=0;\\n        int t=a.length()-1;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(a[i]==\\'1\\')\\n            {\\n                ans+=pow(2,t);\\n            }\\n            t--;\\n        }\\n        return ans;\\n    }\\n    void helper(TreeNode* root,string x,vector<string>&s)\\n    {\\n        if(root==NULL)return;\\n        if(root->left==NULL &&root->right==NULL)\\n        {\\n            x+=to_string(root->val);\\n            s.push_back(x);\\n        }\\n        x+=to_string(root->val);\\n        helper(root->left,x,s);\\n        helper(root->right,x,s);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<string>s;\\n        string x=\"\";\\n        helper(root,x,s);\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ans+=solve(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880444,
                "title": "c-very-easy-to-understand-tree-traversal",
                "content": "\\n\\n       /**\\n     * Definition for a binary tree node.\\n    * struct TreeNode {\\n    *     int val;\\n    *     TreeNode *left;\\n    *     TreeNode *right;\\n    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n    * };\\n    */\\n    class Solution {\\n    public:\\n         void dfs(TreeNode* node, int &ans ,string &str){\\n         \\n            if(node==NULL)\\n                 return;\\n         if(node->left==nullptr && node->right==nullptr){\\n               string s=str+to_string(node->val);\\n                 for(int i=0;i<s.size();++i){\\n                   ans+=pow(2,i)*(s[s.size()-i-1]-\\'0\\');\\n             }\\n                 return;\\n         }\\n         \\n         \\n         str+=to_string(node->val);\\n         dfs(node->left,ans,str);\\n         dfs(node->right,ans,str);\\n          str.pop_back();\\n                \\n     }\\n     \\n    int sumRootToLeaf(TreeNode* root) {\\n         int ans=0; \\n        string str;\\n        dfs(root,ans,str);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "class Solution {\\n    public:\\n         void dfs(TreeNode* node, int &ans ,string &str){\\n         \\n            if(node==NULL)\\n                 return;\\n         if(node->left==nullptr && node->right==nullptr){\\n               string s=str+to_string(node->val);\\n                 for(int i=0;i<s.size();++i){\\n                   ans+=pow(2,i)*(s[s.size()-i-1]-\\'0\\');\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2673967,
                "title": "simple-solution",
                "content": "Here Idea is simple we can write binary 100 to decimal as   (2*(2*1)+0)+0=4.\\n\\nMultiply first digit with base and add the next bit to it and then with the result multiply it with base and add the next bit. Do the same procedure until there is no bit available to add.\\n\\n\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        {\\n           return sum(root,0); \\n        }\\n    }\\n    int sum(TreeNode* root ,int till)\\n    {  \\n        till=till+root->val;\\n        if(!root->left && !root->right)\\n        {\\n            return till;\\n        }\\n        if(root->left && root->right)\\n        {\\n            return sum(root->left,2*till)+sum(root->right,2*till);\\n        }\\n        if(root->right)\\n            return sum(root->right,2*till);\\n        if(root->left)\\n            return sum(root->left,2*till);\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        {\\n           return sum(root,0); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2517156,
                "title": "simple-recursive-solution",
                "content": "```\\nclass Solution {\\n    int total =0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        \\n        sumBinary(root, 0);\\n        return total;\\n    }\\n    \\n    public void sumBinary(TreeNode root, int sum){\\n        if(root==null)  return;        \\n        sum = sum * 2 + root.val;\\n        if(root.left==null && root.right==null){   \\n            total += sum;\\n            return;\\n        }             \\n        sumBinary(root.left,sum);\\n        sumBinary(root.right,sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int total =0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        \\n        sumBinary(root, 0);\\n        return total;\\n    }\\n    \\n    public void sumBinary(TreeNode root, int sum){\\n        if(root==null)  return;        \\n        sum = sum * 2 + root.val;\\n        if(root.left==null && root.right==null){   \\n            total += sum;\\n            return;\\n        }             \\n        sumBinary(root.left,sum);\\n        sumBinary(root.right,sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428079,
                "title": "no-title-just-kiidding-easy-java-soln",
                "content": "```\\nclass Solution {\\n    int res=0;\\n    void go(TreeNode node,int num){\\n        num=(num<<1)|node.val;\\n        if(node.left==null && node.right==null)res+=num;\\n        else{\\n            if(node. left!=null)go(node.left,num);\\n            if(node.right!=null)go(node.right,num);\\n        }\\n    }\\n    public int sumRootToLeaf(TreeNode root) {\\n        go(root,0);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res=0;\\n    void go(TreeNode node,int num){\\n        num=(num<<1)|node.val;\\n        if(node.left==null && node.right==null)res+=num;\\n        else{\\n            if(node. left!=null)go(node.left,num);\\n            if(node.right!=null)go(node.right,num);\\n        }\\n    }\\n    public int sumRootToLeaf(TreeNode root) {\\n        go(root,0);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415522,
                "title": "easy-to-understand-backtracking-cpp",
                "content": "class Solution {\\npublic:\\n    int sum;\\n    void dfs(TreeNode* root , string &s )\\n    {\\n        if(root == NULL)\\n            return ;\\n        \\n        s += to_string(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            sum = sum + stoi(s , 0 , 2);\\n            s.pop_back(); \\n            return ;\\n        }      \\n        \\n        dfs(root->left ,s); \\n        dfs(root->right ,s);\\n        s.pop_back(); \\n        \\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n        sum = 0;\\n        string s =\"\";\\n        dfs(root , s);\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int sum;\\n    void dfs(TreeNode* root , string &s )\\n    {\\n        if(root == NULL)\\n            return ;\\n        \\n        s += to_string(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            sum = sum + stoi(s , 0 , 2);\\n            s.pop_back(); \\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2353547,
                "title": "c-solution-easy-recursive-solution-tc-o-n-sc-o-1",
                "content": "```\\n// IF it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root,int &ans,int num){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        if(root->left==NULL && root->right==NULL){\\n           num = (num << 1) + root->val;\\n           ans += num;\\n           return;\\n        }\\n\\n        // preorder traversal\\n        num = (num << 1) + root->val;\\n\\n        solve(root->left,ans,num);\\n        solve(root->right,ans,num);\\n    \\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans = 0;\\n        int num = 0;\\n        solve(root,ans,num);\\n        return ans;\\n    }\\n};\\n\\n// IF it helps plz upvote :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n// IF it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root,int &ans,int num){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        if(root->left==NULL && root->right==NULL){\\n           num = (num << 1) + root->val;\\n           ans += num;\\n           return;\\n        }\\n\\n        // preorder traversal\\n        num = (num << 1) + root->val;\\n\\n        solve(root->left,ans,num);\\n        solve(root->right,ans,num);\\n    \\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans = 0;\\n        int num = 0;\\n        solve(root,ans,num);\\n        return ans;\\n    }\\n};\\n\\n// IF it helps plz upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321687,
                "title": "c-fast-easy-commented-picture",
                "content": "![image](https://assets.leetcode.com/users/images/80abde06-c585-4ec7-be9c-ceca7a054fe3_1658580276.606866.png)\\n![image](https://assets.leetcode.com/users/images/57871122-a0f2-49da-b934-c1658a0f46ee_1658580356.3314888.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/80abde06-c585-4ec7-be9c-ceca7a054fe3_1658580276.606866.png)\\n![image](https://assets.leetcode.com/users/images/57871122-a0f2-49da-b934-c1658a0f46ee_1658580356.3314888.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2281298,
                "title": "java-solution-using-parseint",
                "content": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        helper(root,\"\");\\n        return sum;\\n    }\\n    public void helper(TreeNode root,String s)\\n    {\\n        s=s+Integer.toString(root.val);\\n        if(root.left==null && root.right==null)\\n        {\\n            sum=sum+Integer.parseInt(s,2);\\n            return ;\\n        }\\n        if(root.left!=null)\\n            helper(root.left,s);\\n        if(root.right!=null)\\n            helper(root.right,s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        helper(root,\"\");\\n        return sum;\\n    }\\n    public void helper(TreeNode root,String s)\\n    {\\n        s=s+Integer.toString(root.val);\\n        if(root.left==null && root.right==null)\\n        {\\n            sum=sum+Integer.parseInt(s,2);\\n            return ;\\n        }\\n        if(root.left!=null)\\n            helper(root.left,s);\\n        if(root.right!=null)\\n            helper(root.right,s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245552,
                "title": "easy-python-recursive-solution-beats-95",
                "content": "\\t def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        ans = []\\n        def solve(root, s):\\n            if not root:\\n                return\\n            if not root.left and not root.right:\\n                ans.append(s+str(root.val))\\n                return\\n            s += str(root.val)\\n            solve(root.left, s)\\n            solve(root.right,s)\\n        \\n        solve(root, \"\")\\n        res = 0\\n        for i in ans:\\n            res += int(i,2)\\n        return res",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "\\t def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        ans = []\\n        def solve(root, s):\\n            if not root:\\n                return\\n            if not root.left and not root.right:\\n                ans.append(s+str(root.val))\\n                return\\n            s += str(root.val)\\n            solve(root.left, s)\\n            solve(root.right,s)\\n        \\n        solve(root, \"\")\\n        res = 0\\n        for i in ans:\\n            res += int(i,2)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2222603,
                "title": "1022-sum-of-root-to-leaf-binary-numbers-100-faster-0ms",
                "content": "Simple Solution :-\\n\\n*Just Traverse from root to leaf and store the vale in an int value and use recursive calls to return answer.\\n\\nCODE ------------>\\n\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return getSum(root, 0);\\n    }\\n    \\n    public int getSum(TreeNode root, int data){\\n        if (root==null) return 0;\\n        \\n        data = root.val+data*2;\\n        \\n        if (root.left==null && root.right==null){\\n            return data;\\n        }\\n        \\n        return getSum(root.left, data) + getSum(root.right, data);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return getSum(root, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2220178,
                "title": "94-better-solution",
                "content": "```\\ndef f(root, ans):\\n    if root:\\n        ans = (2*ans) + root.val\\n        if not (root.left or root.right):\\n            return ans\\n        return f(root.left, ans) + f(root.right, ans)\\n    return 0\\n\\n\\nclass Solution(object):\\n    def sumRootToLeaf(self, root):\\n        return f(root, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\ndef f(root, ans):\\n    if root:\\n        ans = (2*ans) + root.val\\n        if not (root.left or root.right):\\n            return ans\\n        return f(root.left, ans) + f(root.right, ans)\\n    return 0\\n\\n\\nclass Solution(object):\\n    def sumRootToLeaf(self, root):\\n        return f(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200281,
                "title": "easy-and-efficient-cpp-solution",
                "content": "//Please Upvote if Like \\n```\\n int sumRootToLeaf(TreeNode* root) {\\n         \\n        return sum_util(root,0);        \\n    }\\n    int sum_util(TreeNode* root,int sum)\\n    {\\n       if(root==nullptr)\\n           return 0;\\n        \\n      sum=2*sum+root->val;\\n      if(root->left==nullptr&&root->right==nullptr)\\n          return sum;\\n      return sum_util(root->left,sum)+sum_util(root->right,sum);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int sumRootToLeaf(TreeNode* root) {\\n         \\n        return sum_util(root,0);        \\n    }\\n    int sum_util(TreeNode* root,int sum)\\n    {\\n       if(root==nullptr)\\n           return 0;\\n        \\n      sum=2*sum+root->val;\\n      if(root->left==nullptr&&root->right==nullptr)\\n          return sum;\\n      return sum_util(root->left,sum)+sum_util(root->right,sum);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2183880,
                "title": "c-easiest-approach-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>v; //to strore all binary strings\\n    int convert(string s) //function to convert binary string to integer\\n    {\\n        int sum=0;\\n        int n=s.length()-1;\\n        for(int i=n;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n                sum+=pow(2,n-i);\\n        }\\n        return sum;\\n    }\\n    void helper(TreeNode* root,string s)//recursive function to gather all the the binary digits from root to leaf \\n    {\\n        if(!root)\\n            return;\\n        s+=to_string(root->val);\\n        if(!root->left and !root->right)\\n        {\\n            v.push_back(s);\\n            s=\"\";\\n        }\\n        \\n        helper(root->left,s);\\n        helper(root->right,s);        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string s=\"\";\\n        int ans=0;\\n        helper(root,s);\\n        for(auto x:v)   //converting and adding all binary strings\\n            ans+=convert(x);\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>v; //to strore all binary strings\\n    int convert(string s) //function to convert binary string to integer\\n    {\\n        int sum=0;\\n        int n=s.length()-1;\\n        for(int i=n;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n                sum+=pow(2,n-i);\\n        }\\n        return sum;\\n    }\\n    void helper(TreeNode* root,string s)//recursive function to gather all the the binary digits from root to leaf \\n    {\\n        if(!root)\\n            return;\\n        s+=to_string(root->val);\\n        if(!root->left and !root->right)\\n        {\\n            v.push_back(s);\\n            s=\"\";\\n        }\\n        \\n        helper(root->left,s);\\n        helper(root->right,s);        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string s=\"\";\\n        int ans=0;\\n        helper(root,s);\\n        for(auto x:v)   //converting and adding all binary strings\\n            ans+=convert(x);\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175813,
                "title": "easy-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    List<String> list=new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        findSumRootToLeaf(root, \"\");\\n        for(String binaryVal: list){\\n            sum+=Integer.parseInt(binaryVal,2);\\n        }\\n        return sum;\\n    }\\n    \\n    void findSumRootToLeaf(TreeNode root, String binaryVal){\\n        if(root.left==null && root.right==null){\\n            binaryVal+=root.val;\\n            list.add(binaryVal);\\n            return;\\n        }\\n        if(root.left!=null)\\n            findSumRootToLeaf(root.left, binaryVal+root.val);\\n        if(root.right!=null)\\n            findSumRootToLeaf(root.right, binaryVal+root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<String> list=new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        findSumRootToLeaf(root, \"\");\\n        for(String binaryVal: list){\\n            sum+=Integer.parseInt(binaryVal,2);\\n        }\\n        return sum;\\n    }\\n    \\n    void findSumRootToLeaf(TreeNode root, String binaryVal){\\n        if(root.left==null && root.right==null){\\n            binaryVal+=root.val;\\n            list.add(binaryVal);\\n            return;\\n        }\\n        if(root.left!=null)\\n            findSumRootToLeaf(root.left, binaryVal+root.val);\\n        if(root.right!=null)\\n            findSumRootToLeaf(root.right, binaryVal+root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168021,
                "title": "python-dfs-stack-list",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        total=0\\n        Q=[]\\n        stack=[]\\n        def DFS(r):\\n            if r:\\n                stack.append(str(r.val))\\n                if r.left:\\n                    DFS(r.left)\\n                    \\n                    if stack: \\n                        stack.pop()\\n                if r.right:\\n                    DFS(r.right)\\n                    \\n                    if stack: \\n                        stack.pop()\\n                if not (r.left or r.right):\\n                    Q.append(int(\\'\\'.join(stack),2))\\n                    \\n        DFS(root)\\n        return sum(Q)",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        total=0\\n        Q=[]\\n        stack=[]\\n        def DFS(r):\\n            if r:\\n                stack.append(str(r.val))\\n                if r.left:\\n                    DFS(r.left)\\n                    \\n                    if stack: \\n                        stack.pop()\\n                if r.right:\\n                    DFS(r.right)\\n                    \\n                    if stack: \\n                        stack.pop()\\n                if not (r.left or r.right):\\n                    Q.append(int(\\'\\'.join(stack),2))\\n                    \\n        DFS(root)\\n        return sum(Q)",
                "codeTag": "Java"
            },
            {
                "id": 2158600,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans = 0;\\n        PreOrder(root,0,ans);\\n        return ans;\\n    }\\n    private:\\n    void PreOrder(TreeNode* root,int sum,int &ans)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        PreOrder(root->left,2*sum+root->val,ans);\\n        PreOrder(root->right,2*sum+root->val,ans);\\n        if(!root->left && !root->right)\\n        {\\n            ans += 2*sum+root->val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans = 0;\\n        PreOrder(root,0,ans);\\n        return ans;\\n    }\\n    private:\\n    void PreOrder(TreeNode* root,int sum,int &ans)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        PreOrder(root->left,2*sum+root->val,ans);\\n        PreOrder(root->right,2*sum+root->val,ans);\\n        if(!root->left && !root->right)\\n        {\\n            ans += 2*sum+root->val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140175,
                "title": "c-easy-solution",
                "content": "```\\nint sum=0;\\n    void summation(TreeNode*root,int num)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        num=num*2+root->val;\\n        if(!root->left && !root->right)\\n        {\\n            sum+=num;\\n        }\\n        summation(root->left,num);\\n        summation(root->right,num);\\n    \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int num=0;\\n        summation(root,num);\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "```\\nint sum=0;\\n    void summation(TreeNode*root,int num)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        num=num*2+root->val;\\n        if(!root->left && !root->right)\\n        {\\n            sum+=num;\\n        }\\n        summation(root->left,num);\\n        summation(root->right,num);\\n    \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int num=0;\\n        summation(root,num);\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2089995,
                "title": "easy-100-working-c-solution-using-recusrion-with-3-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root,int sum=0) {\\n        //if root is null we return null\\n        if(!root) return 0;\\n        //then here we correspondingly calculate convert the binary to decimal\\n        sum=2*sum+root->val;\\n    //then here we check if we have the leaf nodes its the least significant bit we return the same value  and call the left func and right func\\n        return root->left==root->right?sum : sumRootToLeaf(root->left,sum)+sumRootToLeaf(root->right,sum);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root,int sum=0) {\\n        //if root is null we return null\\n        if(!root) return 0;\\n        //then here we correspondingly calculate convert the binary to decimal\\n        sum=2*sum+root->val;\\n    //then here we check if we have the leaf nodes its the least significant bit we return the same value  and call the left func and right func\\n        return root->left==root->right?sum : sumRootToLeaf(root->left,sum)+sumRootToLeaf(root->right,sum);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565577,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1566694,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1565864,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1574348,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1994738,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1856259,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1728246,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1728244,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1718028,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Days to Make m Bouquets",
        "question_content": "<p>You are given an integer array <code>bloomDay</code>, an integer <code>m</code> and an integer <code>k</code>.</p>\n\n<p>You want to make <code>m</code> bouquets. To make a bouquet, you need to use <code>k</code> <strong>adjacent flowers</strong> from the garden.</p>\n\n<p>The garden consists of <code>n</code> flowers, the <code>i<sup>th</sup></code> flower will bloom in the <code>bloomDay[i]</code> and then can be used in <strong>exactly one</strong> bouquet.</p>\n\n<p>Return <em>the minimum number of days you need to wait to be able to make </em><code>m</code><em> bouquets from the garden</em>. If it is impossible to make m bouquets return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> bloomDay = [1,10,3,10,2], m = 3, k = 1\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.\nWe need 3 bouquets each should contain 1 flower.\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> bloomDay = [1,10,3,10,2], m = 3, k = 2\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\n<strong>Output:</strong> 12\n<strong>Explanation:</strong> We need 2 bouquets each should have 3 flowers.\nHere is the garden after the 7 and 12 days:\nAfter day 7: [x, x, x, x, _, x, x]\nWe can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.\nAfter day 12: [x, x, x, x, x, x, x]\nIt is obvious that we can make two bouquets in different ways.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>bloomDay.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= bloomDay[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= m &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 686316,
                "title": "java-c-python-binary-search",
                "content": "# **Intuition**\\nIf `m * k > n`, it impossible, so return -1.\\nOtherwise, it\\'s possible, we can binary search the result.\\n`left = 1` is the smallest days,\\n`right = 1e9` is surely big enough to get m bouquests.\\nSo we are going to binary search in range `[left, right]`.\\n<br>\\n\\n# **Explanation**\\nGiven `mid` days, we can know which flowers blooms.\\nNow the problem is, given an array of `true` and `false`,\\nfind out how many adjacent `true`  bouquest in total.\\n\\nIf `bouq < m`, `mid` is still small for `m` bouquest.\\nSo we turn `left = mid + 1`\\n\\nIf `bouq >= m`, `mid` is big enough for `m` bouquest.\\nSo we turn `right = mid`\\n<br>\\n\\n# **Complexity**\\nTime `O(Nlog(maxA))`\\nSpace `O(1)`\\n\\nNote that the result must be one `A[i]`,\\nso actually we can sort A in `O(NlogK)`,\\nWhere `K` is the number of different values.\\nand then binary search the index of different values.\\n\\nThough I don\\'t thik worth doing that.\\n<br>\\n\\n**Java:**\\n```java\\n    public int minDays(int[] A, int m, int k) {\\n        int n = A.length, left = 1, right = (int)1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int minDays(vector<int>& A, int m, int k) {\\n        int n = A.size(), left = 1, right = 1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def minDays(self, A, m, k):\\n        if m * k > len(A): return -1\\n        left, right = 1, max(A)\\n        while left < right:\\n            mid = (left + right) / 2\\n            flow = bouq = 0\\n            for a in A:\\n                flow = 0 if a > mid else flow + 1\\n                if flow >= k:\\n                    flow = 0\\n                    bouq += 1\\n                    if bouq == m: break\\n            if bouq == m:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n<br>\\n\\n# More Good Binary Search Problems\\nHere are some similar binary search problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n- 5455. [Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/686316/javacpython-binary-search/578488)\\n- 1283. [Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446376/javacpython-bianry-search/401806)\\n- 1231. [Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/408503/Python-Binary-Search)\\n- 1011. [Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/256729/javacpython-binary-search/351188?page=3)\\n- 875. [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/152324/C++JavaPython-Binary-Search)\\n- 774. [Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/113633/Easy-and-Concise-Solution-using-Binary-Search-C++JavaPython)\\n- 410. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n<br>\\n\\n# Solution 2:\\nNote that the result must be one `A[i]`,\\nso actually we can sort A in `O(NlogK)`,\\nWhere `K` is the number of different values.\\nand then binary search the index of different values.\\n\\nI notcied many mentioned that.\\nI didn\\'t do that for the 2 main reasons,\\n1. this didn\\'t change the main idea of binary search,\\nand save just O(log1000) in time complexity,\\nin sacrifice much of writing complexity.\\n2. If we already sort `A` out,\\nwe don\\'t even need `O(NlogN)` binary search at all.\\nThe problem can be already solved in `O(N)`\\n\\nThe idea of `O(N)` is that,\\nOne pass the bloom days from in ascending order,\\nmark the bloomed flower,\\ncalculate the the continous flowers connnected,\\nupdate the bouquets and compared with `m`.\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minDays(int[] A, int m, int k) {\\n        int n = A.length, left = 1, right = (int)1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\n```cpp\\n    int minDays(vector<int>& A, int m, int k) {\\n        int n = A.size(), left = 1, right = 1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\n```py\\n    def minDays(self, A, m, k):\\n        if m * k > len(A): return -1\\n        left, right = 1, max(A)\\n        while left < right:\\n            mid = (left + right) / 2\\n            flow = bouq = 0\\n            for a in A:\\n                flow = 0 if a > mid else flow + 1\\n                if flow >= k:\\n                    flow = 0\\n                    bouq += 1\\n                    if bouq == m: break\\n            if bouq == m:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 769703,
                "title": "python-clear-explanation-powerful-ultimate-binary-search-template-solved-many-problems",
                "content": "First thing first, here is the code:\\n\\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nI have built a powerful generalized binary search template and used it to solve many problems easily. Below is the detailed and clear introduction to this template. I believe it will be worth your time :)\\n\\n****\\n\\n# Intro\\n\\nBinary Search is quite easy to understand conceptually. Basically, it splits the search space into two halves and only keep the half that probably has the search target and throw away the other half that would not possibly have the answer. In this manner, we reduce the search space to half the size at every step, until we find the target. Binary Search helps us reduce the search time from linear O(n) to logarithmic O(log n). But when it comes to implementation, it\\'s rather difficult to write a bug-free code in just a few minutes. Some of the most common problems include:\\n\\n- When to exit the loop? Should we use `left < right` or `left <= right` as the while loop condition?\\n- How to initialize the boundary variable `left` and `right`?\\n- How to update the boundary? How to choose the appropriate combination from `left = mid `, `left = mid + 1` and  `right = mid`, `right = mid - 1`?\\n\\nA rather common misunderstanding of binary search is that people often think this technique could only be used in simple scenario like \"Given a sorted array, find a specific value in it\". As a matter of fact, it can be applied to much more complicated situations.\\n\\nAfter a lot of practice in LeetCode, I\\'ve made a powerful binary search template and solved many Hard problems by just slightly twisting this template. I\\'ll share the template with you guys in this post. I don\\'t want to just show off the code and leave. Most importantly, I want to share the logical thinking: how to apply this general template to all sorts of problems. Hopefully, after reading this post, people wouldn\\'t be pissed off any more when LeetCoding, \"Holy sh*t! This problem could be solved with binary search! Why didn\\'t I think of that before!\"\\n\\n\\n\\n****\\n\\n\\n\\n# Most Generalized Binary Search\\n\\nSuppose we have a search space. It could be an array, a range, etc. Usually it\\'s sorted in ascend order. For most tasks, we can transform the requirement into the following generalized form:\\n\\n**Minimize k ,    s.t.  condition(k) is True**\\n\\nThe following code is the most generalized binary search template:\\n\\n```python\\ndef binary_search(array) -> int:\\n    def condition(value) -> bool:\\n        pass\\n\\n    left, right = 0, len(array)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nWhat\\'s really nice of this template is that, for most of the binary search problems, we only need to modify three parts after copy-pasting this template, and never need to worry about corner cases and bugs in code any more:\\n\\n- Correctly initialize the boundary variables `left` and `right`. Only one rule: set up the boundary to **include all possible elements**;\\n- Decide return value. Is it `return left` or `return left - 1`? Remember this: **after exiting the while loop, `left` is the minimal k\\u200B satisfying the `condition ` function**;\\n- Design the `condition` function. This is the most difficult and most beautiful part. Needs lots of practice.\\n\\nBelow I\\'ll show you guys how to apply this powerful template to many LeetCode problems.\\n\\n\\n\\n****\\n\\n\\n\\n# Basic Application\\n\\n## [278. First Bad Version [Easy]](https://leetcode.com/problems/first-bad-version/)\\n\\nYou are a product manager and currently leading a team to develop a new product. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API `bool isBadVersion(version)` which will return whether `version` is bad.\\n\\n**Example:**\\n\\n```scala\\nGiven n = 5, and version = 4 is the first bad version.\\n\\ncall isBadVersion(3) -> false\\ncall isBadVersion(5) -> true\\ncall isBadVersion(4) -> true\\n\\nThen 4 is the first bad version. \\n```\\n\\nFirst, we initialize `left = 1` and `right = n` to include all possible values. Then we notice that we don\\'t even need to design the `condition` function. It\\'s already given by the `isBadVersion` API. Finding the first bad version is equivalent to finding the minimal k satisfying `isBadVersion(k) is True`. Our template can fit in very nicely:\\n\\n```python\\nclass Solution:\\n    def firstBadVersion(self, n) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n****\\n\\n\\n\\n## [69. Sqrt(x) [Easy]](https://leetcode.com/problems/sqrtx/)\\n\\nImplement `int sqrt(int x)`. Compute and return the square root of *x*, where *x* is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.\\n\\n**Example:**\\n\\n```scala\\nInput: 4\\nOutput: 2\\n```\\n\\n```scala\\nInput: 8\\nOutput: 2\\n```\\n\\nQuite an easy problem. We need to search for maximal k satisfying `k^2 <= x`, so we can easily come up with the solution:\\n\\n```python\\ndef mySqrt(x: int) -> int:\\n    left, right = 0, x\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if mid * mid <= x:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return left - 1\\n```\\n\\nThere\\'s one thing I\\'d like to point out. Remember I say that **we usually look for the minimal k value satisfying certain condition**? But in this problem we are searching for maximal k value instead. Feeling confused? Don\\'t be. Actually, the maximal k satisfying `condition(k) is False` is just equal to the minimal k satisfying `condition(k) is True` minus one. This is why I mentioned earlier that we need to decide which value to return, `left` or `left - 1`.\\n\\n\\n\\n****\\n\\n\\n\\n## [35. Search Insert Position [Easy]](https://leetcode.com/problems/search-insert-position/)\\n\\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.\\n\\n**Example:**\\n\\n```scala\\nInput: [1,3,5,6], 5\\nOutput: 2\\n```\\n\\n```scala\\nInput: [1,3,5,6], 2\\nOutput: 1\\n```\\n\\nVery classic application of binary search. We are looking for the minimal k value satisfying `nums[k] >= target`, and we can just copy-paste our template. Notice that our solution is correct regardless of whether the input array `nums` has duplicates. Also notice that the input  `target` might be larger than all elements in `nums` and therefore needs to placed at the end of the array. That\\'s why we should initialize `right = len(nums)` instead of `right = len(nums) - 1`.\\n\\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= target:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n# Advanced Application\\n\\nThe above problems are quite easy to solve, because they already give us the array to be searched. We\\'d know that we should use binary search to solve them at first glance.  However, more often are the situations where the search space and search target are not so readily available. Sometimes we won\\'t even realize that the problem should be solved with binary search -- we might just turn to dynamic programming or DFS and get stuck for a very long time.\\n\\nAs for the question \"When can we use binary search?\", my answer is that, **If we can discover some kind of monotonicity, for example, if `condition(k) is True` then `condition(k + 1) is True`, then we can consider binary search**.\\n\\n## [1011. Capacity To Ship Packages Within D Days [Medium]](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n\\ndays. The `i`-th package on the conveyor belt has a weight of `weights[i]`. Each day, we load the ship with packages on the conveyor belt (in the order given by `weights`). We may not load more weight than the maximum weight capacity of the ship. \\n\\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within `D` days.\\n\\n**Example :**\\n\\n```scala\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n```\\n\\nBinary search probably would not come to our mind when we first meet this problem. We might automatically treat `weights` as search space and then realize we\\'ve entered a dead end after wasting lots of time. In fact, we are looking for the minimal one among all feasible capacities. We dig out the monotonicity of this problem: if we can successfully ship all packages within `D` days with capacity `m`, then we can definitely ship them all with any capacity larger than `m`. Now we can design a `condition` function, let\\'s call it `feasible`, given an input `capacity`, it returns whether it\\'s possible to ship all packages within `D` days. This can run in a greedy way: if there\\'s still room for the current package, we put this package onto the conveyor belt, otherwise we wait for the next day to place this package. If the total days needed exceeds `D`, we return `False`, otherwise we return `True`.\\n\\nNext, we need to initialize our boundary correctly. Obviously `capacity` should be at least `max(weights)`, otherwise the conveyor belt couldn\\'t ship the heaviest package. On the other hand, `capacity` need not be more than`sum(weights)`, because then we can ship all packages in just one day.\\n\\nNow we\\'ve got all we need to apply our binary search template:\\n\\n```python\\ndef shipWithinDays(weights: List[int], D: int) -> int:\\n    def feasible(capacity) -> bool:\\n        days = 1\\n        total = 0\\n        for weight in weights:\\n            total += weight\\n            if total > capacity:  # too heavy, wait for the next day\\n                total = weight\\n                days += 1\\n                if days > D:  # cannot ship within D days\\n                    return False\\n        return True\\n\\n    left, right = max(weights), sum(weights)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [410. Split Array Largest Sum [Hard]](https://leetcode.com/problems/split-array-largest-sum/)\\n\\nGiven an array which consists of non-negative integers and an integer *m*, you can split the array into *m* non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these *m* subarrays.\\n\\n**Example:**\\n\\n```scala\\nInput:\\nnums = [7,2,5,10,8]\\nm = 2\\n\\nOutput:\\n18\\n\\nExplanation:\\nThere are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n```\\n\\nIf you take a close look, you would probably see how similar this problem is with LC 1011 above. Similarly, we can design a `feasible` function: given an input `threshold`, then decide if we can split the array into several subarrays such that every subarray-sum is less than or equal to `threshold`. In this way, we discover the monotonicity of the problem: if `feasible(m)` is `True`, then all inputs larger than `m` can satisfy `feasible` function. You can see that the solution code is exactly the same as LC 1011.\\n\\n```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nBut we probably would have doubts: It\\'s true that `left` returned by our solution is the minimal value satisfying `feasible`, but how can we know that we can split the original array to **actually get this subarray-sum**? For example, let\\'s say `nums = [7,2,5,10,8]` and `m = 2`. We have 4 different ways to split the array to get 4 different largest subarray-sum correspondingly: `25:[[7], [2,5,10,8]]`, `23:[[7,2], [5,10,8]]`, `18:[[7,2,5], [10,8]]`, `24:[[7,2,5,10], [8]]`. Only 4 values. But our search space `[max(nums), sum(nums)] = [10, 32]` has much more that just 4 values. That is, no matter how we split the input array, we cannot get most of the values in our search space.\\n\\nLet\\'s say `k` is the minimal value satisfying `feasible` function. We can prove the correctness of our solution with proof by contradiction. Assume that no subarray\\'s sum is equal to `k`, that is, every subarray sum is less than `k`. The variable `total` inside `feasible` function keeps track of the total weights of current load. If our assumption is correct, then `total` would always be less than `k`. As a result, `feasible(k - 1)` must be `True`, because `total` would at most be equal to `k - 1` and would never trigger the if-clause `if total > threshold`, therefore `feasible(k - 1)` must have the same output as `feasible(k)`, which is `True`. But we already know that `k`  is the minimal value satisfying `feasible` function, so `feasible(k - 1)` has to be `False`, which is a contradiction. So our assumption is incorrect. Now we\\'ve proved that our algorithm is correct.\\n\\n\\n\\n****\\n\\n\\n\\n## [875. Koko Eating Bananas [Medium]](https://leetcode.com/problems/koko-eating-bananas/)\\n\\nKoko loves to eat bananas. There are `N` piles of bananas, the `i`-th pile has `piles[i]` bananas. The guards have gone and will come back in `H` hours. Koko can decide her bananas-per-hour eating speed of `K`. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than `K` bananas, she eats all of them instead, and won\\'t eat any more bananas during this hour. \\n\\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. **Return the minimum integer `K` such that she can eat all the bananas within `H` hours**.\\n\\n**Example :**\\n\\n```scala\\nInput: piles = [3,6,7,11], H = 8\\nOutput: 4\\n```\\n\\n```scala\\nInput: piles = [30,11,23,4,20], H = 5\\nOutput: 30\\n```\\n\\n```scala\\nInput: piles = [30,11,23,4,20], H = 6\\nOutput: 23\\n```\\n\\nVery similar to LC 1011 and LC 410 mentioned above. Let\\'s design a `feasible` function, given an input `speed`, determine whether Koko can finish all bananas within `H` hours with hourly eating speed `speed`. Obviously, the lower bound of the search space is 1, and upper bound is `max(piles)`, because Koko can only choose one pile of bananas to eat every hour.\\n\\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1482. Minimum Number of Days to Make m Bouquets [Medium]](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n\\nGiven an integer array `bloomDay`, an integer `m` and an integer `k`. We need to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent flowers** from the garden. The garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in **exactly one** bouquet. Return *the minimum number of days* you need to wait to be able to make `m` bouquets from the garden. If it is impossible to make `m` bouquets return **-1**.\\n\\n**Examples:**\\n\\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\\nOutput: 3\\nExplanation: Let\\'s see what happened in the first three days. x means flower bloomed and _ means flower didn\\'t bloom in the garden.\\nWe need 3 bouquets each should contain 1 flower.\\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\\n```\\n\\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\\nOutput: -1\\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\\n```\\n\\nNow that we\\'ve solved three advanced problems above, this one should be pretty easy to do. The monotonicity of this problem is very clear: if we can make `m` bouquets after waiting for `d` days, then we can definitely finish that as well if we wait more than `d` days.\\n\\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [668. Kth Smallest Number in Multiplication Table [Hard]](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\\n\\nNearly every one have used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). But could you find out the `k-th` smallest number quickly from the multiplication table? Given the height `m` and the length `n` of a `m * n` Multiplication Table, and a positive integer `k`, you need to return the `k-th` smallest number in this table.\\n\\n**Example :**\\n\\n```scala\\nInput: m = 3, n = 3, k = 5\\nOutput: 3\\nExplanation: \\nThe Multiplication Table:\\n1\\t2\\t3\\n2\\t4\\t6\\n3\\t6\\t9\\n\\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\\n```\\n\\nFor Kth-Smallest problems like this, what comes to our mind first is Heap. Usually we can  maintain a Min-Heap and just pop the top of the Heap for k times. However, that doesn\\'t work out in this problem. We don\\'t have every single number in the entire Multiplication Table, instead, we only have the height and the length of the table. If we are to apply Heap method, we need to explicitly calculate these `m * n` values and save them to a heap. The time complexity and space complexity of this process are both O(mn), which is quite inefficient. This is when binary search comes in. Remember we say that designing `condition` function is the most difficult part? In order to find the k-th smallest value in the table, we can design an `enough` function, given an input `num`, determine whether there\\'re at least k values less than or equal to `num`. **The minimal `num` satisfying `enough` function is the answer we\\'re looking for**. Recall that the key to binary search is discovering monotonicity. In this problem, if `num` satisfies `enough`, then of course any value larger than `num` can satisfy. This monotonicity is the fundament of our binary search algorithm.\\n\\nLet\\'s consider search space. Obviously the lower bound should be 1, and the upper bound should be the largest value in the Multiplication Table, which is `m * n`, then we have search space `[1, m * n]`. The overwhelming advantage of binary search solution to heap solution is that it doesn\\'t need to explicitly calculate all numbers in that table, all it needs is just picking up one value out of the search space and apply `enough` function to this value, to determine should we keep the left half or the right half of the search space. In this way, binary search solution only requires constant space complexity, much better than heap solution.\\n\\nNext let\\'s consider how to implement `enough` function. It can be observed that every row in the Multiplication Table is just multiples of its index. For example, all numbers in 3rd row `[3,6,9,12,15...]` are multiples of 3. Therefore, we can just go row by row to count the total number of entries less than or equal to input `num`. Following is the complete solution.\\n\\n```python\\ndef findKthNumber(m: int, n: int, k: int) -> int:\\n    def enough(num) -> bool:\\n        count = 0\\n        for val in range(1, m + 1):  # count row by row\\n            add = min(num // val, n)\\n            if add == 0:  # early exit\\n                break\\n            count += add\\n        return count >= k                \\n\\n    left, right = 1, n * m\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left \\n```\\n\\nIn LC 410 above, we have doubt \"Is the result from binary search actually a subarray sum?\". Here we have a similar doubt: \"Is the result from binary search actually in the Multiplication Table?\". The answer is yes, and we also can apply proof by contradiction. Denote `num` as the minimal input that satisfies `enough` function. Let\\'s assume that `num` is not in the table, which means that `num` is not divisible by any `val` in `[1, m]`, that is, `num % val > 0`. Therefore, changing the input from `num` to `num - 1` doesn\\'t have any effect on the expression `add = min(num // val, n)`. So `enough(num)` would also return `True`,  just like `enough(num)`. But we already know `num` is the minimal input satisfying `enough` function, so `enough(num - 1)` has to be `False`. Contradiction! The opposite of our original assumption is true: `num` is actually in the table.\\n\\n\\n\\n****\\n\\n\\n\\n## [719. Find K-th Smallest Pair Distance [Hard]](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\n\\nGiven an integer array, return the k-th smallest **distance** among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.\\n\\n**Example :**\\n\\n```scala\\nInput:\\nnums = [1,3,1]\\nk = 1\\nOutput: 0 \\nExplanation:\\nFollowing are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0.\\n(1,3) -> 2\\n(1,1) -> 0\\n(3,1) -> 2\\n```\\n\\nVery similar to LC 668 above, both are about finding Kth-Smallest. Just like LC 668, We can design an `enough` function, given an input `distance`, determine whether there\\'re at least k pairs whose distances are less than or equal to `distance`. We can sort the input array and use two pointers (fast pointer and slow pointer, pointed at a pair) to scan it. Both pointers go from leftmost end. If the current pair pointed at has a distance less than or equal to `distance`, all pairs between these pointers are valid (since the array is already sorted), we move forward the fast pointer. Otherwise, we move forward the slow pointer. By the time both pointers reach the rightmost end, we finish our scan and see if total counts exceed k. Here is the implementation:\\n\\n```python\\ndef enough(distance) -> bool:  # two pointers\\n    count, i, j = 0, 0, 0\\n    while i < n or j < n:\\n        while j < n and nums[j] - nums[i] <= distance:  # move fast pointer\\n            j += 1\\n        count += j - i - 1  # count pairs\\n        i += 1  # move slow pointer\\n    return count >= k\\n```\\n\\nObviously, our search space should be `[0, max(nums) - min(nums)]`. Now we are ready to copy-paste our template:\\n\\n```python\\ndef smallestDistancePair(nums: List[int], k: int) -> int:\\n    nums.sort()\\n    n = len(nums)\\n    left, right = 0, nums[-1] - nums[0]\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1201. Ugly Number III [Medium]](https://leetcode.com/problems/ugly-number-iii/)\\n\\nWrite a program to find the `n`-th ugly number. Ugly numbers are **positive integers** which are divisible by `a` **or** `b` **or** `c`.\\n\\n**Example :**\\n\\n```scala\\nInput: n = 3, a = 2, b = 3, c = 5\\nOutput: 4\\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\\n```\\n\\n```scala\\nInput: n = 4, a = 2, b = 3, c = 4\\nOutput: 6\\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\\n```\\n\\nNothing special. Still finding the Kth-Smallest. We need to design an `enough` function, given an input `num`, determine whether there are at least n ugly numbers less than or equal to `num`. Since `a` might be a multiple of `b` or `c`, or the other way round, we need the help of greatest common divisor to avoid counting duplicate numbers.\\n\\n```python\\ndef nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\\n    def enough(num) -> bool:\\n        total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n        return total >= n\\n\\n    ab = a * b // math.gcd(a, b)\\n    ac = a * c // math.gcd(a, c)\\n    bc = b * c // math.gcd(b, c)\\n    abc = a * bc // math.gcd(a, bc)\\n    left, right = 1, 10 ** 10\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1283. Find the Smallest Divisor Given a Threshold [Medium]](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n\\nGiven an array of integers `nums` and an integer `threshold`, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the **smallest** divisor such that the result mentioned above is less than or equal to `threshold`.\\n\\nEach result of division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5). It is guaranteed that there will be an answer.\\n\\n**Example :**\\n\\n```scala\\nInput: nums = [1,2,5,9], threshold = 6\\nOutput: 5\\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \\nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \\n```\\n\\nAfter so many problems introduced above, this one should be a piece of cake. We don\\'t even need to bother to design a `condition` function, because the problem has already told us explicitly what condition we need to satisfy.\\n\\n```python\\ndef smallestDivisor(nums: List[int], threshold: int) -> int:\\n    def condition(divisor) -> bool:\\n        return sum((num - 1) // divisor + 1 for num in nums) <= threshold\\n\\n    left, right = 1, max(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n# End\\n\\nWow, thank you so much for making it to the end, really appreciate that. As you can see from the python codes above, they all look very similar to each other. That\\'s because I copy-pasted my template all the time. No exception. This is the strong proof of my template\\'s powerfulness. I believe everyone can acquire this binary search template to solve many problems. All we need is just more practice to build up our ability to discover the monotonicity of the problem and to design a beautiful `condition` function.\\n\\nHope this helps.\\n\\n**Reference**\\n\\n- [[C++ / Fast / Very clear explanation / Clean Code] Solution with Greedy Algorithm and Binary Search](https://leetcode.com/problems/split-array-largest-sum/discuss/89819/C%2B%2B-Fast-Very-clear-explanation-Clean-Code-Solution-with-Greedy-Algorithm-and-Binary-Search)\\n- [Approach the problem using the \"trial and error\" algorithm](https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/109082/Approach-the-problem-using-the-\"trial-and-error\"-algorithm)\\n- [Binary Search 101 The-Ultimate-Binary-Search-Handbook - LeetCode](https://leetcode.com/problems/binary-search/discuss/423162/Binary-Search-101-The-Ultimate-Binary-Search-Handbook)\\n- [ugly-number-iii Binary Search with picture & Binary Search Template - LeetCode](https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```python\\ndef binary_search(array) -> int:\\n    def condition(value) -> bool:\\n        pass\\n\\n    left, right = 0, len(array)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nGiven n = 5, and version = 4 is the first bad version.\\n\\ncall isBadVersion(3) -> false\\ncall isBadVersion(5) -> true\\ncall isBadVersion(4) -> true\\n\\nThen 4 is the first bad version. \\n```\n```python\\nclass Solution:\\n    def firstBadVersion(self, n) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```scala\\nInput: 4\\nOutput: 2\\n```\n```scala\\nInput: 8\\nOutput: 2\\n```\n```python\\ndef mySqrt(x: int) -> int:\\n    left, right = 0, x\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if mid * mid <= x:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return left - 1\\n```\n```scala\\nInput: [1,3,5,6], 5\\nOutput: 2\\n```\n```scala\\nInput: [1,3,5,6], 2\\nOutput: 1\\n```\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= target:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```scala\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n```\n```python\\ndef shipWithinDays(weights: List[int], D: int) -> int:\\n    def feasible(capacity) -> bool:\\n        days = 1\\n        total = 0\\n        for weight in weights:\\n            total += weight\\n            if total > capacity:  # too heavy, wait for the next day\\n                total = weight\\n                days += 1\\n                if days > D:  # cannot ship within D days\\n                    return False\\n        return True\\n\\n    left, right = max(weights), sum(weights)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput:\\nnums = [7,2,5,10,8]\\nm = 2\\n\\nOutput:\\n18\\n\\nExplanation:\\nThere are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n```\n```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: piles = [3,6,7,11], H = 8\\nOutput: 4\\n```\n```scala\\nInput: piles = [30,11,23,4,20], H = 5\\nOutput: 30\\n```\n```scala\\nInput: piles = [30,11,23,4,20], H = 6\\nOutput: 23\\n```\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\\nOutput: 3\\nExplanation: Let\\'s see what happened in the first three days. x means flower bloomed and _ means flower didn\\'t bloom in the garden.\\nWe need 3 bouquets each should contain 1 flower.\\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\\n```\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\\nOutput: -1\\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\\n```\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: m = 3, n = 3, k = 5\\nOutput: 3\\nExplanation: \\nThe Multiplication Table:\\n1\\t2\\t3\\n2\\t4\\t6\\n3\\t6\\t9\\n\\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\\n```\n```python\\ndef findKthNumber(m: int, n: int, k: int) -> int:\\n    def enough(num) -> bool:\\n        count = 0\\n        for val in range(1, m + 1):  # count row by row\\n            add = min(num // val, n)\\n            if add == 0:  # early exit\\n                break\\n            count += add\\n        return count >= k                \\n\\n    left, right = 1, n * m\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left \\n```\n```scala\\nInput:\\nnums = [1,3,1]\\nk = 1\\nOutput: 0 \\nExplanation:\\nFollowing are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0.\\n(1,3) -> 2\\n(1,1) -> 0\\n(3,1) -> 2\\n```\n```python\\ndef enough(distance) -> bool:  # two pointers\\n    count, i, j = 0, 0, 0\\n    while i < n or j < n:\\n        while j < n and nums[j] - nums[i] <= distance:  # move fast pointer\\n            j += 1\\n        count += j - i - 1  # count pairs\\n        i += 1  # move slow pointer\\n    return count >= k\\n```\n```python\\ndef smallestDistancePair(nums: List[int], k: int) -> int:\\n    nums.sort()\\n    n = len(nums)\\n    left, right = 0, nums[-1] - nums[0]\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: n = 3, a = 2, b = 3, c = 5\\nOutput: 4\\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\\n```\n```scala\\nInput: n = 4, a = 2, b = 3, c = 4\\nOutput: 6\\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\\n```\n```python\\ndef nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\\n    def enough(num) -> bool:\\n        total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n        return total >= n\\n\\n    ab = a * b // math.gcd(a, b)\\n    ac = a * c // math.gcd(a, c)\\n    bc = b * c // math.gcd(b, c)\\n    abc = a * bc // math.gcd(a, bc)\\n    left, right = 1, 10 ** 10\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: nums = [1,2,5,9], threshold = 6\\nOutput: 5\\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \\nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \\n```\n```python\\ndef smallestDivisor(nums: List[int], threshold: int) -> int:\\n    def condition(divisor) -> bool:\\n        return sum((num - 1) // divisor + 1 for num in nums) <= threshold\\n\\n    left, right = 1, max(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686237,
                "title": "c-binary-search",
                "content": "**Observation**\\n\\nCan we get the number of bouquets that can form at day `d` ?\\nYes we can, just run a simple count to get the number adjacent bloomed flowers that are greater than or equal to `k` by checking if the day they bloom is less than or equal to `d`(be careful of continuous flowers that can make 2 bouquets eg 2*k bloomed flowers).\\n\\nOnce we have the previous logic, we can simply run binary search on the range `min` and `max` days from the input and try to minimize the day where we can get atleast `m` bouquets.\\nIn the end we only need to check if the minimized `day` has atleast `m` bouquets. This is our answer.\\n\\n**Solution**\\n```c++\\nclass Solution {\\npublic:\\n    int getBouq(vector<int>& bloomDay,int day,int k)\\t//Get the number of bouquets of size k at a certain day.\\n    {\\n        int result=0,count=0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            if(bloomDay[i]<=day)\\n                count++;\\n            else\\n                count=0;\\n            if(count==k)    //Reset the window size to 0 to consider the case with 2*k or more continous bloomed flowers.\\n                result++,count=0;\\n        }\\n        return result;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) \\n    {\\n        auto p=minmax_element(bloomDay.begin(),bloomDay.end());\\n        int j=*p.second,i=*p.first;\\n        int mid;\\n        while(i<j)\\t\\t\\t\\t//Binary search on the range to get the minimum day where we may get `m` bouquets.\\n        {\\n            mid=(i+j)>>1;\\n            if(getBouq(bloomDay,mid,k)<m)\\n                i=mid+1;\\n            else\\n                j=mid;\\n        }\\n        return getBouq(bloomDay,i,k)>=m?i:-1;\\t\\t//Final check if the result day can have atleast `m` bouquets.\\n    }\\n};\\n```\\n**Complexity**\\nTime: `O(nlog(max(bloomDay)-min(bloomDay))` where `max(bloomDay)` is the maximum value and `min(bloomDay)` is the minimum value of the `bloomDay` input.\\nSpace: `O(1)`.",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int getBouq(vector<int>& bloomDay,int day,int k)\\t//Get the number of bouquets of size k at a certain day.\\n    {\\n        int result=0,count=0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            if(bloomDay[i]<=day)\\n                count++;\\n            else\\n                count=0;\\n            if(count==k)    //Reset the window size to 0 to consider the case with 2*k or more continous bloomed flowers.\\n                result++,count=0;\\n        }\\n        return result;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) \\n    {\\n        auto p=minmax_element(bloomDay.begin(),bloomDay.end());\\n        int j=*p.second,i=*p.first;\\n        int mid;\\n        while(i<j)\\t\\t\\t\\t//Binary search on the range to get the minimum day where we may get `m` bouquets.\\n        {\\n            mid=(i+j)>>1;\\n            if(getBouq(bloomDay,mid,k)<m)\\n                i=mid+1;\\n            else\\n                j=mid;\\n        }\\n        return getBouq(bloomDay,i,k)>=m?i:-1;\\t\\t//Final check if the result day can have atleast `m` bouquets.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686529,
                "title": "java-binary-search-with-detailed-explanation-runtime-o-nlog-maxdays-100",
                "content": "This approach is to do a Hit or miss, starting from min days to max days.\\nTime Complexity: O(nLog(maxdays))\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution {\\n\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if (bloomDay.length < m * k) return -1;\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        for (int i : bloomDay) {\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n//        Take the boundary starting from 1 to the max day in the bloomDay.\\n        while (min < max) {\\n            int mid = min + (max - min) / 2;\\n            int possibleBookies = getPossibleBookies(bloomDay, mid, k);\\n//            The\\n            if (possibleBookies < m) {\\n                min = mid + 1;\\n            } else {\\n                max = mid;\\n            }\\n        }\\n        return min;\\n    }\\n\\n    private int getPossibleBookies(int[] bloomDay, int day, int k) {\\n//        This method is to find the number of bouquets that can be formed on a given day.\\n        int bouquets = 0, flowersCollected = 0;\\n        for (int value : bloomDay) {\\n            if (value <= day) {\\n//                If the current flower can be taken with in days then increase the flower flowersCollected.\\n                flowersCollected++;\\n            } else {\\n//                If there is a flower in between that takes more number of days then the given day, then resent the counter.\\n                flowersCollected = 0;\\n            }\\n//            If the flowersCollected is same as the required flower per bookie, then increase the bouquets count;\\n            if (flowersCollected == k) {\\n                bouquets++;\\n                flowersCollected = 0;\\n            }\\n        }\\n        return bouquets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if (bloomDay.length < m * k) return -1;\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        for (int i : bloomDay) {\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n//        Take the boundary starting from 1 to the max day in the bloomDay.\\n        while (min < max) {\\n            int mid = min + (max - min) / 2;\\n            int possibleBookies = getPossibleBookies(bloomDay, mid, k);\\n//            The\\n            if (possibleBookies < m) {\\n                min = mid + 1;\\n            } else {\\n                max = mid;\\n            }\\n        }\\n        return min;\\n    }\\n\\n    private int getPossibleBookies(int[] bloomDay, int day, int k) {\\n//        This method is to find the number of bouquets that can be formed on a given day.\\n        int bouquets = 0, flowersCollected = 0;\\n        for (int value : bloomDay) {\\n            if (value <= day) {\\n//                If the current flower can be taken with in days then increase the flower flowersCollected.\\n                flowersCollected++;\\n            } else {\\n//                If there is a flower in between that takes more number of days then the given day, then resent the counter.\\n                flowersCollected = 0;\\n            }\\n//            If the flowersCollected is same as the required flower per bookie, then increase the bouquets count;\\n            if (flowersCollected == k) {\\n                bouquets++;\\n                flowersCollected = 0;\\n            }\\n        }\\n        return bouquets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686240,
                "title": "binary-search",
                "content": "My first though was to use a sliding window. In a linear time, we can find the maximum bloom days for consecutive  groups of `k` flowers. Then, we can run a top-down DP to search for `m` non-overlapping groups. With memoisation, this approach will take O(n * m). \\n\\nAt this point in the contest, I was thinking that it\\'s a bit of too complex for a medium problem. That was my first hint. \\n\\nThen, I realized that, with `n` and `m` up to 10^5 each and O(n * m), we are looking to 10^10 memory and time operations (well `m` is 10^6 in the description, but it does not make sense). This is a recipe for TLE/MLE. Therefore, I turned back and started considering other patterns that would give us a O(n log n) solution (O(n) seemed unlikely).\\n\\nA second hint was that we need to process the input in the original order (flowers has to be adjacent), and return a minimum value to satisfy some criteria. This sounded very similar these problems that can be solved using binary search:\\n- [Koko eating bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n- [Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n\\nFinally, I confirmed that function `bouquets = f(days)` is non-decreasing, so we can use a binary search to find the minimum `days`. \\n\\n**C++**\\n```cpp\\nbool canHarvest(vector<int>& bDay, int harvestDay, int m, int k) {\\n    int adjacent = 0;\\n    for (auto bloomDay : bDay) {\\n        adjacent = bloomDay <= harvestDay ? adjacent + 1 : 0;\\n        if (adjacent == k) {\\n            adjacent = 0;\\n            --m;\\n        }\\n    }\\n    return m <= 0;\\n}\\nint minDays(vector<int>& bDay, int m, int k) {\\n    if ((long long)m * k > bDay.size())\\n        return -1;\\n    auto lo = 1, hi = 1000000000;\\n    while (lo < hi) {\\n        auto mid = (hi + lo) / 2;\\n        if (canHarvest(bDay, mid, m, k))\\n            hi = mid;\\n        else\\n            lo = mid + 1;\\n    }\\n    return lo;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool canHarvest(vector<int>& bDay, int harvestDay, int m, int k) {\\n    int adjacent = 0;\\n    for (auto bloomDay : bDay) {\\n        adjacent = bloomDay <= harvestDay ? adjacent + 1 : 0;\\n        if (adjacent == k) {\\n            adjacent = 0;\\n            --m;\\n        }\\n    }\\n    return m <= 0;\\n}\\nint minDays(vector<int>& bDay, int m, int k) {\\n    if ((long long)m * k > bDay.size())\\n        return -1;\\n    auto lo = 1, hi = 1000000000;\\n    while (lo < hi) {\\n        auto mid = (hi + lo) / 2;\\n        if (canHarvest(bDay, mid, m, k))\\n            hi = mid;\\n        else\\n            lo = mid + 1;\\n    }\\n    return lo;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686337,
                "title": "c-binary-search-more-similar-problems-listed",
                "content": "**Solution:**\\n\\n```\\nclass Solution {\\n    bool isValid(vector<int>& bloomDay, int m, int k, int mid) {\\n        \\n        int count = 0, size = 0;\\n        for (int i = 0; i < bloomDay.size(); i++) {\\n            size = (bloomDay[i] <= mid) ? size+1 : 0;\\n            if (size == k) size = 0, count++;\\n            if (count == m)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n\\t\\tif(bloomDay.size() == 0 || m == 0 || k == 0) return 0;\\n\\t\\tif (m * k > bloomDay.size()) return -1;\\n\\t\\t\\n\\t\\tint l = INT_MAX, r = INT_MIN;\\n\\t\\tfor (int i = 0; i < bloomDay.size(); i++) {\\n\\t\\t\\tl = min(l, bloomDay[i]);\\n\\t\\t\\tr = max(r, bloomDay[i]);\\n\\t\\t}\\n\\t\\t\\n\\t\\twhile (l <= r) {\\n            int mid = l + (r-l)/2;\\n            \\n            if (isValid(bloomDay, m, k, mid))\\n                r = mid-1;\\n            else\\n                l = mid+1;\\n        }\\n        \\n        return l;\\n    }\\n};\\n```\\n\\n**Similar Binary Search problems:**\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\nhttps://leetcode.com/problems/koko-eating-bananas/\\nhttps://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/\\nhttps://leetcode.com/problems/sum-of-mutated-array-closest-to-target/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isValid(vector<int>& bloomDay, int m, int k, int mid) {\\n        \\n        int count = 0, size = 0;\\n        for (int i = 0; i < bloomDay.size(); i++) {\\n            size = (bloomDay[i] <= mid) ? size+1 : 0;\\n            if (size == k) size = 0, count++;\\n            if (count == m)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n\\t\\tif(bloomDay.size() == 0 || m == 0 || k == 0) return 0;\\n\\t\\tif (m * k > bloomDay.size()) return -1;\\n\\t\\t\\n\\t\\tint l = INT_MAX, r = INT_MIN;\\n\\t\\tfor (int i = 0; i < bloomDay.size(); i++) {\\n\\t\\t\\tl = min(l, bloomDay[i]);\\n\\t\\t\\tr = max(r, bloomDay[i]);\\n\\t\\t}\\n\\t\\t\\n\\t\\twhile (l <= r) {\\n            int mid = l + (r-l)/2;\\n            \\n            if (isValid(bloomDay, m, k, mid))\\n                r = mid-1;\\n            else\\n                l = mid+1;\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731921,
                "title": "simple-c-explanation",
                "content": "### INTUITION\\nHow we can get the idea that we can use binary search??? \\nWe see thet the the answer will lie between the minimum and the maximum of the bloomsDay array i.e the day on which first flower blooms and the day when all the flowers will bloom. For eg. if min = 10 and max = 25 then our answer will be sime number between 10 and 25 [ 10 , 11 ,12 ,13, ... , 24 , 25 ].\\nWe can either tranverse from 10 to 25 to find the minimum possible value when our condition is met which will take lenear time O(n).  But and efficient way would be to use binary search (since the answer range is already sorted).  This would reduce the time complexity to O ( log ( max - min) );\\n\\n## The check function.\\nSuppose the present day is X . So we need to firstly calculate how many bouquets we can make till present day. If the number of bouquets that we can make is greater than the required number of bouquets than we return true or else we return false. Have a look at the code to see how we are calculating this.\\n ```\\n class Solution {\\npublic:\\n      bool check(int present_day, vector<int> bloomDay, int required_bouquet, int required_flower)\\n{\\n\\tint flower_count=0;\\n\\tint bouquet_count =0;\\n\\tfor(int i=0;i<bloomDay.size(); i++)\\n\\t{\\n\\t\\t// when this flower is already blossomed so we can include this   flower.\\n\\t\\tif(bloomDay[i] <= present_day)\\n\\t\\t{\\n\\t\\t\\tflower_count++;\\n\\t\\t\\tif(flower_count == required_flower)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbouquet_count++;\\n\\t\\t\\t\\tflower_count =0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// when the flower has not blosssomed we can not include\\n\\t\\t// so it breaks the chain.\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tflower_count = 0;\\n\\n\\t\\t}\\n\\t}\\n\\n\\tif(bouquet_count >= required_bouquet) return true;\\n\\telse return false;\\n\\n}\\n\\nint minDays(vector<int>& bloomDay, int m, int k) {\\n    \\n    if(m*k > bloomDay.size()) return -1;\\n    \\n    \\n        int lower = *min_element(bloomDay.begin(), bloomDay.end());\\n        int upper = *max_element(bloomDay.begin(), bloomDay.end());\\n\\n        while(lower < upper)\\n        {\\n        \\tint mid = lower + (upper - lower)/2;\\n\\n        \\tif(check(mid , bloomDay , m , k)) upper = mid;\\n        \\telse lower = mid +1;\\n\\n        }\\n\\n        return lower;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n class Solution {\\npublic:\\n      bool check(int present_day, vector<int> bloomDay, int required_bouquet, int required_flower)\\n{\\n\\tint flower_count=0;\\n\\tint bouquet_count =0;\\n\\tfor(int i=0;i<bloomDay.size(); i++)\\n\\t{\\n\\t\\t// when this flower is already blossomed so we can include this   flower.\\n\\t\\tif(bloomDay[i] <= present_day)\\n\\t\\t{\\n\\t\\t\\tflower_count++;\\n\\t\\t\\tif(flower_count == required_flower)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbouquet_count++;\\n\\t\\t\\t\\tflower_count =0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// when the flower has not blosssomed we can not include\\n\\t\\t// so it breaks the chain.\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tflower_count = 0;\\n\\n\\t\\t}\\n\\t}\\n\\n\\tif(bouquet_count >= required_bouquet) return true;\\n\\telse return false;\\n\\n}\\n\\nint minDays(vector<int>& bloomDay, int m, int k) {\\n    \\n    if(m*k > bloomDay.size()) return -1;\\n    \\n    \\n        int lower = *min_element(bloomDay.begin(), bloomDay.end());\\n        int upper = *max_element(bloomDay.begin(), bloomDay.end());\\n\\n        while(lower < upper)\\n        {\\n        \\tint mid = lower + (upper - lower)/2;\\n\\n        \\tif(check(mid , bloomDay , m , k)) upper = mid;\\n        \\telse lower = mid +1;\\n\\n        }\\n\\n        return lower;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327257,
                "title": "template-one-code-works-for-all-problems",
                "content": "Check the code. Can easily identify the pattern. All questions are related to binary search\\n1) https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/\\n\\n````\\npublic class Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int low  = Arrays.stream(bloomDay).min().getAsInt();\\n        int high =  Arrays.stream(bloomDay).max().getAsInt();\\n\\n        int  ans = -1;\\n\\n        while (low<=high){\\n            int mid = low+(high-low)/2;\\n\\n            if(isPossible(bloomDay,mid,k,m)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else {\\n\\n                low=mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isPossible(int[] bloomDay, int mid, int k,int booket) {\\n        int bouquets = 0, flowersCollected = 0;\\n        for (int value : bloomDay) {\\n            if (value <= mid) {\\n//                If the current flower can be taken with in days then increase the flower flowersCollected.\\n                flowersCollected++;\\n            } else {\\n//                If there is a flower in between that takes more number of days then the given day, then resent the counter.\\n                flowersCollected = 0;\\n            }\\n//            If the flowersCollected is same as the required flower per bookie, then increase the bouquets count;\\n            if (flowersCollected == k) {\\n                bouquets++;\\n                flowersCollected = 0;\\n            }\\n        }\\n\\n        return bouquets>=booket;\\n\\n    }\\n}\\n\\n````\\n\\n2) https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\n````\\n public int shipWithinDays(int[] weights, int days) {\\n\\n        int capacity = 0;\\n        int start = Arrays.stream(weights).max().getAsInt();\\n        int end = Arrays.stream(weights).sum();\\n\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if( isPossible(weights, mid,days)){\\n                capacity = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return capacity;\\n\\n    }\\n\\n    private boolean isPossible(int[] weights, int mid, int days) {\\n        int currentDay = 1;\\n        long currentWeight=0;\\n        for(int weight:weights){\\n\\n            currentWeight+=weight;\\n            if(currentWeight>mid){\\n                currentDay++;\\n                currentWeight=weight;\\n            }\\n\\n        }\\n        return currentDay<=days;\\n\\n    }\\n````\\n\\n3)https://leetcode.com/problems/divide-chocolate/\\n````\\n public int maximizeSweetness(int[] sweetness, int k) {\\n        int min = Arrays.stream(sweetness).min().getAsInt();\\n        int max = Arrays.stream(sweetness).sum();\\n        int ans=min;\\n        while(min<=max){\\n            int mid = min+(max-min)/2;\\n            if(isPossible(sweetness,mid,k)){\\n                ans=mid;\\n                max=mid-1;\\n            }\\n            else {min=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n\\n    private boolean isPossible(int[] sweetness, int mid, int k) {\\n        int currSweet=0;\\n        int division=0;\\n        for(int swt: sweetness){\\n            currSweet+=swt;\\n            // because can not have < mid and cut has to be done\\n            if(currSweet>mid){\\n                currSweet=0;\\n                division++;\\n            }\\n        }\\n\\n        return division<=k;\\n    }\\n````\\n\\n4) https://leetcode.com/problems/split-array-largest-sum/\\n\\n````\\npublic class Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int low = Arrays.stream(nums).max().getAsInt();;\\n        int high = Arrays.stream(nums).sum();;\\n        int ans = 0;\\n\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n\\n            if(isPossible(nums,mid,m)){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isPossible(int[] nums, int mid, int m) {\\n        int split = 1;\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum += nums[i];\\n            if(sum > mid){\\n                split ++;\\n                sum = nums[i];\\n            }\\n        }\\n        return split<=m;\\n    }\\n\\n}\\n````",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "````\\npublic class Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int low  = Arrays.stream(bloomDay).min().getAsInt();\\n        int high =  Arrays.stream(bloomDay).max().getAsInt();\\n\\n        int  ans = -1;\\n\\n        while (low<=high){\\n            int mid = low+(high-low)/2;\\n\\n            if(isPossible(bloomDay,mid,k,m)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else {\\n\\n                low=mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isPossible(int[] bloomDay, int mid, int k,int booket) {\\n        int bouquets = 0, flowersCollected = 0;\\n        for (int value : bloomDay) {\\n            if (value <= mid) {\\n//                If the current flower can be taken with in days then increase the flower flowersCollected.\\n                flowersCollected++;\\n            } else {\\n//                If there is a flower in between that takes more number of days then the given day, then resent the counter.\\n                flowersCollected = 0;\\n            }\\n//            If the flowersCollected is same as the required flower per bookie, then increase the bouquets count;\\n            if (flowersCollected == k) {\\n                bouquets++;\\n                flowersCollected = 0;\\n            }\\n        }\\n\\n        return bouquets>=booket;\\n\\n    }\\n}\\n\\n```\n````\\n public int shipWithinDays(int[] weights, int days) {\\n\\n        int capacity = 0;\\n        int start = Arrays.stream(weights).max().getAsInt();\\n        int end = Arrays.stream(weights).sum();\\n\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if( isPossible(weights, mid,days)){\\n                capacity = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return capacity;\\n\\n    }\\n\\n    private boolean isPossible(int[] weights, int mid, int days) {\\n        int currentDay = 1;\\n        long currentWeight=0;\\n        for(int weight:weights){\\n\\n            currentWeight+=weight;\\n            if(currentWeight>mid){\\n                currentDay++;\\n                currentWeight=weight;\\n            }\\n\\n        }\\n        return currentDay<=days;\\n\\n    }\\n```\n````\\n public int maximizeSweetness(int[] sweetness, int k) {\\n        int min = Arrays.stream(sweetness).min().getAsInt();\\n        int max = Arrays.stream(sweetness).sum();\\n        int ans=min;\\n        while(min<=max){\\n            int mid = min+(max-min)/2;\\n            if(isPossible(sweetness,mid,k)){\\n                ans=mid;\\n                max=mid-1;\\n            }\\n            else {min=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n\\n    private boolean isPossible(int[] sweetness, int mid, int k) {\\n        int currSweet=0;\\n        int division=0;\\n        for(int swt: sweetness){\\n            currSweet+=swt;\\n            // because can not have < mid and cut has to be done\\n            if(currSweet>mid){\\n                currSweet=0;\\n                division++;\\n            }\\n        }\\n\\n        return division<=k;\\n    }\\n```\n````\\npublic class Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int low = Arrays.stream(nums).max().getAsInt();;\\n        int high = Arrays.stream(nums).sum();;\\n        int ans = 0;\\n\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n\\n            if(isPossible(nums,mid,m)){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isPossible(int[] nums, int mid, int m) {\\n        int split = 1;\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum += nums[i];\\n            if(sum > mid){\\n                split ++;\\n                sum = nums[i];\\n            }\\n        }\\n        return split<=m;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317010,
                "title": "java-binary-search-13ms-beats-99-45-t-c-o-n-log-max-bloomday-s-c-o-1",
                "content": "\\n\\t// Binary Search\\n\\t// O(bloomDay.length*log(max(bloomDay))) O(1)\\n\\tpublic int minDays(int[] bloomDay, int m, int k) {\\n\\n\\t\\tint max = Integer.MIN_VALUE, len = bloomDay.length;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (bloomDay[i] > max)\\n\\t\\t\\t\\tmax = bloomDay[i];\\n\\t\\t}\\n\\n\\t\\tint lo = 1, hi = max, ans = -1;\\n\\n\\t\\twhile (lo <= hi) {\\n\\n\\t\\t\\tint mid = lo + (hi - lo) / 2;\\n\\t\\t\\tif (isPossible(bloomDay, m, k, mid)) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(bloomDay.length) O(1)\\n\\tpublic boolean isPossible(int[] bloomDay, int m, int k, int days) {\\n\\n\\t\\tint len = bloomDay.length, count = 0, adjacent = 0;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\tif (bloomDay[i] <= days) {\\n\\t\\t\\t\\tadjacent++;\\n\\t\\t\\t\\tif (adjacent == k) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tif (count == m)\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\tadjacent = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else\\n\\t\\t\\t\\tadjacent = 0;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\t// Binary Search\\n\\t// O(bloomDay.length*log(max(bloomDay))) O(1)\\n\\tpublic int minDays(int[] bloomDay, int m, int k) {\\n\\n\\t\\tint max = Integer.MIN_VALUE, len = bloomDay.length;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (bloomDay[i] > max)\\n\\t\\t\\t\\tmax = bloomDay[i];\\n\\t\\t}\\n\\n\\t\\tint lo = 1, hi = max, ans = -1;\\n\\n\\t\\twhile (lo <= hi) {\\n\\n\\t\\t\\tint mid = lo + (hi - lo) / 2;\\n\\t\\t\\tif (isPossible(bloomDay, m, k, mid)) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(bloomDay.length) O(1)\\n\\tpublic boolean isPossible(int[] bloomDay, int m, int k, int days) {\\n\\n\\t\\tint len = bloomDay.length, count = 0, adjacent = 0;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\tif (bloomDay[i] <= days) {\\n\\t\\t\\t\\tadjacent++;\\n\\t\\t\\t\\tif (adjacent == k) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tif (count == m)\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\tadjacent = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else\\n\\t\\t\\t\\tadjacent = 0;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 686521,
                "title": "python2-unionfind-to-merge-adjacent-flowers",
                "content": "\\n```\\nclass Solution(object):\\n    def minDays(self, bloomDay, m, k):\\n        def find(x):\\n            if group[x] != x:\\n                group[x] = find(group[x])\\n            return group[x]\\n        \\n        def union(x, y):\\n            rx = find(x)\\n            ry = find(y)\\n            \\n            group[rx] = ry\\n            groupSize[ry] += groupSize[rx]\\n            return ry\\n            \\n        cnt = len(bloomDay)\\n        groupSize = [1] * cnt\\n        group = range(cnt)\\n        bloomed = [False] * cnt\\n        \\n        \\n        for day, flower in sorted(map(lambda x: list(reversed(x)) , enumerate(bloomDay))):\\n            bloomed[flower] = True\\n            leftsize = rightsize = 0\\n            if flower > 0 and bloomed[flower - 1]:\\n                leftsize = groupSize[find(flower - 1)]\\n                union(flower, flower - 1)\\n            if flower < cnt - 1 and bloomed[flower + 1]:\\n                rightsize = groupSize[find(flower + 1)]\\n                union(flower, flower + 1)\\n            m -= (leftsize + 1 + rightsize) / k - leftsize / k - rightsize / k\\n            if m <= 0:\\n                return day\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minDays(self, bloomDay, m, k):\\n        def find(x):\\n            if group[x] != x:\\n                group[x] = find(group[x])\\n            return group[x]\\n        \\n        def union(x, y):\\n            rx = find(x)\\n            ry = find(y)\\n            \\n            group[rx] = ry\\n            groupSize[ry] += groupSize[rx]\\n            return ry\\n            \\n        cnt = len(bloomDay)\\n        groupSize = [1] * cnt\\n        group = range(cnt)\\n        bloomed = [False] * cnt\\n        \\n        \\n        for day, flower in sorted(map(lambda x: list(reversed(x)) , enumerate(bloomDay))):\\n            bloomed[flower] = True\\n            leftsize = rightsize = 0\\n            if flower > 0 and bloomed[flower - 1]:\\n                leftsize = groupSize[find(flower - 1)]\\n                union(flower, flower - 1)\\n            if flower < cnt - 1 and bloomed[flower + 1]:\\n                rightsize = groupSize[find(flower + 1)]\\n                union(flower, flower + 1)\\n            m -= (leftsize + 1 + rightsize) / k - leftsize / k - rightsize / k\\n            if m <= 0:\\n                return day\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691031,
                "title": "python3-binary-search-elif5-explained-like-i-m-5-years-old",
                "content": "```\\nclass Solution:\\n    \\n    def minDays(self, listOfFlowerBloomDays: List[int], targetNumberOfBouquets: int, flowersPerBouquet: int) -> int:\\n        \\n        def numberOfBouquetsWeCanMakeOnThisDay(dayThatWeAreChecking):\\n            \\n            currentListOfAdjacentBloomedFlowers = []\\n            numberOfBouquetsWeCanMakeOnThisDay = 0\\n            \\n            for dayThatFlowerBlooms in listOfFlowerBloomDays:\\n                \\n                # check if the flower has bloomed on this day \\n                if dayThatFlowerBlooms <= dayThatWeAreChecking:\\n                    \\n                    # add to the list an adjacent bloomed flowers, I use \\'x\\' because the description uses an \\'x\\'\\n                    currentListOfAdjacentBloomedFlowers.append(\\'x\\')\\n                    \\n                else:\\n                    # we\\'ve hit a day where we don\\'t have a bloomed flower, so the list of adjacent bloomed flowers has to be reset\\n                    # BUT FIRST figure out how many bouquets we can make with this list of adjacent bloomed flowers\\n                    numberOfBouquetsWeCanMakeOnThisDay += len(currentListOfAdjacentBloomedFlowers)//flowersPerBouquet\\n                    \\n                    # RESET list of adjacent bloomed flowers cause we\\'re on a day where the a flower has not bloomed yet\\n                    currentListOfAdjacentBloomedFlowers = []\\n            \\n            # we\\'ve gone through the entire listOfFlowerBloomDays list and need to check if the \"residual\" current list \\n            # of adjacent bloomed flowers can make a bouquet ... so handle it here\\n            numberOfBouquetsWeCanMakeOnThisDay += len(currentListOfAdjacentBloomedFlowers)//flowersPerBouquet\\n                    \\n            return numberOfBouquetsWeCanMakeOnThisDay\\n        \\n        \\n        # if the TOTAL amount of flowers we need doesn\\'t match the number of possible flowers we can grow,\\n        # then the given inputs are impossible for making enough bouquets (we don\\'t have enough flowers)\\n        totalNumberOfFlowersNeeded = targetNumberOfBouquets*flowersPerBouquet\\n        numberOfFlowersWeCanGrow = len(listOfFlowerBloomDays)\\n        if numberOfFlowersWeCanGrow < totalNumberOfFlowersNeeded: \\n            return -1\\n        \\n        # no need to go past the day of the flower with the longest bloom date\\n        leftDay = 0\\n        rightDay = max(listOfFlowerBloomDays)\\n        \\n        while leftDay < rightDay:\\n            \\n            # currentDay is functioning as the \"mid\" of a binary search\\n            currentDay = leftDay + (rightDay-leftDay)//2\\n            \\n            # as in most binary searches, we check if the mid (which I\\'m calling \\'currentDay\\') satisfies the constraint\\n            # that is, if we can make the target amount of bouquets on this day\\n            if numberOfBouquetsWeCanMakeOnThisDay(currentDay) < targetNumberOfBouquets:\\n                \\n                # womp womp, we can\\'t make enough bouquets on this day, so set up for next iteration\\n                # the \"correct day\" is on the right side, so we get rid of all the \"incorrect days\" on the left side\\n                # by updating the left to the currentDay+1\\n                leftDay = currentDay+1\\n            else:\\n                \\n                # yay, we can make enough bouquets on this day, but we don\\'t know if this is the \"minimum day\"\\n                # we discard the right side to keep searching\\n                rightDay = currentDay\\n        \\n        # leftDay >= rightDay, so we\\'ve found the \"minimum day\"\\n        return leftDay\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def minDays(self, listOfFlowerBloomDays: List[int], targetNumberOfBouquets: int, flowersPerBouquet: int) -> int:\\n        \\n        def numberOfBouquetsWeCanMakeOnThisDay(dayThatWeAreChecking):\\n            \\n            currentListOfAdjacentBloomedFlowers = []\\n            numberOfBouquetsWeCanMakeOnThisDay = 0\\n            \\n            for dayThatFlowerBlooms in listOfFlowerBloomDays:\\n                \\n                # check if the flower has bloomed on this day \\n                if dayThatFlowerBlooms <= dayThatWeAreChecking:\\n                    \\n                    # add to the list an adjacent bloomed flowers, I use \\'x\\' because the description uses an \\'x\\'\\n                    currentListOfAdjacentBloomedFlowers.append(\\'x\\')\\n                    \\n                else:\\n                    # we\\'ve hit a day where we don\\'t have a bloomed flower, so the list of adjacent bloomed flowers has to be reset\\n                    # BUT FIRST figure out how many bouquets we can make with this list of adjacent bloomed flowers\\n                    numberOfBouquetsWeCanMakeOnThisDay += len(currentListOfAdjacentBloomedFlowers)//flowersPerBouquet\\n                    \\n                    # RESET list of adjacent bloomed flowers cause we\\'re on a day where the a flower has not bloomed yet\\n                    currentListOfAdjacentBloomedFlowers = []\\n            \\n            # we\\'ve gone through the entire listOfFlowerBloomDays list and need to check if the \"residual\" current list \\n            # of adjacent bloomed flowers can make a bouquet ... so handle it here\\n            numberOfBouquetsWeCanMakeOnThisDay += len(currentListOfAdjacentBloomedFlowers)//flowersPerBouquet\\n                    \\n            return numberOfBouquetsWeCanMakeOnThisDay\\n        \\n        \\n        # if the TOTAL amount of flowers we need doesn\\'t match the number of possible flowers we can grow,\\n        # then the given inputs are impossible for making enough bouquets (we don\\'t have enough flowers)\\n        totalNumberOfFlowersNeeded = targetNumberOfBouquets*flowersPerBouquet\\n        numberOfFlowersWeCanGrow = len(listOfFlowerBloomDays)\\n        if numberOfFlowersWeCanGrow < totalNumberOfFlowersNeeded: \\n            return -1\\n        \\n        # no need to go past the day of the flower with the longest bloom date\\n        leftDay = 0\\n        rightDay = max(listOfFlowerBloomDays)\\n        \\n        while leftDay < rightDay:\\n            \\n            # currentDay is functioning as the \"mid\" of a binary search\\n            currentDay = leftDay + (rightDay-leftDay)//2\\n            \\n            # as in most binary searches, we check if the mid (which I\\'m calling \\'currentDay\\') satisfies the constraint\\n            # that is, if we can make the target amount of bouquets on this day\\n            if numberOfBouquetsWeCanMakeOnThisDay(currentDay) < targetNumberOfBouquets:\\n                \\n                # womp womp, we can\\'t make enough bouquets on this day, so set up for next iteration\\n                # the \"correct day\" is on the right side, so we get rid of all the \"incorrect days\" on the left side\\n                # by updating the left to the currentDay+1\\n                leftDay = currentDay+1\\n            else:\\n                \\n                # yay, we can make enough bouquets on this day, but we don\\'t know if this is the \"minimum day\"\\n                # we discard the right side to keep searching\\n                rightDay = currentDay\\n        \\n        # leftDay >= rightDay, so we\\'ve found the \"minimum day\"\\n        return leftDay\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686234,
                "title": "c-nlog-max-bloom-day",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        const int N = bloomDay.size();\\n        if (m*k > N) return -1; //not enough flowers for the given requirement\\n        \\n        int low = 1, high = INT_MIN, ans = -1;\\n        for (const auto &n : bloomDay) high = max(high, n);\\n        \\n        while (low <= high) { //try possible bloom days in range [1, max(bloomDay..)]\\n            int mid = low + (high - low)/2; \\n            int cnt = 0, parts = 0; //cnt = continuous valid flowers for bouquets, parts = no. of such valid partitions \\n            for (int i = 0; i < N; ++i) {\\n                if (bloomDay[i] <= mid) cnt++;\\n                else cnt = 0;\\n                if (cnt == k) {\\n                    parts++;\\n                    cnt = 0;\\n                }\\n            }\\n            if (parts < m) {\\n                low = mid + 1;\\n            } else {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        const int N = bloomDay.size();\\n        if (m*k > N) return -1; //not enough flowers for the given requirement\\n        \\n        int low = 1, high = INT_MIN, ans = -1;\\n        for (const auto &n : bloomDay) high = max(high, n);\\n        \\n        while (low <= high) { //try possible bloom days in range [1, max(bloomDay..)]\\n            int mid = low + (high - low)/2; \\n            int cnt = 0, parts = 0; //cnt = continuous valid flowers for bouquets, parts = no. of such valid partitions \\n            for (int i = 0; i < N; ++i) {\\n                if (bloomDay[i] <= mid) cnt++;\\n                else cnt = 0;\\n                if (cnt == k) {\\n                    parts++;\\n                    cnt = 0;\\n                }\\n            }\\n            if (parts < m) {\\n                low = mid + 1;\\n            } else {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525107,
                "title": "why-we-are-applying-binary-search-here-explanation",
                "content": "On 1st day ,we are checking how many flowers are bloomed and then we will make bouquets of adjacent flowers.Again on 2nd day we are doing same.Again on 3rd day we are doing same.Means we are checking on every next day how many adjacent flowers are bloomed and then we will make bouquets. This will take O(n^2) time .Here our days range is increasing monotonically. We can opotimise it by applying the binary search on the answer itself. We will take range of days from 1 to 1e9 that is given in constraint.Then we will check on day \\'mid\\' how many flowers are bloomed and will make bouquets of adjacent flowers.If we cannot make bouquets equal to m that means we have to increase the day, so we will move to right of range and then again find it.If bouquets are greater than or equal to m then we will try to minimize the days and move toward the left of range.In this way, we can apply binary search .\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& v,int m,int k,int mid){\\n        int adj=0,bough=0;\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]>mid){\\n                adj=0;\\n            }\\n            else if(++adj>=k){\\n                bough++;\\n                adj=0;\\n            }\\n        }\\n        if(bough>=m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(m*k>bloomDay.size()) return -1;\\n        int low=1,high=1e9;\\n        int result=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isValid(bloomDay,m,k,mid)){\\n                result=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& v,int m,int k,int mid){\\n        int adj=0,bough=0;\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]>mid){\\n                adj=0;\\n            }\\n            else if(++adj>=k){\\n                bough++;\\n                adj=0;\\n            }\\n        }\\n        if(bough>=m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(m*k>bloomDay.size()) return -1;\\n        int low=1,high=1e9;\\n        int result=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isValid(bloomDay,m,k,mid)){\\n                result=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204477,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        int l=1,r=1000000000;\\n        int ans=-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            int c=0;\\n            int tt=0;\\n            for(int i=0;i<n;i++){\\n                if(bloomDay[i]<=mid)c++;\\n                else c=0;\\n                if(c==k){\\n                    tt++;\\n                    c=0;\\n                }\\n            }\\n            if(tt>=m){\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/cf05b327-df2f-401d-9ded-b4b1489870b5_1676786992.604219.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        int l=1,r=1000000000;\\n        int ans=-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            int c=0;\\n            int tt=0;\\n            for(int i=0;i<n;i++){\\n                if(bloomDay[i]<=mid)c++;\\n                else c=0;\\n                if(c==k){\\n                    tt++;\\n                    c=0;\\n                }\\n            }\\n            if(tt>=m){\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993479,
                "title": "super-easy-approach-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool check(vector<int>& bloomDay, int m, int k,int mid){\\n    int c=0;int total=0;\\n    for(int i=0;i<bloomDay.size();i++){\\n        if(bloomDay[i]<=mid){\\n            c++;\\n            if(c==k){\\n                total++;\\n                c=0;\\n            }\\n        }else c=0;\\n    }\\n    if(total>=m){\\n        return true;\\n    }return false;\\n}\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int st=0;int end=*max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=-1;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(check(bloomDay,m,k,mid)){\\n                ans=mid;\\n                end=mid-1;\\n            }else{\\n                st=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool check(vector<int>& bloomDay, int m, int k,int mid){\\n    int c=0;int total=0;\\n    for(int i=0;i<bloomDay.size();i++){\\n        if(bloomDay[i]<=mid){\\n            c++;\\n            if(c==k){\\n                total++;\\n                c=0;\\n            }\\n        }else c=0;\\n    }\\n    if(total>=m){\\n        return true;\\n    }return false;\\n}\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int st=0;int end=*max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=-1;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(check(bloomDay,m,k,mid)){\\n                ans=mid;\\n                end=mid-1;\\n            }else{\\n                st=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003760,
                "title": "python-very-beginner-s-bianary-search-solution",
                "content": "Here simply searching for our answer(min days) to want to make `m` bouquets for that we do **Binary Search**\\n\\n1. our ans must exist between the range 1 to `max(A)`\\n threfore we have` l = 1` and `r = max(A`)  left and right pointers\\n 2. then we calculate `mid = (l+r)//2` and check whethere it is feasible or not for our answer (`isFeasible` function do the job here), \\n\\t\\t if it is then we again search for minimum answer by moving right pointer by `r = mid - 1`\\n\\t\\t else we dont find the feasible answer so move our left pointer by `l = mid + 1`\\n\\t\\t we do it untill` l<=r` (while for reason)\\n3. so after end of the loop we simply  return` l` left pointer\\n\\n \\n```\\nclass Solution:\\n    def minDays(self, A: List[int], m: int, k: int) -> int:\\n        def isFeasible(x):\\n            aj_flw = count_flw =0\\n            \\n            for i in A:\\n                if x>=i:\\n                    aj_flw += 1\\n                else:\\n                    aj_flw = 0\\n                if aj_flw == k:\\n                    count_flw += 1 \\n                    aj_flw = 0\\n            return count_flw >=m\\n                    \\n        if len(A)<m*k: return -1 \\n        l,r = 1,max(A) \\n        \\n        while l<=r:\\n            mid = l+(r-l)//2 \\n            if isFeasible(mid):\\n                r = mid - 1 \\n            else:\\n                l = mid + 1\\n                 \\n        return l\\n                \\n```\\n\\nplz **upvote**  you if find atleast something from it",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, A: List[int], m: int, k: int) -> int:\\n        def isFeasible(x):\\n            aj_flw = count_flw =0\\n            \\n            for i in A:\\n                if x>=i:\\n                    aj_flw += 1\\n                else:\\n                    aj_flw = 0\\n                if aj_flw == k:\\n                    count_flw += 1 \\n                    aj_flw = 0\\n            return count_flw >=m\\n                    \\n        if len(A)<m*k: return -1 \\n        l,r = 1,max(A) \\n        \\n        while l<=r:\\n            mid = l+(r-l)//2 \\n            if isFeasible(mid):\\n                r = mid - 1 \\n            else:\\n                l = mid + 1\\n                 \\n        return l\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714075,
                "title": "simple-python-binary-search-similar-problem-listed",
                "content": "Please see my solutions for these similar problems.\\n\\nFor these problems, it\\'s relatively easy to solve the subproblem:\\ngiven a specific guess, determine whether it\\'s possible to xxx?\\nFurthermore, the range of guess is limited, and the boolean answer of the above subproblem has the pattern\\nF...FT...T or T...TF...F.\\nThus, we can use binary search to find the minimal/maximal value such that the boolean answer is True.\\n[378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/1004232/Python-solution-with-thinking-process)\\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/discuss/1714072/Simple-Python-Binary-Search-(similar-problem-listed))\\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/discuss/326747/Python-solutions-with-thinking-process)\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/390359/Simple-Python-Binary-Search)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/409956/Simple-Python-Binary-Search-(similar-problem-listed))\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/390523/Simple-Python-Binary-Search)\\n[774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/390526/Simple-Python-Binary-Search)\\n[1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/discuss/390530/Simple-Python-Binary-Search)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/1714075/Simple-Python-Binary-Search-(similar-problem-listed))\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2361972/Python-Binary-search-solution-(similar-problems-listed))\\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/discuss/1698346/Python-Binary-search-solution-(similar-problems-listed))\\n\\n```\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        def cannotMakeBouquets(guess, m, k):\\n            bouquets = 0\\n            prev_open = 0\\n            for d in bloomDay:\\n                if d <= guess:\\n                    prev_open += 1\\n                else:\\n                    bouquets += prev_open // k\\n                    prev_open = 0\\n            bouquets += prev_open // k\\n            return bouquets < m\\n        \\n        n = len(bloomDay)\\n        if n < m * k:\\n            return -1\\n        low, high = 1, max(bloomDay)\\n        while low < high:\\n            guess = low + (high - low) // 2\\n            if cannotMakeBouquets(guess, m, k):\\n                low = guess + 1\\n            else:\\n                high = guess\\n        return low\\n```",
                "solutionTags": [],
                "code": "```\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        def cannotMakeBouquets(guess, m, k):\\n            bouquets = 0\\n            prev_open = 0\\n            for d in bloomDay:\\n                if d <= guess:\\n                    prev_open += 1\\n                else:\\n                    bouquets += prev_open // k\\n                    prev_open = 0\\n            bouquets += prev_open // k\\n            return bouquets < m\\n        \\n        n = len(bloomDay)\\n        if n < m * k:\\n            return -1\\n        low, high = 1, max(bloomDay)\\n        while low < high:\\n            guess = low + (high - low) // 2\\n            if cannotMakeBouquets(guess, m, k):\\n                low = guess + 1\\n            else:\\n                high = guess\\n        return low\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3713813,
                "title": "python-3-binary-search-beats-95",
                "content": "```python3 []\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m * k: return -1\\n\\n        def isEnoughDays(days):\\n            flowers, bouquets = 0, 0\\n            for d in bloomDay:\\n                flowers = flowers + 1 if d <= days else 0\\n                if flowers == k:\\n                    bouquets += 1\\n                    if bouquets == m: break\\n                    flowers = 0\\n            \\n            return bouquets == m\\n\\n        l, r = 1, max(bloomDay)\\n        while l < r:\\n            days = l + (r-l)//2\\n            if isEnoughDays(days):\\n                r = days\\n            else:\\n                l = days + 1\\n        \\n        return l\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m * k: return -1\\n\\n        def isEnoughDays(days):\\n            flowers, bouquets = 0, 0\\n            for d in bloomDay:\\n                flowers = flowers + 1 if d <= days else 0\\n                if flowers == k:\\n                    bouquets += 1\\n                    if bouquets == m: break\\n                    flowers = 0\\n            \\n            return bouquets == m\\n\\n        l, r = 1, max(bloomDay)\\n        while l < r:\\n            days = l + (r-l)//2\\n            if isEnoughDays(days):\\n                r = days\\n            else:\\n                l = days + 1\\n        \\n        return l\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740154,
                "title": "javascript-binary-search",
                "content": "This binary search solution is based on Zhijun Liao\\'s fantastic post on binary searches:\\nhttps://leetcode.com/discuss/study-guide/786126/python-powerful-ultimate-binary-search-template-solved-many-problems/1087827\\n\\nIf you find any improvements or corrections please comment below!\\n\\nT: O (N * logM) Where M is the greatest value in BloomDay and N is the length of BloomDay\\nS: O (1)\\n\\n```\\nvar minDays = function(bloomDay, m, k) {\\n    // Must have bloomDay.length >= (m * k) in order for bouquets to be at all possible\\n    if (bloomDay.length < m * k) return - 1;\\n    \\n    // Helper function returns boolean indicating whether m bouquets can be made after \"days\" days.\\n    const canMake = days => {  // Helper: T: O(N) (length of bloomDay)\\n        let numBouquets = 0; // tracks bouquets made\\n        let prevFlower = 0; // tracks start of current bouquet\\n        \\n        for (let i = 0; i < bloomDay.length; i++) {\\n            if (bloomDay[i] > days) { // can\\'t use current flower\\n                prevFlower = i + 1; // reset start of current bouquet\\n            } else { // flower is in bloom and is usable\\n                if (i - prevFlower + 1 == k) { \\n                    numBouquets++;\\n                    prevFlower = i + 1;\\n                }\\n            }\\n        }\\n        return numBouquets >= m;\\n    }\\n    \\n    // Find min acceptable days to wait. // T: O(logM) (M is greatest val in bloomDay)\\n    let l = 0;\\n    let r = Math.max(...bloomDay);\\n    while (l < r) {\\n        let mid = l + Math.floor((r - l) / 2);\\n        if (canMake (mid)) r = mid;\\n        else l = mid + 1;\\n    }\\n    return l;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minDays = function(bloomDay, m, k) {\\n    // Must have bloomDay.length >= (m * k) in order for bouquets to be at all possible\\n    if (bloomDay.length < m * k) return - 1;\\n    \\n    // Helper function returns boolean indicating whether m bouquets can be made after \"days\" days.\\n    const canMake = days => {  // Helper: T: O(N) (length of bloomDay)\\n        let numBouquets = 0; // tracks bouquets made\\n        let prevFlower = 0; // tracks start of current bouquet\\n        \\n        for (let i = 0; i < bloomDay.length; i++) {\\n            if (bloomDay[i] > days) { // can\\'t use current flower\\n                prevFlower = i + 1; // reset start of current bouquet\\n            } else { // flower is in bloom and is usable\\n                if (i - prevFlower + 1 == k) { \\n                    numBouquets++;\\n                    prevFlower = i + 1;\\n                }\\n            }\\n        }\\n        return numBouquets >= m;\\n    }\\n    \\n    // Find min acceptable days to wait. // T: O(logM) (M is greatest val in bloomDay)\\n    let l = 0;\\n    let r = Math.max(...bloomDay);\\n    while (l < r) {\\n        let mid = l + Math.floor((r - l) / 2);\\n        if (canMake (mid)) r = mid;\\n        else l = mid + 1;\\n    }\\n    return l;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1200608,
                "title": "easy-binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& a, int m, int k) {\\n        int n=a.size();\\n        if(n<m*k)return -1;\\n        \\n        int left=*min_element(a.begin(),a.end());\\n        int right=*max_element(a.begin(),a.end());\\n        \\n        while(left<right)\\n        {\\n            int c=0,bouquet=0;\\n\\n            int mid=(left+right)/2;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(a[i]<=mid)c++;\\n                else c=0;\\n                \\n                if(c==k)\\n                {\\n                    bouquet++;\\n                    c=0;\\n                }\\n            }\\n            \\n            if(bouquet<m)left=mid+1;\\n            else right=mid;\\n        }\\n        \\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& a, int m, int k) {\\n        int n=a.size();\\n        if(n<m*k)return -1;\\n        \\n        int left=*min_element(a.begin(),a.end());\\n        int right=*max_element(a.begin(),a.end());\\n        \\n        while(left<right)\\n        {\\n            int c=0,bouquet=0;\\n\\n            int mid=(left+right)/2;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(a[i]<=mid)c++;\\n                else c=0;\\n                \\n                if(c==k)\\n                {\\n                    bouquet++;\\n                    c=0;\\n                }\\n            }\\n            \\n            if(bouquet<m)left=mid+1;\\n            else right=mid;\\n        }\\n        \\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693984,
                "title": "c-binary-search-similar-to-painter-s-partition-problem-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/submissions/\\n    \\n    We can use binary search here on the search space of days req to make req. bouquets.\\n    We check for a given days, is it possible to make the bouquets, if yes then search for \\n    an even smaller time duration(days) else make the duration more.\\n    \\n    \\n    TC: O(nlog(INT_MAX))\\n*/\\n\\nclass Solution {\\npublic:\\n    // Whether it is possible required bouquets with given max time\\n    bool bouquetPossible(vector<int>& bloom_days, int bloom_day, int m, int k) {\\n        int bouquets = 0, flowers = 0;\\n        for(const int& day: bloom_days) {\\n            if(day <= bloom_day)\\n                ++flowers;\\n            else\\n                flowers = 0;\\n            if(flowers == k)\\n                ++bouquets, flowers = 0;\\n        }\\n        \\n        return bouquets >= m;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        // No. of flowers req more than available\\n        if(m * k > bloomDay.size())\\n            return -1;\\n        \\n        int low = 0, high = INT_MAX;\\n        while(low < high) {\\n            // Candidate bloom date for making req bouquets\\n            int bloom_day = low + (high - low) / 2;\\n            if(bouquetPossible(bloomDay, bloom_day, m, k))\\n                high = bloom_day;\\n            else\\n                low = bloom_day + 1;\\n        }\\n        \\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/submissions/\\n    \\n    We can use binary search here on the search space of days req to make req. bouquets.\\n    We check for a given days, is it possible to make the bouquets, if yes then search for \\n    an even smaller time duration(days) else make the duration more.\\n    \\n    \\n    TC: O(nlog(INT_MAX))\\n*/\\n\\nclass Solution {\\npublic:\\n    // Whether it is possible required bouquets with given max time\\n    bool bouquetPossible(vector<int>& bloom_days, int bloom_day, int m, int k) {\\n        int bouquets = 0, flowers = 0;\\n        for(const int& day: bloom_days) {\\n            if(day <= bloom_day)\\n                ++flowers;\\n            else\\n                flowers = 0;\\n            if(flowers == k)\\n                ++bouquets, flowers = 0;\\n        }\\n        \\n        return bouquets >= m;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        // No. of flowers req more than available\\n        if(m * k > bloomDay.size())\\n            return -1;\\n        \\n        int low = 0, high = INT_MAX;\\n        while(low < high) {\\n            // Candidate bloom date for making req bouquets\\n            int bloom_day = low + (high - low) / 2;\\n            if(bouquetPossible(bloomDay, bloom_day, m, k))\\n                high = bloom_day;\\n            else\\n                low = bloom_day + 1;\\n        }\\n        \\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882469,
                "title": "most-optimal-solution-with-explanation-using-binary-search",
                "content": "\\n\\n# Approach\\nThe solution uses binary search to find the minimum number of days needed to make m bouquets using k adjacent flowers from the garden. The key idea is to perform a binary search on the possible days within which the flowers can bloom, and then check whether it\\'s possible to make at least m bouquets using those bloomed flowers.\\n\\n- The possible function takes the list of bloom days, a specific day day, the required number of bouquets m, and the number of flowers needed for a bouquet k.\\n\\n- It iterates through the bloomDay list and counts how many flowers have bloomed within the day limit. When a flower\\'s bloom day is greater than day, it resets the cnt (count) and adds the count of complete bouquets that can be formed from the flowers that bloomed before this day.\\n\\n- After the loop, it calculates the total number of bouquets that can be formed using the remaining flowers.\\n\\n- The minDays function takes the bloomDay list, the required number of bouquets m, and the number of flowers needed for a bouquet k.\\n\\n- It calculates the val as the minimum number of flowers required to make m bouquets.\\n\\n- It finds the lowest and highest bloom days in the bloomDay list.\\n\\n- The binary search is performed within the range of bloom days from low to high. Inside the loop, it checks if it\\'s possible to make m bouquets with k flowers each, using flowers that bloom within the mid day. If possible, it updates high to mid-1, else it updates low to mid+1.\\n\\n- Finally, it returns the low value, which represents the minimum number of days needed to make m bouquets using k adjacent flowers.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(max-min))\\n\\n- Space complexity:\\nO(1)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool possible(vector<int>& nums, int day, int m, int k) {\\n        int cnt = 0, num = 0;\\n        for(int i = 0; i< nums.size(); i++) {\\n            if(nums[i] <= day) cnt++;\\n            else {\\n                num += cnt/k;\\n                cnt = 0;\\n            }\\n        }\\n        num += cnt/k;\\n        return num>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        long long val = m * 1ll * k * 1ll;\\n        if(val>n) return -1;\\n        int low = INT_MAX, high = INT_MIN;\\n        for(int i = 0; i< n; i++) {\\n            low = min(bloomDay[i], low);\\n            high = max(bloomDay[i], high);\\n        }\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(possible(bloomDay, mid, m, k)) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        n = len(bloomDay)\\n        val = m * k\\n        if val > n:\\n            return -1\\n        \\n        low = float(\\'inf\\')\\n        high = float(\\'-inf\\')\\n        for day in bloomDay:\\n            low = min(day, low)\\n            high = max(day, high)\\n        \\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            if self.possible(bloomDay, mid, m, k):\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n        \\n        return low\\n    \\n    def possible(self, bloomDay, day, m, k):\\n        cnt = 0\\n        num = 0\\n        for bd in bloomDay:\\n            if bd <= day:\\n                cnt += 1\\n            else:\\n                num += cnt // k\\n                cnt = 0\\n        num += cnt // k\\n        return num >= m\\n\\n```\\n```JAVA []\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        long val = (long) m * k;\\n        if (val > n) return -1;\\n        \\n        int low = Integer.MAX_VALUE, high = Integer.MIN_VALUE;\\n        for (int day : bloomDay) {\\n            low = Math.min(day, low);\\n            high = Math.max(day, high);\\n        }\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (possible(bloomDay, mid, m, k)) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return low;\\n    }\\n    \\n    private boolean possible(int[] bloomDay, int day, int m, int k) {\\n        int cnt = 0, num = 0;\\n        for (int i = 0; i < bloomDay.length; i++) {\\n            if (bloomDay[i] <= day) {\\n                cnt++;\\n            } else {\\n                num += cnt / k;\\n                cnt = 0;\\n            }\\n        }\\n        num += cnt / k;\\n        return num >= m;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool possible(vector<int>& nums, int day, int m, int k) {\\n        int cnt = 0, num = 0;\\n        for(int i = 0; i< nums.size(); i++) {\\n            if(nums[i] <= day) cnt++;\\n            else {\\n                num += cnt/k;\\n                cnt = 0;\\n            }\\n        }\\n        num += cnt/k;\\n        return num>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        long long val = m * 1ll * k * 1ll;\\n        if(val>n) return -1;\\n        int low = INT_MAX, high = INT_MIN;\\n        for(int i = 0; i< n; i++) {\\n            low = min(bloomDay[i], low);\\n            high = max(bloomDay[i], high);\\n        }\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(possible(bloomDay, mid, m, k)) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        n = len(bloomDay)\\n        val = m * k\\n        if val > n:\\n            return -1\\n        \\n        low = float(\\'inf\\')\\n        high = float(\\'-inf\\')\\n        for day in bloomDay:\\n            low = min(day, low)\\n            high = max(day, high)\\n        \\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            if self.possible(bloomDay, mid, m, k):\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n        \\n        return low\\n    \\n    def possible(self, bloomDay, day, m, k):\\n        cnt = 0\\n        num = 0\\n        for bd in bloomDay:\\n            if bd <= day:\\n                cnt += 1\\n            else:\\n                num += cnt // k\\n                cnt = 0\\n        num += cnt // k\\n        return num >= m\\n\\n```\n```JAVA []\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        long val = (long) m * k;\\n        if (val > n) return -1;\\n        \\n        int low = Integer.MAX_VALUE, high = Integer.MIN_VALUE;\\n        for (int day : bloomDay) {\\n            low = Math.min(day, low);\\n            high = Math.max(day, high);\\n        }\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (possible(bloomDay, mid, m, k)) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return low;\\n    }\\n    \\n    private boolean possible(int[] bloomDay, int day, int m, int k) {\\n        int cnt = 0, num = 0;\\n        for (int i = 0; i < bloomDay.length; i++) {\\n            if (bloomDay[i] <= day) {\\n                cnt++;\\n            } else {\\n                num += cnt / k;\\n                cnt = 0;\\n            }\\n        }\\n        num += cnt / k;\\n        return num >= m;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751751,
                "title": "best-c-solution-list-of-8-similar-very-imp-binary-search-questions",
                "content": "# List of similar binary search questions \\n- [Find the Smallest Divisor Given a Threshold - Leetcode](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/solutions/3746201/best-c-solution-pure-binary-search-approach-beats-98-84/)\\n- [Koko Eating bananas - Leetcode](https://leetcode.com/problems/koko-eating-bananas/solutions/3750804/best-c-solution-list-of-7-similar-very-imp-binary-search-questions/)\\n- [Capacity To Ship Packages Within D Days - Leetcode](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/solutions/3751752/best-c-solution-list-of-similar-very-imp-binary-search-questions/)\\n- [Minimum Time to Repair Cars - Leetcode](https://leetcode.com/problems/minimum-time-to-repair-cars/solutions/3753730/best-c-solution-list-of-8-similar-very-imp-binary-search-questions/)\\n- [Minimized Maximum of Products Distributed to Any Store - Leetcode](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/solutions/3750918/best-c-solution-list-of-similar-very-imp-binary-search-questions/) \\n- [Book Allocation - Coding Ninjas](https://www.codingninjas.com/studio/problems/ayush-and-ninja-test_1097574?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=0)\\n- [Aggressive cows - Coding Ninjas](https://www.codingninjas.com/studio/problems/aggressive-cows_1082559?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=1)\\n- [Painter\\'s partition - Coding Ninjas](https://www.codingninjas.com/studio/problems/painter\\'s-partition-problem_1089557?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=0)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& A, int m, int k) {\\n        int n = A.size(), left = 1, right = 1e9;\\n        if ((long)m * (long)k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid)\\n                    flow = 0;\\n                else if (++flow >= k)\\n                    bouq++, flow = 0;\\n            }\\n            if (bouq < m)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& A, int m, int k) {\\n        int n = A.size(), left = 1, right = 1e9;\\n        if ((long)m * (long)k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid)\\n                    flow = 0;\\n                else if (++flow >= k)\\n                    bouq++, flow = 0;\\n            }\\n            if (bouq < m)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204253,
                "title": "4ms-c-binary-search-easy",
                "content": "\\n# Approach\\nThe Code is explained line by line wherever required\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool helper(long long int &mid,vector<int>& bloomDay, int &m, int &k){\\n        int n = bloomDay.size();\\n        int bouq = 0;\\n        int total=0;\\n        for(int i=0;i<n;i++){\\n            if(bloomDay[i] <= mid){ //mid is the particular time, if values below the time are less then mid then it means that the flower has bloomed because it is less than mid\\n            total++;\\n            }\\n            else{\\n                if(total >= k){ //if values in total are greater it means we can forma bouquet\\n                    bouq++;\\n                }\\n                total = 0; //we reset to form a new streak\\n            }\\n            if(total>=k) //if at any point this condn satisfy\\n            {\\n                bouq++;\\n                total = 0;\\n            }\\n        }\\n        if(total >=k) bouq++;\\n        return (bouq >=m);\\n    }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(bloomDay.size() < (long long)m*k) return -1; //garden has flowers less than required\\n        long long int left = 1;\\n        long long int right = *max_element(bloomDay.begin(), bloomDay.end());\\n        while(left<right){\\n            long long int mid = (left+right)/2;\\n            if(helper(mid,bloomDay,m,k)){\\n                right = mid;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool helper(long long int &mid,vector<int>& bloomDay, int &m, int &k){\\n        int n = bloomDay.size();\\n        int bouq = 0;\\n        int total=0;\\n        for(int i=0;i<n;i++){\\n            if(bloomDay[i] <= mid){ //mid is the particular time, if values below the time are less then mid then it means that the flower has bloomed because it is less than mid\\n            total++;\\n            }\\n            else{\\n                if(total >= k){ //if values in total are greater it means we can forma bouquet\\n                    bouq++;\\n                }\\n                total = 0; //we reset to form a new streak\\n            }\\n            if(total>=k) //if at any point this condn satisfy\\n            {\\n                bouq++;\\n                total = 0;\\n            }\\n        }\\n        if(total >=k) bouq++;\\n        return (bouq >=m);\\n    }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(bloomDay.size() < (long long)m*k) return -1; //garden has flowers less than required\\n        long long int left = 1;\\n        long long int right = *max_element(bloomDay.begin(), bloomDay.end());\\n        while(left<right){\\n            long long int mid = (left+right)/2;\\n            if(helper(mid,bloomDay,m,k)){\\n                right = mid;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529845,
                "title": "c-binary-search-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isFeasible(vector<int>& bloomDay,int mid,int k,int required){\\n        int n = bloomDay.size();\\n        \\n        int boquets = 0;\\n        int subArraySize = 0;\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t//if anywhere in between if we found any element that is greater than mid then\\n\\t\\t\\t//we cant use this subarray for creating a boquet within mid time\\n            if(bloomDay[i] > mid){\\n                subArraySize = 0;\\n            }\\n\\t\\t\\t//it means we have found k elements which are <= mid\\n\\t\\t\\t//and we can form a boquet with this subarray within mid time\\n            else if(++subArraySize == k){\\n                subArraySize = 0;\\n                boquets++;\\n            }\\n        }\\n        // cout<<endl;\\n        return boquets >= required;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        int total = 1ll * m * k;\\n        \\n        if(total > n) return -1;\\n        \\n        int low = 1;\\n        int high = *max_element(bloomDay.begin(),bloomDay.end());\\n        \\n        \\n        int res = 1e9;\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(isFeasible(bloomDay,mid,k,m)){\\n                res = min(res,mid);\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nDo upvote if you find it helpful :)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFeasible(vector<int>& bloomDay,int mid,int k,int required){\\n        int n = bloomDay.size();\\n        \\n        int boquets = 0;\\n        int subArraySize = 0;\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t//if anywhere in between if we found any element that is greater than mid then\\n\\t\\t\\t//we cant use this subarray for creating a boquet within mid time\\n            if(bloomDay[i] > mid){\\n                subArraySize = 0;\\n            }\\n\\t\\t\\t//it means we have found k elements which are <= mid\\n\\t\\t\\t//and we can form a boquet with this subarray within mid time\\n            else if(++subArraySize == k){\\n                subArraySize = 0;\\n                boquets++;\\n            }\\n        }\\n        // cout<<endl;\\n        return boquets >= required;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        int total = 1ll * m * k;\\n        \\n        if(total > n) return -1;\\n        \\n        int low = 1;\\n        int high = *max_element(bloomDay.begin(),bloomDay.end());\\n        \\n        \\n        int res = 1e9;\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(isFeasible(bloomDay,mid,k,m)){\\n                res = min(res,mid);\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2277318,
                "title": "don-t-understand-the-question-here-s-a-detailed-explanation-with-example-and-java-solution",
                "content": "1. bloomDay is an array of int values. Each value represents 1 flower. The value itself is the day this flower will bloom on. Heres an example, lets say bloomDay = {1,10,2}. That means there are 3 flowers that can bloom. The first flower will bloom on day 1, the second on day 10, and the third on day 2.\\n\\n2. \\'int m\\' is the number of bouquets that need to be made. \\'int k\\' is the number of flowers required to make a bouquet. For example if m = 4 and k = 2; then that means we will need to make 4 bouquets that each have 2 flowers in them. That also means the length of the array bloomDay must be 8 or greater since you won\\'t be able to make 4 bouquets with 7 or less flowers.\\n\\n3. You can only make bouquets with flowers that have bloomed and are adjacent to other bloomed flowers. For example, lets say \\n\\t* bloomDay = {1,10,2,9,3,8,4,7,5,6}\\n\\t* m = 4\\n\\t* k = 2\\n\\n* If it was day 8 then we could only make 3 bouquets due to adjacency. We can pick flowers 3,8,4,7,5,6. We can\\'t pick flowers 10 and 9 since they haven\\'t bloomed yet. We can\\'t pick flower 2 since flower 9 comes after it which prevents it from being adjacent to 3,8,4,7,5,6. We can\\'t pick flower 1 since 10 comes after. 3,8,4,7,5,6 contains 6 flowers which means we can make 3 bouquets since each bouquet requires 2 flowers.\\n\\n* If it was day 9 then we can make 4 bouquets and get the correct answer by picking flowers 2,9,3,8,4,7,5,6.\\n---------------------------\\nTo solve this problem, you need an algorithm that can get the number of bouquets on a specific day. Then you can place this algorithm inside a binary search and use the midpoint of the binary search as the day you want this algorithm to look at efficently. \\n\\n```\\nint length = bloomDay.length;\\nif (m * k > length)          return -1;      // Not enough flowers to make m bouquets.\\nint left = 1; \\nint right = 0;\\nfor (int bd : bloomDay)     right = Math.max(bd,right);  \\n\\n// Binary search\\nwhile(left<right)  {\\n\\tint mid = left+(right-left)/2;\\n\\tint adjacentFlower = 0;\\n\\tint bouqCount = 0;\\n\\t\\n\\t// Algorithm to get the number of bouquets on a specific day (mid).\\n\\tfor (int i = 0; i < length; i++) {\\n\\t\\tif (mid<bloomDay[i])    adjacentFlower = 0;\\n\\t\\telse if (++adjacentFlower == k)   {\\n\\t\\t\\tbouqCount++;\\n\\t\\t\\tadjacentFlower = 0;\\n\\t\\t}\\n\\t}\\n\\t// END of bouquet counting algorithm.\\n\\t\\n\\tif (bouqCount>=m)       right = mid;         \\n\\telse                    left = mid+1;\\n}\\nreturn left;\\n```\\n\\n\\t\\t\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nint length = bloomDay.length;\\nif (m * k > length)          return -1;      // Not enough flowers to make m bouquets.\\nint left = 1; \\nint right = 0;\\nfor (int bd : bloomDay)     right = Math.max(bd,right);  \\n\\n// Binary search\\nwhile(left<right)  {\\n\\tint mid = left+(right-left)/2;\\n\\tint adjacentFlower = 0;\\n\\tint bouqCount = 0;\\n\\t\\n\\t// Algorithm to get the number of bouquets on a specific day (mid).\\n\\tfor (int i = 0; i < length; i++) {\\n\\t\\tif (mid<bloomDay[i])    adjacentFlower = 0;\\n\\t\\telse if (++adjacentFlower == k)   {\\n\\t\\t\\tbouqCount++;\\n\\t\\t\\tadjacentFlower = 0;\\n\\t\\t}\\n\\t}\\n\\t// END of bouquet counting algorithm.\\n\\t\\n\\tif (bouqCount>=m)       right = mid;         \\n\\telse                    left = mid+1;\\n}\\nreturn left;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1981509,
                "title": "java-c-binary-search-clean",
                "content": "### Java\\n\\n```\\npublic int minDays(int[] bloomDay, int m, int k) {\\n        if (m * k > bloomDay.length)\\n            return -1;\\n\\n        int left = 1;\\n        int right = (int) 1e9;\\n\\n        while (left < right) {\\n            int middle = (right + left) / 2;\\n            if (makeBouquets(bloomDay, m, k, middle))\\n                right = middle;\\n            else\\n                left = middle + 1;\\n        }\\n\\n        return right;\\n    }\\n\\n    private boolean makeBouquets(int[] bloomDay, int bouquets, int inOneBouquet, int day) {\\n        int adjacentCount = 0;\\n\\n        for (int daysNeeded : bloomDay) {\\n            if (daysNeeded <= day) {\\n                if (++adjacentCount == inOneBouquet) {\\n                    adjacentCount = 0;\\n                    if (--bouquets == 0)\\n                        return true;\\n                }\\n            } else {\\n                adjacentCount = 0;\\n            }\\n        }\\n        return bouquets == 0;\\n    }\\n```\\n\\n\\n### C++\\n\\n```\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if (m * k > bloomDay.size())\\n            return -1;\\n\\n        int left = 1;\\n        int right = 1e9;\\n\\n        while (left < right) {\\n            int middle = (right + left) / 2;\\n            if (makeBouquets(bloomDay, m, k, middle))\\n                right = middle;\\n            else\\n                left = middle + 1;\\n        }\\n\\n        return right;\\n    }\\n    \\nprivate: bool makeBouquets(vector<int>& bloomDay, int bouquets, int inOneBouquet, int day) {\\n        int adjacentCount = 0;\\n\\n        for (int daysNeeded : bloomDay) {\\n            if (daysNeeded <= day) {\\n                if (++adjacentCount == inOneBouquet) {\\n                    adjacentCount = 0;\\n                    if (--bouquets == 0)\\n                        return true;\\n                }\\n            } else {\\n                adjacentCount = 0;\\n            }\\n        }\\n        return bouquets == 0;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\npublic int minDays(int[] bloomDay, int m, int k) {\\n        if (m * k > bloomDay.length)\\n            return -1;\\n\\n        int left = 1;\\n        int right = (int) 1e9;\\n\\n        while (left < right) {\\n            int middle = (right + left) / 2;\\n            if (makeBouquets(bloomDay, m, k, middle))\\n                right = middle;\\n            else\\n                left = middle + 1;\\n        }\\n\\n        return right;\\n    }\\n\\n    private boolean makeBouquets(int[] bloomDay, int bouquets, int inOneBouquet, int day) {\\n        int adjacentCount = 0;\\n\\n        for (int daysNeeded : bloomDay) {\\n            if (daysNeeded <= day) {\\n                if (++adjacentCount == inOneBouquet) {\\n                    adjacentCount = 0;\\n                    if (--bouquets == 0)\\n                        return true;\\n                }\\n            } else {\\n                adjacentCount = 0;\\n            }\\n        }\\n        return bouquets == 0;\\n    }\\n```\n```\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if (m * k > bloomDay.size())\\n            return -1;\\n\\n        int left = 1;\\n        int right = 1e9;\\n\\n        while (left < right) {\\n            int middle = (right + left) / 2;\\n            if (makeBouquets(bloomDay, m, k, middle))\\n                right = middle;\\n            else\\n                left = middle + 1;\\n        }\\n\\n        return right;\\n    }\\n    \\nprivate: bool makeBouquets(vector<int>& bloomDay, int bouquets, int inOneBouquet, int day) {\\n        int adjacentCount = 0;\\n\\n        for (int daysNeeded : bloomDay) {\\n            if (daysNeeded <= day) {\\n                if (++adjacentCount == inOneBouquet) {\\n                    adjacentCount = 0;\\n                    if (--bouquets == 0)\\n                        return true;\\n                }\\n            } else {\\n                adjacentCount = 0;\\n            }\\n        }\\n        return bouquets == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1475381,
                "title": "simple-c-solution-using-binary-search-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int> a, int m, int k, int mid)\\n    {\\n        int n=a.size();\\n        int bouq=0;\\n        int flow=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]<=mid)\\n                flow++;\\n            else \\n            {\\n                flow=0;\\n            }\\n            if(flow>=k)\\n            {\\n                bouq++;\\n                flow=0;\\n            }\\n        }\\n        if(bouq>=m)\\n            return true;\\n        else\\n            return false;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        if(n<k*m)\\n            return -1;\\n        int low=1;\\n        int high=1e9;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=low+((high-low)>>1);\\n            if(isValid(bloomDay,m,k,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\tPlease consider upvoting.",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int> a, int m, int k, int mid)\\n    {\\n        int n=a.size();\\n        int bouq=0;\\n        int flow=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]<=mid)\\n                flow++;\\n            else \\n            {\\n                flow=0;\\n            }\\n            if(flow>=k)\\n            {\\n                bouq++;\\n                flow=0;\\n            }\\n        }\\n        if(bouq>=m)\\n            return true;\\n        else\\n            return false;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        if(n<k*m)\\n            return -1;\\n        int low=1;\\n        int high=1e9;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=low+((high-low)>>1);\\n            if(isValid(bloomDay,m,k,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686312,
                "title": "c-binary-search-template-simulation-pruning-natural",
                "content": "**Idea:**\\nRemeber \\'first bad version\\'\\nhttps://leetcode.com/problems/first-bad-version/\\nIt\\'s similar idea with more overheads.\\nI used simulation to make things easier. It took me 56 mintures to come up with this solution in the weekly contest.\\n\\nIf you have any suggestion can help me speed up thinking, I will greatly appreciate. \\n\\n\\nversion 1: one-hour thinking solution in 43-lines:\\nDuring conest, my thinking is very fuzy and doing some brute-force searching for solution.  I smell the binary search pattern, then I was scared by the potential challenge from boutiquet task: k ajacent flower.\\nOne vital point I want to share is: \\nAs human, we think top-down. Please always begin with function calling, such as valid(), then write function to implement it. This is how we communicate with others and how we natually come up the solution.\\n\\n\\nTime complexity: O(NlogMaxDay); maxDay = 1e9;\\nSpace Complexity: O(N)\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {\\n        vector<int> v(b);\\n        const int n = v.size();\\n        if(m*k>n) return -1;\\n        sort(v.begin(), v.end());\\n        int minV = v[0], maxV = v[n-1];        \\n        int l = minV, r = maxV+1;        \\n        int hasSolution = 0;\\n        while(l<r){\\n            int mid = l + (r - l) / 2;\\n            bool possible = isValid(b, mid, m, k);            \\n            if(possible) {\\n                r = mid;\\n                hasSolution++; \\n            }else \\n                l = mid + 1;\\n        }\\n        return hasSolution > 0 ? l : -1;\\n    }\\n    \\nprivate:\\n    bool isValid(const vector<int>& b, int day, int bouquets, int k){        \\n        const int n = b.size();\\n        vector<int> flowers(n);\\n        int tot = 0;\\n        for(int i = 0; i < n; i++){\\n            flowers[i] = (b[i] <= day);        \\n            tot += flowers[i];\\n        }\\n        if(tot < bouquets * k) return false;\\n        for(int i = 0, cnt = 0; i < n; i++){            \\n            if(flowers[i] == 1){\\n                cnt++;\\n                if(cnt ==k) cnt = 0, bouquets--;\\n                if(bouquets == 0) return true;\\n            }\\n            else cnt=0;\\n        }\\n        return false;        \\n    }\\n};\\n```\\n\\n\\nversion 2: optmized version in post-contest in 24-lines\\nTime complexity: O(NlogMaxDay); maxDay = 1e9;\\nSpace Complexity: O(1)\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {      \\n        int maxDay = 1e9 + 1;\\n        int l = 1, r = maxDay; // [); left close right open rule                            \\n        while(l<r){\\n            int mid = l + (r - l) / 2;                \\n            if(isValid(b, mid, m, k)) r = mid;  // use isValid to decouple the question into 2 smalll subproblems then conquer them 1 by 1            \\n            else l = mid + 1;\\n        }\\n        return l < maxDay ? l  : -1;\\n    }\\n    \\nprivate:\\n    bool isValid(const vector<int>& b, int day, int bouquets, int k){                \\n        for(int i = 0, cnt = 0; i < b.size(); i++)\\n            if(b[i] <= day){\\n                cnt++;\\n                if(cnt ==k) cnt = 0, bouquets--;\\n                if(bouquets == 0) return true;\\n            }else cnt=0;        \\n        return false;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {\\n        vector<int> v(b);\\n        const int n = v.size();\\n        if(m*k>n) return -1;\\n        sort(v.begin(), v.end());\\n        int minV = v[0], maxV = v[n-1];        \\n        int l = minV, r = maxV+1;        \\n        int hasSolution = 0;\\n        while(l<r){\\n            int mid = l + (r - l) / 2;\\n            bool possible = isValid(b, mid, m, k);            \\n            if(possible) {\\n                r = mid;\\n                hasSolution++; \\n            }else \\n                l = mid + 1;\\n        }\\n        return hasSolution > 0 ? l : -1;\\n    }\\n    \\nprivate:\\n    bool isValid(const vector<int>& b, int day, int bouquets, int k){        \\n        const int n = b.size();\\n        vector<int> flowers(n);\\n        int tot = 0;\\n        for(int i = 0; i < n; i++){\\n            flowers[i] = (b[i] <= day);        \\n            tot += flowers[i];\\n        }\\n        if(tot < bouquets * k) return false;\\n        for(int i = 0, cnt = 0; i < n; i++){            \\n            if(flowers[i] == 1){\\n                cnt++;\\n                if(cnt ==k) cnt = 0, bouquets--;\\n                if(bouquets == 0) return true;\\n            }\\n            else cnt=0;\\n        }\\n        return false;        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {      \\n        int maxDay = 1e9 + 1;\\n        int l = 1, r = maxDay; // [); left close right open rule                            \\n        while(l<r){\\n            int mid = l + (r - l) / 2;                \\n            if(isValid(b, mid, m, k)) r = mid;  // use isValid to decouple the question into 2 smalll subproblems then conquer them 1 by 1            \\n            else l = mid + 1;\\n        }\\n        return l < maxDay ? l  : -1;\\n    }\\n    \\nprivate:\\n    bool isValid(const vector<int>& b, int day, int bouquets, int k){                \\n        for(int i = 0, cnt = 0; i < b.size(); i++)\\n            if(b[i] <= day){\\n                cnt++;\\n                if(cnt ==k) cnt = 0, bouquets--;\\n                if(bouquets == 0) return true;\\n            }else cnt=0;        \\n        return false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123111,
                "title": "beats-97-c-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if (bloomDay.size() < (long long) m * k) \\n            return -1;\\n\\n        int mn = INT_MAX, mx = INT_MIN;\\n        for (int i : bloomDay) {\\n            mx = max(mx, i);\\n            mn = min(mn, i);\\n        }\\n\\n        int l = mn; \\n        int r = mx;\\n\\n        // l, r bloom days (min, max)\\n        while (l < r) {\\n            int mid = (l + r) / 2;\\n            int possibleBookies = getPossibleBookies(bloomDay, mid, k);\\n\\n            // still not enough.  If wait more days, we will get more floor.  Now increase l (wait more)\\n            if (possibleBookies < m) \\n                l = mid + 1;\\n            else  // why not mid - 1?\\n                r = mid;\\n        }\\n\\n        return l;      \\n    }\\n\\n    int getPossibleBookies(vector<int>& bloomDay, int day, int k) {\\n        int bouquets = 0, flowersCollected = 0;\\n\\n        for (int value : bloomDay) {\\n            if (value <= day) {\\n                flowersCollected++;\\n            } \\n            else  // k adjacent flowers.  if value > day, it will bloom value days. now 0.\\n                flowersCollected = 0;\\n\\n            if (flowersCollected == k) {\\n                // collect all k adjacent flowers. Now collect another k adjacent flowers\\n                bouquets++;\\n                flowersCollected = 0;\\n            }\\n        }\\n        return bouquets;\\n    }\\n};\\n```\\n![leetcode.jpeg](https://assets.leetcode.com/users/images/de28b337-9647-4445-8cc4-9c437648a2b0_1675175214.8793533.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if (bloomDay.size() < (long long) m * k) \\n            return -1;\\n\\n        int mn = INT_MAX, mx = INT_MIN;\\n        for (int i : bloomDay) {\\n            mx = max(mx, i);\\n            mn = min(mn, i);\\n        }\\n\\n        int l = mn; \\n        int r = mx;\\n\\n        // l, r bloom days (min, max)\\n        while (l < r) {\\n            int mid = (l + r) / 2;\\n            int possibleBookies = getPossibleBookies(bloomDay, mid, k);\\n\\n            // still not enough.  If wait more days, we will get more floor.  Now increase l (wait more)\\n            if (possibleBookies < m) \\n                l = mid + 1;\\n            else  // why not mid - 1?\\n                r = mid;\\n        }\\n\\n        return l;      \\n    }\\n\\n    int getPossibleBookies(vector<int>& bloomDay, int day, int k) {\\n        int bouquets = 0, flowersCollected = 0;\\n\\n        for (int value : bloomDay) {\\n            if (value <= day) {\\n                flowersCollected++;\\n            } \\n            else  // k adjacent flowers.  if value > day, it will bloom value days. now 0.\\n                flowersCollected = 0;\\n\\n            if (flowersCollected == k) {\\n                // collect all k adjacent flowers. Now collect another k adjacent flowers\\n                bouquets++;\\n                flowersCollected = 0;\\n            }\\n        }\\n        return bouquets;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907251,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn+n)=O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        int s=INT_MAX,e=INT_MIN,ans=-1;\\n        for(int i=0;i<n;i++){\\n            s=min(s,bloomDay[i]);\\n            e=max(e,bloomDay[i]);\\n        }\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            int c=0,no=0;\\n            for(int i=0;i<n;i++){\\n                if(bloomDay[i]<=mid)\\n                    c++;\\n                else\\n                    c=0;\\n                if(c==k){\\n                    c=0;\\n                    no++;\\n                }\\n                if(no==m)\\n                    break;\\n            }\\n            if(no<m)\\n                s=mid+1;\\n            else{\\n                ans=mid;\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        int s=INT_MAX,e=INT_MIN,ans=-1;\\n        for(int i=0;i<n;i++){\\n            s=min(s,bloomDay[i]);\\n            e=max(e,bloomDay[i]);\\n        }\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            int c=0,no=0;\\n            for(int i=0;i<n;i++){\\n                if(bloomDay[i]<=mid)\\n                    c++;\\n                else\\n                    c=0;\\n                if(c==k){\\n                    c=0;\\n                    no++;\\n                }\\n                if(no==m)\\n                    break;\\n            }\\n            if(no<m)\\n                s=mid+1;\\n            else{\\n                ans=mid;\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754633,
                "title": "c-binary-search-easy-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    /* we want to check can we make m bouquets at a day of mid or not */\\n    bool check(vector<int> &arr, int mid, int m, int k){\\n        int subarray = 0;\\n        int total = 0;\\n        for(int i = 0;i<arr.size();i++){\\n            if(arr[i] <= mid){\\n                total++;\\n            }\\n            else{\\n                if(total == k){\\n                    subarray++;\\n                }\\n                total = 0;\\n            }\\n            if(total == k){\\n                subarray++;\\n                total = 0;\\n            }\\n        }\\n        if(subarray >= m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& arr, int m, int k) {\\n        /* if m*k < total no. of flows then we can\\'t make m bouquets */\\n        if(((long long)m*(long long)k) > arr.size()) return -1;\\n        \\n        /* maximum days we can take as maximum element in the array after that all flows will get bloom  */\\n        int l = 1, r = *max_element(arr.begin(), arr.end());\\n        int ans = -1;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(check(arr, mid, m, k)){\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n\\t/* If you like the solution please upvote */\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* we want to check can we make m bouquets at a day of mid or not */\\n    bool check(vector<int> &arr, int mid, int m, int k){\\n        int subarray = 0;\\n        int total = 0;\\n        for(int i = 0;i<arr.size();i++){\\n            if(arr[i] <= mid){\\n                total++;\\n            }\\n            else{\\n                if(total == k){\\n                    subarray++;\\n                }\\n                total = 0;\\n            }\\n            if(total == k){\\n                subarray++;\\n                total = 0;\\n            }\\n        }\\n        if(subarray >= m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& arr, int m, int k) {\\n        /* if m*k < total no. of flows then we can\\'t make m bouquets */\\n        if(((long long)m*(long long)k) > arr.size()) return -1;\\n        \\n        /* maximum days we can take as maximum element in the array after that all flows will get bloom  */\\n        int l = 1, r = *max_element(arr.begin(), arr.end());\\n        int ans = -1;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(check(arr, mid, m, k)){\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n\\t/* If you like the solution please upvote */\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233972,
                "title": "python-binsearch-and-strings-t-m-94-92",
                "content": "```\\nclass Solution:\\n\\n                                    # pretty much the standard bin-search solution,\\n                                    # but with a string-manipulation helper function \\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m*k: return -1\\n\\n        def f(day: int)->bool:\\n            s = \\'\\'.join([\\'X\\' if b <= day else \\' \\' for b in bloomDay])\\n            return s.count(\\'X\\'*k) >= m\\n\\n        left, right = min(bloomDay), max(bloomDay)\\n        while left < right:\\n            mid = (left + right)//2\\n            if f(mid): right = mid \\n            else: left = mid + 1\\n                \\n        return right",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n                                    # pretty much the standard bin-search solution,\\n                                    # but with a string-manipulation helper function \\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m*k: return -1\\n\\n        def f(day: int)->bool:\\n            s = \\'\\'.join([\\'X\\' if b <= day else \\' \\' for b in bloomDay])\\n            return s.count(\\'X\\'*k) >= m\\n\\n        left, right = min(bloomDay), max(bloomDay)\\n        while left < right:\\n            mid = (left + right)//2\\n            if f(mid): right = mid \\n            else: left = mid + 1\\n                \\n        return right",
                "codeTag": "Java"
            },
            {
                "id": 2227168,
                "title": "c-simple-binary-search-o-n-log-max-min",
                "content": "```\\nclass Solution {\\npublic:\\n    //time complexity O(n*log(max-min))\\n    bool isValid(vector<int>&v,int m,int k,int mid){\\n        int cnt = 0;\\n        int temp = 0;\\n        for(int i=0;i<v.size();++i){\\n            if(v[i] <= mid){\\n                temp++;\\n            }else{\\n                temp = 0;\\n            }\\n            if(temp == k){\\n                temp = 0;\\n                cnt++;\\n            }\\n        }\\n        return cnt >= m;\\n    }\\n    int minDays(vector<int>& v, int m, int k) {\\n        int l = *min_element(v.begin(),v.end());\\n        int h = *max_element(v.begin(),v.end());\\n        int res = -1;\\n        //search space can be reduced to min element to max element\\n        while(l<=h){\\n            int mid = l+(h-l)/2;\\n            if(isValid(v,m,k,mid)){\\n                res = mid;\\n                h = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //time complexity O(n*log(max-min))\\n    bool isValid(vector<int>&v,int m,int k,int mid){\\n        int cnt = 0;\\n        int temp = 0;\\n        for(int i=0;i<v.size();++i){\\n            if(v[i] <= mid){\\n                temp++;\\n            }else{\\n                temp = 0;\\n            }\\n            if(temp == k){\\n                temp = 0;\\n                cnt++;\\n            }\\n        }\\n        return cnt >= m;\\n    }\\n    int minDays(vector<int>& v, int m, int k) {\\n        int l = *min_element(v.begin(),v.end());\\n        int h = *max_element(v.begin(),v.end());\\n        int res = -1;\\n        //search space can be reduced to min element to max element\\n        while(l<=h){\\n            int mid = l+(h-l)/2;\\n            if(isValid(v,m,k,mid)){\\n                res = mid;\\n                h = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651427,
                "title": "binary-search",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length,l = 0, r = findmax(bloomDay); \\n        if ((m*k)>n) return -1;\\n        while (l < r) {\\n            int mid = l+(r - l) / 2, count = 0, total = 0;//count the flowers for each bouq,total is bouq number\\n            for (int i : bloomDay){\\n                if(i>mid) count = 0;\\n                else if (++count>= k) {\\n                        total++; \\n                        count = 0;\\n                    }\\n                \\n            }\\n                        \\n            if (total < m)  l = mid + 1; \\n            else  r = mid;\\n            \\n        }\\n        return l;\\n    }\\n        private int findmax(int[] A){\\n        int max=0;\\n        for (int i :A){\\n            if (i>max) max = i;\\n        }\\n        return max;\\n        }\\n    }       \\n            \\n            \\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length,l = 0, r = findmax(bloomDay); \\n        if ((m*k)>n) return -1;\\n        while (l < r) {\\n            int mid = l+(r - l) / 2, count = 0, total = 0;//count the flowers for each bouq,total is bouq number\\n            for (int i : bloomDay){\\n                if(i>mid) count = 0;\\n                else if (++count>= k) {\\n                        total++; \\n                        count = 0;\\n                    }\\n                \\n            }\\n                        \\n            if (total < m)  l = mid + 1; \\n            else  r = mid;\\n            \\n        }\\n        return l;\\n    }\\n        private int findmax(int[] A){\\n        int max=0;\\n        for (int i :A){\\n            if (i>max) max = i;\\n        }\\n        return max;\\n        }\\n    }       \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580760,
                "title": "read-this-if-you-don-t-understand-why-binary-search-is-used-here-javascript",
                "content": "We know that for any flower to bloom it would atleast take the min of bloomDay and at max it would take the max of bloomDay, so\\nour answer should definitely lie between the minimum of bloomDay and maximum of bloomDay.\\n\\nTo solve this problem we can actually break the problem into two: \\n1. We need to find if we can make m bouqets given any number of days for a given k.\\n2. Now to actually find out the minimum no of days, we can look for all the days iterating from minimum to maximum and then see if we can make m bouqets on any of these days, as soon as we find an answer we know that is the minimum no of days as we are iterating all the way from minimum to maximum no of days.\\n3. Now since we can find a range, for finding the minimum no of days we can optimize the loop for finding the potentialDay using binary search.\\n\\nSo the function for solving the 1st problem would look like below, which is same for both brute force and binary search:\\n\\n```\\nfunction canMakeMBouquets(bloomDay, potentialDay, m, k){\\n    let flowers = 0;\\n    let bouquets = 0;\\n    for(let day of bloomDay){\\n        if(day > potentialDay){\\n\\t\\t\\t// we are resetting flowers to 0 mainly because we can only include adjacent flowers and if this flower cannot be chosen any of them adjacent and before it cannot be used\\n            flowers = 0;\\n        }else{\\n            flowers++;\\n        }\\n        if(flowers === k){\\n            bouquets++;\\n            flowers = 0; // resetting flowers to 0 again since we already made one bouqet using the flowers\\n        }\\n    }\\n    return bouquets >= m;\\n}\\n```\\n\\nThe brute force solution for this problem would look like below:\\n```\\nvar minDays = function(bloomDay, m, k) {\\n    // brute force solution would be to iterate over all the days from min to max\\n    // and then see if we can make m bouqets\\n    if(bloomDay.length < m * k) return -1;\\n    let min = Infinity;\\n    let max = 0;\\n    for(let day of bloomDay){\\n        min = Math.min(min, day);\\n        max = Math.max(max, day);\\n    }\\n    for(let day=min; day <= max; day++){\\n        if(canMakeMBouquets(bloomDay, day, m, k)){\\n            return day;\\n        }\\n    }\\n    return -1;\\n};\\n```\\n\\nThe optimized solution for the problem would look like below:\\n\\n```\\nvar minDays = function(bloomDay, m, k) {\\n    // brute force solution would be to iterate over all the days from min to max\\n    // and then see if we can make m bouqets\\n    // so to optimize the solution we can instead do binary search on the potential day\\n    // instead of going over all the days\\n    if(bloomDay.length < m * k) return -1;\\n    let min = Infinity;\\n    let max = 0;\\n    for(let day of bloomDay){\\n        min = Math.min(min, day);\\n        max = Math.max(max, day);\\n    }\\n    let left = min, right = max;\\n    while(left < right){\\n        let mid = left + Math.floor((right - left) / 2);\\n        if(canMakeMBouquets(bloomDay, mid, m, k)){\\n            right = mid; // this can be a potential ans but we can further look for days lesser than this\\n        }else{\\n            left = mid + 1;\\n        }\\n    }\\n    return left; // either left or right would have the same value at the end.\\n};\\n```\\n\\nPlease upvote if it helps, this will encourage me to write more articles.",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nfunction canMakeMBouquets(bloomDay, potentialDay, m, k){\\n    let flowers = 0;\\n    let bouquets = 0;\\n    for(let day of bloomDay){\\n        if(day > potentialDay){\\n\\t\\t\\t// we are resetting flowers to 0 mainly because we can only include adjacent flowers and if this flower cannot be chosen any of them adjacent and before it cannot be used\\n            flowers = 0;\\n        }else{\\n            flowers++;\\n        }\\n        if(flowers === k){\\n            bouquets++;\\n            flowers = 0; // resetting flowers to 0 again since we already made one bouqet using the flowers\\n        }\\n    }\\n    return bouquets >= m;\\n}\\n```\n```\\nvar minDays = function(bloomDay, m, k) {\\n    // brute force solution would be to iterate over all the days from min to max\\n    // and then see if we can make m bouqets\\n    if(bloomDay.length < m * k) return -1;\\n    let min = Infinity;\\n    let max = 0;\\n    for(let day of bloomDay){\\n        min = Math.min(min, day);\\n        max = Math.max(max, day);\\n    }\\n    for(let day=min; day <= max; day++){\\n        if(canMakeMBouquets(bloomDay, day, m, k)){\\n            return day;\\n        }\\n    }\\n    return -1;\\n};\\n```\n```\\nvar minDays = function(bloomDay, m, k) {\\n    // brute force solution would be to iterate over all the days from min to max\\n    // and then see if we can make m bouqets\\n    // so to optimize the solution we can instead do binary search on the potential day\\n    // instead of going over all the days\\n    if(bloomDay.length < m * k) return -1;\\n    let min = Infinity;\\n    let max = 0;\\n    for(let day of bloomDay){\\n        min = Math.min(min, day);\\n        max = Math.max(max, day);\\n    }\\n    let left = min, right = max;\\n    while(left < right){\\n        let mid = left + Math.floor((right - left) / 2);\\n        if(canMakeMBouquets(bloomDay, mid, m, k)){\\n            right = mid; // this can be a potential ans but we can further look for days lesser than this\\n        }else{\\n            left = mid + 1;\\n        }\\n    }\\n    return left; // either left or right would have the same value at the end.\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1417360,
                "title": "very-simple-binary-search-solution",
                "content": "# Just use binary search on every possible day and check for every day.\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &arr, int m, int k, int mid) {\\n        int n = arr.size();\\n        int count=0;\\n        for(int i=0; i<n; i++) {\\n            if(mid>=arr[i]) count++;\\n            else count=0;\\n            if(count==k) {m--; count=0;}\\n            if(m==0) return true;\\n        }\\n        return false;\\n    }\\n    int minDays(vector<int>& arr, int m, int k) {\\n        int n = arr.size();\\n        int r=*max_element(arr.begin(), arr.end());\\n        if(m*k>n) return -1;\\n        int l=*min_element(arr.begin(), arr.end());\\n        int ans=-1;\\n        while(l<=r) {\\n            int mid = l + (r-l)/2;\\n            if(check(arr, m, k, mid)) {\\n                r=mid-1;\\n                ans=mid;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &arr, int m, int k, int mid) {\\n        int n = arr.size();\\n        int count=0;\\n        for(int i=0; i<n; i++) {\\n            if(mid>=arr[i]) count++;\\n            else count=0;\\n            if(count==k) {m--; count=0;}\\n            if(m==0) return true;\\n        }\\n        return false;\\n    }\\n    int minDays(vector<int>& arr, int m, int k) {\\n        int n = arr.size();\\n        int r=*max_element(arr.begin(), arr.end());\\n        if(m*k>n) return -1;\\n        int l=*min_element(arr.begin(), arr.end());\\n        int ans=-1;\\n        while(l<=r) {\\n            int mid = l + (r-l)/2;\\n            if(check(arr, m, k, mid)) {\\n                r=mid-1;\\n                ans=mid;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083921,
                "title": "binary-search-beats-95-c-with-full-explanation",
                "content": "this solution is on solved on binary search . techniques here is used is binary search on answer .. \\nHere we first consider no. of days to be answers..where smallest no. of day may be 1 and the max days possible is the max of the blooming days\\n... then we find mid .. and on bloom array we chk how many flowers bloom after #mid days,, checking continuity .. if we find continously bloom flowers we kept on increasing our counter ,, if we find any unbloom flower we added them to bouget complete as c/k (total adjacent flowers bloomed/ total adjacent flowers needed) \\nif bougets completed is greater than equal to m the we decrease r to mid -1 \\nelse  we increase l to mid +1\\n\\n\\nhope explanation is clear .. upvote it if uh like the solution\\n\\n// MY CODE ::\\n\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(m*k > bloomDay.size())\\n            return -1;\\n        int l=1,r=*max_element(bloomDay.begin(),bloomDay.end());\\n        while(l<=r){\\n            int md=l+(r-l)/2;\\n            int c=0,mcopy=0;\\n\\n            for(auto i:bloomDay){\\n                if(i<=md)\\n                   c++;\\n                else{\\n                    mcopy+=c/k;\\n                    // cout<<c<<\" \"<<mcopy<<\" \"<<i<<\" \"<<md<<endl;\\n                    c=0;\\n                }\\n            }``\\n            if(c>0){\\n                mcopy+=c/k;\\n            }\\n            if(mcopy>=m)\\n                r=md-1;\\n            else l=md+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(m*k > bloomDay.size())\\n            return -1;\\n        int l=1,r=*max_element(bloomDay.begin(),bloomDay.end());\\n        while(l<=r){\\n            int md=l+(r-l)/2;\\n            int c=0,mcopy=0;\\n\\n            for(auto i:bloomDay){\\n                if(i<=md)\\n                   c++;\\n                else{\\n                    mcopy+=c/k;\\n                    // cout<<c<<\" \"<<mcopy<<\" \"<<i<<\" \"<<md<<endl;\\n                    c=0;\\n                }\\n            }``\\n            if(c>0){\\n                mcopy+=c/k;\\n            }\\n            if(mcopy>=m)\\n                r=md-1;\\n            else l=md+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 819184,
                "title": "6-questions-in-one-template-of-binary-search-for-beginners-python",
                "content": "6 questions in one template of binary search - for beginners! - python\\n\\n**Method:**\\n1. left - inclusive; right - exclusive\\n2. use while left < right\\n3. if finding min value, define \\'isok\\' function (and return left) ; \\n4. if finding max value, define \\'isfail\\' function (and return left-1).\\n\\nIn Chinese:\\n\\n1. \\u5DE6\\u95ED\\u53F3\\u5F00\\uFF1B\\n2. \\u4F7F\\u7528left < right\\n3. binary search\\u662F\\u7528\\u6765\\u67E5\\u627E\\u6700\\u5C0F\\u503C\\u7684\\uFF0C\\u5982\\u679C\\u9898\\u76EE\\u662F\\u5BFB\\u627E\\u6700\\u5C0F\\u503C\\uFF0C\\u90A3\\u5C31\\u76F4\\u63A5\\u8FD4\\u56DEleft\\uFF1B\\n4. \\u5982\\u679C\\u9898\\u76EE\\u8981\\u6C42\\u7684\\u662F\\u6700\\u5927\\u503C\\uFF0C\\u90A3\\u5B9A\\u4E49\\u4E00\\u4E2Aisfail\\u51FD\\u6570\\uFF0C\\u5E76\\u627E\\u8BA9isfail\\u8FD4\\u56DEtrue\\u7684\\u6700\\u5C0F\\u7684left\\uFF0C\\u8FD9\\u6837\\u7684\\u8BDD\\uFF0Cleft-1\\u5C31\\u662F\\u6211\\u4EEC\\u8981\\u6C42\\u7684\\u6700\\u5927\\u7684\\u6EE1\\u8DB3\\u6761\\u4EF6\\u7684\\u503C\\u4E86\\u3002\\n\\n\\n**1011. Capacity To Ship Packages Within D Days**\\n\\nMedium\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\nShare\\nA conveyor belt has packages that must be shipped from one port to another within D days.\\n\\nThe i-th package on the conveyor belt has a weight of weights[i].  Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.\\n\\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.\\n\\nExample 1:\\n\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n\\'\\'\\'\\n\\n```\\n# # looking for a min value, then build a \\'isok\\' function and directly use binary search to \\n# find the min value \\'left\\' so that ok(left) returns True!\\nclass Solution_leetcode1011:\\n    def shipWithinDays(self, weights, D):\\n        # binary search\\n        # min weight capacity of the ship\\n        \\n        def isok(mid):\\n            # real days needed with max weight capacity of mid\\n            day = 1\\n            cursum = 0\\n            for weight in weights:\\n                if cursum + weight > mid:\\n                    day += 1\\n                    cursum = 0\\n                cursum += weight\\n            return day <= D\\n        \\n        left = max(weights) # note that this should be max(weights), not min(weights)!!\\n        right = sum(weights) + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isok(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n\\n\\n\\n**1231. Divide Chocolate**\\n\\nHard\\nhttps://leetcode.com/problems/divide-chocolate/\\n\\nYou have one chocolate bar that consists of some chunks. Each chunk has its own sweetness given by the array sweetness.\\n\\nYou want to share the chocolate with your K friends so you start cutting the chocolate bar into K+1 pieces using K cuts, each piece consists of some consecutive chunks.\\n\\nBeing generous, you will eat the piece with the minimum total sweetness and give the other pieces to your friends.\\n\\nFind the maximum total sweetness of the piece you can get by cutting the chocolate bar optimally.\\n\\nExample 1:\\n\\nInput: sweetness = [1,2,3,4,5,6,7,8,9], K = 5\\nOutput: 6\\nExplanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]\\n\\n```\\n# point: looking for max value, then build a \"fail\" function,\\n# and use binary search to find the min \\'left\\' that let fail(left) return True.\\n# then, left-1 is the max value to let fail(left-1) return False (i.e., not_fail(left-1) is true)!\\nclass Solution_Leetcode1231(object):\\n    def maximizeSweetness(self, sweetness, K):\\n        # binary search method is for looking for the MIN value! so, we find the min value (left) that fail\\n        # then left-1 is the max value that success!\\n        # look for max value, find the min value that fail, and then min.value - 1 is the result of success\\n        \\n        left = min(sweetness)\\n        right = sum(sweetness)+ 1\\n        \\n        def fail(mid):\\n            pieces = 0\\n            cursum = 0\\n            for sweet in sweetness:\\n                cursum += sweet\\n                if cursum >= mid:\\n                    # then current piece is ensure to be >= mid, we can start a new piece\\n                    pieces += 1\\n                    cursum = 0\\n            return pieces < K+1\\n        \\n        while left < right:\\n            mid = left+ (right-left)//2\\n            if fail(mid): # the result \\'left\\' is the min value that let fail(left)=True!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left - 1\\n```        \\n\\nhttps://leetcode.com/problems/split-array-largest-sum/\\n**410. Split Array Largest Sum**\\n\\nHard\\nGiven an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.\\n\\nWrite an algorithm to minimize the largest sum among these m subarrays.\\n\\nExample 1:\\n\\nInput: nums = [7,2,5,10,8], m = 2\\nOutput: 18\\nExplanation:\\nThere are four ways to split nums into two subarrays.\\nThe best way is to split it into [7,2,5] and [10,8],\\nwhere the largest sum among the two subarrays is only 18.\\n\\'\\'\\'\\n```\\n# looking for a min value, then build a \\'isok\\' function and directly use binary search,\\n# to find the min value \\'left\\' so that ok(left) returns True!\\nclass Solution_leetcode410(object):\\n    def splitArray(self, nums, m):\\n        # binary search\\n        # make a guess and then check how many subarrays x; if x > m, the guess is too big; else, the guess is too small\\n        left = max(nums)\\n        right = sum(nums) + 1\\n        \\n        def isok(mid): # or, you can change \\'isok\\' name into \\'is_mid_too_big\\'\\n            # all subarray\\'s sum <= mid\\n            setcount = 1\\n            cursum = 0\\n            for num in nums:\\n                if cursum + num> mid:\\n                    setcount += 1\\n                    cursum = 0\\n                cursum += num\\n            return setcount <= m # this is <=, not >=! which is very important!\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isok(mid): # is_mid_too_big, and we do not have enough subset when separating under mid, so we should make mid smaller!\\n                # or, think extremelly, if mid=2**31-1, then all numbers are in one subset, 1 <= m, so we should make mid smaller!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\nclass Solution_leetcode410_2(object):\\n    def splitArray(self, nums, m):\\n        # use binary search - it is finding the min value!\\n        # find the min sum value such that for the m sbusets of nums, sum of a subset <= x\\n        \\n        left = max(nums)\\n        right = sum(nums)\\n        \\n        def subsetnum(mid):\\n            setnum = 1\\n            cursum = 0\\n            for num in nums:\\n                if cursum + num > mid:  # \\u8F6C\\u6362\\u601D\\u60F3\\uFF1A\\u672C\\u6765\\u662F\\u7ED9\\u5B9Am\\u4E2A\\u5B50\\u96C6\\uFF0C\\u6C42\\u5F97\\u662F\\u5B50\\u96C6\\u548C\\u5F97\\u6700\\u5927\\u503C\\u3002\\n\\t\\t\\t\\t\\t# \\u6211\\u4EEC\\u53CD\\u8FC7\\u6765\\uFF0C\\u5148\\u6307\\u5B9A\\u5B50\\u96C6\\u7684\\u548C\\u7684\\u6700\\u5927\\u503C\\uFF0C\\u7136\\u540E\\u53BB\\u53CD\\u63A8\\u80FD\\u80FD\\u591F\\u5206\\u6210\\u591A\\u5C11\\u4E2A\\u5B50\\u96C6\\n                    # \\u5982\\u679C\\u5B50\\u96C6\\u7684\\u4E2A\\u6570>m\\uFF0C\\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5C0F\\u4E86\\n                    # \\u5982\\u679C\\u5B50\\u96C6\\u7684\\u4E2A\\u6570< m, \\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\n\\t\\t\\t\\t\\t# \\uFF08\\u8003\\u8651\\u731C\\u6D4B\\u4E3A\\u65E0\\u7A77\\u5927\\u7684\\u65F6\\u5019\\uFF0C\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u4E00\\u4E2Asubset\\u5C31\\u53EF\\u4EE5\\u4E86\\uFF09=\\u4E5F\\u5C31\\u662F\\u8BF4\\uFF0C\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u53D8\\u5C0F\\u5B83\\n                    setnum += 1\\n                    cursum = 0\\n                cursum += num\\n            return setnum\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if subsetnum(mid) <= m: # \\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\uFF01\\u6211\\u4EEC\\u9700\\u8981\\u51CF\\u5C0Fmid! \\u8FD9\\u4E00\\u70B9\\u975E\\u5E38\\u91CD\\u8981!\\n                # extremely, if we guess mid = 2**31-1, then subsetnum(mid) = 1 \\n\\t\\t\\t\\t# (all elements are in one subset), this means that our guessing is too big\\n                # we can make it smaller!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n\\'\\'\\'\\n\\n**1482. Minimum Number of Days to Make m Bouquets**\\n\\nhttps://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/\\nGiven an integer array bloomDay, an integer m and an integer k.\\n\\nWe need to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.\\n\\nThe garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.\\n\\nReturn the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.\\n\\'\\'\\'\\n```\\nclass Solution_Leetcode1482:\\n    def minDays(self, bloomdays, m, k):\\n        # binary search method, seek for the min day, \\n        # guess a day, -> check how many bouquets \\u82B1\\u675F\\n        \\n        left = min(bloomdays)\\n        right = max(bloomdays) + 1\\n        \\n        def isgood(mid):\\n            count = 0\\n            cursum = 0\\n            for aday in bloomdays:\\n                if aday > mid:\\n                    cursum = 0 # reset to 0\\n                else:\\n                    cursum += 1\\n                    if cursum == k:\\n                        count += 1\\n                        cursum = 0 # need to reset cursum here!\\n            return count >= m\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isgood(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left if left <= max(bloomdays) else -1\\n```\\n\\n\\n**875. Koko Eating Bananas**\\nhttps://leetcode.com/problems/koko-eating-bananas/\\n\\nKoko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours.\\n\\nKoko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won\\'t eat any more bananas during this hour.\\n\\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.\\n\\nReturn the minimum integer K such that she can eat all the bananas within H hours.\\n```\\n\\nclass Solution_leetcode875(object):\\n    def minEatingSpeed(self, piles, H):\\n        # still, change the problem, binary search,\\n        # guess the target value and compute how many banana koko can eat -> min speed\\n        left = 1\\n        right = max(piles) + 1\\n        \\n        def caneatall(mid): # isok(mid)\\n            # hours cost really should <=H\\n            hours = 0\\n            for pile in piles:\\n                hours += math.ceil(pile/float(mid)) \\n                # do not work if we use pile/mid!!! should change int into float!! this is very important!\\n            return hours <= H\\n        \\n        while left < right:\\n            mid = left + (right - left)//2\\n            if caneatall(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left # the min speed that satisfies caneatall(left)\\n```\\n\\n\\nGo back to finding max value again, using binary search!\\n\\n**1552. Magnetic Force Between Two Balls**\\nhttps://leetcode.com/problems/magnetic-force-between-two-balls/\\n\\nIn universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.\\n\\nRick stated that magnetic force between two different balls at positions x and y is |x - y|.\\n\\nGiven the integer array position and the integer m. Return the required force.\\n```\\nclass Solution_Leetcode1552:\\n    def maxDistance(self, position, m):\\n        n = len(position)\\n        position.sort()\\n        \\n        def isfail(mid):\\n            ans = 1\\n            curr = position[0] # alike greedy idea, we just put the first ball at position 0!\\n            for i in range(1, n):\\n                if position[i] - curr >= mid:\\n                    ans += 1\\n                    curr = position[i]\\n            return ans < m\\n        \\n        left = 0 # \\u6CE8\\u610F\\uFF0C\\u4E0D\\u5E94\\u8BE5\\u628Aleft\\u8D4B\\u503C\\u4E3Amin(position)! \\u56E0\\u4E3A\\u6211\\u4EEC\\u6C42\\u5F97\\u662Fdistance!\\n        # note that, left = min(position) is wrong, since we are looking for \\'distance\\'!\\n        right = max(position) - min(position) + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isfail(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left - 1 # left is the min value to fail, so left-1 is the max value to succeed!\\n        # \\u56E0\\u4E3A\\u6C42\\u7684\\u662F\\u6700\\u5927\\u503C\\uFF01\\u6240\\u4EE5\\u9700\\u8981\\u5DE7\\u5999\\u4F7F\\u7528binary search!\\n```",
                "solutionTags": [],
                "code": "```\\n# # looking for a min value, then build a \\'isok\\' function and directly use binary search to \\n# find the min value \\'left\\' so that ok(left) returns True!\\nclass Solution_leetcode1011:\\n    def shipWithinDays(self, weights, D):\\n        # binary search\\n        # min weight capacity of the ship\\n        \\n        def isok(mid):\\n            # real days needed with max weight capacity of mid\\n            day = 1\\n            cursum = 0\\n            for weight in weights:\\n                if cursum + weight > mid:\\n                    day += 1\\n                    cursum = 0\\n                cursum += weight\\n            return day <= D\\n        \\n        left = max(weights) # note that this should be max(weights), not min(weights)!!\\n        right = sum(weights) + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isok(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```\\n# point: looking for max value, then build a \"fail\" function,\\n# and use binary search to find the min \\'left\\' that let fail(left) return True.\\n# then, left-1 is the max value to let fail(left-1) return False (i.e., not_fail(left-1) is true)!\\nclass Solution_Leetcode1231(object):\\n    def maximizeSweetness(self, sweetness, K):\\n        # binary search method is for looking for the MIN value! so, we find the min value (left) that fail\\n        # then left-1 is the max value that success!\\n        # look for max value, find the min value that fail, and then min.value - 1 is the result of success\\n        \\n        left = min(sweetness)\\n        right = sum(sweetness)+ 1\\n        \\n        def fail(mid):\\n            pieces = 0\\n            cursum = 0\\n            for sweet in sweetness:\\n                cursum += sweet\\n                if cursum >= mid:\\n                    # then current piece is ensure to be >= mid, we can start a new piece\\n                    pieces += 1\\n                    cursum = 0\\n            return pieces < K+1\\n        \\n        while left < right:\\n            mid = left+ (right-left)//2\\n            if fail(mid): # the result \\'left\\' is the min value that let fail(left)=True!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left - 1\\n```\n```\\n# looking for a min value, then build a \\'isok\\' function and directly use binary search,\\n# to find the min value \\'left\\' so that ok(left) returns True!\\nclass Solution_leetcode410(object):\\n    def splitArray(self, nums, m):\\n        # binary search\\n        # make a guess and then check how many subarrays x; if x > m, the guess is too big; else, the guess is too small\\n        left = max(nums)\\n        right = sum(nums) + 1\\n        \\n        def isok(mid): # or, you can change \\'isok\\' name into \\'is_mid_too_big\\'\\n            # all subarray\\'s sum <= mid\\n            setcount = 1\\n            cursum = 0\\n            for num in nums:\\n                if cursum + num> mid:\\n                    setcount += 1\\n                    cursum = 0\\n                cursum += num\\n            return setcount <= m # this is <=, not >=! which is very important!\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isok(mid): # is_mid_too_big, and we do not have enough subset when separating under mid, so we should make mid smaller!\\n                # or, think extremelly, if mid=2**31-1, then all numbers are in one subset, 1 <= m, so we should make mid smaller!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\nclass Solution_leetcode410_2(object):\\n    def splitArray(self, nums, m):\\n        # use binary search - it is finding the min value!\\n        # find the min sum value such that for the m sbusets of nums, sum of a subset <= x\\n        \\n        left = max(nums)\\n        right = sum(nums)\\n        \\n        def subsetnum(mid):\\n            setnum = 1\\n            cursum = 0\\n            for num in nums:\\n                if cursum + num > mid:  # \\u8F6C\\u6362\\u601D\\u60F3\\uFF1A\\u672C\\u6765\\u662F\\u7ED9\\u5B9Am\\u4E2A\\u5B50\\u96C6\\uFF0C\\u6C42\\u5F97\\u662F\\u5B50\\u96C6\\u548C\\u5F97\\u6700\\u5927\\u503C\\u3002\\n\\t\\t\\t\\t\\t# \\u6211\\u4EEC\\u53CD\\u8FC7\\u6765\\uFF0C\\u5148\\u6307\\u5B9A\\u5B50\\u96C6\\u7684\\u548C\\u7684\\u6700\\u5927\\u503C\\uFF0C\\u7136\\u540E\\u53BB\\u53CD\\u63A8\\u80FD\\u80FD\\u591F\\u5206\\u6210\\u591A\\u5C11\\u4E2A\\u5B50\\u96C6\\n                    # \\u5982\\u679C\\u5B50\\u96C6\\u7684\\u4E2A\\u6570>m\\uFF0C\\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5C0F\\u4E86\\n                    # \\u5982\\u679C\\u5B50\\u96C6\\u7684\\u4E2A\\u6570< m, \\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\n\\t\\t\\t\\t\\t# \\uFF08\\u8003\\u8651\\u731C\\u6D4B\\u4E3A\\u65E0\\u7A77\\u5927\\u7684\\u65F6\\u5019\\uFF0C\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u4E00\\u4E2Asubset\\u5C31\\u53EF\\u4EE5\\u4E86\\uFF09=\\u4E5F\\u5C31\\u662F\\u8BF4\\uFF0C\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u53D8\\u5C0F\\u5B83\\n                    setnum += 1\\n                    cursum = 0\\n                cursum += num\\n            return setnum\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if subsetnum(mid) <= m: # \\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\uFF01\\u6211\\u4EEC\\u9700\\u8981\\u51CF\\u5C0Fmid! \\u8FD9\\u4E00\\u70B9\\u975E\\u5E38\\u91CD\\u8981!\\n                # extremely, if we guess mid = 2**31-1, then subsetnum(mid) = 1 \\n\\t\\t\\t\\t# (all elements are in one subset), this means that our guessing is too big\\n                # we can make it smaller!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```\\nclass Solution_Leetcode1482:\\n    def minDays(self, bloomdays, m, k):\\n        # binary search method, seek for the min day, \\n        # guess a day, -> check how many bouquets \\u82B1\\u675F\\n        \\n        left = min(bloomdays)\\n        right = max(bloomdays) + 1\\n        \\n        def isgood(mid):\\n            count = 0\\n            cursum = 0\\n            for aday in bloomdays:\\n                if aday > mid:\\n                    cursum = 0 # reset to 0\\n                else:\\n                    cursum += 1\\n                    if cursum == k:\\n                        count += 1\\n                        cursum = 0 # need to reset cursum here!\\n            return count >= m\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isgood(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left if left <= max(bloomdays) else -1\\n```\n```\\n\\nclass Solution_leetcode875(object):\\n    def minEatingSpeed(self, piles, H):\\n        # still, change the problem, binary search,\\n        # guess the target value and compute how many banana koko can eat -> min speed\\n        left = 1\\n        right = max(piles) + 1\\n        \\n        def caneatall(mid): # isok(mid)\\n            # hours cost really should <=H\\n            hours = 0\\n            for pile in piles:\\n                hours += math.ceil(pile/float(mid)) \\n                # do not work if we use pile/mid!!! should change int into float!! this is very important!\\n            return hours <= H\\n        \\n        while left < right:\\n            mid = left + (right - left)//2\\n            if caneatall(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left # the min speed that satisfies caneatall(left)\\n```\n```\\nclass Solution_Leetcode1552:\\n    def maxDistance(self, position, m):\\n        n = len(position)\\n        position.sort()\\n        \\n        def isfail(mid):\\n            ans = 1\\n            curr = position[0] # alike greedy idea, we just put the first ball at position 0!\\n            for i in range(1, n):\\n                if position[i] - curr >= mid:\\n                    ans += 1\\n                    curr = position[i]\\n            return ans < m\\n        \\n        left = 0 # \\u6CE8\\u610F\\uFF0C\\u4E0D\\u5E94\\u8BE5\\u628Aleft\\u8D4B\\u503C\\u4E3Amin(position)! \\u56E0\\u4E3A\\u6211\\u4EEC\\u6C42\\u5F97\\u662Fdistance!\\n        # note that, left = min(position) is wrong, since we are looking for \\'distance\\'!\\n        right = max(position) - min(position) + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isfail(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left - 1 # left is the min value to fail, so left-1 is the max value to succeed!\\n        # \\u56E0\\u4E3A\\u6C42\\u7684\\u662F\\u6700\\u5927\\u503C\\uFF01\\u6240\\u4EE5\\u9700\\u8981\\u5DE7\\u5999\\u4F7F\\u7528binary search!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707611,
                "title": "python-binary-search-mathematical-function-definition-75-speed",
                "content": "Here the checker function is a function of `day`(days passed) and returns the number of bouquets possible.\\n\\n`checker(day)` is an increasing function because the bouquets possible increase or stay the same with every passing day.\\nIf on a day `d` the checker returns `True`, it means that on day `d`, minimum `m` bouquets are possible to be made, so we need no check for `days > d` and hence `high=mid`\\nOtherwise, on a day `d` if the checker returns `False`, it means that for `days <= d`, the `bouquets count <m` hence, we need to check for days `d+1 onwards`, hence `low=d+1`\\n\\n**Time Complexity**: O(n logn)\\n```\\nclass Solution:\\n    def checker(self,arr, d, m, k) -> bool:\\n        \\'\\'\\'\\n        d -> days\\n        m -> bouquets\\n        k -> adjacent flowers\\n        \\n        return bool\\n        \\'\\'\\'\\n        arr = [10**9] + arr + [10**9] #appending array with maximum values\\n        idx = []\\n        for i in range(len(arr)):\\n            if arr[i] > d:\\n                idx.append(i)\\n        cnt = 0\\n        for i in range(len(idx)-1):\\n            # how many bouquet can we make out of an interval of valid flowers \\n            cnt += (idx[i+1] - idx[i] - 1) // k\\n        \\n        # return if count >= m\\n        return cnt >= m\\n\\n    def minDays(self, arr: List[int], m: int, k: int) -> int:\\n        if m*k > len(arr):\\n            return -1\\n        lo, hi = 1, max(arr)\\n        \\n        while(hi >= lo):\\n            mid = (hi+lo)//2\\n            if(self.checker(arr, mid, m, k) == True):\\n                hi = mid\\n            else:\\n                lo = mid+1\\n            if(hi == lo): break\\n    \\n        if self.checker(arr, lo, m, k):\\n            return lo\\n        else:\\n            return hi\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checker(self,arr, d, m, k) -> bool:\\n        \\'\\'\\'\\n        d -> days\\n        m -> bouquets\\n        k -> adjacent flowers\\n        \\n        return bool\\n        \\'\\'\\'\\n        arr = [10**9] + arr + [10**9] #appending array with maximum values\\n        idx = []\\n        for i in range(len(arr)):\\n            if arr[i] > d:\\n                idx.append(i)\\n        cnt = 0\\n        for i in range(len(idx)-1):\\n            # how many bouquet can we make out of an interval of valid flowers \\n            cnt += (idx[i+1] - idx[i] - 1) // k\\n        \\n        # return if count >= m\\n        return cnt >= m\\n\\n    def minDays(self, arr: List[int], m: int, k: int) -> int:\\n        if m*k > len(arr):\\n            return -1\\n        lo, hi = 1, max(arr)\\n        \\n        while(hi >= lo):\\n            mid = (hi+lo)//2\\n            if(self.checker(arr, mid, m, k) == True):\\n                hi = mid\\n            else:\\n                lo = mid+1\\n            if(hi == lo): break\\n    \\n        if self.checker(arr, lo, m, k):\\n            return lo\\n        else:\\n            return hi\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 686698,
                "title": "java-simple-binary-search",
                "content": "Similar with coco eat bnana and shipping  goods problems.\\nVery easy to think of binary search.\\nMake sure to use:\\n1,  early quit when k * m > n;\\n2,  int mid = l + (r - l) / 2 avoid Integer overflow\\n3,  corner case if (m == 0) return 0;\\n```\\nclass Solution {\\n    public int minDays(int[] bs, int m, int k) {\\n        if (m == 0) return 0;\\n        int n = bs.length, l = Integer.MAX_VALUE, r = Integer.MIN_VALUE;\\n        if (k * m > n) return -1;\\n        for (int i : bs) {\\n            l = Math.min(l, i);\\n            r = Math.max(r, i);\\n        }\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (canMake(bs, mid, k) >= m) r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int canMake(int[] bs, int mid, int k) {\\n        int res = 0;\\n        for (int cnt = 0, i = 0; i < bs.length; i++) {\\n            if (bs[i] <= mid) cnt++; \\n            else cnt = 0;\\n            if (cnt >= k) {\\n                res++;\\n                cnt = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bs, int m, int k) {\\n        if (m == 0) return 0;\\n        int n = bs.length, l = Integer.MAX_VALUE, r = Integer.MIN_VALUE;\\n        if (k * m > n) return -1;\\n        for (int i : bs) {\\n            l = Math.min(l, i);\\n            r = Math.max(r, i);\\n        }\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (canMake(bs, mid, k) >= m) r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int canMake(int[] bs, int mid, int k) {\\n        int res = 0;\\n        for (int cnt = 0, i = 0; i < bs.length; i++) {\\n            if (bs[i] <= mid) cnt++; \\n            else cnt = 0;\\n            if (cnt >= k) {\\n                res++;\\n                cnt = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686655,
                "title": "merge-interval-nlogn-easy-to-understand-not-a-binary-search",
                "content": "The idea is simple. Every time a flower is bloomed, it will connect the blooming flowers before and after it. Try to merge the blooming interval and keep track of how many available bonquets.\\n\\nPlease read the code for details.\\n\\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if m * k > len(bloomDay):\\n            return -1\\n        \\n        # an interval is a consecutive region of flowers\\n\\t\\t# intervals[i] means the other end of an interval, and one of its end is i.\\n\\t\\t# -1 means this is not the end of an interval.\\n        intervals = [-1] * len(bloomDay)\\n        \\n        ## sort the index based on blooming time\\n        bloom_order = sorted(enumerate(bloomDay), key=lambda x: x[1])\\n        ## number of available bonquets\\n        count = 0\\n        \\n        for i, timestamp in bloom_order:\\n            ## the change of #bonquets in this iteration\\n            delta_count = 0\\n            # the new interval generated by this bloom\\n            head = tail = i\\n            # extend the head\\n            if i > 0 and intervals[i-1] != -1:\\n                head = intervals[i-1]\\n                intervals[i-1] = -1\\n                # #bonquets from [head, i-1]\\n                delta_count -= (i - head) // k\\n            \\n            # extend the tail\\n            if i < len(bloomDay) - 1 and intervals[i+1] != -1:\\n                tail = intervals[i+1]\\n                intervals[i+1] = -1\\n                # #bonquets from [i+1, tail]\\n                delta_count -= (tail - i) // k\\n                \\n            # #bonquets from the new interval\\n            delta_count += (tail - head + 1) // k\\n            # update the interval array\\n            intervals[head] = tail\\n            intervals[tail] = head\\n            # update the available bonquets\\n            count += delta_count\\n            \\n            if count >= m:\\n                return timestamp\\n        return -1\\n            \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if m * k > len(bloomDay):\\n            return -1\\n        \\n        # an interval is a consecutive region of flowers\\n\\t\\t# intervals[i] means the other end of an interval, and one of its end is i.\\n\\t\\t# -1 means this is not the end of an interval.\\n        intervals = [-1] * len(bloomDay)\\n        \\n        ## sort the index based on blooming time\\n        bloom_order = sorted(enumerate(bloomDay), key=lambda x: x[1])\\n        ## number of available bonquets\\n        count = 0\\n        \\n        for i, timestamp in bloom_order:\\n            ## the change of #bonquets in this iteration\\n            delta_count = 0\\n            # the new interval generated by this bloom\\n            head = tail = i\\n            # extend the head\\n            if i > 0 and intervals[i-1] != -1:\\n                head = intervals[i-1]\\n                intervals[i-1] = -1\\n                # #bonquets from [head, i-1]\\n                delta_count -= (i - head) // k\\n            \\n            # extend the tail\\n            if i < len(bloomDay) - 1 and intervals[i+1] != -1:\\n                tail = intervals[i+1]\\n                intervals[i+1] = -1\\n                # #bonquets from [i+1, tail]\\n                delta_count -= (tail - i) // k\\n                \\n            # #bonquets from the new interval\\n            delta_count += (tail - head + 1) // k\\n            # update the interval array\\n            intervals[head] = tail\\n            intervals[tail] = head\\n            # update the available bonquets\\n            count += delta_count\\n            \\n            if count >= m:\\n                return timestamp\\n        return -1\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 686436,
                "title": "c-binary-search-with-brief-explanation",
                "content": "The max number of days we can wait is  = maximum value of days required to bloom flower in given input. \\nWhile minimum days = minimum value required to bloom flower. \\nOur task is to find the minimum number of days so that we have sufficient flowers to form required bouquets.\\n\\nSo, We do binary search from 0 to max to find the minimum number of days that gives sufficient m group of k consecutive flowers.\\n\\n```csharp\\npublic int MinDays(int[] bloomDay, int m, int k)\\n{\\n\\tint flowersRequired = m * k;\\n\\tint flowersAvailable = bloomDay.Length;\\n\\n\\tif (flowersAvailable < flowersRequired)\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tint min = int.MaxValue;\\n\\tint max = int.MinValue;\\n\\tforeach(var flower in bloomDay)\\n\\t{\\n\\t\\tmin = Math.Min(min, flower);\\n\\t\\tmax = Math.Max(max, flower);\\n\\t}\\n\\n\\tint low = min;\\n\\tint high = max;\\n\\n\\twhile (low < high)\\n\\t{\\n\\t\\tint mid = low + (high - low) / 2;\\n\\n\\t\\tint currentBlooomed = 0;\\n\\t\\tint bouquets = 0;\\n\\n\\t\\tforeach (var flower in bloomDay)\\n\\t\\t{\\n\\t\\t\\tif (flower <= mid)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentBlooomed++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentBlooomed = 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (currentBlooomed == k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentBlooomed = 0;\\n\\t\\t\\t\\tbouquets++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (bouquets >= m)\\n\\t\\t{\\n\\t\\t\\thigh = mid;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn low;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinDays(int[] bloomDay, int m, int k)\\n{\\n\\tint flowersRequired = m * k;\\n\\tint flowersAvailable = bloomDay.Length;\\n\\n\\tif (flowersAvailable < flowersRequired)\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tint min = int.MaxValue;\\n\\tint max = int.MinValue;\\n\\tforeach(var flower in bloomDay)\\n\\t{\\n\\t\\tmin = Math.Min(min, flower);\\n\\t\\tmax = Math.Max(max, flower);\\n\\t}\\n\\n\\tint low = min;\\n\\tint high = max;\\n\\n\\twhile (low < high)\\n\\t{\\n\\t\\tint mid = low + (high - low) / 2;\\n\\n\\t\\tint currentBlooomed = 0;\\n\\t\\tint bouquets = 0;\\n\\n\\t\\tforeach (var flower in bloomDay)\\n\\t\\t{\\n\\t\\t\\tif (flower <= mid)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentBlooomed++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentBlooomed = 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (currentBlooomed == k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentBlooomed = 0;\\n\\t\\t\\t\\tbouquets++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (bouquets >= m)\\n\\t\\t{\\n\\t\\t\\thigh = mid;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn low;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686388,
                "title": "python3-binary-search",
                "content": "(1428ms, 91.90%)\\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m*k: return -1 # edge case \\n        \\n        def fn(d):\\n            \"\"\"Return True if it is possible to make m bouquets on given day.\"\"\"\\n            mm, kk = m, k\\n            for x in bloomDay: \\n                kk = kk-1 if x <= d else k\\n                if not kk: mm, kk = mm-1, k\\n                if not mm: return True\\n            return False \\n        \\n        # \"first true\" binary search\\n        lo, hi = 0, max(bloomDay)\\n        while lo < hi:\\n            mid = lo + hi >> 1\\n            if fn(mid): hi = mid\\n            else: lo = mid + 1\\n        return lo  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m*k: return -1 # edge case \\n        \\n        def fn(d):\\n            \"\"\"Return True if it is possible to make m bouquets on given day.\"\"\"\\n            mm, kk = m, k\\n            for x in bloomDay: \\n                kk = kk-1 if x <= d else k\\n                if not kk: mm, kk = mm-1, k\\n                if not mm: return True\\n            return False \\n        \\n        # \"first true\" binary search\\n        lo, hi = 0, max(bloomDay)\\n        while lo < hi:\\n            mid = lo + hi >> 1\\n            if fn(mid): hi = mid\\n            else: lo = mid + 1\\n        return lo  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 686379,
                "title": "java-two-solutions-dp-binary-search-solutions",
                "content": "At first glance, I was determined that was a DP problem. So I wrote the following first solution. But to my surprise it was TLE at the last test case. \\n\\nThe time complexity is ```O(N^2)```. I personally think Leetcode should let this solution pass. The test cases seems too strict. I really spent quite some time on this problem during the contest.\\n\\n```\\n    int[][] memo;\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        memo = new int[n + 1][m + 1];\\n        int[] max = new int[n + 1];\\n        for (int i = 0; i <= n - k; i++) {\\n            for (int j = i; j < i + k; j++) {\\n                max[i] = Math.max(max[i], bloomDay[j]);\\n            }\\n        }\\n        return dp(bloomDay, m, k, 0, max);\\n    }\\n    \\n    private int dp(int[] A, int m, int k, int start, int[] max) {\\n        if (m == 0) return 0;\\n        if (memo[start][m] != 0) return memo[start][m];\\n        int n = A.length;\\n        if (n - start < m * k) {\\n            memo[start][m] = -1;\\n            return -1;\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        for (int i = start; i <= n - m * k; i++) {\\n            int c = max[i];\\n            res = Math.min(res, Math.max(c, dp(A, m - 1, k, i + k, max)));\\n        }\\n        memo[start][m] = res;\\n        return res;\\n    }\\n```\\n\\n\\nSo what\\'s better than ```O(N^2)``` ? Cloest one is ```O(NlogN)```. It took me a while to come up with using binary seach to find the answer. \\n\\n```\\n    public int minDays(int[] A, int m, int k) {\\n        // binary search answer\\n        int l = Integer.MAX_VALUE, r = 0;\\n        int n = A.length;\\n        if (n < m * k) return -1;\\n        for (int i = 0; i < A.length; i++) {\\n            l = Math.min(l, A[i]);\\n            r = Math.max(r, A[i]);\\n        }\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (helper(A, m, k, mid)) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    private boolean helper(int[] A, int m, int k, int t) {\\n        int n = A.length;\\n        for (int i = 0; i <= n - k; i++) {\\n            if (A[i] > t) continue;\\n            int c = i;\\n            while (c < i + k) {\\n                if (A[c] > t) break;\\n                c++;\\n            }\\n            if (c == i + k) m--;\\n            i = c - 1;\\n        }\\n        return m <= 0;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```O(N^2)```\n```\\n    int[][] memo;\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        memo = new int[n + 1][m + 1];\\n        int[] max = new int[n + 1];\\n        for (int i = 0; i <= n - k; i++) {\\n            for (int j = i; j < i + k; j++) {\\n                max[i] = Math.max(max[i], bloomDay[j]);\\n            }\\n        }\\n        return dp(bloomDay, m, k, 0, max);\\n    }\\n    \\n    private int dp(int[] A, int m, int k, int start, int[] max) {\\n        if (m == 0) return 0;\\n        if (memo[start][m] != 0) return memo[start][m];\\n        int n = A.length;\\n        if (n - start < m * k) {\\n            memo[start][m] = -1;\\n            return -1;\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        for (int i = start; i <= n - m * k; i++) {\\n            int c = max[i];\\n            res = Math.min(res, Math.max(c, dp(A, m - 1, k, i + k, max)));\\n        }\\n        memo[start][m] = res;\\n        return res;\\n    }\\n```\n```O(N^2)```\n```O(NlogN)```",
                "codeTag": "Unknown"
            },
            {
                "id": 686252,
                "title": "javascript-sort-union-find",
                "content": "```javascript\\nconst BLOOMED = \\'X\\';\\n/**\\n * @param {number[]} bloomDay\\n * @param {number} m\\n * @param {number} k\\n * @return {number}\\n */\\nvar minDays = function(bloomDay, m, k) {\\n    if ((m * k) > bloomDay.length) return -1;\\n    \\n    const unionFind = bloomDay.map((_, idx) => idx);\\n    const daysAndIndexes = bloomDay.map((day, idx) => ({ day, idx }));\\n    daysAndIndexes.sort((a,b) => a.day - b.day);\\n    \\n    \\n    if (k === 1) return daysAndIndexes[m - 1].day;\\n    \\n    const find = (x) => unionFind[x] = unionFind[x] === x ? x : find(unionFind[x]);\\n    const union = (x, y) => unionFind[find(x)] = find(y);\\n    \\n    const map = {};\\n    let totalBouquets = 0;\\n    for (let { day, idx } of daysAndIndexes) {\\n        bloomDay[idx] = BLOOMED;\\n        map[idx] = { numFlowers: 1, numBouquetsInGroup: 0 };\\n        \\n        let totalPrevBouquets = 0;\\n        for (let delta of [1, -1]) {\\n            if (bloomDay[idx + delta] === BLOOMED) {\\n                const root = find(idx + delta);\\n                union(root, idx);\\n                map[idx].numFlowers += map[root].numFlowers;\\n                totalPrevBouquets += map[root].numBouquetsInGroup;\\n            }\\n        }\\n        \\n        map[idx].numBouquetsInGroup = Math.floor(map[idx].numFlowers / k);\\n        if (map[idx].numBouquetsInGroup > totalPrevBouquets) totalBouquets++;\\n        \\n        if (totalBouquets === m) return day;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst BLOOMED = \\'X\\';\\n/**\\n * @param {number[]} bloomDay\\n * @param {number} m\\n * @param {number} k\\n * @return {number}\\n */\\nvar minDays = function(bloomDay, m, k) {\\n    if ((m * k) > bloomDay.length) return -1;\\n    \\n    const unionFind = bloomDay.map((_, idx) => idx);\\n    const daysAndIndexes = bloomDay.map((day, idx) => ({ day, idx }));\\n    daysAndIndexes.sort((a,b) => a.day - b.day);\\n    \\n    \\n    if (k === 1) return daysAndIndexes[m - 1].day;\\n    \\n    const find = (x) => unionFind[x] = unionFind[x] === x ? x : find(unionFind[x]);\\n    const union = (x, y) => unionFind[find(x)] = find(y);\\n    \\n    const map = {};\\n    let totalBouquets = 0;\\n    for (let { day, idx } of daysAndIndexes) {\\n        bloomDay[idx] = BLOOMED;\\n        map[idx] = { numFlowers: 1, numBouquetsInGroup: 0 };\\n        \\n        let totalPrevBouquets = 0;\\n        for (let delta of [1, -1]) {\\n            if (bloomDay[idx + delta] === BLOOMED) {\\n                const root = find(idx + delta);\\n                union(root, idx);\\n                map[idx].numFlowers += map[root].numFlowers;\\n                totalPrevBouquets += map[root].numBouquetsInGroup;\\n            }\\n        }\\n        \\n        map[idx].numBouquetsInGroup = Math.floor(map[idx].numFlowers / k);\\n        if (map[idx].numBouquetsInGroup > totalPrevBouquets) totalBouquets++;\\n        \\n        if (totalBouquets === m) return day;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3953250,
                "title": "java-binary-search-easy-to-untderstand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        long val=(long)m*k;\\n        if( val > bloomDay.length) return -1;\\n\\n        int low=Integer.MAX_VALUE;\\n        int high=Integer.MIN_VALUE;\\n\\n        for(int i=0;i<bloomDay.length;i++){\\n            low=Math.min(low,bloomDay[i]);\\n            high=Math.max(high,bloomDay[i]);\\n        }\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\n            if(possibleDays(bloomDay,m,k,mid)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n           \\n        }\\n        return low;\\n\\n\\n    }\\n\\n    public boolean possibleDays(int[] bloomDay, int m, int k,int mid){\\n        \\n        int totalBouquet=0;\\n        int window=0;\\n        for(int i=0;i<bloomDay.length;i++){\\n            if(bloomDay[i]<=mid){\\n                window++;\\n            }\\n            else{\\n                totalBouquet+=(window/k);\\n                window=0;\\n\\n            }\\n        }\\n\\n        totalBouquet+=(window/k);\\n        return totalBouquet>=m;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        long val=(long)m*k;\\n        if( val > bloomDay.length) return -1;\\n\\n        int low=Integer.MAX_VALUE;\\n        int high=Integer.MIN_VALUE;\\n\\n        for(int i=0;i<bloomDay.length;i++){\\n            low=Math.min(low,bloomDay[i]);\\n            high=Math.max(high,bloomDay[i]);\\n        }\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\n            if(possibleDays(bloomDay,m,k,mid)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n           \\n        }\\n        return low;\\n\\n\\n    }\\n\\n    public boolean possibleDays(int[] bloomDay, int m, int k,int mid){\\n        \\n        int totalBouquet=0;\\n        int window=0;\\n        for(int i=0;i<bloomDay.length;i++){\\n            if(bloomDay[i]<=mid){\\n                window++;\\n            }\\n            else{\\n                totalBouquet+=(window/k);\\n                window=0;\\n\\n            }\\n        }\\n\\n        totalBouquet+=(window/k);\\n        return totalBouquet>=m;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928859,
                "title": "c-interesting-approach-binary-search",
                "content": "\\n# Complexity\\n- Time complexity: O(N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\nbool canMake(vector<int>&v, int mid, int m, int k ){ \\n    long long bc=0, adcnt=0;\\n    for(int i=0; i<v.size(); i++){\\n        if(v[i]<=mid){\\n            adcnt++;\\n            if(adcnt==k){\\n                bc++;\\n                if(bc==m)return true;\\n                adcnt=0;\\n            }\\n        }\\n        else adcnt=0;\\n    } \\n    return false;\\n}\\n\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s = 1, e = *max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=-1;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(canMake(bloomDay, mid, m, k)){\\n                ans = mid;\\n                e = mid-1;\\n            }\\n            else s = mid+1;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nbool canMake(vector<int>&v, int mid, int m, int k ){ \\n    long long bc=0, adcnt=0;\\n    for(int i=0; i<v.size(); i++){\\n        if(v[i]<=mid){\\n            adcnt++;\\n            if(adcnt==k){\\n                bc++;\\n                if(bc==m)return true;\\n                adcnt=0;\\n            }\\n        }\\n        else adcnt=0;\\n    } \\n    return false;\\n}\\n\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s = 1, e = *max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=-1;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(canMake(bloomDay, mid, m, k)){\\n                ans = mid;\\n                e = mid-1;\\n            }\\n            else s = mid+1;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926687,
                "title": "c-easiest-approach-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int solve(int mid,vector<int>&bloomDay,int k){\\n       int ct=0;\\n       int n=bloomDay.size();\\n       int total=0;\\n       for(int i=0;i<n;i++){\\n           if(mid>=bloomDay[i]){\\n               ct++;\\n               if(ct==k){\\n                   total++;ct=0;\\n               }\\n           }else ct=0;\\n       }\\n\\n       return total;\\n\\n   }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        if(m>n/k)return -1;\\n\\n        int i=1,j=INT_MIN;\\n        for(int k=0;k<n;k++)j=max(j,bloomDay[k]);\\n        int mid;\\n        int ans=INT_MAX;\\n        while(i<=j){\\n            mid=i+(j-i)/2;\\n            if(solve(mid,bloomDay,k)>=m){\\n               ans=min(ans,mid);\\n               j=mid-1;\\n            }else i=mid+1;\\n        }\\n\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int solve(int mid,vector<int>&bloomDay,int k){\\n       int ct=0;\\n       int n=bloomDay.size();\\n       int total=0;\\n       for(int i=0;i<n;i++){\\n           if(mid>=bloomDay[i]){\\n               ct++;\\n               if(ct==k){\\n                   total++;ct=0;\\n               }\\n           }else ct=0;\\n       }\\n\\n       return total;\\n\\n   }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        if(m>n/k)return -1;\\n\\n        int i=1,j=INT_MIN;\\n        for(int k=0;k<n;k++)j=max(j,bloomDay[k]);\\n        int mid;\\n        int ans=INT_MAX;\\n        while(i<=j){\\n            mid=i+(j-i)/2;\\n            if(solve(mid,bloomDay,k)>=m){\\n               ans=min(ans,mid);\\n               j=mid-1;\\n            }else i=mid+1;\\n        }\\n\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924003,
                "title": "binary-search-easy-c-solution-best-optimal-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int flower(vector<int>& b, int day, int k) {\\n        int flow = 0;\\n        int count = 0;\\n        for (int i = 0; i < b.size(); i++) {\\n            if (b[i] <= day) {\\n                count++;\\n                if (count == k) {\\n                    flow++;\\n                    count = 0; // Reset count after reaching k consecutive flowers\\n                }\\n            } else {\\n                count = 0;\\n            }\\n        }\\n        return flow;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if (m > bloomDay.size() / k) return -1;\\n        int low = INT_MAX;\\n        int high = INT_MIN;\\n        for (auto i : bloomDay) {\\n            low = min(low, i);\\n            high = max(high, i);\\n        }\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2; // Avoid potential integer overflow\\n            if (flower(bloomDay, mid, k) >= m) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flower(vector<int>& b, int day, int k) {\\n        int flow = 0;\\n        int count = 0;\\n        for (int i = 0; i < b.size(); i++) {\\n            if (b[i] <= day) {\\n                count++;\\n                if (count == k) {\\n                    flow++;\\n                    count = 0; // Reset count after reaching k consecutive flowers\\n                }\\n            } else {\\n                count = 0;\\n            }\\n        }\\n        return flow;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if (m > bloomDay.size() / k) return -1;\\n        int low = INT_MAX;\\n        int high = INT_MIN;\\n        for (auto i : bloomDay) {\\n            low = min(low, i);\\n            high = max(high, i);\\n        }\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2; // Avoid potential integer overflow\\n            if (flower(bloomDay, mid, k) >= m) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804431,
                "title": "best-easy-c-solution-striver-based-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool check(vector<int>& bloomDay, int m, int k,int mid)\\n{\\n    int cnt=0;\\n    int no=0;//no of bouquets formes\\n    for(int i=0;i<bloomDay.size();i++)\\n    {\\n        if(bloomDay[i]<=mid)\\n        {\\n            cnt++;\\n        }\\n        else\\n        {\\n            no+=cnt/k;\\n            cnt=0;\\n        }\\n    }\\n    no+=cnt/k;\\n    return no>=m;\\n}\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        long long val=1LL*m*k;\\n        if(val>bloomDay.size())return -1;\\n        int mini=INT_MAX;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n               mini=min(mini,bloomDay[i]);\\n               maxi=max(maxi,bloomDay[i]);\\n        }\\n        int l=mini;\\n        int h=maxi;\\n        int ans=-1;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            if(check(bloomDay,m,k,mid))\\n           {\\n               ans=mid;\\n               h=mid-1;\\n           }\\n           else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool check(vector<int>& bloomDay, int m, int k,int mid)\\n{\\n    int cnt=0;\\n    int no=0;//no of bouquets formes\\n    for(int i=0;i<bloomDay.size();i++)\\n    {\\n        if(bloomDay[i]<=mid)\\n        {\\n            cnt++;\\n        }\\n        else\\n        {\\n            no+=cnt/k;\\n            cnt=0;\\n        }\\n    }\\n    no+=cnt/k;\\n    return no>=m;\\n}\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        long long val=1LL*m*k;\\n        if(val>bloomDay.size())return -1;\\n        int mini=INT_MAX;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n               mini=min(mini,bloomDay[i]);\\n               maxi=max(maxi,bloomDay[i]);\\n        }\\n        int l=mini;\\n        int h=maxi;\\n        int ans=-1;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            if(check(bloomDay,m,k,mid))\\n           {\\n               ans=mid;\\n               h=mid-1;\\n           }\\n           else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778738,
                "title": "striver-s-solution",
                "content": "# Complexity\\n- Time complexity : $$O(N$$ $$log(range))$$  , where range = maxEle - minEle + 1\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        if(1ll*m*k > 1ll*n) return -1;\\n\\n        int low = *min_element(begin(bloomDay),end(bloomDay));\\n        int high = *max_element(begin(bloomDay),end(bloomDay));\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            if(isPossible(bloomDay,mid,m,k)) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n\\n    bool isPossible(vector<int>& bloomDay, int mid, int m, int k) {\\n        int cnt=0 , curr=0;\\n        for(int i=0 ; i<bloomDay.size() ; i++) {\\n            if(mid >= bloomDay[i]) {\\n                curr++;\\n            }\\n            else {\\n                cnt += curr/k;\\n                curr = 0;\\n            }\\n        }\\n        cnt += curr/k;\\n        return cnt>=m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        if(1ll*m*k > 1ll*n) return -1;\\n\\n        int low = *min_element(begin(bloomDay),end(bloomDay));\\n        int high = *max_element(begin(bloomDay),end(bloomDay));\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            if(isPossible(bloomDay,mid,m,k)) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n\\n    bool isPossible(vector<int>& bloomDay, int mid, int m, int k) {\\n        int cnt=0 , curr=0;\\n        for(int i=0 ; i<bloomDay.size() ; i++) {\\n            if(mid >= bloomDay[i]) {\\n                curr++;\\n            }\\n            else {\\n                cnt += curr/k;\\n                curr = 0;\\n            }\\n        }\\n        cnt += curr/k;\\n        return cnt>=m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720429,
                "title": "binary-search-on-answer",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int mid, vector<int> &nums, int m, int k)\\n{\\n    int req = 0;\\n    int count = 0;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        if (nums[i] <= mid)\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            req += (count / k);\\n            count = 0;\\n        }\\n    }\\n    req += (count / k);\\n    return req >= m;\\n}\\n\\nint minDays(vector<int> &nums, int m, int k)\\n{\\n    int n = nums.size();\\n    // if (m * k > n)\\n    // {\\n    //     return -1;\\n    // }\\n\\n    int lb = 0;\\n    int ub = *max_element(nums.begin(), nums.end());\\n    int ans = -1;\\n\\n    while (lb <= ub)\\n    {\\n        int mid = lb + (ub - lb) / 2;\\n        if (isValid(mid, nums, m, k))\\n        {\\n            ans = mid;\\n            ub = mid - 1;\\n        }\\n        else\\n        {\\n            lb = mid + 1;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int mid, vector<int> &nums, int m, int k)\\n{\\n    int req = 0;\\n    int count = 0;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        if (nums[i] <= mid)\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            req += (count / k);\\n            count = 0;\\n        }\\n    }\\n    req += (count / k);\\n    return req >= m;\\n}\\n\\nint minDays(vector<int> &nums, int m, int k)\\n{\\n    int n = nums.size();\\n    // if (m * k > n)\\n    // {\\n    //     return -1;\\n    // }\\n\\n    int lb = 0;\\n    int ub = *max_element(nums.begin(), nums.end());\\n    int ans = -1;\\n\\n    while (lb <= ub)\\n    {\\n        int mid = lb + (ub - lb) / 2;\\n        if (isValid(mid, nums, m, k))\\n        {\\n            ans = mid;\\n            ub = mid - 1;\\n        }\\n        else\\n        {\\n            lb = mid + 1;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609843,
                "title": "binary-search-time-o-n-log-n-space-o-1",
                "content": "# Intuition\\nSince bloomDay[i] represents the day after flower will bloom. For example if bloomDay[i] = 2, the flower will be available after 2 days. Now we have to make bouquet of size \"k\", we need k adjacent flowers. From this we can conclude that we can form bouquet only in the range min(bloomDay) to max(bloomDay). Since we have low and high endpoints to form a bouquet, we can search through min and max bloomDay using binary Search. \\n\\n# Algorithm:\\nWhile minDay <= maxDay repeat:\\n\\nStep 1: Calculate midDay = (minDay + maxday) / 2 <br>\\nStep 2: For day in bloomDay:\\n    - If day <= midDay i.e. flower is available to form bouquet. If this is the first available flower then increment flower_count by 1 and adjacent to True. Else if already adjacent is True i.e. previous flower is also available then just increment count by 1\\n    -  Else if day > midDay i.e. flower is not ready yet we will reset the count to 0 and adjacent to False\\n    - After above calculation we will check if count is equal to \"k\" then it means we can form a bouquet, so increment bouquet_count and reset count and adjacent variables <br>\\nStep 3:  If bouquet_count >= m: i.e. we found a solution so we will store the min of previos solution and current one. and look for better solution in less days. So we will search through left half of current search space.\\nElse We didn\\'t found solution yet so we will search through right half of search space.\\n\\n# Complexity\\n- Time complexity:\\n- For Binary Search log(n) and in each iteration of binary search we iterate through given array so overall complexity becomes: \\nO(n * log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if m*k > len(bloomDay):\\n            return -1\\n\\n        min_value, max_value = min(bloomDay), max(bloomDay)\\n        answer = max_value\\n\\n        while min_value <= max_value:\\n            mid = (min_value + max_value) // 2\\n\\n            count, bouquets, adjacent = 0, 0, False\\n            for i in range(len(bloomDay)):\\n                if bloomDay[i] <= mid:\\n                    if count == 0:\\n                        adjacent = True\\n                        count += 1\\n                    elif adjacent:\\n                        count += 1\\n                else:\\n                    count = 0\\n                    adjacent = False\\n                \\n                if count == k:\\n                    bouquets += 1\\n                    count, adjacent = 0, False\\n                \\n            if bouquets >= m:\\n                answer = min(answer, mid)\\n                max_value = mid - 1\\n            else:\\n                min_value = mid + 1\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if m*k > len(bloomDay):\\n            return -1\\n\\n        min_value, max_value = min(bloomDay), max(bloomDay)\\n        answer = max_value\\n\\n        while min_value <= max_value:\\n            mid = (min_value + max_value) // 2\\n\\n            count, bouquets, adjacent = 0, 0, False\\n            for i in range(len(bloomDay)):\\n                if bloomDay[i] <= mid:\\n                    if count == 0:\\n                        adjacent = True\\n                        count += 1\\n                    elif adjacent:\\n                        count += 1\\n                else:\\n                    count = 0\\n                    adjacent = False\\n                \\n                if count == k:\\n                    bouquets += 1\\n                    count, adjacent = 0, False\\n                \\n            if bouquets >= m:\\n                answer = min(answer, mid)\\n                max_value = mid - 1\\n            else:\\n                min_value = mid + 1\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413961,
                "title": "beginner-friendly-binary-search-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n bool isPossible(vector<int>& bloomDay, int m, int k,int mid){\\n     int adjFlower=0,Bouquet=0,n=bloomDay.size();\\n     for(int i=0;i<n;i++){\\n         if(bloomDay[i]<=mid){\\n             adjFlower++;\\n             if(adjFlower==k){\\n                 Bouquet++;\\n                  if(Bouquet==m){\\n                      return true;\\n                  }\\n                  adjFlower=0;\\n             }\\n         }\\n         else {\\n             adjFlower=0;\\n            \\n         }\\n     }\\n     return false;\\n }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int start=0 ,sum=0,ans=-1,end=0;\\n        for( int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<start)\\n            start=bloomDay[i];\\n            if(bloomDay[i]>end)\\n            end=bloomDay[i];\\n        }\\n        \\n        int mid=start+(end-start)/2;\\n        while (start<=end){\\n            if(isPossible(bloomDay,m,k,mid)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else {\\n                start=mid+1;\\n            }\\n            mid=start+(end-start)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/ee704328-30ac-4589-9eb4-e9b46f5b8872_1681410421.5456107.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n bool isPossible(vector<int>& bloomDay, int m, int k,int mid){\\n     int adjFlower=0,Bouquet=0,n=bloomDay.size();\\n     for(int i=0;i<n;i++){\\n         if(bloomDay[i]<=mid){\\n             adjFlower++;\\n             if(adjFlower==k){\\n                 Bouquet++;\\n                  if(Bouquet==m){\\n                      return true;\\n                  }\\n                  adjFlower=0;\\n             }\\n         }\\n         else {\\n             adjFlower=0;\\n            \\n         }\\n     }\\n     return false;\\n }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int start=0 ,sum=0,ans=-1,end=0;\\n        for( int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<start)\\n            start=bloomDay[i];\\n            if(bloomDay[i]>end)\\n            end=bloomDay[i];\\n        }\\n        \\n        int mid=start+(end-start)/2;\\n        while (start<=end){\\n            if(isPossible(bloomDay,m,k,mid)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else {\\n                start=mid+1;\\n            }\\n            mid=start+(end-start)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303087,
                "title": "easy-binary-search-implementation-with-comments-logical-approach",
                "content": "**Youtube video for reference : https://www.youtube.com/watch?v=paYIrQKxE7I**\\n```\\nclass Solution\\n{\\npublic:\\n    int minDays(vector<int> &bloomDay, int m, int k)\\n    {\\n\\n        int n = bloomDay.size();\\n\\n        if ((m * k) > n)\\n        { // if there are no flowers which are required then we simply return -1\\n            return -1;\\n        }\\n\\n        int low = INT_MAX;\\n\\n        int high = INT_MIN;\\n\\n        for (auto d : bloomDay)\\n        {\\n\\n            low = min(low, d);\\n\\n            high = max(high, d);\\n        }\\n\\n        while (low < high)\\n        {\\n\\n            int mid = low + (high - low) / 2;\\n\\n            int cur = 0, adj = 0;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (bloomDay[i] > mid)\\n                    adj = 0; // check if the flower is bloomed or not\\n\\n                else\\n                {\\n                    adj++; // if the criteria for k is complete or not\\n\\n                    if (adj == k)\\n                    {\\n                        cur++;\\n                        adj = 0;\\n                    }\\n                }\\n                if (cur >= m)\\n                    break; // check if the curr is equal to m bouquet\\n            }\\n            if (cur < m)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE IF YOU LIKE THIS :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minDays(vector<int> &bloomDay, int m, int k)\\n    {\\n\\n        int n = bloomDay.size();\\n\\n        if ((m * k) > n)\\n        { // if there are no flowers which are required then we simply return -1\\n            return -1;\\n        }\\n\\n        int low = INT_MAX;\\n\\n        int high = INT_MIN;\\n\\n        for (auto d : bloomDay)\\n        {\\n\\n            low = min(low, d);\\n\\n            high = max(high, d);\\n        }\\n\\n        while (low < high)\\n        {\\n\\n            int mid = low + (high - low) / 2;\\n\\n            int cur = 0, adj = 0;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (bloomDay[i] > mid)\\n                    adj = 0; // check if the flower is bloomed or not\\n\\n                else\\n                {\\n                    adj++; // if the criteria for k is complete or not\\n\\n                    if (adj == k)\\n                    {\\n                        cur++;\\n                        adj = 0;\\n                    }\\n                }\\n                if (cur >= m)\\n                    break; // check if the curr is equal to m bouquet\\n            }\\n            if (cur < m)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293318,
                "title": "simple-binary-search-c-solution-easy-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n      // if(m * k > bloomDay.size()) return -1;\\n     int left = INT_MAX, right = INT_MIN,ans = -1;\\n     for(int i = 0; i < bloomDay.size(); i++){\\n       left = min(left, bloomDay[i]);\\n       right = max(right, bloomDay[i]);\\n     }\\n     cout << left << endl;\\n     cout << right << endl;\\n     while(left <= right){\\n       int mid = left + (right - left) / 2;\\n       int flowers = 0, bouquets = 0;\\n       for(int i = 0; i < bloomDay.size(); i++){\\n         if(bloomDay[i] <= mid){\\n           flowers++;\\n         } else {\\n           flowers = 0;\\n         }\\n         if(flowers == k){\\n           bouquets++;\\n           flowers = 0;\\n         }\\n         if(bouquets == m) break;\\n       }\\n       if(bouquets < m) left = mid + 1;\\n       else {\\n       ans = mid;\\n       right = mid - 1;\\n       }\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n      // if(m * k > bloomDay.size()) return -1;\\n     int left = INT_MAX, right = INT_MIN,ans = -1;\\n     for(int i = 0; i < bloomDay.size(); i++){\\n       left = min(left, bloomDay[i]);\\n       right = max(right, bloomDay[i]);\\n     }\\n     cout << left << endl;\\n     cout << right << endl;\\n     while(left <= right){\\n       int mid = left + (right - left) / 2;\\n       int flowers = 0, bouquets = 0;\\n       for(int i = 0; i < bloomDay.size(); i++){\\n         if(bloomDay[i] <= mid){\\n           flowers++;\\n         } else {\\n           flowers = 0;\\n         }\\n         if(flowers == k){\\n           bouquets++;\\n           flowers = 0;\\n         }\\n         if(bouquets == m) break;\\n       }\\n       if(bouquets < m) left = mid + 1;\\n       else {\\n       ans = mid;\\n       right = mid - 1;\\n       }\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3289458,
                "title": "c-simple-solution-wowowow-poggers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfunction to check if the solution is possible and then binary search the respective parts\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool myFunc(vector<int>& bloomDay, int m, int k , int mid){\\n        int count = 0;\\n        for(int i = 0; i < bloomDay.size() ; i ++){\\n            if(bloomDay[i] > mid){\\n                count = 0;\\n            }     \\n            if(bloomDay[i] <= mid){\\n                count++;\\n            }\\n            if(count == k){\\n                count = 0;\\n                m--;\\n            }\\n            if(m == 0) \\n                return true;  \\n    }    \\n      return false;\\n}    \\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int max = *max_element(bloomDay.begin(), bloomDay.end());\\n        int min = 0 ;\\n        int mid = 0 ;\\n        int ans =-1 ;\\n        while(min <= max){\\n            mid = (min + max)/2;\\n            if(myFunc(bloomDay, m, k , mid)){\\n                ans = mid;\\n                max = mid -1;\\n            }\\n            else{\\n                min = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool myFunc(vector<int>& bloomDay, int m, int k , int mid){\\n        int count = 0;\\n        for(int i = 0; i < bloomDay.size() ; i ++){\\n            if(bloomDay[i] > mid){\\n                count = 0;\\n            }     \\n            if(bloomDay[i] <= mid){\\n                count++;\\n            }\\n            if(count == k){\\n                count = 0;\\n                m--;\\n            }\\n            if(m == 0) \\n                return true;  \\n    }    \\n      return false;\\n}    \\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int max = *max_element(bloomDay.begin(), bloomDay.end());\\n        int min = 0 ;\\n        int mid = 0 ;\\n        int ans =-1 ;\\n        while(min <= max){\\n            mid = (min + max)/2;\\n            if(myFunc(bloomDay, m, k , mid)){\\n                ans = mid;\\n                max = mid -1;\\n            }\\n            else{\\n                min = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272174,
                "title": "c-binary-search-on-search-space-self-explainatory",
                "content": "**Time Complexity: O(n*log(end-start)))**, where n is the size of array, end is max_element of the array and start is the minimum element of the array\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& bloomDay, int m, int k, int bloom){\\n        int subarray = 0;\\n        int bouq_cnt = 0;\\n        \\n        for(auto x: bloomDay){\\n            if(x <= bloom){\\n                subarray++;\\n                if(subarray == k)\\n                    bouq_cnt++, subarray = 0;\\n            }\\n            else\\n                subarray = 0;\\n        }\\n        \\n        return bouq_cnt >= m;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int start = *min_element(bloomDay.begin(), bloomDay.end());\\n        int end = *max_element(bloomDay.begin(), bloomDay.end());\\n        int res = -1;\\n        \\n        while(start <= end){\\n            int mid = start+(end-start)/2;\\n            if(isValid(bloomDay, m, k, mid)){\\n                res = mid;\\n                end = mid-1;\\n            }\\n            else\\n                start = mid+1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nDo Upvote if this helps.\\nThanks!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& bloomDay, int m, int k, int bloom){\\n        int subarray = 0;\\n        int bouq_cnt = 0;\\n        \\n        for(auto x: bloomDay){\\n            if(x <= bloom){\\n                subarray++;\\n                if(subarray == k)\\n                    bouq_cnt++, subarray = 0;\\n            }\\n            else\\n                subarray = 0;\\n        }\\n        \\n        return bouq_cnt >= m;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int start = *min_element(bloomDay.begin(), bloomDay.end());\\n        int end = *max_element(bloomDay.begin(), bloomDay.end());\\n        int res = -1;\\n        \\n        while(start <= end){\\n            int mid = start+(end-start)/2;\\n            if(isValid(bloomDay, m, k, mid)){\\n                res = mid;\\n                end = mid-1;\\n            }\\n            else\\n                start = mid+1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218448,
                "title": "easy-java-solution-beat-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing binary search \\nbounds are min and max \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe check if the days less than mid can be enough to make bouquets \\nif so then we check the right half for minimum days\\nelse we traverse the right half \\nwe keep track of the adjacency using count \\n# Complexity\\n- Time complexity:O(nlogm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int minDays(int[] bloomDay, int m, int k) {\\n       if((long)m*k>bloomDay.length) return -1;\\n     \\n        int left=1,right=1,mid;\\n        for(int i:bloomDay)\\n        {\\n            left=Math.min(left,i);\\n            right=Math.max(right,i);\\n        }\\n        while(left<right)\\n        {\\n            mid=left+(right-left)/2;\\n            if(canmake(mid,m,k,bloomDay))\\n                right=mid;\\n            else\\n                left=mid+1;\\n        }\\n        return left;\\n    }\\n    \\n    private boolean canmake(int val,int bouquet, int flowers,int[] bloom)\\n    {\\n        int count=0;\\n        for(int i:bloom)\\n        {\\n            if(i<=val)\\n            {\\n                count++;\\n                if(count==flowers)\\n                {\\n                    bouquet--;\\n                    count=0;\\n                    if(bouquet==0) return true;\\n                }\\n            }\\n            else count = 0;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int minDays(int[] bloomDay, int m, int k) {\\n       if((long)m*k>bloomDay.length) return -1;\\n     \\n        int left=1,right=1,mid;\\n        for(int i:bloomDay)\\n        {\\n            left=Math.min(left,i);\\n            right=Math.max(right,i);\\n        }\\n        while(left<right)\\n        {\\n            mid=left+(right-left)/2;\\n            if(canmake(mid,m,k,bloomDay))\\n                right=mid;\\n            else\\n                left=mid+1;\\n        }\\n        return left;\\n    }\\n    \\n    private boolean canmake(int val,int bouquet, int flowers,int[] bloom)\\n    {\\n        int count=0;\\n        for(int i:bloom)\\n        {\\n            if(i<=val)\\n            {\\n                count++;\\n                if(count==flowers)\\n                {\\n                    bouquet--;\\n                    count=0;\\n                    if(bouquet==0) return true;\\n                }\\n            }\\n            else count = 0;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192866,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<int>& vec, int m, int k,int mid){\\n        \\n        int curr = 0;\\n        int n = vec.size();\\n        int temp = 0;\\n        \\n        for(int i =0;i<n;i++){\\n            \\n            if(temp==k){\\n                curr++;\\n                temp = 0;\\n            }\\n            \\n            if(vec[i]<=mid){\\n                temp++;\\n            }\\n            else{\\n                temp = 0;\\n            }\\n        }\\n        \\n        if(temp==k){\\n            curr++;\\n            temp = 0;\\n        }\\n        \\n        return curr>=m;\\n    }\\n    \\n    int minDays(vector<int>& vec, int m, int k) {\\n        \\n        int high = vec[0];\\n        int n = vec.size();\\n        \\n        for(auto iter : vec){\\n            high = max(high,iter);\\n        }\\n        \\n        int low = 1;\\n        \\n        int ans = -1;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(f(vec,m,k,mid)){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<int>& vec, int m, int k,int mid){\\n        \\n        int curr = 0;\\n        int n = vec.size();\\n        int temp = 0;\\n        \\n        for(int i =0;i<n;i++){\\n            \\n            if(temp==k){\\n                curr++;\\n                temp = 0;\\n            }\\n            \\n            if(vec[i]<=mid){\\n                temp++;\\n            }\\n            else{\\n                temp = 0;\\n            }\\n        }\\n        \\n        if(temp==k){\\n            curr++;\\n            temp = 0;\\n        }\\n        \\n        return curr>=m;\\n    }\\n    \\n    int minDays(vector<int>& vec, int m, int k) {\\n        \\n        int high = vec[0];\\n        int n = vec.size();\\n        \\n        for(auto iter : vec){\\n            high = max(high,iter);\\n        }\\n        \\n        int low = 1;\\n        \\n        int ans = -1;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(f(vec,m,k,mid)){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942086,
                "title": "c-binary-search-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(Nlog(j-i))\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int i=*min_element(bloomDay.begin(), bloomDay.end()), j=*max_element(bloomDay.begin(), bloomDay.end());\\n        while(i<j){\\n            int mid=i+(j-i)/2;\\n            int cnt=0, ans=0;\\n            for(auto it: bloomDay){\\n                if(it>mid){cnt=0;}\\n                else{\\n                    cnt++;\\n                    if(cnt==k){\\n                        cnt=0;\\n                        ans++;\\n                    }\\n                }\\n                if(ans>=m){break;}\\n            }\\n            if(ans>=m){j=mid;}\\n            else{i=mid+1;}\\n        }\\n        int cnt=0, ans=0;\\n        for(auto it: bloomDay){\\n            if(it>i){cnt=0;}\\n            else{\\n                cnt++;\\n                if(cnt==k){\\n                    cnt=0;\\n                    ans++;\\n                }\\n            }\\n            if(ans>=m){break;}\\n        }\\n        if(ans>=m){return i;}\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int i=*min_element(bloomDay.begin(), bloomDay.end()), j=*max_element(bloomDay.begin(), bloomDay.end());\\n        while(i<j){\\n            int mid=i+(j-i)/2;\\n            int cnt=0, ans=0;\\n            for(auto it: bloomDay){\\n                if(it>mid){cnt=0;}\\n                else{\\n                    cnt++;\\n                    if(cnt==k){\\n                        cnt=0;\\n                        ans++;\\n                    }\\n                }\\n                if(ans>=m){break;}\\n            }\\n            if(ans>=m){j=mid;}\\n            else{i=mid+1;}\\n        }\\n        int cnt=0, ans=0;\\n        for(auto it: bloomDay){\\n            if(it>i){cnt=0;}\\n            else{\\n                cnt++;\\n                if(cnt==k){\\n                    cnt=0;\\n                    ans++;\\n                }\\n            }\\n            if(ans>=m){break;}\\n        }\\n        if(ans>=m){return i;}\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916641,
                "title": "golang-binarysearch",
                "content": "# Intuition\\nUsing binarySearch find optimal days required to make m bouques\\n\\n# Approach\\n1. Use binarySearch to find number of appox days\\n2. Using that approx days, find out how many sequential flowers would have bloomed\\n3. If number of sequential flowers bloomed are more than bouquet requirement, then try reducing the number of days to min days required.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc minDays(bloomDay []int, m int, k int) int {\\n    n := len(bloomDay)\\n\\n    if m * k > n {\\n        return -1\\n    }\\n\\n    left, right := 1, 1000000000\\n    for left < right {\\n        mid := (left + right) / 2\\n\\n        if canMakeBouq(bloomDay,  mid, m, k) {\\n            right = mid\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n\\n    return left\\n}\\n\\nfunc canMakeBouq(bloomDay []int, days, m, k int) bool {\\n    bouq := 0\\n    seq := 0\\n    for i := 0; i < len(bloomDay) && bouq < m; i++ {\\n        if bloomDay[i] > days {\\n            seq = 0\\n            continue\\n        } \\n        seq++\\n        if seq == k {\\n            bouq++\\n            seq = 0 // start again new sequence\\n        }\\n    }\\n\\n    return bouq >= m\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```\\nfunc minDays(bloomDay []int, m int, k int) int {\\n    n := len(bloomDay)\\n\\n    if m * k > n {\\n        return -1\\n    }\\n\\n    left, right := 1, 1000000000\\n    for left < right {\\n        mid := (left + right) / 2\\n\\n        if canMakeBouq(bloomDay,  mid, m, k) {\\n            right = mid\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n\\n    return left\\n}\\n\\nfunc canMakeBouq(bloomDay []int, days, m, k int) bool {\\n    bouq := 0\\n    seq := 0\\n    for i := 0; i < len(bloomDay) && bouq < m; i++ {\\n        if bloomDay[i] > days {\\n            seq = 0\\n            continue\\n        } \\n        seq++\\n        if seq == k {\\n            bouq++\\n            seq = 0 // start again new sequence\\n        }\\n    }\\n\\n    return bouq >= m\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2840291,
                "title": "java-binary-search-common-template-commented-with-code-walk-through",
                "content": "```\\nclass Solution \\n{\\n    public int minDays(int[] bloomDay, int m, int k) \\n    {\\n        //  m*k= Number of flowers required that is should be <= n (bloomDay.length)\\n        //  k: is also the length of the subarray (flowers for bouquet)\\n        \\n        if (m*k> bloomDay.length)\\n            return -1;\\n        int ans=-1;\\n        \\n        /*  Main Idea: m subarrays (bouquets) of size k, and we need to minimize the maximum value in these sub-arrays\\n         -> if above condition (m*k> len) is false, we are guaranteed an answer. \\n            Also, we know the answer lies between the maximum and minimum value in our bloom-array, and since the answer is guaranteed we can check the feasibility (which means searching will be involved) and depending on that change our search space.\\n         -> So we might be able to use Binary Search instead of checking for each element of the array.\\n         \\n         Let\\'s think*/\\n         int low=0;\\n         int high= (int)Math.pow(10,9); // Also can find the max and min values from the array\\n        \\n        while (low<=high)\\n        {\\n            int mid= low+ (high-low)/2; // Possible result\\n            \\n            // Check if it is possible?\\n            if (isPossible(bloomDay, mid, m, k)){   \\n                ans= mid;\\n                high= mid-1; // Lets check for a lesser possible answer\\n            }\\n            else\\n                low= mid+1; // Looks like we can not have m bouquets for this mid\\n            \\n        }\\n        return ans;\\n       \\n    }\\n    // Check for a possible answer (mid): Going through the array and checking if for an assumed answer, can we make more than or equal to required bouquets \\n\\t// [Essentially finding the count of subarrays of size k with all elements less than or equal to mid]\\n    public boolean isPossible(int arr[], int mid, int bouquets, int k) \\n    {   \\n        int flowers=0;\\n        int boqs=0;\\n\\n        for (int i=0; i<arr.length; i++)\\n        {\\n            if (arr[i]>mid) // Implies flower hasn\\'t bloomed so can not be a part of subarray, so count set to 0\\n                flowers=0; // Since adjacent\\n            \\n            else \\n            // We need to check if the number of flowers is k(indicates size of curr subarray)\\n            {\\n                flowers++; // Count of elements/ flowers in subarray/ bouquets (adjacent)\\n                if (flowers==k)\\n                    {\\n                    boqs++; // Count of bouquets\\n                    flowers=0; \\n                }\\n                else\\n                    continue;\\n            }\\n            \\n        }\\n        if (boqs>= bouquets) // We can make m bouquets\\n            return true;\\n        else \\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minDays(int[] bloomDay, int m, int k) \\n    {\\n        //  m*k= Number of flowers required that is should be <= n (bloomDay.length)\\n        //  k: is also the length of the subarray (flowers for bouquet)\\n        \\n        if (m*k> bloomDay.length)\\n            return -1;\\n        int ans=-1;\\n        \\n        /*  Main Idea: m subarrays (bouquets) of size k, and we need to minimize the maximum value in these sub-arrays\\n         -> if above condition (m*k> len) is false, we are guaranteed an answer. \\n            Also, we know the answer lies between the maximum and minimum value in our bloom-array, and since the answer is guaranteed we can check the feasibility (which means searching will be involved) and depending on that change our search space.\\n         -> So we might be able to use Binary Search instead of checking for each element of the array.\\n         \\n         Let\\'s think*/\\n         int low=0;\\n         int high= (int)Math.pow(10,9); // Also can find the max and min values from the array\\n        \\n        while (low<=high)\\n        {\\n            int mid= low+ (high-low)/2; // Possible result\\n            \\n            // Check if it is possible?\\n            if (isPossible(bloomDay, mid, m, k)){   \\n                ans= mid;\\n                high= mid-1; // Lets check for a lesser possible answer\\n            }\\n            else\\n                low= mid+1; // Looks like we can not have m bouquets for this mid\\n            \\n        }\\n        return ans;\\n       \\n    }\\n    // Check for a possible answer (mid): Going through the array and checking if for an assumed answer, can we make more than or equal to required bouquets \\n\\t// [Essentially finding the count of subarrays of size k with all elements less than or equal to mid]\\n    public boolean isPossible(int arr[], int mid, int bouquets, int k) \\n    {   \\n        int flowers=0;\\n        int boqs=0;\\n\\n        for (int i=0; i<arr.length; i++)\\n        {\\n            if (arr[i]>mid) // Implies flower hasn\\'t bloomed so can not be a part of subarray, so count set to 0\\n                flowers=0; // Since adjacent\\n            \\n            else \\n            // We need to check if the number of flowers is k(indicates size of curr subarray)\\n            {\\n                flowers++; // Count of elements/ flowers in subarray/ bouquets (adjacent)\\n                if (flowers==k)\\n                    {\\n                    boqs++; // Count of bouquets\\n                    flowers=0; \\n                }\\n                else\\n                    continue;\\n            }\\n            \\n        }\\n        if (boqs>= bouquets) // We can make m bouquets\\n            return true;\\n        else \\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694584,
                "title": "python-binary-search-on-answer-explained",
                "content": "This is one of those problems where we have to make use of the \"Binary Search on Answer\" concept.\\n\\n\\tIn simple words - Apply Binary Search on the range of possible solution values.\\n\\t\\nHere, we have to find \"minimum days to wait\" to make m bouquets.\\n\\nNow, What can be the range of values in which solution can exist?\\n\\nWe have to think of what can be the smallest possible input? We might be asked for 1 bouquet that can be make using 1 flower only.\\n\\nSo in that case, what is the minimum days we need to wait?\\n\\t\\t\\n\\t\\tConsider this example - \\n\\t\\t\\n\\t\\tbloomDay = [1,10,3,10,2], m = 1, k = 1\\n\\t\\t\\n\\t\\tWe can see that bloomDay[0] has value = 1 which means this flower will bloom after waiting for 1 day only.\\n\\t\\t\\n\\t\\tAnd since we only need 1 flower, the minimum days we need to wait is 1. Because 1 is the smallest value in this array.\\n\\t\\t\\n\\t\\tAnd this is the lower bound of our range.\\n\\t\\t\\n\\t\\t\\nSimilarly, think of what can be the upper bound?\\n\\nWhat if we are asked to make one bouquet but that will be made using all the flowers that we have in array. \\n\\n\\t\\tConsider this example - \\n\\t\\t\\n\\t\\tbloomDay = [1,10,3,10,2], m = 1, k = 5\\n\\t\\t\\n\\t\\tSo, to get all the 5 flowers ready for bouquet, we have to wait 10 days, right? \\n\\t\\t\\n\\t\\tBecause only then the flowers at index 1 and index 3 will bloom. \\n\\t\\t\\nThis means, the upper bound of the range is the maximum value in the given array.\\n\\nHence the Range is - \\n\\n\\t\\tMinimum Value in bloomDay \\n\\t\\t\\t\\t\\t\\tTo\\n\\t\\tMaximim Value in bloomDay\\n\\t\\t\\nAnd we are sure that solution for any test case lies in this range only.\\n\\nAnd since this range is sorted, we can use Binary search to get the minimum valid value.\\n\\n\\tbloomDay = [1,10,3,10,2], m = 3, k = 1\\n\\t\\n\\tHere, range is from 1 to 10\\n\\t\\n\\tSo, we get mid = 5\\n\\t\\n\\tNow, how to check if we can wait 5 days to make m bouquets?\\n\\t\\n\\tThat\\'s where we can use a Helper method that checks just that.\\n\\t\\n\\nWe will go through the array and for every flower, we check if it can bloom in <= mid days. IF yes, we can take this flower. But it is also important to note that we need adjacent flowers. So, if some flower takes longer days to bloom, then that means, we have to again start searching for k adjacent flowers from 0.\\n\\nIf we got k adjacent flowers, we can make one bouquet\\n\\nAnd when loop ends, we just need to check whether we were able to make at least \"m\" bouquets after waiting for \"mid\" days.\\n\\n# **CODE**\\n\\n```\\nclass Solution:\\n    \\n    # Helper method to check if after waiting certain number of days\\n    # We can make m bouquets\\n    \\n    def isValid(self, days, bloomDay, m, k):\\n        bouquets = 0\\n        flowerCount = 0\\n        \\n        for day in bloomDay:\\n            # If we have to wait <= \"days\" for this flower, increment flowerCount \\n            if day <= days: flowerCount += 1\\n            # Otherwise we have to reset flowerCount because we can only take adjacent flowers\\n            else: flowerCount = 0\\n            \\n            # If we got k flowers, we can make one bouquet. So increment bouquet count and also reset flowerCount\\n            if flowerCount == k: \\n                bouquets += 1\\n                flowerCount = 0\\n                \\n        # If we can make at least m bouquet after waiting \"days\" days then return True\\n        return bouquets >= m\\n    \\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        \\n        # For one bouquet, we need k flowers\\n        # For m bouquet, we need m * k flowers\\n        # And length of array = flowers we have\\n        \\n        # If we don\\'t have enough flowers at all\\n        \\n        if len(bloomDay) < m * k: return -1\\n        \\n        \\n        # Binary Search on Answer\\n        # We want the minimum number of days to wait to make m bouquets\\n        \\n        \\n        # What is the lower bound for minimum days to wait?\\n        # It is the lowest value in bloomDay, right?\\n        \\n        # What is the upper bound? It is the highest value\\n        \\n        start = min(bloomDay)\\n        end  = max(bloomDay)\\n        result = -1\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            # We need to check if after waiting for mid days, we can make m bouquets\\n            \\n            if self.isValid(mid, bloomDay, m, k):\\n                # If we can wait mid days for m bouquets, this is one possible solution\\n                # But since we want minimum days to wait, we keep searching for a lower possible valid value\\n                \\n                result = mid\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n                \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # Helper method to check if after waiting certain number of days\\n    # We can make m bouquets\\n    \\n    def isValid(self, days, bloomDay, m, k):\\n        bouquets = 0\\n        flowerCount = 0\\n        \\n        for day in bloomDay:\\n            # If we have to wait <= \"days\" for this flower, increment flowerCount \\n            if day <= days: flowerCount += 1\\n            # Otherwise we have to reset flowerCount because we can only take adjacent flowers\\n            else: flowerCount = 0\\n            \\n            # If we got k flowers, we can make one bouquet. So increment bouquet count and also reset flowerCount\\n            if flowerCount == k: \\n                bouquets += 1\\n                flowerCount = 0\\n                \\n        # If we can make at least m bouquet after waiting \"days\" days then return True\\n        return bouquets >= m\\n    \\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        \\n        # For one bouquet, we need k flowers\\n        # For m bouquet, we need m * k flowers\\n        # And length of array = flowers we have\\n        \\n        # If we don\\'t have enough flowers at all\\n        \\n        if len(bloomDay) < m * k: return -1\\n        \\n        \\n        # Binary Search on Answer\\n        # We want the minimum number of days to wait to make m bouquets\\n        \\n        \\n        # What is the lower bound for minimum days to wait?\\n        # It is the lowest value in bloomDay, right?\\n        \\n        # What is the upper bound? It is the highest value\\n        \\n        start = min(bloomDay)\\n        end  = max(bloomDay)\\n        result = -1\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            # We need to check if after waiting for mid days, we can make m bouquets\\n            \\n            if self.isValid(mid, bloomDay, m, k):\\n                # If we can wait mid days for m bouquets, this is one possible solution\\n                # But since we want minimum days to wait, we keep searching for a lower possible valid value\\n                \\n                result = mid\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617570,
                "title": "c-easy-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    bool canGetBouq(vector<int>& bloomDay, int days, int m, int k){\\n        int count=0,result=0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            if(bloomDay[i]<=days){\\n                count++; //count represents consective flowers\\n            }\\n            else{\\n                count=0;\\n            }\\n            if(count==k){\\n                count=0; //reset the window\\n                result++;\\n            }\\n        }\\n        return result>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int low=1,high=1000000000;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(canGetBouq(bloomDay,mid,m,k)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return canGetBouq(bloomDay,low,m,k) ? low : -1; //Final check if the result day can have atleast `m` bouquets.\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool canGetBouq(vector<int>& bloomDay, int days, int m, int k){\\n        int count=0,result=0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            if(bloomDay[i]<=days){\\n                count++; //count represents consective flowers\\n            }\\n            else{\\n                count=0;\\n            }\\n            if(count==k){\\n                count=0; //reset the window\\n                result++;\\n            }\\n        }\\n        return result>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int low=1,high=1000000000;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(canGetBouq(bloomDay,mid,m,k)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return canGetBouq(bloomDay,low,m,k) ? low : -1; //Final check if the result day can have atleast `m` bouquets.\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578894,
                "title": "binary-search-c-best",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& b,int mid, int k, int m,int n)\\n    {\\n        int tot=0,flo=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(b[i] <= mid)\\n            {\\n                flo++;\\n                if(flo == k){\\n                    tot++;\\n                    flo=0;   \\n                }\\n            }else\\n                flo=0;\\n        }\\n        return tot >= m;\\n    }\\n    \\n    int minDays(vector<int>& b, int m, int k) {\\n        int n=b.size();\\n        if(k*m > n)return -1;\\n        int l=1,r=*max_element(b.begin(),b.end()),ans=-1;\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(check(b,mid,k,m,n))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }else\\n                l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& b,int mid, int k, int m,int n)\\n    {\\n        int tot=0,flo=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(b[i] <= mid)\\n            {\\n                flo++;\\n                if(flo == k){\\n                    tot++;\\n                    flo=0;   \\n                }\\n            }else\\n                flo=0;\\n        }\\n        return tot >= m;\\n    }\\n    \\n    int minDays(vector<int>& b, int m, int k) {\\n        int n=b.size();\\n        if(k*m > n)return -1;\\n        int l=1,r=*max_element(b.begin(),b.end()),ans=-1;\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(check(b,mid,k,m,n))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }else\\n                l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244993,
                "title": "cpp-binary-search-with-comments",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isValid(vector<int>& bloomDay, int bouquets, int flowers, int days){\\n\\t\\t\\tint bouq = 0, flow = 0; //initially keep the bouqets with flowers that can be formed as 0\\n\\t\\t\\tfor(auto bloom : bloomDay){\\n\\t\\t\\t\\tflow = (bloom <= days) ? flow + 1 : 0;  //Increment flowers if element is less than or equal to days , or else reset it to 0\\n\\t\\t\\t\\tif(flow == flowers){  //if flowers == desired flowers , you can make a bouquet, Reset flowers after incrementing bouquet\\n\\t\\t\\t\\t\\tflow = 0; \\n\\t\\t\\t\\t\\tbouq ++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn bouq >= bouquets; //return true if bouqets >= desired bouqets or return false\\n\\t\\t}\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(bloomDay.size() < m*k) return -1; // in case making bouqet isnt possible because that many flowers arent present\\n        int low = 1; //Search space - 1 to max of arr. (1 day to bloom or max of all the days present to bloom)\\n        int high = 0;\\n        for(auto days: bloomDay) high = max(high, days);\\n        while(low < high){\\n            int mid = low + (high-low)/2; //avoid integer overflow\\n            if(isValid(bloomDay, m, k, mid)){\\n                high = mid; //if the isValid returns true, try to find a better result by shrink the search space to the left.(Note that mid can be a possible answer , hence high = mid and not mid-1)\\n            }else{\\n                low = mid + 1; //if isValid returns false, eliminate left. Hence low = mid + 1 and not low = mid\\n            }\\n        }\\n        return low; //at last low and high will be pointing to the same answer, so return anyone of them\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isValid(vector<int>& bloomDay, int bouquets, int flowers, int days){\\n\\t\\t\\tint bouq = 0, flow = 0; //initially keep the bouqets with flowers that can be formed as 0\\n\\t\\t\\tfor(auto bloom : bloomDay){\\n\\t\\t\\t\\tflow = (bloom <= days) ? flow + 1 : 0;  //Increment flowers if element is less than or equal to days , or else reset it to 0\\n\\t\\t\\t\\tif(flow == flowers){  //if flowers == desired flowers , you can make a bouquet, Reset flowers after incrementing bouquet\\n\\t\\t\\t\\t\\tflow = 0; \\n\\t\\t\\t\\t\\tbouq ++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2062891,
                "title": "binary-search-easy-solution-c",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPERICIATED**\\n```\\nclass Solution {\\nprivate:\\n    bool isf(int mid,vector<int> &b,int m,int k){\\n        int flower=0;int var=0;\\n        for(int i=0;i<b.size();i++){\\n            if(b[i]<=mid) {\\n                var++;\\n                if(var==k){\\n                    flower++;\\n                    var=0;\\n                }\\n            }else var=0;\\n            \\n        }return flower>=m;\\n    }\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {\\n        if((m*k)>b.size()) return -1;\\n        int i=1;\\n        int j=*max_element(b.begin(),b.end());\\n        int ans=j;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(isf(mid,b,m,k)){\\n                cout<<mid<<\" \";\\n                ans=mid;\\n                j=mid-1;\\n            }else i=mid+1;\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isf(int mid,vector<int> &b,int m,int k){\\n        int flower=0;int var=0;\\n        for(int i=0;i<b.size();i++){\\n            if(b[i]<=mid) {\\n                var++;\\n                if(var==k){\\n                    flower++;\\n                    var=0;\\n                }\\n            }else var=0;\\n            \\n        }return flower>=m;\\n    }\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {\\n        if((m*k)>b.size()) return -1;\\n        int i=1;\\n        int j=*max_element(b.begin(),b.end());\\n        int ans=j;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(isf(mid,b,m,k)){\\n                cout<<mid<<\" \";\\n                ans=mid;\\n                j=mid-1;\\n            }else i=mid+1;\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1995826,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    \\n    def canWork(self, blooms, days, m, k):\\n        flowers = 0\\n        for flower in blooms:\\n            flowers = flowers + 1 if (flower <= days) else 0\\n            if flowers == k:\\n                m -= 1\\n                flowers = 0\\n        return m <= 0\\n    \\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m * k: return -1\\n        left, right = 1, max(bloomDay)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if self.canWork(bloomDay, mid, m, k):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def canWork(self, blooms, days, m, k):\\n        flowers = 0\\n        for flower in blooms:\\n            flowers = flowers + 1 if (flower <= days) else 0\\n            if flowers == k:\\n                m -= 1\\n                flowers = 0\\n        return m <= 0\\n    \\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m * k: return -1\\n        left, right = 1, max(bloomDay)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if self.canWork(bloomDay, mid, m, k):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986979,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\npublic int minDays(int[] A, int m, int k) {\\n        int n = A.length, left = 1, right = (int)1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\\n\\n***JavaScript***\\n```\\nvar minDays = function (bloomDay, m, k) {\\n  let n = bloomDay.length;\\n  let left = 1;\\n  let right = Number.MAX_SAFE_INTEGER;\\n  if (m * k > n) {\\n    return -1;\\n  }\\n  while (left < right) {\\n    let mid = Math.floor(left / 2 + right / 2);\\n    let flowers = 0;\\n    let bouque = 0;\\n    for (let j = 0; j < n; j++) {\\n      if (bloomDay[j] > mid) {\\n        flowers = 0;\\n      } else {\\n        flowers++;\\n        if (flowers >= k) {\\n          bouque++;\\n          flowers = 0;\\n        }\\n      }\\n    }\\n    if (bouque < m) {\\n      left = mid + 1;\\n    } else {\\n      right = mid;\\n    }\\n  }\\n\\n  return left;\\n};\\n```\\n\\n***C++***\\n```\\nint minDays(vector<int>& A, int m, int k) {\\n        int n = A.size(), left = 1, right = 1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\\n\\n***Python***\\n```\\ndef minDays(self, A, m, k):\\n        if m * k > len(A): return -1\\n        left, right = 1, max(A)\\n        while left < right:\\n            mid = (left + right) / 2\\n            flow = bouq = 0\\n            for a in A:\\n                flow = 0 if a > mid else flow + 1\\n                if flow >= k:\\n                    flow = 0\\n                    bouq += 1\\n                    if bouq == m: break\\n            if bouq == m:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n***Kotlin***\\n```\\nfun minDays(A: IntArray, m: Int, k: Int): Int {\\n        val len = A.size\\n        val max = 1000000001 // max value of A is 10^9\\n        \\n        fun isPossible(day: Int): Boolean {\\n            val garden = BooleanArray(len) { i -> if (A[i] <= day) true else false }\\n            var bouquet = 0\\n            var countAdj = 0\\n            for (isBloomed in garden) {\\n                if (isBloomed) { \\n                    countAdj++\\n                    if (countAdj == k) {\\n                        bouquet++\\n                        countAdj = 0\\n                    }\\n                } else {\\n                    countAdj = 0\\n                }\\n            }\\n            return bouquet >= m\\n        }\\n        \\n        var low = 1\\n        var high = max\\n        while (low < high) {\\n            val mid = (high + low) / 2\\n            if (isPossible(mid).not()) \\n                low = mid + 1\\n            else\\n                high = mid\\n        }\\n        return if (low == max) -1 else low\\n    }\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func minDays(_ bd: [Int], _ m: Int, _ k: Int) -> Int {\\n        guard bd.count >= m * k else { return -1 }\\n        var lhs = 0, rhs = 0, valid = Set<Int>(), res = Int.max\\n\\n        for d in bd {\\n            if d > rhs { rhs = d }\\n            if d <= lhs { lhs = d }\\n        }\\n        \\n        func match(_ t: Int) -> Bool {\\n            var cnt = 0, sum = 0\\n            for d in bd {\\n                if d <= t { sum += 1 } else { cnt += sum / k; sum = 0 }\\n            }\\n            return cnt + sum / k >= m\\n        }\\n\\n        while lhs < rhs {\\n            let mid = lhs + (rhs - lhs) >> 1\\n            valid.insert(mid)\\n            if match(mid) {\\n                res = min(res, mid)\\n                rhs = mid - 1\\n            } else {\\n                lhs = mid + 1\\n            }\\n        }\\n        return valid.contains(lhs) ? res : min(res, match(lhs) ? lhs : .max)\\n    }\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\npublic int minDays(int[] A, int m, int k) {\\n        int n = A.length, left = 1, right = (int)1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\n```\\nvar minDays = function (bloomDay, m, k) {\\n  let n = bloomDay.length;\\n  let left = 1;\\n  let right = Number.MAX_SAFE_INTEGER;\\n  if (m * k > n) {\\n    return -1;\\n  }\\n  while (left < right) {\\n    let mid = Math.floor(left / 2 + right / 2);\\n    let flowers = 0;\\n    let bouque = 0;\\n    for (let j = 0; j < n; j++) {\\n      if (bloomDay[j] > mid) {\\n        flowers = 0;\\n      } else {\\n        flowers++;\\n        if (flowers >= k) {\\n          bouque++;\\n          flowers = 0;\\n        }\\n      }\\n    }\\n    if (bouque < m) {\\n      left = mid + 1;\\n    } else {\\n      right = mid;\\n    }\\n  }\\n\\n  return left;\\n};\\n```\n```\\nint minDays(vector<int>& A, int m, int k) {\\n        int n = A.size(), left = 1, right = 1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\n```\\ndef minDays(self, A, m, k):\\n        if m * k > len(A): return -1\\n        left, right = 1, max(A)\\n        while left < right:\\n            mid = (left + right) / 2\\n            flow = bouq = 0\\n            for a in A:\\n                flow = 0 if a > mid else flow + 1\\n                if flow >= k:\\n                    flow = 0\\n                    bouq += 1\\n                    if bouq == m: break\\n            if bouq == m:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```\\nfun minDays(A: IntArray, m: Int, k: Int): Int {\\n        val len = A.size\\n        val max = 1000000001 // max value of A is 10^9\\n        \\n        fun isPossible(day: Int): Boolean {\\n            val garden = BooleanArray(len) { i -> if (A[i] <= day) true else false }\\n            var bouquet = 0\\n            var countAdj = 0\\n            for (isBloomed in garden) {\\n                if (isBloomed) { \\n                    countAdj++\\n                    if (countAdj == k) {\\n                        bouquet++\\n                        countAdj = 0\\n                    }\\n                } else {\\n                    countAdj = 0\\n                }\\n            }\\n            return bouquet >= m\\n        }\\n        \\n        var low = 1\\n        var high = max\\n        while (low < high) {\\n            val mid = (high + low) / 2\\n            if (isPossible(mid).not()) \\n                low = mid + 1\\n            else\\n                high = mid\\n        }\\n        return if (low == max) -1 else low\\n    }\\n```\n```\\nclass Solution {\\n    func minDays(_ bd: [Int], _ m: Int, _ k: Int) -> Int {\\n        guard bd.count >= m * k else { return -1 }\\n        var lhs = 0, rhs = 0, valid = Set<Int>(), res = Int.max\\n\\n        for d in bd {\\n            if d > rhs { rhs = d }\\n            if d <= lhs { lhs = d }\\n        }\\n        \\n        func match(_ t: Int) -> Bool {\\n            var cnt = 0, sum = 0\\n            for d in bd {\\n                if d <= t { sum += 1 } else { cnt += sum / k; sum = 0 }\\n            }\\n            return cnt + sum / k >= m\\n        }\\n\\n        while lhs < rhs {\\n            let mid = lhs + (rhs - lhs) >> 1\\n            valid.insert(mid)\\n            if match(mid) {\\n                res = min(res, mid)\\n                rhs = mid - 1\\n            } else {\\n                lhs = mid + 1\\n            }\\n        }\\n        return valid.contains(lhs) ? res : min(res, match(lhs) ? lhs : .max)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962800,
                "title": "c-binary-search-with-sliding-window-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& arr, int m, int k,int maxDay){\\n        int toPick = m;\\n        int i=0,j = 0,cnt=0;\\n        while(j < arr.size()){\\n            int window = j - i + 1;\\n            if(arr[j] <= maxDay){\\n                cnt++;\\n            }\\n            \\n            if(window == k){\\n                if(cnt == k){\\n                    toPick--;\\n                    cnt = 0;\\n                    i = j + 1;\\n                }else{\\n                    if(arr[i] <= maxDay){\\n                        cnt--;\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return toPick <= 0;\\n    }\\n    int minDays(vector<int>& arr, int m, int k) {\\n        int lo = INT_MAX, hi = INT_MIN;\\n        for(int i : arr){\\n            lo = min(i,lo);\\n            hi = max(i,hi);\\n        }\\n        int ans = -1;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(check(arr,m,k,mid)){\\n                hi = mid - 1;\\n                ans = mid;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// n.log(max-min)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& arr, int m, int k,int maxDay){\\n        int toPick = m;\\n        int i=0,j = 0,cnt=0;\\n        while(j < arr.size()){\\n            int window = j - i + 1;\\n            if(arr[j] <= maxDay){\\n                cnt++;\\n            }\\n            \\n            if(window == k){\\n                if(cnt == k){\\n                    toPick--;\\n                    cnt = 0;\\n                    i = j + 1;\\n                }else{\\n                    if(arr[i] <= maxDay){\\n                        cnt--;\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return toPick <= 0;\\n    }\\n    int minDays(vector<int>& arr, int m, int k) {\\n        int lo = INT_MAX, hi = INT_MIN;\\n        for(int i : arr){\\n            lo = min(i,lo);\\n            hi = max(i,hi);\\n        }\\n        int ans = -1;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(check(arr,m,k,mid)){\\n                hi = mid - 1;\\n                ans = mid;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// n.log(max-min)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950294,
                "title": "c-binary-search",
                "content": "I think many people not able to identify that this problem comes under binary search. So to identify if the given problem can be solved using binary search or not check the final answer if it is between some range or not.\\n\\nYou will always find the range and you have to find the maximum and minimum from that range by keeping in a mind some condition and reducing a boundary.\\n\\nFor eg:  bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\\nhere range will be **1 to sumOfDaysInArray** which is 1 to 54\\nwe have to find the mid element which is 27\\n\\nwe will check for 27 if it can be total no of days or not and we find that it can be the answer but we want the minimum one so will will reduce the boundary from 1 to 27 and will try to find ans in this range and this process will continue untill low<high.\\n\\n**So for binary search always check if answer lies between some range or not.**\\n\\nI know its useless to add code here as many people already posted the code but still i will post for convenience,\\n\\n```\\n int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(k*m>bloomDay.size())\\n            return -1;\\n        long long low=1,high;\\n        for(auto i:bloomDay)\\n            high+=i;\\n        int ans;\\n        while(low<high){\\n            long long mid=low+(high-low)/2;\\n            int temp=0;\\n            int total=0;\\n            for(int i=0;i<bloomDay.size();i++){\\n                if(bloomDay[i]<=mid)\\n                    temp++;\\n                else temp=0;\\n                if(temp==k){\\n                    total++;\\n                    temp=0;\\n                }\\n            }\\n            if(total>=m){\\n                ans=mid;\\n                high=mid;\\n            }\\n            else low=mid+1;\\n            \\n            \\n        }\\n        return ans;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(k*m>bloomDay.size())\\n            return -1;\\n        long long low=1,high;\\n        for(auto i:bloomDay)\\n            high+=i;\\n        int ans;\\n        while(low<high){\\n            long long mid=low+(high-low)/2;\\n            int temp=0;\\n            int total=0;\\n            for(int i=0;i<bloomDay.size();i++){\\n                if(bloomDay[i]<=mid)\\n                    temp++;\\n                else temp=0;\\n                if(temp==k){\\n                    total++;\\n                    temp=0;\\n                }\\n            }\\n            if(total>=m){\\n                ans=mid;\\n                high=mid;\\n            }\\n            else low=mid+1;\\n            \\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1940673,
                "title": "java-binary-search-beats-98-79",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < m*k){return -1;}\\n        \\n        int left = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int i : bloomDay){\\n            max = Math.max(i, max);\\n        }\\n        int right = max;\\n        while(left < right){\\n            int mid = left + (right-left)/2;\\n            if(feasible(bloomDay, m, k, mid)){\\n                right = mid;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean feasible(int[] bloomDay, int m, int k, int days){\\n        int count_continuous = 0;\\n        int count_flower = 0;\\n        for(int i : bloomDay){\\n            if(i <= days){\\n                count_continuous ++;\\n                if(count_continuous >= k){\\n                    count_continuous = 0;\\n                    count_flower ++;\\n                }\\n            }else{\\n                count_continuous = 0;\\n            }\\n        }\\n        \\n        return count_flower >= m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < m*k){return -1;}\\n        \\n        int left = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int i : bloomDay){\\n            max = Math.max(i, max);\\n        }\\n        int right = max;\\n        while(left < right){\\n            int mid = left + (right-left)/2;\\n            if(feasible(bloomDay, m, k, mid)){\\n                right = mid;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean feasible(int[] bloomDay, int m, int k, int days){\\n        int count_continuous = 0;\\n        int count_flower = 0;\\n        for(int i : bloomDay){\\n            if(i <= days){\\n                count_continuous ++;\\n                if(count_continuous >= k){\\n                    count_continuous = 0;\\n                    count_flower ++;\\n                }\\n            }else{\\n                count_continuous = 0;\\n            }\\n        }\\n        \\n        return count_flower >= m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664714,
                "title": "c-binary-search-on-answer-detail-explanation",
                "content": "*`!!!Please please like or Upvote  if you find useful : <3`*\\n**Point to Notice :**\\n1. Array must be in same order.\\n2. m is the number of boque and k is the number of flower in each boque => number of flower in the array must be grater than m*k.\\n\\n**Thinking about binary search :**\\n1.  Minimum time to bloom a single flower is the minimum value in the array.\\n2.  Maximum time to bloom all flower is maximum value in the array.\\n3.  Since we know that answer must lie between maximum and minimum value.\\n4.  Here we use binary search b/w max and min and every time you find middle element and go for it.\\n**Helper function:**\\n1. It help to conclude weather we are able to  find  m boque  with k flower each or not .\\n\\n\\n```\\n//CODE:\\n\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(vector<int>&arr,int m,int k,int mid)\\n    {\\n        int flower=0;\\n        int boque=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<=mid)//checking the flowe which are ready in mid of day\\n            {\\n                flower++;//adding flower var\\n                if(flower==k)//if we get flower ==k we make a boque and add to it.\\n                {\\n                    boque++;\\n                    flower=0;//and making flower count=0;\\n                }\\n            }\\n            else//if we get any array greater than mid then we leave the flower and make flower value=0\\n            {\\n                flower=0;\\n            }\\n        }\\n        if(boque>=m)//checking is we are able to make m boque or not..\\n        {\\n            return 1;\\n            \\n        }\\n        return 0;\\n    }\\n    \\n \\n    int minDays(vector<int>& arr, int m, int k) {\\n        \\n        int n=arr.size();\\n        if(m*k>n)\\n        {\\n            return -1;\\n        }\\n\\t\\t//checking corner cases\\n        \\n        int mini=*min_element(arr.begin(),arr.end());//minimum time\\n        int maxi=*max_element(arr.begin(),arr.end());//maximum time\\n        //applying generic binary seach\\n        int start=mini;\\n        int end=maxi;\\n        int ans=-1;\\n        while(start<end)\\n        {\\n            int mid=(start+end)/2;\\n            if(is_possible(arr,m,k,mid))//checking weather we are able to create m boque or not\\n            {\\n                end=mid;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n                \\n            }\\n        }\\n        return start;\\n        \\n    }\\n    \\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n//CODE:\\n\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(vector<int>&arr,int m,int k,int mid)\\n    {\\n        int flower=0;\\n        int boque=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<=mid)//checking the flowe which are ready in mid of day\\n            {\\n                flower++;//adding flower var\\n                if(flower==k)//if we get flower ==k we make a boque and add to it.\\n                {\\n                    boque++;\\n                    flower=0;//and making flower count=0;\\n                }\\n            }\\n            else//if we get any array greater than mid then we leave the flower and make flower value=0\\n            {\\n                flower=0;\\n            }\\n        }\\n        if(boque>=m)//checking is we are able to make m boque or not..\\n        {\\n            return 1;\\n            \\n        }\\n        return 0;\\n    }\\n    \\n \\n    int minDays(vector<int>& arr, int m, int k) {\\n        \\n        int n=arr.size();\\n        if(m*k>n)\\n        {\\n            return -1;\\n        }\\n\\t\\t//checking corner cases\\n        \\n        int mini=*min_element(arr.begin(),arr.end());//minimum time\\n        int maxi=*max_element(arr.begin(),arr.end());//maximum time\\n        //applying generic binary seach\\n        int start=mini;\\n        int end=maxi;\\n        int ans=-1;\\n        while(start<end)\\n        {\\n            int mid=(start+end)/2;\\n            if(is_possible(arr,m,k,mid))//checking weather we are able to create m boque or not\\n            {\\n                end=mid;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n                \\n            }\\n        }\\n        return start;\\n        \\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266371,
                "title": "easy-binary-search-solution-c",
                "content": "1. n < m*k is to check if the size of  array is less than the number of flowers required.\\n2. As we need to \"minimize the number of days\" so we need to reduce the search space [ ans=mid; high=mid-1]\\n3.  makeBouquet() will check if we can get consecutive flowers of K [ given in the question ] and increase the count of \"bouquet\" variable once \"flower\" count is passed the value of K and return true or false if we can create \"m\" bouquets.\\n4.  if ( !makeBouquet() ) because I want to reduce the search space from maximum value to minimum possible solution.\\n5.  low and high are minimum and maximum number of days.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    using ll=long long;\\n    \\n    bool makeBouquet(vector<int>& bloomDay, int m, int k,int mid){\\n        int flower=0;\\n        int n=bloomDay.size();\\n        int bouquet=0;\\n        for(int i=0;i<n;i++){\\n            if(bloomDay[i]>mid){\\n                flower=0;\\n            }else{\\n                flower++;\\n            }\\n            \\n            if(flower>=k){\\n                bouquet++;\\n                flower=0;\\n            }\\n        }\\n        \\n        return (bouquet>=m);\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int low=*min_element(bloomDay.begin(),bloomDay.end());\\n        int high=*max_element(bloomDay.begin(),bloomDay.end());\\n        \\n        int n=bloomDay.size();\\n        \\n        if((ll)n<((ll)m*k))return -1; \\n        \\n        int ans=0;\\n        \\n        while(low<=high){\\n            ll mid=(low+high)>>1;\\n            if(!makeBouquet(bloomDay,m,k,mid)){\\n                low=mid+1;\\n            }else{\\n                ans=mid;\\n                high=mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    using ll=long long;\\n    \\n    bool makeBouquet(vector<int>& bloomDay, int m, int k,int mid){\\n        int flower=0;\\n        int n=bloomDay.size();\\n        int bouquet=0;\\n        for(int i=0;i<n;i++){\\n            if(bloomDay[i]>mid){\\n                flower=0;\\n            }else{\\n                flower++;\\n            }\\n            \\n            if(flower>=k){\\n                bouquet++;\\n                flower=0;\\n            }\\n        }\\n        \\n        return (bouquet>=m);\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int low=*min_element(bloomDay.begin(),bloomDay.end());\\n        int high=*max_element(bloomDay.begin(),bloomDay.end());\\n        \\n        int n=bloomDay.size();\\n        \\n        if((ll)n<((ll)m*k))return -1; \\n        \\n        int ans=0;\\n        \\n        while(low<=high){\\n            ll mid=(low+high)>>1;\\n            if(!makeBouquet(bloomDay,m,k,mid)){\\n                low=mid+1;\\n            }else{\\n                ans=mid;\\n                high=mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229041,
                "title": "c-binary-search-with-simple-english-explanation",
                "content": "Algorithm: \\n The minimum days will lie in between lo = min(bloomDays) and hi = max(bloomDays),\\n as when\\n  i)  m* k = 1, you only need to have 1 flower, which at min will bloom in min(bloomDays) days\\n  ii) m* k = bloomDays.size(){i.e. number of flowers}, you need n flowers, all of which at max will bloom in max(bloomDays) days; \\n\\nlet the ans be Mid = lo + (hi - lo)/2, and check if its possible to have m* k adjacent flowers in mid days.. If possible then search on a smaller space of days for better value ie ** lo to mid **  \\n\\nPossibility Check\\n1. Check for bouquet and Adjacent Count, bouquet>m and adjacent count should be great than or equal to k \\nas long as bloomDays[i] days <= mid, adjacentCount++, if adjacent count >k then bouquet++, adjacentCount = 1;\\nwhen bloomDays[i] days > mid, adjacent count = 0 \\n\\nCode\\n\\n```\\n typedef long long ll;\\n    \\n    bool isPossible(vector<int>& bloomDay, int m, int k, ll x){\\n        ll bouquet = 0, adjacentBloomers = 0;\\n        for(int i = 0; i<bloomDay.size(); i++){\\n            if(bloomDay[i]<=x){\\n                adjacentBloomers++;\\n                if(adjacentBloomers==k){\\n                    bouquet++; \\n                    adjacentBloomers = 0;\\n                }\\n            }else{\\n                adjacentBloomers = 0;\\n            }\\n        }\\n        \\n        return bouquet>=m;\\n        \\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int flowers = bloomDay.size();\\n       \\n        if(k*m >flowers)return -1;\\n        \\n        ll lo = INT_MAX, hi = INT_MIN, mid;\\n       \\n        for(auto& day:bloomDay){\\n            hi = max(hi, (ll)day);\\n            lo = min(lo, (ll)day);\\n        }\\n        \\n        int ans = 1;\\n        if(lo == hi)return lo;\\n        \\n        \\n        while(lo<=hi){\\n            mid = lo+(hi-lo)/2;\\n            if(isPossible(bloomDay, m, k, mid)){\\n                ans = mid;\\n                hi = mid-1;\\n            }else {\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n typedef long long ll;\\n    \\n    bool isPossible(vector<int>& bloomDay, int m, int k, ll x){\\n        ll bouquet = 0, adjacentBloomers = 0;\\n        for(int i = 0; i<bloomDay.size(); i++){\\n            if(bloomDay[i]<=x){\\n                adjacentBloomers++;\\n                if(adjacentBloomers==k){\\n                    bouquet++; \\n                    adjacentBloomers = 0;\\n                }\\n            }else{\\n                adjacentBloomers = 0;\\n            }\\n        }\\n        \\n        return bouquet>=m;\\n        \\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int flowers = bloomDay.size();\\n       \\n        if(k*m >flowers)return -1;\\n        \\n        ll lo = INT_MAX, hi = INT_MIN, mid;\\n       \\n        for(auto& day:bloomDay){\\n            hi = max(hi, (ll)day);\\n            lo = min(lo, (ll)day);\\n        }\\n        \\n        int ans = 1;\\n        if(lo == hi)return lo;\\n        \\n        \\n        while(lo<=hi){\\n            mid = lo+(hi-lo)/2;\\n            if(isPossible(bloomDay, m, k, mid)){\\n                ans = mid;\\n                hi = mid-1;\\n            }else {\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1078516,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {      \\n        int maxDay = 1e9 + 1;\\n        int l = 1, r = maxDay;                            \\n        while(l<r){\\n            int mid = l + (r - l) / 2;                \\n            if(isValid(b, mid, m, k)) r = mid;  \\n            else l = mid + 1;\\n        }\\n        return l != maxDay ? l  : -1;\\n    }\\n    \\nprivate:\\n    bool isValid(const vector<int>& b, int day, int m, int k){            \\n        \\n        int flwcnt=0;\\n        int buqcnt=0;\\n        for(int i = 0; i < b.size(); i++)\\n            \\n            if(b[i] <= day){\\n                \\n                flwcnt++;\\n                if(flwcnt ==k) flwcnt = 0, buqcnt++;\\n                if(buqcnt == m) return true;\\n                \\n                \\n            }else \\n                flwcnt=0;   \\n        \\n        \\n        return false;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {      \\n        int maxDay = 1e9 + 1;\\n        int l = 1, r = maxDay;                            \\n        while(l<r){\\n            int mid = l + (r - l) / 2;                \\n            if(isValid(b, mid, m, k)) r = mid;  \\n            else l = mid + 1;\\n        }\\n        return l != maxDay ? l  : -1;\\n    }\\n    \\nprivate:\\n    bool isValid(const vector<int>& b, int day, int m, int k){            \\n        \\n        int flwcnt=0;\\n        int buqcnt=0;\\n        for(int i = 0; i < b.size(); i++)\\n            \\n            if(b[i] <= day){\\n                \\n                flwcnt++;\\n                if(flwcnt ==k) flwcnt = 0, buqcnt++;\\n                if(buqcnt == m) return true;\\n                \\n                \\n            }else \\n                flwcnt=0;   \\n        \\n        \\n        return false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990569,
                "title": "java-iterative-binary-search-o-m-log-n-easy-to-understand",
                "content": "**Time Complexity: O(m * log n)**\\nm = length of bloomDay array\\nn = (maximum element of bloomDay - minimum element of bloomDay)\\n\\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k){\\n        int low = Integer.MAX_VALUE; int high = Integer.MIN_VALUE;\\n        for(int d : bloomDay){\\n            low = Math.min(low, d);\\n            high = Math.max(high, d);\\n        }\\n\\n        int result = -1;\\n\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n\\n            if(isSufficient(mid, bloomDay, m, k)){ // Check if (days = mid) will be sufficient to make bouquets\\n                result = mid;\\n                high = mid - 1;\\n            }\\n            else { // If not sufficient then go to right side to check with greater number of days\\n                low = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public boolean isSufficient(int day, int[] bloomDay, int m, int k){\\n        int result = 0; int counter = 0;\\n\\n        for(int i = 0; i < bloomDay.length; i++){\\n            if(bloomDay[i] <= day && counter < k){\\n                counter++;\\n            }\\n            else if(bloomDay[i] > day && counter > 0){\\n                counter = 0;\\n            }\\n\\n            if(counter >= k){\\n                result++;\\n                counter = 0;\\n            }\\n        }\\n        return result >= m;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k){\\n        int low = Integer.MAX_VALUE; int high = Integer.MIN_VALUE;\\n        for(int d : bloomDay){\\n            low = Math.min(low, d);\\n            high = Math.max(high, d);\\n        }\\n\\n        int result = -1;\\n\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n\\n            if(isSufficient(mid, bloomDay, m, k)){ // Check if (days = mid) will be sufficient to make bouquets\\n                result = mid;\\n                high = mid - 1;\\n            }\\n            else { // If not sufficient then go to right side to check with greater number of days\\n                low = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public boolean isSufficient(int day, int[] bloomDay, int m, int k){\\n        int result = 0; int counter = 0;\\n\\n        for(int i = 0; i < bloomDay.length; i++){\\n            if(bloomDay[i] <= day && counter < k){\\n                counter++;\\n            }\\n            else if(bloomDay[i] > day && counter > 0){\\n                counter = 0;\\n            }\\n\\n            if(counter >= k){\\n                result++;\\n                counter = 0;\\n            }\\n        }\\n        return result >= m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852229,
                "title": "java-dp-dfs-defeated-by-mle",
                "content": "83 / 91 test cases passed.\\nStatus: Memory Limit Exceeded\\n```\\nclass Solution {\\n    \\n    Integer[][] dp;\\n    HashMap<Integer, Integer> bloom = new HashMap<>();\\n\\t// days required for bouquet [start, start+k-1]\\n\\t\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        Integer[] days = new Integer[bloomDay.length];\\n        for(int i = 0; i < n; i++){\\n            days[i] = bloomDay[i];\\n        }\\n        \\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n        for(int i = 0; i < k; i++){\\n            pq.add(days[i]);\\n        }\\n        bloom.put(0, pq.peek());\\n        \\n        for(int i = k; i < n; i++){\\n            pq.remove(days[i-k]);\\n            pq.add(days[i]);\\n            bloom.put(i-k+1, pq.peek());\\n        }\\n        dp = new Integer [m+1][n+1];\\n        int ans = dfs(m, k, 0);\\n        if(ans == Integer.MAX_VALUE) return -1;\\n        return ans;\\n    }\\n    \\n    int dfs(int m, int k, int flowerIdx){\\n         if(m == 0)\\n            return 0;\\n        \\n         if(bloom.get(flowerIdx) == null) \\n             return Integer.MAX_VALUE;\\n        \\n         if(dp[m][flowerIdx] != null)\\n             return dp[m][flowerIdx];\\n        \\n         int localMin = Math.min(\\n         //take\\n         Math.max(dfs(m-1, k, flowerIdx+k), bloom.get(flowerIdx)), \\n         //no take\\n         dfs(m, k, flowerIdx+1));\\n        \\n         dp[m][flowerIdx] = localMin;\\n         return localMin;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    \\n    Integer[][] dp;\\n    HashMap<Integer, Integer> bloom = new HashMap<>();\\n\\t// days required for bouquet [start, start+k-1]\\n\\t\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        Integer[] days = new Integer[bloomDay.length];\\n        for(int i = 0; i < n; i++){\\n            days[i] = bloomDay[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 851134,
                "title": "binary-search-intuition-and-theory-explained-c-implementation",
                "content": "**Basic Intuition**\\n\\n* First of all we need to observe that we can make atmost floor(total no of flowers / k) and hence if m is greater than this value then for sure the answer is -1.\\n\\n* Second Lets think of the Intuition for the why binary Search ? Lets say I need to check that If I would be able to have the goal completed with **x days**, lets assume for now the answer is yes, then for sure I would be able to do the same at **x+1 days** and the justification being that next day I would be atleast having the no of already bloomed flowers and hence as the days increase the no of flowers are going to just increase and hence it would be very much possible to do the job tommorow provided I can do it today\\n\\n* This would make the range of the our answer to look something like **BBBBBBGGGGGGG** where **G** stands for a good ans(possible to do within this much days) and **B** stands for bad ans(not possible to do so) and hence, If I am at a **G** right now for sure the next all elements are **G** only and hence I need to find the first answer such that its itself is **G** and the element just before this element would be **B**. So kinda I need to find the border of the same.\\n\\n**Explaining the Implementation**\\n* Lets take two pointers mi which is ryt now at a bad answer(for simplification taking it 0 because it would never be able to do the job in 0 days) and ma which is ryt now at a good answer(INT_MAX is a simple justification because by this day I would have all my flowers bloomed and hence It is for sure a good answer\\n\\n* Now Just Implementing a classic binary search, take the mid element of good-bad sequence, if the current mid is a good answer set the ma pointer to good (because for sure all the answer in front of this are good only) and if the case if opposite then set mi pointer to mid (because for sure all answer before this mid are also bad) \\n\\n* Do this until mi and ma and adjacent (Thus find the border of our good-bad sequence)\\n\\n* In the end my ma pointer would be pointing to the least good value and mi pointer would be pointing to the most bad value \\n\\n* It is easy to see that in the end ma pointer is our required answer and hence return the ma pointer \\n\\n* Implement the check function to justify the current good-bad condition of the mid for our own because not a big deal to imagine\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n\\tbool isPos(int x, int m, int k, vector<int> &b) {\\n\\t\\tint cur = 0;\\n\\t\\tint tot = 0;\\n\\t\\tfor (int &i : b) {\\n\\t\\t\\tif (i > x) tot += cur / k, cur = 0;\\n\\t\\t\\telse cur++;\\n\\t\\t}\\n\\t\\treturn tot >= m;\\n\\t}\\n    \\n\\tint minDays(vector<int>& b, int m, int k) {\\n\\t\\tif (b.size() / k < m) return -1;\\n\\t\\tb.push_back(INT_MAX);\\n\\n\\t\\tint mi = 0, ma = INT_MAX;\\n\\t\\twhile (mi + 1 < ma) {\\n\\t\\t\\tint mid = mi + (ma - mi) / 2;\\n\\t\\t\\tif (isPos(mid, m, k, b)) ma = mid;\\n\\t\\t\\telse mi = mid;\\n\\t\\t}\\n\\n\\t\\treturn ma;\\n\\t}\\n};\\n```\\n**Content Regarding Binary Search**\\n[Just register and open the Binary Search section and start practising (PS : Its not related to me in anyway and is free)](https://codeforces.com/edu/courses)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool isPos(int x, int m, int k, vector<int> &b) {\\n\\t\\tint cur = 0;\\n\\t\\tint tot = 0;\\n\\t\\tfor (int &i : b) {\\n\\t\\t\\tif (i > x) tot += cur / k, cur = 0;\\n\\t\\t\\telse cur++;\\n\\t\\t}\\n\\t\\treturn tot >= m;\\n\\t}\\n    \\n\\tint minDays(vector<int>& b, int m, int k) {\\n\\t\\tif (b.size() / k < m) return -1;\\n\\t\\tb.push_back(INT_MAX);\\n\\n\\t\\tint mi = 0, ma = INT_MAX;\\n\\t\\twhile (mi + 1 < ma) {\\n\\t\\t\\tint mid = mi + (ma - mi) / 2;\\n\\t\\t\\tif (isPos(mid, m, k, b)) ma = mid;\\n\\t\\t\\telse mi = mid;\\n\\t\\t}\\n\\n\\t\\treturn ma;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736440,
                "title": "python-0-nlog-n-using-binary-search-with-explanation",
                "content": "```\\nclass Solution:\\n    def minDays(self, days: List[int], m: int, k: int) -> int:\\n        \\n        n = len(days)\\n        \\n        \\n        if (m*k)>n:\\n            return -1\\n        \\n        def check(num):\\n            \\n            ## This function will return whether in \\'num\\' days, can we form the \\n            ## required number of bouquets or not.\\n            \\n            ## the following array will tell whether the ith flower \\n            ## will bloom in num days or not\\n            yes_no_array = [1 if i<=num else 0 for i in days] \\n            \\n            ## once this is done, just find whether there are m groups\\n            ## in the above list having k consecutive 1s.\\n            \\n            if sum(yes_no_array)<(m*k):\\n                return 0\\n            \\n            total_found = 0\\n            i = 0\\n            \\n            while i<n:\\n                \\n                total = 0\\n                    \\n                while i<n and yes_no_array[i] == 1:\\n                        \\n                    total+=1\\n                    \\n                    \\n                    if total == k:\\n\\t\\t\\t\\t\\t## consecutive k flowers have been collected \\n                        ## increase the total flowers that can be formed\\n                        total_found += 1\\n                        \\n\\t\\t\\t\\t\\t\\t## if the requirement has been satisfied, it is possible to \\n\\t\\t\\t\\t\\t\\t## make the required bouquets in \\'num\\' days, hence return 1\\n                        if total_found == m:\\n                            return 1\\n                        \\n                        break\\n                        \\n                    i+=1\\n                    \\n                i+=1\\n                \\n                \\n            return 0\\n                \\n\\n        \\n        low = min(days)\\n        high = max(days)\\n        \\n        ## the max possible answer is high, no matter what the case is\\n        current_ans = high\\n        \\n        \\n        while low<=high:\\n            \\n            mid = (low+high)//2\\n            \\n            if check(mid):\\n                \\n                current_ans = min(current_ans, mid)\\n                high = mid-1\\n                \\n            else:\\n                \\n                low = mid+1\\n                \\n                \\n        return current_ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDays(self, days: List[int], m: int, k: int) -> int:\\n        \\n        n = len(days)\\n        \\n        \\n        if (m*k)>n:\\n            return -1\\n        \\n        def check(num):\\n            \\n            ## This function will return whether in \\'num\\' days, can we form the \\n            ## required number of bouquets or not.\\n            \\n            ## the following array will tell whether the ith flower \\n            ## will bloom in num days or not\\n            yes_no_array = [1 if i<=num else 0 for i in days] \\n            \\n            ## once this is done, just find whether there are m groups\\n            ## in the above list having k consecutive 1s.\\n            \\n            if sum(yes_no_array)<(m*k):\\n                return 0\\n            \\n            total_found = 0\\n            i = 0\\n            \\n            while i<n:\\n                \\n                total = 0\\n                    \\n                while i<n and yes_no_array[i] == 1:\\n                        \\n                    total+=1\\n                    \\n                    \\n                    if total == k:\\n\\t\\t\\t\\t\\t## consecutive k flowers have been collected \\n                        ## increase the total flowers that can be formed\\n                        total_found += 1\\n                        \\n\\t\\t\\t\\t\\t\\t## if the requirement has been satisfied, it is possible to \\n\\t\\t\\t\\t\\t\\t## make the required bouquets in \\'num\\' days, hence return 1\\n                        if total_found == m:\\n                            return 1\\n                        \\n                        break\\n                        \\n                    i+=1\\n                    \\n                i+=1\\n                \\n                \\n            return 0\\n                \\n\\n        \\n        low = min(days)\\n        high = max(days)\\n        \\n        ## the max possible answer is high, no matter what the case is\\n        current_ans = high\\n        \\n        \\n        while low<=high:\\n            \\n            mid = (low+high)//2\\n            \\n            if check(mid):\\n                \\n                current_ans = min(current_ans, mid)\\n                high = mid-1\\n                \\n            else:\\n                \\n                low = mid+1\\n                \\n                \\n        return current_ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715925,
                "title": "python-100-speed-o-n-log-n-time-o-n-space",
                "content": "**Python - 100% Speed - O(n log n) time, O(n) space**\\n\\nThe code below solves the problem with 100% speed in Python. It might seem intricate, but its working principles are fairly simple:\\n1. Start by assuming that the highest \"day count\" is our best solution.\\n2. Assign a subset-ID to each element of \"bloomDay\", such that each subset is contiguous (and able to hold at least \"k\" flowers)\\n3. Sort the dates, and create an O(n) for-loop where we try to remove the dates one-by-one (checking the feasibility).\\n4. For each date, we split our subsets and remove any trailing pieces unable to hold \"k\" flowers. To keep our O(n) time complexity in the for-loop, we track the boundaries of the subsets using a global dictionary (id_ij) that we constantly update.\\n\\n5. Additionally, we track two scalar variables called \"counting\" and \"residual\", which contain the number of available flower slots and any \"residual\" places in the subsets which can\\'t be fully occupied (E.g. residual=1 for a subset of length=8 and k=7). \\n\\n6. We check the feasibility of decreasing our max. \"day count\" and update the result.\\n\\n7. If the numbers of available slots is too low (<m*k), we break the loop and exit.\\n\\nI hope the explanation was helpful. Cheers,\\n```\\nfmax  = lambda x,y  : x if x>y else y # this is 33%+ faster than the standard \"max\" function\\nfmin  = lambda x,y  : x if x<y else y\\nclass Solution:\\n    def minDays(self, bloomDay, m: int, k: int) -> int:\\n        L0 = len(bloomDay)\\n        if (m*k)>L0 or (not L0) or (m<1) or (k<1):\\n            return -1\\n        if (m*k)==L0:\\n            return max(*bloomDay) if L0>1 else bloomDay[0]\\n        #\\n        get_res = lambda a,b: (b-a+1)%k\\n        #\\n        ids   = [ 1 for _ in bloomDay ]\\n        id_ij = { 1 : [0,L0-1] }\\n        residual = get_res(0,L0-1)\\n        last  = 1\\n        #\\n        ordered = sorted([ (x,i) for i,x in enumerate(bloomDay) ])\\n        #\\n        result   = ordered[-1][0]\\n        counting = L0\\n        #\\n        for i0 in reversed(range(L0)):\\n            x,i = ordered[i0]\\n            # Get rid of each max. values, one-by-one\\n            id0 = ids[i]\\n            if id0:\\n                a,b       = id_ij[id0]\\n                residual -= get_res(a,b)\\n                ids[i]    = None\\n                counting -= 1\\n                #\\n                # Check Left Side\\n                if (i-1-a+1)>=k:\\n                    id_ij[id0] = a,i-1\\n                    residual  += get_res(a,i-1)\\n                else:\\n                    id_ij.pop(id0)\\n                    counting -= len(    range(a,i)    )\\n                    for j in range(a,i):\\n                        ids[j] = None\\n                #\\n                # Check Right Side\\n                if (b-(i+1)+1)>=k:\\n                    new = last = last + 1\\n                    id_ij[new] = i+1,b\\n                    residual  += get_res(i+1,b)\\n                else:\\n                    new = None\\n                    counting -= len( range(i+1,b+1) )\\n                #\\n                for j in range(i+1,b+1):\\n                    ids[j] = new\\n            #\\n            if (counting-residual)>=(m*k) and (i0>0):\\n                result = ordered[i0-1][0]\\n            elif counting<(m*k):\\n                break\\n        #\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfmax  = lambda x,y  : x if x>y else y # this is 33%+ faster than the standard \"max\" function\\nfmin  = lambda x,y  : x if x<y else y\\nclass Solution:\\n    def minDays(self, bloomDay, m: int, k: int) -> int:\\n        L0 = len(bloomDay)\\n        if (m*k)>L0 or (not L0) or (m<1) or (k<1):\\n            return -1\\n        if (m*k)==L0:\\n            return max(*bloomDay) if L0>1 else bloomDay[0]\\n        #\\n        get_res = lambda a,b: (b-a+1)%k\\n        #\\n        ids   = [ 1 for _ in bloomDay ]\\n        id_ij = { 1 : [0,L0-1] }\\n        residual = get_res(0,L0-1)\\n        last  = 1\\n        #\\n        ordered = sorted([ (x,i) for i,x in enumerate(bloomDay) ])\\n        #\\n        result   = ordered[-1][0]\\n        counting = L0\\n        #\\n        for i0 in reversed(range(L0)):\\n            x,i = ordered[i0]\\n            # Get rid of each max. values, one-by-one\\n            id0 = ids[i]\\n            if id0:\\n                a,b       = id_ij[id0]\\n                residual -= get_res(a,b)\\n                ids[i]    = None\\n                counting -= 1\\n                #\\n                # Check Left Side\\n                if (i-1-a+1)>=k:\\n                    id_ij[id0] = a,i-1\\n                    residual  += get_res(a,i-1)\\n                else:\\n                    id_ij.pop(id0)\\n                    counting -= len(    range(a,i)    )\\n                    for j in range(a,i):\\n                        ids[j] = None\\n                #\\n                # Check Right Side\\n                if (b-(i+1)+1)>=k:\\n                    new = last = last + 1\\n                    id_ij[new] = i+1,b\\n                    residual  += get_res(i+1,b)\\n                else:\\n                    new = None\\n                    counting -= len( range(i+1,b+1) )\\n                #\\n                for j in range(i+1,b+1):\\n                    ids[j] = new\\n            #\\n            if (counting-residual)>=(m*k) and (i0>0):\\n                result = ordered[i0-1][0]\\n            elif counting<(m*k):\\n                break\\n        #\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709880,
                "title": "java-faster-than-99-32-100-better-memory-commented-code",
                "content": "class Solution {\\n    \\n\\tpublic int minDays(int[] bloomDay, int m, int k) {\\n        \\n\\t\\t// If No. of flowers required are less than no. of flowers to bloom, then bouquet impossible\\n        if(bloomDay.length < m*k)\\n            return -1;\\n        \\n        int left = 1, right = findMax(bloomDay); // right is set to last day a flower blooms\\n        \\n        while(left <= right)  {\\n            \\n            int mid = left + (right - left)/2;\\n            \\n\\t\\t\\t// if bouquets possible on day i, then right = i - 1\\n            if(isPossible(bloomDay, mid, m, k)) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        \\n        }\\n        \\n        return left;    \\n        \\n        \\n    }\\n    \\n    private boolean isPossible(int[] bloomDay, int day, int m, int k) {\\n        \\n        int bouquets = 0; // No. of bouquets\\n        int countAdjacent = 0; // Adjacent flowers counter\\n        \\n        for(int blooms : bloomDay) {\\n           \\n\\t\\t   // if flower has bloomed, increment countAdjacent\\n\\t\\t   if(blooms <= day) {\\n                countAdjacent++;\\n                \\n\\t\\t\\t\\t// When k adjacent flowers bloomed, increment bouquets\\n\\t\\t\\t\\tif(countAdjacent == k) {\\n                    bouquets++;\\n                    countAdjacent = 0; // reset countAdjacent\\n                }\\n           \\n\\t\\t   } else {\\n                countAdjacent = 0; // If found a gap in adjacent flowers, reset countAdjacent\\n            }\\n        }\\n        \\n        return bouquets >= m; // if no. of bouquets possible >= required bouquets\\n    }\\n    \\n\\t// Find the day the last flower blooms\\n    private int findMax(int[] bloomDay) {\\n        int max = Integer.MIN_VALUE;\\n        for(int day : bloomDay) {\\n            if(max < day)\\n                max = day;\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    \\n\\tpublic int minDays(int[] bloomDay, int m, int k) {\\n        \\n\\t\\t// If No. of flowers required are less than no. of flowers to bloom, then bouquet impossible\\n        if(bloomDay.length < m*k)\\n            return -1;\\n        \\n        int left = 1, right = findMax(bloomDay); // right is set to last day a flower blooms\\n        \\n        while(left <= right)  {\\n            \\n            int mid = left + (right - left)/2;\\n            \\n\\t\\t\\t// if bouquets possible on day i, then right = i - 1\\n            if(isPossible(bloomDay, mid, m, k)) {\\n                right = mid - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 692488,
                "title": "easy-binary-search-with-detailed-explanation-in-c",
                "content": "The Idea is to perform binary search between  the values of array blooms day with left limit equals to the minimum value and r equals to the largest value in given array and then checking for each value wether we have m groups of k size ready if this is the case then we lower the r value to mid or else if more days are required then the answer is defineately greater then the mid therefore l is assigned mid +1.Continuing the loop until we reach the minimum value for which m groups of k flowers could be formed.\\n\\nAttaching the code for better understanding\\n\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& nums, int m, int k)\\n    {\\n        int n=nums.size();\\n        if(n<m*k)\\n            return -1;\\n        int l=nums[min_element(nums.begin(),nums.end())-nums.begin()];\\n        int r=nums[max_element(nums.begin(),nums.end())-nums.begin()];\\n        while(l<r)\\n        {\\n            int mid=(r-l)/2+l;\\n            int z=0,cnt=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums[i]<=mid)\\n                    z++;\\n                else\\n                    z=0;\\n                if(z==k)\\n                {\\n                    z=0;\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>=m)\\n                r=mid;\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\nIf you do like please upvote :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& nums, int m, int k)\\n    {\\n        int n=nums.size();\\n        if(n<m*k)\\n            return -1;\\n        int l=nums[min_element(nums.begin(),nums.end())-nums.begin()];\\n        int r=nums[max_element(nums.begin(),nums.end())-nums.begin()];\\n        while(l<r)\\n        {\\n            int mid=(r-l)/2+l;\\n            int z=0,cnt=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums[i]<=mid)\\n                    z++;\\n                else\\n                    z=0;\\n                if(z==k)\\n                {\\n                    z=0;\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>=m)\\n                r=mid;\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691096,
                "title": "optimal-o-n-algorithm-beat-100",
                "content": "Use divide and conquer, and shrink intervals.\\n```\\nconst int N=100005,inf=~0u>>1;\\nint a[N],b[N];\\nclass Solution {\\npublic:\\n    int minDays(vector<int> &v, int m, int k) {\\n        int n=v.size(),l=0,l1,t,s,c,ans=-1; if (m*k>n)return -1;\\n\\t\\tfor (int i=0;i<n;++i)a[l]=v[i],b[l++]=1;\\n\\t\\twhile (1){\\n\\t\\t\\tdo{t=a[rand()%l];}while (t==0||t==inf);\\n\\t\\t\\ts=c=0;\\n\\t\\t\\tfor (int i=0;i<l;++i)\\n\\t\\t\\t\\tif (a[i]<=t)c+=b[i];\\n\\t\\t\\t\\telse s+=c/k,c=0;\\n\\t\\t\\ts+=c/k;\\n\\t\\t\\tif (s>=m){\\n\\t\\t\\t\\tans=t;\\n\\t\\t\\t\\tfor (int i=0;i<l;++i)if (a[i]>=t)a[i]=inf;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tfor (int i=0;i<l;++i)if (a[i]<=t)a[i]=0;\\n\\t\\t\\t}\\n\\t\\t\\tl1=0;\\n\\t\\t\\tfor (int i=1;i<l;++i)\\n\\t\\t\\t\\tif (a[i]==a[l1])b[l1]+=b[i];\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t++l1,a[l1]=a[i],b[l1]=b[i];\\n\\t\\t\\t\\t\\tif (a[l1]==inf&&a[l1-1]==0&&l1>=2&&a[l1-2]==inf)m-=b[l1-1]/k,l1-=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\tl=l1+1;\\n\\t\\t\\tif (l<4){\\n\\t\\t\\t\\tl1=0;\\n\\t\\t\\t\\tfor (int i=0;i<l;++i)if (a[i]>0&&a[i]<inf)l1=1;\\n\\t\\t\\t\\tif (!l1)return ans;\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int N=100005,inf=~0u>>1;\\nint a[N],b[N];\\nclass Solution {\\npublic:\\n    int minDays(vector<int> &v, int m, int k) {\\n        int n=v.size(),l=0,l1,t,s,c,ans=-1; if (m*k>n)return -1;\\n\\t\\tfor (int i=0;i<n;++i)a[l]=v[i],b[l++]=1;\\n\\t\\twhile (1){\\n\\t\\t\\tdo{t=a[rand()%l];}while (t==0||t==inf);\\n\\t\\t\\ts=c=0;\\n\\t\\t\\tfor (int i=0;i<l;++i)\\n\\t\\t\\t\\tif (a[i]<=t)c+=b[i];\\n\\t\\t\\t\\telse s+=c/k,c=0;\\n\\t\\t\\ts+=c/k;\\n\\t\\t\\tif (s>=m){\\n\\t\\t\\t\\tans=t;\\n\\t\\t\\t\\tfor (int i=0;i<l;++i)if (a[i]>=t)a[i]=inf;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tfor (int i=0;i<l;++i)if (a[i]<=t)a[i]=0;\\n\\t\\t\\t}\\n\\t\\t\\tl1=0;\\n\\t\\t\\tfor (int i=1;i<l;++i)\\n\\t\\t\\t\\tif (a[i]==a[l1])b[l1]+=b[i];\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t++l1,a[l1]=a[i],b[l1]=b[i];\\n\\t\\t\\t\\t\\tif (a[l1]==inf&&a[l1-1]==0&&l1>=2&&a[l1-2]==inf)m-=b[l1-1]/k,l1-=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\tl=l1+1;\\n\\t\\t\\tif (l<4){\\n\\t\\t\\t\\tl1=0;\\n\\t\\t\\t\\tfor (int i=0;i<l;++i)if (a[i]>0&&a[i]<inf)l1=1;\\n\\t\\t\\t\\tif (!l1)return ans;\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686823,
                "title": "python-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        ## RC ##\\n        ## APPROACH : BINARY SEARCH ##\\n        ## Similar to Leetcode: 410. Split Array Largest Sum ##\\n        ## Similar to Leetcode: 875. Koko Eating Bananas ##\\n        \\n        ## TIME COMPLEXICITY : O(NlogN) ##\\n        ## SPACE COMPLEXICITY : O(1) ##\\n        \\n        # How many bouquets are possible with t days ?\\n        def bouquet_count( t ):\\n            count = 0\\n            res = 0\\n            for i in range(n):\\n                if bloomDay[i] <= t:    \\n                    count += 1\\n                    if count == k:      # if consecutive k days are less than t. we count it as one Valid bouquet formation\\n                        count = 0\\n                        res += 1\\n                else:\\n                    count = 0           # watchout, reset count if even one day is more than t.\\n            return res\\n        \\n        n = len(bloomDay)\\n        if m * k > n: return -1\\n        \\n        lo, hi = min(bloomDay), max(bloomDay)\\n        while(lo <= hi):\\n            mid = lo + (hi - lo)//2\\n            if bouquet_count(mid) >= m:\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n        return lo                       # return lo\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        ## RC ##\\n        ## APPROACH : BINARY SEARCH ##\\n        ## Similar to Leetcode: 410. Split Array Largest Sum ##\\n        ## Similar to Leetcode: 875. Koko Eating Bananas ##\\n        \\n        ## TIME COMPLEXICITY : O(NlogN) ##\\n        ## SPACE COMPLEXICITY : O(1) ##\\n        \\n        # How many bouquets are possible with t days ?\\n        def bouquet_count( t ):\\n            count = 0\\n            res = 0\\n            for i in range(n):\\n                if bloomDay[i] <= t:    \\n                    count += 1\\n                    if count == k:      # if consecutive k days are less than t. we count it as one Valid bouquet formation\\n                        count = 0\\n                        res += 1\\n                else:\\n                    count = 0           # watchout, reset count if even one day is more than t.\\n            return res\\n        \\n        n = len(bloomDay)\\n        if m * k > n: return -1\\n        \\n        lo, hi = min(bloomDay), max(bloomDay)\\n        while(lo <= hi):\\n            mid = lo + (hi - lo)//2\\n            if bouquet_count(mid) >= m:\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n        return lo                       # return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686659,
                "title": "python-iterative-not-binary-search",
                "content": "The simpliest solution would be checking the possibility of collecting bouquets at every day when any flower blooms. However this solution is too time consuming. A lot of people used binary search so that they don\\'t have to check every day, but unfourtunately I didn\\'t think about it during the contest. I\\'ve decided to post my way of overcoming time problem to show, that even if you **forgot about existence of binary search** like I did, you can still solve the problem!\\n\\nThe main idea is to check every day something blooms and update the information from previous day. I\\'ve decided to create a list called `flowers_left_from`, which is the same length as `bloomDay`. If there is a flower on `i`th position, then `flowers_left_from` is equal to the number of consecutive flowers to the left modulo `k` + 1, otherwise 0.\\nFor example, if 1 is a flower, 0 is non-flower, the garden is in state [1, 1, 1, 1, 0, 0, 1] and k = 2 then `flowers_left_from` would be [1, 2, 1, 2, 0, 0, 1]. \\nThis list represents the best way to fit bouquets: if there is a group of more that `k` consecutive flowers we take first `k` as a bouquet, then second `k`  as a bouquet if we can fit and so on, therefore the number of elements equal to `k` in `flowers_left_from` is the max number of bouquets from this garden. Now I want to check all days something bloomed and update this list.\\n\\n\\n```\\ndef minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n\\tif m * k > len(bloomDay):\\n\\t\\treturn -1\\n\\tflowers_left_from = [0] * len(bloomDay)\\n\\tbloom_day_dict = defaultdict(list)\\n\\tbouquets = 0\\n\\tfor i in range(len(bloomDay)):\\n\\t\\tbloom_day_dict[bloomDay[i]].append(i)\\n\\tbloomDaySorted = sorted([[day, bloom_day_dict[day]] for day in bloom_day_dict])\\n```\\n\\nI\\'ve created `bloomDaySorted` which is an ordered list, every element there is a pair [day, (flowers that bloomed that day)]. `bouquets` is a variable of number of bouquets now, that will be updated.\\n\\n```\\n\\tfor day, flower_list in bloomDaySorted:\\n\\t\\tfor flower in flower_list:\\n\\t\\t\\tbefore = flowers_left_from[flower]\\n\\t\\t\\tif flower == 0:\\n\\t\\t\\t\\tflowers_left_from[flower] = 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tflowers_left_from[flower] = flowers_left_from[flower - 1] % k + 1\\n\\t\\t\\tif before == k and flowers_left_from[flower] != k:\\n\\t\\t\\t\\tbouquets -= 1\\n\\t\\t\\tif before != k and flowers_left_from[flower] == k:\\n\\t\\t\\t\\tbouquets += 1\\n```\\n\\nNow for each day something bloomed we update `flowers_left from` the following way: if `flowers_left_from[flower]` is now blooming, then we put correct value there. After this operation number of bouquets could change, so I check if this value stopped being `k` or became `k`. \\n\\n```\\n\\t\\t\\tfor i in range(flower + 1, len(flowers_left_from)):\\n\\t\\t\\t\\tbefore = flowers_left_from[i]\\n\\n\\t\\t\\t\\tif flowers_left_from[i] == 0:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tflowers_left_from[i] = flowers_left_from[i - 1] % k + 1\\n\\n\\t\\t\\t\\tif before == k and flowers_left_from[i] != k:\\n\\t\\t\\t\\t\\tbouquets -= 1\\n\\t\\t\\t\\tif before != k and flowers_left_from[i] == k:\\n\\t\\t\\t\\t\\tbouquets += 1\\n\\t\\tif bouquets >= m:\\n\\t\\t\\treturn day \\n```\\n\\nThen I update all flowers to the right until I don\\'t meet a non-flower. And also check if number of `k`\\'s changed. After all updates for this day I check if number of bouquets is equal to at least `m` and return `day` if this happened.\\n\\nP.S. I know this solution is worse than binary search in every possible aspect. I wanted to share it because I saw a comment below someone\\'s binary search solution asking \"How do you even think of binary search here?\" I wanted to show, that even if you didn\\'t come up with binary search idea, you still could think of something else :)\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n\\tif m * k > len(bloomDay):\\n\\t\\treturn -1\\n\\tflowers_left_from = [0] * len(bloomDay)\\n\\tbloom_day_dict = defaultdict(list)\\n\\tbouquets = 0\\n\\tfor i in range(len(bloomDay)):\\n\\t\\tbloom_day_dict[bloomDay[i]].append(i)\\n\\tbloomDaySorted = sorted([[day, bloom_day_dict[day]] for day in bloom_day_dict])\\n```\n```\\n\\tfor day, flower_list in bloomDaySorted:\\n\\t\\tfor flower in flower_list:\\n\\t\\t\\tbefore = flowers_left_from[flower]\\n\\t\\t\\tif flower == 0:\\n\\t\\t\\t\\tflowers_left_from[flower] = 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tflowers_left_from[flower] = flowers_left_from[flower - 1] % k + 1\\n\\t\\t\\tif before == k and flowers_left_from[flower] != k:\\n\\t\\t\\t\\tbouquets -= 1\\n\\t\\t\\tif before != k and flowers_left_from[flower] == k:\\n\\t\\t\\t\\tbouquets += 1\\n```\n```\\n\\t\\t\\tfor i in range(flower + 1, len(flowers_left_from)):\\n\\t\\t\\t\\tbefore = flowers_left_from[i]\\n\\n\\t\\t\\t\\tif flowers_left_from[i] == 0:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tflowers_left_from[i] = flowers_left_from[i - 1] % k + 1\\n\\n\\t\\t\\t\\tif before == k and flowers_left_from[i] != k:\\n\\t\\t\\t\\t\\tbouquets -= 1\\n\\t\\t\\t\\tif before != k and flowers_left_from[i] == k:\\n\\t\\t\\t\\t\\tbouquets += 1\\n\\t\\tif bouquets >= m:\\n\\t\\t\\treturn day \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 686507,
                "title": "to-those-who-don-t-know-why-binary-search-here-is-my-explanation-c",
                "content": "This is my code during the contest. It gives a TLE. \\nStatus: TLE\\nApproach: \\nI will add the days in a priority queue and take the longest day from it and check (validate) whether we can make m bouquets of size k.\\n```\\nclass Solution {\\npublic:\\n    bool canWeMake(vector<int> & bloomDay, int m, int k, int t){\\n        int count = 0;\\n        \\n       for(int i = 0; i < bloomDay.size(); i++){\\n           \\n           if(bloomDay[i] <= t){\\n               count++;\\n               if(count == k){\\n                   count = 0;\\n                   m--;\\n                   if(!m) return true;\\n               }\\n           }\\n           else{\\n               count = 0;\\n           }\\n       }\\n        return !m ? true : false;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        priority_queue<int> pq(bloomDay.begin(), bloomDay.end());\\n        int res = -1;\\n        while(!pq.empty()){\\n            auto t = pq.top();\\n            if(canWeMake(bloomDay, m, k, t)){\\n                res = t;\\n            }\\n            pq.pop();\\n        }\\n        return res == -1 ? -1 : res;\\n    }\\n};\\n```\\nStatus: Accepted\\nWrote this after reading some discuss posts. People solved it using binary search.\\nI am confused. According to my knowledge binary search can be used if the list is sorted. Here the days are not in sorted order.\\nThen How?\\nThere is little difference between both codes.\\nIn the first one, I am trying to validate all the possible days.\\nIn the second one, I am validating the middle day. If the day can make m bouquets of size k then we will look at the day less than it or else i will increase the day.\\n```\\nclass Solution {\\npublic:\\n    bool canWeMake(vector<int> & bloomDay, int m, int k, int t){\\n        int count = 0;\\n        \\n       for(int i = 0; i < bloomDay.size(); i++){\\n           \\n           if(bloomDay[i] <= t){\\n               count++;\\n               if(count == k){\\n                   count = 0;\\n                   m--;\\n                   if(!m) return true;\\n               }\\n           }\\n           else{\\n               count = 0;\\n           }\\n       }\\n        return !m ? true : false;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int left = *min_element(bloomDay.begin(), bloomDay.end());\\n        int right = *max_element(bloomDay.begin(), bloomDay.end());\\n        if (m * k > bloomDay.size())\\n        return -1;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(canWeMake(bloomDay, m, k, mid)){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWeMake(vector<int> & bloomDay, int m, int k, int t){\\n        int count = 0;\\n        \\n       for(int i = 0; i < bloomDay.size(); i++){\\n           \\n           if(bloomDay[i] <= t){\\n               count++;\\n               if(count == k){\\n                   count = 0;\\n                   m--;\\n                   if(!m) return true;\\n               }\\n           }\\n           else{\\n               count = 0;\\n           }\\n       }\\n        return !m ? true : false;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        priority_queue<int> pq(bloomDay.begin(), bloomDay.end());\\n        int res = -1;\\n        while(!pq.empty()){\\n            auto t = pq.top();\\n            if(canWeMake(bloomDay, m, k, t)){\\n                res = t;\\n            }\\n            pq.pop();\\n        }\\n        return res == -1 ? -1 : res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canWeMake(vector<int> & bloomDay, int m, int k, int t){\\n        int count = 0;\\n        \\n       for(int i = 0; i < bloomDay.size(); i++){\\n           \\n           if(bloomDay[i] <= t){\\n               count++;\\n               if(count == k){\\n                   count = 0;\\n                   m--;\\n                   if(!m) return true;\\n               }\\n           }\\n           else{\\n               count = 0;\\n           }\\n       }\\n        return !m ? true : false;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int left = *min_element(bloomDay.begin(), bloomDay.end());\\n        int right = *max_element(bloomDay.begin(), bloomDay.end());\\n        if (m * k > bloomDay.size())\\n        return -1;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(canWeMake(bloomDay, m, k, mid)){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686299,
                "title": "binary-search-easy-with-hint-on-how-to-identify",
                "content": "This solution was a little tricky, not in thought but in implementation, I figured out the binary search approach in 5 mins, the check function took a few fails to understand properly (even though that part was basically heavily hinted by question description examples).\\n\\nFor those who don\\'t understand a binary search problem easily, they usually involve a continuous range you have to check and this range does not necessarily consist of the input array and the solution demands min or max in that range where the solution changes from false to true or vice versa.\\n\\nQuestions that are similar and will help get this idea down:\\n#### EASY: \\n* [First Bad Version](https://leetcode.com/problems/first-bad-version/) | **Same template you don\\'t have to write condition yourself**\\n#### MEDIUM: \\n* [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/) | [**Solution**](https://leetcode.com/problems/koko-eating-bananas/discuss/603208/Binary-Search)\\n* [Capacity to ship packages within d days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/) | [**Solution**](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/665176/Basic-Binary-Search-Solution)\\n#### HARD: \\n* [Split Largest Sum Array Problem](https://leetcode.com/problems/split-array-largest-sum/submissions/) | **Same as capacity to ship pacakges**\\n\\nHere is a link to a video by Errichto that I didn\\'t understand first time I watched, but definitely helped me get an intuition for when to use binary search and how - [Link](https://www.youtube.com/watch?v=GU7DpgHINWQ)\\n\\nUnderstanding things like lower_bound, upper_bound and doing questions like find sq root using binary search, search in sorted rotated array, search minimum in rotated sorted array also help and they also help in questions based on sorting, binary search trees, priority queues and such.\\n```\\nbool check(int mid, vector<int> &bl, int m, int k) {\\n    int nk = k, i = 0;\\n    while(i < bl.size()) {\\n        while(nk && i < bl.size() && (bl[i] - mid) <= 0) {\\n            nk--;\\n            i++;\\n        }\\n        if(!nk)\\n            m--;\\n        nk = k;\\n        if(i < bl.size() && (bl[i] - mid) > 0)\\n            i++;\\n    }\\n    return m <= 0;\\n}\\n\\nint minDays(vector<int>& bloomDay, int m, int k) {\\n    int l = *min_element(begin(bloomDay), end(bloomDay));\\n    int r = *max_element(begin(bloomDay), end(bloomDay));\\n    while(l < r) {\\n        int mid = l + (r-l)/2;\\n        if(check(mid, bloomDay, m, k))\\n            r = mid;\\n        else\\n            l = mid + 1;\\n    }\\n    return check(r, bloomDay, m, k) ? l: -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool check(int mid, vector<int> &bl, int m, int k) {\\n    int nk = k, i = 0;\\n    while(i < bl.size()) {\\n        while(nk && i < bl.size() && (bl[i] - mid) <= 0) {\\n            nk--;\\n            i++;\\n        }\\n        if(!nk)\\n            m--;\\n        nk = k;\\n        if(i < bl.size() && (bl[i] - mid) > 0)\\n            i++;\\n    }\\n    return m <= 0;\\n}\\n\\nint minDays(vector<int>& bloomDay, int m, int k) {\\n    int l = *min_element(begin(bloomDay), end(bloomDay));\\n    int r = *max_element(begin(bloomDay), end(bloomDay));\\n    while(l < r) {\\n        int mid = l + (r-l)/2;\\n        if(check(mid, bloomDay, m, k))\\n            r = mid;\\n        else\\n            l = mid + 1;\\n    }\\n    return check(r, bloomDay, m, k) ? l: -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686253,
                "title": "java-binary-search-with-comments-o-logn",
                "content": "When it comes to search problem within a range, the first thing comes into my mind is binary serach.\\n\\n```\\n\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < m*k) return -1;\\n        //because 1 <= bloomDay[i] <= 10^9, we can set binary search range to be:\\n        int lo = 0, hi = (int) 1e9;\\n        while(lo < hi){\\n            int mid = lo +(hi-lo)/2;\\n            if(valid(mid,bloomDay,m,k)){\\n                hi = mid;//as we want the minimum number of days, keep searching\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    boolean valid(int day, int[] bloomDay, int m, int flowerCnt){\\n        int curFlowerCnt=0;\\n        for(int i = 0; i<bloomDay.length; i++){\\n            //if current flower bloomed and we have enough flowers, go to next garden\\n            if((bloomDay[i] <= day) && (++curFlowerCnt == flowerCnt)){\\n                //reset flowerCnt for next garden\\n                curFlowerCnt = 0;\\n                if(--m == 0) return true;\\n            }else if(bloomDay[i] > day){\\n                //reset flowerCnt as we need continuous flowers\\n                curFlowerCnt = 0;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < m*k) return -1;\\n        //because 1 <= bloomDay[i] <= 10^9, we can set binary search range to be:\\n        int lo = 0, hi = (int) 1e9;\\n        while(lo < hi){\\n            int mid = lo +(hi-lo)/2;\\n            if(valid(mid,bloomDay,m,k)){\\n                hi = mid;//as we want the minimum number of days, keep searching\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    boolean valid(int day, int[] bloomDay, int m, int flowerCnt){\\n        int curFlowerCnt=0;\\n        for(int i = 0; i<bloomDay.length; i++){\\n            //if current flower bloomed and we have enough flowers, go to next garden\\n            if((bloomDay[i] <= day) && (++curFlowerCnt == flowerCnt)){\\n                //reset flowerCnt for next garden\\n                curFlowerCnt = 0;\\n                if(--m == 0) return true;\\n            }else if(bloomDay[i] > day){\\n                //reset flowerCnt as we need continuous flowers\\n                curFlowerCnt = 0;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686236,
                "title": "a-bit-faster-than-binary-search-java-n-log-n",
                "content": "As @hairyCoder mentioned in the comments, this solution is not as strightforwrd as binary search tree, but considering the fact that the length of array is smaller than the value of the biggest element, it\\'s on paper slightly better than BS :) Although it\\'s harder to understand and needs O(n) of space as @linweijie mentioned\\n\\n\\n\\n    TreeSet<Integer> treeSetOfRemovedIndexes;\\n    int totalPossibleBanquets;\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        if (m * k > n) {\\n            return -1;\\n        }\\n        TreeMap<Integer, TreeSet<Integer>> tm = buildTreeMap(bloomDay); // new TreeMap<>();\\n        Integer high = tm.lastKey();\\n        treeSetOfRemovedIndexes = new TreeSet<>();\\n        treeSetOfRemovedIndexes.add(-1);\\n        treeSetOfRemovedIndexes.add(n);\\n        totalPossibleBanquets = n /k;\\n        while (high != null) {\\n            TreeSet<Integer> ts = tm.get(high);\\n            if (cannotMakeDesiredBanquets(ts, m, k)) {\\n                return high;\\n            }\\n            high = tm.lowerKey(high);\\n        }\\n        return tm.firstKey();\\n    }\\n\\n    private TreeMap<Integer, TreeSet<Integer>> buildTreeMap(int[] bloomDay) {\\n        TreeMap<Integer, TreeSet<Integer>> tm = new TreeMap<>();\\n        for (int i = 0; i < bloomDay.length; ++i) {\\n            int n = bloomDay[i];\\n            if (!tm.containsKey(n)) {\\n                tm.put(n, new TreeSet<>());\\n            }\\n            tm.get(n).add(i);\\n        }\\n        return tm;\\n    }\\n\\n    private boolean cannotMakeDesiredBanquets(TreeSet<Integer> ts, int m, int k) {\\n        for (int i : ts) {\\n            int higherKey = treeSetOfRemovedIndexes.higher(i);\\n            int lowerKey = treeSetOfRemovedIndexes.lower(i);\\n            totalPossibleBanquets -= (higherKey - lowerKey - 1) / k;\\n            totalPossibleBanquets += (higherKey - i - 1) / k;\\n            totalPossibleBanquets += (i - lowerKey - 1) / k;\\n            treeSetOfRemovedIndexes.add(i);\\n        }\\n        return totalPossibleBanquets < m;\\n    }",
                "solutionTags": [],
                "code": "As @hairyCoder mentioned in the comments, this solution is not as strightforwrd as binary search tree, but considering the fact that the length of array is smaller than the value of the biggest element, it\\'s on paper slightly better than BS :) Although it\\'s harder to understand and needs O(n) of space as @linweijie mentioned\\n\\n\\n\\n    TreeSet<Integer> treeSetOfRemovedIndexes;\\n    int totalPossibleBanquets;\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        if (m * k > n) {\\n            return -1;\\n        }\\n        TreeMap<Integer, TreeSet<Integer>> tm = buildTreeMap(bloomDay); // new TreeMap<>();\\n        Integer high = tm.lastKey();\\n        treeSetOfRemovedIndexes = new TreeSet<>();\\n        treeSetOfRemovedIndexes.add(-1);\\n        treeSetOfRemovedIndexes.add(n);\\n        totalPossibleBanquets = n /k;\\n        while (high != null) {\\n            TreeSet<Integer> ts = tm.get(high);\\n            if (cannotMakeDesiredBanquets(ts, m, k)) {\\n                return high;\\n            }\\n            high = tm.lowerKey(high);\\n        }\\n        return tm.firstKey();\\n    }\\n\\n    private TreeMap<Integer, TreeSet<Integer>> buildTreeMap(int[] bloomDay) {\\n        TreeMap<Integer, TreeSet<Integer>> tm = new TreeMap<>();\\n        for (int i = 0; i < bloomDay.length; ++i) {\\n            int n = bloomDay[i];\\n            if (!tm.containsKey(n)) {\\n                tm.put(n, new TreeSet<>());\\n            }\\n            tm.get(n).add(i);\\n        }\\n        return tm;\\n    }\\n\\n    private boolean cannotMakeDesiredBanquets(TreeSet<Integer> ts, int m, int k) {\\n        for (int i : ts) {\\n            int higherKey = treeSetOfRemovedIndexes.higher(i);\\n            int lowerKey = treeSetOfRemovedIndexes.lower(i);\\n            totalPossibleBanquets -= (higherKey - lowerKey - 1) / k;\\n            totalPossibleBanquets += (higherKey - i - 1) / k;\\n            totalPossibleBanquets += (i - lowerKey - 1) / k;\\n            treeSetOfRemovedIndexes.add(i);\\n        }\\n        return totalPossibleBanquets < m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3943437,
                "title": "optimal-solution-using-bs-on-answer-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are going to use the Binary Search algorithm to optimize the approach.\\n\\nThe primary objective of the Binary Search algorithm is to efficiently determine the appropriate half to eliminate, thereby reducing the search space by half. It does this by determining a specific condition that ensures that the target is not present in that half.\\n\\nNow, we are not given any sorted array on which we can apply binary search. But, if we observe closely, we can notice that our answer space i.e. [mini(arr[]), max(arr[])] is sorted. So, we will apply binary search on the answer space.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **If m*k > arr.size:** This means we have insufficient flowers. So, it is impossible to make m bouquets and we will return -1.\\n2. Next, we will find the maximum element i.e. max(arr[]), and the minimum element i.e. min(arr[]) in the array.\\n3. Place the 2 pointers i.e. low and high: Initially, we will place the pointers. The pointer low will point to min(arr[]) and the high will point to max(arr[]).\\n4. Calculate the \\u2018mid\\u2019: Now, inside the loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\n    $$mid = (low+high) / 2$$\\n4. Eliminate the halves based on the value returned by possible():\\nWe will pass the potential answer, represented by the variable \\u2018mid\\u2019 (which corresponds to a specific day), to the \\u2018possible()\\u2019 function.\\n    1. If possible() returns true: On satisfying this condition, we can conclude that the number \\u2018mid\\u2019 is one of our possible answers. But we want the minimum number. So, we will eliminate the right half and consider the left half(i.e. high = mid-1).\\n    2. Otherwise, the value mid is smaller than the number we want. This means the numbers greater than \\u2018mid\\u2019 should be considered and the right half of \\u2018mid\\u2019 consists of such numbers. So, we will eliminate the left half and consider the right half(i.e. low = mid+1).\\n6. Finally, outside the loop, we will return the value of low as the pointer will be pointing to the answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int days,vector<int>& bloomDay,int m,int k) {\\n        int count = 0;\\n        int n = bloomDay.size();\\n        int buoquetCount = 0;\\n\\n        for(int i=0;i<n;i++) {\\n            if(days >= bloomDay[i]) {\\n                count++;\\n            }\\n            else {\\n                buoquetCount += (count/k);\\n                count = 0;\\n            }\\n        }\\n        buoquetCount += (count/k);\\n\\n        if(buoquetCount >= m)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n       long long val = m * 1ll * k * 1ll;\\n        int n = bloomDay.size(); //size of the array\\n        if (val > n) return -1; //impossible case.\\n\\n        int low = *min_element(bloomDay.begin(),bloomDay.end());\\n\\n        int high = *max_element(bloomDay.begin(),bloomDay.end());\\n\\n        int ans = high;\\n\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            if(isPossible(mid,bloomDay,m,k)) {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else {\\n                low = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int days,vector<int>& bloomDay,int m,int k) {\\n        int count = 0;\\n        int n = bloomDay.size();\\n        int buoquetCount = 0;\\n\\n        for(int i=0;i<n;i++) {\\n            if(days >= bloomDay[i]) {\\n                count++;\\n            }\\n            else {\\n                buoquetCount += (count/k);\\n                count = 0;\\n            }\\n        }\\n        buoquetCount += (count/k);\\n\\n        if(buoquetCount >= m)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n       long long val = m * 1ll * k * 1ll;\\n        int n = bloomDay.size(); //size of the array\\n        if (val > n) return -1; //impossible case.\\n\\n        int low = *min_element(bloomDay.begin(),bloomDay.end());\\n\\n        int high = *max_element(bloomDay.begin(),bloomDay.end());\\n\\n        int ans = high;\\n\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            if(isPossible(mid,bloomDay,m,k)) {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else {\\n                low = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931399,
                "title": "simple-c-solution",
                "content": "# Linearly Iterating\\nIn this approach we will loop thorugh all the possible solutions linearly\\n```\\nclass Solution {\\npublic:\\n    void arrayMinMax(vector<int> &bloomDay,int &minElement,int &maxElement){\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<minElement){\\n                minElement=bloomDay[i];\\n            }\\n            if(bloomDay[i]>maxElement){\\n                maxElement=bloomDay[i];\\n            }\\n        }\\n    }\\n    bool isPossible(vector<int> &bloomDay,int days,int m,int k){\\n        int count=0,numOfBouq=0;\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<=days){\\n                count++;\\n            }\\n            else{\\n                numOfBouq+=count/k;\\n                count=0;\\n            }\\n        }\\n        numOfBouq+=count/k;\\n        return numOfBouq>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int minDays=INT_MAX,maxDays=INT_MIN;\\n        arrayMinMax(bloomDay,minDays,maxDays);\\n        for(int i=minDays;i<=maxDays;i++){\\n            if(isPossible(bloomDay,i,m,k)){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# Binary Search\\nIn this approach we will be applying binary search on the possible answers/solutions\\n```\\nclass Solution {\\npublic:\\n    void arrayMinMax(vector<int> &bloomDay,int &minElement,int &maxElement){\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<minElement){\\n                minElement=bloomDay[i];\\n            }\\n            if(bloomDay[i]>maxElement){\\n                maxElement=bloomDay[i];\\n            }\\n        }\\n    }\\n    bool isPossible(vector<int> &bloomDay,int days,int m,int k){\\n        int count=0,numOfBouq=0;\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<=days){\\n                count++;\\n            }\\n            else{\\n                numOfBouq+=count/k;\\n                count=0;\\n            }\\n        }\\n        numOfBouq+=count/k;\\n        return numOfBouq>=m;\\n    }\\n    int minDays(vector<int> &bloomDay,int m,int k){\\n        // Edge case\\n        long long val=m*1ll*k*1ll;\\n        int n=bloomDay.size();\\n        if(val>n){\\n            return -1;\\n        }\\n\\n        int low=INT_MAX,high=INT_MIN;\\n        arrayMinMax(bloomDay,low,high);\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isPossible(bloomDay,mid,m,k)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void arrayMinMax(vector<int> &bloomDay,int &minElement,int &maxElement){\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<minElement){\\n                minElement=bloomDay[i];\\n            }\\n            if(bloomDay[i]>maxElement){\\n                maxElement=bloomDay[i];\\n            }\\n        }\\n    }\\n    bool isPossible(vector<int> &bloomDay,int days,int m,int k){\\n        int count=0,numOfBouq=0;\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<=days){\\n                count++;\\n            }\\n            else{\\n                numOfBouq+=count/k;\\n                count=0;\\n            }\\n        }\\n        numOfBouq+=count/k;\\n        return numOfBouq>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int minDays=INT_MAX,maxDays=INT_MIN;\\n        arrayMinMax(bloomDay,minDays,maxDays);\\n        for(int i=minDays;i<=maxDays;i++){\\n            if(isPossible(bloomDay,i,m,k)){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void arrayMinMax(vector<int> &bloomDay,int &minElement,int &maxElement){\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<minElement){\\n                minElement=bloomDay[i];\\n            }\\n            if(bloomDay[i]>maxElement){\\n                maxElement=bloomDay[i];\\n            }\\n        }\\n    }\\n    bool isPossible(vector<int> &bloomDay,int days,int m,int k){\\n        int count=0,numOfBouq=0;\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<=days){\\n                count++;\\n            }\\n            else{\\n                numOfBouq+=count/k;\\n                count=0;\\n            }\\n        }\\n        numOfBouq+=count/k;\\n        return numOfBouq>=m;\\n    }\\n    int minDays(vector<int> &bloomDay,int m,int k){\\n        // Edge case\\n        long long val=m*1ll*k*1ll;\\n        int n=bloomDay.size();\\n        if(val>n){\\n            return -1;\\n        }\\n\\n        int low=INT_MAX,high=INT_MIN;\\n        arrayMinMax(bloomDay,low,high);\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isPossible(bloomDay,mid,m,k)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893349,
                "title": "simple-and-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool possible(vector<int>& bloomDay,int day, int m, int k){\\n        int cnt = 0;\\n        int noofB = 0;\\n        for(int i = 0;i<bloomDay.size();i++){\\n            if(bloomDay[i] <= day){\\n                cnt++;\\n            }\\n            else{\\n                noofB += (cnt/k);\\n                cnt = 0;\\n            }\\n        }\\n        noofB += (cnt/k);\\n        if(noofB >= m){\\n            return 1;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        \\n        long long val = m * 1ll * k * 1ll;\\n        if(val > bloomDay.size()){\\n            return -1;\\n        }\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        for(int i = 0;i<bloomDay.size();i++){\\n            mini = min(mini,bloomDay[i]);\\n            maxi = max(maxi,bloomDay[i]);\\n        }\\n\\n        int low = mini, high = maxi;\\n        int ans = high;\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n\\n            if(possible(bloomDay,mid,m,k)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possible(vector<int>& bloomDay,int day, int m, int k){\\n        int cnt = 0;\\n        int noofB = 0;\\n        for(int i = 0;i<bloomDay.size();i++){\\n            if(bloomDay[i] <= day){\\n                cnt++;\\n            }\\n            else{\\n                noofB += (cnt/k);\\n                cnt = 0;\\n            }\\n        }\\n        noofB += (cnt/k);\\n        if(noofB >= m){\\n            return 1;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        \\n        long long val = m * 1ll * k * 1ll;\\n        if(val > bloomDay.size()){\\n            return -1;\\n        }\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        for(int i = 0;i<bloomDay.size();i++){\\n            mini = min(mini,bloomDay[i]);\\n            maxi = max(maxi,bloomDay[i]);\\n        }\\n\\n        int low = mini, high = maxi;\\n        int ans = high;\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n\\n            if(possible(bloomDay,mid,m,k)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820610,
                "title": "c-super-easy-clean-code-binary-search-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n        int n = bloomDay.size();\\n        if(1LL* m * k > n) return -1;\\n\\n        int low = bloomDay[0];\\n        int high = low;\\n\\n        for(int i=1; i<n; i++){\\n            low = min(low,bloomDay[i]);\\n            high = max(high,bloomDay[i]);\\n        }\\n\\n        while(low < high){\\n            int mid = low + (high - low) / 2;\\n\\n            int total = 0;\\n            int count = 0;\\n\\n            for(int i=0; i<n; i++){\\n                if(bloomDay[i] > mid){\\n                    total += count/k;\\n                    count = 0;\\n                }\\n                else{\\n                    count++;\\n                }\\n            }\\n\\n            total += count/k;\\n\\n            if(total < m){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid;\\n            }\\n\\n        }\\n\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n        int n = bloomDay.size();\\n        if(1LL* m * k > n) return -1;\\n\\n        int low = bloomDay[0];\\n        int high = low;\\n\\n        for(int i=1; i<n; i++){\\n            low = min(low,bloomDay[i]);\\n            high = max(high,bloomDay[i]);\\n        }\\n\\n        while(low < high){\\n            int mid = low + (high - low) / 2;\\n\\n            int total = 0;\\n            int count = 0;\\n\\n            for(int i=0; i<n; i++){\\n                if(bloomDay[i] > mid){\\n                    total += count/k;\\n                    count = 0;\\n                }\\n                else{\\n                    count++;\\n                }\\n            }\\n\\n            total += count/k;\\n\\n            if(total < m){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid;\\n            }\\n\\n        }\\n\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3775049,
                "title": "c-binary-search-easy-to-understand",
                "content": "CODE:\\n```\\nclass Solution {\\npublic:\\n    \\n    bool possible(vector<int>&bloomDay,int day,int m,int k) {\\n        int count =0;\\n        int numB = 0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            if(bloomDay[i] <= day)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n               numB+=(count/k);\\n                count = 0;\\n            }\\n        }\\n        numB+=(count/k);\\n        return numB>=m; // returning true if number of Bouquests greater than or equal to m\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(bloomDay.size() < (long long)((long long )m*k)) return -1; // we have to typecast here because if we dont it will result in integer overflow as 10^9 is constraints \\n        \\n      int low  = *min_element(bloomDay.begin(),bloomDay.end()); \\n      int high =  *max_element(bloomDay.begin(),bloomDay.end());\\n        \\n        while(low<=high)\\n        {\\n            long long mid = low+(high-low)/2;\\n            \\n            if(possible(bloomDay,mid,m,k))\\n            {\\n                high  = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n        \\n    }\\n};\\n```\\nWhy do we return low here\\nWe return low here because suppose we we dont  find a possibility to use that bloomday then we eliminate one part of the search space and do low = mid+1; by doing this we are basically guiding our low from not possible state to possible state and thus we return low.\\n\\nDry run once and u will understand it better.\\n\\nKindly upvote if u find it helpful :))",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool possible(vector<int>&bloomDay,int day,int m,int k) {\\n        int count =0;\\n        int numB = 0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            if(bloomDay[i] <= day)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n               numB+=(count/k);\\n                count = 0;\\n            }\\n        }\\n        numB+=(count/k);\\n        return numB>=m; // returning true if number of Bouquests greater than or equal to m\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(bloomDay.size() < (long long)((long long )m*k)) return -1; // we have to typecast here because if we dont it will result in integer overflow as 10^9 is constraints \\n        \\n      int low  = *min_element(bloomDay.begin(),bloomDay.end()); \\n      int high =  *max_element(bloomDay.begin(),bloomDay.end());\\n        \\n        while(low<=high)\\n        {\\n            long long mid = low+(high-low)/2;\\n            \\n            if(possible(bloomDay,mid,m,k))\\n            {\\n                high  = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766107,
                "title": "binary-search-easy-to-understand-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < (long)m*k) return -1;\\n        int max = 0, min = Integer.MAX_VALUE;\\n        for(int day:bloomDay){\\n            max = Math.max(max, day);\\n            min = Math.min(min, day);\\n        }\\n        int start = min, end = max;\\n        while(start<end){\\n            int mid = start+(end-start)/2;\\n            int bouquet = computeDays(bloomDay, k, mid);\\n            if(bouquet<m){\\n                start = mid+1;\\n            }\\n            else end = mid;\\n        }\\n        return start;\\n    }\\n    private int computeDays(int[] bloomDay, int k, int day){\\n        int b = 0;\\n        int currFlower = 0;\\n        for(int i=0;i<bloomDay.length;i++>){\\n            if(bloomDay[i]>day){\\n                currFlower = 0;\\n            }\\n            else{\\n                currFlower++;\\n                if(currFlower>=k){\\n                    currFlower = 0;\\n                    b++;\\n                }\\n            }\\n        }\\n        return b;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < (long)m*k) return -1;\\n        int max = 0, min = Integer.MAX_VALUE;\\n        for(int day:bloomDay){\\n            max = Math.max(max, day);\\n            min = Math.min(min, day);\\n        }\\n        int start = min, end = max;\\n        while(start<end){\\n            int mid = start+(end-start)/2;\\n            int bouquet = computeDays(bloomDay, k, mid);\\n            if(bouquet<m){\\n                start = mid+1;\\n            }\\n            else end = mid;\\n        }\\n        return start;\\n    }\\n    private int computeDays(int[] bloomDay, int k, int day){\\n        int b = 0;\\n        int currFlower = 0;\\n        for(int i=0;i<bloomDay.length;i++>){\\n            if(bloomDay[i]>day){\\n                currFlower = 0;\\n            }\\n            else{\\n                currFlower++;\\n                if(currFlower>=k){\\n                    currFlower = 0;\\n                    b++;\\n                }\\n            }\\n        }\\n        return b;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721917,
                "title": "binary-search-java-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int max = bloomDay[0];\\n        int min = bloomDay[0];\\n        for(int i = 0;i<bloomDay.length;i++)\\n        {\\n            min = Math.min(min,bloomDay[i]);\\n            max = Math.max(max,bloomDay[i]);\\n        }\\n        int ans = -1;\\n        while(min<=max)\\n        {\\n            int mid = min + (max-min)/2;\\n            boolean can = calc(bloomDay,mid,m,k);\\n            if(can == true)\\n            {\\n                ans = mid;\\n                max = mid - 1;\\n            }\\n            else\\n            min = mid + 1;\\n        }\\n        return ans;\\n    }\\n    public boolean calc(int[] a , int days, int m ,int k)\\n    {\\n        int no=0;\\n        int c = 0;\\n        for(int i = 0;i<a.length;i++)\\n        {\\n            if(a[i]<=days)\\n            c++;\\n            else\\n            {\\n                no = no + (c/k);\\n                c=0;\\n            }\\n        }\\n        no = no + (c/k);\\n        if(no>=m)\\n        return true;\\n        else\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int max = bloomDay[0];\\n        int min = bloomDay[0];\\n        for(int i = 0;i<bloomDay.length;i++)\\n        {\\n            min = Math.min(min,bloomDay[i]);\\n            max = Math.max(max,bloomDay[i]);\\n        }\\n        int ans = -1;\\n        while(min<=max)\\n        {\\n            int mid = min + (max-min)/2;\\n            boolean can = calc(bloomDay,mid,m,k);\\n            if(can == true)\\n            {\\n                ans = mid;\\n                max = mid - 1;\\n            }\\n            else\\n            min = mid + 1;\\n        }\\n        return ans;\\n    }\\n    public boolean calc(int[] a , int days, int m ,int k)\\n    {\\n        int no=0;\\n        int c = 0;\\n        for(int i = 0;i<a.length;i++)\\n        {\\n            if(a[i]<=days)\\n            c++;\\n            else\\n            {\\n                no = no + (c/k);\\n                c=0;\\n            }\\n        }\\n        no = no + (c/k);\\n        if(no>=m)\\n        return true;\\n        else\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586422,
                "title": "detailed-explanation-intuition-c-solution-binary-search",
                "content": "# Intuition\\nThis problem is similar to \\'Koko eating bananas\\' problem. Solve this problem to understand the intuition.\\nHere is the problem link:\\nhttps://leetcode.com/problems/koko-eating-bananas/\\n\\nHere is the brief of the intuition:\\n1. Firstly, if totalFlowers = (m * k) is greater than size of the array then, we cannot make the required bouquets.\\n2. Find the max element from the array then, we have a search space from [1 to max(bloomDay)]. This represents all the possible days. We need to minimize the number of required days.\\n\\nExample, bloomDay = {1, 2, 5, 10, 3, 4}\\nSearch space = [1 ------- 10]\\n\\n3. Apply binary search to the search space.\\n4. With each mid element found, check whether we are able to get the required number of bouquets.\\n5. If (bouquets >= m), update answer and move to the left part of the search space (high = mid - 1). Else, move to the right part of the search space (low = mid + 1).\\n\\n# Approach\\nApproach for the minDays() function is pretty straight forward. We just need to apply binary search.\\n\\nLet us see the approach for possibleBouquets() function.\\n\\nConsider mid = 9\\nbloomDay = {7, 7, 7, 7, 12, 7, 7}\\nLet us make an array which contains 1 for (elem <= mid) else 0\\n**[Note: we are not using any extra array, this is just for demonstration]**\\naux Array = {1, 1, 1, 1, 0, 1, 1}\\nLet the adjacent flowers, k = 3\\n\\nUntil 0, we have count = 4. Therefore 1 bouquet can be made (4 > 3).\\nAfter 0, count = 2. No bouquet can be formed as there are only 2 adjacent flowers.\\n\\nTherefore total bouquets = 1 + 0 = 1\\nReturn the number of bouquets.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int possibleBouquets(vector<int> &bloomDay, int n, int k, long long mid) {\\n\\n        int bouquets = 0, adjCount = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(bloomDay[i] <= mid) {\\n                adjCount++;\\n            }\\n            else {\\n                bouquets += (adjCount / k);\\n                adjCount = 0;\\n            }\\n        } \\n\\n        bouquets += (adjCount / k);\\n\\n        return bouquets;\\n\\n    }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        \\n        int n = bloomDay.size();\\n\\n        if(n < (long long)m * k)\\n            return -1;\\n\\n        long long low = 1, high = *max_element(bloomDay.begin(), bloomDay.end());\\n        long long ans = high;\\n\\n        while(low <= high) {\\n            long long mid = (low + high) >> 1;\\n\\n            int bouquets = possibleBouquets(bloomDay, n, k, mid);\\n\\n            if(bouquets >= m) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity:\\n**O(n * log(max(bloomDay)))**\\n\\nWe are using a search space from 1 to max(blommDay) and apply binary search. Therefore, log(max(bloomDay)).\\nWith each mid element, we are traversing the complete array of size n.\\nTherfore, total complexity is: O(n * log(max(bloomDay)))\\n\\n- Space complexity:\\n**O(1)**\\nWe are not using any extra space.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int possibleBouquets(vector<int> &bloomDay, int n, int k, long long mid) {\\n\\n        int bouquets = 0, adjCount = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(bloomDay[i] <= mid) {\\n                adjCount++;\\n            }\\n            else {\\n                bouquets += (adjCount / k);\\n                adjCount = 0;\\n            }\\n        } \\n\\n        bouquets += (adjCount / k);\\n\\n        return bouquets;\\n\\n    }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        \\n        int n = bloomDay.size();\\n\\n        if(n < (long long)m * k)\\n            return -1;\\n\\n        long long low = 1, high = *max_element(bloomDay.begin(), bloomDay.end());\\n        long long ans = high;\\n\\n        while(low <= high) {\\n            long long mid = (low + high) >> 1;\\n\\n            int bouquets = possibleBouquets(bloomDay, n, k, mid);\\n\\n            if(bouquets >= m) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330075,
                "title": "we-dont-need-1e9-as-end-great-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMany of you are thinking that why are we taking end as 1e9 thats a large no then finding mid and soo on.\\nInstead we take the max element of the array which is maximum no of days it cant exceed that limit so why dont we take and the ans is yes \\nwhich is great for not checking the infite no of mid and finding the solution here is the solution......\\n\\nhope u like it and pls upvote :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& v,int m,int k,int mid){\\n        int tot=0,bough=0;\\n        for(int i=0;i<v.size();i++){\\n            \\n            if(v[i]<=mid){\\n                bough++;\\n                if(bough==k){\\n                    tot++;\\n                    bough=0;\\n                }\\n            }\\n            else bough=0;\\n        }\\n        if(tot>=m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        // if(m*k>bloomDay.size()) return -1;\\n        int maxi=-1;\\n        for(int i=0;i<bloomDay.size();i++){\\n            maxi=max(maxi,bloomDay[i]);\\n        }\\n        int low=0,high=maxi;\\n        int result=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isValid(bloomDay,m,k,mid)){\\n                result=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& v,int m,int k,int mid){\\n        int tot=0,bough=0;\\n        for(int i=0;i<v.size();i++){\\n            \\n            if(v[i]<=mid){\\n                bough++;\\n                if(bough==k){\\n                    tot++;\\n                    bough=0;\\n                }\\n            }\\n            else bough=0;\\n        }\\n        if(tot>=m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        // if(m*k>bloomDay.size()) return -1;\\n        int maxi=-1;\\n        for(int i=0;i<bloomDay.size();i++){\\n            maxi=max(maxi,bloomDay[i]);\\n        }\\n        int low=0,high=maxi;\\n        int result=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isValid(bloomDay,m,k,mid)){\\n                result=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203417,
                "title": "binary-search-in-rust",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n    pub fn min_days(bloom_day: Vec<i32>, m: i32, k: i32) -> i32 {\\n        let gg = *bloom_day.iter().max().unwrap();\\n        let (mut min, mut max) = (0, gg + 1);\\n        let mut mid;\\n        while min < max {\\n            mid = (min + max) / 2;\\n\\n            if Self::can_bloom(mid, &bloom_day, m, k) {\\n                max = mid;\\n            } else {\\n                min = mid + 1;\\n            }\\n        }\\n\\n        if min > gg { -1 } else { min }\\n    }\\n\\n    fn can_bloom(day: i32, days: &Vec<i32>, m: i32, k: i32) -> bool {\\n        let k = k as usize;\\n        let (mut prev, mut ans) = (0, 0);\\n        for i in 0..days.len() {\\n            if days[i] <= day {\\n                if 1 + i - prev == k {\\n                    ans += 1;\\n                    prev = i + 1;\\n                }\\n            } else {\\n                prev = i + 1;\\n            }\\n            if ans == m { return true }\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n    pub fn min_days(bloom_day: Vec<i32>, m: i32, k: i32) -> i32 {\\n        let gg = *bloom_day.iter().max().unwrap();\\n        let (mut min, mut max) = (0, gg + 1);\\n        let mut mid;\\n        while min < max {\\n            mid = (min + max) / 2;\\n\\n            if Self::can_bloom(mid, &bloom_day, m, k) {\\n                max = mid;\\n            } else {\\n                min = mid + 1;\\n            }\\n        }\\n\\n        if min > gg { -1 } else { min }\\n    }\\n\\n    fn can_bloom(day: i32, days: &Vec<i32>, m: i32, k: i32) -> bool {\\n        let k = k as usize;\\n        let (mut prev, mut ans) = (0, 0);\\n        for i in 0..days.len() {\\n            if days[i] <= day {\\n                if 1 + i - prev == k {\\n                    ans += 1;\\n                    prev = i + 1;\\n                }\\n            } else {\\n                prev = i + 1;\\n            }\\n            if ans == m { return true }\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3132581,
                "title": "beats-99-7-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int bouqets, int flowersPerBouqet) {\\n        int n=bloomDay.size(),ans=INT_MAX;\\n        if(n<(long long )bouqets*flowersPerBouqet)\\n        {\\n            return -1;\\n        }\\n        int i=0,j=0;\\n        for(auto element:bloomDay)\\n        {\\n            j=max(j,element);\\n            i=min(i,element);\\n        }\\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            int temp_bouqets=bouqets,temp_flowersPerBouqet=flowersPerBouqet;\\n            for(auto element:bloomDay)\\n            {   \\n                if(element<=mid)\\n                {\\n                      temp_flowersPerBouqet--;    \\n                      if(temp_flowersPerBouqet==0)\\n                      {\\n                           temp_bouqets--;\\n                           if(temp_bouqets==0)\\n                            {\\n                                  break;\\n                            }\\n                          temp_flowersPerBouqet=flowersPerBouqet;\\n                      }\\n                }\\n                else{\\n                        temp_flowersPerBouqet=flowersPerBouqet;\\n                    }\\n             }\\n                 if(mid<=ans and temp_bouqets<=0)\\n                 {\\n                   ans=min(mid,ans);\\n                   j=mid-1;\\n                 }\\n                 else i=mid+1;\\n             \\n            } \\n            return ans;  \\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int bouqets, int flowersPerBouqet) {\\n        int n=bloomDay.size(),ans=INT_MAX;\\n        if(n<(long long )bouqets*flowersPerBouqet)\\n        {\\n            return -1;\\n        }\\n        int i=0,j=0;\\n        for(auto element:bloomDay)\\n        {\\n            j=max(j,element);\\n            i=min(i,element);\\n        }\\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            int temp_bouqets=bouqets,temp_flowersPerBouqet=flowersPerBouqet;\\n            for(auto element:bloomDay)\\n            {   \\n                if(element<=mid)\\n                {\\n                      temp_flowersPerBouqet--;    \\n                      if(temp_flowersPerBouqet==0)\\n                      {\\n                           temp_bouqets--;\\n                           if(temp_bouqets==0)\\n                            {\\n                                  break;\\n                            }\\n                          temp_flowersPerBouqet=flowersPerBouqet;\\n                      }\\n                }\\n                else{\\n                        temp_flowersPerBouqet=flowersPerBouqet;\\n                    }\\n             }\\n                 if(mid<=ans and temp_bouqets<=0)\\n                 {\\n                   ans=min(mid,ans);\\n                   j=mid-1;\\n                 }\\n                 else i=mid+1;\\n             \\n            } \\n            return ans;  \\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098773,
                "title": "easy-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple binary search appraoch\\nand if product of m and k is grater than size of vector then return -1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(max(v)))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(0)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bd, int m, int k) {\\n        int n=bd.size();\\n        long long pdt = (long long)m*k;\\n        if(pdt>n)\\n            return -1;\\n        int st=0; \\n        int en=*max_element(bd.begin(),bd.end());\\n        int ans=0;\\n        while(en>=st)\\n        {\\n            int mid=st+(en-st)/2;\\n            int countb=0,countc=0;\\n            for(int i=0; i<n; i++)\\n            {\\n                \\n                if(bd[i]<=mid)\\n                {\\n                    countc++;\\n                }\\n                if(countc==k)\\n                {\\n                    countb++;\\n                    countc=0;\\n                }\\n                if(bd[i]>mid)\\n                {\\n                    countc=0;\\n                }\\n            }\\n            if(countb>=m)\\n            {\\n                ans=mid;\\n                en=mid-1;\\n            }\\n            else{\\n                st=mid+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bd, int m, int k) {\\n        int n=bd.size();\\n        long long pdt = (long long)m*k;\\n        if(pdt>n)\\n            return -1;\\n        int st=0; \\n        int en=*max_element(bd.begin(),bd.end());\\n        int ans=0;\\n        while(en>=st)\\n        {\\n            int mid=st+(en-st)/2;\\n            int countb=0,countc=0;\\n            for(int i=0; i<n; i++)\\n            {\\n                \\n                if(bd[i]<=mid)\\n                {\\n                    countc++;\\n                }\\n                if(countc==k)\\n                {\\n                    countb++;\\n                    countc=0;\\n                }\\n                if(bd[i]>mid)\\n                {\\n                    countc=0;\\n                }\\n            }\\n            if(countb>=m)\\n            {\\n                ans=mid;\\n                en=mid-1;\\n            }\\n            else{\\n                st=mid+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073981,
                "title": "easy-variables-commented-code-c-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {    // Binary Search, O(nlog(max(bloomDay))) -> O(nlogn)\\npublic:\\n\\n    bool isPossible( vector<int>& bloomDay, int boqCnt, int flrCnt, int curDay ){\\n\\n        int adjCnt = 0;                 // count for number of adjacent bloomed flower we found\\n\\n        for( auto bDay : bloomDay ){    // iterate for all the flowers in bloomDay\\n\\n            if( bDay <= curDay )        // if the bloom day is smaller than current day, this means that the flower is bloomed, so increase adjacent count\\n                adjCnt++ ;\\n\\n            else adjCnt = 0;            // if the flower is not bloomed, reset adjacent count\\n\\n            if( adjCnt == flrCnt ){     // if the adjacent count becomes equal to the flower needed to make a single boquet\\n                boqCnt-- ;              // decrease the boquet count as we made one boquet\\n                adjCnt = 0 ;            // reset the adjacent count, as we will find new k adjacent flowers now\\n            }    \\n        }\\n\\n        if( boqCnt <= 0 ) return true;\\n\\n    return false;\\n}\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        \\n        // if the flowers needed to make all the m boquets that is m times k is greater than the provided flowers, its not possible to make the boquets, return -1\\n        if( (long long )m * k > bloomDay.size() ) return -1;   \\n\\n        int minDay = 1;          // minimum days for a flower to bloom, atleast 1 ofcourse\\n        int maxDay = 1000000000; // maximum day possible, according to constraints let it be 1e9, or we can use max(bloomDay)\\n\\n        while( minDay < maxDay ){   // while the minDay is smaller than maxDay\\n\\n            int curDay = minDay + ( maxDay - minDay )/2;  // let the curDay be the middle between minDay and maxDay\\n\\n            // if for the current day, we can make the m boquets, then lets try for a previous day, so shrink the search space starting from minDay to curDay\\n            if( isPossible( bloomDay, m, k, curDay ) )      \\n                maxDay = curDay ;\\n            \\n            // if we cant make m boquets at current day, lets try for a latter day, shrink the search space from, curDay to maxDay\\n            else minDay = curDay + 1; \\n\\n        }\\n    // return the minimum day we found \\n    return minDay;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {    // Binary Search, O(nlog(max(bloomDay))) -> O(nlogn)\\npublic:\\n\\n    bool isPossible( vector<int>& bloomDay, int boqCnt, int flrCnt, int curDay ){\\n\\n        int adjCnt = 0;                 // count for number of adjacent bloomed flower we found\\n\\n        for( auto bDay : bloomDay ){    // iterate for all the flowers in bloomDay\\n\\n            if( bDay <= curDay )        // if the bloom day is smaller than current day, this means that the flower is bloomed, so increase adjacent count\\n                adjCnt++ ;\\n\\n            else adjCnt = 0;            // if the flower is not bloomed, reset adjacent count\\n\\n            if( adjCnt == flrCnt ){     // if the adjacent count becomes equal to the flower needed to make a single boquet\\n                boqCnt-- ;              // decrease the boquet count as we made one boquet\\n                adjCnt = 0 ;            // reset the adjacent count, as we will find new k adjacent flowers now\\n            }    \\n        }\\n\\n        if( boqCnt <= 0 ) return true;\\n\\n    return false;\\n}\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        \\n        // if the flowers needed to make all the m boquets that is m times k is greater than the provided flowers, its not possible to make the boquets, return -1\\n        if( (long long )m * k > bloomDay.size() ) return -1;   \\n\\n        int minDay = 1;          // minimum days for a flower to bloom, atleast 1 ofcourse\\n        int maxDay = 1000000000; // maximum day possible, according to constraints let it be 1e9, or we can use max(bloomDay)\\n\\n        while( minDay < maxDay ){   // while the minDay is smaller than maxDay\\n\\n            int curDay = minDay + ( maxDay - minDay )/2;  // let the curDay be the middle between minDay and maxDay\\n\\n            // if for the current day, we can make the m boquets, then lets try for a previous day, so shrink the search space starting from minDay to curDay\\n            if( isPossible( bloomDay, m, k, curDay ) )      \\n                maxDay = curDay ;\\n            \\n            // if we cant make m boquets at current day, lets try for a latter day, shrink the search space from, curDay to maxDay\\n            else minDay = curDay + 1; \\n\\n        }\\n    // return the minimum day we found \\n    return minDay;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041542,
                "title": "binary-search",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MinDays(int[] bloomDay, int m, int k) {\\n        var n = bloomDay.Length;\\n\\n        if (n < m * k) {\\n            return -1;\\n        }\\n\\n        var left = 1;\\n        var right = 1000000000;\\n        var res = Int32.MaxValue;\\n\\n        while (left <= right) {\\n            var mid = left + (right - left) / 2;\\n\\n            var flowers = 0;\\n            var bouquets = 0;\\n            for (var i = 0; i < n; i++) {\\n                if (bloomDay[i] > mid) {\\n                    flowers = 0;\\n                    continue;\\n                } \\n                \\n                flowers++;\\n                if (flowers == k) {\\n                    flowers = 0;\\n                    bouquets++;\\n                    if (bouquets == m) {\\n                        res = Math.Min(res, mid);\\n                        break;\\n                    }\\n                }                \\n            }\\n\\n            if (bouquets >= m) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return res == Int32.MaxValue ? -1 : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinDays(int[] bloomDay, int m, int k) {\\n        var n = bloomDay.Length;\\n\\n        if (n < m * k) {\\n            return -1;\\n        }\\n\\n        var left = 1;\\n        var right = 1000000000;\\n        var res = Int32.MaxValue;\\n\\n        while (left <= right) {\\n            var mid = left + (right - left) / 2;\\n\\n            var flowers = 0;\\n            var bouquets = 0;\\n            for (var i = 0; i < n; i++) {\\n                if (bloomDay[i] > mid) {\\n                    flowers = 0;\\n                    continue;\\n                } \\n                \\n                flowers++;\\n                if (flowers == k) {\\n                    flowers = 0;\\n                    bouquets++;\\n                    if (bouquets == m) {\\n                        res = Math.Min(res, mid);\\n                        break;\\n                    }\\n                }                \\n            }\\n\\n            if (bouquets >= m) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return res == Int32.MaxValue ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961733,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\n    bool good(int x, vector<int> &bd, int m, int k) {\\n        int cnt = 0, n = 0;\\n        for(int i=0; i<bd.size(); i++) {\\n            bd[i] <= x ? n++ : n = 0;\\n            if(n == k) cnt++, n = 0;\\n        }\\n        return cnt < m ? false : true;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s = 0, e = 1e9, ans = INT_MAX;\\n        while(s <= e) {\\n            int mid = (s + e) / 2;\\n            if(good(mid, bloomDay, m, k)) ans = min(ans, mid), e = mid - 1;\\n            else s = mid + 1;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool good(int x, vector<int> &bd, int m, int k) {\\n        int cnt = 0, n = 0;\\n        for(int i=0; i<bd.size(); i++) {\\n            bd[i] <= x ? n++ : n = 0;\\n            if(n == k) cnt++, n = 0;\\n        }\\n        return cnt < m ? false : true;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s = 0, e = 1e9, ans = INT_MAX;\\n        while(s <= e) {\\n            int mid = (s + e) / 2;\\n            if(good(mid, bloomDay, m, k)) ans = min(ans, mid), e = mid - 1;\\n            else s = mid + 1;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929787,
                "title": "find-the-range-for-binary-search-and-apply-the-condition-mention-in-the-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {\\n        \\n        \\n        \\n        int n = b.size();\\n        if(long(m)*long(k)>n)\\n            return -1;\\n        int mn = INT_MAX;\\n        int mx = INT_MIN;\\n        \\n        \\n        for(auto i:b)\\n        {\\n            mn = min(mn,i);\\n            mx = max(mx,i);\\n        }\\n        \\n        \\n        int l,r;\\n        l = mn;\\n        r = mx;\\n        \\n        int res = 0;\\n        while(l<r)\\n        {\\n            int mid = (l+r)/2;\\n            int adj=0;\\n            res=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(b[i]<=mid)\\n                {\\n                    adj++;\\n                    if(adj == k){\\n                        res++;\\n                        adj=0;\\n                    }\\n                    if(res>=m)\\n                        break;\\n                }\\n                else\\n                {\\n                    adj=0;\\n                }\\n            }\\n            \\n            if(res<m)\\n            {\\n                l = mid+1;\\n            }\\n            else\\n                r = mid;\\n        }\\n        \\n        return r;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {\\n        \\n        \\n        \\n        int n = b.size();\\n        if(long(m)*long(k)>n)\\n            return -1;\\n        int mn = INT_MAX;\\n        int mx = INT_MIN;\\n        \\n        \\n        for(auto i:b)\\n        {\\n            mn = min(mn,i);\\n            mx = max(mx,i);\\n        }\\n        \\n        \\n        int l,r;\\n        l = mn;\\n        r = mx;\\n        \\n        int res = 0;\\n        while(l<r)\\n        {\\n            int mid = (l+r)/2;\\n            int adj=0;\\n            res=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(b[i]<=mid)\\n                {\\n                    adj++;\\n                    if(adj == k){\\n                        res++;\\n                        adj=0;\\n                    }\\n                    if(res>=m)\\n                        break;\\n                }\\n                else\\n                {\\n                    adj=0;\\n                }\\n            }\\n            \\n            if(res<m)\\n            {\\n                l = mid+1;\\n            }\\n            else\\n                r = mid;\\n        }\\n        \\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726172,
                "title": "c-easy-to-understand-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    /* we want to check can we make m bouquets at a day of mid or not */\\n    bool check(vector<int> &arr, int mid, int m, int k){\\n        int subarray = 0;\\n        int total = 0;\\n        for(int i = 0;i<arr.size();i++){\\n            if(arr[i] <= mid){\\n                total++;\\n            }\\n            else{\\n                if(total == k){\\n                    subarray++;\\n                }\\n                total = 0;\\n            }\\n            if(total == k){\\n                subarray++;\\n                total = 0;\\n            }\\n        }\\n        if(subarray >= m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& arr, int m, int k) {\\n        /* if m*k < total no. of flows then we can\\'t make m bouquets */\\n        if(((long long)m*(long long)k) > arr.size()) return -1;\\n        \\n        /* maximum days we can take as maximum element in the array after that all flows will get bloom  */\\n        int l = 1, r = *max_element(arr.begin(), arr.end());\\n        int ans = -1;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(check(arr, mid, m, k)){\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n\\t/* If you like the solution please upvote */\\n};\\n```\\n\\nIf you like the solution please upvote",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* we want to check can we make m bouquets at a day of mid or not */\\n    bool check(vector<int> &arr, int mid, int m, int k){\\n        int subarray = 0;\\n        int total = 0;\\n        for(int i = 0;i<arr.size();i++){\\n            if(arr[i] <= mid){\\n                total++;\\n            }\\n            else{\\n                if(total == k){\\n                    subarray++;\\n                }\\n                total = 0;\\n            }\\n            if(total == k){\\n                subarray++;\\n                total = 0;\\n            }\\n        }\\n        if(subarray >= m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& arr, int m, int k) {\\n        /* if m*k < total no. of flows then we can\\'t make m bouquets */\\n        if(((long long)m*(long long)k) > arr.size()) return -1;\\n        \\n        /* maximum days we can take as maximum element in the array after that all flows will get bloom  */\\n        int l = 1, r = *max_element(arr.begin(), arr.end());\\n        int ans = -1;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(check(arr, mid, m, k)){\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n\\t/* If you like the solution please upvote */\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608871,
                "title": "c-solution-fast-easy-efficient-readable-and-beginner-friendly",
                "content": "**If the solution helps you, please do consider upvoting it.**\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& bloomDay,int m,int k,int mid)\\n    {\\n        int count=0,size=0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            size=(bloomDay[i]<=mid) ?size+1 :0;\\n            if(size==k)\\n            {\\n                size=0;\\n                count++;\\n            }\\n            if(count==m)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) \\n    {\\n         if(bloomDay.size()==0 or m==0 or k==0)\\n             return 0;\\n        if(m*k>bloomDay.size())\\n            return -1;\\n        int left=*min_element(bloomDay.begin(),bloomDay.end());\\n        int right=*max_element(bloomDay.begin(),bloomDay.end());\\n        while(left<=right)\\n        {\\n            int mid=left+(right-left)/2;\\n            if(isValid(bloomDay,m,k,mid))\\n                right=mid-1;\\n            else\\n                left=mid+1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& bloomDay,int m,int k,int mid)\\n    {\\n        int count=0,size=0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            size=(bloomDay[i]<=mid) ?size+1 :0;\\n            if(size==k)\\n            {\\n                size=0;\\n                count++;\\n            }\\n            if(count==m)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) \\n    {\\n         if(bloomDay.size()==0 or m==0 or k==0)\\n             return 0;\\n        if(m*k>bloomDay.size())\\n            return -1;\\n        int left=*min_element(bloomDay.begin(),bloomDay.end());\\n        int right=*max_element(bloomDay.begin(),bloomDay.end());\\n        while(left<=right)\\n        {\\n            int mid=left+(right-left)/2;\\n            if(isValid(bloomDay,m,k,mid))\\n                right=mid-1;\\n            else\\n                left=mid+1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606682,
                "title": "java-basic-binary-search-93-08-faster",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int min = 0;\\n        int max = 0;\\n        for(int i = 0; i< bloomDay.length; i++){\\n            min = Math.min(min , bloomDay[i]);\\n            max = Math.max(max , bloomDay[i]);\\n            }\\n        int res = -1;\\n        if(bloomDay.length < m*k) return res;\\n        \\n        int low = min;\\n        int high = max;\\n        int mid = 0;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            if(isvalid(bloomDay , mid , k , m)){\\n                res = mid;\\n                high = mid -1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return res;\\n    }\\n    public static boolean isvalid(int [] bloomDay, int mid , int k , int m){\\n        int flower=0;\\n        int bouquet=0;\\n        for(int i=0;i<bloomDay.length;i++)\\n        {\\n            if(bloomDay[i]<=mid)\\n            {\\n                flower++;\\n                if(flower==k)\\n                {\\n                    bouquet++;\\n                    flower=0;\\n                }\\n            }\\n            else\\n            {\\n                flower=0;\\n            }\\n        }\\n        return bouquet>=m;\\n\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int min = 0;\\n        int max = 0;\\n        for(int i = 0; i< bloomDay.length; i++){\\n            min = Math.min(min , bloomDay[i]);\\n            max = Math.max(max , bloomDay[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2606597,
                "title": "java-solution-using-binary-search",
                "content": "\\tclass Solution {\\n\\t\\tpublic int minDays(int[] bloomDay, int m, int k) {\\n\\t\\t if(m*k>bloomDay.length){\\n\\t\\t\\t return -1;\\n\\t\\t }   \\n\\t\\t\\tint min=0;\\n\\t\\t\\tint max=0;\\n\\t\\t\\tfor(int i:bloomDay){\\n\\t\\t\\t\\tmin=Math.min(min,i);\\n\\t\\t\\t\\tmax=Math.max(max,i);\\n\\t\\t\\t}\\n\\t\\t\\tint ans=0;\\n\\t\\t\\twhile(min<=max){\\n\\t\\t\\t\\tint mid=min+(max-min)/2;\\n\\t\\t\\t\\tif(valid(bloomDay,mid,m,k)){\\n\\t\\t\\t\\t\\tans=mid;\\n\\t\\t\\t\\t   max=mid-1; \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmin=mid+1;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tpublic static boolean valid(int[]bloomDay,int mid,int m,int k){\\n\\t\\t\\tint flower=0;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i:bloomDay){\\n\\t\\t\\t\\tif(i<=mid)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tflower++;\\n\\n\\t\\t\\t\\t\\tif(flower==k){\\n\\t\\t\\t\\t\\t\\tcount++;    \\n\\t\\t\\t\\t\\t\\tflower=0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tflower=0;\\n\\t\\t\\t}\\n\\t\\t\\tif(count>=m){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\tpublic int minDays(int[] bloomDay, int m, int k) {\\n\\t\\t if(m*k>bloomDay.length){\\n\\t\\t\\t return -1;\\n\\t\\t }",
                "codeTag": "Java"
            },
            {
                "id": 2553745,
                "title": "c-98-fast-easy-o-n-lgn-readable",
                "content": "**Please upvote if helpful**\\n```\\nclass Solution {\\n    bool isPos(vector<int>& bloomDay, int day, int m, int k) {\\n\\t//Method returns true if it is possible to satisfy given requirement\\n        int n=bloomDay.size(), i=-1, j=0, numBq=0;    //i is point before start of window, j is point under examination\\n        while(j<n) {\\n            if(bloomDay[j]<=day) {\\n\\t\\t\\t//If the flower has bloomed\\n                if(j-i==k) {\\n                    numBq++;\\n                    i=j;\\n                }\\n                j++;\\n            }\\n            else {\\n\\t\\t\\t//Restart the window\\n                i = j;\\n                j++;\\n            }\\n        }\\n        return numBq>=m;\\n    }\\n    \\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        \\n        if(n < m * k)\\n            return -1;\\n        \\n        int left = 1, right = *max_element(bloomDay.begin(), bloomDay.end()), mid;\\n        while(left < right) {\\n            mid = left + (right - left)/2;\\n            \\n            if(isPos(bloomDay, mid, m, k)) \\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        \\n        return left;\\n    }\\n};\\n```\\n**Please upvote if helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    bool isPos(vector<int>& bloomDay, int day, int m, int k) {\\n\\t//Method returns true if it is possible to satisfy given requirement\\n        int n=bloomDay.size(), i=-1, j=0, numBq=0;    //i is point before start of window, j is point under examination\\n        while(j<n) {\\n            if(bloomDay[j]<=day) {\\n\\t\\t\\t//If the flower has bloomed\\n                if(j-i==k) {\\n                    numBq++;\\n                    i=j;\\n                }\\n                j++;\\n            }\\n            else {\\n\\t\\t\\t//Restart the window\\n                i = j;\\n                j++;\\n            }\\n        }\\n        return numBq>=m;\\n    }\\n    \\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        \\n        if(n < m * k)\\n            return -1;\\n        \\n        int left = 1, right = *max_element(bloomDay.begin(), bloomDay.end()), mid;\\n        while(left < right) {\\n            mid = left + (right - left)/2;\\n            \\n            if(isPos(bloomDay, mid, m, k)) \\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        \\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544038,
                "title": "easy-understanding-o-nlog-n-solution",
                "content": "question have a clue that one can choose adjacent k flowers from any subarray of the array\\n\\nclass Solution {\\n    public int minDays(int[] a, int m, int k) {\\n       int l = 0 ,  hi = 0 ,n = a.length,res = -1;\\n        \\n        if(m*k>n)return res;\\n        // Arrays.sort(a);\\n        for(int i : a)\\n        {\\n            l = Math.min(l,i);\\n            hi = Math.max(hi,i);\\n        }\\n        while(l<=hi)\\n        {\\n            int mid= (l+hi)>>1;\\n            if(isVal(a,m,k,mid))\\n            {\\n                res = mid;\\n                // System.out.print(\"--\"+res);\\n                hi = mid-1;\\n                \\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isVal(int[] a, int m , int  k , int mid)\\n    {\\n        int j = 0 ,i=0,buk = 0 ;\\n        while(i<a.length)\\n        {   if(a[i]<=mid)\\n            buk++;\\n            else buk = 0 ;\\n            if(buk==k)\\n            {\\n                j++;\\n                buk=0;\\n            }\\n            if(j==m)return true;\\n            i++;\\n        }\\n        return j>=m;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public int minDays(int[] a, int m, int k) {\\n       int l = 0 ,  hi = 0 ,n = a.length,res = -1;\\n        \\n        if(m*k>n)return res;\\n        // Arrays.sort(a);\\n        for(int i : a)\\n        {\\n            l = Math.min(l,i);\\n            hi = Math.max(hi,i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2518363,
                "title": "binary-search-solution-in-python",
                "content": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if m*k > len(bloomDay):\\n            return -1\\n        start=0\\n        end=self.findMax(bloomDay)\\n        res=-1\\n        while start<=end:\\n            mid=int((start+end)/2)\\n            if self.isValidScheme(bloomDay,mid,m,k)==True:\\n                res=mid\\n                end=mid-1\\n            else:\\n                start=mid+1\\n        return res\\n    def isValidScheme(self,bloomDay,mid,b,f):\\n        boq=0\\n        flower=0\\n        for i in range(len(bloomDay)):\\n            if bloomDay[i]<=mid:\\n                flower=flower+1\\n            if bloomDay[i]>mid:\\n                flower=0\\n            if flower==f:\\n                boq=boq+1\\n                flower=0\\n            if boq==b:\\n                return True\\n        return False\\n    def findMax(self,arr):\\n        max=0\\n        for i in arr:\\n            if i>max:\\n                max=i\\n        return max\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if m*k > len(bloomDay):\\n            return -1\\n        start=0\\n        end=self.findMax(bloomDay)\\n        res=-1\\n        while start<=end:\\n            mid=int((start+end)/2)\\n            if self.isValidScheme(bloomDay,mid,m,k)==True:\\n                res=mid\\n                end=mid-1\\n            else:\\n                start=mid+1\\n        return res\\n    def isValidScheme(self,bloomDay,mid,b,f):\\n        boq=0\\n        flower=0\\n        for i in range(len(bloomDay)):\\n            if bloomDay[i]<=mid:\\n                flower=flower+1\\n            if bloomDay[i]>mid:\\n                flower=0\\n            if flower==f:\\n                boq=boq+1\\n                flower=0\\n            if boq==b:\\n                return True\\n        return False\\n    def findMax(self,arr):\\n        max=0\\n        for i in arr:\\n            if i>max:\\n                max=i\\n        return max\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509404,
                "title": "java-binary-search-with-predicate-function-self-descriptive-codes",
                "content": "*For commented and Explaination, follow the link below*\\n[https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/2509397/Java-or-Binary-Search(On-Day)-or-Handwritten-Explaination-or-TLE-to-Accepted]\\n```\\nclass Solution extends PredicateAPI {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < m * 1L * k) return -1;\\n        return minimumDaysToMakeMBouquets(bloomDay, m, k);\\n    }\\n    \\n    private int minimumDaysToMakeMBouquets(int[] bloomDay, int m, int k) {\\n        int maxBloomDay = Arrays.stream(bloomDay).max().getAsInt(); \\n        int left = 1, right = maxBloomDay;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(isPossibleToMakeMBouquetsWithinDDays(bloomDay, m, k, mid))\\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n}\\n\\nclass PredicateAPI {\\n    private int[] hasFoundKAdjacentFlowers(int[] bloomDay, int d, int left, int right) {\\n        while(left < right) {\\n            if(bloomDay[left] > d)\\n                return new int[]{0, left};\\n            left += 1;\\n        }\\n        return new int[]{1, right};\\n    }\\n    \\n    boolean isPossibleToMakeMBouquetsWithinDDays(int[] bloomDay, int m, int k, int d) {\\n        int lastWinStart = bloomDay.length - k;\\n        int left = 0, right = k;\\n        while(left <= lastWinStart) {\\n            int[] found = hasFoundKAdjacentFlowers(bloomDay, d, left, right);\\n            if(found[0] == 1) m -= 1;\\n            left = (found[0] == 1) ? found[1] : found[1] + 1;\\n            right = left + k;\\n            if(m == 0) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution extends PredicateAPI {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < m * 1L * k) return -1;\\n        return minimumDaysToMakeMBouquets(bloomDay, m, k);\\n    }\\n    \\n    private int minimumDaysToMakeMBouquets(int[] bloomDay, int m, int k) {\\n        int maxBloomDay = Arrays.stream(bloomDay).max().getAsInt(); \\n        int left = 1, right = maxBloomDay;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(isPossibleToMakeMBouquetsWithinDDays(bloomDay, m, k, mid))\\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n}\\n\\nclass PredicateAPI {\\n    private int[] hasFoundKAdjacentFlowers(int[] bloomDay, int d, int left, int right) {\\n        while(left < right) {\\n            if(bloomDay[left] > d)\\n                return new int[]{0, left};\\n            left += 1;\\n        }\\n        return new int[]{1, right};\\n    }\\n    \\n    boolean isPossibleToMakeMBouquetsWithinDDays(int[] bloomDay, int m, int k, int d) {\\n        int lastWinStart = bloomDay.length - k;\\n        int left = 0, right = k;\\n        while(left <= lastWinStart) {\\n            int[] found = hasFoundKAdjacentFlowers(bloomDay, d, left, right);\\n            if(found[0] == 1) m -= 1;\\n            left = (found[0] == 1) ? found[1] : found[1] + 1;\\n            right = left + k;\\n            if(m == 0) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496565,
                "title": "c-easy-and-clean-code-100-faster-with-comment",
                "content": "class Solution {\\n    \\n    public:\\n    bool isPosibleDay(vector<int> &arr,int m,int k,int mid){\\n        int count=0; //flower which bloom\\n        int ans=0; // bouquet\\n        \\n        for(int i=0;i<arr.size();i++){\\n            \\n            // check if flower bloom or not and its hould be in continuos manner is yes count++ else we have reste count\\n            if(arr[i]<=mid){\\n               count++; \\n            }\\n            else\\n            {\\n                count=0;\\n            }\\n            \\n            //we need to check like we have require flower to make  one bouquet if yes increase ans ++ \\n            if(count==k){\\n                ans++;\\n                count=0;\\n            }\\n            \\n        }\\n        \\n        return ans>=m;\\n        \\n    }\\n    \\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        \\n        int start=*min_element(bloomDay.begin(),bloomDay.end());  // if all flower bloom on first day then we require min\\n        int end=*max_element(bloomDay.begin(),bloomDay.end()); // if all flower bloom on last day then we require max \\n        \\n        int ans=-1;\\n        \\n        \\n        //we can directly return -1 if our require flower is greater then what available\\n        if(m*k>bloomDay.size()){\\n            return ans;\\n        }\\n        \\n        // binary search on answer\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n           \\n            \\n            // here we got valid solution so we store and we need minimum so we are eliminating large part\\n            if(isPosibleDay(bloomDay,m,k,mid)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    \\n    public:\\n    bool isPosibleDay(vector<int> &arr,int m,int k,int mid){\\n        int count=0; //flower which bloom\\n        int ans=0; // bouquet\\n        \\n        for(int i=0;i<arr.size();i++){\\n            \\n            // check if flower bloom or not and its hould be in continuos manner is yes count++ else we have reste count\\n            if(arr[i]<=mid){\\n               count++; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2496533,
                "title": "100-faster-java-solution-using-binary-search",
                "content": "```\\n public boolean isPossible(int arr[], int days,int k,int m){\\n        int n = arr.length;\\n        int count = 0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]<=days){\\n                count++;\\n            }else{\\n                count = 0;\\n            }\\n            if(count==k){\\n                ans++;\\n                count = 0;\\n            }\\n        }\\n        return ans>=m;\\n    }\\n    \\n    public int minDays(int[] bloomDay, int m, int k) {\\n        // Arrays.sort(bloomDay);\\n        int start = Integer.MAX_VALUE, end = Integer.MIN_VALUE, n = bloomDay.length;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            start = Math.min(start,bloomDay[i]);\\n            end = Math.max(end,bloomDay[i]);\\n        }\\n        \\n        int ans = -1;\\n        int toallFlowers = m*k;\\n        if(toallFlowers>n)\\n            return ans;\\n        while(start<=end){\\n            int mid = start + (end - start)/2;\\n            if(isPossible(bloomDay,mid,k,m)){\\n                ans = mid;\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n public boolean isPossible(int arr[], int days,int k,int m){\\n        int n = arr.length;\\n        int count = 0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]<=days){\\n                count++;\\n            }else{\\n                count = 0;\\n            }\\n            if(count==k){\\n                ans++;\\n                count = 0;\\n            }\\n        }\\n        return ans>=m;\\n    }\\n    \\n    public int minDays(int[] bloomDay, int m, int k) {\\n        // Arrays.sort(bloomDay);\\n        int start = Integer.MAX_VALUE, end = Integer.MIN_VALUE, n = bloomDay.length;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            start = Math.min(start,bloomDay[i]);\\n            end = Math.max(end,bloomDay[i]);\\n        }\\n        \\n        int ans = -1;\\n        int toallFlowers = m*k;\\n        if(toallFlowers>n)\\n            return ans;\\n        while(start<=end){\\n            int mid = start + (end - start)/2;\\n            if(isPossible(bloomDay,mid,k,m)){\\n                ans = mid;\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2474167,
                "title": "easy-c-solution-with-full-explanation",
                "content": "// Range of our answer will lie between minimum and maximim of bloomdays beacuse we need minimum 1 flower to make a bouquet ans maximum all flowers.\\n\\nExample: bloomDays=[1,10,3,10,2]\\nthen our st=1 and en=10.\\n\\nclass Solution {\\npublic:\\n  \\n  //this function is used to check whether we can make at least m bouquest with mid as our bloom day\\n\\n    bool check(vector<int>v,int bouquets,int flow,int day)\\n    {\\n        int adjFlowers=0,bouq=0;\\n        for (int i = 0; i < v.size(); i++) {\\n               if (v[i] > day) {\\n                 adjFlowers = 0;\\n                } else if (++adjFlowers == flow) {\\n                    bouq++;\\n                    adjFlowers = 0;\\n                }\\n            }\\n        return (bouq>=bouquets);\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(m*k>bloomDay.size())\\n            return -1;\\n        int st=INT_MAX,en=INT_MIN;\\n        int n=bloomDay.size();\\n        int ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            st=min(st,bloomDay[i]);\\n            en=max(en,bloomDay[i]);\\n        }\\n        while(st<=en)\\n        {\\n            int mid=st+(en-st)/2;\\n            if(check(bloomDay,m,k,mid))\\n            {\\n                ans=mid;\\n                en=mid-1;\\n            }\\n            else\\n                st=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease upvote it if you like the solution :)",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n  \\n  //this function is used to check whether we can make at least m bouquest with mid as our bloom day\\n\\n    bool check(vector<int>v,int bouquets,int flow,int day)\\n    {\\n        int adjFlowers=0,bouq=0;\\n        for (int i = 0; i < v.size(); i++) {\\n               if (v[i] > day) {\\n                 adjFlowers = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2445995,
                "title": "java-o-log-n-binary-search",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int s = min(bloomDay), e = (int)1e9, ans = -1;\\n        while(s <= e) {\\n            int mid = s + (e - s) / 2;\\n            if(completable(bloomDay, mid, m, k)) {\\n                ans = mid;\\n                e = mid - 1;\\n            } else s = mid + 1;\\n        }\\n        return ans;\\n    }\\n    \\n    public static boolean completable(int[] arr, int nod, int nob, int nof) {\\n       int k = 0, m = 0;\\n       for(int i : arr) {\\n           if(i <= nod) {\\n               k ++;\\n               if(k == nof) {\\n                   m++;\\n                   k = 0;    \\n               }\\n           } else k = 0;\\n       }\\n        return m >= nob;\\n    }\\n    \\n    public int min(int[] wts) {\\n        int min = wts[0];\\n        for(int i : wts) if(i < min) min = i;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int s = min(bloomDay), e = (int)1e9, ans = -1;\\n        while(s <= e) {\\n            int mid = s + (e - s) / 2;\\n            if(completable(bloomDay, mid, m, k)) {\\n                ans = mid;\\n                e = mid - 1;\\n            } else s = mid + 1;\\n        }\\n        return ans;\\n    }\\n    \\n    public static boolean completable(int[] arr, int nod, int nob, int nof) {\\n       int k = 0, m = 0;\\n       for(int i : arr) {\\n           if(i <= nod) {\\n               k ++;\\n               if(k == nof) {\\n                   m++;\\n                   k = 0;    \\n               }\\n           } else k = 0;\\n       }\\n        return m >= nob;\\n    }\\n    \\n    public int min(int[] wts) {\\n        int min = wts[0];\\n        for(int i : wts) if(i < min) min = i;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434712,
                "title": "simple-c-solution-binary-search-100-fast-o-nlongn-time-complexity",
                "content": "```\\nclass Solution {\\n    bool ispossible(vector<int>& bloomDay, int &day, int &m, int &k)\\n    {\\n        int c = 0, d = 0;\\n        for(int bday : bloomDay)\\n        {\\n            c = bday <= day ? c+1 : 0;\\n            if(c == k)\\n                c = 0, d++;\\n        }\\n        return d >= m;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n =  bloomDay.size();\\n        if(n < m*k) return -1;\\n        int l = 1, h = *max_element(bloomDay.begin(), bloomDay.end());\\n        while(l<h)\\n        {\\n            int mid = l +(h-l)/2;\\n            if(ispossible(bloomDay, mid, m, k))\\n                h = mid;\\n            else\\n                l =  mid+1;\\n        }\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    bool ispossible(vector<int>& bloomDay, int &day, int &m, int &k)\\n    {\\n        int c = 0, d = 0;\\n        for(int bday : bloomDay)\\n        {\\n            c = bday <= day ? c+1 : 0;\\n            if(c == k)\\n                c = 0, d++;\\n        }\\n        return d >= m;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n =  bloomDay.size();\\n        if(n < m*k) return -1;\\n        int l = 1, h = *max_element(bloomDay.begin(), bloomDay.end());\\n        while(l<h)\\n        {\\n            int mid = l +(h-l)/2;\\n            if(ispossible(bloomDay, mid, m, k))\\n                h = mid;\\n            else\\n                l =  mid+1;\\n        }\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421142,
                "title": "c-binary-search-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use binary search to find the minimum number of days it takes for `m` bouquets of flowers to bloom. We can start with `l = 1` and `r = 1e9` as the minimum and maximum possible number of days. We can then check the middle day using the `check` function. If the number of bouquets that bloom on the middle day is less than `m`, we can search for a larger day by setting `l = mid + 1`. Otherwise, we can search for a smaller day by setting `r = mid`. We can continue this process until we find the minimum number of days.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n log(mx))$$, where n is the length of bloomDay, m is the number of bouquets needed, and x is the maximum value in bloomDay. This is because we perform binary search on the range of possible days, and for each day we need to check if it is possible to form m bouquets with k flowers. This takes $$O(n)$$ time, so the overall time complexity is $$O(n log(mx))$$.\\n\\n- Space complexity: $$O(1)$$ We use constant space to store variables and perform calculations, so the space complexity is $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int check(vector<int>& bloomDay, int day, int k) {\\n        int count = 0;\\n        int res = 0;\\n        for(int b : bloomDay) {\\n            if(b <= day) {\\n                count++;\\n                if(count >= k) {\\n                    // increment the result by the number of k bouquets that can be made\\n                    res += count / k;\\n                    count = 0;\\n                }\\n            } else {\\n                count = 0;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int l = 1, r = 1e9;\\n        // if it is impossible to form m bouquets with k flowers, return -1\\n        if(m * k > bloomDay.size()) return -1;\\n        \\n        while(l < r) {\\n            // set the middle value between l and r\\n            int mid = (l + r) / 2;\\n\\n            // if it is not possible to form m bouquets with k flowers with the current middle value\\n            if(check(bloomDay, mid, k) < m) {\\n                l = mid + 1; // increase l to mid + 1\\n            } else {\\n                r = mid; // otherwise, set r to mid\\n            }\\n        }\\n        return l; // return l as the minimum number of days required to form m bouquets with k flowers\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int check(vector<int>& bloomDay, int day, int k) {\\n        int count = 0;\\n        int res = 0;\\n        for(int b : bloomDay) {\\n            if(b <= day) {\\n                count++;\\n                if(count >= k) {\\n                    // increment the result by the number of k bouquets that can be made\\n                    res += count / k;\\n                    count = 0;\\n                }\\n            } else {\\n                count = 0;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int l = 1, r = 1e9;\\n        // if it is impossible to form m bouquets with k flowers, return -1\\n        if(m * k > bloomDay.size()) return -1;\\n        \\n        while(l < r) {\\n            // set the middle value between l and r\\n            int mid = (l + r) / 2;\\n\\n            // if it is not possible to form m bouquets with k flowers with the current middle value\\n            if(check(bloomDay, mid, k) < m) {\\n                l = mid + 1; // increase l to mid + 1\\n            } else {\\n                r = mid; // otherwise, set r to mid\\n            }\\n        }\\n        return l; // return l as the minimum number of days required to form m bouquets with k flowers\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351788,
                "title": "c-most-easy-solution-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n      bool check(int mid,vector<int> &v, int m, int k)\\n      {\\n          int n=v.size();\\n          int cnt=0;// taking cnt for the no of k adjacent bouquets possible\\n          for(int i=0;i<v.size();i++)\\n          {\\n              if(v[i]<=mid)\\n              {\\n                  int c=0;\\n                  while(i<n and v[i]<=mid)\\n                  {\\n                      i++;\\n                      c++;// c->checking for adjacent count\\n                  }\\n                 cnt+=c/k;\\n              }\\n          }\\n          if(cnt>=m)\\n              return true;\\n          return false;\\n          \\n      }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s=*min_element(bloomDay.begin(),bloomDay.end());\\n        int e=*max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=e;\\n        if((m*k)>bloomDay.size())\\n            return -1;\\n        while(s<=e)\\n        {\\n           int mid=s+(e-s)/2;\\n            if(check(mid,bloomDay,m,k))\\n            {\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else\\n                s=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      bool check(int mid,vector<int> &v, int m, int k)\\n      {\\n          int n=v.size();\\n          int cnt=0;// taking cnt for the no of k adjacent bouquets possible\\n          for(int i=0;i<v.size();i++)\\n          {\\n              if(v[i]<=mid)\\n              {\\n                  int c=0;\\n                  while(i<n and v[i]<=mid)\\n                  {\\n                      i++;\\n                      c++;// c->checking for adjacent count\\n                  }\\n                 cnt+=c/k;\\n              }\\n          }\\n          if(cnt>=m)\\n              return true;\\n          return false;\\n          \\n      }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s=*min_element(bloomDay.begin(),bloomDay.end());\\n        int e=*max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=e;\\n        if((m*k)>bloomDay.size())\\n            return -1;\\n        while(s<=e)\\n        {\\n           int mid=s+(e-s)/2;\\n            if(check(mid,bloomDay,m,k))\\n            {\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else\\n                s=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309926,
                "title": "java-binary-search-solution-brute-force-optimization",
                "content": "Time Complexity - O(n * n * log(max item in bloomDay)) \\n\\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int low = 1;\\n        int high = Integer.MIN_VALUE;\\n        \\n        for (int day : bloomDay) {\\n            high = Math.max(day, high);\\n        }\\n        \\n        boolean flag = false;\\n            \\n        while (low <= high) {\\n            int mid = (low + high)/2;\\n            \\n            if (isPossible(bloomDay, m, k, mid)) {\\n                flag = true;\\n                high = mid - 1;\\n            } else\\n                low = mid + 1;\\n        }\\n        \\n        return flag ? low : -1;\\n    }\\n    \\n    private boolean isPossible(int[] bloomDay, int m, int k, int day) {\\n        \\n        for (int i=0; i < bloomDay.length - k + 1; i++) {\\n            int count = 0;\\n            for (int j = i; j < i + k; j++) {\\n                if (bloomDay[j] <= day)\\n                    count++;\\n                else \\n                    break;\\n            }\\n            \\n            if (count == k) {\\n                m--;\\n                i = i + k - 1;\\n            }\\n        }\\n      \\n        return m <= 0;\\n    }\\n}\\n```\\n\\nReducing time complexity of isPossible method from 0(n*n) to O(n)\\n\\nTime Complexity - 0(n * log(max item in bloomDay));\\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int low = Integer.MAX_VALUE;\\n        int high = Integer.MIN_VALUE;\\n        \\n        for (int day : bloomDay) {\\n            high = Math.max(day, high);\\n            low = Math.min(day, low);\\n        }\\n        \\n        boolean flag = false;\\n            \\n        while (low <= high) {\\n            int mid = (low + high)/2;\\n            \\n            if (isPossible(bloomDay, m, k, mid)) {\\n                flag = true;\\n                high = mid - 1;\\n            } else\\n                low = mid + 1;\\n        }\\n        \\n        return flag ? low : -1;\\n    }\\n    \\n    private boolean isPossible(int[] bloomDay, int m, int k, int day) {\\n        int count = 0;\\n        \\n        for (int i=0; i < bloomDay.length; i++) {\\n            if (bloomDay[i] <= day)\\n                    count++;\\n            else\\n                count = 0;\\n            \\n            if (count == k) {\\n                m--;\\n                count = 0;\\n            }\\n        }\\n      \\n        return m <= 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int low = 1;\\n        int high = Integer.MIN_VALUE;\\n        \\n        for (int day : bloomDay) {\\n            high = Math.max(day, high);\\n        }\\n        \\n        boolean flag = false;\\n            \\n        while (low <= high) {\\n            int mid = (low + high)/2;\\n            \\n            if (isPossible(bloomDay, m, k, mid)) {\\n                flag = true;\\n                high = mid - 1;\\n            } else\\n                low = mid + 1;\\n        }\\n        \\n        return flag ? low : -1;\\n    }\\n    \\n    private boolean isPossible(int[] bloomDay, int m, int k, int day) {\\n        \\n        for (int i=0; i < bloomDay.length - k + 1; i++) {\\n            int count = 0;\\n            for (int j = i; j < i + k; j++) {\\n                if (bloomDay[j] <= day)\\n                    count++;\\n                else \\n                    break;\\n            }\\n            \\n            if (count == k) {\\n                m--;\\n                i = i + k - 1;\\n            }\\n        }\\n      \\n        return m <= 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int low = Integer.MAX_VALUE;\\n        int high = Integer.MIN_VALUE;\\n        \\n        for (int day : bloomDay) {\\n            high = Math.max(day, high);\\n            low = Math.min(day, low);\\n        }\\n        \\n        boolean flag = false;\\n            \\n        while (low <= high) {\\n            int mid = (low + high)/2;\\n            \\n            if (isPossible(bloomDay, m, k, mid)) {\\n                flag = true;\\n                high = mid - 1;\\n            } else\\n                low = mid + 1;\\n        }\\n        \\n        return flag ? low : -1;\\n    }\\n    \\n    private boolean isPossible(int[] bloomDay, int m, int k, int day) {\\n        int count = 0;\\n        \\n        for (int i=0; i < bloomDay.length; i++) {\\n            if (bloomDay[i] <= day)\\n                    count++;\\n            else\\n                count = 0;\\n            \\n            if (count == k) {\\n                m--;\\n                count = 0;\\n            }\\n        }\\n      \\n        return m <= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263361,
                "title": "73-tc-and-92-tc-easy-python-solution",
                "content": "```\\ndef minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n\\tn = len(bloomDay)\\n\\tif(n < m*k):\\n\\t\\treturn -1\\n\\tlru_cache(None)\\n\\tdef isValid(day):\\n\\t\\ti = 0\\n\\t\\tc = 0\\n\\t\\ttemp = 0\\n\\t\\twhile(i < n):\\n\\t\\t\\tif(bloomDay[i] <= day):\\n\\t\\t\\t\\tc += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp += c//k\\n\\t\\t\\t\\tc = 0\\n\\t\\t\\tif(temp >= m):\\n\\t\\t\\t\\treturn True\\n\\t\\t\\ti += 1\\n\\t\\ttemp += c//k\\n\\t\\tif(temp >= m):\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\ti, j = min(bloomDay), max(bloomDay)\\n\\tans = -1\\n\\twhile(i <= j):\\n\\t\\tmid = (i+j)//2\\n\\t\\tx = isValid(mid)\\n\\t\\tif(x):\\n\\t\\t\\tj = mid-1\\n\\t\\t\\tans = mid\\n\\t\\telse:\\n\\t\\t\\ti = mid+1\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n\\tn = len(bloomDay)\\n\\tif(n < m*k):\\n\\t\\treturn -1\\n\\tlru_cache(None)\\n\\tdef isValid(day):\\n\\t\\ti = 0\\n\\t\\tc = 0\\n\\t\\ttemp = 0\\n\\t\\twhile(i < n):\\n\\t\\t\\tif(bloomDay[i] <= day):\\n\\t\\t\\t\\tc += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp += c//k\\n\\t\\t\\t\\tc = 0\\n\\t\\t\\tif(temp >= m):\\n\\t\\t\\t\\treturn True\\n\\t\\t\\ti += 1\\n\\t\\ttemp += c//k\\n\\t\\tif(temp >= m):\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\ti, j = min(bloomDay), max(bloomDay)\\n\\tans = -1\\n\\twhile(i <= j):\\n\\t\\tmid = (i+j)//2\\n\\t\\tx = isValid(mid)\\n\\t\\tif(x):\\n\\t\\t\\tj = mid-1\\n\\t\\t\\tans = mid\\n\\t\\telse:\\n\\t\\t\\ti = mid+1\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2263315,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& bloomDay, int m, int k, int day){\\n        int cur = 0;\\n        int cnt = 0;\\n        cout<<day<<\" \";\\n        for(int i=0; i<bloomDay.size(); i++){\\n            if(day >= bloomDay[i]){\\n                cur++;\\n            }else{\\n                cnt += cur/k;\\n                cur = 0;\\n            }\\n        }\\n        cnt += cur/k;\\n        cout<<cnt<<\"\\\\n\";\\n        return cnt>=m;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        if(m*k > n) return -1;\\n        int l=INT_MAX, r=INT_MIN;\\n        for(auto it:bloomDay){\\n            l = min(it,l);\\n            r = max(it,r);\\n        }\\n        int res = INT_MAX;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(check(bloomDay,m,k,mid)){\\n                res = mid;\\n                r = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& bloomDay, int m, int k, int day){\\n        int cur = 0;\\n        int cnt = 0;\\n        cout<<day<<\" \";\\n        for(int i=0; i<bloomDay.size(); i++){\\n            if(day >= bloomDay[i]){\\n                cur++;\\n            }else{\\n                cnt += cur/k;\\n                cur = 0;\\n            }\\n        }\\n        cnt += cur/k;\\n        cout<<cnt<<\"\\\\n\";\\n        return cnt>=m;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        if(m*k > n) return -1;\\n        int l=INT_MAX, r=INT_MIN;\\n        for(auto it:bloomDay){\\n            l = min(it,l);\\n            r = max(it,r);\\n        }\\n        int res = INT_MAX;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(check(bloomDay,m,k,mid)){\\n                res = mid;\\n                r = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2249455,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(m*k>bloomDay.length) return -1;\\n        int lo=1,hi=1_000_000_000;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(isPossible(bloomDay,k,mid,m)) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return hi+1;\\n    }\\n    private boolean isPossible(int[] arr, int k, int time, int m){\\n        int bqs = 0,start = 0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>time) start = i+1;\\n            else if(i-start+1 == k) {bqs++;start=i+1;} \\n        }\\n        return bqs>=m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(m*k>bloomDay.length) return -1;\\n        int lo=1,hi=1_000_000_000;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(isPossible(bloomDay,k,mid,m)) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return hi+1;\\n    }\\n    private boolean isPossible(int[] arr, int k, int time, int m){\\n        int bqs = 0,start = 0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>time) start = i+1;\\n            else if(i-start+1 == k) {bqs++;start=i+1;} \\n        }\\n        return bqs>=m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240283,
                "title": "java-binary-search-with-approach-and-commented-code",
                "content": "Approach :\\n* Create a helper function (checkBouquets) which returns true / false, whether we can get \\'m\\' bouquets for a given day using \\'k\\' adjecent flowers.\\n* Find the min and max day from \\'bloomDay\\'. Call it min and max. They represet that we need at least \\'min\\' day or at most \\'max\\' day to get the bouquets.\\n* The answer should be between [min,max]\\n* Do a binary search on min and max.\\n\\nCommented the code.\\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int min = 0; // hold minimum days\\n        int max = 0;// hold max days\\n        for(int d:bloomDay){\\n            min = min>d?d:min;\\n            max = max<d?d:max;\\n        }\\n        int minday = -1; \\n        // do abinary search between min and max day.\\n        // As we need min day to get at least 1 flower and max day to get all flower.\\n        // The answer should be [min,max]\\n        // We do a binary search to get the minimum no of day needed.\\n        while(min<=max){\\n            int mid = min + (max-min)/2; \\n            if(checkBouquets(bloomDay, m, k, mid)) // this checkBouquets : return if we can create all the bouquets with give condition\\n            {\\n                // we can get the m bouquets. lets try with smaller no of day.\\n                minday = mid;\\n                max = mid-1;\\n            }else{\\n                 // we can\\'t get the m bouquets. lets try with big no of day.\\n                min = mid+1;\\n            }\\n        }\\n        return minday;\\n    }\\n    \\n    private boolean checkBouquets(int[] bloomDay, int m, int k, int day){\\n        int count = 0;\\n        int bouquets = 0;\\n        for(int d:bloomDay) // loop over all flower\\n        { \\n            if(d<=day){ // if the bloomDay of flower is less or equal to day, then increase the count, else reset it to 0.\\n               count++; \\n            }else {\\n                count = 0;\\n            }\\n            /*\\n            if the count is equal to given adjacent number increase the no of bouquets and reset the count to 0.\\n            We are reseting count to zero so that the count for next bouquet begin (one flower can be part of exactly one bouquet).\\n            */\\n            if(count == k){ \\n                count = 0;\\n                bouquets++;\\n            }\\n        }\\n        // return the count of bouquets >= m(target).\\n        return bouquets >= m; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int min = 0; // hold minimum days\\n        int max = 0;// hold max days\\n        for(int d:bloomDay){\\n            min = min>d?d:min;\\n            max = max<d?d:max;\\n        }\\n        int minday = -1; \\n        // do abinary search between min and max day.\\n        // As we need min day to get at least 1 flower and max day to get all flower.\\n        // The answer should be [min,max]\\n        // We do a binary search to get the minimum no of day needed.\\n        while(min<=max){\\n            int mid = min + (max-min)/2; \\n            if(checkBouquets(bloomDay, m, k, mid)) // this checkBouquets : return if we can create all the bouquets with give condition\\n            {\\n                // we can get the m bouquets. lets try with smaller no of day.\\n                minday = mid;\\n                max = mid-1;\\n            }else{\\n                 // we can\\'t get the m bouquets. lets try with big no of day.\\n                min = mid+1;\\n            }\\n        }\\n        return minday;\\n    }\\n    \\n    private boolean checkBouquets(int[] bloomDay, int m, int k, int day){\\n        int count = 0;\\n        int bouquets = 0;\\n        for(int d:bloomDay) // loop over all flower\\n        { \\n            if(d<=day){ // if the bloomDay of flower is less or equal to day, then increase the count, else reset it to 0.\\n               count++; \\n            }else {\\n                count = 0;\\n            }\\n            /*\\n            if the count is equal to given adjacent number increase the no of bouquets and reset the count to 0.\\n            We are reseting count to zero so that the count for next bouquet begin (one flower can be part of exactly one bouquet).\\n            */\\n            if(count == k){ \\n                count = 0;\\n                bouquets++;\\n            }\\n        }\\n        // return the count of bouquets >= m(target).\\n        return bouquets >= m; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131053,
                "title": "javascript-js-solution-ultrafast",
                "content": "JavaScript solution\\n\\n```\\nvar minDays = function(bloomDay, m, k) {\\n    if (m * k > bloomDay.length) {\\n        return -1;\\n    }\\n\\n    let left = 0;\\n    let right = 0;\\n    \\n    for (const day of bloomDay) {\\n        left = Math.min(day, left);\\n        right = Math.max(day, right);\\n    }\\n\\n    let ans = right;\\n    \\n    while (left < right) {\\n        const day = Math.floor((left + right) / 2);\\n        \\n        let count = 0;\\n        let current = 0;\\n        \\n        for (let j = 0; j < bloomDay.length; j++) {\\n            if (bloomDay[j] <= day) {\\n                current++;\\n            } else {\\n                current = 0;\\n            }\\n            \\n            if (current === k) {\\n                count++;\\n                current = 0;\\n            }\\n        }\\n\\n        if (count === m) {\\n            ans = Math.min(ans, day);\\n        }\\n\\n        if (count < m) {\\n            left = day + 1;\\n        } else {\\n            right = day;\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvar minDays = function(bloomDay, m, k) {\\n    if (m * k > bloomDay.length) {\\n        return -1;\\n    }\\n\\n    let left = 0;\\n    let right = 0;\\n    \\n    for (const day of bloomDay) {\\n        left = Math.min(day, left);\\n        right = Math.max(day, right);\\n    }\\n\\n    let ans = right;\\n    \\n    while (left < right) {\\n        const day = Math.floor((left + right) / 2);\\n        \\n        let count = 0;\\n        let current = 0;\\n        \\n        for (let j = 0; j < bloomDay.length; j++) {\\n            if (bloomDay[j] <= day) {\\n                current++;\\n            } else {\\n                current = 0;\\n            }\\n            \\n            if (current === k) {\\n                count++;\\n                current = 0;\\n            }\\n        }\\n\\n        if (count === m) {\\n            ans = Math.min(ans, day);\\n        }\\n\\n        if (count < m) {\\n            left = day + 1;\\n        } else {\\n            right = day;\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2128929,
                "title": "c-short-concise-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeBoquet(vector<int>& bloomDay, int& m, int& k, int& mid){\\n        int count = 0;\\n        int adjacent = 0;\\n        \\n        for(auto &flower : bloomDay){\\n            if(flower > mid){ // flower doesnt bloom yet\\n                adjacent = 0;\\n            }else{\\n                ++adjacent;\\n                if(adjacent == k){\\n                    count++;\\n                    adjacent = 0;\\n                }\\n            }\\n            if(count == m){ // we already made m boquets\\n                break;\\n            }\\n        }\\n        return count>=m;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(m*k > bloomDay.size()){\\n            return -1;\\n        }\\n        \\n        int low = INT_MAX;\\n        int high = INT_MIN;\\n        int ans = -1;\\n        \\n        for(auto &elem : bloomDay){\\n            low = min(low, elem);\\n            high = max(high, elem);\\n        }\\n        \\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            bool boquetPossible = makeBoquet(bloomDay, m, k, mid);\\n            \\n            if(boquetPossible){\\n                ans = mid; // this could be potential answer\\n                high = mid-1; // continue minimizing bloom day\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool makeBoquet(vector<int>& bloomDay, int& m, int& k, int& mid){\\n        int count = 0;\\n        int adjacent = 0;\\n        \\n        for(auto &flower : bloomDay){\\n            if(flower > mid){ // flower doesnt bloom yet\\n                adjacent = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2115254,
                "title": "c-solution-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& bloomDay,int m,int k,int maxDay){\\n        int adj=0,nb=0;\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<=maxDay and adj<k){\\n                adj++;\\n            }else if(bloomDay[i]<=maxDay and adj==k){\\n                nb++;\\n                adj=1;\\n            }else if(bloomDay[i]>maxDay and adj<k){\\n                adj=0;\\n            }else if(bloomDay[i]>maxDay and adj==k){\\n                nb++;\\n                adj=0;\\n            }\\n        }\\n        if(adj==k){\\n            nb++;\\n        }\\n        return nb>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int l=*min_element(bloomDay.begin(),bloomDay.end());\\n        int r=*max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=-1;\\n        while(l<=r){\\n            int mxDay=l+(r-l)/2;\\n            \\n            if(isPossible(bloomDay,m,k,mxDay)){\\n                ans=mxDay;\\n                r=mxDay-1;\\n            }else{\\n                l=mxDay+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& bloomDay,int m,int k,int maxDay){\\n        int adj=0,nb=0;\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<=maxDay and adj<k){\\n                adj++;\\n            }else if(bloomDay[i]<=maxDay and adj==k){\\n                nb++;\\n                adj=1;\\n            }else if(bloomDay[i]>maxDay and adj<k){\\n                adj=0;\\n            }else if(bloomDay[i]>maxDay and adj==k){\\n                nb++;\\n                adj=0;\\n            }\\n        }\\n        if(adj==k){\\n            nb++;\\n        }\\n        return nb>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int l=*min_element(bloomDay.begin(),bloomDay.end());\\n        int r=*max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=-1;\\n        while(l<=r){\\n            int mxDay=l+(r-l)/2;\\n            \\n            if(isPossible(bloomDay,m,k,mxDay)){\\n                ans=mxDay;\\n                r=mxDay-1;\\n            }else{\\n                l=mxDay+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105742,
                "title": "by-dog-stepped-on-bee",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] d, int m, int k) {\\n        int l=0;\\n        int h=0;\\n        int ans=-1;\\n        for(int x:d)if(x>h)h=x;\\n        while(l<=h){\\n            int mi=l+(h-l)/2;\\n            int c=0,dt=0;\\n            for(int x:d){\\n                \\n                if(x<=mi)dt++;\\n                else{\\n                    dt=0;\\n                }\\n                if(dt==k){\\n                    dt=0;\\n                    c++;\\n                }\\n            }\\n            if(c>=m){\\n                ans=mi;\\n                h=mi-1;\\n            }\\n            else{\\n                l=mi+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] d, int m, int k) {\\n        int l=0;\\n        int h=0;\\n        int ans=-1;\\n        for(int x:d)if(x>h)h=x;\\n        while(l<=h){\\n            int mi=l+(h-l)/2;\\n            int c=0,dt=0;\\n            for(int x:d){\\n                \\n                if(x<=mi)dt++;\\n                else{\\n                    dt=0;\\n                }\\n                if(dt==k){\\n                    dt=0;\\n                    c++;\\n                }\\n            }\\n            if(c>=m){\\n                ans=mi;\\n                h=mi-1;\\n            }\\n            else{\\n                l=mi+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950829,
                "title": "simple-and-clear-code-using-binary-search-on-answer",
                "content": "class Solution {\\npublic:\\n    bool ispossible(vector<int>& a, int m, int k,int mid){\\n        int c=0,mc=0;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]<=mid){\\n                c++;\\n                if(c>=k){\\n                   mc++;\\n                    c=0;\\n                }\\n            }\\n            else{\\n                c=0;\\n            }           \\n        }\\n        if(mc>=m)\\n            return true;\\n        return false;\\n    }\\n    int minDays(vector<int>& a, int m, int k) {\\n        int ans=-1,s=0,c=0,n=a.size(),maxi=0;\\n        if(n<m*k)\\n            return -1;\\n        for(int i=0;i<n;i++)\\n            maxi=max(maxi,a[i]);\\n        int l=1,h=maxi;\\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            if(ispossible(a,m,k,mid)){\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool ispossible(vector<int>& a, int m, int k,int mid){\\n        int c=0,mc=0;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]<=mid){\\n                c++;\\n                if(c>=k){\\n                   mc++;\\n                    c=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1950080,
                "title": "javascript-typescript-binary-search-explained-in-code",
                "content": "Following the great binary search template. Same idea as 875 Koko\\'s Bananas.\\n\\nThe search range is whatever we are trying to minimise. Here it is the number of days to pick all required bouquets.\\nso [1, maxDays] where maxDays is max day in bloomDay.\\n\\nSo for each binary search day, we test if it is possible to pick all the required flowers under constraints on with this day value.\\nCreating the function is the hard part imo, I had to look at the hint cos i was using sliding window at first lol ._.\\n\\n\\n```\\nfunction minDays(bloomDay: number[], m: number, k: number): number {\\n    // find min number of days to make m bouquets with k flowers\\n    // min no. of days. range is [1, max(bloomDay)];\\n    let maxDays = 0;\\n    // o(n)\\n    for(const d of bloomDay) {\\n        maxDays = Math.max(maxDays, d);\\n    }\\n    \\n    let left = 1;\\n    let right = maxDays;\\n\\n    // log(maxDays)\\n    while(left <= right) {\\n        // daysElapsed\\n        const mid = Math.floor(left + (right-left) / 2);\\n        \\n        // can we pick m bouquets with k flowers at daysELapsed\\n        if(canPickAllFlowers(bloomDay, mid, m, k)) {\\n            // shrink range find left border\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    // o(n*log(maxDays));\\n    if(left > maxDays) {\\n        return -1;\\n    }\\n    return left;\\n};\\n\\n// o(n);\\nfunction canPickAllFlowers(bloomDay: number[], daysElapsed: number, m: number, k: number) {\\n    let bouquetsPicked = 0;\\n    let numAdjFlowers = 0;\\n    \\n    for(const d of bloomDay) {\\n\\t\\t// can pick this flower as it is within our test day\\n\\t\\tif(d <= daysElapsed) {\\n\\t\\t\\t// add to num of adjacents\\n            numAdjFlowers++;\\n\\t\\t\\t// if enough flowers (constraint k flowers per bouquet, add to bouquet count)\\n            if(numAdjFlowers === k) {\\n                bouquetsPicked++;\\n\\t\\t\\t\\t// reset for next element\\n                numAdjFlowers = 0;\\n            }\\n        } else {\\n            numAdjFlowers = 0;\\n        }\\n    }\\n\\n    // do we have enough bouquets\\n    return bouquetsPicked >= m;\\n}```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Binary Tree"
                ],
                "code": "```\\nfunction minDays(bloomDay: number[], m: number, k: number): number {\\n    // find min number of days to make m bouquets with k flowers\\n    // min no. of days. range is [1, max(bloomDay)];\\n    let maxDays = 0;\\n    // o(n)\\n    for(const d of bloomDay) {\\n        maxDays = Math.max(maxDays, d);\\n    }\\n    \\n    let left = 1;\\n    let right = maxDays;\\n\\n    // log(maxDays)\\n    while(left <= right) {\\n        // daysElapsed\\n        const mid = Math.floor(left + (right-left) / 2);\\n        \\n        // can we pick m bouquets with k flowers at daysELapsed\\n        if(canPickAllFlowers(bloomDay, mid, m, k)) {\\n            // shrink range find left border\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    // o(n*log(maxDays));\\n    if(left > maxDays) {\\n        return -1;\\n    }\\n    return left;\\n};\\n\\n// o(n);\\nfunction canPickAllFlowers(bloomDay: number[], daysElapsed: number, m: number, k: number) {\\n    let bouquetsPicked = 0;\\n    let numAdjFlowers = 0;\\n    \\n    for(const d of bloomDay) {\\n\\t\\t// can pick this flower as it is within our test day\\n\\t\\tif(d <= daysElapsed) {\\n\\t\\t\\t// add to num of adjacents\\n            numAdjFlowers++;\\n\\t\\t\\t// if enough flowers (constraint k flowers per bouquet, add to bouquet count)\\n            if(numAdjFlowers === k) {\\n                bouquetsPicked++;\\n\\t\\t\\t\\t// reset for next element\\n                numAdjFlowers = 0;\\n            }\\n        } else {\\n            numAdjFlowers = 0;\\n        }\\n    }\\n\\n    // do we have enough bouquets\\n    return bouquetsPicked >= m;\\n}```",
                "codeTag": "Unknown"
            },
            {
                "id": 1940088,
                "title": "js-iterative-and-binary-search",
                "content": "The easiest way to solve these binary search problems is to start by implementing the iterative solution like so:\\n\\n```\\nvar minDays = function(bloomDay, m, k) {\\n    const requiredFlowers = k * m;\\n    if(bloomDay.length < requiredFlowers) return -1;\\n    \\n    const canMakeBouquets = (day) => {\\n        let bouquets = 0;\\n        let currentRun = 0;\\n        for(let i = 0; i < bloomDay.length; i++) {\\n            if(bloomDay[i] <= day) {\\n                currentRun++;\\n            } else {\\n                currentRun = 0;\\n            }\\n            if(currentRun === k){\\n                bouquets++;\\n                currentRun = 0;\\n            }\\n        }\\n        return bouquets >= m;\\n    }\\n    \\n    let right = Math.max(...bloomDay);\\n    \\n    for(let day = 1; day <= right; day++) {\\n        if(canMakeBouquets(day)) {\\n            return day;\\n        }\\n    }\\n};\\n```\\n\\nThen just replace the for-loop with a binary search:\\n\\n```\\nvar minDays = function(bloomDay, m, k) {\\n    const requiredFlowers = k * m;\\n    if(bloomDay.length < requiredFlowers) return -1;\\n    \\n    const canMakeBouquets = (day) => {\\n        let bouquets = 0;\\n        let currentRun = 0;\\n        for(let i = 0; i < bloomDay.length; i++) {\\n            if(bloomDay[i] <= day) {\\n                currentRun++;\\n            } else {\\n                currentRun = 0;\\n            }\\n            if(currentRun === k){\\n                bouquets++;\\n                currentRun = 0;\\n            }\\n        }\\n        return bouquets >= m;\\n    }\\n    \\n    let left = 1;\\n    let right = Math.max(...bloomDay);\\n    \\n    while(left < right) {\\n        let day = Math.floor((left + right) / 2);\\n        if(canMakeBouquets(day)) {\\n            right = day;\\n        } else {\\n            left = day+1;\\n        }\\n    }\\n    return left;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minDays = function(bloomDay, m, k) {\\n    const requiredFlowers = k * m;\\n    if(bloomDay.length < requiredFlowers) return -1;\\n    \\n    const canMakeBouquets = (day) => {\\n        let bouquets = 0;\\n        let currentRun = 0;\\n        for(let i = 0; i < bloomDay.length; i++) {\\n            if(bloomDay[i] <= day) {\\n                currentRun++;\\n            } else {\\n                currentRun = 0;\\n            }\\n            if(currentRun === k){\\n                bouquets++;\\n                currentRun = 0;\\n            }\\n        }\\n        return bouquets >= m;\\n    }\\n    \\n    let right = Math.max(...bloomDay);\\n    \\n    for(let day = 1; day <= right; day++) {\\n        if(canMakeBouquets(day)) {\\n            return day;\\n        }\\n    }\\n};\\n```\n```\\nvar minDays = function(bloomDay, m, k) {\\n    const requiredFlowers = k * m;\\n    if(bloomDay.length < requiredFlowers) return -1;\\n    \\n    const canMakeBouquets = (day) => {\\n        let bouquets = 0;\\n        let currentRun = 0;\\n        for(let i = 0; i < bloomDay.length; i++) {\\n            if(bloomDay[i] <= day) {\\n                currentRun++;\\n            } else {\\n                currentRun = 0;\\n            }\\n            if(currentRun === k){\\n                bouquets++;\\n                currentRun = 0;\\n            }\\n        }\\n        return bouquets >= m;\\n    }\\n    \\n    let left = 1;\\n    let right = Math.max(...bloomDay);\\n    \\n    while(left < right) {\\n        let day = Math.floor((left + right) / 2);\\n        if(canMakeBouquets(day)) {\\n            right = day;\\n        } else {\\n            left = day+1;\\n        }\\n    }\\n    return left;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1929329,
                "title": "binary-search-python-solution-75-faster-memory-less-than-50",
                "content": "### ***Solution: Time O(n log(max)) / Memory O(1)***\\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        def is_Possible(day):\\n            flowers=bouquet=0                \\n            for d in bloomDay:\\n                if d>day: flowers=0\\n                else:\\n                    flowers+=1\\n                    if flowers==k: bouquet+=1 ; flowers=0\\n            return bouquet>=m\\n            \\n        if len(bloomDay)<m*k: return -1       \\n        lo=min(bloomDay) ; hi=max(bloomDay)\\n        while lo<hi: \\n            mid=(lo+hi)//2 \\n            if is_Possible(mid): hi=mid          \\n            else: lo=mid+1\\n        return hi\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        def is_Possible(day):\\n            flowers=bouquet=0                \\n            for d in bloomDay:\\n                if d>day: flowers=0\\n                else:\\n                    flowers+=1\\n                    if flowers==k: bouquet+=1 ; flowers=0\\n            return bouquet>=m\\n            \\n        if len(bloomDay)<m*k: return -1       \\n        lo=min(bloomDay) ; hi=max(bloomDay)\\n        while lo<hi: \\n            mid=(lo+hi)//2 \\n            if is_Possible(mid): hi=mid          \\n            else: lo=mid+1\\n        return hi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908205,
                "title": "java-o-nlog-max-binary-search-on-answer",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(m*k>bloomDay.length)\\n            return -1;\\n        \\n        int low=bloomDay[0],high=bloomDay[0];\\n        \\n        for(int x : bloomDay){\\n            low=Math.min(low,x);\\n            high=Math.max(high,x);\\n        }\\n        \\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            int bouqetsPossible=search(bloomDay,mid,k);\\n            \\n            if(bouqetsPossible<m)\\n                low=mid+1;\\n            else\\n                high=mid-1;\\n        }\\n        return low; \\n    }\\n    \\n    int search(int[] ar,int val,int k){\\n        int res=0;\\n        int i=0,n=ar.length;\\n        \\n        while(i<n){\\n            int j=i;\\n            int cnt=0;\\n            while(j<i+k && j<n){\\n                if(ar[j]<=val)\\n                    cnt++;\\n                else\\n                    break;\\n                j++;\\n            }\\n            if(cnt==k)\\n            {\\n                res++;\\n                i=j;\\n            }\\n            else\\n                i=j+1;\\n        } \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(m*k>bloomDay.length)\\n            return -1;\\n        \\n        int low=bloomDay[0],high=bloomDay[0];\\n        \\n        for(int x : bloomDay){\\n            low=Math.min(low,x);\\n            high=Math.max(high,x);\\n        }\\n        \\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            int bouqetsPossible=search(bloomDay,mid,k);\\n            \\n            if(bouqetsPossible<m)\\n                low=mid+1;\\n            else\\n                high=mid-1;\\n        }\\n        return low; \\n    }\\n    \\n    int search(int[] ar,int val,int k){\\n        int res=0;\\n        int i=0,n=ar.length;\\n        \\n        while(i<n){\\n            int j=i;\\n            int cnt=0;\\n            while(j<i+k && j<n){\\n                if(ar[j]<=val)\\n                    cnt++;\\n                else\\n                    break;\\n                j++;\\n            }\\n            if(cnt==k)\\n            {\\n                res++;\\n                i=j;\\n            }\\n            else\\n                i=j+1;\\n        } \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901274,
                "title": "c-easy-to-undestand-with-explanation",
                "content": "**Approach:-** Applying Binary Search on Answer Approach.\\n-->What Actully we are doing?\\n\\n-->**The Lowest Day we require** = Minimum Element of array.\\n-->**The Highest Day we require is** = Maximum Element of array.\\n\\nNow We Check In Between thease days:-\\n**We Calculate a mid day.:-**\\nAnd For Mid day we check how many Bouquets we will form by taking consecutive **k** flowers(whithin mid day)\\n\\n-->If the total number of Bouquets form within mid day is greater than equal to **m**\\n  -->Then this is our one of the Possible answer. so we update high=mid-1; \\n  \\n-->If the total number of boquet form within mid day is less than m.\\nthen we increase low=mid+1;\\n\\n\\nTo understand what is happening inside **isPossible** function look at the code and read comment.\\n```\\nclass Solution {\\npublic: \\n    bool isPossible(vector<int>&nums,int mid,int k,int m)\\n    {\\n        /*Its Little bit Sliding window type.\\n        But not same*/\\n        int i=0,n=nums.size(),count=0;\\n        \\n        while(i+k-1<n) //For Every window of k from starting from any index i.\\n        {\\n            int mx=INT_MIN;\\n            int index=-1;\\n            for(int j=i;j<=i+k-1;j++) //For that window we will find maximimum element and its index.\\n            {\\n                if(nums[j]>=mx)\\n                    mx=nums[j],index=j;\\n            }\\n            if(mx>mid) //for that window if mx>mid, means it is not Possible to form boquest withim mid days.\\n                i=index+1; //So we increase our i to index+1.\\n            else\\n            {\\n                i=i+k; //i=i+k means ,this window is ok ,search for wIndOw after that window.\\n                count++; //Increase the Count\\n            }\\n        }\\n        \\n        return count>=m?1:0; //If count is greater than m means it is possible ans.\\n    }\\n    int minDays(vector<int>& nums, int m, int k) {\\n        int low=*min_element(nums.begin(),nums.end()); //Lowest days we require,\\n        int high=*max_element(nums.begin(),nums.end()); //Highest days we require\\n        \\n        int ans=-1;\\n        \\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            \\n            if(isPossible(nums,mid,k,m))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n*If you find it helpful. Please upvote.*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    bool isPossible(vector<int>&nums,int mid,int k,int m)\\n    {\\n        /*Its Little bit Sliding window type.\\n        But not same*/\\n        int i=0,n=nums.size(),count=0;\\n        \\n        while(i+k-1<n) //For Every window of k from starting from any index i.\\n        {\\n            int mx=INT_MIN;\\n            int index=-1;\\n            for(int j=i;j<=i+k-1;j++) //For that window we will find maximimum element and its index.\\n            {\\n                if(nums[j]>=mx)\\n                    mx=nums[j],index=j;\\n            }\\n            if(mx>mid) //for that window if mx>mid, means it is not Possible to form boquest withim mid days.\\n                i=index+1; //So we increase our i to index+1.\\n            else\\n            {\\n                i=i+k; //i=i+k means ,this window is ok ,search for wIndOw after that window.\\n                count++; //Increase the Count\\n            }\\n        }\\n        \\n        return count>=m?1:0; //If count is greater than m means it is possible ans.\\n    }\\n    int minDays(vector<int>& nums, int m, int k) {\\n        int low=*min_element(nums.begin(),nums.end()); //Lowest days we require,\\n        int high=*max_element(nums.begin(),nums.end()); //Highest days we require\\n        \\n        int ans=-1;\\n        \\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            \\n            if(isPossible(nums,mid,k,m))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859061,
                "title": "python-very-easy-brute-and-optimal-solutions",
                "content": "\\u274C **Solution 1:**  Sort the bloomDays and Linear Search each day and check whether it is possible or not. If it is possible then directly return it because is sorted, day will be minimum\\n\\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        def isPossible(pluckDay):               # this function to check if a day is possible will be used in all the below solutions.\\n            flowers = bouquet = 0\\n            for d in bloomDay:\\n                if d > pluckDay: flowers = 0\\n                else:\\n                    flowers += 1\\n                    if flowers == k:\\n                        bouquet += 1\\n                        flowers = 0\\n            return bouquet >= m\\n          \\n        arr = sorted(list(set(bloomDay)))\\n        \\n        for day in arr:\\n            if isPossible(day): return day\\n        return -1\\n```\\n***\\n```Time Complexity   : O(N*N)```\\n```Space Complexity: O(N) taking another list```\\n***\\n\\n\\u2714 **Solution: 2** (Binary Search between min and max Days)\\nWe know answer will lie beween this min max range. Why?\\nIts easy, we cant make a bouquet when no flower is bloomed(ie first day where atleast one flower is bloomed) or  why would be go after the maxDay when all flower is already bloomed, taking extra day is absurd.\\n\\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        def isPossible(pluckDay):                 # pluckDay: the day when we pluck the flower\\n            flowers = bouquet = 0                 # flowers: to count number of flowers bloomed: bouquet: No of bouquets made\\n            for d in bloomDay:                    # traverse each bloomDay\\n                if d > pluckDay: flowers = 0      # if bloomDay > pluckDay, it means it means that flowers is not yet bloomed, so we cant pluck it on that day, reset it to zero as it break the adjacency streak\\n                else:                             # else the flower is bloomed\\n                    flowers += 1                  # increment the flower counter\\n                    if flowers == k:              # if we have k adjacents, then make a bouquet\\n                        bouquet += 1\\n                        flowers = 0               # also the streak is broken as the flower is already used\\n            return bouquet >= m                   # return whether we had surpass or match the bouqeut making thresold\\n            \\n        if len(bloomDay) < m * k: return -1       # if number of flower is less than required, we cannot make it, so return -1 in that case\\n        \\n        l, h = min(bloomDay), max(bloomDay)\\n        while l < h: \\n            day = (l + h) // 2 \\n            if isPossible(day): h = day           # if possible then we will check for lower days because we need to minimise. h = day bcoz we dont want lose what we got,\\n            else: l = day + 1\\n        return h\\n```\\n***\\n```Time Complexity: O(N*Log(max))```\\n```Space Complexity: O(1)```\\n***\\n\\n\\n\\u2714 **Solution 3:** Copy the list, Sort it and then do the binary search to pick and check days.\\n\\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        def isPossible(pluckDay):\\n            flowers = bouquet = 0\\n            for d in bloomDay:\\n                if d > pluckDay: flowers = 0\\n                else:\\n                    flowers += 1\\n                    if flowers == k:\\n                        bouquet += 1\\n                        flowers = 0\\n            return bouquet >= m\\n            \\n        if len(bloomDay) < m * k: return -1    \\n        \\n        arr = sorted(list(set(bloomDay)))\\n        \\n        l = 0; h = len(arr) - 1\\n        while l < h: \\n            mid = (l + h) // 2\\n            day = arr[mid]\\n            if isPossible(day): h = mid\\n            else: l = mid + 1\\n        return arr[h]\\n```\\n***\\n```Time Complexity: O(N*Log(N))```\\n```Space Complexity: O(N) taking another list```\\n***\\n\\n***If you have any questions or you think above solutions can further be optimised, please do comment below.***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        def isPossible(pluckDay):               # this function to check if a day is possible will be used in all the below solutions.\\n            flowers = bouquet = 0\\n            for d in bloomDay:\\n                if d > pluckDay: flowers = 0\\n                else:\\n                    flowers += 1\\n                    if flowers == k:\\n                        bouquet += 1\\n                        flowers = 0\\n            return bouquet >= m\\n          \\n        arr = sorted(list(set(bloomDay)))\\n        \\n        for day in arr:\\n            if isPossible(day): return day\\n        return -1\\n```\n```Time Complexity   : O(N*N)```\n```Space Complexity: O(N) taking another list```\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        def isPossible(pluckDay):                 # pluckDay: the day when we pluck the flower\\n            flowers = bouquet = 0                 # flowers: to count number of flowers bloomed: bouquet: No of bouquets made\\n            for d in bloomDay:                    # traverse each bloomDay\\n                if d > pluckDay: flowers = 0      # if bloomDay > pluckDay, it means it means that flowers is not yet bloomed, so we cant pluck it on that day, reset it to zero as it break the adjacency streak\\n                else:                             # else the flower is bloomed\\n                    flowers += 1                  # increment the flower counter\\n                    if flowers == k:              # if we have k adjacents, then make a bouquet\\n                        bouquet += 1\\n                        flowers = 0               # also the streak is broken as the flower is already used\\n            return bouquet >= m                   # return whether we had surpass or match the bouqeut making thresold\\n            \\n        if len(bloomDay) < m * k: return -1       # if number of flower is less than required, we cannot make it, so return -1 in that case\\n        \\n        l, h = min(bloomDay), max(bloomDay)\\n        while l < h: \\n            day = (l + h) // 2 \\n            if isPossible(day): h = day           # if possible then we will check for lower days because we need to minimise. h = day bcoz we dont want lose what we got,\\n            else: l = day + 1\\n        return h\\n```\n```Time Complexity: O(N*Log(max))```\n```Space Complexity: O(1)```\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        def isPossible(pluckDay):\\n            flowers = bouquet = 0\\n            for d in bloomDay:\\n                if d > pluckDay: flowers = 0\\n                else:\\n                    flowers += 1\\n                    if flowers == k:\\n                        bouquet += 1\\n                        flowers = 0\\n            return bouquet >= m\\n            \\n        if len(bloomDay) < m * k: return -1    \\n        \\n        arr = sorted(list(set(bloomDay)))\\n        \\n        l = 0; h = len(arr) - 1\\n        while l < h: \\n            mid = (l + h) // 2\\n            day = arr[mid]\\n            if isPossible(day): h = mid\\n            else: l = mid + 1\\n        return arr[h]\\n```\n```Time Complexity: O(N*Log(N))```\n```Space Complexity: O(N) taking another list```",
                "codeTag": "Java"
            },
            {
                "id": 1842863,
                "title": "c-there-were-many-simillar-question-there-on-leetcode",
                "content": "//\\n\\n     there were many simailar question on leetcode .only the difference on the valid function...\\n\\t ## credit : Aditya Verma Sir....\\n\\n\\nclass Solution {\\npublic:\\n\\n\\n    bool isvalid(vector<int>bloomDay,int m,int k,int mid)\\n    {\\n        int count=0;\\n       for(int i=0;i<bloomDay.size();i++)\\n       {\\n            if(bloomDay[i]<=mid)count++;\\n        else if(bloomDay[i]>mid)count=0;\\n        if(count==k)\\n        {\\n            m--;\\n            count=0;\\n        }\\n        if(m==0)\\n            return true;\\n       }\\n        \\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(m*k>bloomDay.size())\\n            return -1;\\n        int i=1;\\n        int j=*max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=-1;\\n        while(i<=j)\\n        {\\n            int mid=i+(j-i)/2;\\n            if(isvalid(bloomDay,m,k,mid))\\n            {\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else\\n                i=mid+1;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n    bool isvalid(vector<int>bloomDay,int m,int k,int mid)\\n    {\\n        int count=0;\\n       for(int i=0;i<bloomDay.size();i++)\\n       {\\n            if(bloomDay[i]<=mid)count++;\\n        else if(bloomDay[i]>mid)count=0;\\n        if(count==k)\\n        {\\n            m--;\\n            count=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1820808,
                "title": "c-binary-search-readable-code-aditya-verma-template",
                "content": "\\tbool checkIfPossible(int mid, int m, int k, vector<int>& bloomDay){\\n\\t\\t\\tint windowsize=0;\\n\\t\\t\\tfor(int i =0; i<bloomDay.size();i++){\\n\\t\\t\\t\\tif(bloomDay[i]<=mid)windowsize++;\\n\\t\\t\\t\\telse if(bloomDay[i]>mid)windowsize=0;\\n\\t\\t\\t\\tif(windowsize==k){\\n\\t\\t\\t\\t\\tm--;\\n\\t\\t\\t\\t\\twindowsize=0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(m==0){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint minDays(vector<int>& bloomDay, int m, int k) {\\n\\t\\t\\tif(m*k>bloomDay.size()) return -1;\\n\\t\\t\\tint high=bloomDay[0];\\n\\t\\t\\tfor(auto i: bloomDay) high=max(high,i);\\n\\t\\t\\tint result =high;\\n\\t\\t\\tint low=0;\\n\\t\\t\\twhile(low<=high){\\n\\t\\t\\t\\tint mid= low + (high-low)/2;\\n\\t\\t\\t\\tif(checkIfPossible(mid, m, k, bloomDay)){\\n\\t\\t\\t\\t\\tresult=mid;\\n\\t\\t\\t\\t\\thigh=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tlow=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "\\tbool checkIfPossible(int mid, int m, int k, vector<int>& bloomDay){\\n\\t\\t\\tint windowsize=0;\\n\\t\\t\\tfor(int i =0; i<bloomDay.size();i++){\\n\\t\\t\\t\\tif(bloomDay[i]<=mid)windowsize++;\\n\\t\\t\\t\\telse if(bloomDay[i]>mid)windowsize=0;\\n\\t\\t\\t\\tif(windowsize==k){\\n\\t\\t\\t\\t\\tm--;\\n\\t\\t\\t\\t\\twindowsize=0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(m==0){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint minDays(vector<int>& bloomDay, int m, int k) {\\n\\t\\t\\tif(m*k>bloomDay.size()) return -1;\\n\\t\\t\\tint high=bloomDay[0];\\n\\t\\t\\tfor(auto i: bloomDay) high=max(high,i);\\n\\t\\t\\tint result =high;\\n\\t\\t\\tint low=0;\\n\\t\\t\\twhile(low<=high){\\n\\t\\t\\t\\tint mid= low + (high-low)/2;\\n\\t\\t\\t\\tif(checkIfPossible(mid, m, k, bloomDay)){\\n\\t\\t\\t\\t\\tresult=mid;\\n\\t\\t\\t\\t\\thigh=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tlow=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1744942,
                "title": "java-92-faster-binary-search-very-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int len = bloomDay.length;\\n        \\n        int min=Integer.MAX_VALUE,max=Integer.MIN_VALUE;\\n        for(int i=0;i<len;i++){\\n            min = Math.min(bloomDay[i],min);\\n            max = Math.max(bloomDay[i],max);\\n        }\\n        int s=min,e=max,ans=-1;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(isPossible(bloomDay,mid,m,k)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean isPossible(int[] arr,int days,int m,int k){\\n        int len = arr.length;\\n        int start=0,end=0;\\n        for(;end<len;end++){\\n            if(arr[end]>days){\\n                m-=(end-start)/k;\\n                start=end+1;\\n            }\\n        }\\n        m-=(end-start)/k;\\n        return m<=0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int len = bloomDay.length;\\n        \\n        int min=Integer.MAX_VALUE,max=Integer.MIN_VALUE;\\n        for(int i=0;i<len;i++){\\n            min = Math.min(bloomDay[i],min);\\n            max = Math.max(bloomDay[i],max);\\n        }\\n        int s=min,e=max,ans=-1;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(isPossible(bloomDay,mid,m,k)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean isPossible(int[] arr,int days,int m,int k){\\n        int len = arr.length;\\n        int start=0,end=0;\\n        for(;end<len;end++){\\n            if(arr[end]>days){\\n                m-=(end-start)/k;\\n                start=end+1;\\n            }\\n        }\\n        m-=(end-start)/k;\\n        return m<=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716567,
                "title": "simple-java-soloution-o-logn",
                "content": "class Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        \\n        int low=Integer.MAX_VALUE,high=-1,n=bloomDay.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            low=Math.min(low,bloomDay[i]);\\n            high=Math.max(high,bloomDay[i]);\\n        }\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n           int mid=low+(-low+high)/2;\\n           int i=0,j=0;\\n            int tmp=0;\\n            while(i<n)\\n            {\\n                if(bloomDay[i]<=mid)\\n                {\\n                    i++;\\n                }\\n                else\\n                {\\n                   tmp+=(i-j)/k;\\n                   i++;\\n                   j=i;\\n                }\\n            }\\n            tmp+=(i-j)/k;\\n           // System.out.println(mid+\" \"+tmp);\\n            if(tmp>=m)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        \\n        int low=Integer.MAX_VALUE,high=-1,n=bloomDay.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            low=Math.min(low,bloomDay[i]);\\n            high=Math.max(high,bloomDay[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1708887,
                "title": "java-allocate-books-pattern-binary-search",
                "content": "```\\nclass Solution {\\n    \\n    \\n    public boolean isValid(int[] arr, int m, int k, int currDay){\\n        \\n        int numOfFlowers = 0;\\n        int numBouquets = 0;\\n\\n        \\n        for(int i=0; i<arr.length; i++){\\n            \\n            if(currDay >= arr[i]){\\n                numOfFlowers++;\\n            }\\n            else{\\n                numOfFlowers = 0;\\n            }\\n            \\n            if(numOfFlowers == k){\\n                numBouquets++;\\n                numOfFlowers = 0;\\n            }\\n            \\n            if(numBouquets >= m){\\n                return true;\\n            }\\n            \\n            \\n        }\\n        \\n\\n        return false;\\n        \\n    }\\n\\n    \\n    \\n    public int minDays(int[] bloomDay, int m, int k) {\\n        \\n        int n = bloomDay.length;\\n        \\n        int start = 0;\\n        // max ele from bloomDay\\n        int end = Arrays.stream(bloomDay).max().getAsInt();\\n        \\n        int result = -1;\\n        \\n        while(start<=end){\\n            \\n            int day = start + ((end-start)/2);\\n            \\n            if(isValid(bloomDay, m, k, day)== true){\\n                result = day;\\n                end = day-1;\\n            }\\n            else{\\n                start = day+1;\\n            }\\n            \\n            \\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n    public boolean isValid(int[] arr, int m, int k, int currDay){\\n        \\n        int numOfFlowers = 0;\\n        int numBouquets = 0;\\n\\n        \\n        for(int i=0; i<arr.length; i++){\\n            \\n            if(currDay >= arr[i]){\\n                numOfFlowers++;\\n            }\\n            else{\\n                numOfFlowers = 0;\\n            }\\n            \\n            if(numOfFlowers == k){\\n                numBouquets++;\\n                numOfFlowers = 0;\\n            }\\n            \\n            if(numBouquets >= m){\\n                return true;\\n            }\\n            \\n            \\n        }\\n        \\n\\n        return false;\\n        \\n    }\\n\\n    \\n    \\n    public int minDays(int[] bloomDay, int m, int k) {\\n        \\n        int n = bloomDay.length;\\n        \\n        int start = 0;\\n        // max ele from bloomDay\\n        int end = Arrays.stream(bloomDay).max().getAsInt();\\n        \\n        int result = -1;\\n        \\n        while(start<=end){\\n            \\n            int day = start + ((end-start)/2);\\n            \\n            if(isValid(bloomDay, m, k, day)== true){\\n                result = day;\\n                end = day-1;\\n            }\\n            else{\\n                start = day+1;\\n            }\\n            \\n            \\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657888,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n\\tbool isValid(vector<int>& A, int m, int k, int x) {\\n\\n\\t\\tint cnt = 0, size = 0;\\n\\t\\tfor (int i = 0; i < A.size(); i++) {\\n\\t\\t\\tsize = (A[i] <= x) ? size+1 : 0;\\n\\t\\t\\tif (size == k) size = 0, cnt++;\\n\\t\\t\\tif (cnt == m)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        if(n<k*m)\\n            return -1;\\n        int lo = *min_element(bloomDay.begin(),bloomDay.end());\\n        int hi = *max_element(bloomDay.begin(),bloomDay.end());\\n        int ans = -1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(isValid(bloomDay,m,k,mid)){\\n                hi = mid-1;\\n                ans = mid;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool isValid(vector<int>& A, int m, int k, int x) {\\n\\n\\t\\tint cnt = 0, size = 0;\\n\\t\\tfor (int i = 0; i < A.size(); i++) {\\n\\t\\t\\tsize = (A[i] <= x) ? size+1 : 0;\\n\\t\\t\\tif (size == k) size = 0, cnt++;\\n\\t\\t\\tif (cnt == m)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        if(n<k*m)\\n            return -1;\\n        int lo = *min_element(bloomDay.begin(),bloomDay.end());\\n        int hi = *max_element(bloomDay.begin(),bloomDay.end());\\n        int ans = -1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(isValid(bloomDay,m,k,mid)){\\n                hi = mid-1;\\n                ans = mid;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657052,
                "title": "c-binary-search-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s = 0, e = *max_element(bloomDay.begin(), bloomDay.end());\\n        int ans = -1;\\n        int mid = s + (e-s)/2;\\n        while(s<=e){\\n            if(isPossible(bloomDay, mid, m, k)){\\n                ans = mid;\\n                e = mid-1;\\n            }\\n            else{\\n                s = mid+1;\\n            }\\n            mid = s + (e-s)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(vector<int>& bDay, int mid, int m, int k){\\n        int adjacent = 0, count = 0;\\n        for(int i = 0; i < bDay.size(); i++){\\n            if(bDay[i] <= mid){\\n                adjacent++;\\n            }\\n            else{\\n                adjacent = 0;\\n            }\\n            if(adjacent==k){\\n                count++;\\n                adjacent = 0;\\n            }\\n        }\\n        if(count < m){\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s = 0, e = *max_element(bloomDay.begin(), bloomDay.end());\\n        int ans = -1;\\n        int mid = s + (e-s)/2;\\n        while(s<=e){\\n            if(isPossible(bloomDay, mid, m, k)){\\n                ans = mid;\\n                e = mid-1;\\n            }\\n            else{\\n                s = mid+1;\\n            }\\n            mid = s + (e-s)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(vector<int>& bDay, int mid, int m, int k){\\n        int adjacent = 0, count = 0;\\n        for(int i = 0; i < bDay.size(); i++){\\n            if(bDay[i] <= mid){\\n                adjacent++;\\n            }\\n            else{\\n                adjacent = 0;\\n            }\\n            if(adjacent==k){\\n                count++;\\n                adjacent = 0;\\n            }\\n        }\\n        if(count < m){\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636706,
                "title": "c-binary-search-with-intuition",
                "content": "We need to find the minimum time so that we can get m bouquets. \\nTwo cases:\\n1- Its not possible - just take the maximum element in the bloom array and check if we are able to get m bouquets or not. If not so return -1 \\n2- Its possible to find a solution\\nHere we need to find the minimum time so here its clear that we need to do a binary search so we will take the maximum time as the max element in the bloom array and the minimum element as 0. so the we need to see if the current mid gets us m bouquets or not if it does then we can decrease the time (range will be from l to mid) or we need to increase the time range [mid + 1,r] so when we come out of the while we will get the minimum time.\\n\\n```\\nclass Solution {\\npublic:\\n    int check(vector<int>&A,int k,int m,int t)\\n    {\\n        int n = A.size();\\n        int i = 0;\\n        int count = 0;\\n        while(i < n)\\n        {\\n            if(A[i] > t)\\n            {\\n                count = 0;\\n            }\\n            else\\n            {\\n                count++; \\n            }\\n            \\n            if(count == k)\\n            {\\n                m--;\\n                count = 0;\\n            }\\n            i++;\\n        }\\n        return (m <= 0);\\n    }\\n    int minDays(vector<int>&A, int m, int k) {\\n        int n = A.size();\\n        int l = 0;\\n        int r = *max_element(A.begin(), A.end());\\n        if(check(A,k,m,r) != 1)\\n            return -1;\\n        while(l < r)\\n        {\\n            int mid = (l + r) / 2;\\n            if(check(A,k,m,mid) != 1)\\n                l = mid + 1;\\n            else\\n                r = mid;\\n                \\n        }\\n        return r;\\n        \\n        \\n    }\\n};\\n```\\nPlease comment if you think there is any error or please give  a upvote if you like the article",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>&A,int k,int m,int t)\\n    {\\n        int n = A.size();\\n        int i = 0;\\n        int count = 0;\\n        while(i < n)\\n        {\\n            if(A[i] > t)\\n            {\\n                count = 0;\\n            }\\n            else\\n            {\\n                count++; \\n            }\\n            \\n            if(count == k)\\n            {\\n                m--;\\n                count = 0;\\n            }\\n            i++;\\n        }\\n        return (m <= 0);\\n    }\\n    int minDays(vector<int>&A, int m, int k) {\\n        int n = A.size();\\n        int l = 0;\\n        int r = *max_element(A.begin(), A.end());\\n        if(check(A,k,m,r) != 1)\\n            return -1;\\n        while(l < r)\\n        {\\n            int mid = (l + r) / 2;\\n            if(check(A,k,m,mid) != 1)\\n                l = mid + 1;\\n            else\\n                r = mid;\\n                \\n        }\\n        return r;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477202,
                "title": "binary-search-o-n-log-n-c-solution-explained",
                "content": "```\\n\\n// count(vector<int>& bloomDay, int d, int k) returns the number of bouquet that can be made if we take \\'d\\' days as the min number of days.\\n// count(bloomDay, d, k) >= m, means that we can easily make \\'m\\' bouquets if we take \\'d\\' as our minimum number of days.\\n// so we store d in a variable \\'res\\' and continued our binary search to find an even better answer if it exits !\\n\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n\\t\\tif(m * k > n) return -1;\\n\\t\\t\\n        int l = INT_MAX, r = -1;\\n        for(int i=0; i<n; i++){\\n            l = min(l, bloomDay[i]);\\n            r = max(r, bloomDay[i]);\\n        }\\n        \\n        int res = r;\\n        while(l <= r){\\n            int d = l + (r - l)/2;\\n            if(count(bloomDay, d, k) >= m){\\n                res = d, r = d-1;\\n            }else{\\n                l = d+1;\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n\\t\\n\\tint count(vector<int>& bloomDay, int d, int k){\\n        int kcnt = 0, mcnt = 0;\\n        for(int i=0; i<bloomDay.size(); i++){\\n            if(d >= bloomDay[i]){\\n                kcnt++;\\n                if(kcnt == k){\\n                    mcnt++;\\n                    kcnt = 0;\\n                }\\n            }else{\\n                kcnt = 0;\\n            }\\n        }\\n        return mcnt;\\n    }\\t\\n\\t\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\n// count(vector<int>& bloomDay, int d, int k) returns the number of bouquet that can be made if we take \\'d\\' days as the min number of days.\\n// count(bloomDay, d, k) >= m, means that we can easily make \\'m\\' bouquets if we take \\'d\\' as our minimum number of days.\\n// so we store d in a variable \\'res\\' and continued our binary search to find an even better answer if it exits !\\n\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n\\t\\tif(m * k > n) return -1;\\n\\t\\t\\n        int l = INT_MAX, r = -1;\\n        for(int i=0; i<n; i++){\\n            l = min(l, bloomDay[i]);\\n            r = max(r, bloomDay[i]);\\n        }\\n        \\n        int res = r;\\n        while(l <= r){\\n            int d = l + (r - l)/2;\\n            if(count(bloomDay, d, k) >= m){\\n                res = d, r = d-1;\\n            }else{\\n                l = d+1;\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n\\t\\n\\tint count(vector<int>& bloomDay, int d, int k){\\n        int kcnt = 0, mcnt = 0;\\n        for(int i=0; i<bloomDay.size(); i++){\\n            if(d >= bloomDay[i]){\\n                kcnt++;\\n                if(kcnt == k){\\n                    mcnt++;\\n                    kcnt = 0;\\n                }\\n            }else{\\n                kcnt = 0;\\n            }\\n        }\\n        return mcnt;\\n    }\\t\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433661,
                "title": "c-binary-search",
                "content": "```\\n\\n```public:\\n    bool solve(vector<int>&nums,int m,int k,int mid)\\n    {\\n        int i,f=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<=mid)\\n            {\\n                f++;\\n            }\\n            else\\n            {\\n                f=0;\\n            }\\n            if(f==k)\\n            {\\n                count++;\\n                f=0;\\n            }\\n        }\\n        if(count>=m)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    int minDays(vector<int>& nums, int m, int k) {\\n        int i,l=0,r,ans=-1;\\n        r=*max_element(nums.begin(),nums.end());\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(solve(nums,m,k,mid))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400675,
                "title": "c-binary-search-easy-solution-with-explanation-beats-90",
                "content": "This is one of the classic problems which uses the concept of applying binary search on our required answer. The least possible answer is 1 and and the max possible answer should be the maximum bloomDay[i] value because at that time all the flowers would have bloomed.\\n\\nThe only edge case here is that we need to have enough flowers to make m bouquets, otherwise it is always possible to make m bouquets given we wait enough number of days.\\n\\nNow we need to minimize these number of days, we apply the standard binary search procedure here and check if it is possible to make m bouquets in (mid) days now, if it is possible then the paradigm of binary search dictates that we must get a smaller answer, hence we decrease our search space to low-->mid-1 else if its not possible to make m bouquets with m number of days then we must go for a higher number of days hence our search spaces reduces to mid+1-->high.\\n\\nThe check function here is a simple function which checks if it is possible to make m bouquets with the given number of days. The logic is to basically find k continuous bloomed flowers and if found then increase the total count otherwise if the current flower is not bloomed, then we must start from the next flower onwards since the question says that we can pick only adjacent flowers.\\n\\n```\\nclass Solution {\\npublic:\\n    int len;\\n    int minDays(vector<int>& bloomDay, int m, int k) \\n    {\\n        len = bloomDay.size();\\n        if(len/k < m)\\n            return -1;\\n        int low=1,high=*max_element(bloomDay.begin(),bloomDay.end());\\n        int res = -1;\\n        while(low<=high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(check(bloomDay,mid,m,k))\\n            {\\n                res = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n        return res;\\n    }\\n    \\n    bool check(const vector<int>&bloomDay,int cdays,int m,int k)\\n    {\\n        int total_count = 0, current_count = 0;\\n        for(auto &x : bloomDay)\\n        {\\n            if(x<=cdays)\\n            {\\n                ++current_count;\\n                if(current_count==k)\\n                {\\n                    ++total_count;\\n                    current_count = 0;\\n                }\\n            }\\n            else\\n            {\\n                current_count = 0;\\n            }\\n        }\\n        return total_count >= m;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int len;\\n    int minDays(vector<int>& bloomDay, int m, int k) \\n    {\\n        len = bloomDay.size();\\n        if(len/k < m)\\n            return -1;\\n        int low=1,high=*max_element(bloomDay.begin(),bloomDay.end());\\n        int res = -1;\\n        while(low<=high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(check(bloomDay,mid,m,k))\\n            {\\n                res = mid;\\n                high = mid-1;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564996,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1569991,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1566620,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1840885,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1838613,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1574615,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1805210,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1958295,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 2030542,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1845933,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1564996,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1569991,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1566620,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1840885,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1838613,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1574615,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1805210,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1958295,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 2030542,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1845933,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            }
        ]
    }
]