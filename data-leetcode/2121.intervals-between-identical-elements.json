[
    {
        "title": "Intervals Between Identical Elements",
        "question_content": "You are given a 0-indexed array of n integers arr.\nThe interval between two elements in arr is defined as the absolute difference between their indices. More formally, the interval between arr[i] and arr[j] is |i - j|.\nReturn an array intervals of length n where intervals[i] is the sum of intervals between arr[i] and each element in arr with the same value as arr[i].\nNote: |x| is the absolute value of x.\n&nbsp;\nExample 1:\n\nInput: arr = [2,1,3,1,2,3,3]\nOutput: [4,2,7,2,4,4,5]\nExplanation:\n- Index 0: Another 2 is found at index 4. |0 - 4| = 4\n- Index 1: Another 1 is found at index 3. |1 - 3| = 2\n- Index 2: Two more 3s are found at indices 5 and 6. |2 - 5| + |2 - 6| = 7\n- Index 3: Another 1 is found at index 1. |3 - 1| = 2\n- Index 4: Another 2 is found at index 0. |4 - 0| = 4\n- Index 5: Two more 3s are found at indices 2 and 6. |5 - 2| + |5 - 6| = 4\n- Index 6: Two more 3s are found at indices 2 and 5. |6 - 2| + |6 - 5| = 5\n\nExample 2:\n\nInput: arr = [10,5,10,10]\nOutput: [5,0,3,4]\nExplanation:\n- Index 0: Two more 10s are found at indices 2 and 3. |0 - 2| + |0 - 3| = 5\n- Index 1: There is only one 5 in the array, so its sum of intervals to identical elements is 0.\n- Index 2: Two more 10s are found at indices 0 and 3. |2 - 0| + |2 - 3| = 3\n- Index 3: Two more 10s are found at indices 0 and 2. |3 - 0| + |3 - 2| = 4\n\n&nbsp;\nConstraints:\n\n\tn == arr.length\n\t1 <= n <= 105\n\t1 <= arr[i] <= 105",
        "solutions": [
            {
                "id": 1647454,
                "title": "c-prefix-suffix-array-with-explanation",
                "content": "**Explanation**\\n1. store index of the same elements.\\n2. preix will store the sum of absolute diff. from the starting index of current element to the current index.\\n3. suffix will store the sum of absolute diff. from the ending index of current element to the current index.\\n4. for formula see comments .\\n\\nFor understanding i have added picture.Hope it helps.\\nSame thing for suffix.\\n![image](https://assets.leetcode.com/users/images/41a5efcd-7123-461d-87c9-3a4142da0dd8_1640499204.451936.jpeg)\\n\\n**Time Complexity:**-O(n)\\n**Space Complexity:**-O(n)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int size=arr.size();\\n        vector<long long>pre(size,0),suf(size,0),ans(size,0);\\n        unordered_map<int,vector<int>>mp;\\n        \\n        // store index of the same elements.\\n        for(int i=0;i<size;i++)\\n            mp[arr[i]].push_back(i);\\n       //  prefix will store the sum of absolute diff. from the starting index of current element to the current index.\\n        // pre[cur index]=pre[prev index]+ number of same elements before cur element * abs diff of cur element pos and pre element pos\\n        for(auto &p:mp){\\n            auto vec=p.second;\\n            for(int i=1;i<vec.size();i++)\\n                pre[vec[i]]=  pre[vec[i-1]]+  i*(long)(vec[i]-vec[i-1]);\\n        }\\n       // suffix will store the sum of absolute diff. from the ending index of current element to the current index.\\n        // same formula as above but in reverse order\\n        for(auto &p:mp){\\n            auto vec=p.second;\\n            for(int i=vec.size()-2;i>=0;i--)\\n                suf[vec[i]]=  suf[vec[i+1]] + long(vec.size()-1-i) * (long)(vec[i+1]-vec[i]);\\n        }\\n        for(int i=0;i<size;i++)\\n            ans[i]+=(pre[i]+suf[i]);\\n        return ans;\\n    }\\n};\\n```\\n\\t\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int size=arr.size();\\n        vector<long long>pre(size,0),suf(size,0),ans(size,0);\\n        unordered_map<int,vector<int>>mp;\\n        \\n        // store index of the same elements.\\n        for(int i=0;i<size;i++)\\n            mp[arr[i]].push_back(i);\\n       //  prefix will store the sum of absolute diff. from the starting index of current element to the current index.\\n        // pre[cur index]=pre[prev index]+ number of same elements before cur element * abs diff of cur element pos and pre element pos\\n        for(auto &p:mp){\\n            auto vec=p.second;\\n            for(int i=1;i<vec.size();i++)\\n                pre[vec[i]]=  pre[vec[i-1]]+  i*(long)(vec[i]-vec[i-1]);\\n        }\\n       // suffix will store the sum of absolute diff. from the ending index of current element to the current index.\\n        // same formula as above but in reverse order\\n        for(auto &p:mp){\\n            auto vec=p.second;\\n            for(int i=vec.size()-2;i>=0;i--)\\n                suf[vec[i]]=  suf[vec[i+1]] + long(vec.size()-1-i) * (long)(vec[i+1]-vec[i]);\\n        }\\n        for(int i=0;i<size;i++)\\n            ans[i]+=(pre[i]+suf[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647522,
                "title": "java-tc-o-n-simple-explanation",
                "content": "**Approach:**\\n```\\nConsider 1\\'s at different postions of an array. \\nx  y  z   p   q\\n1  1  1   1   1\\n\\nconsider 1 at index z: |z - x| + |z - y| + |z - p| + |z - q|\\n\\nwhen we are looping from left to right we are storing sum and count of previous indices of num in maps.\\n|z - x| + |z - y| = z - x + z - y, since z is greater than x and y.\\nz - x + z - y = 2z - (x + y) = (count) * (currentIndex) - (sum).\\n\\nSimilarly we can calculate the |z - p| + |z - q| when we loop from right to left.\\n```\\n**Solution:**\\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        long[] output = new long[arr.length];\\n        Map<Integer, Long> sumMap = new HashMap<>();\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int i = 0; i < arr.length; ++ i) {\\n            if (!sumMap.containsKey(arr[i])) {\\n                sumMap.put(arr[i], 0l);\\n                countMap.put(arr[i], 0);\\n            }\\n            \\n            output[i] += i * (long)countMap.get(arr[i]) - sumMap.get(arr[i]);\\n            sumMap.put(arr[i], sumMap.get(arr[i]) + i);\\n            countMap.put(arr[i], countMap.get(arr[i]) + 1);\\n        }\\n        \\n        sumMap = new HashMap<>();\\n        countMap = new HashMap<>();\\n        int len = arr.length;\\n        for (int i = len - 1; i >= 0; -- i) {\\n            if (!sumMap.containsKey(arr[i])) {\\n                sumMap.put(arr[i], 0l);\\n                countMap.put(arr[i], 0);\\n            }\\n            \\n            output[i] += (len - i - 1) * (long)countMap.get(arr[i]) - sumMap.get(arr[i]);\\n            sumMap.put(arr[i], sumMap.get(arr[i]) + (len - i - 1));\\n            countMap.put(arr[i], countMap.get(arr[i]) + 1);\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nConsider 1\\'s at different postions of an array. \\nx  y  z   p   q\\n1  1  1   1   1\\n\\nconsider 1 at index z: |z - x| + |z - y| + |z - p| + |z - q|\\n\\nwhen we are looping from left to right we are storing sum and count of previous indices of num in maps.\\n|z - x| + |z - y| = z - x + z - y, since z is greater than x and y.\\nz - x + z - y = 2z - (x + y) = (count) * (currentIndex) - (sum).\\n\\nSimilarly we can calculate the |z - p| + |z - q| when we loop from right to left.\\n```\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        long[] output = new long[arr.length];\\n        Map<Integer, Long> sumMap = new HashMap<>();\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int i = 0; i < arr.length; ++ i) {\\n            if (!sumMap.containsKey(arr[i])) {\\n                sumMap.put(arr[i], 0l);\\n                countMap.put(arr[i], 0);\\n            }\\n            \\n            output[i] += i * (long)countMap.get(arr[i]) - sumMap.get(arr[i]);\\n            sumMap.put(arr[i], sumMap.get(arr[i]) + i);\\n            countMap.put(arr[i], countMap.get(arr[i]) + 1);\\n        }\\n        \\n        sumMap = new HashMap<>();\\n        countMap = new HashMap<>();\\n        int len = arr.length;\\n        for (int i = len - 1; i >= 0; -- i) {\\n            if (!sumMap.containsKey(arr[i])) {\\n                sumMap.put(arr[i], 0l);\\n                countMap.put(arr[i], 0);\\n            }\\n            \\n            output[i] += (len - i - 1) * (long)countMap.get(arr[i]) - sumMap.get(arr[i]);\\n            sumMap.put(arr[i], sumMap.get(arr[i]) + (len - i - 1));\\n            countMap.put(arr[i], countMap.get(arr[i]) + 1);\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647630,
                "title": "python3-java-c-dictionary-map-and-prefix-sum-o-n",
                "content": "Dictionary/Hashmap is used to store all the occurences of a given number as {num: [indexes of occurences in arr]}\\n\\n***Explanation for the use of prefix array***:\\nPrefix array `pre` is first used to fetch the sum of numbers uptil index i (for a given number arr[i]). We know that the numbers in the list are sorted thus these numbers will be smaller than i.\\n\\n`v * (i + 1) - pre[i + 1]` finds the `\\u2211 (l[i] - (numbers smaller than or equal to l[i] in list))`\\nLet\\'s say for given list 1, 3, 5, 7, 9:\\nFor example, we choose `i` = 3 or the number `l[i]` = 7.\\nTo find abs difference for numbers smaller than equal to 7:\\n7 - 1 + 7 - 3 + 7 - 5 + 7 - 7\\nor\\n7 * 4 - (1 + 3 + 5 + 7)\\nor\\n7 * `(i + 1)` - `pre[i + 1]`\\n\\nSimilarly\\n`((pre[len(l)] - pre[i]) - v * (len(l) - (i)))` calculates abs difference between` l[i]` and numbers greater than `l[i]`\\n\\n**Python3**:\\n```\\ndef getDistances(self, arr: List[int]) -> List[int]:\\n    m, res = {}, [0] * len(arr)\\n    for i, v in enumerate(arr):\\n        if v not in m: m[v] = list()\\n        m[v].append(i)\\n    \\n    for x in m:\\n        l = m[x]\\n        pre = [0] * (len(l) + 1)\\n        for i in range(len(l)):\\n            pre[i + 1] = pre[i] + l[i]\\n        for i, v in enumerate(l):\\n            res[v] = (v * (i + 1) - pre[i + 1]) + ((pre[len(l)] - pre[i]) - v * (len(l) - (i)))\\n    return res\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/EYjsLmzB/shared\" frameBorder=\"0\" width=\"800\" height=\"410\"></iframe>\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\ndef getDistances(self, arr: List[int]) -> List[int]:\\n    m, res = {}, [0] * len(arr)\\n    for i, v in enumerate(arr):\\n        if v not in m: m[v] = list()\\n        m[v].append(i)\\n    \\n    for x in m:\\n        l = m[x]\\n        pre = [0] * (len(l) + 1)\\n        for i in range(len(l)):\\n            pre[i + 1] = pre[i] + l[i]\\n        for i, v in enumerate(l):\\n            res[v] = (v * (i + 1) - pre[i + 1]) + ((pre[len(l)] - pre[i]) - v * (len(l) - (i)))\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1648143,
                "title": "c-simplest-o-n-solution-till-now-i-promise-no-separate-prefix-and-suffix-arrays",
                "content": "Effectively, after we filter out all the indices at which each number appears into a map of integer to vector, the problem essentially boils down to - `Given an array of integers, for each integer, find the sum of absolute difference of itself with every other integer in the array`. We need to solve this reduced problem for every number in the hash map and store the result in the index wherever this number occured in the original array. \\n\\nFor the first element in the array, there\\'s no other option but to iterate through the entire array and find the sum of absolute differences like so-\\n```\\nfor(int i = 1; i < indices.size(); i++) {\\n\\tres[indices[0]] += std::abs(indices[i]-indices[0]);\\n}\\n```\\n\\nFor successive numbers, we observe a key insight - **The number at index `i` is closer all future numbers at indices `i+1`, `i+2` etc by `indices[i]-indices[i-1]`** compared to the previous number at index `i-1`. Hence we need to subtract this quantity from all the future numbers. And there are `(indices.size()-i-1)` future numbers. Hence the term `(indices[i]-indices[i-1])*(indices.size()-i-1)`. **Also, it is farther to all preceding numbers at indices `i-1`, `i-2` etc by the same amount `indices[i]-indices[i-1]`** compared to the previous number at index `i-1`. And there are `i-1` such predecessors. Hence we need to add this quantity from all the preceeding numbers. Hence the term `(indices[i]-indices[i-1])*(i-1)`\\n\\nThats it. Except the first index that needed us to iterate over all the indices, all future sum of differences can be calculated in constant time. Hence the complexity remains linear.\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        std::vector<long long> res(arr.size(), 0);\\n        std::unordered_map<int, std::vector<long long>> num_to_indices;\\n        \\n        for(long long i=0; i < arr.size(); i++) {\\n            num_to_indices[arr[i]].push_back(i);\\n        }\\n        \\n        for(auto const& ele: num_to_indices) {\\n            auto const& indices = ele.second;\\n            for(int i = 1; i < indices.size(); i++) {\\n                res[indices[0]] += std::abs(indices[i]-indices[0]);\\n            }\\n            for(int i = 1; i < indices.size(); i++) {\\n\\t\\t\\t    // Not simplifying this line intentionally for better understanding.\\n                res[indices[i]] = res[indices[i-1]] - (indices[i]-indices[i-1])*(indices.size()-i-1) + (indices[i]-indices[i-1])*(i-1);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfor(int i = 1; i < indices.size(); i++) {\\n\\tres[indices[0]] += std::abs(indices[i]-indices[0]);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        std::vector<long long> res(arr.size(), 0);\\n        std::unordered_map<int, std::vector<long long>> num_to_indices;\\n        \\n        for(long long i=0; i < arr.size(); i++) {\\n            num_to_indices[arr[i]].push_back(i);\\n        }\\n        \\n        for(auto const& ele: num_to_indices) {\\n            auto const& indices = ele.second;\\n            for(int i = 1; i < indices.size(); i++) {\\n                res[indices[0]] += std::abs(indices[i]-indices[0]);\\n            }\\n            for(int i = 1; i < indices.size(); i++) {\\n\\t\\t\\t    // Not simplifying this line intentionally for better understanding.\\n                res[indices[i]] = res[indices[i-1]] - (indices[i]-indices[i-1])*(indices.size()-i-1) + (indices[i]-indices[i-1])*(i-1);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647499,
                "title": "hash-and-formula",
                "content": "We first normalize our array (using hash map `m`), mapping each unique value to range `[0, k)`, where `k` is the number of unique values.\\n\\nThen, for each unique value, we collect its positions in the array. We also track `last` position for each unique value, and `sum` of intervals for that position.\\n\\nNow, the only question is how to update `sum` as we move. For that, we need the previous position (`p`), and the distance (`diff`) between previous and current positions. To calculate `sum` for the next position `p + 1`, we need to subtract `diff` for all positions after `p + 1`, and add `diff` for all positions before `p + 1`:\\n\\n`sum[p + 1] = sum[p] - diff * (sz - 1 - (p + 1)) + diff * p`\\n\\nHere is the illustration for this test case: `[2,1,3,4,5,1,6,1,7,8,1,9,1]`.\\n\\n![image](https://assets.leetcode.com/users/images/e572224c-eec2-4a19-9dec-e6f8c4cfbf9f_1640493643.5050786.png)\\n\\n**C++**\\n```cpp\\nvector<long long> getDistances(vector<int>& arr) {\\n    unordered_map<int, int> m;\\n    for (int i = 0; i < arr.size(); ++i) {\\n        if (m.count(arr[i]) == 0)\\n            m[arr[i]] = m.size();\\n        arr[i] = m[arr[i]];\\n    }\\n    vector<vector<int>> idx(m.size());\\n    vector<long long> sum(m.size()), last(m.size(), -1), res;\\n    for (int i = 0; i < arr.size(); ++i) {\\n        idx[arr[i]].push_back(i);\\n        sum[arr[i]] += idx[arr[i]].back() - idx[arr[i]][0];\\n    }\\n    for (int i = 0; i < arr.size(); ++i) {\\n        long long p = last[arr[i]], v = arr[i];\\n        if (p >= 0) {\\n            long long diff = idx[v][p + 1] - idx[v][p];\\n            sum[v] += diff * p - diff * (idx[v].size() - 1 - (p + 1));\\n        }\\n        res.push_back(sum[v]);\\n        ++last[v];\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<long long> getDistances(vector<int>& arr) {\\n    unordered_map<int, int> m;\\n    for (int i = 0; i < arr.size(); ++i) {\\n        if (m.count(arr[i]) == 0)\\n            m[arr[i]] = m.size();\\n        arr[i] = m[arr[i]];\\n    }\\n    vector<vector<int>> idx(m.size());\\n    vector<long long> sum(m.size()), last(m.size(), -1), res;\\n    for (int i = 0; i < arr.size(); ++i) {\\n        idx[arr[i]].push_back(i);\\n        sum[arr[i]] += idx[arr[i]].back() - idx[arr[i]][0];\\n    }\\n    for (int i = 0; i < arr.size(); ++i) {\\n        long long p = last[arr[i]], v = arr[i];\\n        if (p >= 0) {\\n            long long diff = idx[v][p + 1] - idx[v][p];\\n            sum[v] += diff * p - diff * (idx[v].size() - 1 - (p + 1));\\n        }\\n        res.push_back(sum[v]);\\n        ++last[v];\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1648352,
                "title": "simple-and-easy-to-understand-solution-c-explained",
                "content": "After reading the question, first thing pops into our head that here we have to work on the indices of the same numbers. So how can we store index of same numbers at one place ? One of the easiest and efficient way is to store it in unordered map. Now we have to make a tough decision on how to calculate the absolute diffrerence of the indices ? Should we do it in n^2 (TLE) complexity or we can think something better. We can see in the index vector that if we choose a index then on the left of that index all are smaller than it and on the right all are greater, so we can make a prefix sum array for the index vector stored in unordered_map, which will help us to find the sum of all index on the left and sum of all index on right. Then using the prefix sum we can fill the ans vector.\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<long long> ans(n);\\n        unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i<n; i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        for(auto itr : mp){\\n            vector<int> v = itr.second;\\n            int size = v.size();\\n            long long pre[size+1];\\n            pre[0] = 0;\\n            for(int i = 0; i<size; i++){\\n                pre[i+1] = (long long)pre[i] + (long long)v[i];\\n            }\\n            for(long long i = 0; i<size; i++){\\n                ans[v[i]] = i*v[i] - pre[i] + pre[size] - pre[i+1] - (size-i-1)*v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThanks for going through my solution.\\nPlease upvote if you find it helpful.",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<long long> ans(n);\\n        unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i<n; i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        for(auto itr : mp){\\n            vector<int> v = itr.second;\\n            int size = v.size();\\n            long long pre[size+1];\\n            pre[0] = 0;\\n            for(int i = 0; i<size; i++){\\n                pre[i+1] = (long long)pre[i] + (long long)v[i];\\n            }\\n            for(long long i = 0; i<size; i++){\\n                ans[v[i]] = i*v[i] - pre[i] + pre[size] - pre[i+1] - (size-i-1)*v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647569,
                "title": "java-easy-o-n-solution-with-prefix-sum-and-sum",
                "content": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        int n = arr.length;\\n        long[] result = new long[n];\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i=0; i<n; i++) {\\n            List<Integer> list = map.getOrDefault(arr[i], new ArrayList<>());\\n            list.add(i);\\n            map.put(arr[i], list);\\n        }\\n        for (Map.Entry<Integer, List<Integer>> entry: map.entrySet()) {\\n            List<Integer> list = entry.getValue();\\n            long sum = 0;\\n            for (int num: list) {\\n                sum += (long) num;\\n            }\\n            long preSum = 0;\\n            int size = list.size();\\n            for (int i=0; i<size; i++) {\\n                int num = list.get(i);\\n                preSum += num;\\n                result[num] = sum + (2*i+2-size)*(long)num - 2*preSum;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        int n = arr.length;\\n        long[] result = new long[n];\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i=0; i<n; i++) {\\n            List<Integer> list = map.getOrDefault(arr[i], new ArrayList<>());\\n            list.add(i);\\n            map.put(arr[i], list);\\n        }\\n        for (Map.Entry<Integer, List<Integer>> entry: map.entrySet()) {\\n            List<Integer> list = entry.getValue();\\n            long sum = 0;\\n            for (int num: list) {\\n                sum += (long) num;\\n            }\\n            long preSum = 0;\\n            int size = list.size();\\n            for (int i=0; i<size; i++) {\\n                int num = list.get(i);\\n                preSum += num;\\n                result[num] = sum + (2*i+2-size)*(long)num - 2*preSum;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647480,
                "title": "python3-prefix-sum",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/338b3e50d12cc0067b8b85e8e27c1b0c10fd91c6) for solutions of weely 273. \\n\\n```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        loc = defaultdict(list)\\n        for i, x in enumerate(arr): loc[x].append(i)\\n        \\n        for k, idx in loc.items(): \\n            prefix = list(accumulate(idx, initial=0))\\n            vals = []\\n            for i, x in enumerate(idx): \\n                vals.append(prefix[-1] - prefix[i] - prefix[i+1] - (len(idx)-2*i-1)*x)\\n            loc[k] = deque(vals)\\n        \\n        return [loc[x].popleft() for x in arr]\\n```\\n\\n**Explanation on the formula**\\nGiven an array, say `nums = [3,2,1,5,4]`. Calculate its prefix sum `[0,3,5,6,11,15]` (note the leading zero). Now let\\'s loop through `nums` by index. At `i`, there are \\n1) `i` numbers whose indices are below `i` with sum `prefix[i]`;\\n2) `len(nums)-i-1` numbers whose indices are above `i` with sum `prefix[-1] - prefix[i+1]`. \\n\\nSo the desired value in this case is `i*x - prefix[i] + prefix[-1] - prefix[i+1] - (len(nums)-i-1)*x`. Rearranging the terms one would arrive at the formula used in this implementation.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        loc = defaultdict(list)\\n        for i, x in enumerate(arr): loc[x].append(i)\\n        \\n        for k, idx in loc.items(): \\n            prefix = list(accumulate(idx, initial=0))\\n            vals = []\\n            for i, x in enumerate(idx): \\n                vals.append(prefix[-1] - prefix[i] - prefix[i+1] - (len(idx)-2*i-1)*x)\\n            loc[k] = deque(vals)\\n        \\n        return [loc[x].popleft() for x in arr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060775,
                "title": "javascript-o-n-432ms",
                "content": "*(this is my first ever post here, hope it helps someone, comments/suggestions are welcome)*\\n\\nIn order to calculate the sum of intervals for each element of an array, we need to know indexes of all the duplicates of a particular element. \\n\\nThe very first brute force solution that comes to mind is to run through the array and find duplicates for each element and do the math with indexes. This would give us a solution with `O(N^2)` runtime (which of course times out):\\n\\n```\\nvar getDistances = function(arr) {\\n    const result = [];\\n    for (let i = 0; i < arr.length; i++) {\\n        let sum = 0;\\n        for (let j = 0; j < arr.length; j++) {\\n            if (arr[j] === arr[i]) {\\n                sum += Math.abs(i - j);\\n            }\\n        }\\n        result[i] = sum;\\n    }\\n    return result;\\n};\\n```\\n\\nCan we do better? Yes we can! \\n\\nLet\\u2019s take a look at what exactly is the sum of intervals for a particular element by looking at an example which intentionally has a lot of duplicates: \\n\\n```\\n[2,3,3,2,3,3,3,3]\\n```\\n\\nLet\\u2019s take the 5th element of the array which is 3. It has 3 duplicate elements before (*arr[1]*, *arr[2]* and *arr[4]*) and 2 duplicate elements after (*arr[6]* and *arr[7]*). For the 5th element the sum of intervals will be:\\n\\n```\\n(5 - 1) + (5 - 2) + (5 - 4) + (6 - 5) + (7 - 5) = 11\\n```\\nor\\n```\\n(index5 - index1) + (index5 - index2) + (index5 - index4) + (index6 - index5) + (index7 - index5) \\n```\\n\\nor\\n```\\n(index5 * 3 - sum(index1, index2, index4)) + (sum(index6, index7) - index5 * 2)\\n```\\n\\nIn the formula above, **3** is the amount of duplicates encountered before the Kth element, and **2** is the amount of duplicates encountered after. It means that we don\\u2019t really need to know all the indexes when calculating the sum for the Kth element. What we need to know is the **sum of indexes** of duplicates encountered before the Kth element and **their count**, and the **sum of indexes** of elements after the Kth element and **their count**:\\n\\nHow can we achieve this?\\n\\nOne of the ways to do this is to use a map to store unique elements, their counts and sums of indexes. We\\'ll need to run through the array 2 times: one forwards and one backwards. On the first run, for every unique element in the array, we store its count and the sum of indexes of its duplicates encountered before it. On the second run we do the same, but for elements encountered after it. If we look at the formula above again:\\n\\n```\\n(index5 * 3 - sum(index1, index2, index4)) + (sum(index6, index7) - index5 * 2)\\n```\\n\\nThe first run will calculate the first part of it: `(index5 * 3 - sum(index1, index2, index4))`. The second one will calculate the secound part of it: `(sum(index6, index7) - index5 * 2)`.\\n\\nHere\\'s the final solution:\\n\\n```\\nvar getDistances = function(arr) {\\n    const map = new Map();\\n    const result = new Array(arr.length).fill(0);\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        const num = arr[i];\\n        const val = map.get(num) || {\\n            count: 0,\\n            sum: 0\\n        };\\n        result[i] += (val.count * i) - val.sum;\\n        val.sum += i;\\n        val.count++;\\n        map.set(num, val);\\n    }\\n    map.clear();\\n\\n    for (let i = arr.length - 1; i >= 0; i--) {\\n        const num = arr[i];\\n        const val = map.get(num) || {\\n            count: 0,\\n            sum: 0\\n        };\\n        result[i] += val.sum - (val.count * i);\\n        val.sum += i;\\n        val.count++;\\n        map.set(num, val);\\n    }\\n\\n    return result;\\n};\\n```\\n\\nIt\\'s also possible to combine both loops into one but it requires a second map:\\n\\n```\\nvar getDistances = function(arr) {\\n    const mapForwards = new Map(), maxBackwards = new Map(), n = arr.length;\\n    const result = new Array(arr.length).fill(0);\\n\\n    for (let i = 0; i < n; i++) {\\n        /* Forwards part */\\n        const num = arr[i];\\n        const val = mapForwards.get(num) || {\\n            count: 0,\\n            sum: 0\\n        };\\n        result[i] += (val.count * i) - val.sum;\\n        val.sum += i;\\n        val.count++;\\n        mapForwards.set(num, val);\\n        /* Backwards part */\\n        const j = n - i - 1;\\n        const num2 = arr[j];\\n        const val2 = maxBackwards.get(num2) || {\\n            count: 0,\\n            sum: 0\\n        };\\n        result[j] += val2.sum - (val2.count * j);\\n        val2.sum += j;\\n        val2.count++;\\n        maxBackwards.set(num2, val2);\\n    }\\n\\n    return result;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getDistances = function(arr) {\\n    const result = [];\\n    for (let i = 0; i < arr.length; i++) {\\n        let sum = 0;\\n        for (let j = 0; j < arr.length; j++) {\\n            if (arr[j] === arr[i]) {\\n                sum += Math.abs(i - j);\\n            }\\n        }\\n        result[i] = sum;\\n    }\\n    return result;\\n};\\n```\n```\\n[2,3,3,2,3,3,3,3]\\n```\n```\\n(5 - 1) + (5 - 2) + (5 - 4) + (6 - 5) + (7 - 5) = 11\\n```\n```\\n(index5 - index1) + (index5 - index2) + (index5 - index4) + (index6 - index5) + (index7 - index5) \\n```\n```\\n(index5 * 3 - sum(index1, index2, index4)) + (sum(index6, index7) - index5 * 2)\\n```\n```\\n(index5 * 3 - sum(index1, index2, index4)) + (sum(index6, index7) - index5 * 2)\\n```\n```\\nvar getDistances = function(arr) {\\n    const map = new Map();\\n    const result = new Array(arr.length).fill(0);\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        const num = arr[i];\\n        const val = map.get(num) || {\\n            count: 0,\\n            sum: 0\\n        };\\n        result[i] += (val.count * i) - val.sum;\\n        val.sum += i;\\n        val.count++;\\n        map.set(num, val);\\n    }\\n    map.clear();\\n\\n    for (let i = arr.length - 1; i >= 0; i--) {\\n        const num = arr[i];\\n        const val = map.get(num) || {\\n            count: 0,\\n            sum: 0\\n        };\\n        result[i] += val.sum - (val.count * i);\\n        val.sum += i;\\n        val.count++;\\n        map.set(num, val);\\n    }\\n\\n    return result;\\n};\\n```\n```\\nvar getDistances = function(arr) {\\n    const mapForwards = new Map(), maxBackwards = new Map(), n = arr.length;\\n    const result = new Array(arr.length).fill(0);\\n\\n    for (let i = 0; i < n; i++) {\\n        /* Forwards part */\\n        const num = arr[i];\\n        const val = mapForwards.get(num) || {\\n            count: 0,\\n            sum: 0\\n        };\\n        result[i] += (val.count * i) - val.sum;\\n        val.sum += i;\\n        val.count++;\\n        mapForwards.set(num, val);\\n        /* Backwards part */\\n        const j = n - i - 1;\\n        const num2 = arr[j];\\n        const val2 = maxBackwards.get(num2) || {\\n            count: 0,\\n            sum: 0\\n        };\\n        result[j] += val2.sum - (val2.count * j);\\n        val2.sum += j;\\n        val2.count++;\\n        maxBackwards.set(num2, val2);\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1652212,
                "title": "c-prefix-suffix-sum-hashmap-explanation-clean-code",
                "content": "#### Time Complexity: O(N) Space Complexity: O(N)\\n\\n**Approach**\\nThe approach to this question is divided in two parts.\\n\\n( i ) First part is to store the array of indexes in a hashmap for multiple occurences of a number where key is the number and value is the array of indexes.\\n\\n( ii ) Then I\\'ve iterated on the hashmap and for a particular array of indexes, I\\'ve recorded the prefix and suffix sum for that index and stored it in respective arrays.\\n\\n**Challenge:**\\nThe real challenge was to calculate the abs difference of indexes in O(N).\\n\\n**Questions:**\\nWhy I have recorded the prefix and suffix sum ??\\n\\nThis is because prefix sum of abs difference gave me the sum of abs differences of all the occurences of same number before the current one. \\n\\nSimilarly, suffix sum of abs difference gave me the sum of abs differences of all occurences of same number after the current one.\\n\\n**PS:**\\nFeel free to suggest a better approach in comments. You can also ask your doubts over there.\\n\\nDo upvote if you liked my solution \\u2B50.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        unordered_map<int,vector<int>> map;\\n        \\n        for(int idx = 0; idx < arr.size(); idx++)\\n            map[arr[idx]].push_back(idx);\\n        \\n        vector<long long> ans(arr.size());\\n        vector<long long> prefixSum(arr.size(), 0);\\n        vector<long long> suffixSum(arr.size(), 0);\\n        \\n        for(auto element: map) {\\n            \\n            vector<int> temp = element.second;\\n            \\n            for(int idx = 1; idx < temp.size(); idx++) {\\n                \\n                int prev = temp[idx-1];\\n                int curr = temp[idx];\\n                \\n                prefixSum[curr] += prefixSum[prev] + (idx-1) * ( curr - prev );\\n                prefixSum[curr] += curr - prev;\\n            }\\n            \\n            int multiplier = 0;\\n            \\n            for(int idx = temp.size() - 2; idx >= 0; idx --) {\\n                \\n                int next = temp[idx+1];\\n                int curr = temp[idx];\\n                \\n                suffixSum[curr] += next - curr;\\n                suffixSum[curr] += suffixSum[next] + (multiplier) * (next - curr);\\n                \\n                multiplier ++;\\n            }\\n            \\n        }\\n        \\n        for(int idx = 0; idx < ans.size(); idx ++)\\n            ans[idx] = prefixSum[idx] + suffixSum[idx];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        unordered_map<int,vector<int>> map;\\n        \\n        for(int idx = 0; idx < arr.size(); idx++)\\n            map[arr[idx]].push_back(idx);\\n        \\n        vector<long long> ans(arr.size());\\n        vector<long long> prefixSum(arr.size(), 0);\\n        vector<long long> suffixSum(arr.size(), 0);\\n        \\n        for(auto element: map) {\\n            \\n            vector<int> temp = element.second;\\n            \\n            for(int idx = 1; idx < temp.size(); idx++) {\\n                \\n                int prev = temp[idx-1];\\n                int curr = temp[idx];\\n                \\n                prefixSum[curr] += prefixSum[prev] + (idx-1) * ( curr - prev );\\n                prefixSum[curr] += curr - prev;\\n            }\\n            \\n            int multiplier = 0;\\n            \\n            for(int idx = temp.size() - 2; idx >= 0; idx --) {\\n                \\n                int next = temp[idx+1];\\n                int curr = temp[idx];\\n                \\n                suffixSum[curr] += next - curr;\\n                suffixSum[curr] += suffixSum[next] + (multiplier) * (next - curr);\\n                \\n                multiplier ++;\\n            }\\n            \\n        }\\n        \\n        for(int idx = 0; idx < ans.size(); idx ++)\\n            ans[idx] = prefixSum[idx] + suffixSum[idx];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649945,
                "title": "python-o-n-by-prefix-postfix-table-w-hint",
                "content": "**Hint**:\\n\\nWhen it comes to **accumulation on history data in the same direction**, think of **prefix sum** / **postfix sum** technique,\\nlike what we did in [#2100 Find good days to rob](https://leetcode.com/problems/find-good-days-to-rob-the-bank/discuss/1646354/python-on-by-prefixpostfix-table-w-example) as well as [#303 Range sum query - immutable](https://leetcode.com/problems/range-sum-query-immutable/)\\n\\nWe can define Presum and Postsum as following:\\n\\n**Presum**( i ) = 0 if we have no identical elements **on the lefthand side** of i.\\n**Presum**( i ) = Presum( j ) + ( **i - j** ) * **count of equal elements so far**, where **j < i**, and j is the nearest index to i\\n\\nSimilarly,\\n\\n**Postsum**( i ) = 0 if we have no identical elements **on the righthand side** of i.\\n**Postsum**( i ) = Postsum( k ) + ( **k - i** ) * **count of equal elements so far**, where **k > i**, and k is the nearest index to i\\n\\nFinally, we have summation of distance to all identical elements for i \\n= summation of distance to all identical elements for i on the **lefthand side** + summation of distance to all identical elements for i on the **righthand side**\\n= Presum( i ) + Postsum( i )\\n\\n\\n\\n\\n---\\n\\n```\\n\\n# helper data structure Scout\\nclass Scout:\\n    \\n    def __init__(self, prev_idx=-1, count_of_equal=0):\\n        \\n        # record of index of last identical element\\n        self.prev_idx = prev_idx\\n        \\n        # count of identical elements so far\\n        self.count_of_equal = count_of_equal\\n    \\n    def __iter__(self):\\n\\t\\t# ouput previous index, and count of equal in order\\n        return iter( (self.prev_idx, self.count_of_equal) )\\n    \\n    \\n        \\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        \\n        size = len(arr)\\n        \\n        pre_scout = defaultdict( Scout )\\n        pre_dist_sum = [0 for _ in range(size)]\\n        \\n        post_scout = defaultdict( Scout )\\n        post_dist_sum = [0 for _ in range(size)]\\n        \\n        \\n        ## Step_1:\\n        # update for pre_dist_sum table, direction is from left to right\\n        for i, element in enumerate(arr):\\n            \\n            prev_equal_idx, prev_count_of_equal = pre_scout[element]\\n            \\n            # update pre_dist_sum table if we have identical elements before index i\\n            if prev_count_of_equal:\\n                pre_dist_sum[i] += pre_dist_sum[ prev_equal_idx ] + (i - prev_equal_idx) * prev_count_of_equal\\n            \\n            # update Scout information for current element\\n            pre_scout[element] = i, prev_count_of_equal+1\\n            \\n        # --------------------------------------------------------------\\n        \\n        ## Step_2:\\n        # update for pos_dist_sum table, direction is from right to left\\n        for i, element in reversed( [*enumerate(arr)] ):\\n            \\n            post_equal_idx, post_count_of_equal = post_scout[element]\\n\\n            # update post_dist_sum table if we have identical elements after index i\\n            if post_count_of_equal:\\n                post_dist_sum[i] += post_dist_sum[ post_equal_idx ] + (post_equal_idx - i) * post_count_of_equal\\n            \\n            # update Scout information for current element\\n            post_scout[element] = i, post_count_of_equal+1\\n            \\n            \\n        ## Step_3:\\n        # Generate final output by definition\\n        return [ pre_dist_sum[i] + post_dist_sum[i] for i in range(size) ]\\n        \\n        \\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n [Leetcode #2100 Find good days to rob](https://leetcode.com/problems/find-good-days-to-rob-the-bank/) \\n \\n [Leetcode #303 Range sum query - immutable](https://leetcode.com/problems/range-sum-query-immutable/)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Iterator",
                    "Prefix Sum"
                ],
                "code": "```\\n\\n# helper data structure Scout\\nclass Scout:\\n    \\n    def __init__(self, prev_idx=-1, count_of_equal=0):\\n        \\n        # record of index of last identical element\\n        self.prev_idx = prev_idx\\n        \\n        # count of identical elements so far\\n        self.count_of_equal = count_of_equal\\n    \\n    def __iter__(self):\\n\\t\\t# ouput previous index, and count of equal in order\\n        return iter( (self.prev_idx, self.count_of_equal) )\\n    \\n    \\n        \\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        \\n        size = len(arr)\\n        \\n        pre_scout = defaultdict( Scout )\\n        pre_dist_sum = [0 for _ in range(size)]\\n        \\n        post_scout = defaultdict( Scout )\\n        post_dist_sum = [0 for _ in range(size)]\\n        \\n        \\n        ## Step_1:\\n        # update for pre_dist_sum table, direction is from left to right\\n        for i, element in enumerate(arr):\\n            \\n            prev_equal_idx, prev_count_of_equal = pre_scout[element]\\n            \\n            # update pre_dist_sum table if we have identical elements before index i\\n            if prev_count_of_equal:\\n                pre_dist_sum[i] += pre_dist_sum[ prev_equal_idx ] + (i - prev_equal_idx) * prev_count_of_equal\\n            \\n            # update Scout information for current element\\n            pre_scout[element] = i, prev_count_of_equal+1\\n            \\n        # --------------------------------------------------------------\\n        \\n        ## Step_2:\\n        # update for pos_dist_sum table, direction is from right to left\\n        for i, element in reversed( [*enumerate(arr)] ):\\n            \\n            post_equal_idx, post_count_of_equal = post_scout[element]\\n\\n            # update post_dist_sum table if we have identical elements after index i\\n            if post_count_of_equal:\\n                post_dist_sum[i] += post_dist_sum[ post_equal_idx ] + (post_equal_idx - i) * post_count_of_equal\\n            \\n            # update Scout information for current element\\n            post_scout[element] = i, post_count_of_equal+1\\n            \\n            \\n        ## Step_3:\\n        # Generate final output by definition\\n        return [ pre_dist_sum[i] + post_dist_sum[i] for i in range(size) ]\\n        \\n        \\n```",
                "codeTag": "C++"
            },
            {
                "id": 1649255,
                "title": "state-transition-technique-detailed-explanation",
                "content": "When I saw this problem in the contest, I tried to isolate the core problem from the noise. The first thing I did was create a map of each value to where the indices of that value occur.\\n\\nFor example:\\n```\\nlet arr = [2, 1, 3, 1, 2, 3, 3];\\n```\\nbecomes\\n```\\nlet usefulDataStructure = {\\n\\t1: [1, 3],\\n\\t2: [0, 4].\\n\\t3: [2, 5, 6]\\n};\\n```\\nWith that data structure, we just need to write an algothithm that takes one of those lists and returns the sum of intervals as described by the problem. If we have that algorithm, finishing the problem is just a matter of plumbing.\\n\\nLet\\'s start with a brute force algorithm which is `O(n^2)`.\\n\\n```\\n// indices = [2, 5, 6] returns [7, 4, 5]\\nfunction bruteForceRollingIntervalSum(indices) {\\n\\tconst result = [];\\n\\tfor (let i = 0; i < indices.length; i++) {\\n\\t\\tlet sum = 0;\\n\\t\\tfor (let j = 0; j < indices.length; j++) {\\n\\t\\t\\tsum += Math.abs(indices[i] - indices[j]);\\n\\t\\t}\\n\\t\\tresult.push(sum);\\n\\t}\\n\\treturn result;\\n }\\n```\\n\\nThis code is correct but very slow for the edge case where `arr` is all the same number.  I think many people got TLE with this solution.\\n\\nSo this is the question my brain asked. **If we know the interval sum for one index, can we calculate the interval sum for the next index in O(1) time?**\\n\\nLet\\'s look at the example `[2, 5, 6, 8]`. \\n\\nWe can calculate the value for the first index (using brute force):\\n```\\nindex0 = (5 - 2) + (6 - 2) + (8 - 2) = 13\\n```\\n\\nWhat happens when we transition to index 1? Well the distances from all the indices to the right are reduced by 3. Additionally, a sum of 3 is added to the left. So we get:\\n\\n```\\nindex1 =  index0 - (5 - 2) * 3 + (5 - 2) * 1 = 7\\n```\\n\\nLet\\'s do this exercise again for index 2. The distances of every value to the right is reduced by 1. And the distances of every value to the left is increased by 1. There are two indices to the left and to the right so the sum is unchanged.\\n\\n```\\nindex2 = index1 - (6 - 5) * 2 + (6 - 5) * 2 = 7\\n```\\n\\nAnd finally let repeat this for the final index:\\n\\n```\\nindex3 = index2 - (8 - 6) * 1 + (8 - 6) * 3 = 11\\n```\\n\\nBoom! We created an algorithm that runs in `O(n)`! First calculate the interval sum for the first index. Just keep track of how many indices are left and right of the current index and use them to calculate the next index. Here\\'s the code:\\n\\n```js\\n// indices = [2, 5, 6, 8] returns [13, 7, 7, 11]\\nfunction efficientRollingIntervalSum(indices) {\\n\\t// Initialize the current sum for the first index;\\n\\tlet currSum = 0;\\n\\tfor (let i = 1; i < indices.length; i++) {\\n\\t\\tcurrSum += indices[i] - indices[0];\\n\\t}\\n\\t\\n\\t// Now do the state transitions as described above.\\n\\tconst result = [currSum];\\n\\tlet rightCount = indices.length - 1;\\n\\tlet leftCount = 0;\\n\\tfor (let i = 1; i < indices.length; i++) {\\n\\t\\tcurrSum -= rightCount * (indices[i] - indices[i - 1]);\\n\\t\\trightCount -= 1;\\n\\t\\tleftCount += 1;\\n\\t\\tcurrSum += leftCount * (indices[i] - indices[i - 1]);\\n\\t\\tresult.push(currSum);\\n\\t}\\n\\treturn result;\\n }\\n```\\n\\nNow with the core algorithm implemented efficiently we can proceed to use it finish the problem. Here\\'s the final solution written in javascript.\\n\\n\\n```js\\nvar getDistances = function(arr) {\\n    // indices = [2, 5, 6, 8] returns [13, 7, 7, 11]\\n\\tfunction efficientRollingIntervalSum(indices) {\\n\\t\\t// Initialize the current sum for the first index;\\n\\t\\tlet currSum = 0;\\n\\t\\tfor (let i = 1; i < indices.length; i++) {\\n\\t\\t\\tcurrSum += indices[i] - indices[0];\\n\\t\\t}\\n\\n\\t\\t// Now do the state transitions as described above.\\n\\t\\tconst result = [currSum];\\n\\t\\tlet rightCount = indices.length - 1;\\n\\t\\tlet leftCount = 0;\\n\\t\\tfor (let i = 1; i < indices.length; i++) {\\n\\t\\t\\tcurrSum -= rightCount * (indices[i] - indices[i - 1]);\\n\\t\\t\\trightCount -= 1;\\n\\t\\t\\tleftCount += 1;\\n\\t\\t\\tcurrSum += leftCount * (indices[i] - indices[i - 1]);\\n\\t\\t\\tresult.push(currSum);\\n\\t\\t}\\n\\t\\treturn result;\\n\\t }\\n\\n    // First create a lookup table for locations of each number\\n\\t// [1, 2, 1] -> {1: [0, 2], 2: [1]}\\n    const indicesMap = {};\\n    for (let i = 0; i < arr.length; i++) {\\n        let n = arr[i];\\n        indicesMap[n] = indicesMap[n] || [];\\n        indicesMap[n].push(i);\\n    }\\n    \\n    const result = Array(arr.length).fill(null);\\n\\t// loop over every unique number in arr\\n    for (const n in indicesMap) {\\n        const list = indicesMap[n];\\n        const solution = efficientRollingIntervalSum(list);\\n\\t\\t// inject the answer into the right index of result\\n        for (let j = 0; j < list.length; j++) {\\n            result[list[j]] = solution[j];\\n        }\\n    }\\n    return result;\\n};\\n```\\n\\nHope this helped!\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nlet arr = [2, 1, 3, 1, 2, 3, 3];\\n```\n```\\nlet usefulDataStructure = {\\n\\t1: [1, 3],\\n\\t2: [0, 4].\\n\\t3: [2, 5, 6]\\n};\\n```\n```\\n// indices = [2, 5, 6] returns [7, 4, 5]\\nfunction bruteForceRollingIntervalSum(indices) {\\n\\tconst result = [];\\n\\tfor (let i = 0; i < indices.length; i++) {\\n\\t\\tlet sum = 0;\\n\\t\\tfor (let j = 0; j < indices.length; j++) {\\n\\t\\t\\tsum += Math.abs(indices[i] - indices[j]);\\n\\t\\t}\\n\\t\\tresult.push(sum);\\n\\t}\\n\\treturn result;\\n }\\n```\n```\\nindex0 = (5 - 2) + (6 - 2) + (8 - 2) = 13\\n```\n```\\nindex1 =  index0 - (5 - 2) * 3 + (5 - 2) * 1 = 7\\n```\n```\\nindex2 = index1 - (6 - 5) * 2 + (6 - 5) * 2 = 7\\n```\n```\\nindex3 = index2 - (8 - 6) * 1 + (8 - 6) * 3 = 11\\n```\n```js\\n// indices = [2, 5, 6, 8] returns [13, 7, 7, 11]\\nfunction efficientRollingIntervalSum(indices) {\\n\\t// Initialize the current sum for the first index;\\n\\tlet currSum = 0;\\n\\tfor (let i = 1; i < indices.length; i++) {\\n\\t\\tcurrSum += indices[i] - indices[0];\\n\\t}\\n\\t\\n\\t// Now do the state transitions as described above.\\n\\tconst result = [currSum];\\n\\tlet rightCount = indices.length - 1;\\n\\tlet leftCount = 0;\\n\\tfor (let i = 1; i < indices.length; i++) {\\n\\t\\tcurrSum -= rightCount * (indices[i] - indices[i - 1]);\\n\\t\\trightCount -= 1;\\n\\t\\tleftCount += 1;\\n\\t\\tcurrSum += leftCount * (indices[i] - indices[i - 1]);\\n\\t\\tresult.push(currSum);\\n\\t}\\n\\treturn result;\\n }\\n```\n```js\\nvar getDistances = function(arr) {\\n    // indices = [2, 5, 6, 8] returns [13, 7, 7, 11]\\n\\tfunction efficientRollingIntervalSum(indices) {\\n\\t\\t// Initialize the current sum for the first index;\\n\\t\\tlet currSum = 0;\\n\\t\\tfor (let i = 1; i < indices.length; i++) {\\n\\t\\t\\tcurrSum += indices[i] - indices[0];\\n\\t\\t}\\n\\n\\t\\t// Now do the state transitions as described above.\\n\\t\\tconst result = [currSum];\\n\\t\\tlet rightCount = indices.length - 1;\\n\\t\\tlet leftCount = 0;\\n\\t\\tfor (let i = 1; i < indices.length; i++) {\\n\\t\\t\\tcurrSum -= rightCount * (indices[i] - indices[i - 1]);\\n\\t\\t\\trightCount -= 1;\\n\\t\\t\\tleftCount += 1;\\n\\t\\t\\tcurrSum += leftCount * (indices[i] - indices[i - 1]);\\n\\t\\t\\tresult.push(currSum);\\n\\t\\t}\\n\\t\\treturn result;\\n\\t }\\n\\n    // First create a lookup table for locations of each number\\n\\t// [1, 2, 1] -> {1: [0, 2], 2: [1]}\\n    const indicesMap = {};\\n    for (let i = 0; i < arr.length; i++) {\\n        let n = arr[i];\\n        indicesMap[n] = indicesMap[n] || [];\\n        indicesMap[n].push(i);\\n    }\\n    \\n    const result = Array(arr.length).fill(null);\\n\\t// loop over every unique number in arr\\n    for (const n in indicesMap) {\\n        const list = indicesMap[n];\\n        const solution = efficientRollingIntervalSum(list);\\n\\t\\t// inject the answer into the right index of result\\n        for (let j = 0; j < list.length; j++) {\\n            result[list[j]] = solution[j];\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647611,
                "title": "java-creating-buckets-and-then-prefix-sum-commented-solution-t-o-n-s-o-n",
                "content": "```\\n/*\\n   The idea is to create a bucket for each unique value in the array arr, so that each of them can be handled separately.\\n   The bucket will be in the form of a list containing the index of that particular element in ascending order.\\n   Let array ans contains the final value.\\n   Now in each bucket B, we have to do the following:\\n        Suppose B is of size k, i.e., a particular element num appears k times in the original array.\\n        for each i, 0<=i<k, \\n            B[i] is an index where num appears in the original array.\\n            ans[B[i]]=difference of indices on left+difference of indices on right\\n            difference of index on left=B[i]-B[j] (for B[j]<B[i],i.e, j<i, since B is ascending) = i*B[i]-sum(B[j],0<=j<i)\\n            difference of index on right=B[j]-B[i] (for B[i]<B[j],i.e, i<j, since B is ascending) = sum(B[j],i<j<k)-(k-i-1)*B[i]              \\n*/\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        int n=arr.length;\\n        long []ans=new long[n];\\n        \\n        // creating the bucket.\\n        HashMap<Integer,List<Integer>> hmap=new HashMap<>();         \\n        for(int i=0;i<n;i++){\\n            hmap.putIfAbsent(arr[i],new ArrayList<>());\\n            hmap.get(arr[i]).add(i);\\n        }\\n        \\n        /*\\n         next represents prefix sum of the right indices. sum(B[j],i<j<k).\\n         prev represents prefix sum of the left indices. sum(B[j],0<=j<i).\\n         curr represents current index.\\n        */\\n        long next,curr,prev;\\n        int v,k;\\n        for(List<Integer> list:hmap.values()){ // for each bucket\\n            \\n            k=list.size(); // size of bucket.\\n            \\n            // for creating prefix sum to calculate the sum on the left and sum on the right\\n            List<Long>prefixSum=new ArrayList<>(); \\n            v=list.get(0);            \\n            prefixSum.add((long)v);\\n            for(int i=1;i<k;i++){\\n                prefixSum.add(prefixSum.get(i-1)+list.get(i));\\n            }\\n            \\n            for(int i=0;i<k;i++){\\n                prev=i==0?0:prefixSum.get(i-1);\\n                curr=list.get(i);\\n                next=prefixSum.get(k-1)-prefixSum.get(i);\\n                ans[list.get(i)]=curr*(long)i-prev+next-curr*(long)(k-1-i);\\n            }\\n        }\\n        return ans;\\n    }    \\n}\\n/*\\nT=O(N)\\nS=O(N)\\n*/\\n```\\nThanks for reading. Please upvote if this helps.",
                "solutionTags": [],
                "code": "```\\n/*\\n   The idea is to create a bucket for each unique value in the array arr, so that each of them can be handled separately.\\n   The bucket will be in the form of a list containing the index of that particular element in ascending order.\\n   Let array ans contains the final value.\\n   Now in each bucket B, we have to do the following:\\n        Suppose B is of size k, i.e., a particular element num appears k times in the original array.\\n        for each i, 0<=i<k, \\n            B[i] is an index where num appears in the original array.\\n            ans[B[i]]=difference of indices on left+difference of indices on right\\n            difference of index on left=B[i]-B[j] (for B[j]<B[i],i.e, j<i, since B is ascending) = i*B[i]-sum(B[j],0<=j<i)\\n            difference of index on right=B[j]-B[i] (for B[i]<B[j],i.e, i<j, since B is ascending) = sum(B[j],i<j<k)-(k-i-1)*B[i]              \\n*/\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        int n=arr.length;\\n        long []ans=new long[n];\\n        \\n        // creating the bucket.\\n        HashMap<Integer,List<Integer>> hmap=new HashMap<>();         \\n        for(int i=0;i<n;i++){\\n            hmap.putIfAbsent(arr[i],new ArrayList<>());\\n            hmap.get(arr[i]).add(i);\\n        }\\n        \\n        /*\\n         next represents prefix sum of the right indices. sum(B[j],i<j<k).\\n         prev represents prefix sum of the left indices. sum(B[j],0<=j<i).\\n         curr represents current index.\\n        */\\n        long next,curr,prev;\\n        int v,k;\\n        for(List<Integer> list:hmap.values()){ // for each bucket\\n            \\n            k=list.size(); // size of bucket.\\n            \\n            // for creating prefix sum to calculate the sum on the left and sum on the right\\n            List<Long>prefixSum=new ArrayList<>(); \\n            v=list.get(0);            \\n            prefixSum.add((long)v);\\n            for(int i=1;i<k;i++){\\n                prefixSum.add(prefixSum.get(i-1)+list.get(i));\\n            }\\n            \\n            for(int i=0;i<k;i++){\\n                prev=i==0?0:prefixSum.get(i-1);\\n                curr=list.get(i);\\n                next=prefixSum.get(k-1)-prefixSum.get(i);\\n                ans[list.get(i)]=curr*(long)i-prev+next-curr*(long)(k-1-i);\\n            }\\n        }\\n        return ans;\\n    }    \\n}\\n/*\\nT=O(N)\\nS=O(N)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647916,
                "title": "c-solution-using-hash-map-easy-to-understand",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<ll> v(n);\\n        \\n        unordered_map<ll,ll> mp,sum;\\n        \\n        // left to right traversal\\n        \\n        for(int i=0;i<n;i++){\\n             v[i]=mp[arr[i]]*i - sum[arr[i]];\\n             mp[arr[i]]++;\\n             sum[arr[i]]+=i;\\n        }\\n        \\n         mp.clear();\\n         sum.clear();\\n        \\n        // right to left traversal\\n        \\n        for(int i=n-1;i>=0;i--){\\n            v[i]+= (sum[arr[i]] - mp[arr[i]]*i);\\n            mp[arr[i]]++;\\n            sum[arr[i]]+=i;\\n        }\\n        \\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<ll> v(n);\\n        \\n        unordered_map<ll,ll> mp,sum;\\n        \\n        // left to right traversal\\n        \\n        for(int i=0;i<n;i++){\\n             v[i]=mp[arr[i]]*i - sum[arr[i]];\\n             mp[arr[i]]++;\\n             sum[arr[i]]+=i;\\n        }\\n        \\n         mp.clear();\\n         sum.clear();\\n        \\n        // right to left traversal\\n        \\n        for(int i=n-1;i>=0;i--){\\n            v[i]+= (sum[arr[i]] - mp[arr[i]]*i);\\n            mp[arr[i]]++;\\n            sum[arr[i]]+=i;\\n        }\\n        \\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798501,
                "title": "simple-c-code-map-prefix-suffix-sum-o-n-commented-explanation",
                "content": "```\\n//a b c d e (such that a<b<c<d<e)\\n//let\\'s assume a,b,c,d,e are indices such that arr[a]=arr[b]=arr[c]=arr[d]=arr[e]\\n//now assume we are stading at index \\'c\\' then \\n// ans[c] = |c-a| + |c-b| + |d-c| + |e-c| -----(1)\\n//we can divide it into two parts 1.) occuring before index \\'c\\' 2.) occuring after index \\'c\\'\\n//let\\'s say count of indexes occuring before index \\'c\\' be cnt1=2(which is 2 here) and sum of those indices is a+b (here)\\n\\n//let\\'s say count of indexes occuring after index \\'c\\' be cnt2=2(which is 2 here) and sum of those indices is d+e (here)\\n\\n//then equation 1 boils down to\\n// cnt1*c - (a+b) + (d+e) - cnt2*c\\n// 2*c-(a+b) + (d+e) - 2*c\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int,long long> sum_map;\\n        unordered_map<int,long long> count_map;\\n        vector<long long> ans(n,0);\\n        \\n        //first loop for first part of condition when we considering all the indices occuring before the curr_idx\\n        for(int i=0;i<n;i++){\\n            if(count_map.find(arr[i])==count_map.end()){\\n                count_map[arr[i]]++;\\n                sum_map[arr[i]]+=i;\\n                ans[i]=0;\\n            }\\n            else{\\n                long long cnt=count_map[arr[i]];\\n                long long before_sum=sum_map[arr[i]];\\n                ans[i]=(long long)cnt*i - (before_sum);\\n                count_map[arr[i]]++;\\n                sum_map[arr[i]]+=i;\\n            }\\n        }\\n        \\n        count_map.clear();\\n        sum_map.clear();\\n        \\n        \\n        //second loop for second part of condition when we considering all the indices occuring after the curr_idx\\n        for(int i=n-1;i>=0;i--){\\n            if(count_map.find(arr[i])==count_map.end()){\\n                count_map[arr[i]]++;\\n                sum_map[arr[i]]+=i;\\n                ans[i]+=0;\\n            }\\n            else{\\n                long long cnt=count_map[arr[i]];\\n                long long after_sum=sum_map[arr[i]];\\n                ans[i]+=after_sum - (long long)(cnt*i);\\n                count_map[arr[i]]++;\\n                sum_map[arr[i]]+=i;\\n            }\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n//a b c d e (such that a<b<c<d<e)\\n//let\\'s assume a,b,c,d,e are indices such that arr[a]=arr[b]=arr[c]=arr[d]=arr[e]\\n//now assume we are stading at index \\'c\\' then \\n// ans[c] = |c-a| + |c-b| + |d-c| + |e-c| -----(1)\\n//we can divide it into two parts 1.) occuring before index \\'c\\' 2.) occuring after index \\'c\\'\\n//let\\'s say count of indexes occuring before index \\'c\\' be cnt1=2(which is 2 here) and sum of those indices is a+b (here)\\n\\n//let\\'s say count of indexes occuring after index \\'c\\' be cnt2=2(which is 2 here) and sum of those indices is d+e (here)\\n\\n//then equation 1 boils down to\\n// cnt1*c - (a+b) + (d+e) - cnt2*c\\n// 2*c-(a+b) + (d+e) - 2*c\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int,long long> sum_map;\\n        unordered_map<int,long long> count_map;\\n        vector<long long> ans(n,0);\\n        \\n        //first loop for first part of condition when we considering all the indices occuring before the curr_idx\\n        for(int i=0;i<n;i++){\\n            if(count_map.find(arr[i])==count_map.end()){\\n                count_map[arr[i]]++;\\n                sum_map[arr[i]]+=i;\\n                ans[i]=0;\\n            }\\n            else{\\n                long long cnt=count_map[arr[i]];\\n                long long before_sum=sum_map[arr[i]];\\n                ans[i]=(long long)cnt*i - (before_sum);\\n                count_map[arr[i]]++;\\n                sum_map[arr[i]]+=i;\\n            }\\n        }\\n        \\n        count_map.clear();\\n        sum_map.clear();\\n        \\n        \\n        //second loop for second part of condition when we considering all the indices occuring after the curr_idx\\n        for(int i=n-1;i>=0;i--){\\n            if(count_map.find(arr[i])==count_map.end()){\\n                count_map[arr[i]]++;\\n                sum_map[arr[i]]+=i;\\n                ans[i]+=0;\\n            }\\n            else{\\n                long long cnt=count_map[arr[i]];\\n                long long after_sum=sum_map[arr[i]];\\n                ans[i]+=after_sum - (long long)(cnt*i);\\n                count_map[arr[i]]++;\\n                sum_map[arr[i]]+=i;\\n            }\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1648388,
                "title": "simple-python-solution-two-pass-prefix-sum-one-level-loop-only",
                "content": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        n=len(arr)\\n        res=[0]*n\\n\\t\\t\\n\\t\\t#left to the right\\n        last={}\\n        lastdist={}\\n        lastcount={}\\n        for i in range(n):\\n            if arr[i] not in last:\\n                last[arr[i]]=i\\n                lastcount[arr[i]]=1\\n                lastdist[arr[i]]=0\\n            else:\\n                lastdist[arr[i]]+=(i-last[arr[i]])*lastcount[arr[i]]\\n                lastcount[arr[i]]+=1\\n                last[arr[i]]=i\\n                res[i]+=lastdist[arr[i]]\\n\\t\\t\\t\\t\\n\\t\\t#right to the left\\n        last={}\\n        lastdist={}\\n        lastcount={}\\n        for i in range(n-1,-1,-1):\\n            if arr[i] not in last:\\n                last[arr[i]]=i\\n                lastcount[arr[i]]=1\\n                lastdist[arr[i]]=0\\n            else:\\n                lastdist[arr[i]]+=(-i+last[arr[i]])*lastcount[arr[i]]\\n                lastcount[arr[i]]+=1\\n                last[arr[i]]=i\\n                res[i]+=lastdist[arr[i]]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        n=len(arr)\\n        res=[0]*n\\n\\t\\t\\n\\t\\t#left to the right\\n        last={}\\n        lastdist={}\\n        lastcount={}\\n        for i in range(n):\\n            if arr[i] not in last:\\n                last[arr[i]]=i\\n                lastcount[arr[i]]=1\\n                lastdist[arr[i]]=0\\n            else:\\n                lastdist[arr[i]]+=(i-last[arr[i]])*lastcount[arr[i]]\\n                lastcount[arr[i]]+=1\\n                last[arr[i]]=i\\n                res[i]+=lastdist[arr[i]]\\n\\t\\t\\t\\t\\n\\t\\t#right to the left\\n        last={}\\n        lastdist={}\\n        lastcount={}\\n        for i in range(n-1,-1,-1):\\n            if arr[i] not in last:\\n                last[arr[i]]=i\\n                lastcount[arr[i]]=1\\n                lastdist[arr[i]]=0\\n            else:\\n                lastdist[arr[i]]+=(-i+last[arr[i]])*lastcount[arr[i]]\\n                lastcount[arr[i]]+=1\\n                last[arr[i]]=i\\n                res[i]+=lastdist[arr[i]]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647636,
                "title": "c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        map<int, vector<int>> iPos;\\n        map<int, long long> sum;\\n            \\n        vector<long long> ans;\\n        \\n        int len = arr.size();\\n        for(int i = 0; i<len; i++){\\n            ans.push_back(0);\\n            iPos[arr[i]].push_back(i);\\n            sum[arr[i]] += i;\\n        }\\n        \\n        for(int i = 0; i<len; i++){\\n            if(ans[i] > 0) continue;\\n            \\n            vector<int> v = iPos[arr[i]];\\n            long long leftSum = 0;\\n            long long rightSum = 0;\\n            long long leftCnt = 0;\\n            long long rightCnt = 0;\\n            \\n            for(int j = 0; j<v.size(); j++){\\n                rightSum = sum[arr[i]] - (v[j] + leftSum);\\n                rightCnt = v.size() - (j+1);\\n                \\n                ans[v[j]] = abs((leftCnt*v[j]) - leftSum) + abs((rightCnt*v[j]) - rightSum);    \\n                \\n                leftSum += v[j];    \\n                leftCnt ++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        map<int, vector<int>> iPos;\\n        map<int, long long> sum;\\n            \\n        vector<long long> ans;\\n        \\n        int len = arr.size();\\n        for(int i = 0; i<len; i++){\\n            ans.push_back(0);\\n            iPos[arr[i]].push_back(i);\\n            sum[arr[i]] += i;\\n        }\\n        \\n        for(int i = 0; i<len; i++){\\n            if(ans[i] > 0) continue;\\n            \\n            vector<int> v = iPos[arr[i]];\\n            long long leftSum = 0;\\n            long long rightSum = 0;\\n            long long leftCnt = 0;\\n            long long rightCnt = 0;\\n            \\n            for(int j = 0; j<v.size(); j++){\\n                rightSum = sum[arr[i]] - (v[j] + leftSum);\\n                rightCnt = v.size() - (j+1);\\n                \\n                ans[v[j]] = abs((leftCnt*v[j]) - leftSum) + abs((rightCnt*v[j]) - rightSum);    \\n                \\n                leftSum += v[j];    \\n                leftCnt ++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660356,
                "title": "unordered-map-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Approach-1:** Brute Force Approach Using Hash Table Looks Easy but it is not efficient solution it gives TLE.\\n**Approach-2:** to optmize the brute force, Break Dawn the Brute Force into **Current (SUM & FREQUENCY)** and **Remaining (SUM & FREQUENCY**) \\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        vector<long long> ans(n);\\n        unordered_map<long long,long long> sum,freq,currfreq,currsum;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n           sum[arr[i]]+=i;\\n           freq[arr[i]]++;\\n        }\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n           currfreq[arr[i]]++;\\n           currsum[arr[i]]+=i;\\n\\n           long long currfrq = currfreq[arr[i]]-1,remfreq = freq[arr[i]]-currfreq[arr[i]];\\n           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];\\n           ans[i] =  abs(i*currfrq-(currsumval-i))+abs(i*remfreq-remsum);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/ef1866bf-43d6-4c44-877f-d7106d457c67_1687245465.1707878.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        vector<long long> ans(n);\\n        unordered_map<long long,long long> sum,freq,currfreq,currsum;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n           sum[arr[i]]+=i;\\n           freq[arr[i]]++;\\n        }\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n           currfreq[arr[i]]++;\\n           currsum[arr[i]]+=i;\\n\\n           long long currfrq = currfreq[arr[i]]-1,remfreq = freq[arr[i]]-currfreq[arr[i]];\\n           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];\\n           ans[i] =  abs(i*currfrq-(currsumval-i))+abs(i*remfreq-remsum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163492,
                "title": "99-faster-c-o-n-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<int,vector<int>> mp;\\n        for(int i = 0; i < arr.size(); i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<long long> v(arr.size());\\n        long long int s1,s2,k,ans;\\n        for(auto &i: mp){\\n            s1 = 0, s2 = 0;\\n            for(auto j: i.second){\\n                s2 = s2 + j;\\n            }\\n            // cout<<i.first<<\" \"<<s2<<endl;\\n            for(k = 0; k < i.second.size(); k++){\\n                // cout<<i.second[k];\\n                ans = (s2-(i.second.size()-k)*i.second[k]) + abs(s1-k*i.second[k]);\\n                v[i.second[k]] = ans;\\n                s2 -= i.second[k];\\n                s1 += i.second[k];\\n                \\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<int,vector<int>> mp;\\n        for(int i = 0; i < arr.size(); i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<long long> v(arr.size());\\n        long long int s1,s2,k,ans;\\n        for(auto &i: mp){\\n            s1 = 0, s2 = 0;\\n            for(auto j: i.second){\\n                s2 = s2 + j;\\n            }\\n            // cout<<i.first<<\" \"<<s2<<endl;\\n            for(k = 0; k < i.second.size(); k++){\\n                // cout<<i.second[k];\\n                ans = (s2-(i.second.size()-k)*i.second[k]) + abs(s1-k*i.second[k]);\\n                v[i.second[k]] = ans;\\n                s2 -= i.second[k];\\n                s1 += i.second[k];\\n                \\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1699544,
                "title": "detailed-explanation-with-implementation-using-hashmaps-and-prefixsum-c",
                "content": "Given Array = [2,1,3,1,2,3,3,1,3,2,1,2,2,1,1]\\n\\n**Unordered_map built from the given array:**  (key, value) = (Array[i], array of all indexes of Array[i])\\n1 -> [1, 3, 7, 10, 13, 14]\\n2 -> [0, 4, 9, 11, 12]\\n3 -> [2, 5, 6, 8]\\n\\ntemp  =    [1, 3, 7, 10, 13, 14]\\npre     =    [1, 4, 11, 21, 34, 48]   (Prefix sum array of temp array)\\n\\n* Index 1:       (1 - 1) + (3 - 1) + (7 - 1) + (10 - 1) + (13 - 1) + (14 - 1)\\n* Index 3:       (3 - 1) + (3 - 3) + (7 - 3) + (10 - 3) + (13 - 3) + (14 - 3)\\n* Index 7:       (7 - 1) + (7 - 3) + (7 - 7) + (10 - 7) + (13 - 7) + (14 - 7)\\n* Index 10:     (10 - 1) + (10 - 3) + (10 - 7) + (10 - 10) + (13 - 10) + (14 - 10)\\n* Index 13:     (13 - 1) + (13 - 3) + (13 - 7) + (13 - 10) + (13 - 13) + (14 - 13)\\n* Index 14:     (14 - 1) + (14 - 3) + (14 - 7) + (14 - 10) + (14 - 13) + (14 - 14)\\n\\nIn the above bulleted list, in every line one thing is common i.e., (temp[i] - temp[i])  ------> eq (1)\\n\\nIf we observe carefully, in every line there are some elements(possibly 0) before eq (1) and some elements(possibly 0) after eq (1).\\nA fixed pattern is being followed before and after eq (1).\\n\\n**Before eq (1):**   (temp[i] - x)\\n\\n**After eq (1):**      (x - temp[i]) \\n\\nNow compute,\\n**after = (temp.size() - 1 - i)**  *------> No.of elements present in temp array after temp[i]*\\n**before = i**    *------------------------> No.of elements present in temp array before temp[i]*\\n\\nSum of Intervals = (Computation before eq (1) + Computation after eq (1))\\n\\n**Computation before eq (1):**\\nbefore * temp[i] - (sum of all elements from index 0 to (i-1) in temp array. -> we can get this from prefix sum array = pre[i-1]).\\n\\n**Computation after eq (1):**\\n(sum of all elements from (i+1) to (temp.size()-1). -> we can get this from prefix sum array = (pre[temp.size()-1] - pre[i])) - after*temp[i].\\n\\n\\n**Implementation:**\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& A) \\n    {\\n        int n = A.size();\\n        \\n        unordered_map<int,vector<long long>> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[A[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n);\\n        \\n        for(auto j:m)\\n        {\\n            vector<long long> temp = j.second;\\n            int len = temp.size();\\n            \\n            vector<long long> pre(len, 0);\\n            \\n            pre[0] = temp[0];\\n            for(int i=1;i<len;i++)\\n            {\\n                pre[i] = pre[i-1] + temp[i];\\n            }\\n            \\n            for(int i=0;i<len;i++)\\n            {\\n                long long count = 0;\\n                long long after = (len - 1 - i), before = i;\\n                \\n                count = (pre[len-1] - pre[i]) - (after*temp[i]);   //Computation After\\n                if(i > 0) count += (before*temp[i] - (pre[i-1]));  //Computation Before\\n                \\n                res[temp[i]] = count;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& A) \\n    {\\n        int n = A.size();\\n        \\n        unordered_map<int,vector<long long>> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[A[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n);\\n        \\n        for(auto j:m)\\n        {\\n            vector<long long> temp = j.second;\\n            int len = temp.size();\\n            \\n            vector<long long> pre(len, 0);\\n            \\n            pre[0] = temp[0];\\n            for(int i=1;i<len;i++)\\n            {\\n                pre[i] = pre[i-1] + temp[i];\\n            }\\n            \\n            for(int i=0;i<len;i++)\\n            {\\n                long long count = 0;\\n                long long after = (len - 1 - i), before = i;\\n                \\n                count = (pre[len-1] - pre[i]) - (after*temp[i]);   //Computation After\\n                if(i > 0) count += (before*temp[i] - (pre[i-1]));  //Computation Before\\n                \\n                res[temp[i]] = count;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657201,
                "title": "the-art-of-dynamic-programming",
                "content": "**\\u26A1\\uFE0F TL;DR**\\n\\nDynamic programming on `K` disjoint graph paths formed by the monotonically increasing/decreasing index values of each identical element `x` of the input array `A`, where `K` is the quantity of unique elements `x` of the input array `A`, ie. traverse each edge `i..j` of each path in forward and reverse order, remembering each past `j`<sup>th</sup> index\\'s `cost` to formulate each future `i`<sup>th</sup> index\\'s `cost`.  Below are details for this DP approach which bottom-up sequentially builds upon `K`<sup>th</sup> buckets of previous solutions.\\n\\n---\\n\\n[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) We can perform 2 linear scans of the input array `A` (one from left-to-right and one from right-to-left) and track the previously seen `j`<sup>th</sup> index `cost` when compared to each current `i`<sup>th</sup> index from `i=0..N-1` during the first linear scan and from `i=N-1..0` during the second linear scan.\\n\\n**\\uD83D\\uDED1 Base Cases:** The cost of first element of each linear scan is `0`, ie. `ans[0] = 0` during the first linear scan in the forward direction, and `ans[N - 1] = 0` during the second linear scan in the reverse direction.\\n\\n**\\uD83D\\uDE80 Recurrence Relation:** During these linear scans, each answer\\'s `i`<sup>th</sup> index `ans[i]` is associated with a current `i`<sup>th</sup> index `cost` as the absolute difference `|i - j|` (where `j` is the last seen index of the value `x = A[i]`) multipled by the count of `x` seen thus far plus the previous `j`<sup>th</sup> index `cost`.\\n* `current cost = (|i - j| * count[x]) + previous cost`\\n\\nNote: we multipy each absolute difference `|i - j|` by the count of `x` seen thus far as the current `i`<sup>th</sup> index `cost` because this allows us to account for all parallel/overlapping edges `i..j` holistically (rather than accumulate those `i..j` edges sequentially in piecemeal fashion which results in TLE).\\n\\n**\\u2B50\\uFE0F Final Answer:** We can accumulate each `i`<sup>th</sup> value of the two linear scans\\' answers (`a` and `b` correspondingly) as two \"halves\" coalesced to formulate the final answer `c` to be returned.\\n* `a + b = c`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun getDistances(A: IntArray): LongArray {\\n        var N = A.size\\n        fun f(rev: Boolean): LongArray {\\n            var ans = LongArray(N)\\n            var (m, cnt) = Pair(mutableMapOf<Int, Pair<Int, Long>>(), mutableMapOf<Int, Int>())\\n            var index = if (!rev) IntArray(N) { it } else IntArray(N) { N - 1 - it }\\n            for (i in index) {\\n                var (x, cur) = Pair(A[i], 0L)\\n                if (m.contains(x)) {\\n                    var (j, pre) = m[x]!!\\n                    cur = (Math.abs(i - j).toLong() * cnt[x]!!) + pre\\n                }\\n                m[x] = Pair(i, cur)\\n                cnt[x] = 1 + cnt.getOrDefault(x, 0)\\n                ans[i] = cur\\n            }\\n            return ans\\n        }\\n        return (f(false) zip f(true)).map{ (a, b) -> a + b }.toLongArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet getDistances = A => {\\n    let N = A.length;\\n    let f = (beg, end) => {\\n        let ans = Array(N);\\n        let [m, cnt] = [new Map(), new Map()];\\n        for (let i = beg; beg < end ? i <= end : end <= i; beg < end ? ++i : --i) {\\n            let [x, cur] = [A[i], 0];\\n            if (m.has(x)) {\\n                let [j, pre] = m.get(x);\\n                cnt.set(x, 1 + (cnt.get(x) || 0));\\n                cur = (Math.abs(i - j) * cnt.get(x)) + pre;\\n            }\\n            m.set(x, [i, cur]);\\n            ans[i] = cur;\\n        }\\n        return ans;\\n    };\\n    let a = f(0, N - 1),\\n        b = f(N - 1, 0);\\n    return _.zip(a, b).map(([a, b]) => a + b);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def getDistances(self, A: List[int]) -> List[int]:\\n        N = len(A)\\n        def f(rev):\\n            ans = [0] * N\\n            m, cnt = {}, Counter()\\n            for i in range(N) if not rev else range(N - 1, -1, -1):\\n                x, cur = A[i], 0\\n                if x in m:\\n                    j, pre = m[x]\\n                    cnt[x] += 1\\n                    cur = (abs(i - j) * cnt[x]) + pre\\n                m[x] = [i, cur]\\n                ans[i] = cur\\n            return ans\\n        return [a + b for a, b in zip(f(False), f(True))]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using Pair = pair<LL, LL>;\\n    using Map = unordered_map<LL, Pair>; // x -> i, cost\\n    using Counter = unordered_map<LL, LL>;\\n    VL getDistances(VI& A) {\\n        int N = A.size();\\n        auto f = [&](LL beg, LL end) {\\n            VL ans(N);\\n            Map m;\\n            Counter cnt;\\n            for (LL i{ beg }; beg < end ? i <= end : end <= i; beg < end ? ++i : --i) {\\n                auto [x, cur] = make_pair(A[i], 0LL);\\n                if (m.find(x) != m.end()) {\\n                    auto [j, pre] = m[x];\\n                    cur = (abs(i - j) * ++cnt[x]) + pre;\\n                }\\n                m[x] = make_pair(i, cur);\\n                ans[i] = cur;\\n            }\\n            return ans;\\n        };\\n        auto a = f(0, N - 1),\\n             b = f(N - 1, 0),\\n             c = VL(N);\\n        for (auto i{ 0 }; i < N; ++i)\\n            c[i] = a[i] + b[i];\\n        return c;\\n    }\\n};\\n```\\n\\n---\\n\\n**Supplemental:** below are the chronologically ordered \"failures\" which were prerequisites to the \"sucess\" above...\\n\\n*Python3*\\n```\\n\\n# lets see this brute-force TLE... OK this is correct solution (as i thought, which TLEs as expected)\\n\\n# m => need to lookup by index i, not value x\\n\\n# oh ok i is relative, not absolute\\n\\n# brute-force, then optimize to avoid TLE\\n\\n# Example 1:\\n\\n# Input: arr = [2,1,3,1,2,3,3]\\n# Output: [4,2,7,2,4,4,5]\\n\\n# Your input\\n# [2,1,3,1,2,3,3]\\n# Your answer\\n# [4,2,7,2,4,4,5]\\n\\n# this will TLE since N=1e5\\n# class Solution:\\n#     def getDistances(self, A: List[int]) -> List[int]:\\n#         m = {}\\n#         for i, x in enumerate(A):\\n#             if x not in m:\\n#                 m[x] = []\\n#             m[x].append(i)\\n#         dist = []\\n#         for i in range(len(A)):\\n#             t = 0\\n#             x = A[i]\\n#             index = m[x]\\n#             for j in index:\\n#                 if i != j:\\n#                     t += abs(i - j)\\n#             dist.append(t)\\n#         return dist\\n            \\n# ok we want to include absolute diffs relative to each i = 0..N-1\\n# Q: how to avoid TLE?\\n# can i use prefix sums? <-- use inversion, ie. can we deduce/derive it?\\n\\n# maybe preprocess input from right-to-left and from left-to-right?\\n\\n# let\\'s take a break on this one and come back...\\n\\nclass Solution:\\n    def getDistances(self, A: List[int]) -> List[int]:\\n        m = {}\\n        for i, x in enumerate(A):\\n            if x not in m:\\n                m[x] = []\\n            m[x].append(i)\\n        dist = []\\n        for i in range(len(A)):\\n            t = 0\\n            x = A[i]\\n            index = m[x]\\n            for j in index:\\n                if i != j:\\n                    t += abs(i - j)\\n            dist.append(t)\\n        return dist\\n```\\n\\n---\\n\\n*C++*\\n```\\n/*\\n\\nas i changes, so does the relative distances for each value of x along the way\\n\\nok i think i know what might work...\\n\\nuse a map to store a list of indices i for each value x\\n\\nthen perform prefix sums from left-to-right and from right-to-left for each O(1) lookup relative to each \"pivot\" index\\n\\nKISS == keep it super simple...\\n\\nInput: arr = [2,1,3,1,2,3,3]\\n              0 1 2 3 4 5 6 7\\n                        ^\\n                          R[5] = 6\\n                 L[5] = 2\\nOutput: [4,2,7,2,4,4,5]\\n\\n\\nA = [2,1,3,1,2,3,3]\\n     0 1 2 3 4 5 6 7\\nL =  0 1 2 1 0 2 5\\nR =  4 3 5 3 4 6 6\\n\\nok so we can use L/R and relative index lookups for closest same value to-the-left and to-the-right\\n\\nand use dynamic programming to solve it?\\n\\nlet\\'s use a more simple example\\n\\nN = 3\\n\\nA = 1 1 1\\n    0 1 2 3\\n\\nL = 0 1 2  preL = 0, 1, 3\\nR = 2 1 0  preR = 3, 1, 0\\n                  3, 2, 3\\n\\nthen add them up? <-- well this works ok for a single value x\\n\\nso each value x will need L/R and prefix sums?\\n\\nans = [3, 2, 3]\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using VL = vector<LL>;\\n    using Map = unordered_map<>;\\n    VL getDistances(VI& A, VL ans = {}) {\\n        int N = A.size();\\n        auto L{ A }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/04287ee5-bc72-48c1-be25-de79922a2518_1640896409.2668686.jpeg)\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    fun getDistances(A: IntArray): LongArray {\\n        var N = A.size\\n        fun f(rev: Boolean): LongArray {\\n            var ans = LongArray(N)\\n            var (m, cnt) = Pair(mutableMapOf<Int, Pair<Int, Long>>(), mutableMapOf<Int, Int>())\\n            var index = if (!rev) IntArray(N) { it } else IntArray(N) { N - 1 - it }\\n            for (i in index) {\\n                var (x, cur) = Pair(A[i], 0L)\\n                if (m.contains(x)) {\\n                    var (j, pre) = m[x]!!\\n                    cur = (Math.abs(i - j).toLong() * cnt[x]!!) + pre\\n                }\\n                m[x] = Pair(i, cur)\\n                cnt[x] = 1 + cnt.getOrDefault(x, 0)\\n                ans[i] = cur\\n            }\\n            return ans\\n        }\\n        return (f(false) zip f(true)).map{ (a, b) -> a + b }.toLongArray()\\n    }\\n}\\n```\n```\\nlet getDistances = A => {\\n    let N = A.length;\\n    let f = (beg, end) => {\\n        let ans = Array(N);\\n        let [m, cnt] = [new Map(), new Map()];\\n        for (let i = beg; beg < end ? i <= end : end <= i; beg < end ? ++i : --i) {\\n            let [x, cur] = [A[i], 0];\\n            if (m.has(x)) {\\n                let [j, pre] = m.get(x);\\n                cnt.set(x, 1 + (cnt.get(x) || 0));\\n                cur = (Math.abs(i - j) * cnt.get(x)) + pre;\\n            }\\n            m.set(x, [i, cur]);\\n            ans[i] = cur;\\n        }\\n        return ans;\\n    };\\n    let a = f(0, N - 1),\\n        b = f(N - 1, 0);\\n    return _.zip(a, b).map(([a, b]) => a + b);\\n};\\n```\n```\\nclass Solution:\\n    def getDistances(self, A: List[int]) -> List[int]:\\n        N = len(A)\\n        def f(rev):\\n            ans = [0] * N\\n            m, cnt = {}, Counter()\\n            for i in range(N) if not rev else range(N - 1, -1, -1):\\n                x, cur = A[i], 0\\n                if x in m:\\n                    j, pre = m[x]\\n                    cnt[x] += 1\\n                    cur = (abs(i - j) * cnt[x]) + pre\\n                m[x] = [i, cur]\\n                ans[i] = cur\\n            return ans\\n        return [a + b for a, b in zip(f(False), f(True))]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using Pair = pair<LL, LL>;\\n    using Map = unordered_map<LL, Pair>; // x -> i, cost\\n    using Counter = unordered_map<LL, LL>;\\n    VL getDistances(VI& A) {\\n        int N = A.size();\\n        auto f = [&](LL beg, LL end) {\\n            VL ans(N);\\n            Map m;\\n            Counter cnt;\\n            for (LL i{ beg }; beg < end ? i <= end : end <= i; beg < end ? ++i : --i) {\\n                auto [x, cur] = make_pair(A[i], 0LL);\\n                if (m.find(x) != m.end()) {\\n                    auto [j, pre] = m[x];\\n                    cur = (abs(i - j) * ++cnt[x]) + pre;\\n                }\\n                m[x] = make_pair(i, cur);\\n                ans[i] = cur;\\n            }\\n            return ans;\\n        };\\n        auto a = f(0, N - 1),\\n             b = f(N - 1, 0),\\n             c = VL(N);\\n        for (auto i{ 0 }; i < N; ++i)\\n            c[i] = a[i] + b[i];\\n        return c;\\n    }\\n};\\n```\n```\\n\\n# lets see this brute-force TLE... OK this is correct solution (as i thought, which TLEs as expected)\\n\\n# m => need to lookup by index i, not value x\\n\\n# oh ok i is relative, not absolute\\n\\n# brute-force, then optimize to avoid TLE\\n\\n# Example 1:\\n\\n# Input: arr = [2,1,3,1,2,3,3]\\n# Output: [4,2,7,2,4,4,5]\\n\\n# Your input\\n# [2,1,3,1,2,3,3]\\n# Your answer\\n# [4,2,7,2,4,4,5]\\n\\n# this will TLE since N=1e5\\n# class Solution:\\n#     def getDistances(self, A: List[int]) -> List[int]:\\n#         m = {}\\n#         for i, x in enumerate(A):\\n#             if x not in m:\\n#                 m[x] = []\\n#             m[x].append(i)\\n#         dist = []\\n#         for i in range(len(A)):\\n#             t = 0\\n#             x = A[i]\\n#             index = m[x]\\n#             for j in index:\\n#                 if i != j:\\n#                     t += abs(i - j)\\n#             dist.append(t)\\n#         return dist\\n            \\n# ok we want to include absolute diffs relative to each i = 0..N-1\\n# Q: how to avoid TLE?\\n# can i use prefix sums? <-- use inversion, ie. can we deduce/derive it?\\n\\n# maybe preprocess input from right-to-left and from left-to-right?\\n\\n# let\\'s take a break on this one and come back...\\n\\nclass Solution:\\n    def getDistances(self, A: List[int]) -> List[int]:\\n        m = {}\\n        for i, x in enumerate(A):\\n            if x not in m:\\n                m[x] = []\\n            m[x].append(i)\\n        dist = []\\n        for i in range(len(A)):\\n            t = 0\\n            x = A[i]\\n            index = m[x]\\n            for j in index:\\n                if i != j:\\n                    t += abs(i - j)\\n            dist.append(t)\\n        return dist\\n```\n```\\n/*\\n\\nas i changes, so does the relative distances for each value of x along the way\\n\\nok i think i know what might work...\\n\\nuse a map to store a list of indices i for each value x\\n\\nthen perform prefix sums from left-to-right and from right-to-left for each O(1) lookup relative to each \"pivot\" index\\n\\nKISS == keep it super simple...\\n\\nInput: arr = [2,1,3,1,2,3,3]\\n              0 1 2 3 4 5 6 7\\n                        ^\\n                          R[5] = 6\\n                 L[5] = 2\\nOutput: [4,2,7,2,4,4,5]\\n\\n\\nA = [2,1,3,1,2,3,3]\\n     0 1 2 3 4 5 6 7\\nL =  0 1 2 1 0 2 5\\nR =  4 3 5 3 4 6 6\\n\\nok so we can use L/R and relative index lookups for closest same value to-the-left and to-the-right\\n\\nand use dynamic programming to solve it?\\n\\nlet\\'s use a more simple example\\n\\nN = 3\\n\\nA = 1 1 1\\n    0 1 2 3\\n\\nL = 0 1 2  preL = 0, 1, 3\\nR = 2 1 0  preR = 3, 1, 0\\n                  3, 2, 3\\n\\nthen add them up? <-- well this works ok for a single value x\\n\\nso each value x will need L/R and prefix sums?\\n\\nans = [3, 2, 3]\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using VL = vector<LL>;\\n    using Map = unordered_map<>;\\n    VL getDistances(VI& A, VL ans = {}) {\\n        int N = A.size();\\n        auto L{ A }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656730,
                "title": "simple-prefix-sum-approach-c-explained",
                "content": "Idea :\\n--> Two array ```prefix ``` and ```suffix``` to store each element\\'s PREFIX and SUFFIX sum.\\n--> A map ```steps``` to store each identical element\\'s LAST FOUND INDEX.\\n--> A map ```count``` to store each distinct element\\'s COUNT.\\n\\n--> Initialize ```steps``` as ```steps[arr[i]] = i``` ( although , initially this will store each unique element\\'s last found index , but it will not affect as initially count is 0 ) We will se further in the loop...\\n--> Initilalize ```count``` as ```count[arr[i]] = 0``` ( initial count of every element is 0 )\\n\\n![image](https://assets.leetcode.com/users/images/90d9ffda-c90d-4301-b79b-8a1edaa5cac6_1640875578.003579.jpeg)\\n\\n\\nNOW , THE MAIN PART :\\nFor Prefix Sum ... ( Moving from LEFT ---> RIGHT )\\nprefix sum = previous found prefix sum of that element + current count of that element * abs(current Index of that element - last found index of that element)\\nNote : abs(current Index of that element - last found index of that element) => Steps moved from the last found identical element till current identical element \\n```\\nfor(int i=0;i<n;i++){\\n       // prefix sum = previous found prefix sum of that element + current count of that element * abs(current Index of that element - last found index of that element) \\n        prefix[i] = prefix[steps[arr[i]]] + count[arr[i]]*abs(i-steps[arr[i]]);\\n\\t\\t// then we incremente the count ( as we found one more of that same element )\\n        count[arr[i]]++;\\n\\t\\t// update the last found index of the element ( steps[arr[i]] ) to the current index of that element\\n        steps[arr[i]] = i;\\n\\t\\t}\\n```\\n\\nSimilarly , For Suffix Sum ... ( Moving from RIGHT ---> LEFT )\\n```\\nfor(int i=n-1;i>=0;i--){\\n        suffix[i] = suffix[steps[arr[i]]] + count[arr[i]] * abs(i-steps[arr[i]]);\\n        count[arr[i]]++;\\n        steps[arr[i]] = i;\\n\\t}\\n```\\n\\nFinally , Adding Prefix and Suffix elements...\\n```\\nfor(int i=0;i<n;i++){\\n            answer.push_back(prefix[i] + suffix[i]);\\n        }\\n```\\n\\n**FINAL CODE :**\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<long long> answer;\\n        vector<long long> prefix(n);\\n        vector<long long> suffix(n);\\n        unordered_map<long,long> steps;\\n        unordered_map<long,long> count;\\n        \\n        for(int i=0;i<n;i++){\\n            steps[arr[i]] = i;\\n            count[arr[i]] = 0;\\n        }\\n        for(int i=0;i<n;i++){\\n            prefix[i] = prefix[steps[arr[i]]] + count[arr[i]]*abs(i-steps[arr[i]]);\\n            count[arr[i]]++;\\n            steps[arr[i]] = i;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            steps[arr[i]] = i;\\n            count[arr[i]] = 0;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            suffix[i] = suffix[steps[arr[i]]] + count[arr[i]] * abs(i-steps[arr[i]]);\\n            count[arr[i]]++;\\n            steps[arr[i]] = i;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            answer.push_back(prefix[i] + suffix[i]);\\n        }\\n        return answer;\\n    }\\n};\\n```\\n\\nThank You !",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```prefix ```\n```suffix```\n```steps```\n```count```\n```steps```\n```steps[arr[i]] = i```\n```count```\n```count[arr[i]] = 0```\n```\\nfor(int i=0;i<n;i++){\\n       // prefix sum = previous found prefix sum of that element + current count of that element * abs(current Index of that element - last found index of that element) \\n        prefix[i] = prefix[steps[arr[i]]] + count[arr[i]]*abs(i-steps[arr[i]]);\\n\\t\\t// then we incremente the count ( as we found one more of that same element )\\n        count[arr[i]]++;\\n\\t\\t// update the last found index of the element ( steps[arr[i]] ) to the current index of that element\\n        steps[arr[i]] = i;\\n\\t\\t}\\n```\n```\\nfor(int i=n-1;i>=0;i--){\\n        suffix[i] = suffix[steps[arr[i]]] + count[arr[i]] * abs(i-steps[arr[i]]);\\n        count[arr[i]]++;\\n        steps[arr[i]] = i;\\n\\t}\\n```\n```\\nfor(int i=0;i<n;i++){\\n            answer.push_back(prefix[i] + suffix[i]);\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<long long> answer;\\n        vector<long long> prefix(n);\\n        vector<long long> suffix(n);\\n        unordered_map<long,long> steps;\\n        unordered_map<long,long> count;\\n        \\n        for(int i=0;i<n;i++){\\n            steps[arr[i]] = i;\\n            count[arr[i]] = 0;\\n        }\\n        for(int i=0;i<n;i++){\\n            prefix[i] = prefix[steps[arr[i]]] + count[arr[i]]*abs(i-steps[arr[i]]);\\n            count[arr[i]]++;\\n            steps[arr[i]] = i;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            steps[arr[i]] = i;\\n            count[arr[i]] = 0;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            suffix[i] = suffix[steps[arr[i]]] + count[arr[i]] * abs(i-steps[arr[i]]);\\n            count[arr[i]]++;\\n            steps[arr[i]] = i;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            answer.push_back(prefix[i] + suffix[i]);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647671,
                "title": "javascript-solution-times-out-despite-being-fairly-efficient-solved",
                "content": "I did the same thing as some solutions here that were implemented in Java or C++ where the indexes and diff values have been stored in HashMaps, but I was able to avoid it and yet I still get a Time Limit Exceeded.\\n\\nI avoided:\\n* using `Math.abs`,\\n* additional hash maps that stored the differences, and\\n* additional loop to store the indexes\\n\\nThis fails at the 59 / 61 Test Case.\\n\\nWhat can I do better?\\n\\n```\\nvar getDistances = function(arr) {\\n  const numToIndexes = {};\\n  const output = [];\\n  let num, indexes, diff, j;\\n  for (let i = 0; i < arr.length; i++) {\\n    num = arr[i];\\n    output.push(0);\\n    if (!numToIndexes[num]) {\\n      numToIndexes[num] = [];\\n    }\\n    else {\\n      //look back at already added indexes\\n      indexes = numToIndexes[num];\\n      for (j = 0; j < indexes.length; j++) {\\n        diff = i - indexes[j];\\n\\n        //add diffs to the output at both indexes\\n        output[i] += diff;\\n        output[indexes[j]] += diff;\\n      }\\n    }\\n    numToIndexes[num].push(i);\\n  }\\n  return output;\\n};\\n```\\n\\n### SOLUTION (based on [this Java solution](https://leetcode.com/problems/intervals-between-identical-elements/discuss/1647522/Java-or-TC%3A-O(N)-or-Simple-or-Explanation))\\n__S/T:__ O(n)\\n```\\nvar getDistances = function(arr) {\\n  const len = arr.length;\\n  const numToIndexes = {};\\n  const output = [];\\n\\n  let sumMap = {}, countMap = {};\\n  let i, num, count, sum;\\n  for (i = 0; i < len; i++) {\\n    output.push(0);\\n    num = arr[i];\\n    if (typeof sumMap[num] === \\'undefined\\') {\\n      sumMap[num] = 0;\\n      countMap[num] = 0;\\n    }\\n\\n    sum = sumMap[num];\\n    count = countMap[num];\\n    output[i] += i * count - sum;\\n    sumMap[num] += i;\\n    countMap[num]++;\\n  }\\n\\n  sumMap = {};\\n  countMap = {};\\n  for (i = len - 1; i >= 0; i--) {\\n    num = arr[i];\\n    if (typeof sumMap[num] === \\'undefined\\') {\\n      sumMap[num] = 0;\\n      countMap[num] = 0;\\n    }\\n\\n    sum = sumMap[num];\\n    count = countMap[num];\\n    output[i] += (len - i - 1) * count - sum;\\n    sumMap[num] += (len - i - 1);\\n    countMap[num]++;\\n  }\\n  return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getDistances = function(arr) {\\n  const numToIndexes = {};\\n  const output = [];\\n  let num, indexes, diff, j;\\n  for (let i = 0; i < arr.length; i++) {\\n    num = arr[i];\\n    output.push(0);\\n    if (!numToIndexes[num]) {\\n      numToIndexes[num] = [];\\n    }\\n    else {\\n      //look back at already added indexes\\n      indexes = numToIndexes[num];\\n      for (j = 0; j < indexes.length; j++) {\\n        diff = i - indexes[j];\\n\\n        //add diffs to the output at both indexes\\n        output[i] += diff;\\n        output[indexes[j]] += diff;\\n      }\\n    }\\n    numToIndexes[num].push(i);\\n  }\\n  return output;\\n};\\n```\n```\\nvar getDistances = function(arr) {\\n  const len = arr.length;\\n  const numToIndexes = {};\\n  const output = [];\\n\\n  let sumMap = {}, countMap = {};\\n  let i, num, count, sum;\\n  for (i = 0; i < len; i++) {\\n    output.push(0);\\n    num = arr[i];\\n    if (typeof sumMap[num] === \\'undefined\\') {\\n      sumMap[num] = 0;\\n      countMap[num] = 0;\\n    }\\n\\n    sum = sumMap[num];\\n    count = countMap[num];\\n    output[i] += i * count - sum;\\n    sumMap[num] += i;\\n    countMap[num]++;\\n  }\\n\\n  sumMap = {};\\n  countMap = {};\\n  for (i = len - 1; i >= 0; i--) {\\n    num = arr[i];\\n    if (typeof sumMap[num] === \\'undefined\\') {\\n      sumMap[num] = 0;\\n      countMap[num] = 0;\\n    }\\n\\n    sum = sumMap[num];\\n    count = countMap[num];\\n    output[i] += (len - i - 1) * count - sum;\\n    sumMap[num] += (len - i - 1);\\n    countMap[num]++;\\n  }\\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647516,
                "title": "c-prefix-suffix",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\nconsidering array: [1,3,2,3,2,3,4,5,3]\\n                    index: [0,1,2,3,4,5,6,7,8]\\n            \\nlets focus on element 3:\\n\\n1. Right to Left traversal : \\n\\t\\t\\t\\t\\t\\t\\t idx=8: sub1[8]=0, mp[3]=8, dist[3]=0, count[3]=1\\n                             idx=5: sub1[5]=1 * abs(5-8)+0 = 3, mp[3]=5, dist[3]=3, count[3]=2\\n                             idx=3: sub1[3]=2 * abs(3-5)+3 = 7, mp[3]=3, dist[3]=7, count[3]=3\\n                             idx=1: sub1[1]=3 * abs(1-3)+7 = 13, mp[3]=1, dist[3]=13, count[3]=4 \\n                                 \\n2. Left to Right traversal : \\n\\t\\t\\t\\t\\t\\t\\t idx=1: sub1[1]=0, mp[3]=1, dist[3]=0, count[3]=1  \\n                             idx=3: sub1[3]=1 * abs(3-1)+0 = 2, mp[3]=3, dist[3]=2, count[3]=2\\n                             idx=5: sub1[5]=2 * abs(5-3)+2 = 6, mp[3]=5, dist[3]=6, count[3]=3    \\n                             idx=8: sub1[8]=3 * abs(8-5)+6 = 15, mp[3]=8, dist[3]=15, count[3]=1 \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    vector<long long> getDistances(vector<int>& a) {\\n        int n=a.size();\\n        \\n        vector<long long> sub1(n,0), sub2(n,0);\\n        \\n        map<int,ll int> mp; // to store index of previous occurance of element\\n        map<int,ll int> dist; // summation of abs(i-j) for all occurance of element encounterd previously which can be used to update distance for next element\\n        map<int,ll int> count; // storing frequency of occurance of element\\n        \\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(mp.find(a[i])==mp.end()){\\n                dist[a[i]]=0;\\n                count[a[i]]=0;\\n            }else{\\n                sub1[i]=count[a[i]]*abs(i-mp[a[i]])+dist[a[i]];\\n                dist[a[i]]=sub1[i];\\n            }\\n            mp[a[i]]=i;\\n            count[a[i]]++;\\n        }\\n        \\n        mp.clear(), dist.clear(), count.clear();\\n        for(int i=0;i<n;i++){\\n            if(mp.find(a[i])==mp.end()){\\n                dist[a[i]]=0;\\n                count[a[i]]=0;\\n            }else{\\n                sub2[i]+=count[a[i]]*abs(i-mp[a[i]])+dist[a[i]];\\n                dist[a[i]]=sub2[i];\\n            }\\n            count[a[i]]++;\\n            mp[a[i]]=i;\\n        }\\n        vector<long long> ans(n,0);\\n        for(int i=0;i<n;i++) ans[i]=sub1[i]+sub2[i];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    vector<long long> getDistances(vector<int>& a) {\\n        int n=a.size();\\n        \\n        vector<long long> sub1(n,0), sub2(n,0);\\n        \\n        map<int,ll int> mp; // to store index of previous occurance of element\\n        map<int,ll int> dist; // summation of abs(i-j) for all occurance of element encounterd previously which can be used to update distance for next element\\n        map<int,ll int> count; // storing frequency of occurance of element\\n        \\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(mp.find(a[i])==mp.end()){\\n                dist[a[i]]=0;\\n                count[a[i]]=0;\\n            }else{\\n                sub1[i]=count[a[i]]*abs(i-mp[a[i]])+dist[a[i]];\\n                dist[a[i]]=sub1[i];\\n            }\\n            mp[a[i]]=i;\\n            count[a[i]]++;\\n        }\\n        \\n        mp.clear(), dist.clear(), count.clear();\\n        for(int i=0;i<n;i++){\\n            if(mp.find(a[i])==mp.end()){\\n                dist[a[i]]=0;\\n                count[a[i]]=0;\\n            }else{\\n                sub2[i]+=count[a[i]]*abs(i-mp[a[i]])+dist[a[i]];\\n                dist[a[i]]=sub2[i];\\n            }\\n            count[a[i]]++;\\n            mp[a[i]]=i;\\n        }\\n        vector<long long> ans(n,0);\\n        for(int i=0;i<n;i++) ans[i]=sub1[i]+sub2[i];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647463,
                "title": "java-o-n-two-loop",
                "content": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        long [] out = new long [arr.length];\\n        Map<Integer, long []> preSum = new HashMap<>(); // pre index sum and number of index used\\n        for(int i=0;i<arr.length;i++){\\n            long [] inner = preSum.get(arr[i]);\\n            if(inner == null){\\n                inner = new long[2];\\n                preSum.put(arr[i], inner);\\n            }else {\\n                out[i] = (inner[1] * i) - inner[0]; // number of index multiplied by index value minus sum\\n            }\\n            inner[0] += i;\\n            inner[1]++;\\n        }\\n        Map<Integer, long []> revSum = new HashMap<>(); // pre index sum and number of index used in reverse direction\\n        for(int i=arr.length-1;i>=0;i--){\\n            long [] inner = revSum.get(arr[i]);\\n            if(inner == null){\\n                inner = new long[2];\\n                revSum.put(arr[i], inner);\\n            }else {\\n                out[i] += (inner[0] - (inner[1] * i)); // number of index multiplied by index value minus sum\\n            }\\n            inner[0] += i;\\n            inner[1]++;\\n        }\\n        return out;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long[] getDistances(int[] arr) {\\n        long [] out = new long [arr.length];\\n        Map<Integer, long []> preSum = new HashMap<>(); // pre index sum and number of index used\\n        for(int i=0;i<arr.length;i++){\\n            long [] inner = preSum.get(arr[i]);\\n            if(inner == null){\\n                inner = new long[2];\\n                preSum.put(arr[i], inner);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2845901,
                "title": "2121-intervals-between-identical-elements-approach-pictures",
                "content": "Please go through the pictures below to understand the approach.\\nExample array = [3, 3, 3, 3, 3, 3]\\n\\n![image](https://assets.leetcode.com/users/images/c7f897d4-0895-4cb1-9e04-360e12c88c8d_1669313940.1151843.png)\\n\\n![image](https://assets.leetcode.com/users/images/ff59a9c0-63a7-4da4-82f1-a5e0fcf7a29b_1669313992.4758763.png)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "Please go through the pictures below to understand the approach.\\nExample array = [3, 3, 3, 3, 3, 3]\\n\\n![image](https://assets.leetcode.com/users/images/c7f897d4-0895-4cb1-9e04-360e12c88c8d_1669313940.1151843.png)\\n\\n![image](https://assets.leetcode.com/users/images/ff59a9c0-63a7-4da4-82f1-a5e0fcf7a29b_1669313992.4758763.png)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2490726,
                "title": "o-n",
                "content": "# define ll long long int\\n vector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<ll,vector<ll>>mp;\\n        vector<long long>ans(n,0);\\n        for (int i = 0; i < n; i++)\\n        {\\n           mp[arr[i]].push_back(i);\\n        }\\n        auto it=mp.begin();\\n        while (it!=mp.end())\\n        {\\n            int sz=it->second.size();\\n            vector<ll>temp(sz,0);\\n            for (int i = 1; i < sz; i++)\\n            {\\n                temp[i]+=temp[i-1]+(i*(it->second[i]-it->second[i-1]));\\n            }\\n            vector<ll>temp2(sz,0);\\n            int k=1;\\n            for (int i = sz-2; i >=0; i--)\\n            {\\n                temp2[i]+=temp2[i+1]+(k*(it->second[i+1]-it->second[i]));\\n                k++;\\n            }\\n            for (int i = 0; i < sz; i++)\\n            {\\n                ans[it->second[i]]=temp[i]+temp2[i];\\n            }\\n            it++;\\n\\n            \\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "# define ll long long int\\n vector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<ll,vector<ll>>mp;\\n        vector<long long>ans(n,0);\\n        for (int i = 0; i < n; i++)\\n        {\\n           mp[arr[i]].push_back(i);\\n        }\\n        auto it=mp.begin();\\n        while (it!=mp.end())\\n        {\\n            int sz=it->second.size();\\n            vector<ll>temp(sz,0);\\n            for (int i = 1; i < sz; i++)\\n            {\\n                temp[i]+=temp[i-1]+(i*(it->second[i]-it->second[i-1]));\\n            }\\n            vector<ll>temp2(sz,0);\\n            int k=1;\\n            for (int i = sz-2; i >=0; i--)\\n            {\\n                temp2[i]+=temp2[i+1]+(k*(it->second[i+1]-it->second[i]));\\n                k++;\\n            }\\n            for (int i = 0; i < sz; i++)\\n            {\\n                ans[it->second[i]]=temp[i]+temp2[i];\\n            }\\n            it++;\\n\\n            \\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2160924,
                "title": "c-o-n-prefix-sum",
                "content": "```\\nvector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int> ind(100001,-1);\\n        vector<int> count(100001,0);\\n        vector<long long> ans(n);\\n        for(int i=0;i<n;i++){\\n            int ele=arr[i];\\n            if(ind[ele]!=-1){\\n                ans[i]+=ans[ind[ele]];\\n                int prev=ind[ele];\\n                ans[i]+=count[ele]*(i-prev);\\n            }\\n            ind[ele]=i;\\n            count[ele]++;\\n        }\\n        fill(ind.begin(), ind.end(), -1);\\n        fill(count.begin(), count.end(), 0);\\n        vector<long long> rev(n,0);\\n        for(int i=n-1; i>=0; i--){\\n            int elem = arr[i];\\n            if(ind[elem] != -1){\\n                rev[i] += rev[ind[elem]];\\n                int prev = ind[elem];\\n                rev[i] += count[elem] * (prev-i);\\n            }\\n            ind[elem] = i;\\n            count[elem]++;\\n            ans[i] += rev[i];\\n        }\\n        return ans;\\n        \\n    }```",
                "solutionTags": [
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int> ind(100001,-1);\\n        vector<int> count(100001,0);\\n        vector<long long> ans(n);\\n        for(int i=0;i<n;i++){\\n            int ele=arr[i];\\n            if(ind[ele]!=-1){\\n                ans[i]+=ans[ind[ele]];\\n                int prev=ind[ele];\\n                ans[i]+=count[ele]*(i-prev);\\n            }\\n            ind[ele]=i;\\n            count[ele]++;\\n        }\\n        fill(ind.begin(), ind.end(), -1);\\n        fill(count.begin(), count.end(), 0);\\n        vector<long long> rev(n,0);\\n        for(int i=n-1; i>=0; i--){\\n            int elem = arr[i];\\n            if(ind[elem] != -1){\\n                rev[i] += rev[ind[elem]];\\n                int prev = ind[elem];\\n                rev[i] += count[elem] * (prev-i);\\n            }\\n            ind[elem] = i;\\n            count[elem]++;\\n            ans[i] += rev[i];\\n        }\\n        return ans;\\n        \\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 2117539,
                "title": "c-easy-to-understand-simple-map-prefixsum-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    vector<long long> getDistances(vector<int>& arr) {\\n     unordered_map<ll,vector<ll>> mp;\\n        ll n=arr.size();\\n        for(ll i=0;i<n;i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<ll> ans(n);\\n        for(auto pr:mp)\\n        {\\n            vector<ll> v=pr.second;\\n            ll total=accumulate(v.begin(),v.end(),(ll)0);\\n            ll pre=0;\\n            ll n2=v.size();\\n            ll res=0;\\n            for(ll i=0;i<n2;i++)\\n            {\\n                res=i*v[i]-pre+(total-pre-v[i])-(n2-i-1)*v[i];\\n                pre+=v[i];\\n                ans[v[i]]=res;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    vector<long long> getDistances(vector<int>& arr) {\\n     unordered_map<ll,vector<ll>> mp;\\n        ll n=arr.size();\\n        for(ll i=0;i<n;i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<ll> ans(n);\\n        for(auto pr:mp)\\n        {\\n            vector<ll> v=pr.second;\\n            ll total=accumulate(v.begin(),v.end(),(ll)0);\\n            ll pre=0;\\n            ll n2=v.size();\\n            ll res=0;\\n            for(ll i=0;i<n2;i++)\\n            {\\n                res=i*v[i]-pre+(total-pre-v[i])-(n2-i-1)*v[i];\\n                pre+=v[i];\\n                ans[v[i]]=res;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893484,
                "title": "java-2-hashmaps",
                "content": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        long[] ans = new long[arr.length];\\n        \\n        Map<Integer, List<Integer>> maps = new HashMap<>();\\n        Map<Integer, long[]> front = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            maps.computeIfAbsent(arr[i], v -> new ArrayList<>()).add(i);\\n            if(front.containsKey(arr[i])){\\n                long[] p = front.get(arr[i]);\\n                p[1] += (i - p[0]);\\n                front.put(arr[i], p);\\n            }\\n            else front.put(arr[i], new long[]{i, 0});\\n        }\\n        \\n        for(int key : maps.keySet()){\\n           List<Integer> list = maps.get(key);    \\n           long[] p = front.get(key); \\n           ans[(int)(p[0])] = p[1];\\n           long sum = 0l;\\n           for(int i = 1; i < list.size(); i++){\\n               p[1] = p[1] - ((list.size() - i - 1) * (list.get(i) - list.get(i - 1)))\\n                    + ((i - 1) * (list.get(i) - list.get(i - 1)));\\n               ans[list.get(i)] = p[1];\\n           }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        long[] ans = new long[arr.length];\\n        \\n        Map<Integer, List<Integer>> maps = new HashMap<>();\\n        Map<Integer, long[]> front = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            maps.computeIfAbsent(arr[i], v -> new ArrayList<>()).add(i);\\n            if(front.containsKey(arr[i])){\\n                long[] p = front.get(arr[i]);\\n                p[1] += (i - p[0]);\\n                front.put(arr[i], p);\\n            }\\n            else front.put(arr[i], new long[]{i, 0});\\n        }\\n        \\n        for(int key : maps.keySet()){\\n           List<Integer> list = maps.get(key);    \\n           long[] p = front.get(key); \\n           ans[(int)(p[0])] = p[1];\\n           long sum = 0l;\\n           for(int i = 1; i < list.size(); i++){\\n               p[1] = p[1] - ((list.size() - i - 1) * (list.get(i) - list.get(i - 1)))\\n                    + ((i - 1) * (list.get(i) - list.get(i - 1)));\\n               ans[list.get(i)] = p[1];\\n           }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715426,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        vector<long long> res(arr.size());\\n        auto doit = [&] (int start_, int step_, int end_) {\\n            unordered_map<int, long long> cnts, prev_idx, prev_sum;        \\n            for (int i = start_; i != end_; i += step_) {\\n                long long sum =  prev_sum[arr[i]] + cnts[arr[i]] * abs(i - prev_idx[arr[i]]);\\n                res[i] += sum;\\n                prev_sum[arr[i]] = sum;\\n                cnts[arr[i]]++;\\n                prev_idx[arr[i]] = i;\\n            }\\n        };\\n        doit(0, 1, arr.size());\\n        doit(arr.size() - 1, -1, -1);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        vector<long long> res(arr.size());\\n        auto doit = [&] (int start_, int step_, int end_) {\\n            unordered_map<int, long long> cnts, prev_idx, prev_sum;        \\n            for (int i = start_; i != end_; i += step_) {\\n                long long sum =  prev_sum[arr[i]] + cnts[arr[i]] * abs(i - prev_idx[arr[i]]);\\n                res[i] += sum;\\n                prev_sum[arr[i]] = sum;\\n                cnts[arr[i]]++;\\n                prev_idx[arr[i]] = i;\\n            }\\n        };\\n        doit(0, 1, arr.size());\\n        doit(arr.size() - 1, -1, -1);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674395,
                "title": "c-simple-solution-o-n-with-explanation-hashmap",
                "content": "**For each index** **find** the **sum of intervals before it** and then **sum of intervals after it**.\\nFor **0 to ith index** = **count of same element before the current element * current index - sum of indexes**\\nfor **ith to n-1th index** = **sum of indexes - count of same element before the current element * current index**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        int n(arr.size());\\n        vector <long long> res(n, 0);\\n        unordered_map <int, pair<int, long long>> left, right;\\n        \\n        for (int i=0; i<n; i++)\\n        {\\n            // 0 to i count*i-sum\\n            long long sum(left[arr[i]].second), count(left[arr[i]].first++);\\n            res[i] = count*i-sum;\\n            left[arr[i]].second += i;\\n        }\\n        \\n        for (int i=n-1; ~i; i--)\\n        {\\n            // i to n-1 sum-count*i\\n            long long sum(right[arr[i]].second), count(right[arr[i]].first++);\\n            res[i] += sum-(i*count);\\n            right[arr[i]].second += i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        int n(arr.size());\\n        vector <long long> res(n, 0);\\n        unordered_map <int, pair<int, long long>> left, right;\\n        \\n        for (int i=0; i<n; i++)\\n        {\\n            // 0 to i count*i-sum\\n            long long sum(left[arr[i]].second), count(left[arr[i]].first++);\\n            res[i] = count*i-sum;\\n            left[arr[i]].second += i;\\n        }\\n        \\n        for (int i=n-1; ~i; i--)\\n        {\\n            // i to n-1 sum-count*i\\n            long long sum(right[arr[i]].second), count(right[arr[i]].first++);\\n            res[i] += sum-(i*count);\\n            right[arr[i]].second += i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652874,
                "title": "c-frequency-map-prefix-suffix-sums",
                "content": "Let us say we have same element at indices a,b,c,T,x,y,z and we want to calculate the value for index T.\\n\\nHere,  a,b,c<T so | T-a | = T - a, likewise for b and c.\\nHere, x,y,z>T so | T - x | = x - T, likewise for y and z. \\n1. Prefix modded sum = |T-a| + |T-b| + |T-c| = T-a + T-b + T-c = 3T - (a+b+c) \\n2. Suffix modded sum = | T - x | + | T-y | + | T - z | = x - T + y - T + z - T = (x+y+z) - 3*T\\n\\nNote, the multiple for T is decided based on how many indices come before or after it.\\n\\n**Total value for index T = Prefix modded sum + Suffix modded sum**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        unordered_map<int,long long>sumBack , sumFront;\\n        unordered_map<int,long long>occurBack , occurFront;\\n        vector<long long>ans;\\n        int n = arr.size();\\n        \\n        //store the suffix sums and the suffix occurences\\n        for (int i = n-1 ; i>=0 ; i--){\\n            sumBack[arr[i]]+=i;\\n            occurBack[arr[i]]++;\\n        }\\n        \\n        for (int i = 0 ; i < n ; i++){\\n            int elem = arr[i];\\n            //increment prefix sum and prefix occurence\\n            occurFront[elem]++;\\n            sumFront[elem]+=i;\\n            \\n            //decrement suffix sum and suffix occurence\\n            occurBack[elem]--;\\n            sumBack[elem]-=i;\\n            \\n            long long modSumFront = i * occurFront[elem] - sumFront[elem];\\n            long long modSumBack = sumBack[elem] - i * occurBack[elem];\\n            long long totModSum = modSumFront + modSumBack;\\n            ans.push_back(totModSum);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        unordered_map<int,long long>sumBack , sumFront;\\n        unordered_map<int,long long>occurBack , occurFront;\\n        vector<long long>ans;\\n        int n = arr.size();\\n        \\n        //store the suffix sums and the suffix occurences\\n        for (int i = n-1 ; i>=0 ; i--){\\n            sumBack[arr[i]]+=i;\\n            occurBack[arr[i]]++;\\n        }\\n        \\n        for (int i = 0 ; i < n ; i++){\\n            int elem = arr[i];\\n            //increment prefix sum and prefix occurence\\n            occurFront[elem]++;\\n            sumFront[elem]+=i;\\n            \\n            //decrement suffix sum and suffix occurence\\n            occurBack[elem]--;\\n            sumBack[elem]-=i;\\n            \\n            long long modSumFront = i * occurFront[elem] - sumFront[elem];\\n            long long modSumBack = sumBack[elem] - i * occurBack[elem];\\n            long long totModSum = modSumFront + modSumBack;\\n            ans.push_back(totModSum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651134,
                "title": "python3-single-loop-hash-easy-to-understand-with-explanation",
                "content": "The idea is simple. For example, let\\'s focus on \\'3\\' first in the array [x,x,3,x,3,x,x,3] where x means some numbers, then we calculate intervals to the left elements first, we get \\n**left = [x,x,0,x,2,x,x,8]**\\nthen, we calculate intervals to the right elements\\n**right = [x,x,7,x,3,x,x,0]**\\nThen we get answer\\n**ans = left + right = [x,x,7,x,5,x,x,8]**\\n\\nHow do we get arrays left and right?\\nLet\\'s say we are at the last \\'3\\' in the array left[7]. We have seen \\'3\\' **twice**, and last \\'3\\' is at index 4. Then we have\\nleft[7] = left[4] + **2** * (7 - 4) = 8, where 2 comes from the number of \\'3\\' we have seen so far.\\nMore formally,\\n**left[j] = left[i] + N * (j - i)**, where N is the number of arr[j] we have seen so far.\\nThe information of N, i, and left[i] is saved in the prev dictionary in the below code.\\n\\'right\\' array can be derived similarly by reversing the array.\\n```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        \\n        def cal(arr):\\n            ans = [0]*len(arr)\\n            prev = {}  # num to (prev index, number of num, total)\\n            for i, num in enumerate(arr):\\n                if num not in prev:\\n                    prev[num] = (i, 1, 0)\\n                else:\\n                    ans[i] += prev[num][2] + prev[num][1]*(i - prev[num][0])\\n                    prev[num] = (i, prev[num][1]+1, ans[i])\\n            return ans\\n        \\n        #print(cal(arr))\\n        return [i + j for i, j in zip(cal(arr), cal(arr[::-1])[::-1])]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        \\n        def cal(arr):\\n            ans = [0]*len(arr)\\n            prev = {}",
                "codeTag": "Java"
            },
            {
                "id": 1649079,
                "title": "c-maps-no-map-of-vector-explanation-prefix-and-suffix-sums-o-n",
                "content": "My approach to this problem is quite simple.\\nLet us assume :\\n*  `prefix[i]` - be the sum of interval distances of all elements from `[0, i - 1]` whose value equals `arr[i]`\\n*  `suffix[i]` - be the sum of interval distances of all elements from `[i + 1, n - 1]` whose value equals `arr[i]`\\n*  `cntLeft` - be a map which stores the count of `arr[i]` from `[0, i - 1]`\\n*  `cntRight` - be a map which stores the count of `arr[i]` from `[i + 1, n - 1]`\\n*  `prevIdx` - be a map which stores the index of previous occurrence of `arr[i]`\\n*  `nextIdx` - be a map which stores the index of next occurrenct of `arr[i]`\\n\\nFor example, let us take the array as **`arr` =  `[1, 2, 3, 1, 2, 3, 1, 3, 2, 1, 2, 3]`**\\nThe corresponding prefix array is **`prefix` = `[0, 0, 0, 3, 3, 3, 9, 7, 11, 18, 17, 19]`**\\nThe corresponding suffix array is **`suffix` = `[18, 19, 17, 9, 10, 8, 3, 4, 2, 0, 0, 0]`**\\nThe corresponding answer array is **`ans`  = `[18, 19, 17, 12, 13, 11, 12, 11, 13, 18, 17, 19]`**\\n\\nNow let us analyze the `prefix` array for the last occurrence of `3` and `suffix` array for the first occurrence of `3`\\n* `prefix[11]` = `|11 - 7|` + `|11 - 5|` + `|11 - 2|`\\n* `prefix[11]` = `4` + `6` + `9` \\n* `prefix[11]` = `4 + (4 + 2) + (4 + 5)`\\n* `prefix[11]` = `(4 + 4 + 4)` + `(2 + 5)`\\n* `prefix[11]` = `3 * 4` + `7`\\n* `prefix[11]` = `cntLeft[arr[11]] * (11 - 7)` + `prefix[7]`\\n* `prefix[11]` = `cntLeft[arr[11]] * (11 - prevIdx[arr[11]])` + `prefix[prevIdx[arr[11]]`\\n\\nSimilarly, we can calculate `suffix` of first occurrence of `3` as:\\n* `suffix[2]` = `suffix[nextIdx[arr[2]]]` + `(nextIdx[arr[2]] - 2) * cntRight[arr[2]]`\\n\\n\\nTherfore, we can calculate `prefix[i]` and `suffix[i]` as:\\n* **`prefix[i]` = `prefix[prevIdx[arr[i]]]` + `(i - prevIdx[arr[i]]) * cntLeft[arr[i]]`**\\n* **`suffix[i]` = `suffix[nextIdx[arr[i]]]` + `(nextIdx[arr[i]] - i) * cntRight[arr[i]]`**\\n\\nFinally in order to calculate the answer array, we can simply add the `prefix` and `suffix` arrays.\\n* Time complexity - `O(N)`\\n* Space complexity - `O(N)`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        using ll = long long;\\n    \\n        int n = arr.size();\\n        \\n        unordered_map<ll, int> cntLeft;\\n        unordered_map<ll, int> prevIdx;\\n        vector<ll> prefix(n);\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(prevIdx.find(arr[i]) != prevIdx.end()) {\\n                prefix[i] = prefix[prevIdx[arr[i]]] + (i - prevIdx[arr[i]]) * cntLeft[arr[i]];\\n            }\\n            cntLeft[arr[i]]++;\\n            prevIdx[arr[i]] = i;\\n        }\\n        \\n        unordered_map<ll, int> cntRight;\\n        unordered_map<ll, int> nextIdx;\\n        vector<ll> suffix(n);\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            if(nextIdx.find(arr[i]) != nextIdx.end()) {\\n                suffix[i] = suffix[nextIdx[arr[i]]] + (nextIdx[arr[i]] - i) * cntRight[arr[i]];\\n            }\\n            cntRight[arr[i]]++;\\n            nextIdx[arr[i]] = i;\\n        }\\n        \\n        vector<ll> ans(n);\\n        for(int i = 0; i < n; i++) {\\n            ans[i] = prefix[i] + suffix[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        using ll = long long;\\n    \\n        int n = arr.size();\\n        \\n        unordered_map<ll, int> cntLeft;\\n        unordered_map<ll, int> prevIdx;\\n        vector<ll> prefix(n);\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(prevIdx.find(arr[i]) != prevIdx.end()) {\\n                prefix[i] = prefix[prevIdx[arr[i]]] + (i - prevIdx[arr[i]]) * cntLeft[arr[i]];\\n            }\\n            cntLeft[arr[i]]++;\\n            prevIdx[arr[i]] = i;\\n        }\\n        \\n        unordered_map<ll, int> cntRight;\\n        unordered_map<ll, int> nextIdx;\\n        vector<ll> suffix(n);\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            if(nextIdx.find(arr[i]) != nextIdx.end()) {\\n                suffix[i] = suffix[nextIdx[arr[i]]] + (nextIdx[arr[i]] - i) * cntRight[arr[i]];\\n            }\\n            cntRight[arr[i]]++;\\n            nextIdx[arr[i]] = i;\\n        }\\n        \\n        vector<ll> ans(n);\\n        for(int i = 0; i < n; i++) {\\n            ans[i] = prefix[i] + suffix[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648198,
                "title": "c-prefix-suffix",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n\\t//this vector will help us in storing all the arr[i] no in one place\\n        vector<vector<long long> > help(100001);\\n        int n=arr.size();\\n        for(int i=0;i<arr.size();i++){\\n            help[arr[i]].push_back(i);\\n        }\\n\\t\\t//we will calculate prefix of each no using fromula prefix[i]=prefix[i]-prefix[i-1]+(difference in there index)*(i times beacause we have too add difference in each element which come first)\\n        vector<vector<long long> > prefix(100001);\\n        \\n        for(int i=0;i<100001;i++){\\n            int size=help[i].size();\\n            \\n            if(size==0)continue;\\n            prefix[i].resize(size);\\n            prefix[i][0]=0;\\n            for(int j=1;j<size;j++){\\n                long long next_prefix=prefix[i][j-1]+abs(help[i][j-1]-help[i][j])*j;\\n                prefix[i][j]=next_prefix;\\n                }\\n            }\\n        \\n        vector<vector<long long> > suffix(100001);\\n        for(int i=0;i<100001;i++){\\n            int size=help[i].size();\\n            if(size==0)continue;\\n            suffix[i].resize(size);\\n            suffix[i][size-1]=0;\\n            for(int j=size-2;j>=0;j--){\\n                long long next_suffix=suffix[i][j+1]+abs(help[i][j+1]-help[i][j])*(size-1-j);\\n                suffix[i][j]=next_suffix;\\n                }\\n            }\\n        \\n        vector<long long>  ans(n);\\n        for(int i=0;i<n;i++){\\n            int no=arr[i];\\n            int l=0,r=help[arr[i]].size()-1,index;\\n            \\n            while(l<=r){\\n                int mid=(l+r)/2;\\n                if(help[arr[i]][mid]==i){\\n                    index=mid;\\n                    break;\\n                }\\n                if(help[arr[i]][mid]>i){\\n                    r=mid-1;\\n                }else{\\n                    l=mid+1;\\n                }\\n            }\\n            ans[i]=prefix[arr[i]][index]+suffix[arr[i]][index];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n\\t//this vector will help us in storing all the arr[i] no in one place\\n        vector<vector<long long> > help(100001);\\n        int n=arr.size();\\n        for(int i=0;i<arr.size();i++){\\n            help[arr[i]].push_back(i);\\n        }\\n\\t\\t//we will calculate prefix of each no using fromula prefix[i]=prefix[i]-prefix[i-1]+(difference in there index)*(i times beacause we have too add difference in each element which come first)\\n        vector<vector<long long> > prefix(100001);\\n        \\n        for(int i=0;i<100001;i++){\\n            int size=help[i].size();\\n            \\n            if(size==0)continue;\\n            prefix[i].resize(size);\\n            prefix[i][0]=0;\\n            for(int j=1;j<size;j++){\\n                long long next_prefix=prefix[i][j-1]+abs(help[i][j-1]-help[i][j])*j;\\n                prefix[i][j]=next_prefix;\\n                }\\n            }\\n        \\n        vector<vector<long long> > suffix(100001);\\n        for(int i=0;i<100001;i++){\\n            int size=help[i].size();\\n            if(size==0)continue;\\n            suffix[i].resize(size);\\n            suffix[i][size-1]=0;\\n            for(int j=size-2;j>=0;j--){\\n                long long next_suffix=suffix[i][j+1]+abs(help[i][j+1]-help[i][j])*(size-1-j);\\n                suffix[i][j]=next_suffix;\\n                }\\n            }\\n        \\n        vector<long long>  ans(n);\\n        for(int i=0;i<n;i++){\\n            int no=arr[i];\\n            int l=0,r=help[arr[i]].size()-1,index;\\n            \\n            while(l<=r){\\n                int mid=(l+r)/2;\\n                if(help[arr[i]][mid]==i){\\n                    index=mid;\\n                    break;\\n                }\\n                if(help[arr[i]][mid]>i){\\n                    r=mid-1;\\n                }else{\\n                    l=mid+1;\\n                }\\n            }\\n            ans[i]=prefix[arr[i]][index]+suffix[arr[i]][index];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647976,
                "title": "c-map-of-vectors",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int \\n    vector<long long> getDistances(vector<int>& a) {\\n        int n  = a.size() ;\\n        map<ll,vector<ll>>mp ;  \\n        \\n        for(int i = 0 ; i < n ;i++)\\n        {\\n            mp[a[i]].push_back(i); \\n        }\\n        vector<ll>ans(n,-1) ; \\n        for(int i = 0 ; i < n ;i++)\\n        {\\n            if(ans[i]!=-1)continue ; \\n            vector<ll>t = mp[a[i]];\\n          \\n            vector<ll>pre(t.size() , 0) ; \\n            pre[0] = t[0];\\n            for(int j=1;j<t.size();j++)\\n            {\\n                pre[j] = pre[j-1]+t[j];\\n            }\\n          \\n            // fill ans ; \\n            int k = -1 ; int m = pre.size()-1;\\n            for(int j = 0  ; j <=m;j++)\\n            {\\n                ll p = pre[m] - pre[j] ; \\n                p = p - (m-j)*t[j];\\n                if(k >= 0){\\n                p+=(t[j]*j - pre[k]);\\n                    }\\n                ans[t[j]] = p ; \\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    #define ll long long int \\n    vector<long long> getDistances(vector<int>& a) {\\n        int n  = a.size() ;\\n        map<ll,vector<ll>>mp ;  \\n        \\n        for(int i = 0 ; i < n ;i++)\\n        {\\n            mp[a[i]].push_back(i); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1647706,
                "title": "c-prefix-and-suffix-sums-clean-and-concise",
                "content": "**Process :**\\n*   First Find the indices of each of the unique elements and store them in map.\\n*   Then find the prefix sum corresponding to current element.\\n*   Then find the suffix sum corresponding to current element.\\n*   Then Add both sums and get the answer.\\n\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        map<ll,vector<ll>>ma;\\n        vector<ll>pfx(n),sfx(n);\\n\\t\\tint i;\\n        for(i=0;i<n;i++)\\n            ma[arr[i]].push_back(i);\\n        \\n        for(auto it:ma)\\n        {\\n            auto val=it.second;\\n            for(i=1;i<val.size();i++)\\n            { \\n               pfx[val[i]]=pfx[val[i-1]]+i*(val[i]-val[i-1]); \\n            } \\n        }\\n\\t\\t\\n\\t   for(auto it:ma)\\n        {\\n            auto val=it.second;\\n            int nn=val.size();\\n            for(i=val.size()-2;i>=0;i--)\\n            {\\n                sfx[val[i]]=sfx[val[i+1]]+(nn-i-1)*(val[i+1]-val[i]);\\n            }\\n        }\\n//         for(i=0;i<n;i++)\\n//             cout<<pfx[i]<<\" \";\\n//         cout<<endl;\\n//         for(i=0;i<n;i++)\\n//             cout<<sfx[i]<<\" \";\\n        \\n//         cout<<endl;\\n        vector<ll>ans;\\n        for(i=0;i<n;i++)\\n        {\\n            ans.push_back(pfx[i]+sfx[i]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n**Pls upvote if you found helpful.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        map<ll,vector<ll>>ma;\\n        vector<ll>pfx(n),sfx(n);\\n\\t\\tint i;\\n        for(i=0;i<n;i++)\\n            ma[arr[i]].push_back(i);\\n        \\n        for(auto it:ma)\\n        {\\n            auto val=it.second;\\n            for(i=1;i<val.size();i++)\\n            { \\n               pfx[val[i]]=pfx[val[i-1]]+i*(val[i]-val[i-1]); \\n            } \\n        }\\n\\t\\t\\n\\t   for(auto it:ma)\\n        {\\n            auto val=it.second;\\n            int nn=val.size();\\n            for(i=val.size()-2;i>=0;i--)\\n            {\\n                sfx[val[i]]=sfx[val[i+1]]+(nn-i-1)*(val[i+1]-val[i]);\\n            }\\n        }\\n//         for(i=0;i<n;i++)\\n//             cout<<pfx[i]<<\" \";\\n//         cout<<endl;\\n//         for(i=0;i<n;i++)\\n//             cout<<sfx[i]<<\" \";\\n        \\n//         cout<<endl;\\n        vector<ll>ans;\\n        for(i=0;i<n;i++)\\n        {\\n            ans.push_back(pfx[i]+sfx[i]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1647638,
                "title": "c-solution",
                "content": "```\\n\\nres[i] = (nums[i] - nums[0]) + (nums[i] - nums[1]) + ... + (nums[i] - nums[i - 1])   absolute difference of nums[i] with first i numbers\\n     + (nums[i] - nums[i]) + (nums[i + 1] - nums[i]) + (nums[i + 2] - nums[i]) + ... + (nums[n - 1] - nums[i])   absolute difference of nums[i] with last n - i numbers\\n```\\n```\\nres[i] = i * nums[i] - (nums[0] + ... + nums[i - 1])    absolute difference of nums[i] with first i numbers\\n     + (nums[i + 1] + ... + nums[n]) - (n - i) * nums[i]    absolute difference of nums[i] with last n - i numbers\\n```\\n```\\nres[i] = i * nums[i] - prefixSum[i]\\nprefixSum[n] - prefixSum[i] - (n - i) * nums[i]\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<long long> find(vector<long long>nums)\\n    {\\n        int n = nums.size();\\n        vector<long long>res(n,0);\\n        vector<long long>prefix(n+1,0);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            prefix[i + 1] = prefix[i] + nums[i];\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            res[i] = i * nums[i] - prefix[i] + (prefix[n] -  prefix[i] - (n - i) * nums[i]);\\n        }\\n        return res;\\n        \\n        \\n        \\n        \\n        // O(1)\\n        // long long n=nums.size();\\n        // long long right,left;\\n        // right=left=0;\\n        // long long ans=0;\\n        // vector<long long>v(n,0);\\n        // right=accumulate(nums.begin(),nums.end(),0ll);\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     right=right-nums[i];\\n        //     long long left_sum=i*nums[i]-left;\\n        //     long long right_sum=right-(n-i-1)*nums[i];\\n        //     v[i]=left_sum+right_sum;\\n        //     left+=nums[i];\\n        // }\\n        // return v;\\n    }\\n    vector<long long> getDistances(vector<int>& arr) \\n    {\\n        unordered_map<long long,vector<long long>>mp;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<long long>ans(arr.size(),0);\\n        for(auto &it:mp)\\n        {\\n            vector<long long>v=find(it.second);\\n            vector<long long>index=it.second;\\n            for(int i=0;i<index.size();i++)\\n            {\\n                ans[index[i]]=v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nres[i] = (nums[i] - nums[0]) + (nums[i] - nums[1]) + ... + (nums[i] - nums[i - 1])   absolute difference of nums[i] with first i numbers\\n     + (nums[i] - nums[i]) + (nums[i + 1] - nums[i]) + (nums[i + 2] - nums[i]) + ... + (nums[n - 1] - nums[i])   absolute difference of nums[i] with last n - i numbers\\n```\n```\\nres[i] = i * nums[i] - (nums[0] + ... + nums[i - 1])    absolute difference of nums[i] with first i numbers\\n     + (nums[i + 1] + ... + nums[n]) - (n - i) * nums[i]    absolute difference of nums[i] with last n - i numbers\\n```\n```\\nres[i] = i * nums[i] - prefixSum[i]\\nprefixSum[n] - prefixSum[i] - (n - i) * nums[i]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<long long> find(vector<long long>nums)\\n    {\\n        int n = nums.size();\\n        vector<long long>res(n,0);\\n        vector<long long>prefix(n+1,0);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            prefix[i + 1] = prefix[i] + nums[i];\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            res[i] = i * nums[i] - prefix[i] + (prefix[n] -  prefix[i] - (n - i) * nums[i]);\\n        }\\n        return res;\\n        \\n        \\n        \\n        \\n        // O(1)\\n        // long long n=nums.size();\\n        // long long right,left;\\n        // right=left=0;\\n        // long long ans=0;\\n        // vector<long long>v(n,0);\\n        // right=accumulate(nums.begin(),nums.end(),0ll);\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     right=right-nums[i];\\n        //     long long left_sum=i*nums[i]-left;\\n        //     long long right_sum=right-(n-i-1)*nums[i];\\n        //     v[i]=left_sum+right_sum;\\n        //     left+=nums[i];\\n        // }\\n        // return v;\\n    }\\n    vector<long long> getDistances(vector<int>& arr) \\n    {\\n        unordered_map<long long,vector<long long>>mp;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<long long>ans(arr.size(),0);\\n        for(auto &it:mp)\\n        {\\n            vector<long long>v=find(it.second);\\n            vector<long long>index=it.second;\\n            for(int i=0;i<index.size();i++)\\n            {\\n                ans[index[i]]=v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647539,
                "title": "o-n-hash-and-sliding-index-beats-90-c-clean-code",
                "content": "The idea is store all indices for same num, and calculate the sidng index difference.\\nFor example, in a same value indices group, if we know the result of ith position, the i+1 th position can be calculated by:\\nfrom 0 , i - 1 their distance increased by id[i+1] -  id[i]\\nfor id[i+1] -  id[i] no changed\\nfrom i + 1  to the end their distance decreased by id[i+1] -  id[i]\\nSo we can say **(prev_count - post_count) * abs(id[i+1] -  id[i]) is the siding index difference**. \\nThe time and space complexity is O(N)\\n\\n\\tvector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int,vector<int>> num_ids;\\n        for(int i = 0; i < n; i++){\\n            num_ids[arr[i]].push_back(i);\\n        }\\n        vector<long long> ans(n,0);\\n        for(auto [num, ids] : num_ids){\\n            int ids_size = ids.size();\\n            if(ids_size == 1) continue;\\n            for(int i = 0; i < ids_size; i++){\\n                if( i == 0){\\n                    for(int j = i + 1; j < ids_size; j++) ans[ids[i]] += abs(ids[j] - ids[i]);\\n                }\\n                else{\\n                    int prev = i - 1;\\n                    int post = ids_size - i - 1;\\n                    ans[ids[i]] = ans[ids[i-1]] + (prev - post) * (ids[i] - ids[i-1]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "The idea is store all indices for same num, and calculate the sidng index difference.\\nFor example, in a same value indices group, if we know the result of ith position, the i+1 th position can be calculated by:\\nfrom 0 , i - 1 their distance increased by id[i+1] -  id[i]\\nfor id[i+1] -  id[i] no changed\\nfrom i + 1  to the end their distance decreased by id[i+1] -  id[i]\\nSo we can say **(prev_count - post_count) * abs(id[i+1] -  id[i]) is the siding index difference**. \\nThe time and space complexity is O(N)\\n\\n\\tvector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int,vector<int>> num_ids;\\n        for(int i = 0; i < n; i++){\\n            num_ids[arr[i]].push_back(i);\\n        }\\n        vector<long long> ans(n,0);\\n        for(auto [num, ids] : num_ids){\\n            int ids_size = ids.size();\\n            if(ids_size == 1) continue;\\n            for(int i = 0; i < ids_size; i++){\\n                if( i == 0){\\n                    for(int j = i + 1; j < ids_size; j++) ans[ids[i]] += abs(ids[j] - ids[i]);\\n                }\\n                else{\\n                    int prev = i - 1;\\n                    int post = ids_size - i - 1;\\n                    ans[ids[i]] = ans[ids[i-1]] + (prev - post) * (ids[i] - ids[i-1]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1647514,
                "title": "c-soln-using-map-easy-absolute-sum-find",
                "content": "```\\n\\tvector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<long long, vector<long long>> um;\\n        vector<long long> res;\\n        for(long long i=0; i<arr.size(); i++) {\\n            um[arr[i]].push_back(i);\\n        }\\n        unordered_map<long long, long long> um1, um2;\\n        for(long long i=0; i<arr.size(); i++) {\\n            if(um[arr[i]].size()==1) res.push_back(0);\\n            else {\\n                if(um2.find(arr[i])!=um2.end()) {\\n                    long long idx = um2[arr[i]];\\n                    um2[arr[i]] = i;\\n                    long long sum = um1[idx];\\n                    long long diff = i-idx;\\n                    long long n = um[arr[i]].size();\\n                    long long curr = sum + diff*(um[arr[i]][0]-1) - (n-um[arr[i]][0]-1)*diff;\\n                    um[arr[i]][0]++;\\n                    res.push_back(curr);\\n                    um1[i] = curr;\\n                }\\n                else {\\n                    vector<long long> v = um[arr[i]];\\n                    long long curr = 0, st = v[0];\\n                    for(long long j=1; j<v.size(); j++) {\\n                        curr += abs(st-v[j]);\\n                    }\\n                    res.push_back(curr);\\n                    um[arr[i]][0] = 1;\\n                    um2[arr[i]] = i;\\n                    um1[i] = curr;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tvector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<long long, vector<long long>> um;\\n        vector<long long> res;\\n        for(long long i=0; i<arr.size(); i++) {\\n            um[arr[i]].push_back(i);\\n        }\\n        unordered_map<long long, long long> um1, um2;\\n        for(long long i=0; i<arr.size(); i++) {\\n            if(um[arr[i]].size()==1) res.push_back(0);\\n            else {\\n                if(um2.find(arr[i])!=um2.end()) {\\n                    long long idx = um2[arr[i]];\\n                    um2[arr[i]] = i;\\n                    long long sum = um1[idx];\\n                    long long diff = i-idx;\\n                    long long n = um[arr[i]].size();\\n                    long long curr = sum + diff*(um[arr[i]][0]-1) - (n-um[arr[i]][0]-1)*diff;\\n                    um[arr[i]][0]++;\\n                    res.push_back(curr);\\n                    um1[i] = curr;\\n                }\\n                else {\\n                    vector<long long> v = um[arr[i]];\\n                    long long curr = 0, st = v[0];\\n                    for(long long j=1; j<v.size(); j++) {\\n                        curr += abs(st-v[j]);\\n                    }\\n                    res.push_back(curr);\\n                    um[arr[i]][0] = 1;\\n                    um2[arr[i]] = i;\\n                    um1[i] = curr;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647483,
                "title": "bfs-based-on-prefix-sum-commented-code-easy-explanation",
                "content": "At a first glance first approach which came into mind go for all element and find the |i - j| for each arr[i]==arr[j]. But it takes N^2 time even though If I go directly those valid (arr[i]==arr[j]) elements. \\nE.G. [2,2,2,2,2]\\nNow for each index I need to visit all the index to calculate |i - j|.\\n* So what we can do?\\n* Any pre-computation will work?\\n* If yes then which parts we need to re-compute?\\n\\nSo, what we are doing in N^2 approach?\\n1. Getting the |i - j| for each valid i and j. So we can do it in constant time if we have some thing like prefix sum.\\n\\t* Like, in above example -> \\n\\t\\t[2,2,2,2,2]\\n\\t\\t2->[0,1,2,3,4]\\n\\t\\tSo prefix will be [0,1,3,6,10]\\n2. Now how, prefix sum will help?\\n\\t* \\tWe know that for any i-th index for arr[i] res will be\\n\\t\\t|i1-i|+|i2-i|.....+|i-i|+|i-(i+1)|+....+|i-(n-1)|, for all valid pairs.\\n\\t\\t\\n\\t\\tSo we know that [i1,i2,i3....in-1| is nothing just index. So \\n\\t\\ti1<i2<i3<...<i<.....<i-(n-1). Note it we\\'ll use it later.\\n3. Now the third chalange if we modify the array index mapped things 2->[0,1,2,3,4], then we\\'ll loss the information regarding the index. Becase we\\'ll need to calculate final result for any i-th because :\\n\\t* \\tFrom statement 2 :\\n\\t\\ti-i1+i-i2+...i-i+...+i-(n-1), it\\'s same as |i1-i|+|i2-i|.....+|i-i|+|i-(i+1)|+....+|i-(n-1)| why? because we know i1<i2<i3<...<i<.....<i-(n-1).\\n\\t\\tnow ((i1+i2+i3.....i(i-1))-i)+ ((i+1)+...+(n-1))-(n*i-1) from above result\\n\\n\\t* \\tSo for this challenge (keep the information about index) I have used queue to store the all indices of particular number. And will do bfs and keep getting answer for current number untill it\\'s not completed.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<int,vector<long long>> sum;\\n        unordered_map<int,queue<int>> mapToIndex;//store the freq because once we made pref array than we need the possitions.\\n        for(int i=0;i<arr.size();i++){\\n            // Store prefix and the index also\\n            if(sum[arr[i]].size()==0){\\n                sum[arr[i]].push_back(i);\\n            } else {\\n                sum[arr[i]].push_back(sum[arr[i]].back()+i);\\n            }\\n            mapToIndex[arr[i]].push(i);\\n        }\\n        \\n        vector<long long> res(arr.size(),0);\\n        for(auto &currElement:mapToIndex) {\\n            int i=0;\\n            vector<long long> &pref = sum[currElement.first];\\n            // Go for each position one by one\\n            while(!currElement.second.empty()){\\n                long long idx = currElement.second.front();\\n                currElement.second.pop();\\n                long long &r = res[idx];\\n                // Get the left sum\\n                long long left = (i==0?0:pref[i-1]);\\n                \\n                // Get the right sum\\n                long long right = (i==pref.size()-1 ? 0 :pref.back()-pref[i]);\\n                left = (i*idx)-left;// since, idx>[0..idx) then also i*idx>sum[0...idx)\\n                right = right - (pref.size()-i-1)*idx;// since, idx<(0..n) then also i*idx<sum[idx+1....n)\\n                r=left+right; // Now finall\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Time Complexity :**\\n**O(N)**, Because we\\'ll see each number only once in bfs. And also making prefix sum and storing index will take linear time\\n**Space Complexity :**\\n**O(N)**, Because at the begining (Worst space time) mapToIndex and sum will keep n elements only.\\n\\n***Please upvote if you find helpfull.***",
                "solutionTags": [
                    "Breadth-First Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<int,vector<long long>> sum;\\n        unordered_map<int,queue<int>> mapToIndex;//store the freq because once we made pref array than we need the possitions.\\n        for(int i=0;i<arr.size();i++){\\n            // Store prefix and the index also\\n            if(sum[arr[i]].size()==0){\\n                sum[arr[i]].push_back(i);\\n            } else {\\n                sum[arr[i]].push_back(sum[arr[i]].back()+i);\\n            }\\n            mapToIndex[arr[i]].push(i);\\n        }\\n        \\n        vector<long long> res(arr.size(),0);\\n        for(auto &currElement:mapToIndex) {\\n            int i=0;\\n            vector<long long> &pref = sum[currElement.first];\\n            // Go for each position one by one\\n            while(!currElement.second.empty()){\\n                long long idx = currElement.second.front();\\n                currElement.second.pop();\\n                long long &r = res[idx];\\n                // Get the left sum\\n                long long left = (i==0?0:pref[i-1]);\\n                \\n                // Get the right sum\\n                long long right = (i==pref.size()-1 ? 0 :pref.back()-pref[i]);\\n                left = (i*idx)-left;// since, idx>[0..idx) then also i*idx>sum[0...idx)\\n                right = right - (pref.size()-i-1)*idx;// since, idx<(0..n) then also i*idx<sum[idx+1....n)\\n                r=left+right; // Now finall\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647451,
                "title": "python-3-prefix-sum-with-comments",
                "content": "Time complexity - O(N)\\nSpace complexity - O(N)\\n```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        cache = collections.defaultdict(list)\\n        for i, v in enumerate(arr): # group positions of each number into separate arrays\\n            cache[v].append(i)\\n        \\n        res = [0] * len(arr)\\n        for k, positions in cache.items(): # now iterate through each number\\'s array\\n            prefix = [] \\n            pn = len(positions)\\n            for pos in positions:\\n                prefix.append(pos if not prefix else prefix[-1] + pos) # calculate prefix sum of all indexes\\n            \\n            for i, v in enumerate(positions):\\n                if i < pn - 1:\\n                    # if it is not last element \\n                    # muplitply current element times of number elements after it\\n                    # and substract the sum of elements which are located after current\\n                    res[v] += abs(v * (pn-i-1) - (prefix[-1] - prefix[i]))\\n                if i > 0:\\n                    # if it is not first element\\n                    # do the same with number of element before current and their prefix sum\\n                    res[v] += abs(v * i - prefix[i-1])\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        cache = collections.defaultdict(list)\\n        for i, v in enumerate(arr): # group positions of each number into separate arrays\\n            cache[v].append(i)\\n        \\n        res = [0] * len(arr)\\n        for k, positions in cache.items(): # now iterate through each number\\'s array\\n            prefix = [] \\n            pn = len(positions)\\n            for pos in positions:\\n                prefix.append(pos if not prefix else prefix[-1] + pos) # calculate prefix sum of all indexes\\n            \\n            for i, v in enumerate(positions):\\n                if i < pn - 1:\\n                    # if it is not last element \\n                    # muplitply current element times of number elements after it\\n                    # and substract the sum of elements which are located after current\\n                    res[v] += abs(v * (pn-i-1) - (prefix[-1] - prefix[i]))\\n                if i > 0:\\n                    # if it is not first element\\n                    # do the same with number of element before current and their prefix sum\\n                    res[v] += abs(v * i - prefix[i-1])\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013579,
                "title": "easy-brute-force-to-start-with-the-solution",
                "content": "# Intuition \\n\\n# BruteForce \\n\\nLet\\'s see how think from brute force to advance solution \\n\\n# Approach\\nFirst make a map of type int, vector which will keep track of indexes of same elements like in array one elecement is reapeting then in vector push that element\\'s indexes \\n\\nunderstand by one example \\n\\neg : 2 1 3 1 2 3 3 \\n\\nmap<int, vector<int>> mpp\\n\\nfor(int i = 0; i < arr.size(); i++){\\n    mpp[arr[i]].push_back(i);\\n}\\n\\nmpp will look like this\\n\\n**[ 2---> [0, 4],\\n  1---> [1, 3]\\n  3---> [2, 5, 6]\\n]**\\n\\nwe store all the index of every element. Now we will iteret through each vector of above map and find difference between each element and we will store it to the ans vector and return it.\\n\\n# Complexity\\n- Time complexity: **O(n^2)**\\n\\n- Space complexity: **(one map + one vector)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        map<int, vector<int>> m;\\n\\n        for(int i = 0; i < arr.size(); i++){\\n            m[arr[i]].push_back(i);\\n        }\\n        vector<long long> ans(arr.size(), 0);\\n\\n        for(auto it:m){\\n            vector<int> index = it.second;\\n            for(int i = 0; i < index.size(); i++){\\n                long long sum = 0;\\n                for(int j = 0; j < index.size(); j++){\\n                    sum += abs(index[j]-index[i]);\\n                }\\n                ans[index[i]] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        map<int, vector<int>> m;\\n\\n        for(int i = 0; i < arr.size(); i++){\\n            m[arr[i]].push_back(i);\\n        }\\n        vector<long long> ans(arr.size(), 0);\\n\\n        for(auto it:m){\\n            vector<int> index = it.second;\\n            for(int i = 0; i < index.size(); i++){\\n                long long sum = 0;\\n                for(int j = 0; j < index.size(); j++){\\n                    sum += abs(index[j]-index[i]);\\n                }\\n                ans[index[i]] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963689,
                "title": "c-clean-code-prefix-array-beats-100-runtime-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        int freq[100001] = {0};\\n        long long sum[100001] = {0};\\n\\n        int n = arr.size();\\n        vector<long long> ans(n);\\n\\n        for(int i=0; i<n; i++){\\n            ans[i] = 1LL * freq[arr[i]] * i - sum[arr[i]];\\n            freq[arr[i]]++;\\n            sum[arr[i]] += i;\\n        }\\n\\n        memset(freq,0,sizeof(freq));\\n        memset(sum,0,sizeof(sum));\\n\\n        for(int i=n-1; i>=0; i--){\\n            ans[i] += sum[arr[i]] - 1LL * freq[arr[i]] * i;\\n            sum[arr[i]] += i;\\n            freq[arr[i]]++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        int freq[100001] = {0};\\n        long long sum[100001] = {0};\\n\\n        int n = arr.size();\\n        vector<long long> ans(n);\\n\\n        for(int i=0; i<n; i++){\\n            ans[i] = 1LL * freq[arr[i]] * i - sum[arr[i]];\\n            freq[arr[i]]++;\\n            sum[arr[i]] += i;\\n        }\\n\\n        memset(freq,0,sizeof(freq));\\n        memset(sum,0,sizeof(sum));\\n\\n        for(int i=n-1; i>=0; i--){\\n            ans[i] += sum[arr[i]] - 1LL * freq[arr[i]] * i;\\n            sum[arr[i]] += i;\\n            freq[arr[i]]++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870837,
                "title": "c-simple-easy-explanation-with-images-o-n",
                "content": "Before Solving the Question ,  Let\\'s understand what is the **motive behind** the question \\n\\nGive an array of size n , return the array of size n such that ,\\n\\nFor every ith position , look to the **left and right and identify other jth index position where nums[i] == nums[j]**. \\n \\nAfter identifying it , **take the absolute diff and add it to the sum variable**  and store it in the res array for the every ith position.\\n\\nHow do we identify the jth position considering the left and right side for the given curr index can be understood from the given pics down below.\\n![image](https://assets.leetcode.com/users/images/6c548864-8666-4c04-a2f9-7a0262d02fe6_1691305639.501626.jpeg)\\n![image](https://assets.leetcode.com/users/images/2e3a1e3a-38e5-44f9-8d12-6cd3f508041d_1691305680.296396.jpeg)\\n![image](https://assets.leetcode.com/users/images/159faa04-b388-47b0-8596-89d1342632ed_1691305689.1652877.jpeg)\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<long long> ans(n);\\n        unordered_map<int , vector<int>> mp;\\n        \\n        // Store all the indices fop every unique numbers that exist.\\n        for(int i = 0 ; i < nums.size() ; i++) {\\n            mp[nums[i]].push_back(i);\\n        } \\n        \\n        /*\\n          Access the vector for every unique number and for every index position \\n          in the vector , find out the sum of absolute diff (considering the left side + right side).\\n          \\n          The concept of how we are finding out the absolute diff from both side\\n          for the curr index is shown in the pictures.\\n        */\\n        for(auto it : mp) {\\n           auto indexes = it.second;\\n           \\n           long long totalSum = 0;\\n           for(auto index : indexes) {\\n               totalSum += index;\\n           }\\n            \\n           long long preSum = 0;\\n           for(int i = 0 ; i < indexes.size() ; i++) {\\n               int index = indexes[i];\\n               long long postSum = totalSum - preSum - index;\\n               \\n               // Taking the left side for the curr index --> (i * count) - preSum;\\n               ans[index] += (index * (long long)i);\\n               ans[index] -= preSum;\\n               \\n               // Taking the right side for the curr index --> postSum - (i * count);\\n               ans[index] -= (index * (long long)(indexes.size() - i - 1));\\n               ans[index] += postSum;\\n               \\n               preSum += index;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nSpecial thanks to [Mohak Harjani](https://leetcode.com/MohakHarjani/) to help me **understand this concept**. \\n\\n**Time Complexity : O(N)\\nSpace Complexity : O(N)**\\n\\nSolve this question too for better practice :  [Sum of Distances](https://leetcode.com/problems/sum-of-distances/)\\n\\nIf you really understood something from this post , Please Do **Upvote** \\uD83D\\uDE80\\nThank you \\uD83D\\uDE0A.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<long long> ans(n);\\n        unordered_map<int , vector<int>> mp;\\n        \\n        // Store all the indices fop every unique numbers that exist.\\n        for(int i = 0 ; i < nums.size() ; i++) {\\n            mp[nums[i]].push_back(i);\\n        } \\n        \\n        /*\\n          Access the vector for every unique number and for every index position \\n          in the vector , find out the sum of absolute diff (considering the left side + right side).\\n          \\n          The concept of how we are finding out the absolute diff from both side\\n          for the curr index is shown in the pictures.\\n        */\\n        for(auto it : mp) {\\n           auto indexes = it.second;\\n           \\n           long long totalSum = 0;\\n           for(auto index : indexes) {\\n               totalSum += index;\\n           }\\n            \\n           long long preSum = 0;\\n           for(int i = 0 ; i < indexes.size() ; i++) {\\n               int index = indexes[i];\\n               long long postSum = totalSum - preSum - index;\\n               \\n               // Taking the left side for the curr index --> (i * count) - preSum;\\n               ans[index] += (index * (long long)i);\\n               ans[index] -= preSum;\\n               \\n               // Taking the right side for the curr index --> postSum - (i * count);\\n               ans[index] -= (index * (long long)(indexes.size() - i - 1));\\n               ans[index] += postSum;\\n               \\n               preSum += index;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395841,
                "title": "simple-java-solution-using-6-hashmaps",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] getDistances(int[] nums) {\\n        HashMap<Integer, Long> before = new HashMap<>(), after = new HashMap<>();\\n        HashMap<Integer, Integer> f1 = new HashMap<>(), f2 = new HashMap<>();\\n        HashMap<Integer, Pair<Long, Integer>> a = new HashMap<>(), b = new HashMap<>();\\n        int n = nums.length;\\n        for(int i = 0; i<n; i++) {\\n            before.merge(nums[i], (long)i, Long :: sum );\\n            f1.merge(nums[i], 1, Integer :: sum);\\n            a.put(i, new Pair(before.get(nums[i]), f1.get(nums[i])));\\n        }\\n        for(int i = n-1; i>=0; i--) {\\n            after.merge(nums[i], (long)i, Long :: sum);\\n            f2.merge(nums[i], 1, Integer :: sum);\\n            b.put(i, new Pair(after.get(nums[i]), f2.get(nums[i])));\\n        }\\n        long[] ans = new long[n];\\n        for(int i = 0; i<n; i++) {\\n            long val = 0;\\n            val += ((long)i * (long)a.get(i).getValue()) - a.get(i).getKey();\\n            val += b.get(i).getKey() - ((long)i * (long)b.get(i).getValue());\\n            ans[i] = val;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] nums) {\\n        HashMap<Integer, Long> before = new HashMap<>(), after = new HashMap<>();\\n        HashMap<Integer, Integer> f1 = new HashMap<>(), f2 = new HashMap<>();\\n        HashMap<Integer, Pair<Long, Integer>> a = new HashMap<>(), b = new HashMap<>();\\n        int n = nums.length;\\n        for(int i = 0; i<n; i++) {\\n            before.merge(nums[i], (long)i, Long :: sum );\\n            f1.merge(nums[i], 1, Integer :: sum);\\n            a.put(i, new Pair(before.get(nums[i]), f1.get(nums[i])));\\n        }\\n        for(int i = n-1; i>=0; i--) {\\n            after.merge(nums[i], (long)i, Long :: sum);\\n            f2.merge(nums[i], 1, Integer :: sum);\\n            b.put(i, new Pair(after.get(nums[i]), f2.get(nums[i])));\\n        }\\n        long[] ans = new long[n];\\n        for(int i = 0; i<n; i++) {\\n            long val = 0;\\n            val += ((long)i * (long)a.get(i).getValue()) - a.get(i).getKey();\\n            val += b.get(i).getKey() - ((long)i * (long)b.get(i).getValue());\\n            ans[i] = val;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954151,
                "title": "crisp-n-clear-o-n-javascript-runtime-86-67-meaningful-vars",
                "content": "# Intuition\\nCreate an object which has indexes and few other infor\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nvar getDistances = function (array) {\\n    const output = [];\\n    const obj = {};\\n    for (let index = 0; index < array.length; index++) {\\n        const element = array[index];\\n        if (!obj[element]) {\\n            obj[element] = { currentIndex: 0, leftSum: 0, sum: 0, indexes: [] };\\n        }\\n        obj[element].sum += index;\\n        obj[element].indexes.push(index);\\n    }\\n    for (let index = 0; index < array.length; index++) {\\n        const element = array[index];\\n        const elementConfig = obj[element];\\n        const leftSideSum = elementConfig.leftSum;\\n        const tempElement = elementConfig.indexes[elementConfig.currentIndex];\\n        const rightSideSum = elementConfig.sum - tempElement - leftSideSum;\\n        const totalElementsOnLeftSide = elementConfig.currentIndex;\\n        const totalElementsOnRightSide =\\n            elementConfig.indexes.length - elementConfig.currentIndex - 1;\\n        const rightPart = rightSideSum - totalElementsOnRightSide * tempElement;\\n        const leftPart = totalElementsOnLeftSide * tempElement - leftSideSum;\\n        output.push(leftPart + rightPart);\\n        elementConfig.leftSum +=\\n            elementConfig.indexes[elementConfig.currentIndex];\\n        elementConfig.currentIndex += 1;\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getDistances = function (array) {\\n    const output = [];\\n    const obj = {};\\n    for (let index = 0; index < array.length; index++) {\\n        const element = array[index];\\n        if (!obj[element]) {\\n            obj[element] = { currentIndex: 0, leftSum: 0, sum: 0, indexes: [] };\\n        }\\n        obj[element].sum += index;\\n        obj[element].indexes.push(index);\\n    }\\n    for (let index = 0; index < array.length; index++) {\\n        const element = array[index];\\n        const elementConfig = obj[element];\\n        const leftSideSum = elementConfig.leftSum;\\n        const tempElement = elementConfig.indexes[elementConfig.currentIndex];\\n        const rightSideSum = elementConfig.sum - tempElement - leftSideSum;\\n        const totalElementsOnLeftSide = elementConfig.currentIndex;\\n        const totalElementsOnRightSide =\\n            elementConfig.indexes.length - elementConfig.currentIndex - 1;\\n        const rightPart = rightSideSum - totalElementsOnRightSide * tempElement;\\n        const leftPart = totalElementsOnLeftSide * tempElement - leftSideSum;\\n        output.push(leftPart + rightPart);\\n        elementConfig.leftSum +=\\n            elementConfig.indexes[elementConfig.currentIndex];\\n        elementConfig.currentIndex += 1;\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2915371,
                "title": "o-n-faster-solution-hash-table-maths",
                "content": "# Intuition\\nUsed the answer of previous index of the same value and added the product of its occurences and difference between its intervals.\\n\\n# Approach\\nThe first vector is used for left intervals of all the same values.\\nThe second vector is used for right intervals of all the same values.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr){\\n        int n=arr.size();\\n        vector<long long> ans(n,0);\\n        vector<long long> res(n,0);\\n        unordered_map<int,int> count,index;\\n        for(int i=0; i<n; i++){\\n            int num=arr[i];\\n            int freq=count[num];\\n            if(freq!=0){\\n                int diff=i-index[num];\\n                ans[i]+=ans[index[num]];\\n                ans[i]+=1ll*diff*freq;\\n            }\\n            count[num]++;\\n            index[num]=i;\\n        }\\n        count.clear(); index.clear();\\n        for(int i=n-1; i>=0; i--){\\n            int num=arr[i];\\n            int freq=count[num];\\n            if(freq!=0){\\n                int diff=index[num]-i;\\n                res[i]+=res[index[num]];\\n                res[i]+=1ll*diff*freq;\\n            }\\n            count[num]++;\\n            index[num]=i;\\n        }\\n        for(int i=0; i<n; i++){\\n            ans[i]+=res[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr){\\n        int n=arr.size();\\n        vector<long long> ans(n,0);\\n        vector<long long> res(n,0);\\n        unordered_map<int,int> count,index;\\n        for(int i=0; i<n; i++){\\n            int num=arr[i];\\n            int freq=count[num];\\n            if(freq!=0){\\n                int diff=i-index[num];\\n                ans[i]+=ans[index[num]];\\n                ans[i]+=1ll*diff*freq;\\n            }\\n            count[num]++;\\n            index[num]=i;\\n        }\\n        count.clear(); index.clear();\\n        for(int i=n-1; i>=0; i--){\\n            int num=arr[i];\\n            int freq=count[num];\\n            if(freq!=0){\\n                int diff=index[num]-i;\\n                res[i]+=res[index[num]];\\n                res[i]+=1ll*diff*freq;\\n            }\\n            count[num]++;\\n            index[num]=i;\\n        }\\n        for(int i=0; i<n; i++){\\n            ans[i]+=res[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585125,
                "title": "python-accepted-took-me-an-hr-to-solve-this",
                "content": "\\tfrom collections import defaultdict\\n\\tclass Solution:\\n\\t\\tdef getDistances(self, arr: List[int]) -> List[int]:\\n\\t\\t\\tdef ps(arr):\\n\\t\\t\\t\\tl = [0]*len(arr) \\n\\t\\t\\t\\tr = [0]*len(arr)\\n\\n\\t\\t\\t\\tleft=0\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tleft+=arr[i]\\n\\t\\t\\t\\t\\tl[i] = left\\n\\t\\t\\t\\tright=0\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tright+=arr[-(i+1)]\\n\\t\\t\\t\\t\\tr[-(i+1)] = right\\n\\t\\t\\t\\treturn l,r\\n\\n\\n\\t\\t\\td = defaultdict(list)\\n\\n\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\tv  = arr[i]\\n\\t\\t\\t\\td[v].append(i)\\n\\t\\t\\t# print(d)\\n\\n\\n\\t\\t\\tres = [0]*len(arr)\\n\\n\\t\\t\\tfor arr in d.values():\\n\\t\\t\\t\\tl,r = ps(arr)\\n\\t\\t\\t\\t# print()\\n\\t\\t\\t\\t# print(l)\\n\\t\\t\\t\\t# print(r)\\n\\t\\t\\t\\t#LIMR\\n\\t\\t\\t\\tif len(arr)==1:\\n\\t\\t\\t\\t\\tres[arr[0]]=0\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tindex = arr[i]\\n\\t\\t\\t\\t\\ta = 0\\n\\t\\t\\t\\t\\tb = 0\\n\\t\\t\\t\\t\\tif i==0:\\n\\t\\t\\t\\t\\t\\t b = r[i+1]  - (len(arr)-i-1)*arr[i]\\n\\t\\t\\t\\t\\telif i==len(arr)-1:\\n\\t\\t\\t\\t\\t\\t a = (i * arr[i]) -  l[i-1]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ta = (i * arr[i]) -  l[i-1]\\n\\t\\t\\t\\t\\t\\tb = r[i+1] - (len(arr)-i-1)*arr[i]\\n\\t\\t\\t\\t\\tres[index]=a+b  \\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tfrom collections import defaultdict\\n\\tclass Solution:\\n\\t\\tdef getDistances(self, arr: List[int]) -> List[int]:\\n\\t\\t\\tdef ps(arr):\\n\\t\\t\\t\\tl = [0]*len(arr) \\n\\t\\t\\t\\tr = [0]*len(arr)\\n\\n\\t\\t\\t\\tleft=0\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tleft+=arr[i]\\n\\t\\t\\t\\t\\tl[i] = left\\n\\t\\t\\t\\tright=0\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tright+=arr[-(i+1)]\\n\\t\\t\\t\\t\\tr[-(i+1)] = right\\n\\t\\t\\t\\treturn l,r\\n\\n\\n\\t\\t\\td = defaultdict(list)\\n\\n\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\tv  = arr[i]\\n\\t\\t\\t\\td[v].append(i)\\n\\t\\t\\t# print(d)\\n\\n\\n\\t\\t\\tres = [0]*len(arr)\\n\\n\\t\\t\\tfor arr in d.values():\\n\\t\\t\\t\\tl,r = ps(arr)\\n\\t\\t\\t\\t# print()\\n\\t\\t\\t\\t# print(l)\\n\\t\\t\\t\\t# print(r)\\n\\t\\t\\t\\t#LIMR\\n\\t\\t\\t\\tif len(arr)==1:\\n\\t\\t\\t\\t\\tres[arr[0]]=0\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tindex = arr[i]\\n\\t\\t\\t\\t\\ta = 0\\n\\t\\t\\t\\t\\tb = 0\\n\\t\\t\\t\\t\\tif i==0:\\n\\t\\t\\t\\t\\t\\t b = r[i+1]  - (len(arr)-i-1)*arr[i]\\n\\t\\t\\t\\t\\telif i==len(arr)-1:\\n\\t\\t\\t\\t\\t\\t a = (i * arr[i]) -  l[i-1]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ta = (i * arr[i]) -  l[i-1]\\n\\t\\t\\t\\t\\t\\tb = r[i+1] - (len(arr)-i-1)*arr[i]\\n\\t\\t\\t\\t\\tres[index]=a+b  \\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2574996,
                "title": "simple-and-clean-solution-time-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        vector<pair<long long,int>> ps(1e5+1,{0,0});\\n        unordered_map<int,int> um;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            um[arr[i]]++;\\n            ps[arr[i]].second++;\\n            ps[arr[i]].first+=i;\\n        }\\n        vector<long long> ans;\\n        long long temp1=0,temp2=0,add=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            temp1=ps[arr[i]].second*1ll*i;\\n            add=(um[arr[i]]-ps[arr[i]].second)*1ll*i;\\n            temp2=i*2;\\n            ans.push_back(ps[arr[i]].first+add-temp1);\\n            ps[arr[i]].first-=temp2;\\n            ps[arr[i]].second--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        vector<pair<long long,int>> ps(1e5+1,{0,0});\\n        unordered_map<int,int> um;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            um[arr[i]]++;\\n            ps[arr[i]].second++;\\n            ps[arr[i]].first+=i;\\n        }\\n        vector<long long> ans;\\n        long long temp1=0,temp2=0,add=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            temp1=ps[arr[i]].second*1ll*i;\\n            add=(um[arr[i]]-ps[arr[i]].second)*1ll*i;\\n            temp2=i*2;\\n            ans.push_back(ps[arr[i]].first+add-temp1);\\n            ps[arr[i]].first-=temp2;\\n            ps[arr[i]].second--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356199,
                "title": "python-3-travel-from-both-directions",
                "content": "\\tclass Solution:\\n\\t\\tdef getDistances(self, arr: List[int]) -> List[int]:\\n\\t\\t\\tdef get_dist(A):\\n\\t\\t\\t\\tcount=0\\n\\t\\t\\t\\tl=[0]\\n\\t\\t\\t\\tfor i,ind in enumerate(A):\\n\\t\\t\\t\\t\\tif i==0:\\n\\t\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tl.append(l[-1]+abs(ind-A[i-1])*(count))\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\treturn l\\n\\n\\t\\t\\ta=defaultdict(list)\\n\\t\\t\\tfor i,x in enumerate(arr):\\n\\t\\t\\t\\ta[x].append(i)\\n\\t\\t\\tres=[0]*len(arr)\\n\\n\\t\\t\\tfor x in a:\\n\\t\\t\\t\\tleft=get_dist(a[x])\\n\\t\\t\\t\\tright=get_dist(a[x][::-1])\\n\\n\\t\\t\\t\\tfor i,y in enumerate(a[x]):\\n\\t\\t\\t\\t\\tres[y]=left[i]+right[len(a[x])-i-1]\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef getDistances(self, arr: List[int]) -> List[int]:\\n\\t\\t\\tdef get_dist(A):\\n\\t\\t\\t\\tcount=0\\n\\t\\t\\t\\tl=[0]\\n\\t\\t\\t\\tfor i,ind in enumerate(A):\\n\\t\\t\\t\\t\\tif i==0:\\n\\t\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tl.append(l[-1]+abs(ind-A[i-1])*(count))\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\treturn l\\n\\n\\t\\t\\ta=defaultdict(list)\\n\\t\\t\\tfor i,x in enumerate(arr):\\n\\t\\t\\t\\ta[x].append(i)\\n\\t\\t\\tres=[0]*len(arr)\\n\\n\\t\\t\\tfor x in a:\\n\\t\\t\\t\\tleft=get_dist(a[x])\\n\\t\\t\\t\\tright=get_dist(a[x][::-1])\\n\\n\\t\\t\\t\\tfor i,y in enumerate(a[x]):\\n\\t\\t\\t\\t\\tres[y]=left[i]+right[len(a[x])-i-1]\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1857357,
                "title": "java-beat-90",
                "content": "We just need to compute left -> right and right -> left sums of occurance positions.\\n\\n```\\nclass Solution {\\n    \\n    public long[] getDistances(int[] arr) {\\n        Map<Integer, List<Integer>> map = new HashMap();\\n        long[] left = new long[arr.length];\\n        long[] right = new long[arr.length]; \\n        long[] res = new long[arr.length];\\n        \\n        int x = 0;\\n        for(int a : arr) {\\n            map.putIfAbsent(a, new ArrayList<Integer>());\\n            map.get(a).add(map.get(a).size(), x++);\\n        }\\n             \\n        for(int key : map.keySet()) {\\n           if(map.get(key).size() < 2) continue;\\n            \\n           List<Integer> temp = map.get(key);\\n            int f = 0; \\n            \\n           //left to right\\n           for(int i = 0; i < temp.size(); i++) {\\n               if(i > 0) {\\n                    left[temp.get(i)] = (Math.abs(temp.get(i) - temp.get(i - 1)) * f) + left[temp.get(i - 1)];\\n               }\\n               f++;\\n           } \\n           \\n           f = 0;\\n           //right to left\\n           for(int i = temp.size() - 1; i >= 0; i--) {\\n               if(i < temp.size() - 1) {\\n                   right[temp.get(i)] = (Math.abs(temp.get(i) - temp.get(i + 1)) * f) + right[temp.get(i + 1)];\\n               }\\n               f++;\\n           } \\n        }\\n        \\n        // Sum\\n        for(int i = 0; i < left.length; i++){\\n            res[i] = left[i] + right[i];\\n        }\\n        \\n        return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public long[] getDistances(int[] arr) {\\n        Map<Integer, List<Integer>> map = new HashMap();\\n        long[] left = new long[arr.length];\\n        long[] right = new long[arr.length]; \\n        long[] res = new long[arr.length];\\n        \\n        int x = 0;\\n        for(int a : arr) {\\n            map.putIfAbsent(a, new ArrayList<Integer>());\\n            map.get(a).add(map.get(a).size(), x++);\\n        }\\n             \\n        for(int key : map.keySet()) {\\n           if(map.get(key).size() < 2) continue;\\n            \\n           List<Integer> temp = map.get(key);\\n            int f = 0; \\n            \\n           //left to right\\n           for(int i = 0; i < temp.size(); i++) {\\n               if(i > 0) {\\n                    left[temp.get(i)] = (Math.abs(temp.get(i) - temp.get(i - 1)) * f) + left[temp.get(i - 1)];\\n               }\\n               f++;\\n           } \\n           \\n           f = 0;\\n           //right to left\\n           for(int i = temp.size() - 1; i >= 0; i--) {\\n               if(i < temp.size() - 1) {\\n                   right[temp.get(i)] = (Math.abs(temp.get(i) - temp.get(i + 1)) * f) + right[temp.get(i + 1)];\\n               }\\n               f++;\\n           } \\n        }\\n        \\n        // Sum\\n        for(int i = 0; i < left.length; i++){\\n            res[i] = left[i] + right[i];\\n        }\\n        \\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830404,
                "title": "java-prefix-sum-solution-o-n",
                "content": "\\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        int n = arr.length;\\n        long[] left = new long[n];\\n        long[] right = new long[n];\\n        HashMap<Integer, Pair<Integer, Integer>> left2right = new HashMap<>();\\n        HashMap<Integer, Pair<Integer, Integer>> right2left = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int val1 = arr[i];\\n            if (left2right.containsKey(val1)) {\\n                Pair<Integer, Integer> pair = left2right.get(val1);\\n                int previousIndex = pair.getKey();\\n                int count = pair.getValue();\\n                left[i] = (long) (i - previousIndex) * count + left[previousIndex];\\n                left2right.put(val1, new Pair<>(i, count + 1));\\n            } else {\\n                left2right.put(val1, new Pair<>(i, 1));\\n            }\\n        }\\n        for (int i = n - 1; i >= 0; i--) {\\n            int val2 = arr[i];\\n            if (right2left.containsKey(val2)) {\\n                Pair<Integer, Integer> pair = right2left.get(val2);\\n                int previousIndex = pair.getKey();\\n                int count = pair.getValue();\\n                right[i] = (long) (previousIndex - i) * count + right[previousIndex];\\n                right2left.put(val2, new Pair<>(i, count + 1));\\n            } else {\\n                right2left.put(val2, new Pair<>(i, 1));\\n            }\\n        }\\n        long[] ret = new long[n];\\n        for (int i = 0; i < n; i++) {\\n            ret[i] = left[i] + right[i];\\n        }\\n        return ret;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long[] getDistances(int[] arr) {\\n        int n = arr.length;\\n        long[] left = new long[n];\\n        long[] right = new long[n];\\n        HashMap<Integer, Pair<Integer, Integer>> left2right = new HashMap<>();\\n        HashMap<Integer, Pair<Integer, Integer>> right2left = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int val1 = arr[i];\\n            if (left2right.containsKey(val1)) {\\n                Pair<Integer, Integer> pair = left2right.get(val1);\\n                int previousIndex = pair.getKey();\\n                int count = pair.getValue();\\n                left[i] = (long) (i - previousIndex) * count + left[previousIndex];\\n                left2right.put(val1, new Pair<>(i, count + 1));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1826420,
                "title": "typescript-o-n-two-pass-map-clean-code",
                "content": "```\\nfunction getDistances(arr: number[]): number[] {\\n  const n = arr.length;\\n  const res = Array(n).fill(0);\\n  const map = new Map<number, number[]>();\\n  \\n  const processItem = (i: number): void => {\\n    const curr = arr[i]; \\n    if (map.has(curr)) {\\n      const [acc, prev, count] = map.get(curr);\\n      const nextAcc = Math.abs(i - prev) * count + acc;\\n      res[i] += nextAcc;\\n      map.set(curr, [nextAcc, i, count + 1]);\\n    } else {\\n      map.set(curr, [0, i, 1]);\\n    }\\n  }\\n  \\n  for(let i=0; i<n; i++) processItem(i);\\n  map.clear();\\n  for(let i=n-1; i>=0; i--) processItem(i)\\n  \\n  return res;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction getDistances(arr: number[]): number[] {\\n  const n = arr.length;\\n  const res = Array(n).fill(0);\\n  const map = new Map<number, number[]>();\\n  \\n  const processItem = (i: number): void => {\\n    const curr = arr[i]; \\n    if (map.has(curr)) {\\n      const [acc, prev, count] = map.get(curr);\\n      const nextAcc = Math.abs(i - prev) * count + acc;\\n      res[i] += nextAcc;\\n      map.set(curr, [nextAcc, i, count + 1]);\\n    } else {\\n      map.set(curr, [0, i, 1]);\\n    }\\n  }\\n  \\n  for(let i=0; i<n; i++) processItem(i);\\n  map.clear();\\n  for(let i=n-1; i>=0; i--) processItem(i)\\n  \\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1706167,
                "title": "python3-concise-code-with-visual-notes",
                "content": "![image](https://assets.leetcode.com/users/images/1d0836f9-f19c-4e3a-bbfd-e458cc430b45_1642742751.185903.png)\\n\\n\\n```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        d = defaultdict(list)\\n        for i, v in enumerate(arr): d[v].append(i)\\n            \\n        \\n        res = defaultdict(list)\\n        for v, idx in d.items():\\n            ps = list(accumulate(idx, initial=0))\\n            vals = []\\n            idn = len(idx)\\n            for i, x in enumerate(idx):\\n                vals.append(i*x-ps[i] + ps[-1]-ps[i+1]-(idn-i-1)*x)\\n\\n            res[v] = deque(vals)\\n            \\n        return [res[v].popleft() for v in arr]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        d = defaultdict(list)\\n        for i, v in enumerate(arr): d[v].append(i)\\n            \\n        \\n        res = defaultdict(list)\\n        for v, idx in d.items():\\n            ps = list(accumulate(idx, initial=0))\\n            vals = []\\n            idn = len(idx)\\n            for i, x in enumerate(idx):\\n                vals.append(i*x-ps[i] + ps[-1]-ps[i+1]-(idn-i-1)*x)\\n\\n            res[v] = deque(vals)\\n            \\n        return [res[v].popleft() for v in arr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694496,
                "title": "simple-java-solution-using-map-and-list",
                "content": "```\\nclass Solution {\\n    public long[] getDistances(int[] a) {\\n        int n = a.length;\\n        \\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i=0;i<n;i++) {\\n            List<Integer> list = map.get(a[i]);\\n            if (list == null) list = new ArrayList<>();\\n            list.add(i);\\n            map.put(a[i], list);\\n        }\\n        \\n        long ans[] = new long[n];\\n        Arrays.fill(ans, 0);\\n        for (List<Integer> list:map.values()) {\\n            long sum = 0;\\n            int first = list.get(0);\\n            for (int i=1;i<list.size();i++) {\\n                sum = sum + list.get(i) - first;\\n            }\\n            ans[first] = sum;\\n            \\n            int prevElements = 0, nextElements = list.size()-2;\\n            for (int i=1;i<list.size();i++) {\\n                int diff = list.get(i)-list.get(i-1);\\n                sum = sum + diff*(prevElements - nextElements);\\n                ans[list.get(i)] = sum;\\n                prevElements++;\\n                nextElements--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] a) {\\n        int n = a.length;\\n        \\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i=0;i<n;i++) {\\n            List<Integer> list = map.get(a[i]);\\n            if (list == null) list = new ArrayList<>();\\n            list.add(i);\\n            map.put(a[i], list);\\n        }\\n        \\n        long ans[] = new long[n];\\n        Arrays.fill(ans, 0);\\n        for (List<Integer> list:map.values()) {\\n            long sum = 0;\\n            int first = list.get(0);\\n            for (int i=1;i<list.size();i++) {\\n                sum = sum + list.get(i) - first;\\n            }\\n            ans[first] = sum;\\n            \\n            int prevElements = 0, nextElements = list.size()-2;\\n            for (int i=1;i<list.size();i++) {\\n                int diff = list.get(i)-list.get(i-1);\\n                sum = sum + diff*(prevElements - nextElements);\\n                ans[list.get(i)] = sum;\\n                prevElements++;\\n                nextElements--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669823,
                "title": "java-solution-o-n-with-explanations",
                "content": "Explanations on how to compute all sums in O(n): https://poitevinpm.medium.com/leetcode-2121-intervals-between-identical-elements-2dd1f7dcae9a\\n\\nRaw Java code:\\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        // reverse map\\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\\n        int n = arr.length;\\n        for (int i = 0; i < n; i++) {\\n            int x = arr[i];\\n            if (!map.containsKey(x)) {\\n                map.put(x, new TreeSet<Integer>());\\n            }\\n            map.get(x).add(i);\\n        }\\n        \\n        long[] res = new long[n];\\n        for (int val : map.keySet()) {\\n            TreeSet<Integer> sorted = map.get(val);\\n            long sum = 0L;\\n            int firstIndex = sorted.first();\\n            for (int index: sorted) {\\n                sum += (index - firstIndex);\\n            }\\n            res[firstIndex] = sum;\\n            int prevIndex = firstIndex;\\n            int prevElements = 0;\\n            int nextElements = sorted.size() - 2;\\n            for (int index : sorted.tailSet(firstIndex+1)) {\\n                int diff = index - prevIndex;\\n                sum = sum + diff * (prevElements - nextElements);\\n                res[index] = sum;\\n                prevIndex = index;\\n                prevElements++;\\n                nextElements--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        // reverse map\\n        Map<Integer, TreeSet<Integer>> map = new HashMap<>();\\n        int n = arr.length;\\n        for (int i = 0; i < n; i++) {\\n            int x = arr[i];\\n            if (!map.containsKey(x)) {\\n                map.put(x, new TreeSet<Integer>());\\n            }\\n            map.get(x).add(i);\\n        }\\n        \\n        long[] res = new long[n];\\n        for (int val : map.keySet()) {\\n            TreeSet<Integer> sorted = map.get(val);\\n            long sum = 0L;\\n            int firstIndex = sorted.first();\\n            for (int index: sorted) {\\n                sum += (index - firstIndex);\\n            }\\n            res[firstIndex] = sum;\\n            int prevIndex = firstIndex;\\n            int prevElements = 0;\\n            int nextElements = sorted.size() - 2;\\n            for (int index : sorted.tailSet(firstIndex+1)) {\\n                int diff = index - prevIndex;\\n                sum = sum + diff * (prevElements - nextElements);\\n                res[index] = sum;\\n                prevIndex = index;\\n                prevElements++;\\n                nextElements--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667740,
                "title": "java-o-n-solution-explained-by-using-induction",
                "content": "1. Iterate array, use a hash table records each number\\'s indices in a list. \\n\\n2. ~~(Brute force each list to construct the result array. Time **O(n^2)**.)~~\\n\\n3. For a specific number, suppose its indices list is ```{a, b, c, ... , k, m, ... , n}```\\n\\n   - ```sumA = (a - a) + (b - a) + (c - a) + ... + (n - a)```\\n\\n   - ``` sumK = (k - a) + (k - b) + ... + (k - k) + (m - k) + ... + (n - k) ```\\n\\n   - ```sumM = (m - a) + (m - b) + ... + (m - k) + (m - m) + ... + (n - m)```\\n\\n     ```= ((k - a) - (k - m)) + ((k - b) - (k - m)) + ... + ((k - k) - (k - m)) + ((m - k) + (k - m)) + ... + ((n - k) + (k - m)) ```\\n\\n     ```= sumK - (k - m) * (k\\'s index in list + 1) + (k - m) * (list size - (k\\'s index in list + 1))```\\n\\nJava code:\\n\\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        Map<Integer, List<Integer>> numberIndexMap = new HashMap();\\n        for (int i = 0; i < arr.length; i++) {\\n            if (numberIndexMap.containsKey(arr[i])) {\\n                numberIndexMap.get(arr[i]).add(i);\\n            } else {\\n                List<Integer> indicesList = new ArrayList();\\n                indicesList.add(i);\\n                numberIndexMap.put(arr[i], indicesList);\\n            }\\n        }\\n        \\n        long[] result = new long[arr.length];\\n        for (Map.Entry<Integer, List<Integer>> e : numberIndexMap.entrySet()) {\\n            List<Integer> indicesList = e.getValue();\\n            long sum = 0;\\n            for (int i = 0; i < indicesList.size(); i++) {\\n                if (i == 0) {\\n                    for (int j = 0; j < indicesList.size(); j++) {\\n                        sum += Math.abs(indicesList.get(i) - indicesList.get(j));\\n                    }\\n                } else {\\n                    sum = sum + Long.valueOf(indicesList.get(i - 1) - indicesList.get(i)) * (indicesList.size() - 2 * i); \\n                }\\n                result[indicesList.get(i)] = sum;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```{a, b, c, ... , k, m, ... , n}```\n```sumA = (a - a) + (b - a) + (c - a) + ... + (n - a)```\n``` sumK = (k - a) + (k - b) + ... + (k - k) + (m - k) + ... + (n - k) ```\n```sumM = (m - a) + (m - b) + ... + (m - k) + (m - m) + ... + (n - m)```\n```= ((k - a) - (k - m)) + ((k - b) - (k - m)) + ... + ((k - k) - (k - m)) + ((m - k) + (k - m)) + ... + ((n - k) + (k - m)) ```\n```= sumK - (k - m) * (k\\'s index in list + 1) + (k - m) * (list size - (k\\'s index in list + 1))```\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        Map<Integer, List<Integer>> numberIndexMap = new HashMap();\\n        for (int i = 0; i < arr.length; i++) {\\n            if (numberIndexMap.containsKey(arr[i])) {\\n                numberIndexMap.get(arr[i]).add(i);\\n            } else {\\n                List<Integer> indicesList = new ArrayList();\\n                indicesList.add(i);\\n                numberIndexMap.put(arr[i], indicesList);\\n            }\\n        }\\n        \\n        long[] result = new long[arr.length];\\n        for (Map.Entry<Integer, List<Integer>> e : numberIndexMap.entrySet()) {\\n            List<Integer> indicesList = e.getValue();\\n            long sum = 0;\\n            for (int i = 0; i < indicesList.size(); i++) {\\n                if (i == 0) {\\n                    for (int j = 0; j < indicesList.size(); j++) {\\n                        sum += Math.abs(indicesList.get(i) - indicesList.get(j));\\n                    }\\n                } else {\\n                    sum = sum + Long.valueOf(indicesList.get(i - 1) - indicesList.get(i)) * (indicesList.size() - 2 * i); \\n                }\\n                result[indicesList.get(i)] = sum;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654736,
                "title": "java-mathematical-explanation-and-commented-code-with-image",
                "content": "**Problem**\\nYou are given a 0-indexed array of n integers arr.\\n\\nThe interval between two elements in arr is defined as the absolute difference between their indices. More formally, the interval between arr[i] and arr[j] is |i - j|.\\n\\nReturn an array intervals of length n where intervals[i] is the sum of intervals between arr[i] and each element in arr with the same value as arr[i].\\n\\nNote: |x| is the absolute value of x.\\n\\n**Example.** \\nInput: arr = [2,1,3,1,2,3,3]\\nOutput: [4,2,7,2,4,4,5]\\n\\nFirst part of the problem is simple: the best data structure is an HashMap where\\n- **key**: is the element x in arr (ex. x = 2);\\n- **value**:  it\\'s the arraylist with all indexes where x is stored (ex val = [0, 3]). \\n\\n\\n```\\n    public long[] getDistances(int[] arr) {\\n        \\n        Map<Integer, ArrayList> map = new HashMap<Integer, ArrayList>();\\n        \\n        \\n        for(int i = 0; i < arr.length ; i++)\\n            \\n            if(!map.containsKey(arr[i]))\\n            { \\n                ArrayList a = new ArrayList<Integer>();\\n                a.add(i);\\n                map.put(arr[i], a);\\n             }\\n        else\\n         map.get(arr[i]).add(i);\\n  \\n```\\n\\nThe second part isn\\'t so trivial.\\n**First approach** is to solve the problem with **brute force.**\\n```\\nlong ans [] = new long[arr.length];\\n        Arrays.fill(ans, 0);\\nfor(int i : map.keySet())\\n            {\\n                ArrayList index = new ArrayList<Integer>();\\n                index = map.get(i);\\n                for(int j = 0; j < index.size(); j++)\\n                 for(int z =j+1; z < index.size(); z++)   \\n                {\\n                    long an = Math.abs((int)index.get(j)-(int)index.get(z)); \\n                    ans[(int)index.get(j)] += an;\\n                    ans[(int)index.get(z)] += an;\\n                }\\n                 \\n              } \\n         \\n         return ans;        \\n```\\nTime complexity: O(n+ (n-1)+ (n-2)+...+1) = O((n+1)(n/2)) = O(n^2).\\nBoom! TLE (Time Limit Exceeded).\\nNow we have to solve this part in a linear time. But how?\\n\\nLet\\'s assume that everything would be **simple** if there were **no triangle inequality** because we would have solved the problem by doing something like this:\\n\\na, b, c is in N+ (read the constraints of the problem)\\n\\nSo I can observe that if such a thing were true\\n\\t\\t\\t\\t\\t\\n\\t   | a-b| + |a-c| = |a-b + a-c|\\n\\n \\n I can easily solve in a linear way doing something like\\n \\n\\t\\t| a+b+c - a*n | where n is the size of the array (in this case n = 3)\\n\\t\\t \\nBut for triangle inequality \\n\\n\\t\\t\\t\\t\\t| a-b| + |a-c| >= |a-b + a-c|\\n\\nLet\\'s take an exemple.\\nSuppose we have a value x that is in position 2,5,6 of starting arr and we have to calculate the answer in 5.\\n\\t\\t\\t\\t|5-2|+|5-6| = |3|+|-1| = **4   !=**  |5-2+5-6| = **2**\\n\\nSo what will I have to observe?\\nAn idea like this can only mathematically work when my differences are ALL positive (or ALL negative).\\n\\n**Notice that:**\\n* The array is \"naturally\" SORTED (because when you build the hashmap you have inserted first the lower index).\\n*  To have always a positive difference you have to do \\n\\t*  a - b if a > b\\n\\t*  b - a if b > a\\n\\nSuppose we have an array like that: 1,2,3,4,5,6. Our linear algorithm have to work as in picture below.\\n![image](https://assets.leetcode.com/users/images/8fb47f1f-8168-4d80-95f1-447e2d4b84a1_1640782289.4044113.png)\\n\\n[There is a mistake in the picture, finally j = 2, not j=3]\\nSo let\\'s see the final implementation of this second part\\n```\\n    long ans [] = new long[arr.length];\\n        Arrays.fill(ans, 0);\\n        \\n        //System.out.println(map.entrySet().toString());  \\n        \\n            for(int i : map.keySet())\\n            {\\n                ArrayList index = new ArrayList<Integer>();\\n                \\n                index = map.get(i);\\n                \\n                long sum = 0;\\n           \\n                //sum of all element\\n                for(int j = 0; j < index.size(); j++)\\n                 sum += (int)index.get(j);\\n                  \\n                ans[(int)index.get(0)] = sum - (long)((int)index.get(0) * (index.size()));\\n               \\n                long elRep = 0;\\n                long prefixSum = 0;\\n              \\n                for(int j = 1; j < index.size(); j++)\\n                {\\n                    prefixSum += (long)((int)(index.get(j-1)));\\n                    \\n                    elRep = (long)(int)(index.get(j))*j;\\n                    \\n                    ans[(int) index.get(j)] = sum + elRep - (long)(2.0 * prefixSum) - (long)((int) index.get(j) * (long)(index.size()-j));\\n                }\\n               \\n              } \\n         \\n         return ans;  \\n```\\n\\nNow time complexity is O(2n) = O(n).\\nSpace complexity: O(n). It depends from input size. \\n\\nThat\\'s all. \\n\\nLittle tips for beginner (as me):\\n* Pay attention to long element: bugs can pop up if you forget you are working with long values.\\n* Pay attention when in Java you instantiate arraylist: specifies that this is an integer Arraylist.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\n    public long[] getDistances(int[] arr) {\\n        \\n        Map<Integer, ArrayList> map = new HashMap<Integer, ArrayList>();\\n        \\n        \\n        for(int i = 0; i < arr.length ; i++)\\n            \\n            if(!map.containsKey(arr[i]))\\n            { \\n                ArrayList a = new ArrayList<Integer>();\\n                a.add(i);\\n                map.put(arr[i], a);\\n             }\\n        else\\n         map.get(arr[i]).add(i);\\n  \\n```\n```\\nlong ans [] = new long[arr.length];\\n        Arrays.fill(ans, 0);\\nfor(int i : map.keySet())\\n            {\\n                ArrayList index = new ArrayList<Integer>();\\n                index = map.get(i);\\n                for(int j = 0; j < index.size(); j++)\\n                 for(int z =j+1; z < index.size(); z++)   \\n                {\\n                    long an = Math.abs((int)index.get(j)-(int)index.get(z)); \\n                    ans[(int)index.get(j)] += an;\\n                    ans[(int)index.get(z)] += an;\\n                }\\n                 \\n              } \\n         \\n         return ans;        \\n```\n```\\n    long ans [] = new long[arr.length];\\n        Arrays.fill(ans, 0);\\n        \\n        //System.out.println(map.entrySet().toString());  \\n        \\n            for(int i : map.keySet())\\n            {\\n                ArrayList index = new ArrayList<Integer>();\\n                \\n                index = map.get(i);\\n                \\n                long sum = 0;\\n           \\n                //sum of all element\\n                for(int j = 0; j < index.size(); j++)\\n                 sum += (int)index.get(j);\\n                  \\n                ans[(int)index.get(0)] = sum - (long)((int)index.get(0) * (index.size()));\\n               \\n                long elRep = 0;\\n                long prefixSum = 0;\\n              \\n                for(int j = 1; j < index.size(); j++)\\n                {\\n                    prefixSum += (long)((int)(index.get(j-1)));\\n                    \\n                    elRep = (long)(int)(index.get(j))*j;\\n                    \\n                    ans[(int) index.get(j)] = sum + elRep - (long)(2.0 * prefixSum) - (long)((int) index.get(j) * (long)(index.size()-j));\\n                }\\n               \\n              } \\n         \\n         return ans;  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1651440,
                "title": "c-228m-100-simple-math-o-n",
                "content": "```\\nvector<long long> getDistances(vector<int>& arr) {\\n        vector<long long> c(100001, 0);\\n        vector<long long> p(100001, 0);\\n        for(int i=0; i<arr.size(); i++) {\\n            p[arr[i]]+= i;\\n            c[arr[i]]++;\\n        }\\n        \\n        vector<long long> ret;\\n        \\n        for(int i=0; i<arr.size(); i++) {\\n            {\\n                //cout<<\"*\"<<i<<\",\"<<p[arr[i]]<<\",\"<<c[arr[i]]<<endl;\\n                ret.push_back(p[arr[i]]-i*c[arr[i]]);\\n                p[arr[i]] -= (i+i);\\n                c[arr[i]] -= 2;\\n            }\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<long long> getDistances(vector<int>& arr) {\\n        vector<long long> c(100001, 0);\\n        vector<long long> p(100001, 0);\\n        for(int i=0; i<arr.size(); i++) {\\n            p[arr[i]]+= i;\\n            c[arr[i]]++;\\n        }\\n        \\n        vector<long long> ret;\\n        \\n        for(int i=0; i<arr.size(); i++) {\\n            {\\n                //cout<<\"*\"<<i<<\",\"<<p[arr[i]]<<\",\"<<c[arr[i]]<<endl;\\n                ret.push_back(p[arr[i]]-i*c[arr[i]]);\\n                p[arr[i]] -= (i+i);\\n                c[arr[i]] -= 2;\\n            }\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1650379,
                "title": "java-solution",
                "content": "Explained by Striver\\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        Map<Integer,Long> sum=new HashMap<>();\\n        Map<Integer,Integer> count=new HashMap<>();\\n        long ans[]=new long[arr.length];\\n        for(int i=0;i<arr.length;i++){\\n            if(!sum.containsKey(arr[i])){\\n                sum.put(arr[i],(\\nlong)0);\\n                count.put(arr[i],0);\\n            }\\n         \\n                ans[i]+=(long)i*count.get(arr[i])-sum.get(arr[i]);\\n                sum.put(arr[i],sum.get(arr[i])+i);\\n                count.put(arr[i],count.get(arr[i])+1);\\n           \\n        }\\n        sum=new HashMap<>();\\n        count=new HashMap<>();\\n          for(int i=arr.length-1;i>=0;i--){\\n            if(!sum.containsKey(arr[i])){\\n                sum.put(arr[i],(long)0);\\n                count.put(arr[i],0);\\n            }\\n           \\n                ans[i]+=sum.get(arr[i])-(long)i*count.get(arr[i]);\\n                sum.put(arr[i],sum.get(arr[i])+i);\\n                count.put(arr[i],count.get(arr[i])+1);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        Map<Integer,Long> sum=new HashMap<>();\\n        Map<Integer,Integer> count=new HashMap<>();\\n        long ans[]=new long[arr.length];\\n        for(int i=0;i<arr.length;i++){\\n            if(!sum.containsKey(arr[i])){\\n                sum.put(arr[i],(\\nlong)0);\\n                count.put(arr[i],0);\\n            }\\n         \\n                ans[i]+=(long)i*count.get(arr[i])-sum.get(arr[i]);\\n                sum.put(arr[i],sum.get(arr[i])+i);\\n                count.put(arr[i],count.get(arr[i])+1);\\n           \\n        }\\n        sum=new HashMap<>();\\n        count=new HashMap<>();\\n          for(int i=arr.length-1;i>=0;i--){\\n            if(!sum.containsKey(arr[i])){\\n                sum.put(arr[i],(long)0);\\n                count.put(arr[i],0);\\n            }\\n           \\n                ans[i]+=sum.get(arr[i])-(long)i*count.get(arr[i]);\\n                sum.put(arr[i],sum.get(arr[i])+i);\\n                count.put(arr[i],count.get(arr[i])+1);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649740,
                "title": "python-3-prefix-sum-100-time",
                "content": "![image](https://assets.leetcode.com/users/images/94d97d9d-2c85-4fbf-ad99-a96f7d15278b_1640580050.4046202.png)\\n\\nTake arr = [0, 1, 1, 2, 1, 1, 3, 1] as an example. For all 1s, their indices in arr defines another array, namely idx = [1, 2, 4, 5, 7], which has a length L = 5. prefix_sum of idx = [0, 1, 3, 7, 12, 19].\\n\\nFor the 3rd 1 at arr[4], its index in arr, i = 4; its corresponding index in idx, j = 2.  Calculation of its intervals sum = (4 - 1) + (4 - 2) + (4 - 4) + (5 - 4) + (7 - 4), which can be reformulated as (1 + 2 + 4 + 5 + 7) - 2 * (1 + 2 + 4) + 4 = \\nprefix_sum[-1] - 2 * prefix_sum[j + 1] - (2 * j + 2 - L) * i.\\n\\n```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        N = len(arr)\\n        dc_idx = defaultdict(list)\\n        dc_ps = {}\\n        \\n        for i, v in enumerate(arr):\\n            dc_idx[v].append(i)\\n            if v not in dc_ps:\\n                dc_ps[v] = [0, i]\\n            else:\\n                dc_ps[v].append(i + dc_ps[v][-1])\\n        \\n        ans = [0] * N\\n        for v in dc_idx:\\n            L = len(dc_idx[v])\\n            if L > 1:\\n                for j, i in enumerate(dc_idx[v]):\\n                    ans[i] = dc_ps[v][-1] - 2 * dc_ps[v][j+1] + (2 * j + 2 - L) * i\\n                    \\n        return ans\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        N = len(arr)\\n        dc_idx = defaultdict(list)\\n        dc_ps = {}\\n        \\n        for i, v in enumerate(arr):\\n            dc_idx[v].append(i)\\n            if v not in dc_ps:\\n                dc_ps[v] = [0, i]\\n            else:\\n                dc_ps[v].append(i + dc_ps[v][-1])\\n        \\n        ans = [0] * N\\n        for v in dc_idx:\\n            L = len(dc_idx[v])\\n            if L > 1:\\n                for j, i in enumerate(dc_idx[v]):\\n                    ans[i] = dc_ps[v][-1] - 2 * dc_ps[v][j+1] + (2 * j + 2 - L) * i\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648945,
                "title": "o-n-java-solution-easy-to-understand",
                "content": "```\\nclass Solution{\\n    class Pair{\\n        long sum;\\n        long count;\\n        Pair(long sum,long count){\\n            this.sum=sum;\\n            this.count=count;\\n        }\\n    }\\n    public long[] getDistances(int[] arr) {\\n        long[] result=new long[arr.length];\\n        HashMap<Integer,Pair> hm=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(!hm.containsKey(arr[i])){\\n                hm.put(arr[i],new Pair(i,1));\\n            }else{\\n                Pair temp=hm.get(arr[i]);\\n                long count=temp.count;\\n                long sum=temp.sum;\\n                result[i]+=(count*i-sum);\\n                hm.put(arr[i],new Pair(sum+i,count+1));\\n            }\\n        }\\n        hm=new HashMap<>();\\n        for(int i=arr.length-1;i>=0;i--){\\n            if(!hm.containsKey(arr[i])){\\n                hm.put(arr[i],new Pair(i,1));\\n            }else{\\n                Pair temp=hm.get(arr[i]);\\n                long count=temp.count;\\n                long sum=temp.sum;\\n                result[i]+=(sum-count*i);\\n                hm.put(arr[i],new Pair(sum+i,count+1));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    class Pair{\\n        long sum;\\n        long count;\\n        Pair(long sum,long count){\\n            this.sum=sum;\\n            this.count=count;\\n        }\\n    }\\n    public long[] getDistances(int[] arr) {\\n        long[] result=new long[arr.length];\\n        HashMap<Integer,Pair> hm=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(!hm.containsKey(arr[i])){\\n                hm.put(arr[i],new Pair(i,1));\\n            }else{\\n                Pair temp=hm.get(arr[i]);\\n                long count=temp.count;\\n                long sum=temp.sum;\\n                result[i]+=(count*i-sum);\\n                hm.put(arr[i],new Pair(sum+i,count+1));\\n            }\\n        }\\n        hm=new HashMap<>();\\n        for(int i=arr.length-1;i>=0;i--){\\n            if(!hm.containsKey(arr[i])){\\n                hm.put(arr[i],new Pair(i,1));\\n            }else{\\n                Pair temp=hm.get(arr[i]);\\n                long count=temp.count;\\n                long sum=temp.sum;\\n                result[i]+=(sum-count*i);\\n                hm.put(arr[i],new Pair(sum+i,count+1));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648882,
                "title": "java-detailed-explanation",
                "content": "```\\nThink about the list of indexes for the same elements look like this\\nA: [A(0), A(1), A(2), A(3) ... A(i) ... A(n-1)]  // a list of indexes of the K \\n\\nLet\\'s assume the length of the array is n and in general\\nA = [A(0), A(1), A(2), A(3) ... A(i)... A(n-1)]\\n\\nLet\\'s take A(i) for instance. In order to compute the equation, we need to do something like below -\\n\\nres = |A(i) - A(0)| + |A(i) - A(1)| +  |A(i) - A(i-1)| + ... + |A(i) - A(i+1)| + |A(i) - A(n-1)|. \\n\\nBecause A(i) is greater than all the numbers before A(i) and less than all the numbers after A(i), we\\'re able to refactor the above into following - \\n\\nres = - (A(0) + A(1)... + A(i-1))  +  i * A(i)         + (A(i+1) + ... + A(n-1))    -  (n - i - 1) * A[i]\\n\\t               |                    |                          |                         |\\n\\t               |                    |                          |                         |\\n\\t\\tsum from 0 - (i-1)        first i num of A(i)      sum from (i+1) - (n-1)   last (n-i-1) num of A[i]\\n\\t\\tand flip to negative                                           \\n\\t\\t\\nAs you can see here, a presum array / list would highly improve the efficiency of the algorithm.\\n```\\n\\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        int n = arr.length;\\n        long[] res = new long[n];\\n        \\n        Map<Integer, List<Long>> map = new HashMap<>(); // map from elements to presum list\\n        Map<Integer, Integer> indexes = new HashMap<>(); // an easier way to locate index of the index of elements\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(arr[i])){\\n                List<Long> l = map.get(arr[i]);\\n                l.add(l.get(l.size()-1) + (long)i);\\n                map.put(arr[i], l);\\n            }else{\\n                map.put(arr[i], new ArrayList<>());\\n                map.get(arr[i]).add((long)i);\\n            }\\n            \\n            indexes.put(i, map.get(arr[i]).size()-1);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            int index = indexes.get(i);\\n            List<Long> l = map.get(arr[i]);\\n            \\n            long prefix = index == 0 ? 0 : l.get(index-1);\\n            res[i] = - prefix + (l.get(l.size()-1) - l.get(index)) + (long)i * (index - (l.size()-index-1));// find pattern listed above\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nThink about the list of indexes for the same elements look like this\\nA: [A(0), A(1), A(2), A(3) ... A(i) ... A(n-1)]  // a list of indexes of the K \\n\\nLet\\'s assume the length of the array is n and in general\\nA = [A(0), A(1), A(2), A(3) ... A(i)... A(n-1)]\\n\\nLet\\'s take A(i) for instance. In order to compute the equation, we need to do something like below -\\n\\nres = |A(i) - A(0)| + |A(i) - A(1)| +  |A(i) - A(i-1)| + ... + |A(i) - A(i+1)| + |A(i) - A(n-1)|. \\n\\nBecause A(i) is greater than all the numbers before A(i) and less than all the numbers after A(i), we\\'re able to refactor the above into following - \\n\\nres = - (A(0) + A(1)... + A(i-1))  +  i * A(i)         + (A(i+1) + ... + A(n-1))    -  (n - i - 1) * A[i]\\n\\t               |                    |                          |                         |\\n\\t               |                    |                          |                         |\\n\\t\\tsum from 0 - (i-1)        first i num of A(i)      sum from (i+1) - (n-1)   last (n-i-1) num of A[i]\\n\\t\\tand flip to negative                                           \\n\\t\\t\\nAs you can see here, a presum array / list would highly improve the efficiency of the algorithm.\\n```\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        int n = arr.length;\\n        long[] res = new long[n];\\n        \\n        Map<Integer, List<Long>> map = new HashMap<>(); // map from elements to presum list\\n        Map<Integer, Integer> indexes = new HashMap<>(); // an easier way to locate index of the index of elements\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(arr[i])){\\n                List<Long> l = map.get(arr[i]);\\n                l.add(l.get(l.size()-1) + (long)i);\\n                map.put(arr[i], l);\\n            }else{\\n                map.put(arr[i], new ArrayList<>());\\n                map.get(arr[i]).add((long)i);\\n            }\\n            \\n            indexes.put(i, map.get(arr[i]).size()-1);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            int index = indexes.get(i);\\n            List<Long> l = map.get(arr[i]);\\n            \\n            long prefix = index == 0 ? 0 : l.get(index-1);\\n            res[i] = - prefix + (l.get(l.size()-1) - l.get(index)) + (long)i * (index - (l.size()-index-1));// find pattern listed above\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648689,
                "title": "with-two-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        // lets take the map to store the current value of the index .......\\n        int n=arr.size();\\n        unordered_map<int,queue<long long>>harsh;\\n        unordered_map<int,long long>aksh,precnt,pre;\\n        for(int i=0;i<n;i++)\\n        {\\n            harsh[arr[i]].push(i);\\n            aksh[arr[i]]+=i;\\n        }\\n        vector cnt(n,0ll);\\n        for(int i=0;i<n;i++)\\n        {\\n            long long res=aksh[arr[i]]-1ll*harsh[arr[i]].front()*harsh[arr[i]].size();\\n            res+=1ll*i*precnt[arr[i]]-pre[arr[i]];\\n            pre[arr[i]]+=i;\\n            precnt[arr[i]]++;\\n            cnt[i]=res;\\n            \\n            aksh[arr[i]]-=harsh[arr[i]].front();\\n            harsh[arr[i]].pop();\\n            \\n        }\\n        return cnt;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        // lets take the map to store the current value of the index .......\\n        int n=arr.size();\\n        unordered_map<int,queue<long long>>harsh;\\n        unordered_map<int,long long>aksh,precnt,pre;\\n        for(int i=0;i<n;i++)\\n        {\\n            harsh[arr[i]].push(i);\\n            aksh[arr[i]]+=i;\\n        }\\n        vector cnt(n,0ll);\\n        for(int i=0;i<n;i++)\\n        {\\n            long long res=aksh[arr[i]]-1ll*harsh[arr[i]].front()*harsh[arr[i]].size();\\n            res+=1ll*i*precnt[arr[i]]-pre[arr[i]];\\n            pre[arr[i]]+=i;\\n            precnt[arr[i]]++;\\n            cnt[i]=res;\\n            \\n            aksh[arr[i]]-=harsh[arr[i]].front();\\n            harsh[arr[i]].pop();\\n            \\n        }\\n        return cnt;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648432,
                "title": "csharp-c-with-prefix-sum",
                "content": "if we have [2,1,2,1,2,1,2,1,2], if we are looking for ans[4],\\n\\nans[4] = (4-0)+(4-2) + (6-4) + (8-4)\\n\\n there are two parts, the ones before and after the 4th element.\\n \\n before =  (4-0)+(4-2) , \\n after = (6-4) + (8-4)\\n \\n let\\'s look at *before* first.\\n before = (4-0) + (4-2) = 4 * 2 - (0+2)\\n we can see that (0+2) is the accumulate from the first element to the second. or to say, the indices summation before the ith element (here i is 4). \\n \\n after = (6-4) + (8-4) = (6+8) - 4 * 2.\\n here 6+8 is the sum from (i+1)th to the last. \\n\\n\\n\\n\\n```csharp\\npublic class Solution\\n{\\n    public long[] GetDistances(int[] arr)\\n    {\\n        int n = arr.Length;\\n        Dictionary<int, List<int>> positionMap = new Dictionary<int, List<int>>();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (!positionMap.ContainsKey(arr[i]))\\n            {\\n                positionMap[arr[i]] = new List<int>();\\n            }\\n\\n            positionMap[arr[i]].Add(i);\\n        }\\n\\n        long[] ans = new long[n];\\n        foreach(List<int> list in positionMap.Values)\\n        {\\n            long[] preSums = new long[list.Count + 1];\\n            for(int i = 0; i < list.Count; i++)\\n            {\\n                preSums[i + 1] = preSums[i] + list[i];\\n            }\\n\\n            for(int i = 0; i < list.Count; i++)\\n            {\\n                long v = list[i];\\n                // pre\\n                ans[v] = v * (i+1) - preSums[i+1];\\n                // post\\n                ans[v] += preSums[list.Count] - preSums[i] - v * (list.Count - i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public long[] GetDistances(int[] arr)\\n    {\\n        int n = arr.Length;\\n        Dictionary<int, List<int>> positionMap = new Dictionary<int, List<int>>();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (!positionMap.ContainsKey(arr[i]))\\n            {\\n                positionMap[arr[i]] = new List<int>();\\n            }\\n\\n            positionMap[arr[i]].Add(i);\\n        }\\n\\n        long[] ans = new long[n];\\n        foreach(List<int> list in positionMap.Values)\\n        {\\n            long[] preSums = new long[list.Count + 1];\\n            for(int i = 0; i < list.Count; i++)\\n            {\\n                preSums[i + 1] = preSums[i] + list[i];\\n            }\\n\\n            for(int i = 0; i < list.Count; i++)\\n            {\\n                long v = list[i];\\n                // pre\\n                ans[v] = v * (i+1) - preSums[i+1];\\n                // post\\n                ans[v] += preSums[list.Count] - preSums[i] - v * (list.Count - i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647957,
                "title": "python-prefix-and-suffix-array-solution-with-comments-faster-than-100-python3-solutions",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n\\t\\t# to store all positions of  an element in the array in a list\\n        pos = defaultdict(list)\\n        for i,x in enumerate(arr):\\n            pos[x].append(i)\\n        \\n        # prefix array\\n        pre = [0]*(len(arr))\\n\\t\\t# suffix array\\n        suf = [0]*(len(arr))\\n\\t\\t\\n        ans = [0]*(len(arr))\\n\\t\\t\\n        for elem,l in pos.items():\\n\\t\\t\\t# traversing the positions of each element \\n\\t\\t\\t#\\xA0for prefix\\n            for i in range(1,len(l)):\\n                pre[l[i]] = pre[l[i-1]] + i*(l[i]-l[i-1])\\n\\t\\t\\t\\n\\t\\t\\t# for suffux\\n            for i in range(len(l)-2,-1,-1):\\n                suf[l[i]] = suf[l[i+1]] + (len(l)-1-i)*(l[i+1]-l[i])\\n        \\n\\t\\t\\n        for i in range(len(arr)):\\n            ans[i] += pre[i]+suf[i]\\n\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Suffix Array"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n\\t\\t# to store all positions of  an element in the array in a list\\n        pos = defaultdict(list)\\n        for i,x in enumerate(arr):\\n            pos[x].append(i)\\n        \\n        # prefix array\\n        pre = [0]*(len(arr))\\n\\t\\t# suffix array\\n        suf = [0]*(len(arr))\\n\\t\\t\\n        ans = [0]*(len(arr))\\n\\t\\t\\n        for elem,l in pos.items():\\n\\t\\t\\t# traversing the positions of each element \\n\\t\\t\\t#\\xA0for prefix\\n            for i in range(1,len(l)):\\n                pre[l[i]] = pre[l[i-1]] + i*(l[i]-l[i-1])\\n\\t\\t\\t\\n\\t\\t\\t# for suffux\\n            for i in range(len(l)-2,-1,-1):\\n                suf[l[i]] = suf[l[i+1]] + (len(l)-1-i)*(l[i+1]-l[i])\\n        \\n\\t\\t\\n        for i in range(len(arr)):\\n            ans[i] += pre[i]+suf[i]\\n\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647955,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<long long, vector<long long>> map;\\n        long long n = arr.size();\\n        for(long long i = 0; i<n; ++i) {\\n            map[arr[i]].push_back(i);\\n        }\\n        vector<long long> output(n);\\n        for(auto& [key, row] : map) {\\n            long long prefixSum = 0, totalSum = 0, m = row.size();\\n            for(long long i = 0; i<m; ++i) {\\n                totalSum += row[i];\\n            }\\n            for(long long i = 0; i<m; i++) {\\n                long long suffixSum = totalSum - row[i] - prefixSum;\\n                long long elementsToTheLeft = i;\\n                long long elementsToTheRight = m-i-1;\\n                output[row[i]] = elementsToTheLeft*row[i] - prefixSum + suffixSum - elementsToTheRight*row[i];\\n                prefixSum += row[i];\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<long long, vector<long long>> map;\\n        long long n = arr.size();\\n        for(long long i = 0; i<n; ++i) {\\n            map[arr[i]].push_back(i);\\n        }\\n        vector<long long> output(n);\\n        for(auto& [key, row] : map) {\\n            long long prefixSum = 0, totalSum = 0, m = row.size();\\n            for(long long i = 0; i<m; ++i) {\\n                totalSum += row[i];\\n            }\\n            for(long long i = 0; i<m; i++) {\\n                long long suffixSum = totalSum - row[i] - prefixSum;\\n                long long elementsToTheLeft = i;\\n                long long elementsToTheRight = m-i-1;\\n                output[row[i]] = elementsToTheLeft*row[i] - prefixSum + suffixSum - elementsToTheRight*row[i];\\n                prefixSum += row[i];\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647764,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar getDistances = function(arr) {\\n    let hash = {};\\n    let result = [];\\n    \\n        const calculateSum = (keys, res) => {\\n        for(let key in keys) {\\n            let arr = keys[key];\\n            let prefix = []\\n            prefix[0] = arr[0];\\n            for (let i = 1; i < arr.length; i++) {\\n                prefix[i] = prefix[i-1] + arr[i];\\n            }\\n            \\n            for (let i = 0; i < arr.length; i++) {\\n                let prevSum = (arr[i] * i ) - (prefix[i] - arr[i]);\\n                let next = \\n                    (prefix[prefix.length - 1] - prefix[i]) - arr[i] *                            (arr.length - (i + 1));\\n                let nextSum =  next < 0 ? 0 : next;\\n              \\n                res[arr[i]] = prevSum + nextSum;\\n            }\\n        }\\n            return res\\n    }\\n    for(let i = 0; i< arr.length; i++) {\\n        if(hash[arr[i]]) {\\n            hash[arr[i]].push(i)\\n        } else {\\n            hash[arr[i]] = [i]\\n        }\\n    }\\n     return calculateSum(hash, [])\\n\\n};",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar getDistances = function(arr) {\\n    let hash = {};\\n    let result = [];\\n    \\n        const calculateSum = (keys, res) => {\\n        for(let key in keys) {\\n            let arr = keys[key];\\n            let prefix = []\\n            prefix[0] = arr[0];\\n            for (let i = 1; i < arr.length; i++) {\\n                prefix[i] = prefix[i-1] + arr[i];\\n            }\\n            \\n            for (let i = 0; i < arr.length; i++) {\\n                let prevSum = (arr[i] * i ) - (prefix[i] - arr[i]);\\n                let next = \\n                    (prefix[prefix.length - 1] - prefix[i]) - arr[i] *                            (arr.length - (i + 1));\\n                let nextSum =  next < 0 ? 0 : next;\\n              \\n                res[arr[i]] = prevSum + nextSum;\\n            }\\n        }\\n            return res\\n    }\\n    for(let i = 0; i< arr.length; i++) {\\n        if(hash[arr[i]]) {\\n            hash[arr[i]].push(i)\\n        } else {\\n            hash[arr[i]] = [i]\\n        }\\n    }\\n     return calculateSum(hash, [])\\n\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1647684,
                "title": "o-n-java-clean-solution-prefix-sum",
                "content": "```\\n//store index in map (value - list of indexes)\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        long[] res = new long[arr.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            if (!map.containsKey(arr[i])) map.put(arr[i], new ArrayList<>()); // init list\\n            map.get(arr[i]).add(i);\\n        }\\n        for (int key : map.keySet()) {\\n            List<Integer> indexes = map.get(key);\\n            long sum = 0, pre = 0;\\n            for (int num : indexes) sum += num;\\n            for (int i = 0; i < indexes.size(); i++) { //note that they are ordered since they are indexes, so we can use prefix sum to quick calculate\\n                int num = indexes.get(i);\\n                long left = i * (long)num - pre, right = (sum - pre - num) - (indexes.size() - i - 1) * (long)num; //prefix sum to calculate abs in a faster way. Consider there\\'re left and right parts\\n\\t\\t\\t\\t//left part, i num - pre sum. Right part, sum of right - (n-1-i) num\\n                res[num] = left + right;\\n                pre += num;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nTime complexity should be O(n) n = length of arr array\\nBecause although there are 2 for loops, it actually just visits the arr array twice. One time for calculating sum and another time to get abs diff by prefix sum",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n//store index in map (value - list of indexes)\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        long[] res = new long[arr.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            if (!map.containsKey(arr[i])) map.put(arr[i], new ArrayList<>()); // init list\\n            map.get(arr[i]).add(i);\\n        }\\n        for (int key : map.keySet()) {\\n            List<Integer> indexes = map.get(key);\\n            long sum = 0, pre = 0;\\n            for (int num : indexes) sum += num;\\n            for (int i = 0; i < indexes.size(); i++) { //note that they are ordered since they are indexes, so we can use prefix sum to quick calculate\\n                int num = indexes.get(i);\\n                long left = i * (long)num - pre, right = (sum - pre - num) - (indexes.size() - i - 1) * (long)num; //prefix sum to calculate abs in a faster way. Consider there\\'re left and right parts\\n\\t\\t\\t\\t//left part, i num - pre sum. Right part, sum of right - (n-1-i) num\\n                res[num] = left + right;\\n                pre += num;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647674,
                "title": "python-simple-o-n-solution-prefix-sum-easy-to-understand",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n\\n```\\nclass Solution(object):\\n    def getDistances(self, arr):\\n        dic = collections.defaultdict(list)\\n        ans = [0] * len(arr)\\n        for i, n in enumerate(arr):  # Group the indexes of the same val in arr via defaultdict dic\\n            dic[n].append(i)\\n\\n        for ids in dic.values():  # for each group ids with the same val\\n            if len(ids):\\n                org_ids = copy.deepcopy(ids)  # backup the original ids for update ans\\n                for j in range(len(ids)):  # compute the abs diff to ids[0]\\n                    ids[j] -= org_ids[0]\\n                ans[org_ids[0]] = sum(ids)  # sum the abs diff to ids[0]\\n                prefix = [0] * len(ids)\\n                for j in range(1, len(ids)):\\n                    prefix[j] = prefix[j - 1] + ids[j]\\n                for j in range(1, len(ids)):\\n                    ans[org_ids[j]] = (ans[org_ids[0]]\\n                                       # there are (len(ids) - j - 1) index greater than ids[j], when they minus ids[j],\\n                                       # ans[ans[org_ids[j]]] should minus ids[j] * (len(ids) - j - 1)\\n                                       # based on ans[org_ids[0]]\\n                                       - ids[j] * (len(ids) - j - 1)\\n                                       # there are (j - 1) index less than ids[j] and greater than 0, when they minus\\n                                       # ids[j], ans[ans[org_ids[j]]] should add (j - 1) * ids[j] - 2 * prefix[j - 1]\\n                                       # based on ans[org_ids[0]]\\n                                       + (j - 1) * ids[j] - 2 * prefix[j - 1]\\n                                       )\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getDistances(self, arr):\\n        dic = collections.defaultdict(list)\\n        ans = [0] * len(arr)\\n        for i, n in enumerate(arr):  # Group the indexes of the same val in arr via defaultdict dic\\n            dic[n].append(i)\\n\\n        for ids in dic.values():  # for each group ids with the same val\\n            if len(ids):\\n                org_ids = copy.deepcopy(ids)  # backup the original ids for update ans\\n                for j in range(len(ids)):  # compute the abs diff to ids[0]\\n                    ids[j] -= org_ids[0]\\n                ans[org_ids[0]] = sum(ids)  # sum the abs diff to ids[0]\\n                prefix = [0] * len(ids)\\n                for j in range(1, len(ids)):\\n                    prefix[j] = prefix[j - 1] + ids[j]\\n                for j in range(1, len(ids)):\\n                    ans[org_ids[j]] = (ans[org_ids[0]]\\n                                       # there are (len(ids) - j - 1) index greater than ids[j], when they minus ids[j],\\n                                       # ans[ans[org_ids[j]]] should minus ids[j] * (len(ids) - j - 1)\\n                                       # based on ans[org_ids[0]]\\n                                       - ids[j] * (len(ids) - j - 1)\\n                                       # there are (j - 1) index less than ids[j] and greater than 0, when they minus\\n                                       # ids[j], ans[ans[org_ids[j]]] should add (j - 1) * ids[j] - 2 * prefix[j - 1]\\n                                       # based on ans[org_ids[0]]\\n                                       + (j - 1) * ids[j] - 2 * prefix[j - 1]\\n                                       )\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647664,
                "title": "simple-python-solution-using-hashmap-prefix-and-suffix-sum-approach",
                "content": "\\'\\'\\'\\n\\t******Author : cyberkid05******\\n\\'\\'\\'\\n\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        hp = defaultdict(lambda:[])\\n        for i in range(len(arr)):\\n            hp[arr[i]].append(i)\\n        pre = defaultdict(lambda:0)\\n        suf = defaultdict(lambda:0)\\n        for x in hp.keys():\\n            for i in range(1, len(hp[x])):\\n                pre[hp[x][i]] = pre[hp[x][i - 1]] + i * (hp[x][i] - hp[x][i - 1])\\n        for x in hp.keys():\\n            for i in range(len(hp[x]) - 2, -1, -1):\\n                suf[hp[x][i]] = suf[hp[x][i + 1]] + (len(hp[x]) -1 -i) * (hp[x][i + 1] - hp[x][i])\\n        ans = [0] * len(arr)\\n        for i in range(len(arr)):\\n            ans[i] += (pre[i] + suf[i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        hp = defaultdict(lambda:[])\\n        for i in range(len(arr)):\\n            hp[arr[i]].append(i)\\n        pre = defaultdict(lambda:0)\\n        suf = defaultdict(lambda:0)\\n        for x in hp.keys():\\n            for i in range(1, len(hp[x])):\\n                pre[hp[x][i]] = pre[hp[x][i - 1]] + i * (hp[x][i] - hp[x][i - 1])\\n        for x in hp.keys():\\n            for i in range(len(hp[x]) - 2, -1, -1):\\n                suf[hp[x][i]] = suf[hp[x][i + 1]] + (len(hp[x]) -1 -i) * (hp[x][i + 1] - hp[x][i])\\n        ans = [0] * len(arr)\\n        for i in range(len(arr)):\\n            ans[i] += (pre[i] + suf[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647662,
                "title": "clear-prefix-sum-o-n",
                "content": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n\\t\"\"\"\\n\\tThe key fact is that\\n\\tresult[i] = sum(i - indices below i) + sum(indices above i - i)\\n\\tThis implies\\n\\tresults[i] = sum(indices above i) - sum(indices below i) + \\n\\t\\ti * (number of indices above i - number of indices below i)\\n\\tFortunately, you can update the sums in constant time.\\n\\t\"\"\"\\n        indicesAbove = {}\\n        indicesBelow = {}\\n        runningSumAbove = {}\\n        runningSumBelow = {}\\n        result = [0] * len(arr)\\n        for i, n in enumerate(arr):\\n            if n not in indicesAbove:\\n                indicesAbove[n] = 1\\n                indicesBelow[n] = 0\\n                runningSumAbove[n] = i\\n                runningSumBelow[n] = 0\\n            else:\\n                indicesAbove[n] += 1\\n                runningSumAbove[n] += i\\n        # result = sum of numbers above - sum of #s below + pivot * (Nb - Na)\\n        for i, n in enumerate(arr):\\n            runningSumAbove[n] -= i\\n            indicesAbove[n] -= 1\\n            result[i] = runningSumAbove[n] - runningSumBelow[n] + i * (indicesBelow[n] - indicesAbove[n])\\n            indicesBelow[n] += 1\\n            runningSumBelow[n] += i\\n            \\n            \\n        return result\\n\\t\\t```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n\\t\"\"\"\\n\\tThe key fact is that\\n\\tresult[i] = sum(i - indices below i) + sum(indices above i - i)\\n\\tThis implies\\n\\tresults[i] = sum(indices above i) - sum(indices below i) + \\n\\t\\ti * (number of indices above i - number of indices below i)\\n\\tFortunately, you can update the sums in constant time.\\n\\t\"\"\"\\n        indicesAbove = {}\\n        indicesBelow = {}\\n        runningSumAbove = {}\\n        runningSumBelow = {}\\n        result = [0] * len(arr)\\n        for i, n in enumerate(arr):\\n            if n not in indicesAbove:\\n                indicesAbove[n] = 1\\n                indicesBelow[n] = 0\\n                runningSumAbove[n] = i\\n                runningSumBelow[n] = 0\\n            else:\\n                indicesAbove[n] += 1\\n                runningSumAbove[n] += i\\n        # result = sum of numbers above - sum of #s below + pivot * (Nb - Na)\\n        for i, n in enumerate(arr):\\n            runningSumAbove[n] -= i\\n            indicesAbove[n] -= 1\\n            result[i] = runningSumAbove[n] - runningSumBelow[n] + i * (indicesBelow[n] - indicesAbove[n])\\n            indicesBelow[n] += 1\\n            runningSumBelow[n] += i\\n            \\n            \\n        return result\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1647623,
                "title": "python-hash-and-prefix-sum",
                "content": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        res = [0] * len(arr)\\n        \\n\\t\\t# hashMap stores [number of the same value as arr[i] seen so far, sum of those values\\' indexes]\\n        hashMap = {}\\n        for i in range(len(arr)):\\n            if arr[i] not in hashMap:\\n                hashMap[arr[i]] = [1, i]\\n            else:\\n                hashMap[arr[i]][0] += 1\\n                hashMap[arr[i]][1] += i\\n\\t\\t\\t# ex. arr = [1, 1, 1], suppose i = 2, hashMap[arr[i]][0] = 3, hashMap[arr[i]][1] = 0 + 1 + 2 = 3, res[2] = 2 * 3 - 3 = 3\\n            res[i] += i * hashMap[arr[i]][0] - hashMap[arr[i]][1]\\n        \\n\\t\\t# traverse again to deal with the suffix sum, similar logic as above\\n        hashMap = {}\\n        for i in range(len(arr)-1, -1, -1):\\n            if arr[i] not in hashMap:\\n                hashMap[arr[i]] = [1, i]\\n            else:\\n                hashMap[arr[i]][0] += 1\\n                hashMap[arr[i]][1] += i\\n            res[i] += hashMap[arr[i]][1] - i * hashMap[arr[i]][0]\\n                \\n        return res",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        res = [0] * len(arr)\\n        \\n\\t\\t# hashMap stores [number of the same value as arr[i] seen so far, sum of those values\\' indexes]\\n        hashMap = {}",
                "codeTag": "Java"
            },
            {
                "id": 1647549,
                "title": "java-o-n-prefix-and-suffix-sum-previous-and-next-element-index-inline-comments",
                "content": "**Theme:**\\nWe divide the problem in 2 part.\\n1. For each index, we try to bring all the same numbers which are to its right on given position\\n2. For each index, we try to bring all the same numbers which are to its left on given position\\n\\n**Formula**\\nImagine you are at position ```i```, and same number is at position ```j, such that  j > i```. Now all the same numbers which are to the right of ```j```, we first need to bring them to ```j``` and then to ```i```. So if we know how many steps it will take to move all numbers to ```j```, then in one go, we can move all those to ```i``` with ```(j - i)``` steps.\\n\\n```\\nclass Solution {\\n    int max = 100000 + 1;\\n    public long[] getDistances(int[] arr) {\\n        int n = arr.length;\\n        int[] fr = new int[max]; // frequency of this number till now from right\\n        long[] distr = new long[n]; // ans so far on given index considering all numbers to its right only\\n        int[] li = new int[max]; // last seen index of this number\\n        fr[arr[n - 1]]++;\\n        li[arr[n-1]] = n - 1;\\n        for(int i = n - 2; i >= 0; i--) {\\n            int num = arr[i];\\n            if(fr[num] > 0)  // if we are seeing this first time, then do nothing!\\n                distr[i] = distr[li[num]] + fr[num] * (li[num] - i);\\n            fr[num]++;\\n            li[num] = i;\\n        }\\n        \\n        int[] fl = new int[max]; // frequency of this number till now from left\\n        long[] distl = new long[n]; // // ans so far on given index considering all numbers to its left only\\n        int[] pi = new int[max]; // previous seen index of this number\\n        fl[arr[0]]++;\\n        pi[arr[0]] = 0;\\n        for(int i = 1; i < n; i++) {\\n            int num = arr[i];\\n            if(fl[num] > 0)  // if we are seeing this first time, then do nothing!\\n                distl[i] = distl[pi[num]] + fl[num] * (i - pi[num]);\\n            fl[num]++;\\n            pi[num] = i;\\n        }\\n        long[] ans = new long[n];\\n        for(int i = 0; i < n; i++)\\n            ans[i] = distl[i] + distr[i];\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```i```\n```j, such that  j > i```\n```j```\n```j```\n```i```\n```j```\n```i```\n```(j - i)```\n```\\nclass Solution {\\n    int max = 100000 + 1;\\n    public long[] getDistances(int[] arr) {\\n        int n = arr.length;\\n        int[] fr = new int[max]; // frequency of this number till now from right\\n        long[] distr = new long[n]; // ans so far on given index considering all numbers to its right only\\n        int[] li = new int[max]; // last seen index of this number\\n        fr[arr[n - 1]]++;\\n        li[arr[n-1]] = n - 1;\\n        for(int i = n - 2; i >= 0; i--) {\\n            int num = arr[i];\\n            if(fr[num] > 0)  // if we are seeing this first time, then do nothing!\\n                distr[i] = distr[li[num]] + fr[num] * (li[num] - i);\\n            fr[num]++;\\n            li[num] = i;\\n        }\\n        \\n        int[] fl = new int[max]; // frequency of this number till now from left\\n        long[] distl = new long[n]; // // ans so far on given index considering all numbers to its left only\\n        int[] pi = new int[max]; // previous seen index of this number\\n        fl[arr[0]]++;\\n        pi[arr[0]] = 0;\\n        for(int i = 1; i < n; i++) {\\n            int num = arr[i];\\n            if(fl[num] > 0)  // if we are seeing this first time, then do nothing!\\n                distl[i] = distl[pi[num]] + fl[num] * (i - pi[num]);\\n            fl[num]++;\\n            pi[num] = i;\\n        }\\n        long[] ans = new long[n];\\n        for(int i = 0; i < n; i++)\\n            ans[i] = distl[i] + distr[i];\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647536,
                "title": "python-forward-and-backward-passes",
                "content": "To calculate the sum of intervals on one side, we only need to keep track of the `total` sum of indices of identical elements and the count `c`. Then the sum of intervals from the current element to the identical elements on the right is `total - c * i` and to the identical elements on the left is `c * i - total`, so just add them up.\\n\\nTime / space complexity: O(n)\\n \\n```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        d = collections.defaultdict(lambda: [0, 0])\\n        n = len(arr)\\n        ans = [None] * n\\n        for i in reversed(range(n)):\\n            c, total = d[arr[i]]\\n            ans[i] = total - c * i\\n            d[arr[i]][0] += 1\\n            d[arr[i]][1] += i\\n        d = collections.defaultdict(lambda: [0, 0])\\n        for i in range(n):\\n            c, total = d[arr[i]]\\n            ans[i] += c * i - total\\n            d[arr[i]][0] += 1\\n            d[arr[i]][1] += i\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        d = collections.defaultdict(lambda: [0, 0])\\n        n = len(arr)\\n        ans = [None] * n\\n        for i in reversed(range(n)):\\n            c, total = d[arr[i]]\\n            ans[i] = total - c * i\\n            d[arr[i]][0] += 1\\n            d[arr[i]][1] += i\\n        d = collections.defaultdict(lambda: [0, 0])\\n        for i in range(n):\\n            c, total = d[arr[i]]\\n            ans[i] += c * i - total\\n            d[arr[i]][0] += 1\\n            d[arr[i]][1] += i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647528,
                "title": "hashmap-solution",
                "content": "```\\npublic long[] getDistances(int[] arr) {\\n        long[] res = new long[arr.length];\\n        Map<Integer, List<Integer>> map1 = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            if (map1.get(arr[i]) == null) {\\n                map1.put(arr[i], new ArrayList<>());\\n            }\\n            map1.get(arr[i]).add(i);\\n        }\\n        Map<List<Integer>, Long> map2 = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            long cur = 0;\\n            if (map1.get(arr[i]).size() < 2) {\\n                continue;\\n            }\\n            for (int j : map1.get(arr[i])) {\\n                if (j == i) {\\n                    continue;\\n                }\\n                List<Integer> key1 = new ArrayList<>(), key2 = new ArrayList<>();\\n                key1.add(i);key1.add(j);\\n                key2.add(j);key2.add(i);\\n                if (map2.containsKey(key1)) {\\n                    cur += map2.get(key1);\\n                    continue;\\n                } else if (map2.containsKey(key2)) {\\n                    cur += map2.get(key2);\\n                    continue;\\n                } else {\\n                    map2.put(key1, (long)Math.abs(i - j));\\n                    map2.put(key2, (long)Math.abs(i - j));\\n                    cur += (long)Math.abs(i - j);\\n                }\\n            }\\n            // System.out.println(map2.values().size());\\n            res[i] = cur;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic long[] getDistances(int[] arr) {\\n        long[] res = new long[arr.length];\\n        Map<Integer, List<Integer>> map1 = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            if (map1.get(arr[i]) == null) {\\n                map1.put(arr[i], new ArrayList<>());\\n            }\\n            map1.get(arr[i]).add(i);\\n        }\\n        Map<List<Integer>, Long> map2 = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            long cur = 0;\\n            if (map1.get(arr[i]).size() < 2) {\\n                continue;\\n            }\\n            for (int j : map1.get(arr[i])) {\\n                if (j == i) {\\n                    continue;\\n                }\\n                List<Integer> key1 = new ArrayList<>(), key2 = new ArrayList<>();\\n                key1.add(i);key1.add(j);\\n                key2.add(j);key2.add(i);\\n                if (map2.containsKey(key1)) {\\n                    cur += map2.get(key1);\\n                    continue;\\n                } else if (map2.containsKey(key2)) {\\n                    cur += map2.get(key2);\\n                    continue;\\n                } else {\\n                    map2.put(key1, (long)Math.abs(i - j));\\n                    map2.put(key2, (long)Math.abs(i - j));\\n                    cur += (long)Math.abs(i - j);\\n                }\\n            }\\n            // System.out.println(map2.values().size());\\n            res[i] = cur;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647500,
                "title": "prefix-sum-o-n-easy-explanation",
                "content": "Store the indices of each elements, since maximum is only 10^5, we can maintain an array of vectors for that. Since i wanted to make sure we are not visiting any elements twice, so i created a visited array and prefix array for indices position. \\n\\nif indices array for element 3 is --> [2,5,6]\\n(which means 3 is present at position 2,5,6)\\n\\nthen i created a prefix array for it, i.e [0,2,7,13]\\n\\nNow, iterating over indexes of 3,\\nfirst element is 2, so the contribution of 2 is nothing but sum ahead - ( 2 * no. of elements ahead)\\nsecond element is 5, so its contribution is sum ahead - (5 * no. of elements ahead) + sum before 5 - (5 * no. of elements before 5)\\nand so on..\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<long long> ans(n);\\n        vector<long long> indices[100005],visit(100005,0),prefix[100005],visitpre(100005,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            indices[arr[i]].push_back(i);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visitpre[arr[i]])continue;\\n            vector<long long> temp = indices[arr[i]];\\n            long long sum=0;\\n            for(int i=1;i<temp.size();i++)\\n            {\\n                temp[i]+=temp[i-1];\\n            }\\n            vector<long long> pre;\\n            pre.push_back(0);\\n            for(int i=0;i<temp.size();i++)pre.push_back(temp[i]);\\n            prefix[arr[i]] = pre;\\n            visitpre[arr[i]]=1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visit[arr[i]])continue;\\n            visit[arr[i]]=1;\\n            for(int j=1;j<prefix[arr[i]].size();j++)\\n            {\\n                long long front = prefix[arr[i]][prefix[arr[i]].size()-1]-prefix[arr[i]][j];\\n                long long back = prefix[arr[i]][j-1];\\n                long long mul = indices[arr[i]][j-1];\\n                ans[indices[arr[i]][j-1]] = (mul*(j-1)-back)+(front-mul*(prefix[arr[i]].size()-(j)-1));\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<long long> ans(n);\\n        vector<long long> indices[100005],visit(100005,0),prefix[100005],visitpre(100005,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            indices[arr[i]].push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1647468,
                "title": "pythoooooon",
                "content": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        \\n        dic = {}\\n        for i in range(len(arr)) :\\n            if arr[i] in dic :\\n                dic[arr[i]].append(i)\\n            else:\\n                dic[arr[i]] = [i]\\n        res = [0]*len(arr)\\n\\n        for key in dic :\\n            if len(dic[key]) == 1:\\n                res[dic[key][0]] = 0\\n            else:\\n                temp = []\\n                n = len(dic[key])\\n                curr = 0\\n                for i in dic[key] :\\n                    curr += i\\n                    temp.append(curr)\\n                \\n                for i in range(n) :\\n                    if i==0 : \\n                        c = 0\\n                    else:\\n                        c = temp[i-1] \\n\\n                    res[dic[key][i]] = (i*dic[key][i])-(c) + (curr - temp[i]) - (n-i-1)*dic[key][i]\\n                    \\n        return res\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        \\n        dic = {}\\n        for i in range(len(arr)) :\\n            if arr[i] in dic :\\n                dic[arr[i]].append(i)\\n            else:\\n                dic[arr[i]] = [i]\\n        res = [0]*len(arr)\\n\\n        for key in dic :\\n            if len(dic[key]) == 1:\\n                res[dic[key][0]] = 0\\n            else:\\n                temp = []\\n                n = len(dic[key])\\n                curr = 0\\n                for i in dic[key] :\\n                    curr += i\\n                    temp.append(curr)\\n                \\n                for i in range(n) :\\n                    if i==0 : \\n                        c = 0\\n                    else:\\n                        c = temp[i-1] \\n\\n                    res[dic[key][i]] = (i*dic[key][i])-(c) + (curr - temp[i]) - (n-i-1)*dic[key][i]\\n                    \\n        return res\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647466,
                "title": "c-prefix-sum-and-binary-search",
                "content": "In this problem we insert the indices of the same number to an unordered_map of int and vector<int> which the key is all the indicies for that number. \\nThen we create a prefix sum of the previous map, this new unordered_map we call it mpPfSum.\\nNow, we can do binary search over the numbers in mpPfSum value and do math to calculate the value and insert it into the final return vector.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<int,vector<int>> mp;\\n        for(int i = 0;i<arr.size();i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        unordered_map<int,vector<long long>> mpPfSum; // Prefix sum for the index counts\\n        for (auto it = mp.begin();it!=mp.end();++it){\\n            mpPfSum[(*it).first].push_back((*it).second[0]);\\n            for (int i = 1;i<(*it).second.size();i++){\\n                mpPfSum[(*it).first].push_back((*it).second[i]+mpPfSum[(*it).first].back());\\n            }\\n        }\\n        vector<long long> ret;\\n        int lo;\\n        int hi;\\n        int mid;\\n        for(int i = 0;i<arr.size();i++){\\n            lo = 0;\\n            hi = mp[arr[i]].size()-1;\\n            while(lo<=hi){\\n                mid = lo + (hi-lo)/2;\\n                if (mp[arr[i]][mid]==i){\\n                    break;\\n                }\\n                if (mp[arr[i]][mid]<i){\\n                    lo = mid+1;\\n                    continue;\\n                }\\n                if (mp[arr[i]][mid]>i){\\n                    hi = mid-1;\\n                    continue;\\n                }\\n            }\\n            ret.push_back((long long)((long long)i*(mid+1)-mpPfSum[arr[i]][mid])+\\n                          (long long)(mpPfSum[arr[i]].back()-mpPfSum[arr[i]][mid]-(long long)i*(mp[arr[i]].size()-mid-1)));\\n        }\\n        return ret;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<int,vector<int>> mp;\\n        for(int i = 0;i<arr.size();i++){\\n            mp[arr[i]].push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1647455,
                "title": "java-two-loops-with-dp",
                "content": "Use map to keep prefix and suffix for **count and sum of index** with DP\\n\\n```\\npublic class Solution {\\n  public long[] getDistances(int[] arr) {\\n    int n = arr.length;\\n    long[] result = new long[n];\\n    // number => [count of index, sum of index]\\n    Map<Integer, long[]> map = new HashMap<>();\\n    for (int index = 0; index < n; index++) {\\n      map.putIfAbsent(arr[index], new long[2]);\\n      long[] dp = map.get(arr[index]);\\n      result[index] += dp[0] * index - dp[1];\\n      dp[0]++;\\n      dp[1] += index;\\n    }\\n    // clear map\\n    map.clear();\\n\\n    for (int index = n - 1; index >= 0; index--) {\\n      map.putIfAbsent(arr[index], new long[2]);\\n      long[] dp = map.get(arr[index]);\\n      result[index] += dp[1] - dp[0] * index;\\n      dp[0]++;\\n      dp[1] += index;\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n  public long[] getDistances(int[] arr) {\\n    int n = arr.length;\\n    long[] result = new long[n];\\n    // number => [count of index, sum of index]\\n    Map<Integer, long[]> map = new HashMap<>();\\n    for (int index = 0; index < n; index++) {\\n      map.putIfAbsent(arr[index], new long[2]);\\n      long[] dp = map.get(arr[index]);\\n      result[index] += dp[0] * index - dp[1];\\n      dp[0]++;\\n      dp[1] += index;\\n    }\\n    // clear map\\n    map.clear();\\n\\n    for (int index = n - 1; index >= 0; index--) {\\n      map.putIfAbsent(arr[index], new long[2]);\\n      long[] dp = map.get(arr[index]);\\n      result[index] += dp[1] - dp[0] * index;\\n      dp[0]++;\\n      dp[1] += index;\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030927,
                "title": "solution-using-hashmap-and-prefixsum-with-comments",
                "content": "# Code\\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        long[] res = new long[arr.length];\\n\\n        Map<Integer, ArrayList<Integer>> map = new HashMap<>();\\n\\n        for (int i=0; i<arr.length; i++) {\\n            map.putIfAbsent(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n\\n        for (List<Integer> indices: map.values()) {\\n            \\n            long sum = 0;\\n\\n            for(int e: indices) {\\n                sum += e;\\n            }\\n\\n            long prefixSum = 0;\\n            int size = indices.size();\\n\\n            for (long i=0; i<size; i++) {\\n                int index = indices.get((int)i);\\n\\n                /* If indices are A B C D E F , to calculate D \\n                (D-A) + (D-B) + (D-C) + (E-D) + (F-D) -> 3 * D - (A + B + C) - 2 * D * (E + F)\\n\\n                Here, \\n                1. We are keeping prefixSum to store sum of left elements. \\n                2. \\'i\\' denotes occurences. \\n                3. \\'index\\' denotes the value ( Ex: \\'D\\' in above case)\\n                4. To calculate sum of right elements, we are subtracting index and prefixSum from overall sum. \\n                5. To calculate no of right elements, overall size - current index ( \\'i\\' ) - 1.\\n                */\\n\\n                res[index] = (index * i - prefixSum ) + (sum - prefixSum - index) - (size - i - 1) * index;\\n                prefixSum += index;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        long[] res = new long[arr.length];\\n\\n        Map<Integer, ArrayList<Integer>> map = new HashMap<>();\\n\\n        for (int i=0; i<arr.length; i++) {\\n            map.putIfAbsent(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n\\n        for (List<Integer> indices: map.values()) {\\n            \\n            long sum = 0;\\n\\n            for(int e: indices) {\\n                sum += e;\\n            }\\n\\n            long prefixSum = 0;\\n            int size = indices.size();\\n\\n            for (long i=0; i<size; i++) {\\n                int index = indices.get((int)i);\\n\\n                /* If indices are A B C D E F , to calculate D \\n                (D-A) + (D-B) + (D-C) + (E-D) + (F-D) -> 3 * D - (A + B + C) - 2 * D * (E + F)\\n\\n                Here, \\n                1. We are keeping prefixSum to store sum of left elements. \\n                2. \\'i\\' denotes occurences. \\n                3. \\'index\\' denotes the value ( Ex: \\'D\\' in above case)\\n                4. To calculate sum of right elements, we are subtracting index and prefixSum from overall sum. \\n                5. To calculate no of right elements, overall size - current index ( \\'i\\' ) - 1.\\n                */\\n\\n                res[index] = (index * i - prefixSum ) + (sum - prefixSum - index) - (size - i - 1) * index;\\n                prefixSum += index;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991414,
                "title": "easy-solution-c-map-and-maths",
                "content": "# Intuition\\nMain task is to cater the the absolute difference part, determine how to formulate in one go instead of iterating.\\n\\n# Approach\\nMaintain left count, right count and left sum, right sum which will help calculate in one go\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n            \\n        vector<long long> ans(n, 0);\\n        \\n        map<int, vector<int>> m;\\n        \\n        for(int i=0; i<n; i++){\\n            m[arr[i]].push_back(i);\\n        }\\n        \\n        for(auto v:m){\\n            if(v.second.size() > 1){\\n                long long sum = 0;\\n                for(int i=0; i<v.second.size(); i++){\\n                    sum += v.second[i];\\n                }\\n            \\n                long long lc = 0;\\n                long long rc = v.second.size() - 1;\\n                long long ls = 0;\\n                long long rs = sum - v.second[0];\\n                ans[v.second[0]] = (v.second[0]*1ll*lc - ls) + (rs - v.second[0]*1ll*rc);    \\n                \\n                for(long long i=1; i<v.second.size(); i++){\\n                    lc = i;\\n                    rc = v.second.size() - 1 - i;\\n                    ls = sum - rs;\\n                    rs = sum - v.second[i] - ls;\\n                    \\n                    ans[v.second[i]] = (v.second[i]*1ll*lc - ls) + (rs - v.second[i]*1ll*rc);    \\n                    \\n                    \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n            \\n        vector<long long> ans(n, 0);\\n        \\n        map<int, vector<int>> m;\\n        \\n        for(int i=0; i<n; i++){\\n            m[arr[i]].push_back(i);\\n        }\\n        \\n        for(auto v:m){\\n            if(v.second.size() > 1){\\n                long long sum = 0;\\n                for(int i=0; i<v.second.size(); i++){\\n                    sum += v.second[i];\\n                }\\n            \\n                long long lc = 0;\\n                long long rc = v.second.size() - 1;\\n                long long ls = 0;\\n                long long rs = sum - v.second[0];\\n                ans[v.second[0]] = (v.second[0]*1ll*lc - ls) + (rs - v.second[0]*1ll*rc);    \\n                \\n                for(long long i=1; i<v.second.size(); i++){\\n                    lc = i;\\n                    rc = v.second.size() - 1 - i;\\n                    ls = sum - rs;\\n                    rs = sum - v.second[i] - ls;\\n                    \\n                    ans[v.second[i]] = (v.second[i]*1ll*lc - ls) + (rs - v.second[i]*1ll*rc);    \\n                    \\n                    \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879267,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        long pref[][]=new long[arr.length][2];\\n        long suff[][]=new long[arr.length][2];\\n        HashMap<Integer,Long> h1=new HashMap<Integer,Long>();\\n        HashMap<Integer,Long> h2=new HashMap<Integer,Long>();\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(!h1.containsKey(arr[i]))\\n            {\\n                long x=i;\\n                h1.put(arr[i],x);\\n                h2.put(arr[i],1l);\\n                pref[i][0]=0;\\n                pref[i][1]=0;\\n            }\\n            else\\n            {\\n                pref[i][0]=h1.get(arr[i]);\\n                pref[i][1]=h2.get(arr[i]);\\n                h1.put(arr[i],h1.get(arr[i])+i);\\n                h2.put(arr[i],h2.get(arr[i])+1);\\n            }\\n        }\\n       h1=new HashMap<Integer,Long>();\\n       h2=new HashMap<Integer,Long>();\\n        for(int i=arr.length-1;i>=0;i--)\\n        {\\n            if(!h1.containsKey(arr[i]))\\n            {\\n                long x=i;\\n                h1.put(arr[i],x);\\n                h2.put(arr[i],1l);\\n                suff[i][0]=0;\\n                suff[i][1]=0;\\n            }\\n            else\\n            {\\n                suff[i][0]=h1.get(arr[i]);\\n                suff[i][1]=h2.get(arr[i]);\\n                h1.put(arr[i],h1.get(arr[i])+i);\\n                h2.put(arr[i],h2.get(arr[i])+1);\\n            }\\n        }\\n        long result[]=new long[arr.length];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            result[i]=((pref[i][1]*i)-(pref[i][0]))+(suff[i][0]-(suff[i][1]*i));\\n           \\n        }\\n\\n        return result;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        long pref[][]=new long[arr.length][2];\\n        long suff[][]=new long[arr.length][2];\\n        HashMap<Integer,Long> h1=new HashMap<Integer,Long>();\\n        HashMap<Integer,Long> h2=new HashMap<Integer,Long>();\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(!h1.containsKey(arr[i]))\\n            {\\n                long x=i;\\n                h1.put(arr[i],x);\\n                h2.put(arr[i],1l);\\n                pref[i][0]=0;\\n                pref[i][1]=0;\\n            }\\n            else\\n            {\\n                pref[i][0]=h1.get(arr[i]);\\n                pref[i][1]=h2.get(arr[i]);\\n                h1.put(arr[i],h1.get(arr[i])+i);\\n                h2.put(arr[i],h2.get(arr[i])+1);\\n            }\\n        }\\n       h1=new HashMap<Integer,Long>();\\n       h2=new HashMap<Integer,Long>();\\n        for(int i=arr.length-1;i>=0;i--)\\n        {\\n            if(!h1.containsKey(arr[i]))\\n            {\\n                long x=i;\\n                h1.put(arr[i],x);\\n                h2.put(arr[i],1l);\\n                suff[i][0]=0;\\n                suff[i][1]=0;\\n            }\\n            else\\n            {\\n                suff[i][0]=h1.get(arr[i]);\\n                suff[i][1]=h2.get(arr[i]);\\n                h1.put(arr[i],h1.get(arr[i])+i);\\n                h2.put(arr[i],h2.get(arr[i])+1);\\n            }\\n        }\\n        long result[]=new long[arr.length];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            result[i]=((pref[i][1]*i)-(pref[i][0]))+(suff[i][0]-(suff[i][1]*i));\\n           \\n        }\\n\\n        return result;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874302,
                "title": "10-line-c-simplest-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<long long> incomdis(100001,0);\\n        vector<long long> incomcount(100001,0);\\n        vector<long long> passdis(100001,0);\\n        vector<long long> passcount(100001,0);\\n        vector<long long> ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            incomdis[nums[i]]+=i;\\n            incomcount[nums[i]]++;\\n        }\\n        int temp;\\n        for(int i=0;i<n;i++)\\n        {\\n            temp=nums[i];\\n            ans[i]+=incomdis[temp]-incomcount[temp]--*i;\\n            ans[i]+=(i*passcount[temp]++)-passdis[temp];\\n            incomdis[temp]-=i;\\n            passdis[temp]+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<long long> incomdis(100001,0);\\n        vector<long long> incomcount(100001,0);\\n        vector<long long> passdis(100001,0);\\n        vector<long long> passcount(100001,0);\\n        vector<long long> ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            incomdis[nums[i]]+=i;\\n            incomcount[nums[i]]++;\\n        }\\n        int temp;\\n        for(int i=0;i<n;i++)\\n        {\\n            temp=nums[i];\\n            ans[i]+=incomdis[temp]-incomcount[temp]--*i;\\n            ans[i]+=(i*passcount[temp]++)-passdis[temp];\\n            incomdis[temp]-=i;\\n            passdis[temp]+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868201,
                "title": "python-solution-faster-than-100-of-submissions-uses-93-less-memory",
                "content": "# Approach\\nTo solve this problem, we create a dictionary named indexes, where each key represents an unique element in the input array and the corresponding value represents an array of indices where that unique element is found in the array.\\n\\nWe iterate over the dictionary values and calculate the total prefix and total sum of each group of indices. For each value of k and ind in group, we calculate the total interval between elements arr[ind] and all other elements with that same value present in the input array. This is done by subtracting the interval between ind and each element in group from total.\\n\\nFor each iteration of the loop, we keep updating prefix and arr[ind] to their respective values to reduce time complexity.\\n\\nFinally, we return the updated input array arr with all intervals calculated.\\n\\n# Complexity\\n## Time Complexity: O(n), where n is the length of the input array.\\n\\nThe time complexity of the program includes creating the dictionary indexes, calculating the prefix and total sum of each group of indices, and calculating the intervals between each element with same value. All of these operations take O(n) time.\\n\\nTherefore, the overall time complexity of the program is O(n).\\n\\n## Space Complexity: O(n)\\n\\nThe dictionary indexes will contain a maximum of n unique keys and the corresponding values can contain at most n elements. Therefore, the space complexity of the program is O(n).\\n\\n# Code\\n```\\nclass Solution:\\n    def getDistances(self, nums: List[int]) -> List[int]:\\n        # Create a dictionary to store the indices of each unique number\\n        unique_nums = defaultdict(list)\\n        for index, num in enumerate(nums):\\n            unique_nums[num].append(index)\\n\\n        # Loop through all the unique numbers and calculate the intervals between all the elements\\n        for index_group in unique_nums.values():\\n            prefix_sum = 0\\n            suffix_sum = sum(index_group)\\n            group_length = len(index_group) - 1\\n            for k, index in enumerate(index_group):\\n                intervals = suffix_sum - 2 * prefix_sum - (group_length - 2 * k + 1) * index\\n                nums[index] = intervals\\n                prefix_sum += index\\n\\n        # Return the updated array with all the intervals calculated\\n        return nums\\n\\n```\\n# Core logic\\nThe main logic goes in this part of the code:\\n```\\nintervals = suffix_sum - 2 * prefix_sum - (group_length - 2 * k + 1) * index\\n```\\nFirstly, `suffix_sum` is the sum of all indices in the current group of unique numbers, and `prefix_sum` is the sum of all indices up to the current index being processed. We can think of these two variables as representing the sum of all indices after and including the current index, and the sum of all indices before the current index, respectively.\\n\\nSo `suffix_sum - prefix_sum` would give us the sum of all indices after the current index, or *\"suffix\"* to the current index. But why subtract `2 * prefix_sum` from suffix_sum? Well, `prefix_sum` is actually the sum of all indices before the current index, but we want the sum of all indices after the current index as well. So we subtract `prefix_sum` a second time to get the sum of all indices after the current index.\\n\\nHowever, we\\'ve now double-subtracted the indices before the current index, so we need to add them back in to get the total sum of all indices in the group (i.e. suffix_sum). We do this by subtracting `2 * prefix_sum`.\\n\\nNow we\\'re left with the last term in the equation, `(group_length - 2 * k + 1) * index`. This term is the product of two factors:\\n\\n`(group_length - 2 * k + 1)`: This factor represents the number of indices between the current index and the last index in the group of unique numbers. We subtract 2 times k because we have already processed the first k indices in the group, and the \"+1\" is necessary to compensate for the fact that group_length is one less than the total number of indices in the group.\\n\\nindex: This factor is the index being processed in the current iteration.\\n\\nMultiplying these two factors gives us the total sum of all distances between the current index and all indices in the group of unique numbers.\\n\\nSo putting it all together, intervals is the total distance between the current index and all indices in the group of unique numbers.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDistances(self, nums: List[int]) -> List[int]:\\n        # Create a dictionary to store the indices of each unique number\\n        unique_nums = defaultdict(list)\\n        for index, num in enumerate(nums):\\n            unique_nums[num].append(index)\\n\\n        # Loop through all the unique numbers and calculate the intervals between all the elements\\n        for index_group in unique_nums.values():\\n            prefix_sum = 0\\n            suffix_sum = sum(index_group)\\n            group_length = len(index_group) - 1\\n            for k, index in enumerate(index_group):\\n                intervals = suffix_sum - 2 * prefix_sum - (group_length - 2 * k + 1) * index\\n                nums[index] = intervals\\n                prefix_sum += index\\n\\n        # Return the updated array with all the intervals calculated\\n        return nums\\n\\n```\n```\\nintervals = suffix_sum - 2 * prefix_sum - (group_length - 2 * k + 1) * index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788296,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        N = len(arr)\\n        lookup = defaultdict(list)\\n\\n\\n        for index, num in enumerate(arr):\\n            lookup[num].append(index)\\n\\n\\n        ans = [0] * N\\n\\n        def calc(x):\\n            xArr = lookup[x]\\n\\n            total = 0\\n\\n            for i in range(1, len(xArr)):\\n                total += xArr[i] - xArr[0]\\n\\n            ans[xArr[0]] = total\\n\\n            for i in range(1, len(xArr)):\\n                total += (xArr[i] - xArr[i - 1]) * (i)\\n                total -= (xArr[i] - xArr[i - 1]) * (len(xArr) - i)\\n                ans[xArr[i]] = total\\n\\n\\n        for num in list(lookup.keys()):\\n            calc(num)\\n\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        N = len(arr)\\n        lookup = defaultdict(list)\\n\\n\\n        for index, num in enumerate(arr):\\n            lookup[num].append(index)\\n\\n\\n        ans = [0] * N\\n\\n        def calc(x):\\n            xArr = lookup[x]\\n\\n            total = 0\\n\\n            for i in range(1, len(xArr)):\\n                total += xArr[i] - xArr[0]\\n\\n            ans[xArr[0]] = total\\n\\n            for i in range(1, len(xArr)):\\n                total += (xArr[i] - xArr[i - 1]) * (i)\\n                total -= (xArr[i] - xArr[i - 1]) * (len(xArr) - i)\\n                ans[xArr[i]] = total\\n\\n\\n        for num in list(lookup.keys()):\\n            calc(num)\\n\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784611,
                "title": "python-o-n-solution-easy-read-clear-cccccode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor any number in list arr, if we want to get its sum of all intervals with the indenticals, we just add the sum of intervals on the left and the sum of intervals on the right.\\nFor example in [10,5,10,10]. The intervals from left is [0,0,2,2+1],\\nintervals from right is [2+3,0,1,0], if you add these two lists element-wise, you get the answer [5,0,3,4].\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a mapping dict, to keep track of every unique number appeared in arr.\\nWhile we loop through arr, keep updating the index, count, and interval_sum of every unique number. (A small DP trick here)\\nTraverse arr both forwards and backwards to get keep1 and keep2 ([0,0,2,2+1] and [2+3,0,1,0] in the previous example). Then sum them up.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        from collections import defaultdict\\n        store = defaultdict()\\n        store2 = defaultdict()\\n        keep1 = []\\n        keep2 = []\\n        res = []\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            left = arr[i]\\n            right = arr[n-1-i]\\n            if left not in store:\\n                store[left] = [i, 1, 0]  # index, cnt, sum\\n            else:\\n                store[left][2] += store[left][1] * (i - store[left][0])\\n                store[left][1] += 1\\n                store[left][0] = i\\n            keep1.append(store[left][2])\\n            if right not in store2:\\n                store2[right] = [i, 1, 0]  # index, cnt, sum\\n            else:\\n                store2[right][2] += store2[right][1] * (i - store2[right][0])\\n                store2[right][1] += 1\\n                store2[right][0] = i\\n            keep2.append(store2[right][2])\\n\\n        for i in range(len(keep1)):\\n            res.append(keep1[i]+keep2[len(keep1)-1-i])\\n        return res\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        from collections import defaultdict\\n        store = defaultdict()\\n        store2 = defaultdict()\\n        keep1 = []\\n        keep2 = []\\n        res = []\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            left = arr[i]\\n            right = arr[n-1-i]\\n            if left not in store:\\n                store[left] = [i, 1, 0]  # index, cnt, sum\\n            else:\\n                store[left][2] += store[left][1] * (i - store[left][0])\\n                store[left][1] += 1\\n                store[left][0] = i\\n            keep1.append(store[left][2])\\n            if right not in store2:\\n                store2[right] = [i, 1, 0]  # index, cnt, sum\\n            else:\\n                store2[right][2] += store2[right][1] * (i - store2[right][0])\\n                store2[right][1] += 1\\n                store2[right][0] = i\\n            keep2.append(store2[right][2])\\n\\n        for i in range(len(keep1)):\\n            res.append(keep1[i]+keep2[len(keep1)-1-i])\\n        return res\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765330,
                "title": "my-stinky-solution-tle-but-i-got-inspitation-imitate-ofc-from-other-rust-tm",
                "content": "# Code\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn get_distances(arr: Vec<i32>) -> Vec<i64> {\\n        let mut result: Vec<i64> = vec![];\\n        let mut map_num_idxs: HashMap<i32, Vec<i64>> = HashMap::new();\\n        // num : [curr_sum, curr_idx_idxs, ...idxs]\\n\\n        // finding the current sum: curr_idx: the first one\\n        // let mut curr_sum_idx: HashMap<i32, Vec<i32>> = HashMap::new();\\n        // curr_sum: num => [idx, curr_sum] \\n\\n        for i in 0..arr.len() {\\n            if let Some(vec) = map_num_idxs.get_mut(&arr[i]) {\\n                // num : [ curr_sum, curr_idx_idxs, ...idxs]\\n                vec.push(i as i64);\\n                vec[0] += i64::abs(i as i64-vec[vec[1] as usize]);\\n            }else {\\n                map_num_idxs.insert(arr[i], vec![0,2,i as i64]);\\n            }\\n        }\\n        // println!(\"{:?}\", map_num_idxs);\\n\\n        for i in 0..arr.len() {\\n            // // TLE\\n            // let mut sum: i64 = 0;\\n            // // TLE\\n            if let Some(idxs) = map_num_idxs.get_mut(&arr[i]) {\\n                if idxs[idxs[1] as usize] as usize == i {\\n                    result.push(idxs[0]);\\n                    continue;\\n                }\\n                // num : [ curr_sum, curr_idx_idxs, ...idxs]\\n                // inspiration : https://leetcode.com/problems/intervals-between-identical-elements/solutions/1647499/hash-and-formula/\\n                // https://leetcode.com/problems/intervals-between-identical-elements/solutions/1647499/hash-and-formula/comments/1192260\\n                let mut prev_sum: i64 = idxs[0] as i64;\\n                let diff: i64 = i64::abs(idxs[idxs[1] as usize] as i64 - idxs[(idxs[1] + 1) as usize] as i64);\\n                let count_ele_before: i64 = idxs.len() as i64 -  (idxs.len() as i64 - idxs[1] as i64) - 2;\\n                let count_ele_after: i64 = idxs.len() as i64 - idxs[1] as i64 - 2;\\n                let distance_reduced = diff * count_ele_after;\\n                // DistanceReduced = Diff * (count of Elements on right side of 7)  = 2 * 2 = 4\\n                let distance_increased = diff * count_ele_before;\\n                // DistanceIncreased = Diff * (count of Elements on left side of 5) = 2 * 1 = 2\\n                let curr_sum = prev_sum - distance_reduced + distance_increased;\\n                //result[7] = result[5] - DistanceReduced + DistanceIncreased = 18 - 4 + 2 = 16\\n\\n                // println!(\"arr_idx:{},before:{},after:{}\", i,count_ele_before,count_ele_after);\\n                // println!(\"{:?}\", idxs);\\n                // println!(\"{:?}\", curr_sum);\\n                // println!(\"{}\", diff);\\n\\n\\n                idxs[1] += 1;\\n                idxs[0] = curr_sum;\\n                result.push(curr_sum);\\n\\n                // // TLE\\n                // for idx in 2..idxs.len() {\\n                //     sum += i64::abs((i as i64-idxs[idx]) as i64);\\n                // }\\n                // // TLE\\n            }\\n            // // TLE\\n            // result.push(sum);     \\n            // // TLE\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn get_distances(arr: Vec<i32>) -> Vec<i64> {\\n        let mut result: Vec<i64> = vec![];\\n        let mut map_num_idxs: HashMap<i32, Vec<i64>> = HashMap::new();\\n        // num : [curr_sum, curr_idx_idxs, ...idxs]\\n\\n        // finding the current sum: curr_idx: the first one\\n        // let mut curr_sum_idx: HashMap<i32, Vec<i32>> = HashMap::new();\\n        // curr_sum: num => [idx, curr_sum] \\n\\n        for i in 0..arr.len() {\\n            if let Some(vec) = map_num_idxs.get_mut(&arr[i]) {\\n                // num : [ curr_sum, curr_idx_idxs, ...idxs]\\n                vec.push(i as i64);\\n                vec[0] += i64::abs(i as i64-vec[vec[1] as usize]);\\n            }else {\\n                map_num_idxs.insert(arr[i], vec![0,2,i as i64]);\\n            }\\n        }\\n        // println!(\"{:?}\", map_num_idxs);\\n\\n        for i in 0..arr.len() {\\n            // // TLE\\n            // let mut sum: i64 = 0;\\n            // // TLE\\n            if let Some(idxs) = map_num_idxs.get_mut(&arr[i]) {\\n                if idxs[idxs[1] as usize] as usize == i {\\n                    result.push(idxs[0]);\\n                    continue;\\n                }\\n                // num : [ curr_sum, curr_idx_idxs, ...idxs]\\n                // inspiration : https://leetcode.com/problems/intervals-between-identical-elements/solutions/1647499/hash-and-formula/\\n                // https://leetcode.com/problems/intervals-between-identical-elements/solutions/1647499/hash-and-formula/comments/1192260\\n                let mut prev_sum: i64 = idxs[0] as i64;\\n                let diff: i64 = i64::abs(idxs[idxs[1] as usize] as i64 - idxs[(idxs[1] + 1) as usize] as i64);\\n                let count_ele_before: i64 = idxs.len() as i64 -  (idxs.len() as i64 - idxs[1] as i64) - 2;\\n                let count_ele_after: i64 = idxs.len() as i64 - idxs[1] as i64 - 2;\\n                let distance_reduced = diff * count_ele_after;\\n                // DistanceReduced = Diff * (count of Elements on right side of 7)  = 2 * 2 = 4\\n                let distance_increased = diff * count_ele_before;\\n                // DistanceIncreased = Diff * (count of Elements on left side of 5) = 2 * 1 = 2\\n                let curr_sum = prev_sum - distance_reduced + distance_increased;\\n                //result[7] = result[5] - DistanceReduced + DistanceIncreased = 18 - 4 + 2 = 16\\n\\n                // println!(\"arr_idx:{},before:{},after:{}\", i,count_ele_before,count_ele_after);\\n                // println!(\"{:?}\", idxs);\\n                // println!(\"{:?}\", curr_sum);\\n                // println!(\"{}\", diff);\\n\\n\\n                idxs[1] += 1;\\n                idxs[0] = curr_sum;\\n                result.push(curr_sum);\\n\\n                // // TLE\\n                // for idx in 2..idxs.len() {\\n                //     sum += i64::abs((i as i64-idxs[idx]) as i64);\\n                // }\\n                // // TLE\\n            }\\n            // // TLE\\n            // result.push(sum);     \\n            // // TLE\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3730323,
                "title": "c-mapping-for-frequency-and-position",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n    map<int,vector<long long>> mp;\\n    map<int,long long> p,q,pos,qos;\\n    map<int,long long> cnt1,cnt2,cnt3,cnt4;\\n    int n=arr.size();\\n\\n    for(int i=0;i<arr.size();i++){\\n        pos[i]=p[arr[i]];\\n        p[arr[i]]+=i;\\n        cnt2[i]=cnt1[arr[i]];\\n        cnt1[arr[i]]++;\\n    }\\n    for(int i=arr.size()-1;i>=0;i--){\\n        qos[i]=q[arr[i]];\\n        q[arr[i]]+=i;\\n        cnt3[i]=cnt4[arr[i]];\\n        cnt4[arr[i]]++;\\n    }\\n vector<long long> ans(arr.size(),0);  \\n    for(long long i=0;i<arr.size();i++){ \\n    ans[i]=(long long)cnt2[i]*i-pos[i]+qos[i]-(long long)cnt3[i]*i;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n    map<int,vector<long long>> mp;\\n    map<int,long long> p,q,pos,qos;\\n    map<int,long long> cnt1,cnt2,cnt3,cnt4;\\n    int n=arr.size();\\n\\n    for(int i=0;i<arr.size();i++){\\n        pos[i]=p[arr[i]];\\n        p[arr[i]]+=i;\\n        cnt2[i]=cnt1[arr[i]];\\n        cnt1[arr[i]]++;\\n    }\\n    for(int i=arr.size()-1;i>=0;i--){\\n        qos[i]=q[arr[i]];\\n        q[arr[i]]+=i;\\n        cnt3[i]=cnt4[arr[i]];\\n        cnt4[arr[i]]++;\\n    }\\n vector<long long> ans(arr.size(),0);  \\n    for(long long i=0;i<arr.size();i++){ \\n    ans[i]=(long long)cnt2[i]*i-pos[i]+qos[i]-(long long)cnt3[i]*i;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723826,
                "title": "optimal-solution-beats-90-with-explanation",
                "content": "# Intuition\\n- First, we need to collect all indices of each number and store it into hashmap.\\n- We can use left sum and right sum to compute value at a particular index without having nested for loop.\\n\\n# Approach\\n- Store number and its indices into hashmap.\\n- Loop through every key in hashmap.\\n- Compute left sum, starting from 0, right sum which is the total sum at first.\\n- We know that sum to the left of current index are always smaller than current value, and sum to the right are always greater than current index.\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        ans = [0] * len(arr)\\n        loc = collections.defaultdict(list)\\n        for i, x in enumerate(arr):\\n            loc[x].append(i)\\n\\n        for key in loc:\\n            leftSum = 0\\n            rightSum = sum(loc[key])\\n            n = len(loc[key])\\n            for i, idx in enumerate(loc[key]):\\n                rightSum -= idx\\n                ans[idx] = rightSum - (idx * (n - i - 1)) + (i * idx) - leftSum\\n                leftSum += idx\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        ans = [0] * len(arr)\\n        loc = collections.defaultdict(list)\\n        for i, x in enumerate(arr):\\n            loc[x].append(i)\\n\\n        for key in loc:\\n            leftSum = 0\\n            rightSum = sum(loc[key])\\n            n = len(loc[key])\\n            for i, idx in enumerate(loc[key]):\\n                rightSum -= idx\\n                ans[idx] = rightSum - (idx * (n - i - 1)) + (i * idx) - leftSum\\n                leftSum += idx\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691316,
                "title": "2-pass-keep-sum-and-count-of-indices",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        res = [0] * n\\n        sums = defaultdict(int)\\n        count = defaultdict(int)\\n        for i in range(n):\\n            res[i] += count[arr[i]] * i - sums[arr[i]]\\n            sums[arr[i]] += i\\n            count[arr[i]] += 1\\n        sums = defaultdict(int)\\n        count = defaultdict(int)\\n        for i in range(n - 1, -1, -1):\\n            res[i] += sums[arr[i]] - count[arr[i]] * i\\n            sums[arr[i]] += i\\n            count[arr[i]] += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        res = [0] * n\\n        sums = defaultdict(int)\\n        count = defaultdict(int)\\n        for i in range(n):\\n            res[i] += count[arr[i]] * i - sums[arr[i]]\\n            sums[arr[i]] += i\\n            count[arr[i]] += 1\\n        sums = defaultdict(int)\\n        count = defaultdict(int)\\n        for i in range(n - 1, -1, -1):\\n            res[i] += sums[arr[i]] - count[arr[i]] * i\\n            sums[arr[i]] += i\\n            count[arr[i]] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686132,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<long long>ans(n);\\n        unordered_map<int, vector<long long>>mp;\\n\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        for(auto i:mp){\\n            long long left =0 , right =0;\\n            for(auto j:i.second){\\n                right+=j;\\n            }\\n            int m=i.second.size();\\n            for(int j=0;j<m;j++){\\n                long long curr=i.second[j];\\n                \\n                \\n\\n                long long diff =(long long) (j*(curr) - left)+(long long) (right- (m-j)*curr);\\n                left+=i.second[j];\\n                right-=i.second[j];\\n                ans[curr]=diff;\\n            }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<long long>ans(n);\\n        unordered_map<int, vector<long long>>mp;\\n\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        for(auto i:mp){\\n            long long left =0 , right =0;\\n            for(auto j:i.second){\\n                right+=j;\\n            }\\n            int m=i.second.size();\\n            for(int j=0;j<m;j++){\\n                long long curr=i.second[j];\\n                \\n                \\n\\n                long long diff =(long long) (j*(curr) - left)+(long long) (right- (m-j)*curr);\\n                left+=i.second[j];\\n                right-=i.second[j];\\n                ans[curr]=diff;\\n            }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686131,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<long long>ans(n);\\n        unordered_map<int, vector<long long>>mp;\\n\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        for(auto i:mp){\\n            long long left =0 , right =0;\\n            for(auto j:i.second){\\n                right+=j;\\n            }\\n            int m=i.second.size();\\n            for(int j=0;j<m;j++){\\n                long long curr=i.second[j];\\n                \\n                \\n\\n                long long diff =(long long) (j*(curr) - left)+(long long) (right- (m-j)*curr);\\n                left+=i.second[j];\\n                right-=i.second[j];\\n                ans[curr]=diff;\\n            }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<long long>ans(n);\\n        unordered_map<int, vector<long long>>mp;\\n\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        for(auto i:mp){\\n            long long left =0 , right =0;\\n            for(auto j:i.second){\\n                right+=j;\\n            }\\n            int m=i.second.size();\\n            for(int j=0;j<m;j++){\\n                long long curr=i.second[j];\\n                \\n                \\n\\n                long long diff =(long long) (j*(curr) - left)+(long long) (right- (m-j)*curr);\\n                left+=i.second[j];\\n                right-=i.second[j];\\n                ans[curr]=diff;\\n            }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649934,
                "title": "dictionary-for-indices-with-same-value",
                "content": "class Solution(object):\\n    def getDistances(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        \\n        sum_dict = {}\\n        index_dict = {}\\n        \\n        for i,a in enumerate(arr):\\n            if a not in sum_dict:\\n                sum_dict[a] = 0\\n                index_dict[a] = []\\n            \\n            sum_dict[a] += i\\n            index_dict[a].append((i,sum_dict[a]))\\n        \\n        #print index_dict\\n        \\n        res = [0 for i in range(len(arr))]\\n        \\n        for key,val in index_dict.items():\\n            total_sum = sum_dict[key]\\n            \\n            n = len(val)\\n            for index,(v,sum_so_far) in enumerate(val):\\n                res[v] = (index+1)*v - sum_so_far + (total_sum - sum_so_far) - (n-1-index)*v\\n        \\n        \\n        #print res\\n        return res\\n                \\n            \\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def getDistances(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        \\n        sum_dict = {}",
                "codeTag": "Java"
            },
            {
                "id": 3574310,
                "title": "c-solution-o-n",
                "content": "class Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int ,long long>mp;\\n        vector<long long>freq(100001,0);\\n        vector<long long>ans(n,0);\\n        for(int i=0;i<arr.size();i++){\\n            int el=arr[i];\\n            if(mp.find(el)==mp.end()){\\n                mp[el]=0ll;\\n            }\\n            ans[i]+=i*(long long)freq[el] -mp[el];\\n            freq[el]++;\\n            mp[el]=mp[el]+i;\\n        }\\n        \\n        unordered_map<int ,long long>mp1;\\n        vector<long long>freq1(100001,0);\\n        for(int i=n-1;i>=0;i--){\\n            int el=arr[i];\\n            if(mp1.find(el)==mp1.end()){\\n                mp1[el]=0ll;\\n            }\\n            ans[i]+=mp1[el]-i*(long long)freq1[el] ;\\n            freq1[el]++;\\n            mp1[el]=mp1[el]+i;\\n        }\\n        \\n        return ans;\\n    }\\n### };",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int ,long long>mp;\\n        vector<long long>freq(100001,0);\\n        vector<long long>ans(n,0);\\n        for(int i=0;i<arr.size();i++){\\n            int el=arr[i];\\n            if(mp.find(el)==mp.end()){\\n                mp[el]=0ll;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3559106,
                "title": "easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<long long ,long long>cntidx;\\n        unordered_map<long long ,long long>sumidx;\\n        vector<long long>ans(arr.size());\\n        for(int i=0;i<arr.size();i++){\\n            ans[i]=(cntidx[arr[i]]*i) -(sumidx[arr[i]]);\\n            cntidx[arr[i]]++;\\n            sumidx[arr[i]]+=i;\\n        }\\n        cntidx.clear();\\n        sumidx.clear();\\n          for(int i=arr.size()-1;i>=0;i--){\\n            ans[i]+=(sumidx[arr[i]])-(cntidx[arr[i]]*i);\\n            cntidx[arr[i]]++;\\n            sumidx[arr[i]]+=i;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<long long ,long long>cntidx;\\n        unordered_map<long long ,long long>sumidx;\\n        vector<long long>ans(arr.size());\\n        for(int i=0;i<arr.size();i++){\\n            ans[i]=(cntidx[arr[i]]*i) -(sumidx[arr[i]]);\\n            cntidx[arr[i]]++;\\n            sumidx[arr[i]]+=i;\\n        }\\n        cntidx.clear();\\n        sumidx.clear();\\n          for(int i=arr.size()-1;i>=0;i--){\\n            ans[i]+=(sumidx[arr[i]])-(cntidx[arr[i]]*i);\\n            cntidx[arr[i]]++;\\n            sumidx[arr[i]]+=i;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509962,
                "title": "c-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<long long> ans(n);\\n        unordered_map<int,vector<long long>> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.count(arr[i])){\\n                long long x=mp[arr[i]].back();\\n                mp[arr[i]].push_back(i+x);\\n            }\\n            else mp[arr[i]].push_back(i);\\n        }\\n        \\n        for(auto& [num,vec]: mp){\\n            int s=vec.size();\\n            long long sum=vec.back();\\n            ans[vec[0]]=sum-vec[0]*s;\\n            for(int i=1;i<s;i++){\\n                long long x=vec[i]-vec[i-1];\\n                long long res=x*i-vec[i-1];\\n                res+=sum-vec[i-1]-(s-i)*x;\\n                ans[x]=res;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<long long> ans(n);\\n        unordered_map<int,vector<long long>> mp;\\n        for(int i=0;i<n;i++){\\n            if(mp.count(arr[i])){\\n                long long x=mp[arr[i]].back();\\n                mp[arr[i]].push_back(i+x);\\n            }\\n            else mp[arr[i]].push_back(i);\\n        }\\n        \\n        for(auto& [num,vec]: mp){\\n            int s=vec.size();\\n            long long sum=vec.back();\\n            ans[vec[0]]=sum-vec[0]*s;\\n            for(int i=1;i<s;i++){\\n                long long x=vec[i]-vec[i-1];\\n                long long res=x*i-vec[i-1];\\n                res+=sum-vec[i-1]-(s-i)*x;\\n                ans[x]=res;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458573,
                "title": "hashing-easy-c-solution",
                "content": "# Intuition\\nLeetCode Hint - For each element, keep track of the sum of indices of the identical elements that have come before and that will come after respectively. Use this to calculate the sum of intervals for that element to the rest of the elements with identical values.\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n        vector<long long> ans(n,0);\\n\\n        map<int,long long> before, after;\\n\\n        map<int,long long> m;\\n        map<int,long long> cnt;\\n        map<int,long long> cnt1;\\n\\n        for(int x=0; x<n; x++)\\n        {\\n            before[x]=m[arr[x]];\\n            m[arr[x]]+=x;\\n            cnt1[x]=cnt[arr[x]];\\n            cnt[arr[x]]++;\\n        }\\n\\n        map<int,long long> m1;\\n        map<int,long long> cnt2;\\n        map<int,long long> cnt3;\\n\\n        for(int x=n-1; x>=0; x--)\\n        {\\n            after[x]=m1[arr[x]];\\n            m1[arr[x]]+=x;\\n            cnt3[x]=cnt2[arr[x]];\\n            cnt2[arr[x]]++;\\n        }\\n\\n        for(int x=0; x<n; x++)\\n        {\\n            ans[x]=(long long)cnt1[x]*x-before[x]+after[x]-(long long)cnt3[x]*x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n        vector<long long> ans(n,0);\\n\\n        map<int,long long> before, after;\\n\\n        map<int,long long> m;\\n        map<int,long long> cnt;\\n        map<int,long long> cnt1;\\n\\n        for(int x=0; x<n; x++)\\n        {\\n            before[x]=m[arr[x]];\\n            m[arr[x]]+=x;\\n            cnt1[x]=cnt[arr[x]];\\n            cnt[arr[x]]++;\\n        }\\n\\n        map<int,long long> m1;\\n        map<int,long long> cnt2;\\n        map<int,long long> cnt3;\\n\\n        for(int x=n-1; x>=0; x--)\\n        {\\n            after[x]=m1[arr[x]];\\n            m1[arr[x]]+=x;\\n            cnt3[x]=cnt2[arr[x]];\\n            cnt2[arr[x]]++;\\n        }\\n\\n        for(int x=0; x<n; x++)\\n        {\\n            ans[x]=(long long)cnt1[x]*x-before[x]+after[x]-(long long)cnt3[x]*x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412086,
                "title": "simple-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        map<long long,vector<long long>>amap;\\n        for(int i=0;i<arr.size();i++){\\n            amap[arr[i]].push_back(i);\\n        }\\n        vector<long long>ans;\\n        for(int i=0;i<arr.size();i++){\\n            ans.push_back(0);\\n        }\\n        for(auto i: amap){\\n            long long sum1=0;\\n            long long sum=0;\\n            for(int j=0;j<amap[i.first].size();j++){\\n                sum+=amap[i.first][j];\\n            }\\n            long long n=amap[i.first].size();\\n            for(int j=0;j<amap[i.first].size();j++){\\n                long long ans1=((j*amap[i.first][j])-(sum1))+((sum-sum1-amap[i.first][j])-((n-1-j)*(amap[i.first][j])));\\n                ans[amap[i.first][j]]=ans1;\\n                sum1+=amap[i.first][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        map<long long,vector<long long>>amap;\\n        for(int i=0;i<arr.size();i++){\\n            amap[arr[i]].push_back(i);\\n        }\\n        vector<long long>ans;\\n        for(int i=0;i<arr.size();i++){\\n            ans.push_back(0);\\n        }\\n        for(auto i: amap){\\n            long long sum1=0;\\n            long long sum=0;\\n            for(int j=0;j<amap[i.first].size();j++){\\n                sum+=amap[i.first][j];\\n            }\\n            long long n=amap[i.first].size();\\n            for(int j=0;j<amap[i.first].size();j++){\\n                long long ans1=((j*amap[i.first][j])-(sum1))+((sum-sum1-amap[i.first][j])-((n-1-j)*(amap[i.first][j])));\\n                ans[amap[i.first][j]]=ans1;\\n                sum1+=amap[i.first][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405096,
                "title": "c-code-for-beginners-easy-understanding-hashmaps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        \\n        unordered_map<long long,pair<long long,long long>> RIGHT,LEFT;  // {freq,sum}\\n        \\n        for(int i=0;i<n;i++){\\n            RIGHT[arr[i]].first++;\\n            RIGHT[arr[i]].second+=i;\\n        }\\n        \\n        vector<long long> res(n);\\n        \\n        for(int i=0;i<n;i++){\\n            long long L=LEFT[arr[i]].first*i-LEFT[arr[i]].second;\\n            long long R=RIGHT[arr[i]].second-RIGHT[arr[i]].first*i;\\n\\n\\t\\t\\tres[i]=L+R;\\n            \\n            LEFT[arr[i]].first++;\\n            LEFT[arr[i]].second+=i;\\n            \\n            RIGHT[arr[i]].first--;\\n            RIGHT[arr[i]].second-=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n=arr.size();\\n        \\n        unordered_map<long long,pair<long long,long long>> RIGHT,LEFT;  // {freq,sum}\\n        \\n        for(int i=0;i<n;i++){\\n            RIGHT[arr[i]].first++;\\n            RIGHT[arr[i]].second+=i;\\n        }\\n        \\n        vector<long long> res(n);\\n        \\n        for(int i=0;i<n;i++){\\n            long long L=LEFT[arr[i]].first*i-LEFT[arr[i]].second;\\n            long long R=RIGHT[arr[i]].second-RIGHT[arr[i]].first*i;\\n\\n\\t\\t\\tres[i]=L+R;\\n            \\n            LEFT[arr[i]].first++;\\n            LEFT[arr[i]].second+=i;\\n            \\n            RIGHT[arr[i]].first--;\\n            RIGHT[arr[i]].second-=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397798,
                "title": "prefix-suffix-sum-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def getDistances(self, nums: List[int]) -> List[int]:\\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in d:\\n                d[nums[i]] = [i]\\n            else:\\n                d[nums[i]].append(i)\\n        lst = [0] * len(nums)\\n        for val in d.values():\\n            suff=sum(val)#suffix sum\\n            pre=0#prefix sum\\n            s=len(val)#len(suffix)\\n            p=0#len(pre)\\n            for i in val:\\n                pre+=i \\n                p+=1\\n                suff-=i\\n                s-=1\\n                lst[i]=(-pre+p*i-s*i+suff)\\n            \\n        return lst\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def getDistances(self, nums: List[int]) -> List[int]:\\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in d:\\n                d[nums[i]] = [i]\\n            else:\\n                d[nums[i]].append(i)\\n        lst = [0] * len(nums)\\n        for val in d.values():\\n            suff=sum(val)#suffix sum\\n            pre=0#prefix sum\\n            s=len(val)#len(suffix)\\n            p=0#len(pre)\\n            for i in val:\\n                pre+=i \\n                p+=1\\n                suff-=i\\n                s-=1\\n                lst[i]=(-pre+p*i-s*i+suff)\\n            \\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396442,
                "title": "simple-c-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<long long>res;\\n    void ok(vector<int>&v){\\n        int n=v.size();\\n        vector<long long>pre(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            pre[i]=pre[i-1]+1ll*v[i-1];\\n        }\\n        for(int i=1;i<=n;i++){\\n            long long tmp=1ll*(i-1)*v[i-1]-pre[i-1];\\n            tmp+=pre[n]-pre[i]-1ll*(n-i)*v[i-1];\\n            res[v[i-1]]=tmp;\\n        }\\n    }\\n    vector<long long> getDistances(vector<int>& arr) {\\n        map<int,vector<int>>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        res.assign(arr.size(),0);\\n        for(auto it:mp){\\n            ok(it.second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<long long>res;\\n    void ok(vector<int>&v){\\n        int n=v.size();\\n        vector<long long>pre(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            pre[i]=pre[i-1]+1ll*v[i-1];\\n        }\\n        for(int i=1;i<=n;i++){\\n            long long tmp=1ll*(i-1)*v[i-1]-pre[i-1];\\n            tmp+=pre[n]-pre[i]-1ll*(n-i)*v[i-1];\\n            res[v[i-1]]=tmp;\\n        }\\n    }\\n    vector<long long> getDistances(vector<int>& arr) {\\n        map<int,vector<int>>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        res.assign(arr.size(),0);\\n        for(auto it:mp){\\n            ok(it.second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394886,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n       vector<long long>ans(n,0);\\n       unordered_map<long long,long long>cntMp;\\n       unordered_map<long long,long long>sumMp;\\n       for (int i=0;i<n;i++)\\n       {\\n           if (cntMp.count(arr[i]))\\n           {\\n              ans[i]=(cntMp[arr[i]]*i)-sumMp[arr[i]];\\n           }\\n           cntMp[arr[i]]++;\\n           sumMp[arr[i]]+=i;\\n       }\\n       cntMp.clear();\\n       sumMp.clear();\\n       for (int i=n-1;i>=0;i--)\\n       {\\n           if (cntMp.count(arr[i]))\\n           {\\n              ans[i]+=sumMp[arr[i]]-(cntMp[arr[i]]*i);\\n           }\\n           cntMp[arr[i]]++;\\n           sumMp[arr[i]]+=i;\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n       vector<long long>ans(n,0);\\n       unordered_map<long long,long long>cntMp;\\n       unordered_map<long long,long long>sumMp;\\n       for (int i=0;i<n;i++)\\n       {\\n           if (cntMp.count(arr[i]))\\n           {\\n              ans[i]=(cntMp[arr[i]]*i)-sumMp[arr[i]];\\n           }\\n           cntMp[arr[i]]++;\\n           sumMp[arr[i]]+=i;\\n       }\\n       cntMp.clear();\\n       sumMp.clear();\\n       for (int i=n-1;i>=0;i--)\\n       {\\n           if (cntMp.count(arr[i]))\\n           {\\n              ans[i]+=sumMp[arr[i]]-(cntMp[arr[i]]*i);\\n           }\\n           cntMp[arr[i]]++;\\n           sumMp[arr[i]]+=i;\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386977,
                "title": "probably-the-worst-solution-xd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\npublic:\\n    vector<long long> getDistances(vector<int>& arr){\\n        // 3->0,4,7,10,13,15\\n        // For 0\\n        // \\n        // FOR 10\\n        // (10-0)+(10-4)+(10-7)  +(10-10)+  (13-10)+(15-10)\\n        // 1 2 3 4\\n        // 1 3 6 10\\n        \\n        \\n        unordered_map<long long,vector<long long>> m;\\n        long long n=arr.size();\\n        map<long long,long long> f;\\n        for(long long i=0;i<n;i++){\\n            m[arr[i]].push_back(i);\\n            f[arr[i]]++;\\n        }\\n        unordered_map<long long,vector<long long>> pref;\\n        for(auto i:m){\\n            vector<long long> temp=i.second;\\n            vector<long long> s;\\n            s.push_back(temp[0]);\\n            for(long long j=1;j<temp.size();j++){\\n                s.push_back(s.back()+temp[j]);\\n            }\\n            for(long long j=0;j<s.size();j++){\\n                pref[i.first].push_back(s[j]);\\n            }\\n        }\\n        // for(long long i=0;i<pref[3].size();i++) cout<<pref[3][i]<<\" \";\\n        vector<long long> v;\\n        map<long long,long long> ct;\\n        for(long long i=0;i<n;i++){\\n            // 1 -> 1,3\\n            // 3 => occur=0\\n            long long occur=ct[arr[i]]-1;\\n            long long ans=0;\\n            long long minus=0;\\n            if(occur>=0) minus+=pref[arr[i]][occur];\\n            ans-=minus;\\n            // ans=-1\\n            ans=ans+(long long)((long long)m[arr[i]][occur+1]*(long long)(occur+1));\\n            if(occur+1<=pref[arr[i]].size()-1){\\n                ans-=m[arr[i]][occur+1]*(pref[arr[i]].size()-occur-2);\\n            }\\n            long long plus=0;\\n            if(occur+1<=pref[arr[i]].size()-1){\\n                plus+=pref[arr[i]][pref[arr[i]].size()-1]-pref[arr[i]][occur+1];\\n            }\\n            ans+=plus;\\n            v.push_back(ans*1ll);\\n            ct[arr[i]]++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    vector<long long> getDistances(vector<int>& arr){\\n        // 3->0,4,7,10,13,15\\n        // For 0\\n        // \\n        // FOR 10\\n        // (10-0)+(10-4)+(10-7)  +(10-10)+  (13-10)+(15-10)\\n        // 1 2 3 4\\n        // 1 3 6 10\\n        \\n        \\n        unordered_map<long long,vector<long long>> m;\\n        long long n=arr.size();\\n        map<long long,long long> f;\\n        for(long long i=0;i<n;i++){\\n            m[arr[i]].push_back(i);\\n            f[arr[i]]++;\\n        }\\n        unordered_map<long long,vector<long long>> pref;\\n        for(auto i:m){\\n            vector<long long> temp=i.second;\\n            vector<long long> s;\\n            s.push_back(temp[0]);\\n            for(long long j=1;j<temp.size();j++){\\n                s.push_back(s.back()+temp[j]);\\n            }\\n            for(long long j=0;j<s.size();j++){\\n                pref[i.first].push_back(s[j]);\\n            }\\n        }\\n        // for(long long i=0;i<pref[3].size();i++) cout<<pref[3][i]<<\" \";\\n        vector<long long> v;\\n        map<long long,long long> ct;\\n        for(long long i=0;i<n;i++){\\n            // 1 -> 1,3\\n            // 3 => occur=0\\n            long long occur=ct[arr[i]]-1;\\n            long long ans=0;\\n            long long minus=0;\\n            if(occur>=0) minus+=pref[arr[i]][occur];\\n            ans-=minus;\\n            // ans=-1\\n            ans=ans+(long long)((long long)m[arr[i]][occur+1]*(long long)(occur+1));\\n            if(occur+1<=pref[arr[i]].size()-1){\\n                ans-=m[arr[i]][occur+1]*(pref[arr[i]].size()-occur-2);\\n            }\\n            long long plus=0;\\n            if(occur+1<=pref[arr[i]].size()-1){\\n                plus+=pref[arr[i]][pref[arr[i]].size()-1]-pref[arr[i]][occur+1];\\n            }\\n            ans+=plus;\\n            v.push_back(ans*1ll);\\n            ct[arr[i]]++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3370920,
                "title": "c-prefix-suffix-array",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<long long> prefix(n);\\n        vector<long long> suffix(n);\\n        unordered_map<int, int> count;\\n        unordered_map<int, int> lastPos;\\n        for(int i = 0; i < n; i++) {\\n            prefix[i] = prefix[lastPos[arr[i]]] + count[arr[i]] * (i - lastPos[arr[i]]);\\n            lastPos[arr[i]] = i;\\n            count[arr[i]]++;\\n        }\\n        count.clear();\\n        lastPos.clear();\\n        for(int i = n - 1; i >= 0; i--) {\\n            suffix[i] = suffix[lastPos[arr[i]]] + count[arr[i]] * (lastPos[arr[i]] - i);\\n            lastPos[arr[i]] = i;\\n            count[arr[i]]++;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            prefix[i] = prefix[i] + suffix[i];\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<long long> prefix(n);\\n        vector<long long> suffix(n);\\n        unordered_map<int, int> count;\\n        unordered_map<int, int> lastPos;\\n        for(int i = 0; i < n; i++) {\\n            prefix[i] = prefix[lastPos[arr[i]]] + count[arr[i]] * (i - lastPos[arr[i]]);\\n            lastPos[arr[i]] = i;\\n            count[arr[i]]++;\\n        }\\n        count.clear();\\n        lastPos.clear();\\n        for(int i = n - 1; i >= 0; i--) {\\n            suffix[i] = suffix[lastPos[arr[i]]] + count[arr[i]] * (lastPos[arr[i]] - i);\\n            lastPos[arr[i]] = i;\\n            count[arr[i]]++;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            prefix[i] = prefix[i] + suffix[i];\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364749,
                "title": "easy-maths",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    \\n    vector<long long> getDistances(vector<int>& arr) {\\n        map<int, vector<int>> pos;\\n        for (int i = 0; i < (int)arr.size(); i++) {\\n            pos[arr[i]].push_back(i);\\n        }\\n        \\n        // How interval sum changes when we iterate over occurrences of same number\\n        vector<long long> ans(arr.size(), 0);\\n        for (auto &[key, indices] : pos) {\\n            for (int index : indices) {\\n                ans[indices[0]] += index - indices.front();\\n            }\\n            \\n            for (int i = 1; i < indices.size(); i++) {\\n                int cnt_after = indices.size() - i - 1, cnt_before = i - 1;\\n                ans[indices[i]] = ans[indices[i - 1]] + (cnt_before - cnt_after) * (indices[i] - indices[i - 1]);\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```python\\nfrom collections import defaultdict\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        pos = defaultdict(list)\\n        for i in range(len(arr)):\\n            pos[arr[i]].append(i)\\n        \\n        intervals = [0] * len(arr)\\n        for indices in pos.values():\\n            for index in indices:\\n                intervals[indices[0]] += index - indices[0]\\n            \\n            for i in range(1, len(indices)):\\n                cnt_before, cnt_after = i - 1, len(indices) - i - 1\\n                intervals[indices[i]] = intervals[indices[i - 1]] + (cnt_before - cnt_after) * (indices[i] - indices[i - 1])\\n        \\n        return intervals\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    \\n    vector<long long> getDistances(vector<int>& arr) {\\n        map<int, vector<int>> pos;\\n        for (int i = 0; i < (int)arr.size(); i++) {\\n            pos[arr[i]].push_back(i);\\n        }\\n        \\n        // How interval sum changes when we iterate over occurrences of same number\\n        vector<long long> ans(arr.size(), 0);\\n        for (auto &[key, indices] : pos) {\\n            for (int index : indices) {\\n                ans[indices[0]] += index - indices.front();\\n            }\\n            \\n            for (int i = 1; i < indices.size(); i++) {\\n                int cnt_after = indices.size() - i - 1, cnt_before = i - 1;\\n                ans[indices[i]] = ans[indices[i - 1]] + (cnt_before - cnt_after) * (indices[i] - indices[i - 1]);\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```\n```python\\nfrom collections import defaultdict\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        pos = defaultdict(list)\\n        for i in range(len(arr)):\\n            pos[arr[i]].append(i)\\n        \\n        intervals = [0] * len(arr)\\n        for indices in pos.values():\\n            for index in indices:\\n                intervals[indices[0]] += index - indices[0]\\n            \\n            for i in range(1, len(indices)):\\n                cnt_before, cnt_after = i - 1, len(indices) - i - 1\\n                intervals[indices[i]] = intervals[indices[i - 1]] + (cnt_before - cnt_after) * (indices[i] - indices[i - 1])\\n        \\n        return intervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359335,
                "title": "python-easy-and-simple-solution-using-hashmap-prefix-sum",
                "content": "```\\nclass Solution(object):\\n    def getDistances(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ad = dict()\\n        sd = dict()\\n\\n        for i,v in enumerate(arr):\\n            if v in ad:\\n                ad[v].append(i)\\n                sd[v] = i + sd.get(v,0)\\n            else:\\n                ad[v] = [i]\\n                sd[v] = i + sd.get(v,0)\\n        \\n        for a in ad:\\n            sm = sd[a]\\n            psm = 0\\n            nsm = sm\\n            la = len(ad[a])\\n            for x in range(la):\\n                cr = ad[a][x]\\n                nsm -= cr\\n                arr[cr] = abs(psm - (cr * x)) + abs(nsm - (cr * (la-x-1)))\\n                psm += cr   \\n                \\n        return arr\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution(object):\\n    def getDistances(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ad = dict()\\n        sd = dict()\\n\\n        for i,v in enumerate(arr):\\n            if v in ad:\\n                ad[v].append(i)\\n                sd[v] = i + sd.get(v,0)\\n            else:\\n                ad[v] = [i]\\n                sd[v] = i + sd.get(v,0)\\n        \\n        for a in ad:\\n            sm = sd[a]\\n            psm = 0\\n            nsm = sm\\n            la = len(ad[a])\\n            for x in range(la):\\n                cr = ad[a][x]\\n                nsm -= cr\\n                arr[cr] = abs(psm - (cr * x)) + abs(nsm - (cr * (la-x-1)))\\n                psm += cr   \\n                \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326690,
                "title": "2-pass-python-solution",
                "content": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        hashmap = {}\\n        res = [0] * n\\n        for i in range(n):\\n            num, total = hashmap.get(arr[i],[0,0])\\n            res[i] += i * num - total\\n            hashmap[arr[i]] = [num+1,total+i]\\n            \\n        hashmap = {}\\n        for i in range(n-1,-1,-1):\\n            num, total = hashmap.get(arr[i],[0,0])\\n            res[i] += (n-1-i) * num - total\\n            hashmap[arr[i]] = [num + 1,total+n-1-i]\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        n = len(arr)\\n        hashmap = {}\\n        res = [0] * n\\n        for i in range(n):\\n            num, total = hashmap.get(arr[i],[0,0])\\n            res[i] += i * num - total\\n            hashmap[arr[i]] = [num+1,total+i]\\n            \\n        hashmap = {}\\n        for i in range(n-1,-1,-1):\\n            num, total = hashmap.get(arr[i],[0,0])\\n            res[i] += (n-1-i) * num - total\\n            hashmap[arr[i]] = [num + 1,total+n-1-i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315137,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<int, vector<int>>Map ; //{val, idxs}\\n        for(int i = 0 ; i < arr.size(); i++){\\n            Map[arr[i]].push_back(i) ;\\n        }        \\n        unordered_map<int, vector<LL>>rets ; //{val, ans}\\n        unordered_map<int, int>ret_idx ;\\n        for(auto&x : Map){\\n            int val = x.first ;\\n            ret_idx[val] = 0 ;\\n            auto& pos = x.second ;\\n            int n = pos.size() ;\\n            long long sum = 0 ;\\n            for(int i = 0; i < pos.size(); i++)\\n                sum += pos[i] - pos[0] ;\\n            rets[val].push_back(sum) ;\\n            for(int i = 1 ; i < pos.size(); i++){\\n                //sum -= (n-i)* (pos[i] - pos[i-1]) ;\\n                //sum += i * (pos[i] - pos[i-1]) ;\\n                sum += (2*i - n) * (pos[i] - pos[i-1]) ;\\n                rets[val].push_back(sum) ;\\n            }\\n        }\\n        vector<LL>ans ;\\n        for(int i = 0; i < arr.size(); i++){\\n            int val = arr[i] ;\\n            int k = ret_idx[val] ;\\n            ret_idx[val]++ ;\\n            ans.push_back(rets[val][k]) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<int, vector<int>>Map ; //{val, idxs}\\n        for(int i = 0 ; i < arr.size(); i++){\\n            Map[arr[i]].push_back(i) ;\\n        }        \\n        unordered_map<int, vector<LL>>rets ; //{val, ans}\\n        unordered_map<int, int>ret_idx ;\\n        for(auto&x : Map){\\n            int val = x.first ;\\n            ret_idx[val] = 0 ;\\n            auto& pos = x.second ;\\n            int n = pos.size() ;\\n            long long sum = 0 ;\\n            for(int i = 0; i < pos.size(); i++)\\n                sum += pos[i] - pos[0] ;\\n            rets[val].push_back(sum) ;\\n            for(int i = 1 ; i < pos.size(); i++){\\n                //sum -= (n-i)* (pos[i] - pos[i-1]) ;\\n                //sum += i * (pos[i] - pos[i-1]) ;\\n                sum += (2*i - n) * (pos[i] - pos[i-1]) ;\\n                rets[val].push_back(sum) ;\\n            }\\n        }\\n        vector<LL>ans ;\\n        for(int i = 0; i < arr.size(); i++){\\n            int val = arr[i] ;\\n            int k = ret_idx[val] ;\\n            ret_idx[val]++ ;\\n            ans.push_back(rets[val][k]) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313019,
                "title": "c-unorderd-map-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        vector<long long> res;\\n        unordered_map<int,vector<long long>> mp;\\n        for (int i = 0; i < arr.size(); ++ i) mp[arr[i]].push_back(i);\\n        for (int i = 0; i < arr.size(); ++ i) {\\n            res.push_back(0LL);\\n            if (mp[arr[i]].back() >= 0) {\\n                for (int j : mp[arr[i]]) res.back() += abs(j - i);\\n                mp[arr[i]].push_back(res.back());\\n                mp[arr[i]].push_back(-1);\\n            } else {\\n                int n = mp[arr[i]].size() - 2, k = -mp[arr[i]].back(), diff = mp[arr[i]][k] - mp[arr[i]][k - 1];\\n                res.back() += mp[arr[i]][n] + diff * 1LL * (k * 2 - n);\\n                mp[arr[i]][n] = res.back();\\n                -- mp[arr[i]].back();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        vector<long long> res;\\n        unordered_map<int,vector<long long>> mp;\\n        for (int i = 0; i < arr.size(); ++ i) mp[arr[i]].push_back(i);\\n        for (int i = 0; i < arr.size(); ++ i) {\\n            res.push_back(0LL);\\n            if (mp[arr[i]].back() >= 0) {\\n                for (int j : mp[arr[i]]) res.back() += abs(j - i);\\n                mp[arr[i]].push_back(res.back());\\n                mp[arr[i]].push_back(-1);\\n            } else {\\n                int n = mp[arr[i]].size() - 2, k = -mp[arr[i]].back(), diff = mp[arr[i]][k] - mp[arr[i]][k - 1];\\n                res.back() += mp[arr[i]][n] + diff * 1LL * (k * 2 - n);\\n                mp[arr[i]][n] = res.back();\\n                -- mp[arr[i]].back();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311662,
                "title": "c-easy-solution-prefix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        map<long long,vector<long long>> m1,m2;\\n        int n = arr.size();\\n        vector<long long> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            m1[arr[i]].push_back(i);\\n            if(m2[arr[i]].size()==0)\\n            {\\n                m2[arr[i]].push_back(i);\\n            }\\n            else\\n            {\\n                long long ele = m2[arr[i]][m2[arr[i]].size()-1];\\n                ele+=i;\\n                m2[arr[i]].push_back(ele);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(m1[arr[i]].size()==1)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            long long idx = lower_bound(m1[arr[i]].begin(),m1[arr[i]].end(),i)-m1[arr[i]].begin();\\n            long long n1 = m1[arr[i]].size()-1;\\n            long long n2 = idx;\\n            long long n3 = n1-idx;\\n            long long prefS = idx>0?m2[arr[i]][idx-1]:0;\\n            long long suffS = idx<n1?m2[arr[i]][n1]-m2[arr[i]][idx]:0;\\n            long long res = n2*(m1[arr[i]][idx])-prefS + suffS-n3*(m1[arr[i]][idx]);\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        map<long long,vector<long long>> m1,m2;\\n        int n = arr.size();\\n        vector<long long> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            m1[arr[i]].push_back(i);\\n            if(m2[arr[i]].size()==0)\\n            {\\n                m2[arr[i]].push_back(i);\\n            }\\n            else\\n            {\\n                long long ele = m2[arr[i]][m2[arr[i]].size()-1];\\n                ele+=i;\\n                m2[arr[i]].push_back(ele);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(m1[arr[i]].size()==1)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            long long idx = lower_bound(m1[arr[i]].begin(),m1[arr[i]].end(),i)-m1[arr[i]].begin();\\n            long long n1 = m1[arr[i]].size()-1;\\n            long long n2 = idx;\\n            long long n3 = n1-idx;\\n            long long prefS = idx>0?m2[arr[i]][idx-1]:0;\\n            long long suffS = idx<n1?m2[arr[i]][n1]-m2[arr[i]][idx]:0;\\n            long long res = n2*(m1[arr[i]][idx])-prefS + suffS-n3*(m1[arr[i]][idx]);\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305950,
                "title": "java-solution-from-huifeng-guan-youtube-video",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://www.youtube.com/watch?v=4OSbgIQV6v8\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n\\n        int n = arr.length;\\n\\n        Map<Integer, List<Integer>> map = new HashMap();\\n\\n        for (int i = 0; i < n; i++) {\\n            List<Integer> tmp = map.getOrDefault(arr[i], new ArrayList());\\n            tmp.add(i);\\n            map.put(arr[i], tmp);\\n        }\\n\\n        Map<Integer, List<Long>> rets = new HashMap();\\n\\n        for (var entry: map.entrySet()) {\\n            Integer key = entry.getKey();\\n            List<Integer> val = entry.getValue();\\n\\n            long sum = 0;\\n            for (int i = 0; i < val.size(); i++) {\\n                sum += val.get(i) - val.get(0);\\n            }\\n            List<Long> result = new ArrayList();\\n            result.add(sum);\\n\\n            for (int i = 1; i < val.size(); i++) {\\n                long tmp = result.get(i-1);\\n                tmp += (val.get(i) - val.get(i-1)) * i;\\n                tmp -= (val.get(i) - val.get(i-1)) * (val.size() - i);\\n                result.add(tmp);\\n            }\\n\\n            rets.put(key, result);\\n        }\\n\\n        // System.out.print(\"rets:\"+rets+\"\\\\n\");\\n\\n        Map<Integer, Integer> index = new HashMap();\\n        long[] ans = new long[n];\\n        int id = 0;\\n\\n        for (int i : arr) {\\n            int idx = index.getOrDefault(i, 0);\\n            // if (i == 3) {\\n            //     System.out.print(\"i:\"+i+\" \"+\"idx:\"+idx+\"\\\\n\");\\n            //     System.out.print(\"index:\"+index+\"\\\\n\");\\n            // }\\n            ans[id++] = rets.get(i).get(idx);\\n            index.put(i, ++idx);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n\\n        int n = arr.length;\\n\\n        Map<Integer, List<Integer>> map = new HashMap();\\n\\n        for (int i = 0; i < n; i++) {\\n            List<Integer> tmp = map.getOrDefault(arr[i], new ArrayList());\\n            tmp.add(i);\\n            map.put(arr[i], tmp);\\n        }\\n\\n        Map<Integer, List<Long>> rets = new HashMap();\\n\\n        for (var entry: map.entrySet()) {\\n            Integer key = entry.getKey();\\n            List<Integer> val = entry.getValue();\\n\\n            long sum = 0;\\n            for (int i = 0; i < val.size(); i++) {\\n                sum += val.get(i) - val.get(0);\\n            }\\n            List<Long> result = new ArrayList();\\n            result.add(sum);\\n\\n            for (int i = 1; i < val.size(); i++) {\\n                long tmp = result.get(i-1);\\n                tmp += (val.get(i) - val.get(i-1)) * i;\\n                tmp -= (val.get(i) - val.get(i-1)) * (val.size() - i);\\n                result.add(tmp);\\n            }\\n\\n            rets.put(key, result);\\n        }\\n\\n        // System.out.print(\"rets:\"+rets+\"\\\\n\");\\n\\n        Map<Integer, Integer> index = new HashMap();\\n        long[] ans = new long[n];\\n        int id = 0;\\n\\n        for (int i : arr) {\\n            int idx = index.getOrDefault(i, 0);\\n            // if (i == 3) {\\n            //     System.out.print(\"i:\"+i+\" \"+\"idx:\"+idx+\"\\\\n\");\\n            //     System.out.print(\"index:\"+index+\"\\\\n\");\\n            // }\\n            ans[id++] = rets.get(i).get(idx);\\n            index.put(i, ++idx);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299167,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<long long,long long> index,freq;\\n        int n=arr.size();\\n        index[arr[0]]=0;\\n        freq[arr[0]]=1;\\n        vector<long long> ans(n,0);\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]=freq[arr[i]]*i-(index[arr[i]]);\\n            index[arr[i]]+=i;\\n            freq[arr[i]]++;\\n        }\\n\\n        vector<long long> ans1(n,0);\\n        freq.clear();\\n        index.clear();\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            ans1[i]=index[arr[i]]-freq[arr[i]]*i;\\n            index[arr[i]]+=i;\\n            freq[arr[i]]++;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i]+=ans1[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<long long,long long> index,freq;\\n        int n=arr.size();\\n        index[arr[0]]=0;\\n        freq[arr[0]]=1;\\n        vector<long long> ans(n,0);\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]=freq[arr[i]]*i-(index[arr[i]]);\\n            index[arr[i]]+=i;\\n            freq[arr[i]]++;\\n        }\\n\\n        vector<long long> ans1(n,0);\\n        freq.clear();\\n        index.clear();\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            ans1[i]=index[arr[i]]-freq[arr[i]]*i;\\n            index[arr[i]]+=i;\\n            freq[arr[i]]++;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i]+=ans1[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292584,
                "title": "easy-c-no-prefix-sum-just-a-map",
                "content": "\\n# Approach\\nTake an unordered map of int and vector /array, the key has to be the unique value from array and vector will store the indices of this key, say this vector is vec.\\nNow travel on each of these vectors and simply find the ans for this index using formula\\n\\n**ans[i] = vec[i] * i - (currSum - vec[i]) + (sum-currSum) - vec[i] * (vec.size()-1-i);**\\n\\ncurrSum is sum till that index in vec and sum is sum of all elements of vec.\\n\\n\\n**Please upvote if u find it useful**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<long long> getDistances(vector<int>& v) {\\n        \\n        int n = v.size();\\n        unordered_map<int, vector<int> > mp;\\n\\n        for(int i=0; i<n; i++)\\n            mp[v[i]].push_back(i);\\n\\n        vector<long long> ans(n, -1);\\n\\n        for(int i=0; i<n; i++)\\n        {   \\n            if(ans[i]!=-1)\\n                continue; \\n\\n            auto vec = mp[v[i]];\\n\\n            long long sum=0, currSum=0;\\n\\n            for(int i=0; i<vec.size(); i++)\\n                sum = sum + 0LL + vec[i];\\n\\n            for(int i=0; i<vec.size(); i++)\\n            {\\n                currSum = currSum +0LL+ vec[i];\\n                ans[vec[i]] = vec[i]*1LL*(i) - (currSum - vec[i]) + 0LL+ (sum-currSum) - vec[i]*1LL*(vec.size()-1-i);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<long long> getDistances(vector<int>& v) {\\n        \\n        int n = v.size();\\n        unordered_map<int, vector<int> > mp;\\n\\n        for(int i=0; i<n; i++)\\n            mp[v[i]].push_back(i);\\n\\n        vector<long long> ans(n, -1);\\n\\n        for(int i=0; i<n; i++)\\n        {   \\n            if(ans[i]!=-1)\\n                continue; \\n\\n            auto vec = mp[v[i]];\\n\\n            long long sum=0, currSum=0;\\n\\n            for(int i=0; i<vec.size(); i++)\\n                sum = sum + 0LL + vec[i];\\n\\n            for(int i=0; i<vec.size(); i++)\\n            {\\n                currSum = currSum +0LL+ vec[i];\\n                ans[vec[i]] = vec[i]*1LL*(i) - (currSum - vec[i]) + 0LL+ (sum-currSum) - vec[i]*1LL*(vec.size()-1-i);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273976,
                "title": "java-40ms-99-prefixsum-and-bloody-good-explanations",
                "content": "# Approach\\n1. Traverse arr and map each number to a list of positions.\\n    - [2,1,3,1,2,3,3,3,3,3,3,3]: 1 -> [1,3], 2 -> [0,4], 3-> [2,5,6,7,8,9,10,11].\\n2. Intuition would tell you to traverse each position from arr, get its list of other positions and calculate the differences. \\n    - EG: i = 7. List of positions of 3 : [2,5,6,7,8,9,10,11].\\n        Intuition would tell you to calculate the differences: Math.abs(2-7) + .. Math.abs(6-7) + Math.abs(8-7) + .. Math.abs(11-7).\\n3. However, doing step #2 for all the 3 digits leads to a n^n complexity. What is arr has a length of 100000 and all elements are the same? You would have to traverse the list of positions for each element.\\n4. Steps #2 and #3 reveal that calculating the diffs for each element is redundant.\\n    - i = 7. We don\\'t need to calculate the abs one by one, but simply apply math: (a-x) + (b-x) + (c-x) = (a+b+c) - 3x. We can calculate a+b+c because we know the list of positions => we can calculate the prefix sum.\\n    - i = 7. prefix sum = (2+5+6) = 13. 7 x 3 = 21.  Abs(13 - 21) = 8 == (7-2 + 7-5 + 7-6) \\n5. So for each group/unique number, calculate the prefix sum of each index position.\\nBased on that, calculate the sum of ALL differences on left + sum of ALL differences on right.\\nThese two sums will give you the sum of ALL differences between element at pos p and rest of elements that have the same value as element at pos p.\\n\\n# Complexity\\n- Time complexity:$$O(n + n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(100001)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        int[] minMax = {Integer.MAX_VALUE, Integer.MIN_VALUE};\\n        List[] indexPos = getElementIndexAndMinMax(arr, minMax);\\n        long[] distances = new long[arr.length];\\n        List<Integer> positions;\\n        while(minMax[0] <= minMax[1]) {\\n            positions = indexPos[minMax[0]];\\n            if (positions != null) {\\n                addPositions(distances, positions);\\n            }\\n            minMax[0]++;\\n        }\\n        return distances;\\n    }\\n\\n    private List[] getElementIndexAndMinMax(int[] arr, int[] minMax) {\\n        List[] indexPos = new List[100_001];\\n        for(int i = 0; i < arr.length; i++) {\\n            minMax[0] = Math.min(minMax[0], arr[i]);    \\n            minMax[1] = Math.max(minMax[1], arr[i]);\\n            if (indexPos[arr[i]] == null) {\\n                indexPos[arr[i]] = new ArrayList<>();\\n            }\\n            List<Integer> positions = indexPos[arr[i]];\\n            positions.add(i);\\n        }\\n        return indexPos;\\n    }\\n\\n    private void addPositions(long[] distances, List<Integer> positions) {\\n        if (positions.size() == 1) {\\n            distances[positions.get(0)] = 0;\\n        } else {\\n            long sumOfDistances = 0L, diffOnLeft, diffOnRight, prefixSum = 0L;\\n            for (int position : positions) {\\n                sumOfDistances += position;\\n            }\\n            int pos;\\n            for (int i = 0; i < positions.size(); i++) {\\n                pos = positions.get(i);\\n                // (x -a) + (x - b) + (x -c) == 3x - (a+b+c). (Reversing them to avoid math.abs)\\n                diffOnLeft = i == 0 ? 0 : (long) i * pos - prefixSum;\\n                diffOnRight = (sumOfDistances - (prefixSum + pos)) - (pos * (long)(positions.size() -1 - i));\\n                distances[pos] = diffOnLeft + diffOnRight;\\n                prefixSum += pos;\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        int[] minMax = {Integer.MAX_VALUE, Integer.MIN_VALUE};\\n        List[] indexPos = getElementIndexAndMinMax(arr, minMax);\\n        long[] distances = new long[arr.length];\\n        List<Integer> positions;\\n        while(minMax[0] <= minMax[1]) {\\n            positions = indexPos[minMax[0]];\\n            if (positions != null) {\\n                addPositions(distances, positions);\\n            }\\n            minMax[0]++;\\n        }\\n        return distances;\\n    }\\n\\n    private List[] getElementIndexAndMinMax(int[] arr, int[] minMax) {\\n        List[] indexPos = new List[100_001];\\n        for(int i = 0; i < arr.length; i++) {\\n            minMax[0] = Math.min(minMax[0], arr[i]);    \\n            minMax[1] = Math.max(minMax[1], arr[i]);\\n            if (indexPos[arr[i]] == null) {\\n                indexPos[arr[i]] = new ArrayList<>();\\n            }\\n            List<Integer> positions = indexPos[arr[i]];\\n            positions.add(i);\\n        }\\n        return indexPos;\\n    }\\n\\n    private void addPositions(long[] distances, List<Integer> positions) {\\n        if (positions.size() == 1) {\\n            distances[positions.get(0)] = 0;\\n        } else {\\n            long sumOfDistances = 0L, diffOnLeft, diffOnRight, prefixSum = 0L;\\n            for (int position : positions) {\\n                sumOfDistances += position;\\n            }\\n            int pos;\\n            for (int i = 0; i < positions.size(); i++) {\\n                pos = positions.get(i);\\n                // (x -a) + (x - b) + (x -c) == 3x - (a+b+c). (Reversing them to avoid math.abs)\\n                diffOnLeft = i == 0 ? 0 : (long) i * pos - prefixSum;\\n                diffOnRight = (sumOfDistances - (prefixSum + pos)) - (pos * (long)(positions.size() -1 - i));\\n                distances[pos] = diffOnLeft + diffOnRight;\\n                prefixSum += pos;\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239580,
                "title": "left-and-right-very-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) \\n    {\\n         //final vector to be returned from the function\\n         vector<long long>ans(arr.size(),0);    \\n\\n         //the sum would be contributed form the left part and the rightpart\\n         \\n         //using the map for taking the contribution form the left\\n\\n         //the map will store <ele,pair<sum of index,count of the element>>\\n         unordered_map<int,pair<long long int,long long int>>mp;\\n         \\n         //traversing form the left to right to take the left contribution\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             int ele = arr[i];\\n\\n             //if the curr element is encountered for the first time\\n             //it means it has no identical pairing for the index previously\\n             if(mp.find(ele) == mp.end())\\n             {\\n                  mp[ele].first+=i;\\n                  mp[ele].second+=1;\\n                  ans[i]+=0;\\n             }\\n             else    //if the curr ele has also occured previously\\n             {\\n                    long long int prvsum = mp[ele].first;\\n                    long long int prvcount = mp[ele].second;\\n                   \\n                    long long int leftsum = 0LL+(prvcount*i) - (prvsum);\\n                    ans[i]+=leftsum;\\n\\n                    //taking the mapping of the curr element and its index\\n                    mp[ele].first+=i;\\n                    mp[ele].second+=1;\\n             }\\n         }\\n\\n         //clearing map to use the same map for generating the right ans\\n         mp.clear();\\n\\n         //traversing the array from the right to left\\n         for(int i=arr.size()-1;i>=0;i--)\\n         {\\n             //finding out the curr ele\\n             int ele = arr[i];\\n\\n             //if the curr element has occurred for the first time \\n             //it means that it has no further occuring in the right from the curr pos\\n             if(mp.find(ele) == mp.end())\\n             {\\n                 mp[ele].first+=i;\\n                 mp[ele].second+=1;\\n                 ans[i]+=0;\\n             }\\n             else //it mean the ele has occured again\\n             {\\n                  long long int sum = mp[ele].first;\\n                  long long int count = mp[ele].second;\\n                   \\n                  //calculating the rightsum\\n                  long long int rightsum = 0LL+( sum - (count*i));\\n                  \\n                  //taking the rightsum into the account\\n                  ans[i]+=rightsum; \\n\\n                  //taking the mapping of the curr element and its index\\n                  mp[ele].first+=i;\\n                  mp[ele].second+=1;\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) \\n    {\\n         //final vector to be returned from the function\\n         vector<long long>ans(arr.size(),0);    \\n\\n         //the sum would be contributed form the left part and the rightpart\\n         \\n         //using the map for taking the contribution form the left\\n\\n         //the map will store <ele,pair<sum of index,count of the element>>\\n         unordered_map<int,pair<long long int,long long int>>mp;\\n         \\n         //traversing form the left to right to take the left contribution\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             int ele = arr[i];\\n\\n             //if the curr element is encountered for the first time\\n             //it means it has no identical pairing for the index previously\\n             if(mp.find(ele) == mp.end())\\n             {\\n                  mp[ele].first+=i;\\n                  mp[ele].second+=1;\\n                  ans[i]+=0;\\n             }\\n             else    //if the curr ele has also occured previously\\n             {\\n                    long long int prvsum = mp[ele].first;\\n                    long long int prvcount = mp[ele].second;\\n                   \\n                    long long int leftsum = 0LL+(prvcount*i) - (prvsum);\\n                    ans[i]+=leftsum;\\n\\n                    //taking the mapping of the curr element and its index\\n                    mp[ele].first+=i;\\n                    mp[ele].second+=1;\\n             }\\n         }\\n\\n         //clearing map to use the same map for generating the right ans\\n         mp.clear();\\n\\n         //traversing the array from the right to left\\n         for(int i=arr.size()-1;i>=0;i--)\\n         {\\n             //finding out the curr ele\\n             int ele = arr[i];\\n\\n             //if the curr element has occurred for the first time \\n             //it means that it has no further occuring in the right from the curr pos\\n             if(mp.find(ele) == mp.end())\\n             {\\n                 mp[ele].first+=i;\\n                 mp[ele].second+=1;\\n                 ans[i]+=0;\\n             }\\n             else //it mean the ele has occured again\\n             {\\n                  long long int sum = mp[ele].first;\\n                  long long int count = mp[ele].second;\\n                   \\n                  //calculating the rightsum\\n                  long long int rightsum = 0LL+( sum - (count*i));\\n                  \\n                  //taking the rightsum into the account\\n                  ans[i]+=rightsum; \\n\\n                  //taking the mapping of the curr element and its index\\n                  mp[ele].first+=i;\\n                  mp[ele].second+=1;\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232273,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        // map --> sum of indices , count\\n        unordered_map<int,pair<long long,long long>>mp;\\n        vector<long long>ans(arr.size());\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(mp.find(arr[i])==mp.end())\\n            {\\n                mp[arr[i]].first+=i;\\n                mp[arr[i]].second++;\\n                ans[i]=0;\\n            }\\n            else \\n            {\\n                long long int count=mp[arr[i]].second;\\n                long long int sum=mp[arr[i]].first;\\n                long long val=count*i-sum;\\n                ans[i]=val;\\n                mp[arr[i]].first+=i;\\n                mp[arr[i]].second++;\\n            }\\n        }\\n        mp.clear();\\n        for(int i=arr.size()-1;i>=0;i--)\\n        {\\n            if(mp.find(arr[i])==mp.end())\\n            {\\n                mp[arr[i]].first+=i;\\n                mp[arr[i]].second++;\\n            }\\n            else\\n            {\\n                long long int count=mp[arr[i]].second;\\n                long long int sum=mp[arr[i]].first;\\n                long long val=sum-count*i;\\n                ans[i]+=val;\\n                mp[arr[i]].first+=i;\\n                mp[arr[i]].second++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        // map --> sum of indices , count\\n        unordered_map<int,pair<long long,long long>>mp;\\n        vector<long long>ans(arr.size());\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(mp.find(arr[i])==mp.end())\\n            {\\n                mp[arr[i]].first+=i;\\n                mp[arr[i]].second++;\\n                ans[i]=0;\\n            }\\n            else \\n            {\\n                long long int count=mp[arr[i]].second;\\n                long long int sum=mp[arr[i]].first;\\n                long long val=count*i-sum;\\n                ans[i]=val;\\n                mp[arr[i]].first+=i;\\n                mp[arr[i]].second++;\\n            }\\n        }\\n        mp.clear();\\n        for(int i=arr.size()-1;i>=0;i--)\\n        {\\n            if(mp.find(arr[i])==mp.end())\\n            {\\n                mp[arr[i]].first+=i;\\n                mp[arr[i]].second++;\\n            }\\n            else\\n            {\\n                long long int count=mp[arr[i]].second;\\n                long long int sum=mp[arr[i]].first;\\n                long long val=sum-count*i;\\n                ans[i]+=val;\\n                mp[arr[i]].first+=i;\\n                mp[arr[i]].second++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229913,
                "title": "swift-solution-with-detailed-explanation",
                "content": "# Approach\\n1. We create a dictionary called \"map\" and \"ps\".\\n2. We create a variable called \"n\" and set it to the length of the array.\\n3. We create an array called \"ans\" and set it to an array of 0s the length of the array.\\n4. We iterate through the array, setting the value of i to the index of the array.\\n5. We create a variable called \"value\" and set it to the value of the key at the current index of the array in the dictionary \"map\".\\n6. If the value of the key at the current index of the array in the dictionary \"map\" is not nil, we set the value of the variable \"times\" to the value of the key at the current index of the array in the dictionary \"map\".\\n7. If the value of the key at the current index of the array in the dictionary \"map\" is not nil, we set the value of the variable \"value\" to the value of the variable \"times\" multiplied by the value of the variable \"i\" minus the value of the key at the current index of the array in the dictionary \"ps\".\\n8. We set the value of the key at the current index of the array in the dictionary \"ans\" to the value of the variable \"value\".\\n9. We set the value of the key at the current index of the array in the dictionary \"map\" to the value of the key at the current index of the array in the dictionary \"map\" plus 1.\\n10. We set the value of the key at the current index of the array in the dictionary \"ps\" to the value of the key at the current index of the array in the dictionary \"ps\" plus the value of the variable \"i\".\\n11. We remove all the key-value pairs from the dictionary \"map\".\\n12. We remove all the key-value pairs from the dictionary \"ps\".\\n13. We create a variable called \"itr\" and set it to 0.\\n14. We iterate through the array in reverse, setting the value of i to the index of the array.\\n15. We create a variable called \"value\" and set it to the value of the key at the current index of the array in the dictionary \"map\".\\n16. If the value of the key at the current index of the array in the dictionary \"map\" is not nil, we set the value of the variable \"times\" to the value of the key at the current index of the array in the dictionary \"map\".\\n17. If the value of the key at the current index of the array in the dictionary \"map\" is not nil, we set the value of the variable \"value\" to the value of the variable \"times\" multiplied by the value of the variable \"itr\" minus the value of the key at the current index of the array in the dictionary \"ps\".\\n18. We set the value of the key at the current index of the array in the dictionary \"ans\" to the value of the key at the current index of the array in the dictionary \"ans\" plus the value of the variable \"value\".\\n19. We set the value of the key at the current index of the array in the dictionary \"map\" to the value of the key at the current index of the array in the dictionary \"map\" plus 1.\\n20. We set the value of the key at the current index of the array in the dictionary \"ps\" to the value of the key at the current index of the array in the dictionary \"ps\" plus the value of the variable \"itr\".\\n21. We set the value of the variable \"itr\" to the value of the variable \"itr\" plus 1.\\n22. We return the dictionary \"ans\"\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    func getDistances(_ arr: [Int]) -> [Int]\\n    {\\n        var map = [Int: Int]()\\n        var ps = [Int: Int]()\\n\\n        var n = arr.count\\n        var ans = [Int](repeating: 0, count: n)\\n\\n        for i in 0..<arr.count\\n        {\\n            if let value = map[arr[i]]\\n            {\\n                let times = value\\n                let value = (times * i) - ps[arr[i]]!\\n                ans[i] += value\\n            }\\n            map[arr[i]] = (map[arr[i]] ?? 0) + 1\\n            ps[arr[i]] = (ps[arr[i]] ?? 0) + i\\n        }\\n\\n        map.removeAll()\\n        ps.removeAll()\\n\\n        var itr = 0\\n        for i in (0..<n).reversed()\\n        {\\n            if let value = map[arr[i]]\\n            {\\n                let times = value\\n                let value = (times * itr) - ps[arr[i]]!\\n                ans[i] += value\\n            }\\n            map[arr[i]] = (map[arr[i]] ?? 0) + 1\\n            ps[arr[i]] = (ps[arr[i]] ?? 0) + itr\\n            itr += 1\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution\\n{\\n    func getDistances(_ arr: [Int]) -> [Int]\\n    {\\n        var map = [Int: Int]()\\n        var ps = [Int: Int]()\\n\\n        var n = arr.count\\n        var ans = [Int](repeating: 0, count: n)\\n\\n        for i in 0..<arr.count\\n        {\\n            if let value = map[arr[i]]\\n            {\\n                let times = value\\n                let value = (times * i) - ps[arr[i]]!\\n                ans[i] += value\\n            }\\n            map[arr[i]] = (map[arr[i]] ?? 0) + 1\\n            ps[arr[i]] = (ps[arr[i]] ?? 0) + i\\n        }\\n\\n        map.removeAll()\\n        ps.removeAll()\\n\\n        var itr = 0\\n        for i in (0..<n).reversed()\\n        {\\n            if let value = map[arr[i]]\\n            {\\n                let times = value\\n                let value = (times * itr) - ps[arr[i]]!\\n                ans[i] += value\\n            }\\n            map[arr[i]] = (map[arr[i]] ?? 0) + 1\\n            ps[arr[i]] = (ps[arr[i]] ?? 0) + itr\\n            itr += 1\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198422,
                "title": "easy-c-o-n-solution-suffix-and-prefix-array",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<long long> getDistances(vector<int>& arr) {\\n        //element value as  key  and {lasIndex,cnt} as pair\\n        unordered_map<int,pair<ll,ll>> mp;\\n        vector<ll> res(arr.size(),0);\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int val=arr[i];\\n            if(mp.find(arr[i])==mp.end())\\n            {\\n                //insert into mp\\n                mp[arr[i]]={i,1};\\n            }\\n            else{\\n                //get the dist and multiply with the num of values previous\\n                ll lastCnt=mp[val].second;\\n                ll lastIndx=mp[val].first;\\n                ll curr=(res[lastIndx])+(i-lastIndx)*(lastCnt);\\n                res[i]=curr;\\n                mp[val]={i,lastCnt+1};\\n            }\\n        }\\n        vector<ll> res2(arr.size(),0);\\n        //now from right to left\\n        mp.clear();\\n        for(int j=arr.size()-1;j>=0;j--)\\n        {\\n            int val=arr[j];\\n            if(mp.find(arr[j])==mp.end())\\n                mp[val]={j,1};\\n            else{\\n                ll lastCnt=mp[val].second;\\n                ll lastIndx=mp[val].first;\\n                ll curr=(res2[lastIndx])+(lastIndx-j)*(lastCnt);\\n                res2[j]=curr;\\n                mp[val]={j,lastCnt+1};\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++)\\n            res[i]+=res2[i];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<long long> getDistances(vector<int>& arr) {\\n        //element value as  key  and {lasIndex,cnt} as pair\\n        unordered_map<int,pair<ll,ll>> mp;\\n        vector<ll> res(arr.size(),0);\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int val=arr[i];\\n            if(mp.find(arr[i])==mp.end())\\n            {\\n                //insert into mp\\n                mp[arr[i]]={i,1};\\n            }\\n            else{\\n                //get the dist and multiply with the num of values previous\\n                ll lastCnt=mp[val].second;\\n                ll lastIndx=mp[val].first;\\n                ll curr=(res[lastIndx])+(i-lastIndx)*(lastCnt);\\n                res[i]=curr;\\n                mp[val]={i,lastCnt+1};\\n            }\\n        }\\n        vector<ll> res2(arr.size(),0);\\n        //now from right to left\\n        mp.clear();\\n        for(int j=arr.size()-1;j>=0;j--)\\n        {\\n            int val=arr[j];\\n            if(mp.find(arr[j])==mp.end())\\n                mp[val]={j,1};\\n            else{\\n                ll lastCnt=mp[val].second;\\n                ll lastIndx=mp[val].first;\\n                ll curr=(res2[lastIndx])+(lastIndx-j)*(lastCnt);\\n                res2[j]=curr;\\n                mp[val]={j,lastCnt+1};\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++)\\n            res[i]+=res2[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109482,
                "title": "c-solution",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<int, vector<int>> mp;\\n        int n = arr.size();\\n\\n        for(int i = 0; i < arr.size(); i++) mp[arr[i]].push_back(i);\\n        \\n        vector<long long> pre_sum(n), suff_sum(n), ans(n);\\n        for(auto j: mp) {\\n            auto v = j.second;\\n            for(int i = 1; i < v.size(); i++) \\n                pre_sum[v[i]] = pre_sum[v[i - 1]] + i * (v[i] - v[i - 1]);\\n        }\\n        \\n        for(auto j: mp) {\\n            auto v = j.second;\\n            for(int i = v.size() - 2; i >= 0; i--) \\n                suff_sum[v[i]] = suff_sum[v[i + 1]] + long(v.size() - i - 1) * (v[i + 1] - v[i]);\\n        }\\n\\n        for(int i = 0; i < n; i++) \\n            ans[i] = pre_sum[i] + suff_sum[i];\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<int, vector<int>> mp;\\n        int n = arr.size();\\n\\n        for(int i = 0; i < arr.size(); i++) mp[arr[i]].push_back(i);\\n        \\n        vector<long long> pre_sum(n), suff_sum(n), ans(n);\\n        for(auto j: mp) {\\n            auto v = j.second;\\n            for(int i = 1; i < v.size(); i++) \\n                pre_sum[v[i]] = pre_sum[v[i - 1]] + i * (v[i] - v[i - 1]);\\n        }\\n        \\n        for(auto j: mp) {\\n            auto v = j.second;\\n            for(int i = v.size() - 2; i >= 0; i--) \\n                suff_sum[v[i]] = suff_sum[v[i + 1]] + long(v.size() - i - 1) * (v[i + 1] - v[i]);\\n        }\\n\\n        for(int i = 0; i < n; i++) \\n            ans[i] = pre_sum[i] + suff_sum[i];\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092221,
                "title": "python-index-o-n",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        index = defaultdict(list)\\n        for i, a in enumerate(arr):\\n            index[a].append(i)\\n        n = len(arr)\\n        res = [0]*n\\n        for k in index:\\n            cur = 0\\n            for j in range(1, len(index[k])):\\n                cur += index[k][j] - index[k][0]\\n            res[index[k][0]] = cur\\n            left, right = 1, len(index[k]) - 1\\n            for j in range(1, len(index[k])):\\n                cur += -(right - left)*(index[k][j] - index[k][j-1])\\n                res[index[k][j]] = cur\\n                left += 1\\n                right -= 1\\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        index = defaultdict(list)\\n        for i, a in enumerate(arr):\\n            index[a].append(i)\\n        n = len(arr)\\n        res = [0]*n\\n        for k in index:\\n            cur = 0\\n            for j in range(1, len(index[k])):\\n                cur += index[k][j] - index[k][0]\\n            res[index[k][0]] = cur\\n            left, right = 1, len(index[k]) - 1\\n            for j in range(1, len(index[k])):\\n                cur += -(right - left)*(index[k][j] - index[k][j-1])\\n                res[index[k][j]] = cur\\n                left += 1\\n                right -= 1\\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027853,
                "title": "python-my-own-unique-solution-beats-70-traverse-only-array-twice",
                "content": "A good solution I spotted from others, is actually traversing the hashmap afterward. Here is a solution for traversing only the array, but sacrificing memory complexity to map the index of array to an index (nested hash) \\nYou don\\'t need suffix array actually (extra memory)\\nOne prefix array is enough. The smaller hashtable is storing the index of the index in the prefix array of arr[i].\\n\\n\\n```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        hashpref = {}\\n        res = []\\n        \\n        for i in range(len(arr)):\\n            if arr[i] not in hashpref:\\n                hashpref[arr[i]] = {\\'pref\\':[0],\\'hash\\':{}}\\n                hashpref[arr[i]][\\'pref\\'].append(i)\\n                hashpref[arr[i]][\\'hash\\'][i] = 1\\n            else:\\n                hashpref[arr[i]][\\'pref\\'].append(hashpref[arr[i]][\\'pref\\'][-1]+i)\\n                hashpref[arr[i]][\\'hash\\'][i] = len(hashpref[arr[i]][\\'pref\\'])-1\\n            \\n        for i in range(len(arr)):\\n            index = hashpref[arr[i]][\\'hash\\'][i]\\n            pref = hashpref[arr[i]][\\'pref\\']\\n            cur = (index-1)*i-pref[index-1] + (pref[-1]-pref[index]) - (len(pref)-1-index)*i\\n            res.append(cur)\\n        return res",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        hashpref = {}",
                "codeTag": "Java"
            },
            {
                "id": 3024533,
                "title": "easy-to-understand-o-n-time-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n\\n        map1 = {}\\n        map2 = {}\\n        n = len(arr)\\n        ans = [0 for i in range(0,n)]\\n        \\n        for i in range(0,n):\\n\\n            if(arr[i] not in map1):\\n\\n                map1[arr[i]] = (i,1) \\n            \\n            else:\\n\\n                s,c  = map1[arr[i]]\\n              \\n                ans[i] =  c*i - s\\n               \\n                map1[arr[i]] = (s+i,c+1)\\n        \\n   \\n        for i in range(n-1,-1,-1):\\n\\n            if(arr[i] not in map2):\\n\\n                map2[arr[i]] = (i,1) \\n            \\n            else:\\n\\n                s,c  = map2[arr[i]]\\n             \\n                ans[i] += s - c*i \\n         \\n                map2[arr[i]] = (s+i,c+1)\\n        \\n\\n        return ans\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n\\n        map1 = {}\\n        map2 = {}\\n        n = len(arr)\\n        ans = [0 for i in range(0,n)]\\n        \\n        for i in range(0,n):\\n\\n            if(arr[i] not in map1):\\n\\n                map1[arr[i]] = (i,1) \\n            \\n            else:\\n\\n                s,c  = map1[arr[i]]\\n              \\n                ans[i] =  c*i - s\\n               \\n                map1[arr[i]] = (s+i,c+1)\\n        \\n   \\n        for i in range(n-1,-1,-1):\\n\\n            if(arr[i] not in map2):\\n\\n                map2[arr[i]] = (i,1) \\n            \\n            else:\\n\\n                s,c  = map2[arr[i]]\\n             \\n                ans[i] += s - c*i \\n         \\n                map2[arr[i]] = (s+i,c+1)\\n        \\n\\n        return ans\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010836,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        lookup = defaultdict(list)\\n        \\n        for i,val in enumerate(arr):\\n            lookup[val].append(i)\\n\\n        for key,vals in lookup.items():\\n            prefix = list(accumulate(vals, initial = 0))\\n\\n            result = []\\n            for i,x in enumerate(vals):\\n                result.append(prefix[-1] - prefix[i] - prefix[i+1] - (len(vals) - 2*i-1)*x)\\n            lookup[key] = deque(result)\\n\\n        return [lookup[x].popleft() for x in arr]\\n            \\n\\n                \\n      \\n                 \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        lookup = defaultdict(list)\\n        \\n        for i,val in enumerate(arr):\\n            lookup[val].append(i)\\n\\n        for key,vals in lookup.items():\\n            prefix = list(accumulate(vals, initial = 0))\\n\\n            result = []\\n            for i,x in enumerate(vals):\\n                result.append(prefix[-1] - prefix[i] - prefix[i+1] - (len(vals) - 2*i-1)*x)\\n            lookup[key] = deque(result)\\n\\n        return [lookup[x].popleft() for x in arr]\\n            \\n\\n                \\n      \\n                 \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976899,
                "title": "c-prefix-sum-suffix-sum-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        vector<long long> ans(n);\\n        unordered_map<long long,vector<long long>> ourmap;\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n            ourmap[arr[i]].push_back(i);\\n        }\\n        unordered_map<long long,vector<long long>> :: iterator it=ourmap.begin();\\n        while(it!=ourmap.end()){\\n            \\n            vector<long long> temp=it->second;\\n            if(temp.size()==1){\\n                ans[temp[0]]=0;\\n            }\\n            else{\\n                vector<long long> prefix(temp.size());\\n                vector<long long> suffix(temp.size());\\n                long long sum=0;\\n                for(int i=0;i<temp.size();i++){\\n                    sum=sum+temp[i];\\n                    prefix[i]=sum;\\n                }\\n                sum=0;\\n                for(int i=temp.size()-1;i>=0;i--){\\n                    sum=sum+temp[i];\\n                    suffix[i]=sum;\\n                }\\n                for(int i=0;i<temp.size();i++){\\n                    \\n                    if(i==0){\\n                        ans[temp[i]]=(suffix[i]-temp[i])-((long long)(temp.size()-1)*temp[i]);\\n                    }\\n                    else if(i==temp.size()-1){\\n                        ans[temp[i]]=(long long)((temp.size()-1)*temp[i])-(prefix[i]-temp[i]);\\n                    }\\n                    else{\\n                        ans[temp[i]]=((suffix[i]-temp[i])-(long long)(temp[i]*(temp.size()-1-i)))+((long long)(i*temp[i])-(prefix[i]-temp[i]));\\n                    }\\n                }\\n            }\\n            it++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        vector<long long> ans(n);\\n        unordered_map<long long,vector<long long>> ourmap;\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n            ourmap[arr[i]].push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2957084,
                "title": "head-hurting-solution-don-t-downvote-just-for-fun",
                "content": "I honestly don\\'t know why this was the very first solution that came to my mind. Upon analysing the approach for 2 minutes, I figured that it will pass and not give TLE. (and it actually beats 45% time, although it takes a lot and lot of space)\\nIt is the exact opposite of elegant. I don\\'t know why I thought this would be a good solution. But, as this was the first approach that came to my mind, I simply coded it.\\n\\nYou can skip this, if you don\\'t want to hurt your head. But if you are getting bored, you are more than welcome to try. \\n\\nOne Tiny Request : I am just posting this for fun. Kindly don\\'t downvote. I, in no way, claim that it is a good approach. (as clear by the title itself)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<int,set<int>> pos;\\n        for(int i=0;i<arr.size();i++) {\\n            pos[arr[i]].insert(i);\\n        }\\n        unordered_map<int,vector<long long>> posPrefixSum;\\n        unordered_map<int,long long> count;\\n        vector<long long> temp;\\n        for(auto itr=pos.begin();itr!=pos.end();itr++) {\\n            temp.push_back(0);\\n            for(int i : itr->second) {\\n                temp.push_back(temp.back()+i);\\n            }\\n            posPrefixSum[itr->first] = temp;\\n            temp.clear();\\n            count[itr->first] = 1;\\n        }\\n        vector<long long> ans(arr.size());\\n        for(int i=0;i<arr.size();i++) {\\n            ans[i] = (posPrefixSum[arr[i]].back()-posPrefixSum[arr[i]][count[arr[i]]]) - (i*(pos[arr[i]].size()-count[arr[i]])) + \\n                     (i*(count[arr[i]]-1)) - (posPrefixSum[arr[i]][count[arr[i]]-1]);\\n            count[arr[i]] ++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<int,set<int>> pos;\\n        for(int i=0;i<arr.size();i++) {\\n            pos[arr[i]].insert(i);\\n        }\\n        unordered_map<int,vector<long long>> posPrefixSum;\\n        unordered_map<int,long long> count;\\n        vector<long long> temp;\\n        for(auto itr=pos.begin();itr!=pos.end();itr++) {\\n            temp.push_back(0);\\n            for(int i : itr->second) {\\n                temp.push_back(temp.back()+i);\\n            }\\n            posPrefixSum[itr->first] = temp;\\n            temp.clear();\\n            count[itr->first] = 1;\\n        }\\n        vector<long long> ans(arr.size());\\n        for(int i=0;i<arr.size();i++) {\\n            ans[i] = (posPrefixSum[arr[i]].back()-posPrefixSum[arr[i]][count[arr[i]]]) - (i*(pos[arr[i]].size()-count[arr[i]])) + \\n                     (i*(count[arr[i]]-1)) - (posPrefixSum[arr[i]][count[arr[i]]-1]);\\n            count[arr[i]] ++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929590,
                "title": "using-two-hashmap-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<long long,long long>cntMap,sumMap;\\n        int n=arr.size();\\n        vector<long long >ans(n,0);\\n        for(int i=0;i<n;i++){\\n            ans[i]+=(cntMap[arr[i]]*i)-(sumMap[arr[i]]);\\n           cntMap[arr[i]]++;\\n           sumMap[arr[i]]+=i;\\n        }\\n        cntMap.clear();\\n        sumMap.clear();\\n        for(int i=n-1;i>=0;i--){\\n            ans[i]+=(sumMap[arr[i]])-(cntMap[arr[i]]*i);\\n           cntMap[arr[i]]++;\\n           sumMap[arr[i]]+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<long long,long long>cntMap,sumMap;\\n        int n=arr.size();\\n        vector<long long >ans(n,0);\\n        for(int i=0;i<n;i++){\\n            ans[i]+=(cntMap[arr[i]]*i)-(sumMap[arr[i]]);\\n           cntMap[arr[i]]++;\\n           sumMap[arr[i]]+=i;\\n        }\\n        cntMap.clear();\\n        sumMap.clear();\\n        for(int i=n-1;i>=0;i--){\\n            ans[i]+=(sumMap[arr[i]])-(cntMap[arr[i]]*i);\\n           cntMap[arr[i]]++;\\n           sumMap[arr[i]]+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915370,
                "title": "o-n-faster-solution-hash-table-maths",
                "content": "# Intuition\\nUsed the answer of previous index of the same value and added the product of its occurences and difference between its intervals.\\n\\n# Approach\\nThe first vector is used for left intervals of all the same values.\\nThe second vector is used for right intervals of all the same values.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr){\\n        int n=arr.size();\\n        vector<long long> ans(n,0);\\n        vector<long long> res(n,0);\\n        unordered_map<int,int> count,index;\\n        for(int i=0; i<n; i++){\\n            int num=arr[i];\\n            int freq=count[num];\\n            if(freq!=0){\\n                int diff=i-index[num];\\n                ans[i]+=ans[index[num]];\\n                ans[i]+=1ll*diff*freq;\\n            }\\n            count[num]++;\\n            index[num]=i;\\n        }\\n        count.clear(); index.clear();\\n        for(int i=n-1; i>=0; i--){\\n            int num=arr[i];\\n            int freq=count[num];\\n            if(freq!=0){\\n                int diff=index[num]-i;\\n                res[i]+=res[index[num]];\\n                res[i]+=1ll*diff*freq;\\n            }\\n            count[num]++;\\n            index[num]=i;\\n        }\\n        for(int i=0; i<n; i++){\\n            ans[i]+=res[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr){\\n        int n=arr.size();\\n        vector<long long> ans(n,0);\\n        vector<long long> res(n,0);\\n        unordered_map<int,int> count,index;\\n        for(int i=0; i<n; i++){\\n            int num=arr[i];\\n            int freq=count[num];\\n            if(freq!=0){\\n                int diff=i-index[num];\\n                ans[i]+=ans[index[num]];\\n                ans[i]+=1ll*diff*freq;\\n            }\\n            count[num]++;\\n            index[num]=i;\\n        }\\n        count.clear(); index.clear();\\n        for(int i=n-1; i>=0; i--){\\n            int num=arr[i];\\n            int freq=count[num];\\n            if(freq!=0){\\n                int diff=index[num]-i;\\n                res[i]+=res[index[num]];\\n                res[i]+=1ll*diff*freq;\\n            }\\n            count[num]++;\\n            index[num]=i;\\n        }\\n        for(int i=0; i<n; i++){\\n            ans[i]+=res[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895361,
                "title": "easy-understanding-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        std::vector<long long> res(arr.size(), 0);\\n        std::unordered_map<int, std::vector<long long>> num_to_indices;\\n        \\n        for(long long i=0; i < arr.size(); i++) {\\n            num_to_indices[arr[i]].push_back(i);\\n        }\\n        \\n        for(auto const& ele: num_to_indices) {\\n            auto const& indices = ele.second;\\n            for(int i = 1; i < indices.size(); i++) {\\n                res[indices[0]] += std::abs(indices[i]-indices[0]);\\n            }\\n            for(int i = 1; i < indices.size(); i++) {\\n\\t\\t\\t    // Not simplifying this line intentionally for better understanding.\\n                res[indices[i]] = res[indices[i-1]] - (indices[i]-indices[i-1])*(indices.size()-i-1) + (indices[i]-indices[i-1])*(i-1);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        std::vector<long long> res(arr.size(), 0);\\n        std::unordered_map<int, std::vector<long long>> num_to_indices;\\n        \\n        for(long long i=0; i < arr.size(); i++) {\\n            num_to_indices[arr[i]].push_back(i);\\n        }\\n        \\n        for(auto const& ele: num_to_indices) {\\n            auto const& indices = ele.second;\\n            for(int i = 1; i < indices.size(); i++) {\\n                res[indices[0]] += std::abs(indices[i]-indices[0]);\\n            }\\n            for(int i = 1; i < indices.size(); i++) {\\n\\t\\t\\t    // Not simplifying this line intentionally for better understanding.\\n                res[indices[i]] = res[indices[i-1]] - (indices[i]-indices[i-1])*(indices.size()-i-1) + (indices[i]-indices[i-1])*(i-1);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880102,
                "title": "simple-formula-with-o-1-space-cost",
                "content": "Formula: for each vector in unordered_map\\n\\t\\t\\t\\tans[idx] = (countLeft * idx - sumLeft) + (sumRight - countRight * idx)\\n\\t\\t\\t\\t              = sumRight - sumLeft + (countLeft - countRight) * idx\\n\\t\\t\\t\\t\\t\\t\\t  = sumRight - sumLeft + k * idx\\n\\t\\t\\t\\t\\t\\t\\t  \\nWe can easily find that k is start from 0 - (n-1) and end with (n-1) - 0.\\nuse [2,3,3,3,2,3,3] as an instance, unordered_map here would be:\\nmp[3] = {1, 2, 3, 5, 6}\\nmp[2] = {0, 4}\\nuse first vec={1, 2, 3, 5, 6}, we can generate ans[1], ans[2], ans[3], ans[5], ans[6],\\nhere ans[1] = sumRight - sumLeft + (countLeft - countRight) * idx\\n                    = (2+3+5+6) - (0) + (0 - 4) * 1\\n\\t\\t\\t\\t\\t= 12\\n\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i < arr.size(); i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<long long> ans(arr.size());\\n        for(auto& [_, vec]: mp){\\n            int64_t left = 0, right = accumulate(vec.begin(), vec.end(), (int64_t)0), k = 1 - vec.size();\\n            for(auto& v: vec){\\n                right -= v;\\n                ans[v] = right - left + k * v;\\n                left += v;\\n                k += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i < arr.size(); i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<long long> ans(arr.size());\\n        for(auto& [_, vec]: mp){\\n            int64_t left = 0, right = accumulate(vec.begin(), vec.end(), (int64_t)0), k = 1 - vec.size();\\n            for(auto& v: vec){\\n                right -= v;\\n                ans[v] = right - left + k * v;\\n                left += v;\\n                k += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876758,
                "title": "prefix-sum-o-n-easy-to-understand-code-with-comments",
                "content": "class Solution {\\npublic:\\n\\t\\t\\tvector<long long> getDistances(vector<int>& arr) {\\n\\t\\t\\t\\tvector<long long> ans(arr.size());\\n\\t\\t\\t\\tunordered_map<int, vector<int>> mp;\\n\\t\\t\\t\\t// store index of same elements in an unordered_map\\n\\t\\t\\t\\tfor(int i = 0; i < arr.size(); ++i){\\n\\t\\t\\t\\t\\tmp[arr[i]].push_back(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(auto it : mp){\\n\\t\\t\\t\\t\\tif(it.second.size() == 1){\\n\\t\\t\\t\\t\\t\\tans[it.second[0]] = 0;\\n\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t// If count of same elements is > 1 then use prefix sum and calculate the sum \\n\\t\\t\\t\\t\\t\\t// of diff of current index with all indices\\n\\t\\t\\t\\t\\t\\tvector<int> &v = it.second;\\n\\t\\t\\t\\t\\t\\tvector<long long> left_sum(v.size(), 0);\\n\\t\\t\\t\\t\\t\\tvector<long long> right_sum(v.size(), 0);\\n\\t\\t\\t\\t\\t\\tint n = v.size();\\n\\t\\t\\t\\t\\t\\tfor(int j = n - 2; j >= 0; --j){\\n\\t\\t\\t\\t\\t\\t\\tright_sum[j] = (v[j + 1] - v[j]) * (n - 1 - j) + right_sum[j + 1]; \\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tfor(int i = 1; i < v.size(); ++i){\\n\\t\\t\\t\\t\\t\\t\\tleft_sum[i] = (v[i] - v[i - 1]) * i + left_sum[i - 1];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < v.size(); ++i){\\n\\t\\t\\t\\t\\t\\t\\tans[v[i]] = left_sum[i] + right_sum[i];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n};",
                "solutionTags": [
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n\\t\\t\\tvector<long long> getDistances(vector<int>& arr) {\\n\\t\\t\\t\\tvector<long long> ans(arr.size());\\n\\t\\t\\t\\tunordered_map<int, vector<int>> mp;\\n\\t\\t\\t\\t// store index of same elements in an unordered_map\\n\\t\\t\\t\\tfor(int i = 0; i < arr.size(); ++i){\\n\\t\\t\\t\\t\\tmp[arr[i]].push_back(i);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2825374,
                "title": "easy-java-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        HashMap<Integer, Long> ps = new HashMap<>();\\n\\n        int n = arr.length;\\n        long[] ans = new long[n];\\n\\n        for(int i = 0 ; i < arr.length ; i ++){\\n            if(map.containsKey(arr[i])){\\n                long times = (long)map.get(arr[i]);\\n                long value = (times*(long)i) - (long)ps.get(arr[i]);\\n                ans[i]+= value;\\n            }\\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n            ps.put(arr[i], ps.getOrDefault(arr[i], 0l) + (long)i);\\n        }\\n\\n        map.clear();\\n        ps.clear();\\n\\n        int itr = 0;\\n        for(int i = n - 1; i >= 0 ; i--){\\n            if(map.containsKey(arr[i])){\\n                long times = (long)map.get(arr[i]);\\n                long value = (times*(long)itr) - (long)ps.get(arr[i]);\\n                ans[i]+= value;\\n            }\\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n            ps.put(arr[i], ps.getOrDefault(arr[i], 0l) + (long)itr);\\n            itr++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        HashMap<Integer, Long> ps = new HashMap<>();\\n\\n        int n = arr.length;\\n        long[] ans = new long[n];\\n\\n        for(int i = 0 ; i < arr.length ; i ++){\\n            if(map.containsKey(arr[i])){\\n                long times = (long)map.get(arr[i]);\\n                long value = (times*(long)i) - (long)ps.get(arr[i]);\\n                ans[i]+= value;\\n            }\\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n            ps.put(arr[i], ps.getOrDefault(arr[i], 0l) + (long)i);\\n        }\\n\\n        map.clear();\\n        ps.clear();\\n\\n        int itr = 0;\\n        for(int i = n - 1; i >= 0 ; i--){\\n            if(map.containsKey(arr[i])){\\n                long times = (long)map.get(arr[i]);\\n                long value = (times*(long)itr) - (long)ps.get(arr[i]);\\n                ans[i]+= value;\\n            }\\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n            ps.put(arr[i], ps.getOrDefault(arr[i], 0l) + (long)itr);\\n            itr++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813708,
                "title": "easy-c-solution",
                "content": "# Intuition\\nFinding the solution for the current problem using solution of the previous problem!!\\n\\n# Approach\\nstep1:Store the first occurence of every unique element in an unordered_map.\\nstep2:Finding the solution for every first occurence of a unique element.This is needed in the computation of upcoming elements. \\nstep3:Use this formula which i have mentioned in the else block of a for loop.We generally construct the solution for current problem using next problem.\\n-We have to add some portion that is diff(diff that is difference b/w current index and the previous index where that element found earlier)\\n--Add:(total elements  - no of elements till that index)*diff\\n--Sub:(no of elements till that index - 2)*diff  \\nAlso update the map and make it point to the current index because we are construting the soln from previous one.\\n# Complexity\\n- Time complexity:\\n0(N)\\n\\n- Space complexity:\\n0(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        vector<long long> ans(arr.size(),0);\\n        unordered_map<int,pair<int,int>> mp;//element---{index-number of elements}\\n        for(int i=0;i<arr.size();i++){\\n            if(mp.find(arr[i])==mp.end())\\n                mp[arr[i]].first = i;\\n            mp[arr[i]].second += 1; \\n        }\\n        //finding the soln for first case!!!\\n        for(int i=0;i<arr.size();i++){\\n            ans[mp[arr[i]].first] += (i - mp[arr[i]].first); \\n        }\\n        unordered_map<int,int> track;\\n        for(int i=0;i<arr.size();i++){\\n            ++track[arr[i]];\\n            if(track[arr[i]]==1) continue;\\n            else{\\n                int diff = i - mp[arr[i]].first;\\n                ans[i] = ans[mp[arr[i]].first] - (mp[arr[i]].second-track[arr[i]])*diff;\\n                if(track[arr[i]]-2>0) ans[i] += (track[arr[i]]-2)*diff;\\n                mp[arr[i]].first = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        vector<long long> ans(arr.size(),0);\\n        unordered_map<int,pair<int,int>> mp;//element---{index-number of elements}\\n        for(int i=0;i<arr.size();i++){\\n            if(mp.find(arr[i])==mp.end())\\n                mp[arr[i]].first = i;\\n            mp[arr[i]].second += 1; \\n        }\\n        //finding the soln for first case!!!\\n        for(int i=0;i<arr.size();i++){\\n            ans[mp[arr[i]].first] += (i - mp[arr[i]].first); \\n        }\\n        unordered_map<int,int> track;\\n        for(int i=0;i<arr.size();i++){\\n            ++track[arr[i]];\\n            if(track[arr[i]]==1) continue;\\n            else{\\n                int diff = i - mp[arr[i]].first;\\n                ans[i] = ans[mp[arr[i]].first] - (mp[arr[i]].second-track[arr[i]])*diff;\\n                if(track[arr[i]]-2>0) ans[i] += (track[arr[i]]-2)*diff;\\n                mp[arr[i]].first = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797169,
                "title": "striver-s-method-java-solution-using-prefix-and-suffixsum",
                "content": "\\n\\n# Approach\\nWill iterate on the array two times-\\n1-we will maintain two hashmap one with frequency count and other with prefixsum \\n2-we will maintain two hashmap one with frequency count and other with suffixsum \\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        HashMap<Integer,Long>cmp=new HashMap<>();\\n        HashMap<Integer,Long>smp=new HashMap<>();\\n        int n=arr.length;\\n        long[] ans=new long[arr.length];\\n        for(int i=0;i<n;i++){\\n            ans[i]+=(cmp.getOrDefault(arr[i],0L)*i)-(smp.getOrDefault(arr[i],0L));\\n            cmp.put(arr[i],cmp.getOrDefault(arr[i],0L)+1);\\n            smp.put(arr[i],smp.getOrDefault(arr[i],0L)+i);\\n        }\\n        cmp=new HashMap<>();\\n        smp=new HashMap<>();\\n\\n\\n        for(int i=n-1;i>=0;i--){\\n            ans[i]+=(smp.getOrDefault(arr[i],0L)-(cmp.getOrDefault(arr[i],0L)*i));\\n            cmp.put(arr[i],cmp.getOrDefault(arr[i],0L)+1);\\n            smp.put(arr[i],smp.getOrDefault(arr[i],0L)+i);\\n        } \\n        return ans;\\n\\n\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        HashMap<Integer,Long>cmp=new HashMap<>();\\n        HashMap<Integer,Long>smp=new HashMap<>();\\n        int n=arr.length;\\n        long[] ans=new long[arr.length];\\n        for(int i=0;i<n;i++){\\n            ans[i]+=(cmp.getOrDefault(arr[i],0L)*i)-(smp.getOrDefault(arr[i],0L));\\n            cmp.put(arr[i],cmp.getOrDefault(arr[i],0L)+1);\\n            smp.put(arr[i],smp.getOrDefault(arr[i],0L)+i);\\n        }\\n        cmp=new HashMap<>();\\n        smp=new HashMap<>();\\n\\n\\n        for(int i=n-1;i>=0;i--){\\n            ans[i]+=(smp.getOrDefault(arr[i],0L)-(cmp.getOrDefault(arr[i],0L)*i));\\n            cmp.put(arr[i],cmp.getOrDefault(arr[i],0L)+1);\\n            smp.put(arr[i],smp.getOrDefault(arr[i],0L)+i);\\n        } \\n        return ans;\\n\\n\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784582,
                "title": "java-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to group indices based on their values. Then for each value, calculate the total difference for its first index. Keep the difference between indices smaller to it and larger to it separately. Solve using prefix sum approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n       Map<Integer, List<Integer>> in = new HashMap<>();\\n\\n       for(int i = 0; i < arr.length; i++) {\\n           in.putIfAbsent(arr[i], new ArrayList<Integer>());\\n           in.get(arr[i]).add(i);\\n       }\\n\\n       long[] ans = new long[arr.length];\\n       for(int i: in.keySet()) {\\n           long smaller = 0, larger = 0;\\n           int st = in.get(i).get(0);\\n           for(int j = 1; j < in.get(i).size(); j++) {\\n               larger += in.get(i).get(j) - st;\\n           }\\n           ans[st] = larger;\\n           for(int j = 1; j < in.get(i).size(); j++) {\\n               smaller += (j - 1) * (in.get(i).get(j) - in.get(i).get(j - 1));\\n               larger -= (in.get(i).size() - j - 1) * (in.get(i).get(j) - in.get(i).get(j - 1));\\n               ans[in.get(i).get(j)] = smaller + larger;\\n           }\\n       }\\n\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n       Map<Integer, List<Integer>> in = new HashMap<>();\\n\\n       for(int i = 0; i < arr.length; i++) {\\n           in.putIfAbsent(arr[i], new ArrayList<Integer>());\\n           in.get(arr[i]).add(i);\\n       }\\n\\n       long[] ans = new long[arr.length];\\n       for(int i: in.keySet()) {\\n           long smaller = 0, larger = 0;\\n           int st = in.get(i).get(0);\\n           for(int j = 1; j < in.get(i).size(); j++) {\\n               larger += in.get(i).get(j) - st;\\n           }\\n           ans[st] = larger;\\n           for(int j = 1; j < in.get(i).size(); j++) {\\n               smaller += (j - 1) * (in.get(i).get(j) - in.get(i).get(j - 1));\\n               larger -= (in.get(i).size() - j - 1) * (in.get(i).get(j) - in.get(i).get(j - 1));\\n               ans[in.get(i).get(j)] = smaller + larger;\\n           }\\n       }\\n\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748328,
                "title": "java-tc-o-n-simple-two-passes-beats-100",
                "content": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        \\n        long[] res = new long[arr.length];\\n        \\n        int[] lastI = new int[100001];\\n        int[] count = new int[100001];\\n        \\n        for (int i = arr.length-1; i >= 0; i--) {\\n            if (count[arr[i]] != 0) {\\n                res[i] = (lastI[arr[i]]-i) * count[arr[i]] + res[lastI[arr[i]]];\\n            }\\n            count[arr[i]]++;\\n            lastI[arr[i]] = i;\\n        }\\n        \\n        lastI = new int[100001];\\n        count = new int[100001];\\n        long[] tmpRes = new long[arr.length];\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (count[arr[i]] != 0) {\\n                tmpRes[i] = (i - lastI[arr[i]]) * count[arr[i]] + tmpRes[lastI[arr[i]]];\\n                res[i] += tmpRes[i];\\n            }\\n            count[arr[i]]++;\\n            lastI[arr[i]] = i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        \\n        long[] res = new long[arr.length];\\n        \\n        int[] lastI = new int[100001];\\n        int[] count = new int[100001];\\n        \\n        for (int i = arr.length-1; i >= 0; i--) {\\n            if (count[arr[i]] != 0) {\\n                res[i] = (lastI[arr[i]]-i) * count[arr[i]] + res[lastI[arr[i]]];\\n            }\\n            count[arr[i]]++;\\n            lastI[arr[i]] = i;\\n        }\\n        \\n        lastI = new int[100001];\\n        count = new int[100001];\\n        long[] tmpRes = new long[arr.length];\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (count[arr[i]] != 0) {\\n                tmpRes[i] = (i - lastI[arr[i]]) * count[arr[i]] + tmpRes[lastI[arr[i]]];\\n                res[i] += tmpRes[i];\\n            }\\n            count[arr[i]]++;\\n            lastI[arr[i]] = i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747916,
                "title": "java-prefix-and-suffix-array",
                "content": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        long[] res = new long[100001];\\n        long[] countArr = new long[100001];\\n        long[] pLArr = new long[100001];\\n        long[] pRArr = new long[100001];\\n        \\n        for(int i=0;i<arr.length;i++){\\n            countArr[arr[i]]++;\\n            pLArr[arr[i]] += i;\\n            res[i] += countArr[arr[i]]*i-pLArr[arr[i]];\\n        }\\n        \\n        countArr = new long[100001];\\n        \\n        for(int i=arr.length-1;i>=0;i--){\\n            countArr[arr[i]]++;\\n            pRArr[arr[i]] += i;\\n            res[i] += Math.abs(countArr[arr[i]]*i-pRArr[arr[i]]);\\n        }\\n        long[] r = new long[arr.length];\\n        for(int i=0;i<arr.length;i++){\\n            r[i] = res[i];\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        long[] res = new long[100001];\\n        long[] countArr = new long[100001];\\n        long[] pLArr = new long[100001];\\n        long[] pRArr = new long[100001];\\n        \\n        for(int i=0;i<arr.length;i++){\\n            countArr[arr[i]]++;\\n            pLArr[arr[i]] += i;\\n            res[i] += countArr[arr[i]]*i-pLArr[arr[i]];\\n        }\\n        \\n        countArr = new long[100001];\\n        \\n        for(int i=arr.length-1;i>=0;i--){\\n            countArr[arr[i]]++;\\n            pRArr[arr[i]] += i;\\n            res[i] += Math.abs(countArr[arr[i]]*i-pRArr[arr[i]]);\\n        }\\n        long[] r = new long[arr.length];\\n        for(int i=0;i<arr.length;i++){\\n            r[i] = res[i];\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746496,
                "title": "java-hashmap-prefixsum-suffixsum",
                "content": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        int n = arr.length;\\n        long[] res = new long[n];\\n        \\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i=0; i<n; i++) {\\n            map.putIfAbsent(arr[i], new ArrayList<Integer>());\\n            map.get(arr[i]).add(i);\\n        }\\n        \\n        for (Map.Entry<Integer, List<Integer>> entry: map.entrySet()) {\\n            List<Integer> list = entry.getValue();\\n            \\n            int size = list.size();\\n            \\n            long[] prefixSum = new long[size];\\n            \\n            prefixSum[0] = list.get(0);\\n            for (int i = 1; i < size; i++) {\\n                prefixSum[i] = prefixSum[i-1] + (long)list.get(i);\\n            }\\n            \\n            long[] suffixSum = new long[size];\\n            \\n            suffixSum[size-1] = list.get(size-1);\\n            for (int i = size-2; i >= 0; i--) {\\n                suffixSum[i] = suffixSum[i+1] + (long)list.get(i);\\n            }\\n            \\n            for (int i = 0; i < size; i++) {\\n                res[list.get(i)] = (2*i+1-size) * (long)list.get(i) + suffixSum[i] - prefixSum[i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        int n = arr.length;\\n        long[] res = new long[n];\\n        \\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i=0; i<n; i++) {\\n            map.putIfAbsent(arr[i], new ArrayList<Integer>());\\n            map.get(arr[i]).add(i);\\n        }\\n        \\n        for (Map.Entry<Integer, List<Integer>> entry: map.entrySet()) {\\n            List<Integer> list = entry.getValue();\\n            \\n            int size = list.size();\\n            \\n            long[] prefixSum = new long[size];\\n            \\n            prefixSum[0] = list.get(0);\\n            for (int i = 1; i < size; i++) {\\n                prefixSum[i] = prefixSum[i-1] + (long)list.get(i);\\n            }\\n            \\n            long[] suffixSum = new long[size];\\n            \\n            suffixSum[size-1] = list.get(size-1);\\n            for (int i = size-2; i >= 0; i--) {\\n                suffixSum[i] = suffixSum[i+1] + (long)list.get(i);\\n            }\\n            \\n            for (int i = 0; i < size; i++) {\\n                res[list.get(i)] = (2*i+1-size) * (long)list.get(i) + suffixSum[i] - prefixSum[i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746356,
                "title": "python-dp-with-prefix-sum-and-only-prefix-sum-solution-with-explanation",
                "content": "\\n### dp with prefix sum\\nthe basic idea is\\naggregate the indexs whose corresponding value are the same using hash map,\\nTo calaulate difference for the index ```i```, we can use prefix sum```pre[i]``` and suffix sum```post[i]```\\n```pre[i]``` represents the sum of the difference from the index before ```i```\\n```post[i]```  represents the sum of the difference from the index after ```i```\\nwe want to find ```pre[i] + post[i]``` for each index ```i```\\nfor example,\\n```\\nidx = [2,3,5,6,7], size = 5\\n\\ni   0 1 2 3 4\\nidx 2 3 5 6 7\\npre[1] = 3-2\\npre[2] = (5-3)+(5-2) = 2*(5-3)+(3-2)\\npre[i] = i*(idx[i]-idx[i-1]) + pre[i-1]\\n\\npost[2] = (7-5) + (6-5)\\npost[3] = (7-6) = 2 * (5-6) + (7-5) + (6-5)\\npost[i] = (size-i)*(idx[i-1]-idx[i]) + post[i-1]\\n\\nans[i] = pre[i] + post[i] \\nans[i] = i*(idx[i]-idx[i-1]) + pre[i-1] + (size-i)*(idx[i-1]-idx[i]) + post[i-1] \\n       = (2i-size) * (idx[i]-idx[i-1]) + ans[i-1]\\n```\\ntc is ```O(N)```, sc is the same as tc.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        numToIdxs = defaultdict(list)\\n        for idx, n in enumerate(arr):\\n            numToIdxs[n].append(idx) # aggregate the indexs whose corresponding value are the same\\n        ans = [0] * len(arr)\\n        for idxs in numToIdxs.values():\\n            s = sum(i-idxs[0] for i in idxs) # find ans[0], sum of difference of all index and first index \\n            ans[idxs[0]] = s\\n            k = len(idxs)\\n            for i in range(1, k):\\n                s += (2 * i - k) * (idxs[i] - idxs[i-1]) # ans[i] = (2i-size) * (idx[i]-idx[i-1]) + ans[i-1]\\n                ans[idxs[i]] = s\\n        return ans\\n```\\n\\n### only prefix sum\\nit is a kind of brute force, but exactly ```O(N)```\\nthe basic idea is\\naggregate the indexs whose corresponding value are the same using hash map,\\nThe difference is calculate prefix sum for these indexs, and we find the sum of the difference from the index before ```i```  and after ```i```\\n\\n```\\nidx = [2,3,5,6,7], size = 5\\n\\n    i       0 1  2  3  4\\n    idx     2 3  5  6  7\\nprefix sum  2 5 10 16 23\\n\\n         before i + after i\\nans[3] = (3 * idx[3] - prefix sum[2]) +  ((prefix sum[4] - prefix sum[3]) - 3 * (5-1-i))\\nans[i] = i * idx[i] - prefix sum[i-1] + max prefix sum - prefix sum[i] - idx[i] * (size-1-i)\\n       = - prefix sum[i-1] + max prefix sum - prefix sum[i] -idx[i] * (size-1-2i)\\n```\\n\\nthe quention is that we need a view to find prefix sum array with correspoding value and find the prefix sum value with correnspoding index,\\nSo I use hash map to store prefix sum, key is correnspoding index, value are ```(prefix sum value, its index for prefix sum array)``` and we need to find max prefix sum, so also track max prefix sum in hash map, and ```size``` of prefix sum array  can be found in size of hasp map. \\n\\ntc is ```O(N)```, sc is the same as tc.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        numToIdxs = defaultdict(dict)\\n        for idx, n in enumerate(arr):\\n            if len(numToIdxs[n]) == 0:\\n                numToIdxs[n][idx] = (0, idx) # initialize prefix sum\\n                numToIdxs[n][\\'maxSum\\'] = idx # track max prefix sum\\n            else:\\n                numToIdxs[n][\\'maxSum\\'] += idx # track max prefix sum\\n                numToIdxs[n][idx] = (len(numToIdxs[n])-1, numToIdxs[n][\\'maxSum\\']) # prefix sum\\n        for i in range(len(arr)):\\n            n = arr[i]\\n            prefixSumIdx, prefixSum = numToIdxs[n][i]\\n            maxPrefixSum, PrefixSumLen = numToIdxs[n][\\'maxSum\\'], len(numToIdxs[n]) - 1\\n\\t\\t\\t# ans[i] = - prefix sum[i-1] + max prefix sum - prefix sum[i] -idx[i] * (size-1-2i)\\n            arr[i] = -(prefixSum - i) + maxPrefixSum - prefixSum - (PrefixSumLen-1-2*prefixSumIdx) * i\\n        return arr\\n```\\n\\n```python\\n\\'\\'\\'\\nprefix sum only\\nthere has a array stores index where nums[index] are the same value.\\ne.g. arr = [2,5,6]\\nwe want to calaulate ans[1] = 5 - 2 + 6 - 5 = 4\\nwe can calculate prefix sum first, prefix = [0,2,7,13], prefix sum for arr[1](=5) is 7\\nans[1] = arr[1] * (index of prefix = 2) - 7 + (last sum of prefix - 7) - arr[1] * (number of element on the right of arr[1] = 1)\\n\\t   = 5 * 2 - 7 + (13 - 7) - 5 * 1 = 3 + 1 = 4\\n\\'\\'\\'\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        valueToPrefix = collections.defaultdict(lambda: [[0], 0])\\n        for idx, v in enumerate(arr):\\n            prefix = valueToPrefix[v][0]\\n            prefix.append(prefix[-1] + idx)\\n        ans = [0] * len(arr)\\n        for idx, v in enumerate(arr):\\n            prefix = valueToPrefix[v][0]\\n            if len(prefix) == 2: continue\\n            valueToPrefix[v][1] += 1\\n            cur = valueToPrefix[v][1]\\n            ans[idx] = idx * cur - prefix[cur] + (prefix[-1] - prefix[cur]) - idx * (len(prefix) - cur - 1)\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```i```\n```pre[i]```\n```post[i]```\n```pre[i]```\n```i```\n```post[i]```\n```i```\n```pre[i] + post[i]```\n```i```\n```\\nidx = [2,3,5,6,7], size = 5\\n\\ni   0 1 2 3 4\\nidx 2 3 5 6 7\\npre[1] = 3-2\\npre[2] = (5-3)+(5-2) = 2*(5-3)+(3-2)\\npre[i] = i*(idx[i]-idx[i-1]) + pre[i-1]\\n\\npost[2] = (7-5) + (6-5)\\npost[3] = (7-6) = 2 * (5-6) + (7-5) + (6-5)\\npost[i] = (size-i)*(idx[i-1]-idx[i]) + post[i-1]\\n\\nans[i] = pre[i] + post[i] \\nans[i] = i*(idx[i]-idx[i-1]) + pre[i-1] + (size-i)*(idx[i-1]-idx[i]) + post[i-1] \\n       = (2i-size) * (idx[i]-idx[i-1]) + ans[i-1]\\n```\n```O(N)```\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        numToIdxs = defaultdict(list)\\n        for idx, n in enumerate(arr):\\n            numToIdxs[n].append(idx) # aggregate the indexs whose corresponding value are the same\\n        ans = [0] * len(arr)\\n        for idxs in numToIdxs.values():\\n            s = sum(i-idxs[0] for i in idxs) # find ans[0], sum of difference of all index and first index \\n            ans[idxs[0]] = s\\n            k = len(idxs)\\n            for i in range(1, k):\\n                s += (2 * i - k) * (idxs[i] - idxs[i-1]) # ans[i] = (2i-size) * (idx[i]-idx[i-1]) + ans[i-1]\\n                ans[idxs[i]] = s\\n        return ans\\n```\n```O(N)```\n```i```\n```i```\n```\\nidx = [2,3,5,6,7], size = 5\\n\\n    i       0 1  2  3  4\\n    idx     2 3  5  6  7\\nprefix sum  2 5 10 16 23\\n\\n         before i + after i\\nans[3] = (3 * idx[3] - prefix sum[2]) +  ((prefix sum[4] - prefix sum[3]) - 3 * (5-1-i))\\nans[i] = i * idx[i] - prefix sum[i-1] + max prefix sum - prefix sum[i] - idx[i] * (size-1-i)\\n       = - prefix sum[i-1] + max prefix sum - prefix sum[i] -idx[i] * (size-1-2i)\\n```\n```(prefix sum value, its index for prefix sum array)```\n```size```\n```O(N)```\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        numToIdxs = defaultdict(dict)\\n        for idx, n in enumerate(arr):\\n            if len(numToIdxs[n]) == 0:\\n                numToIdxs[n][idx] = (0, idx) # initialize prefix sum\\n                numToIdxs[n][\\'maxSum\\'] = idx # track max prefix sum\\n            else:\\n                numToIdxs[n][\\'maxSum\\'] += idx # track max prefix sum\\n                numToIdxs[n][idx] = (len(numToIdxs[n])-1, numToIdxs[n][\\'maxSum\\']) # prefix sum\\n        for i in range(len(arr)):\\n            n = arr[i]\\n            prefixSumIdx, prefixSum = numToIdxs[n][i]\\n            maxPrefixSum, PrefixSumLen = numToIdxs[n][\\'maxSum\\'], len(numToIdxs[n]) - 1\\n\\t\\t\\t# ans[i] = - prefix sum[i-1] + max prefix sum - prefix sum[i] -idx[i] * (size-1-2i)\\n            arr[i] = -(prefixSum - i) + maxPrefixSum - prefixSum - (PrefixSumLen-1-2*prefixSumIdx) * i\\n        return arr\\n```\n```python\\n\\'\\'\\'\\nprefix sum only\\nthere has a array stores index where nums[index] are the same value.\\ne.g. arr = [2,5,6]\\nwe want to calaulate ans[1] = 5 - 2 + 6 - 5 = 4\\nwe can calculate prefix sum first, prefix = [0,2,7,13], prefix sum for arr[1](=5) is 7\\nans[1] = arr[1] * (index of prefix = 2) - 7 + (last sum of prefix - 7) - arr[1] * (number of element on the right of arr[1] = 1)\\n\\t   = 5 * 2 - 7 + (13 - 7) - 5 * 1 = 3 + 1 = 4\\n\\'\\'\\'\\nclass Solution:\\n    def getDistances(self, arr: List[int]) -> List[int]:\\n        valueToPrefix = collections.defaultdict(lambda: [[0], 0])\\n        for idx, v in enumerate(arr):\\n            prefix = valueToPrefix[v][0]\\n            prefix.append(prefix[-1] + idx)\\n        ans = [0] * len(arr)\\n        for idx, v in enumerate(arr):\\n            prefix = valueToPrefix[v][0]\\n            if len(prefix) == 2: continue\\n            valueToPrefix[v][1] += 1\\n            cur = valueToPrefix[v][1]\\n            ans[idx] = idx * cur - prefix[cur] + (prefix[-1] - prefix[cur]) - idx * (len(prefix) - cur - 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746170,
                "title": "o-n-time-o-n-space-for-beginners",
                "content": "\\n\\n\\n\\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        Map<Integer,List<Long>> m=new HashMap<>();\\n        int n=arr.length;\\n        long r[]=new long[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!m.containsKey(arr[i]))\\n            m.put(arr[i],new ArrayList<>());\\n            m.get(arr[i]).add((long)i);   // Added all index in a list\\n            \\n        }\\n        for(List<Long> l:m.values())\\n        {\\n           // System.out.println(l);\\n            long sum=0;\\n            for(int j=1;j<l.size();j++)\\n            {\\n                \\n                l.set(j,(long)l.get(j)+(long)l.get(j-1));        // added all index , to get total sum of all index for any value, \\n            \\n            \\n            }\\n            \\n        }\\n        Map<Integer,Integer> poi=new HashMap<>();    //this will tell which index of particular value, like whether number 5\\'s first index or second index is being talked about\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!poi.containsKey(arr[i]))\\n            poi.put(arr[i],0);\\n            int y=poi.get(arr[i]);\\n            long pivot=m.get(arr[i]).get(y);\\n            int totlen=m.get(arr[i]).size();\\n            long prefix=0;\\n            long suffix=0;\\n            long finalsum=(long)(m.get(arr[i]).get(totlen-1));\\n            suffix=finalsum-pivot;\\n            prefix=pivot-i;\\n            long plen=((long)(-(totlen-y-1)+(y))*(long)i);        //1 2 3 4 5 6    if for index 2 ,there are three elements on right, 2 on left, so difference is 1, so add that 1*3 to the number\\n           // System.out.println(suffix+\" \"+prefix+\" \"+plen+\" \"+y);\\n            r[i]=(long)suffix-(long)prefix+(long)plen;\\n            poi.put(arr[i],poi.get(arr[i])+1);\\n            \\n        }\\n        return r;\\n    }\\n}\\n```\\n\\n\\n\\n 2 2 2 2 2 2 2   lets disucss this, its list will be  2-> {0,1,2,3,4,5,6}\\n this list becomes={0,1,3,6,10,15,21}    //prefix sum\\n for index 0,  prefix=0  suffix=21-0=21      totalsum=suffix-prefix+(number of elements on left-number of elements on right)* index 0   = 21-0+(0-6)*0 =21\\n for index 1,    prefix=0,  suffix=21-1=20    totalsum=20-0-(1-5)*1=16\\n \\n and so on.....",
                "solutionTags": [
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        Map<Integer,List<Long>> m=new HashMap<>();\\n        int n=arr.length;\\n        long r[]=new long[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!m.containsKey(arr[i]))\\n            m.put(arr[i],new ArrayList<>());\\n            m.get(arr[i]).add((long)i);   // Added all index in a list\\n            \\n        }\\n        for(List<Long> l:m.values())\\n        {\\n           // System.out.println(l);\\n            long sum=0;\\n            for(int j=1;j<l.size();j++)\\n            {\\n                \\n                l.set(j,(long)l.get(j)+(long)l.get(j-1));        // added all index , to get total sum of all index for any value, \\n            \\n            \\n            }\\n            \\n        }\\n        Map<Integer,Integer> poi=new HashMap<>();    //this will tell which index of particular value, like whether number 5\\'s first index or second index is being talked about\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!poi.containsKey(arr[i]))\\n            poi.put(arr[i],0);\\n            int y=poi.get(arr[i]);\\n            long pivot=m.get(arr[i]).get(y);\\n            int totlen=m.get(arr[i]).size();\\n            long prefix=0;\\n            long suffix=0;\\n            long finalsum=(long)(m.get(arr[i]).get(totlen-1));\\n            suffix=finalsum-pivot;\\n            prefix=pivot-i;\\n            long plen=((long)(-(totlen-y-1)+(y))*(long)i);        //1 2 3 4 5 6    if for index 2 ,there are three elements on right, 2 on left, so difference is 1, so add that 1*3 to the number\\n           // System.out.println(suffix+\" \"+prefix+\" \"+plen+\" \"+y);\\n            r[i]=(long)suffix-(long)prefix+(long)plen;\\n            poi.put(arr[i],poi.get(arr[i])+1);\\n            \\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745198,
                "title": "easy-solution-o-n-tc-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n  \\n        unordered_map<int,vector<int>> mp;\\n        for (int i=0;i<arr.size();i++)\\n        {\\n            //cout<<arr[i]<<\" \"<<i<<endl;\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<long long> dp(arr.size());\\n        \\n        \\n        \\n        for (auto x:mp)   \\n        {\\n            long long int difference=0;\\n            \\n           for (int i=1;i<x.second.size();i++)\\n           {\\n               difference+=((x.second)[i]-(x.second)[0]);\\n           }\\n           \\n            \\n            dp[x.second[0]]+=difference;\\n            long long int tempdiff=0;\\n            long long int leftdiff=0;\\n            for (int i=1;i<x.second.size();i++)\\n            {\\n                leftdiff+=((x.second)[i]-(x.second)[i-1])*(i);\\n                tempdiff=(x.second)[i]-(x.second)[i-1];\\n                tempdiff=tempdiff*(x.second.size()-i);\\n                difference-=tempdiff;\\n                 \\n                dp[x.second[i]]+=difference;\\n                dp[x.second[i]]+=leftdiff;\\n            }   \\n            \\n            \\n        }\\n        return dp;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n  \\n        unordered_map<int,vector<int>> mp;\\n        for (int i=0;i<arr.size();i++)\\n        {\\n            //cout<<arr[i]<<\" \"<<i<<endl;\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<long long> dp(arr.size());\\n        \\n        \\n        \\n        for (auto x:mp)   \\n        {\\n            long long int difference=0;\\n            \\n           for (int i=1;i<x.second.size();i++)\\n           {\\n               difference+=((x.second)[i]-(x.second)[0]);\\n           }\\n           \\n            \\n            dp[x.second[0]]+=difference;\\n            long long int tempdiff=0;\\n            long long int leftdiff=0;\\n            for (int i=1;i<x.second.size();i++)\\n            {\\n                leftdiff+=((x.second)[i]-(x.second)[i-1])*(i);\\n                tempdiff=(x.second)[i]-(x.second)[i-1];\\n                tempdiff=tempdiff*(x.second.size()-i);\\n                difference-=tempdiff;\\n                 \\n                dp[x.second[i]]+=difference;\\n                dp[x.second[i]]+=leftdiff;\\n            }   \\n            \\n            \\n        }\\n        return dp;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2744924,
                "title": "c-o-n-solution-using-prefixsum",
                "content": "**C++ Code:**\\n**Please Upvote my Solution**\\n\\n```\\nvector<long long> getDistances(vector<int>& arr) {\\n    int n = arr.size();\\n    unordered_map<int,vector<long long>>m1,m2;\\n    for(int i=0;i<n;i++){\\n        m1[arr[i]].push_back(i);\\n        m2[arr[i]].push_back(i);\\n    }\\n    for(auto it = m1.begin();it!=m1.end();it++) {\\n        for(int j=1;j<(it->second).size();j++){\\n            m1[it->first][j] += m1[it->first][j-1]; \\n        }\\n    }\\n    vector<long long>ans(n); \\n    for(auto it=m1.begin();it!=m1.end();it++){\\n        int num = it->first;\\n        vector<long long>v=it->second;\\n        for(int i=0;i<v.size();i++){\\n             int index = m2[num][i];\\n             ans[index] = (long long)index*(i+1)-v[i] + (v[v.size()-1]-v[i])-index*(v.size()-i-1);\\n        }\\n       \\n    }\\n    return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<long long> getDistances(vector<int>& arr) {\\n    int n = arr.size();\\n    unordered_map<int,vector<long long>>m1,m2;\\n    for(int i=0;i<n;i++){\\n        m1[arr[i]].push_back(i);\\n        m2[arr[i]].push_back(i);\\n    }\\n    for(auto it = m1.begin();it!=m1.end();it++) {\\n        for(int j=1;j<(it->second).size();j++){\\n            m1[it->first][j] += m1[it->first][j-1]; \\n        }\\n    }\\n    vector<long long>ans(n); \\n    for(auto it=m1.begin();it!=m1.end();it++){\\n        int num = it->first;\\n        vector<long long>v=it->second;\\n        for(int i=0;i<v.size();i++){\\n             int index = m2[num][i];\\n             ans[index] = (long long)index*(i+1)-v[i] + (v[v.size()-1]-v[i])-index*(v.size()-i-1);\\n        }\\n       \\n    }\\n    return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2744539,
                "title": "prefix-sum",
                "content": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        \\n        class Data {\\n            int index;\\n            int count;\\n            long sum;\\n            public Data(int i, int c, long s) {\\n                index = i;\\n                count = c;\\n                sum = s;\\n            }\\n        }\\n        HashMap<Integer, Data> map = new HashMap<>();\\n        int n = arr.length;\\n        long[] ans = new long[n];\\n        for(int i = 0; i < n; ++i) {\\n            if(!map.containsKey(arr[i])) {\\n                Data data = new Data(i, 1, 0l);\\n                map.put(arr[i], data);\\n            }else {\\n                Data d = map.get(arr[i]);\\n                long diff = Math.abs(d.index - i)*d.count + d.sum ;\\n                ans[i] += diff;\\n                d.index = i;\\n                d.count++;\\n                d.sum = diff;\\n            }\\n        }\\n        \\n        map = new HashMap<>();\\n        for(int i = n-1; i >= 0; --i) {\\n            if(!map.containsKey(arr[i])) {\\n                Data data = new Data(i, 1, 0l);\\n                map.put(arr[i], data);\\n            }else {\\n                Data d = map.get(arr[i]);\\n                long diff = Math.abs(d.index - i)*d.count + d.sum ;\\n                ans[i] += diff;\\n                d.index = i;\\n                d.count++;\\n                d.sum = diff;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n// O(N)\\n// O(N)\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        \\n        class Data {\\n            int index;\\n            int count;\\n            long sum;\\n            public Data(int i, int c, long s) {\\n                index = i;\\n                count = c;\\n                sum = s;\\n            }\\n        }\\n        HashMap<Integer, Data> map = new HashMap<>();\\n        int n = arr.length;\\n        long[] ans = new long[n];\\n        for(int i = 0; i < n; ++i) {\\n            if(!map.containsKey(arr[i])) {\\n                Data data = new Data(i, 1, 0l);\\n                map.put(arr[i], data);\\n            }else {\\n                Data d = map.get(arr[i]);\\n                long diff = Math.abs(d.index - i)*d.count + d.sum ;\\n                ans[i] += diff;\\n                d.index = i;\\n                d.count++;\\n                d.sum = diff;\\n            }\\n        }\\n        \\n        map = new HashMap<>();\\n        for(int i = n-1; i >= 0; --i) {\\n            if(!map.containsKey(arr[i])) {\\n                Data data = new Data(i, 1, 0l);\\n                map.put(arr[i], data);\\n            }else {\\n                Data d = map.get(arr[i]);\\n                long diff = Math.abs(d.index - i)*d.count + d.sum ;\\n                ans[i] += diff;\\n                d.index = i;\\n                d.count++;\\n                d.sum = diff;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n// O(N)\\n// O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724375,
                "title": "python-prefix-sum-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef getDistances(self, arr: List[int]) -> List[int]:\\n\\t\\t\\thash = defaultdict(list)\\n\\t\\t\\tres = [0 for i in range(len(arr))]\\n\\n\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\thash[arr[i]].append(i)\\n\\n\\t\\t\\tfor key in hash.keys():\\n\\t\\t\\t\\tprefix = [hash[key][0]]\\n\\t\\t\\t\\tsuffix = [hash[key][-1]]\\n\\n\\t\\t\\t\\tfor i in range(1, len(hash[key])):\\n\\t\\t\\t\\t\\tprefix.append(prefix[-1] + hash[key][i])\\n\\n\\t\\t\\t\\tfor i in range(len(hash[key])-2, -1, -1):\\n\\t\\t\\t\\t\\tsuffix.append(suffix[-1] + hash[key][i])\\n\\n\\t\\t\\t\\tsuffix.reverse()\\n\\n\\t\\t\\t\\tfor i in range(len(hash[key])):\\n\\t\\t\\t\\t\\tval = 0\\n\\n\\t\\t\\t\\t\\tif i > 0:\\n\\t\\t\\t\\t\\t\\tval += abs(((i) * hash[key][i]) - prefix[i-1])\\n\\n\\t\\t\\t\\t\\tif i + 1 < len(hash[key]):\\n\\t\\t\\t\\t\\t\\tval += abs(suffix[i+1] - ((len(hash[key]) - 1 - i) * hash[key][i]))\\n\\n\\t\\t\\t\\t\\tres[hash[key][i]] = val\\n\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef getDistances(self, arr: List[int]) -> List[int]:\\n\\t\\t\\thash = defaultdict(list)\\n\\t\\t\\tres = [0 for i in range(len(arr))]\\n\\n\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\thash[arr[i]].append(i)\\n\\n\\t\\t\\tfor key in hash.keys():\\n\\t\\t\\t\\tprefix = [hash[key][0]]\\n\\t\\t\\t\\tsuffix = [hash[key][-1]]\\n\\n\\t\\t\\t\\tfor i in range(1, len(hash[key])):\\n\\t\\t\\t\\t\\tprefix.append(prefix[-1] + hash[key][i])\\n\\n\\t\\t\\t\\tfor i in range(len(hash[key])-2, -1, -1):\\n\\t\\t\\t\\t\\tsuffix.append(suffix[-1] + hash[key][i])\\n\\n\\t\\t\\t\\tsuffix.reverse()\\n\\n\\t\\t\\t\\tfor i in range(len(hash[key])):\\n\\t\\t\\t\\t\\tval = 0\\n\\n\\t\\t\\t\\t\\tif i > 0:\\n\\t\\t\\t\\t\\t\\tval += abs(((i) * hash[key][i]) - prefix[i-1])\\n\\n\\t\\t\\t\\t\\tif i + 1 < len(hash[key]):\\n\\t\\t\\t\\t\\t\\tval += abs(suffix[i+1] - ((len(hash[key]) - 1 - i) * hash[key][i]))\\n\\n\\t\\t\\t\\t\\tres[hash[key][i]] = val\\n\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2704723,
                "title": "easy-to-understand-c-solution",
                "content": "**Method - 1: -> TLE Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        vector<long long>ans;\\n        unordered_map<int,vector<int>>umv;\\n        for(int i = 0; i < arr.size(); i++) {\\n            umv[arr[i]].push_back(i);\\n        }\\n        for(int i = 0; i < arr.size(); i++) {\\n            vector<int>temp = umv[arr[i]];\\n            long long sum = 0;\\n            for(int j = 0; j < temp.size(); j++) {\\n                sum += abs(i - temp[j]);\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Method - 2: -> Accepted Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<long long>ans(n,0);\\n        unordered_map<int,long long>cntMap,sumMap;\\n        for(int i = 0; i < n; i++) {\\n            ans[i] += ((cntMap[arr[i]] * i * 1ll) - (sumMap[arr[i]]));\\n            cntMap[arr[i]]++;\\n            sumMap[arr[i]] += i;\\n        }\\n        cntMap.clear();\\n        sumMap.clear();\\n        for(int i = n - 1; i >= 0; i--) {\\n            ans[i] += ((sumMap[arr[i]]) - (cntMap[arr[i]] * i * 1ll));\\n            cntMap[arr[i]]++;\\n            sumMap[arr[i]] += i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        vector<long long>ans;\\n        unordered_map<int,vector<int>>umv;\\n        for(int i = 0; i < arr.size(); i++) {\\n            umv[arr[i]].push_back(i);\\n        }\\n        for(int i = 0; i < arr.size(); i++) {\\n            vector<int>temp = umv[arr[i]];\\n            long long sum = 0;\\n            for(int j = 0; j < temp.size(); j++) {\\n                sum += abs(i - temp[j]);\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<long long>ans(n,0);\\n        unordered_map<int,long long>cntMap,sumMap;\\n        for(int i = 0; i < n; i++) {\\n            ans[i] += ((cntMap[arr[i]] * i * 1ll) - (sumMap[arr[i]]));\\n            cntMap[arr[i]]++;\\n            sumMap[arr[i]] += i;\\n        }\\n        cntMap.clear();\\n        sumMap.clear();\\n        for(int i = n - 1; i >= 0; i--) {\\n            ans[i] += ((sumMap[arr[i]]) - (cntMap[arr[i]] * i * 1ll));\\n            cntMap[arr[i]]++;\\n            sumMap[arr[i]] += i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700210,
                "title": "java-simple-hashmap-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        int N = arr.length;\\n        long[] ansArr = new long[N];\\n\\n        HashMap<Integer, Integer> cnt = new HashMap<>();\\n        HashMap<Integer, Integer> num2Idx = new HashMap<>();\\n        HashMap<Integer, Long> num2Val = new HashMap<>();\\n\\n        // left -> right\\n        for(int i=0; i<N; i++) {\\n            int num = arr[i];\\n\\n            num2Val.put(num, num2Val.getOrDefault(num, 0l) + (i-num2Idx.getOrDefault(num, i))*cnt.getOrDefault(num, 0));\\n            \\n            ansArr[i] += num2Val.get(num);\\n\\n            num2Idx.put(num, i);\\n            cnt.put(num, cnt.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        cnt = new HashMap<>();\\n        num2Idx = new HashMap<>();\\n        num2Val = new HashMap<>();\\n        \\n        // right -> left\\n        for(int i=N-1; i>=0; i--) {\\n            int num = arr[i];\\n            \\n            num2Val.put(num, num2Val.getOrDefault(num, 0l) + (num2Idx.getOrDefault(num, i)-i)*cnt.getOrDefault(num, 0));\\n            \\n            ansArr[i] += num2Val.get(num);\\n\\n            num2Idx.put(num, i);\\n            cnt.put(num, cnt.getOrDefault(num, 0) + 1);\\n        }\\n\\n        return ansArr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] getDistances(int[] arr) {\\n        int N = arr.length;\\n        long[] ansArr = new long[N];\\n\\n        HashMap<Integer, Integer> cnt = new HashMap<>();\\n        HashMap<Integer, Integer> num2Idx = new HashMap<>();\\n        HashMap<Integer, Long> num2Val = new HashMap<>();\\n\\n        // left -> right\\n        for(int i=0; i<N; i++) {\\n            int num = arr[i];\\n\\n            num2Val.put(num, num2Val.getOrDefault(num, 0l) + (i-num2Idx.getOrDefault(num, i))*cnt.getOrDefault(num, 0));\\n            \\n            ansArr[i] += num2Val.get(num);\\n\\n            num2Idx.put(num, i);\\n            cnt.put(num, cnt.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        cnt = new HashMap<>();\\n        num2Idx = new HashMap<>();\\n        num2Val = new HashMap<>();\\n        \\n        // right -> left\\n        for(int i=N-1; i>=0; i--) {\\n            int num = arr[i];\\n            \\n            num2Val.put(num, num2Val.getOrDefault(num, 0l) + (num2Idx.getOrDefault(num, i)-i)*cnt.getOrDefault(num, 0));\\n            \\n            ansArr[i] += num2Val.get(num);\\n\\n            num2Idx.put(num, i);\\n            cnt.put(num, cnt.getOrDefault(num, 0) + 1);\\n        }\\n\\n        return ansArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656924,
                "title": "basic-math-which-simplifies-the-code",
                "content": "lets say, x is the element at positions i, j, k and l and consider the distance between current and previous occurence are a, b, c respectively - \\t \\n\\t i       j      k      l\\n       a       b     c\\nJust try to right the prefix distance for each pos of x in terms of a, b, c, which would be as following -\\n\\tprefix_distance[i] = 0\\n    prefix_distance[j] = a\\n    prefix_distance[k] = a+b+b = a+2b\\n    prefix_distance[l] = a+b+c+b+c+c = a+2b+3c\\nnow repeat the same process for postfix distance -\\n    prefix_distance[l] = 0\\n    prefix_distance[k] = c\\n    prefix_distance[j] = c+2b\\n    prefix_distance[i] = 3a+2b+c\\n\\t\\nThis gives us a hint that -\\nfor prefix, distance of element x at ith position can be written down in simple math -\\ndist[i] = dis[previous_occurence of x, say j] + #occurence of x*(distance between i and j)\\ndis[i] = dis[j] + (#occurence of x) * (j-i);\\n\\nuse the same formula for post fix.\\n\\n```\\nclass Solution {\\n    void calculatePrefixDistance(vector<int>& arr, vector<long long>& prefix) {\\n        unordered_map<int,vector<int>> posMap;\\n        for(int i=0; i<arr.size(); i++) {\\n            if(posMap.find(arr[i]) != posMap.end()) {\\n                prefix[i]=(long long) abs(posMap[arr[i]][0]-i) * posMap[arr[i]][1] + prefix[posMap[arr[i]][0]];\\n                posMap[arr[i]][0] = i;\\n                posMap[arr[i]][1]++;\\n            } else {\\n                posMap[arr[i]]={i,1};\\n                prefix[i] = 0;\\n            }\\n        }\\n    }\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        const int size = arr.size();\\n        vector<long long> prefix(size);\\n        vector<long long> postfix(size);\\n        calculatePrefixDistance(arr, prefix);\\n        reverse(arr.begin(), arr.end());\\n        calculatePrefixDistance(arr, postfix);\\n        reverse(postfix.begin(), postfix.end());\\n        for(int i=0; i<arr.size(); i++) {\\n            prefix[i]+=postfix[i];\\n        }\\n        return prefix;\\n    }\\n};\\n```\\nHopefully it might help some folks.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void calculatePrefixDistance(vector<int>& arr, vector<long long>& prefix) {\\n        unordered_map<int,vector<int>> posMap;\\n        for(int i=0; i<arr.size(); i++) {\\n            if(posMap.find(arr[i]) != posMap.end()) {\\n                prefix[i]=(long long) abs(posMap[arr[i]][0]-i) * posMap[arr[i]][1] + prefix[posMap[arr[i]][0]];\\n                posMap[arr[i]][0] = i;\\n                posMap[arr[i]][1]++;\\n            } else {\\n                posMap[arr[i]]={i,1};\\n                prefix[i] = 0;\\n            }\\n        }\\n    }\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        const int size = arr.size();\\n        vector<long long> prefix(size);\\n        vector<long long> postfix(size);\\n        calculatePrefixDistance(arr, prefix);\\n        reverse(arr.begin(), arr.end());\\n        calculatePrefixDistance(arr, postfix);\\n        reverse(postfix.begin(), postfix.end());\\n        for(int i=0; i<arr.size(); i++) {\\n            prefix[i]+=postfix[i];\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637506,
                "title": "c-solution-o-n-time-o-n-space-399ms-beats-98-20-112-5mb-beats-98-88",
                "content": "```\\nclass Solution {\\n    using i64 = long long;\\npublic:\\n    static vector<i64> getDistances(const vector<int>& arr) {\\n        const int n = size(arr);\\n        vector<i64> ret(n);\\n        unordered_map<int, pair<i64, i64>> m;\\n        for (int i = 0; i < n; ++i) {\\n            auto& [count, accu] = m[arr[i]];\\n            ret[i] += count * i - accu;\\n            ++count;\\n            accu += i;\\n        }\\n        m.clear();\\n        for (int i = n - 1; i >= 0; --i) {\\n            auto& [count, accu] = m[arr[i]];\\n            ret[i] += accu - count * i;\\n            ++count;\\n            accu += i;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    using i64 = long long;\\npublic:\\n    static vector<i64> getDistances(const vector<int>& arr) {\\n        const int n = size(arr);\\n        vector<i64> ret(n);\\n        unordered_map<int, pair<i64, i64>> m;\\n        for (int i = 0; i < n; ++i) {\\n            auto& [count, accu] = m[arr[i]];\\n            ret[i] += count * i - accu;\\n            ++count;\\n            accu += i;\\n        }\\n        m.clear();\\n        for (int i = n - 1; i >= 0; --i) {\\n            auto& [count, accu] = m[arr[i]];\\n            ret[i] += accu - count * i;\\n            ++count;\\n            accu += i;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1697215,
                "content": [
                    {
                        "username": "miha2k",
                        "content": "damn, this is hard\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The TLE kills me every time... it\\'s getting pretty annoying at this point :/"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/0789f2ff-1893-44d7-857b-17450edf660e_1640497970.9420185.png)\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be hard. Took me 3h to find the correct formula."
                    },
                    {
                        "username": "stefan1096",
                        "content": "It is a well-known problem and idea is simple if you know it already."
                    }
                ]
            },
            {
                "id": 1933833,
                "content": [
                    {
                        "username": "miha2k",
                        "content": "damn, this is hard\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The TLE kills me every time... it\\'s getting pretty annoying at this point :/"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/0789f2ff-1893-44d7-857b-17450edf660e_1640497970.9420185.png)\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be hard. Took me 3h to find the correct formula."
                    },
                    {
                        "username": "stefan1096",
                        "content": "It is a well-known problem and idea is simple if you know it already."
                    }
                ]
            },
            {
                "id": 1576124,
                "content": [
                    {
                        "username": "miha2k",
                        "content": "damn, this is hard\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The TLE kills me every time... it\\'s getting pretty annoying at this point :/"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/0789f2ff-1893-44d7-857b-17450edf660e_1640497970.9420185.png)\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be hard. Took me 3h to find the correct formula."
                    },
                    {
                        "username": "stefan1096",
                        "content": "It is a well-known problem and idea is simple if you know it already."
                    }
                ]
            },
            {
                "id": 1995435,
                "content": [
                    {
                        "username": "miha2k",
                        "content": "damn, this is hard\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The TLE kills me every time... it\\'s getting pretty annoying at this point :/"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/0789f2ff-1893-44d7-857b-17450edf660e_1640497970.9420185.png)\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be hard. Took me 3h to find the correct formula."
                    },
                    {
                        "username": "stefan1096",
                        "content": "It is a well-known problem and idea is simple if you know it already."
                    }
                ]
            }
        ]
    }
]