[
    {
        "title": "Increasing Order Search Tree",
        "question_content": "Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.\n&nbsp;\nExample 1:\n\nInput: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\nOutput: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n\nExample 2:\n\nInput: root = [5,1,7]\nOutput: [1,null,5,null,7]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the given tree will be in the range [1, 100].\n\t0 <= Node.val <= 1000",
        "solutions": [
            {
                "id": 165885,
                "title": "c-java-python-self-explained-5-line-o-n",
                "content": "## **Intuition**\\nDon\\'t need the condition of BST, just in-order output the whole tree.\\n\\nStraight forward idea here:\\n`result = inorder(root.left) + root + inorder(root.right)`\\n<br>\\n\\n## **Explanation**\\n\\nRecursively call function `increasingBST(TreeNode root, TreeNode tail)`\\n`tail` is its next node in inorder,\\n\\uFF08the word `next` may be easier to understand, but it\\u2019s a keyword in python)\\n\\nIf `root == null`, the head will be `tail`, so we return `tail` directly.\\n\\nwe recursively call `increasingBST(root.left, root)`,\\nchange left subtree into the linked list + current node.\\n\\nwe recursively call `increasingBST(root.right, tail)`,\\nchange right subtree into the linked list + tail.\\n\\nNow the result will be in a format of linked list, with right child is next node.\\nSince it\\'s single linked list, so we set `root.left = null`.\\nOtherwise it will be TLE for Leetcode judgment to traverse over your tree.\\n\\nThe result now is `increasingBST(root.left) + root + increasingBST(root.right)`.\\n\\nOne tip here, we should arrange the old tree, not create a new tree.\\nThe leetcode judgment comparer only the values,\\nso it won\\'t take it as wrong answer if you return a new tree,\\nbut it is wrong.\\n<br>\\n\\n## **Complexity**\\n`O(N)` time traversal of all nodes\\n`O(height)` space\\n<br>\\n\\n**C++:**\\n```cpp\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail = NULL) {\\n        if (!root) return tail;\\n        TreeNode* res = increasingBST(root->left, root);\\n        root->left = NULL;\\n        root->right = increasingBST(root->right, tail);\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public TreeNode increasingBST(TreeNode root) {\\n        return increasingBST(root, null);\\n    }\\n\\n    public TreeNode increasingBST(TreeNode root, TreeNode tail) {\\n        if (root == null) return tail;\\n        TreeNode res = increasingBST(root.left, root);\\n        root.left = null;\\n        root.right = increasingBST(root.right, tail);\\n        return res;\\n    }\\n```\\n**Python:**\\n```python\\n    def increasingBST(self, root, tail = None):\\n        if not root: return tail\\n        res = self.increasingBST(root.left, root)\\n        root.left = None\\n        root.right = self.increasingBST(root.right, tail)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail = NULL) {\\n        if (!root) return tail;\\n        TreeNode* res = increasingBST(root->left, root);\\n        root->left = NULL;\\n        root->right = increasingBST(root->right, tail);\\n        return res;\\n    }\\n```\n```java\\n    public TreeNode increasingBST(TreeNode root) {\\n        return increasingBST(root, null);\\n    }\\n\\n    public TreeNode increasingBST(TreeNode root, TreeNode tail) {\\n        if (root == null) return tail;\\n        TreeNode res = increasingBST(root.left, root);\\n        root.left = null;\\n        root.right = increasingBST(root.right, tail);\\n        return res;\\n    }\\n```\n```python\\n    def increasingBST(self, root, tail = None):\\n        if not root: return tail\\n        res = self.increasingBST(root.left, root)\\n        root.left = None\\n        root.right = self.increasingBST(root.right, tail)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 958108,
                "title": "c-inorder-traversal-o-n-easy-to-understand",
                "content": "```\\n  void inorder(TreeNode*& ans, TreeNode* root) {\\n        if (!root) return;\\n        inorder(ans, root->left);\\n        ans->right = new TreeNode(root->val);\\n        ans = ans->right;\\n        inorder(ans, root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* temp;\\n        TreeNode* ans = new TreeNode();\\n        temp = ans;\\n        inorder(ans, root);\\n        return temp->right;\\n    }\\n```\\n\\nRecursive inorder call, upvote if you like the solution",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n  void inorder(TreeNode*& ans, TreeNode* root) {\\n        if (!root) return;\\n        inorder(ans, root->left);\\n        ans->right = new TreeNode(root->val);\\n        ans = ans->right;\\n        inorder(ans, root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* temp;\\n        TreeNode* ans = new TreeNode();\\n        temp = ans;\\n        inorder(ans, root);\\n        return temp->right;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165941,
                "title": "inorder-traversal",
                "content": "```\\nclass Solution {\\n    private TreeNode result;\\n    private TreeNode pre;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return result;\\n    }\\n    private void inorder(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorder(root.left);\\n        if (result == null) {\\n            result = root;\\n        } else {\\n            pre.right = root;\\n        }\\n        pre = root;\\n        root.left = null;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private TreeNode result;\\n    private TreeNode pre;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return result;\\n    }\\n    private void inorder(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorder(root.left);\\n        if (result == null) {\\n            result = root;\\n        } else {\\n            pre.right = root;\\n        }\\n        pre = root;\\n        root.left = null;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165870,
                "title": "java-simple-inorder-traversal-with-explanation",
                "content": "```\\n   TreeNode prev=null, head=null;\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;   \\n        increasingBST(root.left);  \\n        if(prev!=null) { \\n        \\troot.left=null; // we no  longer needs the left  side of the node, so set it to null\\n        \\tprev.right=root; \\n        }\\n        if(head==null) head=root; // record the most left node as it will be our root\\n        prev=root; //keep track of the prev node\\n        increasingBST(root.right); \\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   TreeNode prev=null, head=null;\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;   \\n        increasingBST(root.left);  \\n        if(prev!=null) { \\n        \\troot.left=null; // we no  longer needs the left  side of the node, so set it to null\\n        \\tprev.right=root; \\n        }\\n        if(head==null) head=root; // record the most left node as it will be our root\\n        prev=root; //keep track of the prev node\\n        increasingBST(root.right); \\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 958059,
                "title": "python-inorder-dfs-explained",
                "content": "Let us construct new tree, using already existing nodes. My `dfs` function will have two outputs: node with smallest value (root of tree) and node with biggest value (leaf of tree). Then, all we need to do is to run `dfs` recursively:\\n\\n1. First, we denote `l1 = node` and `r2 = node`, this is for the case, if we will not have left or right children.\\n2. If we have left children, we create straight tree for left subtree using recursion and attach our `node` as right children of leaf of this tree.\\n3. If we have right children, we againg create straigh tree for right subtree using recursion and attach `r1` as right children of `node`.\\n4. We put left children of node to `None` to avoid loops in our final tree.\\n5. Return `dfs(root)[0]`: only root of constructed tree, not need to return leaf.\\n\\n**Complexity**: time complexity is `O(n)`, because we visit each node exactly once. Space compexity is `O(h)`, height of our tree.\\n\\n```\\nclass Solution:\\n    def increasingBST(self, root):\\n        def dfs(node):\\n            l1, r2 = node, node\\n            \\n            if node.left: \\n                l1, l2 = dfs(node.left)\\n                l2.right = node\\n                \\n            if node.right:\\n                r1, r2 = dfs(node.right)\\n                node.right = r1\\n            \\n            node.left = None\\n            return (l1, r2)\\n        \\n        return dfs(root)[0]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root):\\n        def dfs(node):\\n            l1, r2 = node, node\\n            \\n            if node.left: \\n                l1, l2 = dfs(node.left)\\n                l2.right = node\\n                \\n            if node.right:\\n                r1, r2 = dfs(node.right)\\n                node.right = r1\\n            \\n            node.left = None\\n            return (l1, r2)\\n        \\n        return dfs(root)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958187,
                "title": "morris-in-order-traversal-python-3-o-n-time-o-1-space",
                "content": "Hi everyone and thank you for showing interest in reading this article \\uD83D\\uDE4C.\\n\\n**Morris In-order traversal algorithm**\\nHave you ever asked yourself why do we use the stack when it comes to traversing a tree? Lets answer to this question! Stacks are used in [traversal algorithms](https://en.wikipedia.org/wiki/Tree_traversal) to keep track of parent-nodes that are not explored completely. This algorithm gets rid of the need for a stack and uses ```left``` and ```right``` links instead. Usually, this algorithm is used to collect only values, but we can do a slight modification to do relinking among different subtrees.\\n\\n**The workflow**\\n* create variables ```dummy``` and ```tail``` that will hold a link to a new node\\n* start iterating the tree with a while loop\\n\\t* if the current node has left child\\n\\t\\t*  find the rightmost node in the left subtree (the predecessor)\\n\\t\\t*  make the current node as the sibling\\'s right child\\n\\t\\t*  delete the link between the current node and its left child\\n\\t\\t*  mark the left child as a current node\\n\\t* if the current node does not have left child\\n\\t\\t* make the current node as the right child of the ```tail```\\n\\t\\t* mark current node as the ```tail```\\n\\t\\t* mark the right child of the current node as a current node\\n5. return the right child of the ```dummy```\\n\\n**The code**\\n```\\nclass Solution:\\n    def increasingBST(self, node: TreeNode) -> TreeNode:\\n        dummy = tail = TreeNode()\\n        while node is not None:\\n            if node.left is not None:\\n                predecessor = node.left\\n                while predecessor.right is not None:\\n                    predecessor = predecessor.right\\n                \\n                predecessor.right = node\\n                left, node.left = node.left, None\\n                node = left\\n            else:\\n                tail.right = tail = node\\n                node = node.right\\n        \\n        return dummy.right\\n```\\n\\n**Complexity analysis**\\nO(n) time - we traverse each node at most two times\\nO(1) space - no additional data structures were used\\n\\n**In conclusion**\\nThis is one of the most remarkably interesting algorithms I have ever learned \\uD83D\\uDC98. This algorithm does not only give you the possibility to collect all the nodes\\' values of the tree (without using any space) but also can rearrange the whole tree where nodes are present in order and each node has only the right child.\\n\\n\\uD83D\\uDCE2 *If you think that that solution is good enough to be recommended to other LeetCoders then upvote.*",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```left```\n```right```\n```dummy```\n```tail```\n```tail```\n```tail```\n```dummy```\n```\\nclass Solution:\\n    def increasingBST(self, node: TreeNode) -> TreeNode:\\n        dummy = tail = TreeNode()\\n        while node is not None:\\n            if node.left is not None:\\n                predecessor = node.left\\n                while predecessor.right is not None:\\n                    predecessor = predecessor.right\\n                \\n                predecessor.right = node\\n                left, node.left = node.left, None\\n                node = left\\n            else:\\n                tail.right = tail = node\\n                node = node.right\\n        \\n        return dummy.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314557,
                "title": "100-faster-easy-python-iterative-solution-without-the-dummy-tree-node",
                "content": "```\\n# Keep going to the left of the tree by appending the nodes to the stack and once you reach the \\n# leaf, then pop the stack and make the first popped node as root and then for rest of the nodes, \\n# append it to the right of the current root and make the left for each node as None \\nclass Solution(object):\\n    def increasingBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return None\\n        stack = []\\n        temp = x = root\\n        i = 0\\n        while stack or temp:\\n            if temp:\\n                stack.append(temp)\\n                temp = temp.left\\n            else:\\n                node = stack.pop()\\n                if i==0:\\n                    root = x = node\\n                    i+=1\\n                else:\\n                    x.right = node\\n                    x = node\\n                    x.left = None\\n                temp = node.right\\n        return root\\t\\n\\t\\t\\n# If you like the solution, upvote it and do suggest if you have a better solution!!\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\n# Keep going to the left of the tree by appending the nodes to the stack and once you reach the \\n# leaf, then pop the stack and make the first popped node as root and then for rest of the nodes, \\n# append it to the right of the current root and make the left for each node as None \\nclass Solution(object):\\n    def increasingBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return None\\n        stack = []\\n        temp = x = root\\n        i = 0\\n        while stack or temp:\\n            if temp:\\n                stack.append(temp)\\n                temp = temp.left\\n            else:\\n                node = stack.pop()\\n                if i==0:\\n                    root = x = node\\n                    i+=1\\n                else:\\n                    x.right = node\\n                    x = node\\n                    x.left = None\\n                temp = node.right\\n        return root\\t\\n\\t\\t\\n# If you like the solution, upvote it and do suggest if you have a better solution!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200938,
                "title": "c-recursive-and-iterative",
                "content": "Recursive: \\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* newroot, *curr;\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        increasingBST(root->left);\\n        \\n        if (newroot == NULL) { \\n            newroot = new TreeNode(root->val);\\n            curr = newroot;\\n        }\\n        else {\\n            curr->right = new TreeNode(root->val);\\n            curr=curr->right;\\n        }\\n        \\n        increasingBST(root->right);\\n        return newroot;\\n    }\\n};\\n```\\nIterative:\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        TreeNode* newroot=NULL, *newcurr;\\n        stack<TreeNode*> stck;\\n        TreeNode* curr=root;\\n        while (curr || !stck.empty()) {\\n            while (curr) {\\n                stck.push(curr);\\n                curr=curr->left;\\n            }\\n            \\n            curr=stck.top();\\n            stck.pop();\\n            if (newroot == NULL) {\\n                newroot = new TreeNode(curr->val);\\n                newcurr = newroot;\\n            }\\n            else {\\n                newcurr->right = new TreeNode(curr->val);\\n                newcurr = newcurr->right;\\n            }\\n            \\n            curr=curr->right;\\n        }\\n        \\n        return newroot;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* newroot, *curr;\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        increasingBST(root->left);\\n        \\n        if (newroot == NULL) { \\n            newroot = new TreeNode(root->val);\\n            curr = newroot;\\n        }\\n        else {\\n            curr->right = new TreeNode(root->val);\\n            curr=curr->right;\\n        }\\n        \\n        increasingBST(root->right);\\n        return newroot;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        TreeNode* newroot=NULL, *newcurr;\\n        stack<TreeNode*> stck;\\n        TreeNode* curr=root;\\n        while (curr || !stck.empty()) {\\n            while (curr) {\\n                stck.push(curr);\\n                curr=curr->left;\\n            }\\n            \\n            curr=stck.top();\\n            stck.pop();\\n            if (newroot == NULL) {\\n                newroot = new TreeNode(curr->val);\\n                newcurr = newroot;\\n            }\\n            else {\\n                newcurr->right = new TreeNode(curr->val);\\n                newcurr = newcurr->right;\\n            }\\n            \\n            curr=curr->right;\\n        }\\n        \\n        return newroot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955033,
                "title": "simple-easy-c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/d9beda34-fea7-4f11-88de-7f8a50562f2c_1650157442.741445.png)\\n\\n**Time complexcity O(n)**\\n**Space complexcity O(n) (recursion)**\\n```\\nTreeNode * inorder(TreeNode *root,TreeNode *tmp)\\n    {\\n        if(root==NULL) return tmp;\\n        tmp=inorder(root->left,tmp);\\n        tmp->right=root;\\n        root->left=NULL;\\n        tmp=root;\\n        return inorder(root->right,tmp);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        TreeNode* dummy=new TreeNode(0);\\n        TreeNode* tmp=dummy;\\n        inorder(root,tmp);\\n        return dummy->right;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode * inorder(TreeNode *root,TreeNode *tmp)\\n    {\\n        if(root==NULL) return tmp;\\n        tmp=inorder(root->left,tmp);\\n        tmp->right=root;\\n        root->left=NULL;\\n        tmp=root;\\n        return inorder(root->right,tmp);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        TreeNode* dummy=new TreeNode(0);\\n        TreeNode* tmp=dummy;\\n        inorder(root,tmp);\\n        return dummy->right;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 777069,
                "title": "easy-python-solution-beats-90-with-comments",
                "content": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        \\n        vals = []\\n        # Easy recursive Inorder Traversal to get our values to insert.\\n        def inord(node):\\n            if not node:\\n                return\\n            inord(node.left)\\n            vals.append(node.val)\\n            inord(node.right)\\n            \\n        inord(root)\\n        # Create a new tree to return.\\n        tree = TreeNode(val=vals[0])\\n\\t\\t# Use a sentinel so we dont lose our tree location in memory.\\n        tmp = tree\\n\\t\\t# Iterate through our vals, creating a new right node with the current val.\\n        for i in vals[1:]:\\n            tmp.right = TreeNode(val=i)\\n\\t\\t\\t# Move the sentinel to the next node.\\n            tmp = tmp.right\\n            \\n        return tree\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        \\n        vals = []\\n        # Easy recursive Inorder Traversal to get our values to insert.\\n        def inord(node):\\n            if not node:\\n                return\\n            inord(node.left)\\n            vals.append(node.val)\\n            inord(node.right)\\n            \\n        inord(root)\\n        # Create a new tree to return.\\n        tree = TreeNode(val=vals[0])\\n\\t\\t# Use a sentinel so we dont lose our tree location in memory.\\n        tmp = tree\\n\\t\\t# Iterate through our vals, creating a new right node with the current val.\\n        for i in vals[1:]:\\n            tmp.right = TreeNode(val=i)\\n\\t\\t\\t# Move the sentinel to the next node.\\n            tmp = tmp.right\\n            \\n        return tree\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251290,
                "title": "c-short-iterative",
                "content": "The iterative inorder traversal is a good way to solve this problem. Each time we meet a node, link it like a linked list using the `right` pointer. To facilitate the linking, create a dummy `head`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *head = new TreeNode(0), *pre = head;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            pre -> right = root;\\n            pre = pre -> right;\\n            root -> left = NULL;\\n            root = root -> right;\\n        }\\n        return head -> right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Tree",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *head = new TreeNode(0), *pre = head;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            pre -> right = root;\\n            pre = pre -> right;\\n            root -> left = NULL;\\n            root = root -> right;\\n        }\\n        return head -> right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668493,
                "title": "c-inorder-traversal-with-detail-explanation-and-intuition-of-general-recursion-on-tree",
                "content": "Hello everyone, recursion on tree is hard to understand, but hope this answer can give you some intuition.\\n\\nI figure it will be helpful to **only think of a simplest tree** when it comes recusion on tree. Concretly, think **a node with only a left child node and right child node**. What would the code look like if we want to do inorder-traversal. Answer is:\\n```\\n// Because it is just a simplest tree, we can write like this.\\nvoid inorder(TreeNode *root){\\n\\tcout << root->left->val;\\n\\tcout << root->val;\\n\\tcout << root->right>val;\\n}\\n```\\nOk, so far so well. But remember, the tree in real question is always not so simple. And that\\'s why we use recursion.\\n\\nNow, we **keep** the operation we did **for the current node** and **replace** the **left and right** operation with **recursion as operation of current node**, because this time we see left and right as subtree rather than node. \\n\\nAnd every time we enter a subtree, we face the same situation as its parent, that\\'s why we keep the current node operation and replace others, **we only have to and only CAN deal with the current node directly**, we can\\'t deal with subtree directly. Code like this:\\n```\\n// This time we face a real complicated tree. And just deal with some edge case when root is nullptr.\\nvoid inorder(TreeNode *root){\\n\\tif(root == nullptr) return; // edge case and for the stop of recursion.\\n\\tinorder(root->left); // replace\\n\\tcout << root->val; // keep\\n\\tinorder(root->right); // replace\\n}\\n```\\nOK, take a breath and let\\'s look at this question. The first thing you should know is **the result of inorder-traversal of a BST is an ordered sequence**. Go and search google or check MIT OCW 6.006 lecture05 if you are not familiar with BST.\\n\\nWelcome back and we move on, just think of it is a simplest tree in this question, and code should be:\\n```\\nclass Solution {\\n public:\\n\\tTreeNode* increasingBST(TreeNode* root) {\\n\\t\\tsolve(root);\\n\\t\\treturn ret;\\n\\t}\\n\\t\\nprivate:\\n\\tTreeNode *ret = nullptr; // record left-most TreeNode\\n\\tTreeNode *pre = nullptr; // record pre TreeNode\\n\\tvoid solve(TreeNode *root){\\n\\t\\tret = root->left; // ret is the left-most node.\\n\\t\\tpre = ret; // initialize pre\\n\\t\\tpre->right = root; // just keep right node of pre is current node.\\n\\t\\troot->left = nullptr; \\n\\t\\tpre = root; // we have go through root, let\\'s mark root as pre and move on.\\n\\t\\t// same operation bellow\\n\\t\\tpre->right = root->right;\\n\\t\\troot->right->left = nullptr;\\n\\t\\tpre = root->right;\\n\\t}\\n};\\n```\\n\\nOK, hope you have understood the solution for the simplest BST. There are just few things to do next.\\nFirst keep the operation for current node which are:\\n```\\n// in the view of current node, we have recorded pre node.\\npre->right = root;\\nroot->left = nullptr;\\npre = root;\\n```\\n**ret** is the left-most TreeNode, and we want to return it at last. How can we get it? At very beginning, we initialize **pre** as nullptr, that makes sense because there is no pre node. And after we see first current node, we assign current code to pre. \\n\\nSo we can use the state of pre to get ret. We check whether pre is nullptr or not, if it is, we know the node that we currently deal with is the first node (**first is also the left-most** based on the observation of simplest BST), and we assign it to ret. Code now looks like:\\n```\\nif(pre){\\n\\tpre->right = root;\\n}else{\\n\\tret = root;\\n}\\nroot->left = nullptr;\\npre = root;\\n```\\nThe rest code is just trivial. We add two recursion for left subtree and right subtree and the edge case to stop recursion. Total code is there:\\n```\\nclass Solution {\\n public:\\n\\tTreeNode* increasingBST(TreeNode* root) {\\n\\t\\tsolve(root);\\n\\t\\treturn ret;\\n\\t}\\nprivate:\\n    TreeNode *ret = nullptr;\\n    TreeNode *pre = nullptr;\\n    void solve(TreeNode *root){\\n        if(root == nullptr) return; // edge case and for the stop of recursion.\\n        solve(root->left); // recursion on left subtree.\\n\\t\\tif(pre){\\n\\t\\t\\tpre->right = root;\\n\\t\\t}else{\\n\\t\\t\\tret = root;\\n\\t\\t}\\n\\t\\troot->left = nullptr;\\n\\t\\tpre = root;\\n        solve(root->right); //recursion on right subtree.\\n    }\\n};\\n```\\n\\nHave a good day.\\n\\nBy,\\nAincrad-Lyu",
                "solutionTags": [],
                "code": "```\\n// Because it is just a simplest tree, we can write like this.\\nvoid inorder(TreeNode *root){\\n\\tcout << root->left->val;\\n\\tcout << root->val;\\n\\tcout << root->right>val;\\n}\\n```\n```\\n// This time we face a real complicated tree. And just deal with some edge case when root is nullptr.\\nvoid inorder(TreeNode *root){\\n\\tif(root == nullptr) return; // edge case and for the stop of recursion.\\n\\tinorder(root->left); // replace\\n\\tcout << root->val; // keep\\n\\tinorder(root->right); // replace\\n}\\n```\n```\\nclass Solution {\\n public:\\n\\tTreeNode* increasingBST(TreeNode* root) {\\n\\t\\tsolve(root);\\n\\t\\treturn ret;\\n\\t}\\n\\t\\nprivate:\\n\\tTreeNode *ret = nullptr; // record left-most TreeNode\\n\\tTreeNode *pre = nullptr; // record pre TreeNode\\n\\tvoid solve(TreeNode *root){\\n\\t\\tret = root->left; // ret is the left-most node.\\n\\t\\tpre = ret; // initialize pre\\n\\t\\tpre->right = root; // just keep right node of pre is current node.\\n\\t\\troot->left = nullptr; \\n\\t\\tpre = root; // we have go through root, let\\'s mark root as pre and move on.\\n\\t\\t// same operation bellow\\n\\t\\tpre->right = root->right;\\n\\t\\troot->right->left = nullptr;\\n\\t\\tpre = root->right;\\n\\t}\\n};\\n```\n```\\n// in the view of current node, we have recorded pre node.\\npre->right = root;\\nroot->left = nullptr;\\npre = root;\\n```\n```\\nif(pre){\\n\\tpre->right = root;\\n}else{\\n\\tret = root;\\n}\\nroot->left = nullptr;\\npre = root;\\n```\n```\\nclass Solution {\\n public:\\n\\tTreeNode* increasingBST(TreeNode* root) {\\n\\t\\tsolve(root);\\n\\t\\treturn ret;\\n\\t}\\nprivate:\\n    TreeNode *ret = nullptr;\\n    TreeNode *pre = nullptr;\\n    void solve(TreeNode *root){\\n        if(root == nullptr) return; // edge case and for the stop of recursion.\\n        solve(root->left); // recursion on left subtree.\\n\\t\\tif(pre){\\n\\t\\t\\tpre->right = root;\\n\\t\\t}else{\\n\\t\\t\\tret = root;\\n\\t\\t}\\n\\t\\troot->left = nullptr;\\n\\t\\tpre = root;\\n        solve(root->right); //recursion on right subtree.\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 280299,
                "title": "iterative-python-solution-faster-than-98-56",
                "content": "\\t\\'\\'\\'\\n\\tclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        new = head = TreeNode(0)\\n        stack = []\\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            new.right = root\\n            new = new.right\\n            root = root.right\\n            new.left = None\\n        \\n        return head.right\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\t\\'\\'\\'\\n\\tclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        new = head = TreeNode(0)\\n        stack = []\\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            new.right = root\\n            new = new.right\\n            root = root.right\\n            new.left = None\\n        \\n        return head.right\\n\\t\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1955036,
                "title": "c-easy-fast-single-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* nxt=NULL) {\\n        if(!root) return nxt;\\n        root->right=increasingBST(root->right,nxt);\\n        TreeNode* temp=increasingBST(root->left,root);\\n        root->left=NULL;\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* nxt=NULL) {\\n        if(!root) return nxt;\\n        root->right=increasingBST(root->right,nxt);\\n        TreeNode* temp=increasingBST(root->left,root);\\n        root->left=NULL;\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955141,
                "title": "python-2-way-9-line-simple-clean-code-with-explanation-beginner-level",
                "content": "**Please upvote me if you think this is helpful :) Much Appreciated!**\\n\\nMethod 1 --- Get the in order list of the tree, and generate the new tree\\n```\\nclass Solution(object):\\n    \\n    def increasingBST(self, root):\\n        \\n        def sortBST(node):\\n            if not node:    return []\\n            \\n            # return the in order BST nodes in list\\n            return sortBST(node.left) + [node.val] + sortBST(node.right)\\n            \\n        # the in order sorted list of the tree nodes\\n        sorted_list = sortBST(root)\\n        \\n        # generate new tree: temp for update, ans for return the root\\n        ans = temp = TreeNode(sorted_list[0])\\n        \\n        # insert nodes to the right side of the new tree\\n        for i in range(1, len(sorted_list)):\\n            temp.right = TreeNode(sorted_list[i])\\n            temp = temp.right\\n            \\n        return ans\\n```\\n\\nMethod 2 --- Track the old tree in order and generate the new tree at the same time\\n```\\nclass Solution(object):\\n    \\n    def increasingBST(self, root):\\n\\t\\n\\t\\t# generate new tree: self.cur for update, ans for return the root\\n        ans = self.cur = TreeNode()\\n        \\n        def inorder(node):\\n            if node:\\n\\t\\t\\t\\t# track the left side first\\n                inorder(node.left)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# update the new tree\\n                self.cur.right = TreeNode(node.val)\\n                self.cur = self.cur.right\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# track the right side then\\n                inorder(node.right)\\n        \\n        inorder(root)\\n        return ans.right\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    \\n    def increasingBST(self, root):\\n        \\n        def sortBST(node):\\n            if not node:    return []\\n            \\n            # return the in order BST nodes in list\\n            return sortBST(node.left) + [node.val] + sortBST(node.right)\\n            \\n        # the in order sorted list of the tree nodes\\n        sorted_list = sortBST(root)\\n        \\n        # generate new tree: temp for update, ans for return the root\\n        ans = temp = TreeNode(sorted_list[0])\\n        \\n        # insert nodes to the right side of the new tree\\n        for i in range(1, len(sorted_list)):\\n            temp.right = TreeNode(sorted_list[i])\\n            temp = temp.right\\n            \\n        return ans\\n```\n```\\nclass Solution(object):\\n    \\n    def increasingBST(self, root):\\n\\t\\n\\t\\t# generate new tree: self.cur for update, ans for return the root\\n        ans = self.cur = TreeNode()\\n        \\n        def inorder(node):\\n            if node:\\n\\t\\t\\t\\t# track the left side first\\n                inorder(node.left)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# update the new tree\\n                self.cur.right = TreeNode(node.val)\\n                self.cur = self.cur.right\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# track the right side then\\n                inorder(node.right)\\n        \\n        inorder(root)\\n        return ans.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284841,
                "title": "simple-inorder-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* tree = new TreeNode(0); // make new node and initialize with 0 value\\n    TreeNode *h = tree; // another node pointing to the head of new node\\n    \\n    void inorder(TreeNode* root){\\n         if(root==NULL){\\n            return;\\n        }\\n        \\n        inorder(root->left);\\n        tree->right= new TreeNode(root->val);  // make new node with root value \\n        tree->left=NULL;  \\n        tree=tree->right;  // move ahead in right direction\\n        \\n       inorder(root->right);\\n       \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {       \\n        \\n        inorder(root);\\n        return h->right; // move in right to skip the initial 0 value\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* tree = new TreeNode(0); // make new node and initialize with 0 value\\n    TreeNode *h = tree; // another node pointing to the head of new node\\n    \\n    void inorder(TreeNode* root){\\n         if(root==NULL){\\n            return;\\n        }\\n        \\n        inorder(root->left);\\n        tree->right= new TreeNode(root->val);  // make new node with root value \\n        tree->left=NULL;  \\n        tree=tree->right;  // move ahead in right direction\\n        \\n       inorder(root->right);\\n       \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {       \\n        \\n        inorder(root);\\n        return h->right; // move in right to skip the initial 0 value\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1097619,
                "title": "simple-and-easy-to-understand-java-0-ms-faster-than-100-00-using-dfs",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n\\n    TreeNode curr;\\n    public TreeNode increasingBST(TreeNode root) {\\n        //create a dummy node\\n        TreeNode first = new TreeNode(-1);\\n        \\n        //assign first\\n        curr = first;\\n        \\n\\t\\t//depth first search\\n        dfs(root);\\n        \\n        return first.right;\\n    }\\n    \\n    private void dfs(TreeNode node){\\n        if(node == null) return;\\n        \\n        //go to left child\\n        dfs(node.left);\\n        \\n        //create a new node, and assign to right\\n        curr.right = new TreeNode(node.val);\\n        \\n        //move the current pointer\\n        curr = curr.right;\\n        \\n        dfs(node.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    TreeNode curr;\\n    public TreeNode increasingBST(TreeNode root) {\\n        //create a dummy node\\n        TreeNode first = new TreeNode(-1);\\n        \\n        //assign first\\n        curr = first;\\n        \\n\\t\\t//depth first search\\n        dfs(root);\\n        \\n        return first.right;\\n    }\\n    \\n    private void dfs(TreeNode node){\\n        if(node == null) return;\\n        \\n        //go to left child\\n        dfs(node.left);\\n        \\n        //create a new node, and assign to right\\n        curr.right = new TreeNode(node.val);\\n        \\n        //move the current pointer\\n        curr = curr.right;\\n        \\n        dfs(node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957287,
                "title": "c-simple-solution-with-visual-explanation",
                "content": "**The idea:**\\nFirst, split any tree intro three parts:\\n1. \\tOriginal left child tree rooted at ```3```\\n2. \\tRoot node ```5```\\n3. \\tOriginal right child tree rooted at ```6```\\n```\\n\\n                5\\n              /   \\\\\\n            3       6\\n          /   \\\\      \\\\\\n         2     4      8\\n        /            / \\\\\\n       1            7   9\\n```\\n\\nSecond, convert the original left and right child trees into increasing order trees. \\n```\\n        1                                 6\\n         \\\\                                 \\\\        \\n          2                                 7 \\n           \\\\          +      5      +        \\\\\\n            3                                 8\\n             \\\\                                 \\\\\\n              4                                 9\\n```\\n\\nFinally, connect these three parts back.\\n```\\n           1      \\n            \\\\     \\n             2    \\n              \\\\   \\n               3  \\n                \\\\ \\n                 4   \\n                  \\\\\\n                   5\\n                    \\\\\\n                     6\\n                      \\\\\\n                       7\\n                        \\\\\\n                         8\\n                          \\\\\\n                           9\\n```\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        \\n\\t\\t// Make both child nodes an increasing order search tree\\n        TreeNode* left = increasingBST(root->left);\\n        TreeNode* right = increasingBST(root->right);\\n        \\n\\t\\t// Disconnect the original left child node and connect to the right increasing order search tree\\n        root->left = nullptr;\\n        root->right = right;\\n        \\n\\t\\t// Left child node returns a nullptr so just return the root\\n        if (!left) {\\n            return root;\\n        }\\n        \\n\\t\\t// Otherwise we search for the rightmost child of the left increasing order search tree\\n        TreeNode* iter = left;\\n        while (iter && iter->right) {\\n            iter = iter->right;\\n        }\\n\\t\\t\\n\\t\\t// Connect to the root node\\n        iter->right = root;\\n        \\n\\t\\t// Now the left root node should be the root of the whole tree\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```3```\n```5```\n```6```\n```\\n\\n                5\\n              /   \\\\\\n            3       6\\n          /   \\\\      \\\\\\n         2     4      8\\n        /            / \\\\\\n       1            7   9\\n```\n```\\n        1                                 6\\n         \\\\                                 \\\\        \\n          2                                 7 \\n           \\\\          +      5      +        \\\\\\n            3                                 8\\n             \\\\                                 \\\\\\n              4                                 9\\n```\n```\\n           1      \\n            \\\\     \\n             2    \\n              \\\\   \\n               3  \\n                \\\\ \\n                 4   \\n                  \\\\\\n                   5\\n                    \\\\\\n                     6\\n                      \\\\\\n                       7\\n                        \\\\\\n                         8\\n                          \\\\\\n                           9\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        \\n\\t\\t// Make both child nodes an increasing order search tree\\n        TreeNode* left = increasingBST(root->left);\\n        TreeNode* right = increasingBST(root->right);\\n        \\n\\t\\t// Disconnect the original left child node and connect to the right increasing order search tree\\n        root->left = nullptr;\\n        root->right = right;\\n        \\n\\t\\t// Left child node returns a nullptr so just return the root\\n        if (!left) {\\n            return root;\\n        }\\n        \\n\\t\\t// Otherwise we search for the rightmost child of the left increasing order search tree\\n        TreeNode* iter = left;\\n        while (iter && iter->right) {\\n            iter = iter->right;\\n        }\\n\\t\\t\\n\\t\\t// Connect to the root node\\n        iter->right = root;\\n        \\n\\t\\t// Now the left root node should be the root of the whole tree\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956051,
                "title": "java-0ms-naive-optimized-simple-inorder-traversal",
                "content": "\\n* **BELOW IS A NAIVE APPROACH**\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        ArrayList<Integer> al = new ArrayList<>();\\n        inorder(root, al);\\n        return buildTree(al);\\n    }\\n    \\n    private TreeNode buildTree(ArrayList<Integer> al){\\n        if(al.size() == 0) return null;\\n        TreeNode root = new TreeNode(al.remove(0));\\n        root.right = buildTree(al);\\n        return root;\\n    }\\n    \\n    private void inorder(TreeNode root, ArrayList<Integer> al){\\n        if(root == null) return;\\n        inorder(root.left, al);\\n        al.add(root.val);\\n        inorder(root.right, al);\\n    }\\n}\\n```\\n* **OPTIMIZED APPROACH**\\n```\\nclass Solution {\\n    \\n    private TreeNode head = null, parent = null;\\n    public TreeNode increasingBST(TreeNode root) {\\n        solve(root);\\n        return head;\\n    }\\n    \\n    private void solve(TreeNode root){\\n        if(root == null) return;\\n        solve(root.left);\\n        if(head == null) head = root;\\n        if(parent == null) parent = root;\\n        else {\\n            parent.right = root;\\n            parent = root;\\n            root.left = null;\\n        }\\n        solve(root.right); \\n    }\\n}\\n```\\n\\n```\\n* Always make helper functions ``` private ```.\\n* Because you shouldn\\'t expose them to the end party. Its an example of abstraction \\uD83D\\uDE00\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        ArrayList<Integer> al = new ArrayList<>();\\n        inorder(root, al);\\n        return buildTree(al);\\n    }\\n    \\n    private TreeNode buildTree(ArrayList<Integer> al){\\n        if(al.size() == 0) return null;\\n        TreeNode root = new TreeNode(al.remove(0));\\n        root.right = buildTree(al);\\n        return root;\\n    }\\n    \\n    private void inorder(TreeNode root, ArrayList<Integer> al){\\n        if(root == null) return;\\n        inorder(root.left, al);\\n        al.add(root.val);\\n        inorder(root.right, al);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    private TreeNode head = null, parent = null;\\n    public TreeNode increasingBST(TreeNode root) {\\n        solve(root);\\n        return head;\\n    }\\n    \\n    private void solve(TreeNode root){\\n        if(root == null) return;\\n        solve(root.left);\\n        if(head == null) head = root;\\n        if(parent == null) parent = root;\\n        else {\\n            parent.right = root;\\n            parent = root;\\n            root.left = null;\\n        }\\n        solve(root.right); \\n    }\\n}\\n```\n```\\n* Always make helper functions ```\n```.\\n* Because you shouldn\\'t expose them to the end party. Its an example of abstraction \\uD83D\\uDE00\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958097,
                "title": "c-two-very-simple-solutions",
                "content": "**Using a vector to store nodes in increasing order and then costructing a new tree from it:**\\n```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        nodes.push_back(root->val);\\n        inOrder(root->right);\\n        \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* new_head = new TreeNode();\\n        TreeNode* curr = new_head;\\n        inOrder(root);\\n        for (auto a : nodes) {\\n            curr->right = new TreeNode(a);\\n            curr = curr->right;\\n        }\\n        return new_head->right;\\n    }\\n    \\nprivate:\\n    vector<int> nodes;\\n};\\n```\\n**Another solution - without using a vector, just constructing the new tree while traversing original tree:**\\n```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        curr->right = new TreeNode(root->val);\\n        curr = curr->right;\\n        inOrder(root->right);\\n        \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        new_head = new TreeNode();\\n        curr = new_head;\\n        inOrder(root);\\n        return new_head->right;\\n    }\\nprivate:\\n    TreeNode* new_head;\\n    TreeNode* curr;\\n};\\n```\\n**Time compexity: O(n), Space complexity: O(n)**\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        nodes.push_back(root->val);\\n        inOrder(root->right);\\n        \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* new_head = new TreeNode();\\n        TreeNode* curr = new_head;\\n        inOrder(root);\\n        for (auto a : nodes) {\\n            curr->right = new TreeNode(a);\\n            curr = curr->right;\\n        }\\n        return new_head->right;\\n    }\\n    \\nprivate:\\n    vector<int> nodes;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        curr->right = new TreeNode(root->val);\\n        curr = curr->right;\\n        inOrder(root->right);\\n        \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        new_head = new TreeNode();\\n        curr = new_head;\\n        inOrder(root);\\n        return new_head->right;\\n    }\\nprivate:\\n    TreeNode* new_head;\\n    TreeNode* curr;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375371,
                "title": "simple-c-solution",
                "content": "```\\nTreeNode* Solution::increasingBST(TreeNode* root)\\n{\\n    if(root == nullptr)\\n        return nullptr;\\n\\n    if(root->left == nullptr)\\n    {\\n        root->right = increasingBST(root->right);\\n        return root;\\n    }\\n    TreeNode* node = root->left;\\n    root->left = node->right;\\n    node->right = root;\\n    return increasingBST(node);\\n}\\n```\\n\\nRecursively use root->left replace root. when root has no left child, we get the result. Recursively do it to root->right",
                "solutionTags": [],
                "code": "```\\nTreeNode* Solution::increasingBST(TreeNode* root)\\n{\\n    if(root == nullptr)\\n        return nullptr;\\n\\n    if(root->left == nullptr)\\n    {\\n        root->right = increasingBST(root->right);\\n        return root;\\n    }\\n    TreeNode* node = root->left;\\n    root->left = node->right;\\n    node->right = root;\\n    return increasingBST(node);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165888,
                "title": "6-line-python-o-n-solution",
                "content": "```\\n    def increasingBST(self, root, tail=None):\\n        if root is None:\\n            return tail\\n        x = TreeNode(root.val)\\n        x.right = self.increasingBST(root.right, tail)\\n        return self.increasingBST(root.left, x)\\n```",
                "solutionTags": [],
                "code": "```\\n    def increasingBST(self, root, tail=None):\\n        if root is None:\\n            return tail\\n        x = TreeNode(root.val)\\n        x.right = self.increasingBST(root.right, tail)\\n        return self.increasingBST(root.left, x)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 399072,
                "title": "python-concise-simple-solution",
                "content": "\\tclass Solution(object):\\n\\t\\tdef increasingBST(self, root):\\n\\t\\t\\tdef in_order(node):\\n\\t\\t\\t\\tif not node:\\n\\t\\t\\t\\t\\treturn []\\n\\t\\t\\t\\treturn in_order(node.left) + [node] + in_order(node.right)\\n\\n\\n\\t\\t\\t# get list of nodes in order\\n\\t\\t\\tnodelist = in_order(root)\\n\\n\\t\\t\\t# update node pointers\\n\\t\\t\\tfor i in xrange(len(nodelist)-1):\\n\\t\\t\\t\\tnodelist[i].left = None\\n\\t\\t\\t\\tnodelist[i].right = nodelist[i+1]\\n\\n\\t\\t\\tnodelist[-1].left = None\\n\\t\\t\\tnodelist[-1].right = None\\n\\n\\t\\t\\treturn nodelist[0]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef increasingBST(self, root):\\n\\t\\t\\tdef in_order(node):\\n\\t\\t\\t\\tif not node:\\n\\t\\t\\t\\t\\treturn []\\n\\t\\t\\t\\treturn in_order(node.left) + [node] + in_order(node.right)\\n\\n\\n\\t\\t\\t# get list of nodes in order\\n\\t\\t\\tnodelist = in_order(root)\\n\\n\\t\\t\\t# update node pointers\\n\\t\\t\\tfor i in xrange(len(nodelist)-1):\\n\\t\\t\\t\\tnodelist[i].left = None\\n\\t\\t\\t\\tnodelist[i].right = nodelist[i+1]\\n\\n\\t\\t\\tnodelist[-1].left = None\\n\\t\\t\\tnodelist[-1].right = None\\n\\n\\t\\t\\treturn nodelist[0]",
                "codeTag": "Java"
            },
            {
                "id": 1955921,
                "title": "day-17-daily-leetcode-challenge-problem-java-recursion-100-faster",
                "content": "\\nBy using inorder traversal , we costruct new Tree (for that we already declare two pointer type variables (root , temp) and on each function frame we create new node and point it to right side and update the temp) \\n\\n\\n#### ***JAVA***\\n\\n```\\nclass Solution {\\n    \\n       static TreeNode temp=null;\\n       static TreeNode newroot=null;\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        temp=null;\\n        \\n        inorder(root);\\n        \\n        return newroot;    \\n      }\\n    \\n    public static void inorder(TreeNode root){\\n        \\n        if(root==null) return;\\n        \\n        inorder(root.left);\\n        \\n        if(temp==null){\\n            TreeNode nn=new TreeNode(root.val);\\n            temp=nn;\\n            newroot=nn;\\n        }else{\\n            TreeNode nn1=new TreeNode(root.val);\\n            temp.right=nn1;\\n            temp=nn1;\\n        }\\n        \\n        inorder(root.right);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n       static TreeNode temp=null;\\n       static TreeNode newroot=null;\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        temp=null;\\n        \\n        inorder(root);\\n        \\n        return newroot;    \\n      }\\n    \\n    public static void inorder(TreeNode root){\\n        \\n        if(root==null) return;\\n        \\n        inorder(root.left);\\n        \\n        if(temp==null){\\n            TreeNode nn=new TreeNode(root.val);\\n            temp=nn;\\n            newroot=nn;\\n        }else{\\n            TreeNode nn1=new TreeNode(root.val);\\n            temp.right=nn1;\\n            temp=nn1;\\n        }\\n        \\n        inorder(root.right);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958092,
                "title": "0ms-beats-100-easy-explained-with-diagram-dry-run",
                "content": "If you like it, pls **Upvote** :)\\n\\t\\n\\tRun time: 0 ms, faster than 100.00%\\n\\t\\n## Code:\\n\\tNote: In order to understand the code better, follow the steps from 1.a) to 2.e) mentioned in the diagram.\\n\\tclass Solution {\\n\\t\\tpublic TreeNode increasingBST(TreeNode root) {\\n\\t\\t\\treturn increasingBST(root, null);\\n\\t\\t}\\n\\t\\tpublic TreeNode increasingBST(TreeNode node, TreeNode par) {\\n\\t\\t\\tif(node == null) return par;                                    // 1.a)\\n\\t\\t\\tTreeNode newRoot = increasingBST(node.left, node);              // 2.a)\\n\\t\\t\\tnode.left = null;                                               // 2.b)\\n\\t\\t\\tnode.right = increasingBST(node.right, par);                    // 2.c)  +  2.d)  \\n\\t\\t\\treturn newRoot;                                                 // 2.e)\\n\\t\\t}\\n\\t}\\n\\n## Dry Run:\\n![image](https://assets.leetcode.com/users/images/9a13037c-39d1-4475-9adc-114c5871f87a_1650217630.111815.png)\\n\\nIf any questions/suggestions, comment down below.\\nIf you liked the explanation/dry run, pls **Upvote** :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic TreeNode increasingBST(TreeNode root) {\\n\\t\\t\\treturn increasingBST(root, null);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1618344,
                "title": "easy-solution-100-faster-c-inorder-traversal",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&v)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* increasingBST(TreeNode* root)\\n    {\\n        vector<int>v;\\n        inorder(root,v);\\n        TreeNode*temp=new TreeNode(v[0]);\\n        TreeNode* r=temp;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            temp->right=new TreeNode(v[i]);\\n            temp=temp->right;\\n        }\\n        return r;\\n    }\\n};\\n```\\n\\n**Upvote if it helped , Thanks :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&v)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* increasingBST(TreeNode* root)\\n    {\\n        vector<int>v;\\n        inorder(root,v);\\n        TreeNode*temp=new TreeNode(v[0]);\\n        TreeNode* r=temp;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            temp->right=new TreeNode(v[i]);\\n            temp=temp->right;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1468619,
                "title": "easy-to-understand-code-in-c-recursion",
                "content": "class Solution {\\npublic:\\n    TreeNode* node= new TreeNode(0);\\n    TreeNode* h=node;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL){\\n            return NULL;\\n        }\\n        \\n        increasingBST(root->left);\\n        node->right=new TreeNode(root->val);\\n        node=node->right;\\n        increasingBST(root->right);\\n        \\n        return h->right;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* node= new TreeNode(0);\\n    TreeNode* h=node;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL){\\n            return NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1957531,
                "title": "c-100-beats-in-runtime",
                "content": "Run an inorder traversal and add each node value to your answer tree. As left will be always `null` so set value only for right. And at last return the root of new tree.\\nNote that I declared a dummy node 0 initially to make the code simple. That\\'s why I returned the the side of root of my answer tree.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* inorder(TreeNode *cur, TreeNode *ans) {\\n        if (cur == nullptr) return ans;\\n        TreeNode *now = inorder(cur->left, ans);\\n        now->right = new TreeNode(cur->val);\\n        return inorder(cur->right, now->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *cur = new TreeNode();\\n        inorder(root, cur);\\n        return cur->right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* inorder(TreeNode *cur, TreeNode *ans) {\\n        if (cur == nullptr) return ans;\\n        TreeNode *now = inorder(cur->left, ans);\\n        now->right = new TreeNode(cur->val);\\n        return inorder(cur->right, now->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *cur = new TreeNode();\\n        inorder(root, cur);\\n        return cur->right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955831,
                "title": "c-simple-inorder-implementation-daily-leetcoding-challenge-april-day-17",
                "content": "**Please upvote if it helps**\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* head = new TreeNode();\\n    TreeNode* it=head;\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        // go to the extreme left\\n        inorder(root->left);\\n        \\n        // store that extreme left into the right of the new tree\\n        it->right = new TreeNode(root->val);\\n        \\n        // update the itr by itr->right\\n        it=it->right;\\n        \\n        // check the right if there is\\n        inorder(root->right);\\n    }\\n\\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        inorder(root);\\n        return head->right;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* head = new TreeNode();\\n    TreeNode* it=head;\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        // go to the extreme left\\n        inorder(root->left);\\n        \\n        // store that extreme left into the right of the new tree\\n        it->right = new TreeNode(root->val);\\n        \\n        // update the itr by itr->right\\n        it=it->right;\\n        \\n        // check the right if there is\\n        inorder(root->right);\\n    }\\n\\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        inorder(root);\\n        return head->right;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954962,
                "title": "c-dfs-inorder-traversal-sentinel-node",
                "content": "Inorder Traversal using a sentinel node\\n\\n**Solved live on stream, everyday at 6pm PT. Link in profile.**\\n\\n```\\nclass Solution {\\n    \\n    void dfs(TreeNode* root, TreeNode*& sentinel) {\\n        if(!root) return;\\n        dfs(root->left, sentinel);\\n        TreeNode* newNode = new TreeNode(root->val);\\n        sentinel->right = newNode;\\n        sentinel = sentinel->right;\\n        dfs(root->right, sentinel);\\n        return;\\n    }\\n\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* sentinel = new TreeNode(0);\\n        TreeNode* ans = sentinel;\\n        dfs(root, sentinel);\\n        return ans->right;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    void dfs(TreeNode* root, TreeNode*& sentinel) {\\n        if(!root) return;\\n        dfs(root->left, sentinel);\\n        TreeNode* newNode = new TreeNode(root->val);\\n        sentinel->right = newNode;\\n        sentinel = sentinel->right;\\n        dfs(root->right, sentinel);\\n        return;\\n    }\\n\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* sentinel = new TreeNode(0);\\n        TreeNode* ans = sentinel;\\n        dfs(root, sentinel);\\n        return ans->right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465015,
                "title": "increasing-order-search-tree-java-recursion-solution",
                "content": "Brute Force Approach:\\nTime Complexity - O(n), Space Complexity - O(n)\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root == null) return null;\\n        List<TreeNode> traversal = new ArrayList<>();\\n        inorder(root, traversal);\\n        reorder(traversal);\\n        return traversal.get(0);\\n    }\\n    \\n    public void inorder(TreeNode root, List<TreeNode> traversal){\\n        if(root != null){\\n            inorder(root.left, traversal);\\n            traversal.add(root);\\n            inorder(root.right, traversal);\\n        }\\n    }\\n    \\n    public void reorder(List<TreeNode> traversal){\\n        for(int i=0; i<=traversal.size()-1; i++){\\n            TreeNode current = traversal.get(i);\\n            current.left = null;\\n            if(i<traversal.size()-1){\\n                current.right = traversal.get(i+1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\nOptimised Approach:\\nTime Complexity - O(n), Space Complexity - O(h)\\n```\\nclass Solution {\\n    private TreeNode previous, result;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return result;\\n    }\\n    \\n    private void inorder(TreeNode root) {\\n        if (root != null) {\\n            inorder(root.left);\\n            \\n            if (result == null) {\\n                result = root;\\n            } else {\\n                previous.right = root;\\n            }\\n            previous = root;\\n            root.left = null;\\n            \\n            inorder(root.right);\\n        }\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root == null) return null;\\n        List<TreeNode> traversal = new ArrayList<>();\\n        inorder(root, traversal);\\n        reorder(traversal);\\n        return traversal.get(0);\\n    }\\n    \\n    public void inorder(TreeNode root, List<TreeNode> traversal){\\n        if(root != null){\\n            inorder(root.left, traversal);\\n            traversal.add(root);\\n            inorder(root.right, traversal);\\n        }\\n    }\\n    \\n    public void reorder(List<TreeNode> traversal){\\n        for(int i=0; i<=traversal.size()-1; i++){\\n            TreeNode current = traversal.get(i);\\n            current.left = null;\\n            if(i<traversal.size()-1){\\n                current.right = traversal.get(i+1);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private TreeNode previous, result;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return result;\\n    }\\n    \\n    private void inorder(TreeNode root) {\\n        if (root != null) {\\n            inorder(root.left);\\n            \\n            if (result == null) {\\n                result = root;\\n            } else {\\n                previous.right = root;\\n            }\\n            previous = root;\\n            root.left = null;\\n            \\n            inorder(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958007,
                "title": "python-simple-algorithm-o-n-space",
                "content": "**Inorder traversal gives the increasing order of the node values**\\n*Simple and easy python3 solution*\\n**\"comment below if you solve it in lesser space complexity and please upvote if you liked the solution\"**\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        #store the inorder references of the nodes in a list\\n        #as inorder traversal gives the increasing order of node values\\n        ans = []\\n        def inorder(node):\\n            if node is None:\\n                return \\n            inorder(node.left)\\n            ans.append(node)\\n            inorder(node.right)\\n        inorder(root)\\n        \\n        for i in range(len(ans) - 1):\\n            ans[i].left = None\\n            ans[i].right = ans[i + 1]\\n        ans[len(ans) - 1].left = None\\n        ans[len(ans) - 1].right = None\\n        return ans[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        #store the inorder references of the nodes in a list\\n        #as inorder traversal gives the increasing order of node values\\n        ans = []\\n        def inorder(node):\\n            if node is None:\\n                return \\n            inorder(node.left)\\n            ans.append(node)\\n            inorder(node.right)\\n        inorder(root)\\n        \\n        for i in range(len(ans) - 1):\\n            ans[i].left = None\\n            ans[i].right = ans[i + 1]\\n        ans[len(ans) - 1].left = None\\n        ans[len(ans) - 1].right = None\\n        return ans[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653847,
                "title": "javascript-2-solutions",
                "content": "**Recursive:**\\n```\\nvar increasingBST = function(root) {\\n    let newRoot = null, newTree = null;\\n    \\n    const helper = (node) => {\\n        if(!node) return;\\n\\t\\t// left\\n        helper(node.left);\\n\\t\\t\\n\\t\\t// read/visit\\n        // while reading/visiting the node update newRoot/newTree\\n        if(!newRoot) {\\n            newRoot = newTree = node;\\n        } else {\\n            newTree.right = node;\\n            newTree = newTree.right;\\n            // set left to null to avoid duplication & to create skewed tree\\n            node.left = null;\\n        }\\n\\t\\t\\n\\t\\t// right\\n        helper(node.right);\\n    }\\n    \\n    helper(root);\\n    return newRoot;\\n};\\n```\\n**Iterative:**\\n```\\nvar increasingBST = function(root) {\\n    if(!root) return null;\\n    let stack = [], newRoot = null, newTree = null;\\n    \\n    while(root){\\n        // left\\n        while(root){\\n            stack.push(root);\\n            root = root.left;\\n        }\\n        while(stack.length > 0){\\n            // read/visit\\n            let node = stack.pop();\\n            if(!newRoot){\\n                newRoot = newTree = node;\\n            } else {\\n                newTree.right = node;\\n                newTree = newTree.right;\\n            }\\n            node.left = null;\\n            // right\\n            if(node.right){\\n                root = node.right;\\n                break;\\n            }\\n        }\\n    }\\n    return newRoot;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvar increasingBST = function(root) {\\n    let newRoot = null, newTree = null;\\n    \\n    const helper = (node) => {\\n        if(!node) return;\\n\\t\\t// left\\n        helper(node.left);\\n\\t\\t\\n\\t\\t// read/visit\\n        // while reading/visiting the node update newRoot/newTree\\n        if(!newRoot) {\\n            newRoot = newTree = node;\\n        } else {\\n            newTree.right = node;\\n            newTree = newTree.right;\\n            // set left to null to avoid duplication & to create skewed tree\\n            node.left = null;\\n        }\\n\\t\\t\\n\\t\\t// right\\n        helper(node.right);\\n    }\\n    \\n    helper(root);\\n    return newRoot;\\n};\\n```\n```\\nvar increasingBST = function(root) {\\n    if(!root) return null;\\n    let stack = [], newRoot = null, newTree = null;\\n    \\n    while(root){\\n        // left\\n        while(root){\\n            stack.push(root);\\n            root = root.left;\\n        }\\n        while(stack.length > 0){\\n            // read/visit\\n            let node = stack.pop();\\n            if(!newRoot){\\n                newRoot = newTree = node;\\n            } else {\\n                newTree.right = node;\\n                newTree = newTree.right;\\n            }\\n            node.left = null;\\n            // right\\n            if(node.right){\\n                root = node.right;\\n                break;\\n            }\\n        }\\n    }\\n    return newRoot;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1733175,
                "title": "c-easiest-sol-using-inorder-traversal",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* increasingBST(TreeNode* root) {\\n\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tinorderTraversal(root, ans);\\n\\n\\t\\t\\tTreeNode* dummy = new TreeNode(-1);\\n\\t\\t\\tTreeNode* newroot = dummy;\\n\\n\\t\\t\\tfor(auto i : ans)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdummy->right = new TreeNode(i); //create a new node\\n\\t\\t\\t\\tdummy = dummy->right;           //setting the new node to right\\n\\t\\t\\t}\\n\\t\\t\\treturn newroot->right;\\n\\t\\t}\\n\\n\\t\\tvoid inorderTraversal(TreeNode* root, vector<int>&ans)\\n\\t\\t{\\n\\t\\t\\tif(root == NULL)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tinorderTraversal(root->left, ans);\\n\\t\\t\\tans.push_back(root->val);\\n\\t\\t\\tinorderTraversal(root->right, ans);\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* increasingBST(TreeNode* root) {\\n\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tinorderTraversal(root, ans);\\n\\n\\t\\t\\tTreeNode* dummy = new TreeNode(-1);\\n\\t\\t\\tTreeNode* newroot = dummy;\\n\\n\\t\\t\\tfor(auto i : ans)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdummy->right = new TreeNode(i); //create a new node\\n\\t\\t\\t\\tdummy = dummy->right;           //setting the new node to right\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1723817,
                "title": "100-faster-inorder-traversal-recursion-solution",
                "content": "```\\nclass Solution {\\n    TreeNode res = null;\\n    TreeNode head = null;\\n    public TreeNode increasingBST(TreeNode root) {\\n       if(root==null)\\n           return null;\\n        increasingBST(root.left);\\n        if(res==null){\\n            res = new TreeNode(root.val);\\n            head = res;\\n        }\\n        else{\\n         res.right = new TreeNode(root.val);\\n            res = res.right;\\n        }\\n        increasingBST(root.right);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode res = null;\\n    TreeNode head = null;\\n    public TreeNode increasingBST(TreeNode root) {\\n       if(root==null)\\n           return null;\\n        increasingBST(root.left);\\n        if(res==null){\\n            res = new TreeNode(root.val);\\n            head = res;\\n        }\\n        else{\\n         res.right = new TreeNode(root.val);\\n            res = res.right;\\n        }\\n        increasingBST(root.right);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958021,
                "title": "python-in-order-traversal",
                "content": "In-order traversal of a binary-search tree lists values in increasing order. Suppose that we construct a new tree with the dummy node `head`. While we do an in-order traversal starting from `root`, we add each value to the right of `head`. Since `head` is dummy, return `head.right`.\\n\\n```python\\nclass Solution:\\n    def increasingBST(self, root):\\n        def recur(node):\\n            if not node: return\\n            recur(node.left)\\n            new_node[0].right = TreeNode(node.val)\\n            new_node[0] = new_node[0].right\\n            recur(node.right)\\n            \\n        head = TreeNode(0)\\n        new_node = [head]\\n        recur(root)\\n        return head.right\\n```\\n\\nThe version above builds a new tree. If we want to avoid that we need to reuse the existing nodes. Which requires the changing the two lines with comment.\\n\\n```python\\nclass Solution:\\n    def increasingBST(self, root):\\n        def recur(node):\\n            if not node: return\\n            recur(node.left)\\n            node.left = None #clear left\\n            new_node[0].right = node #reuse node\\n            new_node[0] = new_node[0].right\\n            recur(node.right)\\n            \\n        head = TreeNode(0)\\n        new_node = [head]\\n        recur(root)\\n        return head.right\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def increasingBST(self, root):\\n        def recur(node):\\n            if not node: return\\n            recur(node.left)\\n            new_node[0].right = TreeNode(node.val)\\n            new_node[0] = new_node[0].right\\n            recur(node.right)\\n            \\n        head = TreeNode(0)\\n        new_node = [head]\\n        recur(root)\\n        return head.right\\n```\n```python\\nclass Solution:\\n    def increasingBST(self, root):\\n        def recur(node):\\n            if not node: return\\n            recur(node.left)\\n            node.left = None #clear left\\n            new_node[0].right = node #reuse node\\n            new_node[0] = new_node[0].right\\n            recur(node.right)\\n            \\n        head = TreeNode(0)\\n        new_node = [head]\\n        recur(root)\\n        return head.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394874,
                "title": "javascript-simple-inorder-dfs",
                "content": "```\\nvar increasingBST = function(root) {\\n    let dummy = new TreeNode(); \\n    let node = dummy;\\n\\t\\n    const traverse = function(root) {\\n        if(!root) return; \\n        traverse(root.left); \\n        node.right = root; \\n        node = node.right; \\n        node.left = null;\\n        traverse(root.right);    \\n    }; \\n\\t\\n    traverse(root);\\n    return dummy.right;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar increasingBST = function(root) {\\n    let dummy = new TreeNode(); \\n    let node = dummy;\\n\\t\\n    const traverse = function(root) {\\n        if(!root) return; \\n        traverse(root.left); \\n        node.right = root; \\n        node = node.right; \\n        node.left = null;\\n        traverse(root.right);    \\n    }; \\n\\t\\n    traverse(root);\\n    return dummy.right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955865,
                "title": "faadu-100-faster-solution-0ms-cpp",
                "content": "```\\nvoid inorder(TreeNode* root,vector<int>&v){\\n\\t\\tif(!root)return;\\n        \\n        if(root->left){\\n            inorder(root->left,v);\\n        }\\n        if(root){\\n          v.push_back(root->val);\\n        }\\n        if(root->right){\\n            inorder(root->right,v);\\n        }\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)return NULL;\\n        vector<int>v;\\n        inorder(root,v);\\n            \\n        TreeNode * head = new TreeNode(v[0]);\\n        TreeNode * temp = head;\\n        for(int i=1;i<v.size();i++){\\n            temp->right = new TreeNode(v[i]);\\n            temp = temp->right;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvoid inorder(TreeNode* root,vector<int>&v){\\n\\t\\tif(!root)return;\\n        \\n        if(root->left){\\n            inorder(root->left,v);\\n        }\\n        if(root){\\n          v.push_back(root->val);\\n        }\\n        if(root->right){\\n            inorder(root->right,v);\\n        }\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)return NULL;\\n        vector<int>v;\\n        inorder(root,v);\\n            \\n        TreeNode * head = new TreeNode(v[0]);\\n        TreeNode * temp = head;\\n        for(int i=1;i<v.size();i++){\\n            temp->right = new TreeNode(v[i]);\\n            temp = temp->right;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1849038,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc increasingBST(root *TreeNode) *TreeNode {\\n\\treturn dfs(root, nil)\\n}\\n\\nfunc dfs(root, tail *TreeNode) *TreeNode {\\n\\tif root == nil {\\n\\t\\treturn tail\\n\\t}\\n\\t\\n\\tres := dfs(root.Left, root)\\n\\troot.Left = nil\\n\\troot.Right = dfs(root.Right, tail)\\n\\t\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc increasingBST(root *TreeNode) *TreeNode {\\n\\treturn dfs(root, nil)\\n}\\n\\nfunc dfs(root, tail *TreeNode) *TreeNode {\\n\\tif root == nil {\\n\\t\\treturn tail\\n\\t}\\n\\t\\n\\tres := dfs(root.Left, root)\\n\\troot.Left = nil\\n\\troot.Right = dfs(root.Right, tail)\\n\\t\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1724571,
                "title": "3-lines-only-0ms-100-faster-easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail = nullptr) {\\n        if (!root) return tail;\\n        TreeNode* res = increasingBST(root->left, root);\\n        root->left = nullptr;\\n        root->right = increasingBST(root->right, tail);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail = nullptr) {\\n        if (!root) return tail;\\n        TreeNode* res = increasingBST(root->left, root);\\n        root->left = nullptr;\\n        root->right = increasingBST(root->right, tail);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354963,
                "title": "reverse-inorder-traversal-o-n-100ms-c-easy-to-understand",
                "content": "## Approach:\\n        \\n* We traverse the tree in reverse inorder and attach the previous nodes to the right of our our current node.\\n\\n* We keep the left in a temporary variable because it gets lost due to removal of left side of the tree.\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\n    TreeNode *prevNode = NULL;\\n    \\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        if(!root) return NULL;\\n        \\n        root->right = increasingBST(root->right);\\n        \\n        if(prevNode)\\n            root->right = prevNode;\\n        \\n        TreeNode *temp = root->left;\\n\\n        root->left = NULL;\\n        \\n        prevNode = root;\\n        \\n        increasingBST(temp);\\n        \\n        \\n        return prevNode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    TreeNode *prevNode = NULL;\\n    \\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        if(!root) return NULL;\\n        \\n        root->right = increasingBST(root->right);\\n        \\n        if(prevNode)\\n            root->right = prevNode;\\n        \\n        TreeNode *temp = root->left;\\n\\n        root->left = NULL;\\n        \\n        prevNode = root;\\n        \\n        increasingBST(temp);\\n        \\n        \\n        return prevNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1106048,
                "title": "c-inorder-traversal-simple-and-faster-than-100-submission",
                "content": "```\\nTreeNode* curr=NULL;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        if(root==NULL){return NULL;}\\n        TreeNode* res = new TreeNode(0);\\n        curr = res;\\n        inorder(root);\\n        return res->right;\\n        \\n    }\\n    void inorder(TreeNode*root){\\n        \\n        if(root==NULL){return;}\\n        \\n        inorder(root->left);\\n        \\n        root->left = NULL;\\n        curr->right = root;\\n        curr = root;\\n        \\n        inorder(root->right);\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nTreeNode* curr=NULL;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        if(root==NULL){return NULL;}\\n        TreeNode* res = new TreeNode(0);\\n        curr = res;\\n        inorder(root);\\n        return res->right;\\n        \\n    }\\n    void inorder(TreeNode*root){\\n        \\n        if(root==NULL){return;}\\n        \\n        inorder(root->left);\\n        \\n        root->left = NULL;\\n        curr->right = root;\\n        curr = root;\\n        \\n        inorder(root->right);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 959460,
                "title": "python-clear-easy-to-understand-solution",
                "content": "\\tdef inorderTraversal(root: TreeNode) -> List[int]: \\n\\t\\treturn [] if root is None else inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\\n\\t\\t\\t\\n\\tdef buildTree(lst: list) -> TreeNode:\\n\\t\\thead = TreeNode(lst[0])\\n\\t\\tptr = head\\n\\t\\tfor val in lst[1:]:\\n\\t\\t\\tptr.right = TreeNode(val)\\n\\t\\t\\tptr = ptr.right\\n\\t\\t\\t\\t\\n\\t\\treturn head\\n\\t\\n\\tclass Solution:\\n\\t\\tdef increasingBST(self, root: TreeNode) -> TreeNode:\\n\\t\\t\\treturn buildTree(inorderTraversal(root))\\n\\nlike it? please upvote!...",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tdef inorderTraversal(root: TreeNode) -> List[int]: \\n\\t\\treturn [] if root is None else inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\\n\\t\\t\\t\\n\\tdef buildTree(lst: list) -> TreeNode:\\n\\t\\thead = TreeNode(lst[0])\\n\\t\\tptr = head\\n\\t\\tfor val in lst[1:]:\\n\\t\\t\\tptr.right = TreeNode(val)\\n\\t\\t\\tptr = ptr.right\\n\\t\\t\\t\\t\\n\\t\\treturn head\\n\\t\\n\\tclass Solution:\\n\\t\\tdef increasingBST(self, root: TreeNode) -> TreeNode:\\n\\t\\t\\treturn buildTree(inorderTraversal(root))\\n\\nlike it? please upvote!...",
                "codeTag": "Java"
            },
            {
                "id": 958482,
                "title": "iterative-and-recursive-javascript-typescript",
                "content": "Iterative Solution: \\n```\\nfunction increasingBST(root: TreeNode | null): TreeNode | null {\\n    if (!root) {\\n        return null\\n    }\\n\\n    let stack: TreeNode[] = []\\n    let curr: TreeNode | null = root\\n\\n    const dummyHead = new TreeNode()\\n    let holdingPointer = dummyHead\\n    \\n\\n    while (stack.length || curr) {\\n        if (curr) {\\n            stack.push(curr)\\n            curr = curr.left\\n        } else {\\n            let temp = stack.pop()\\n            if (temp) {\\n                holdingPointer.right = new TreeNode(temp.val)\\n                holdingPointer = holdingPointer.right\\n                curr = temp.right\\n            }\\n            \\n        }\\n    }\\n    return dummyHead.right\\n};\\n```\\nRecursive Solution: \\n```\\nfunction increasingBST(root: TreeNode | null): TreeNode | null {\\n    const dummyHead = new TreeNode()\\n    let temp = dummyHead\\n    function inOrder(root:TreeNode | null) {\\n        if (!root) return\\n\\n        if (root.left) {\\n            inOrder(root.left)\\n        }\\n\\n        temp.right = new TreeNode(root.val)\\n        temp = temp.right\\n\\n        if (root.right) {\\n            inOrder(root.right)\\n        }\\n    }\\n\\n    inOrder(root)\\n\\n    return dummyHead.right\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction increasingBST(root: TreeNode | null): TreeNode | null {\\n    if (!root) {\\n        return null\\n    }\\n\\n    let stack: TreeNode[] = []\\n    let curr: TreeNode | null = root\\n\\n    const dummyHead = new TreeNode()\\n    let holdingPointer = dummyHead\\n    \\n\\n    while (stack.length || curr) {\\n        if (curr) {\\n            stack.push(curr)\\n            curr = curr.left\\n        } else {\\n            let temp = stack.pop()\\n            if (temp) {\\n                holdingPointer.right = new TreeNode(temp.val)\\n                holdingPointer = holdingPointer.right\\n                curr = temp.right\\n            }\\n            \\n        }\\n    }\\n    return dummyHead.right\\n};\\n```\n```\\nfunction increasingBST(root: TreeNode | null): TreeNode | null {\\n    const dummyHead = new TreeNode()\\n    let temp = dummyHead\\n    function inOrder(root:TreeNode | null) {\\n        if (!root) return\\n\\n        if (root.left) {\\n            inOrder(root.left)\\n        }\\n\\n        temp.right = new TreeNode(root.val)\\n        temp = temp.right\\n\\n        if (root.right) {\\n            inOrder(root.right)\\n        }\\n    }\\n\\n    inOrder(root)\\n\\n    return dummyHead.right\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 958288,
                "title": "java-100-no-recursion-commented-code",
                "content": "Recursive approach with class-level variable to keep previous node is fairly simple. I decided to do it without recursion to refresh on how in-order traversal is done iteratively using stack + extra pointer. Overall, this exercise has good take-aways:\\n* Pre-head pointer technique used in many problems, esp. linked list related\\n* Iterative in-order traversal mixed with custom logic\\n* Corner case analysis (easy to miss out to clear left child of the last node)\\n\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        TreeNode preRoot = new TreeNode();\\n        TreeNode prev = preRoot;\\n        \\n        TreeNode curr = root;\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        \\n        // classic stack+current approach for non-recursive in-order traversal\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            curr = stack.pop();\\n            \\n            // link previous node with current one (and detach it from left branch)\\n            prev.right = curr;\\n            prev.left = null;\\n            \\n            // current node becomes previous\\n            prev = curr;\\n            \\n            // this is transition within in-order traversal\\n            // (next iteration will use either stack of switch over to curr if it\\'s not null)\\n            curr = curr.right;\\n        }\\n        // this is tricky corner case:\\n        prev.left = null;\\n        \\n        // prev.right is already null since it\\'s the last node within in-order traversal\\n\\n        return preRoot.right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        TreeNode preRoot = new TreeNode();\\n        TreeNode prev = preRoot;\\n        \\n        TreeNode curr = root;\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        \\n        // classic stack+current approach for non-recursive in-order traversal\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            curr = stack.pop();\\n            \\n            // link previous node with current one (and detach it from left branch)\\n            prev.right = curr;\\n            prev.left = null;\\n            \\n            // current node becomes previous\\n            prev = curr;\\n            \\n            // this is transition within in-order traversal\\n            // (next iteration will use either stack of switch over to curr if it\\'s not null)\\n            curr = curr.right;\\n        }\\n        // this is tricky corner case:\\n        prev.left = null;\\n        \\n        // prev.right is already null since it\\'s the last node within in-order traversal\\n\\n        return preRoot.right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352997,
                "title": "compilation-of-different-solutions",
                "content": "**Recursive Traversal** with Global variables\\n```\\npublic:\\n    TreeNode* newroot, *curr;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        increasingBST(root->left);\\n        if (newroot == NULL) { \\n            newroot = new TreeNode(root->val);\\n            curr = newroot;\\n        }\\n        else {\\n            curr->right = new TreeNode(root->val);\\n            curr=curr->right;\\n        }   \\n        increasingBST(root->right);\\n        return newroot;\\n    }\\n```\\n\\n**Recursive traversal** without Global variables\\n```\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) {\\n            return NULL;\\n        }\\n        TreeNode* tmp = new TreeNode(-1);\\n        TreeNode* cur = tmp;\\n\\t\\t\\n        in_order(root, cur);\\n        \\n        cur = tmp->right;\\n        return cur;\\n    }\\n    \\n    void in_order(TreeNode* root, TreeNode* &cur) {\\n        if (root) {\\n            in_order(root->left, cur);\\n            cur->right = root;\\n            root->left = NULL;\\n            cur = cur->right;   \\n            in_order(root->right, cur);\\n        }\\n```\\n**Iterative Traversal** with stack\\n```\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        TreeNode* newroot=NULL, *newcurr;\\n        stack<TreeNode*> stck;\\n        TreeNode* curr=root;\\n        while (curr || !stck.empty()) {\\n            while (curr) {\\n                stck.push(curr);\\n                curr=curr->left;\\n            }\\n            \\n            curr=stck.top();\\n            stck.pop();\\n            if (newroot == NULL) {\\n                newroot = new TreeNode(curr->val);\\n                newcurr = newroot;\\n            }\\n            else {\\n                newcurr->right = new TreeNode(curr->val);\\n                newcurr = newcurr->right;\\n            }   \\n            curr=curr->right;\\n        }   \\n        return newroot;\\n    }\\n```\\n\\n**Iterative Traversal** without stack(**Morrys Method**)\\n```\\nTreeNode* increasingBST(TreeNode* root) {\\n        TreeNode dummy(0);\\n        TreeNode* cur = root, *prev = &dummy;\\n        while(cur) {\\n            if(!cur->left) {\\n                prev->right = cur;\\n                prev = cur;\\n                cur = cur->right;\\n            }else {\\n                TreeNode* pred = cur->left;\\n                while(pred->right && pred->right!= cur) pred = pred->right;\\n                if(!pred->right) {\\n                    pred->right = cur;\\n                    cur = cur->left;\\n                }else {\\n                    cur->left = nullptr;\\n                    prev->right = cur;\\n                    prev = cur;\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return dummy.right;\\n    }\\n```\\n**Recursive way** without Global variables and helper function\\n```\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail = NULL) {\\n        if (!root) return tail;\\n        TreeNode* res = increasingBST(root->left, root);\\n        root->left = NULL;\\n        root->right = increasingBST(root->right, tail);\\n        return res;\\n    }\\n```\\n\\nHappy Coding :)",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\npublic:\\n    TreeNode* newroot, *curr;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        increasingBST(root->left);\\n        if (newroot == NULL) { \\n            newroot = new TreeNode(root->val);\\n            curr = newroot;\\n        }\\n        else {\\n            curr->right = new TreeNode(root->val);\\n            curr=curr->right;\\n        }   \\n        increasingBST(root->right);\\n        return newroot;\\n    }\\n```\n```\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) {\\n            return NULL;\\n        }\\n        TreeNode* tmp = new TreeNode(-1);\\n        TreeNode* cur = tmp;\\n\\t\\t\\n        in_order(root, cur);\\n        \\n        cur = tmp->right;\\n        return cur;\\n    }\\n    \\n    void in_order(TreeNode* root, TreeNode* &cur) {\\n        if (root) {\\n            in_order(root->left, cur);\\n            cur->right = root;\\n            root->left = NULL;\\n            cur = cur->right;   \\n            in_order(root->right, cur);\\n        }\\n```\n```\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        TreeNode* newroot=NULL, *newcurr;\\n        stack<TreeNode*> stck;\\n        TreeNode* curr=root;\\n        while (curr || !stck.empty()) {\\n            while (curr) {\\n                stck.push(curr);\\n                curr=curr->left;\\n            }\\n            \\n            curr=stck.top();\\n            stck.pop();\\n            if (newroot == NULL) {\\n                newroot = new TreeNode(curr->val);\\n                newcurr = newroot;\\n            }\\n            else {\\n                newcurr->right = new TreeNode(curr->val);\\n                newcurr = newcurr->right;\\n            }   \\n            curr=curr->right;\\n        }   \\n        return newroot;\\n    }\\n```\n```\\nTreeNode* increasingBST(TreeNode* root) {\\n        TreeNode dummy(0);\\n        TreeNode* cur = root, *prev = &dummy;\\n        while(cur) {\\n            if(!cur->left) {\\n                prev->right = cur;\\n                prev = cur;\\n                cur = cur->right;\\n            }else {\\n                TreeNode* pred = cur->left;\\n                while(pred->right && pred->right!= cur) pred = pred->right;\\n                if(!pred->right) {\\n                    pred->right = cur;\\n                    cur = cur->left;\\n                }else {\\n                    cur->left = nullptr;\\n                    prev->right = cur;\\n                    prev = cur;\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return dummy.right;\\n    }\\n```\n```\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail = NULL) {\\n        if (!root) return tail;\\n        TreeNode* res = increasingBST(root->left, root);\\n        root->left = NULL;\\n        root->right = increasingBST(root->right, tail);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331974,
                "title": "javascript-clean-recursive-solution",
                "content": "```\\nvar increasingBST = function(root) {\\n  if (!root) {\\n    return root;\\n  }\\n  \\n  const leftRoot = increasingBST(root.left);\\n  root.left = null;\\n  root.right = increasingBST(root.right);\\n  \\n  if (!leftRoot) {\\n    return root;\\n  }\\n  \\n  let lastLeftNode = leftRoot;\\n  while (lastLeftNode.right) {\\n    lastLeftNode = lastLeftNode.right;\\n  }\\n  \\n  lastLeftNode.right = root;\\n  return leftRoot;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar increasingBST = function(root) {\\n  if (!root) {\\n    return root;\\n  }\\n  \\n  const leftRoot = increasingBST(root.left);\\n  root.left = null;\\n  root.right = increasingBST(root.right);\\n  \\n  if (!leftRoot) {\\n    return root;\\n  }\\n  \\n  let lastLeftNode = leftRoot;\\n  while (lastLeftNode.right) {\\n    lastLeftNode = lastLeftNode.right;\\n  }\\n  \\n  lastLeftNode.right = root;\\n  return leftRoot;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169107,
                "title": "c-easy-solution-using-in-order-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) {\\n            return NULL;\\n        }\\n        \\n        TreeNode* tmp = new TreeNode(-1);\\n        TreeNode* cur = tmp;\\n        \\n        in_order(root, cur);\\n        \\n        cur = tmp->right;\\n        delete tmp;\\n            \\n        return cur;\\n    }\\n    \\n    void in_order(TreeNode* root, TreeNode* &cur) {\\n        if (root) {\\n            in_order(root->left, cur);\\n            \\n            cur->right = root;\\n            root->left = NULL;\\n            cur = cur->right;\\n            \\n            in_order(root->right, cur);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) {\\n            return NULL;\\n        }\\n        \\n        TreeNode* tmp = new TreeNode(-1);\\n        TreeNode* cur = tmp;\\n        \\n        in_order(root, cur);\\n        \\n        cur = tmp->right;\\n        delete tmp;\\n            \\n        return cur;\\n    }\\n    \\n    void in_order(TreeNode* root, TreeNode* &cur) {\\n        if (root) {\\n            in_order(root->left, cur);\\n            \\n            cur->right = root;\\n            root->left = NULL;\\n            cur = cur->right;\\n            \\n            in_order(root->right, cur);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511732,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  TreeNode* increasingBST(TreeNode* root, TreeNode* tail = nullptr) {\\n    if (root == nullptr)\\n      return tail;\\n    TreeNode* ans = increasingBST(root->left, root);\\n    root->left = nullptr;\\n    root->right = increasingBST(root->right, tail);\\n    return ans;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def dfsInorder(self, root):\\n        if root is None: return\\n        self.dfsInorder(root.left)\\n        self.represented.append(root.val)\\n        self.dfsInorder(root.right)\\n\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        self.represented = []\\n        self.dfsInorder(root)\\n\\n        pointer = answer = TreeNode(self.represented[0])\\n        for node in self.represented[1:]:\\n            pointer.right = TreeNode(node)\\n            pointer = pointer.right\\n\\n        return answer\\n```\\n\\n```Java []\\nclass Solution {\\n    TreeNode arr = new TreeNode(0, null, null);\\n    TreeNode pointer = arr;\\n    public TreeNode increasingBST(TreeNode root) {\\n        func(root);\\n        return arr.right;\\n    }\\n    void func (TreeNode root) {\\n        if (root==null) return;\\n        func(root.left);\\n        TreeNode temp = new TreeNode (root.val, null, null);\\n        pointer.right = temp;\\n        pointer = pointer.right;\\n        func(root.right);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  TreeNode* increasingBST(TreeNode* root, TreeNode* tail = nullptr) {\\n    if (root == nullptr)\\n      return tail;\\n    TreeNode* ans = increasingBST(root->left, root);\\n    root->left = nullptr;\\n    root->right = increasingBST(root->right, tail);\\n    return ans;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def dfsInorder(self, root):\\n        if root is None: return\\n        self.dfsInorder(root.left)\\n        self.represented.append(root.val)\\n        self.dfsInorder(root.right)\\n\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        self.represented = []\\n        self.dfsInorder(root)\\n\\n        pointer = answer = TreeNode(self.represented[0])\\n        for node in self.represented[1:]:\\n            pointer.right = TreeNode(node)\\n            pointer = pointer.right\\n\\n        return answer\\n```\n```Java []\\nclass Solution {\\n    TreeNode arr = new TreeNode(0, null, null);\\n    TreeNode pointer = arr;\\n    public TreeNode increasingBST(TreeNode root) {\\n        func(root);\\n        return arr.right;\\n    }\\n    void func (TreeNode root) {\\n        if (root==null) return;\\n        func(root.left);\\n        TreeNode temp = new TreeNode (root.val, null, null);\\n        pointer.right = temp;\\n        pointer = pointer.right;\\n        func(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440812,
                "title": "89-tc-and-76-sc-easy-python-solution",
                "content": "```\\ndef increasingBST(self, root: TreeNode) -> TreeNode:\\n\\tarr = []\\n\\tdef dfs(node):\\n\\t\\tif not(node):\\n\\t\\t\\treturn \\n\\t\\tdfs(node.left)\\n\\t\\tarr.append(node.val)\\n\\t\\tdfs(node.right)\\n\\n\\tdfs(root)\\n\\troot = curr = TreeNode(arr[0])\\n\\tfor i in arr[1:]:\\n\\t\\tcurr.right = TreeNode(i)\\n\\t\\tcurr = curr.right\\n\\treturn root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef increasingBST(self, root: TreeNode) -> TreeNode:\\n\\tarr = []\\n\\tdef dfs(node):\\n\\t\\tif not(node):\\n\\t\\t\\treturn \\n\\t\\tdfs(node.left)\\n\\t\\tarr.append(node.val)\\n\\t\\tdfs(node.right)\\n\\n\\tdfs(root)\\n\\troot = curr = TreeNode(arr[0])\\n\\tfor i in arr[1:]:\\n\\t\\tcurr.right = TreeNode(i)\\n\\t\\tcurr = curr.right\\n\\treturn root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2269176,
                "title": "includes-explanation-95-efficient-easy-understanding",
                "content": "# Upvote, it matters \\n**Explanation:**\\n* To find solve out the respective task as given in the question,\\n* Find out the inOrder Traversal of the tree.\\n* Re-draw the entire tree such that left part of each node takes **None**\\n\\n\\n```\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        \\n        res = self.inOrder(root)        \\n        newTree = TreeNode(res[0])\\n        temp = newTree\\n        for i in range(1,len(res)):\\n            newNode = TreeNode(res[i])\\n            temp.right = newNode\\n            temp = temp.right\\n        return newTree\\n        \\n    def inOrder(self,root):\\n        if(root == None):\\n            return []\\n        return self.inOrder(root.left)+[root.val]+self.inOrder(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        \\n        res = self.inOrder(root)        \\n        newTree = TreeNode(res[0])\\n        temp = newTree\\n        for i in range(1,len(res)):\\n            newNode = TreeNode(res[i])\\n            temp.right = newNode\\n            temp = temp.right\\n        return newTree\\n        \\n    def inOrder(self,root):\\n        if(root == None):\\n            return []\\n        return self.inOrder(root.left)+[root.val]+self.inOrder(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957606,
                "title": "c-o-1-space-rotations-in-a-tree-dsw-algorithm",
                "content": "The question may be easy, but it has an elegant constant space solution. I\\'m really impressed that nobody wrote about it. \\n\\nIf you\\'d heard of the [DSW algorithm](https://en.wikipedia.org/wiki/Day\\u2013Stout\\u2013Warren_algorithm) for balancing a BST, you could recognize that the problem asks for the first step of the algorithm, which creates a \"vine\" from the tree.\\n\\nThe idea is simple if you know about [rotations in a tree](https://en.wikipedia.org/wiki/Tree_rotation), as we can apply \"right rotations\" until we no longer have left children in our tree.\\n\\nWhat are those \"right rotations\", and why do they work for this problem?\\nRight rotations are used to make a left child of a node the parent of that node. These rotations work really well when working with BSTs, as a left child always has a value less than the node\\'s value, so if we make our node as a right child for the left child, the BST property remains (see the image below where we rotate the E node to the right):\\n\\n![image](https://assets.leetcode.com/users/images/ed7b4770-3b66-4289-8070-89d58f9f583f_1650206049.1359787.png)\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        TreeNode *prev = NULL, *node = root;\\n        \\n        while(node != NULL) {\\n            \\n            if(node->left == NULL) {\\n                prev = node;\\n                node = node->right;\\n                continue;\\n            }\\n            \\n            TreeNode *child = node->left;\\n            TreeNode *left = child->right;\\n            \\n            child->right = node;\\n            node->left = left;\\n            \\n            if(prev == NULL)\\n                root = child;\\n            else\\n                prev->right = child;\\n            \\n            node = child;\\n            \\n        }\\n        \\n        return root;\\n        \\n    }\\n    \\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        TreeNode *prev = NULL, *node = root;\\n        \\n        while(node != NULL) {\\n            \\n            if(node->left == NULL) {\\n                prev = node;\\n                node = node->right;\\n                continue;\\n            }\\n            \\n            TreeNode *child = node->left;\\n            TreeNode *left = child->right;\\n            \\n            child->right = node;\\n            node->left = left;\\n            \\n            if(prev == NULL)\\n                root = child;\\n            else\\n                prev->right = child;\\n            \\n            node = child;\\n            \\n        }\\n        \\n        return root;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957363,
                "title": "kotlin-recursive-tree-walk-reuse-nodes",
                "content": "Starting from the largest element, reconnect the nodes as requested.\\n```\\nclass Solution {\\n    fun increasingBST(root: TreeNode?): TreeNode? {\\n        var p: TreeNode? = null\\n        \\n        fun walk(node: TreeNode?) {\\n            node?.run {\\n                walk(right)\\n                right = p\\n                p = this\\n                walk(left)\\n                left = null\\n            }\\n        }\\n        \\n        walk(root)\\n        return p       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun increasingBST(root: TreeNode?): TreeNode? {\\n        var p: TreeNode? = null\\n        \\n        fun walk(node: TreeNode?) {\\n            node?.run {\\n                walk(right)\\n                right = p\\n                p = this\\n                walk(left)\\n                left = null\\n            }\\n        }\\n        \\n        walk(root)\\n        return p       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956214,
                "title": "c-2-solutions-with-w-o-creating-new-tree-inorder-w-o-vector",
                "content": "**1. By creating a new tree**\\nTime - O(n)\\nSpace - O(n) (new tree)\\n```\\n    TreeNode* r2;\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left);\\n        \\n        r2->right=new TreeNode(root->val);\\n        r2=r2->right;\\n        \\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        r2=new TreeNode();\\n        TreeNode* r3=r2;\\n        \\n        inorder(root);\\n        \\n        return r3->right;\\n    }\\n```\\n\\n**2. Witout creating a new tree / rearranging the given tree**\\nTime - O(n)\\nSpace - O(h) (recursion stack)\\n\\n**Note :** Don\\'t forget to set left of root node as NULL after visiting left subtree . I got error due to this & was stuck for about 10 minutes \\uD83D\\uDE29 .\\n\\n```\\n\\tTreeNode* r2;\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left);\\n        \\n        root->left=NULL;\\n        r2->right=root;\\n        r2=r2->right;\\n        \\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        r2=new TreeNode();\\n        TreeNode* r3=r2;\\n        \\n        inorder(root);\\n        \\n        return r3->right;\\n    }\\n```\\n\\n**Do share your views & upvote if you like !!!**  \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n    TreeNode* r2;\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left);\\n        \\n        r2->right=new TreeNode(root->val);\\n        r2=r2->right;\\n        \\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        r2=new TreeNode();\\n        TreeNode* r3=r2;\\n        \\n        inorder(root);\\n        \\n        return r3->right;\\n    }\\n```\n```\\n\\tTreeNode* r2;\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left);\\n        \\n        root->left=NULL;\\n        r2->right=root;\\n        r2=r2->right;\\n        \\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        r2=new TreeNode();\\n        TreeNode* r3=r2;\\n        \\n        inorder(root);\\n        \\n        return r3->right;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955004,
                "title": "python-3-iterative-in-order-traversal-explanation",
                "content": "### Explanation\\n- Perform an in-order traversal\\n- Let the right child of the previous/smaller node be the current node\\n- Remove the left child to avoid cycle\\n- Return the smallest node\\n### Implementation\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        node = root\\n        stack = []\\n        prev = None\\n        lowest = None\\n        while stack or node:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:    \\n                node = stack.pop()\\n                if not lowest:\\n                    lowest = node\\n                node.left = None\\n                if prev:\\n                    prev.right = node\\n                prev = node\\n                node = node.right\\n        return lowest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        node = root\\n        stack = []\\n        prev = None\\n        lowest = None\\n        while stack or node:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:    \\n                node = stack.pop()\\n                if not lowest:\\n                    lowest = node\\n                node.left = None\\n                if prev:\\n                    prev.right = node\\n                prev = node\\n                node = node.right\\n        return lowest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488013,
                "title": "c-easy-to-understand-fast-2-methods-with-and-without-using-extra-space",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Time complexity O(N)\\nSpace complexity O(N)**\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<TreeNode*> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,v);\\n        v.push_back(root);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n     vector<TreeNode*> v;\\n     inorder(root,v);\\n     for(int i=0;i<v.size()-1;i++)\\n     {\\n         v[i]->right=v[i+1];\\n         v[i]->left=NULL;\\n     }\\n        v[v.size()-1]->left=NULL;\\n        v[v.size()-1]->right=NULL;\\n        return v[0];\\n    }\\n};\\n```\\n**Time complexity O(N)\\nspace complexity O(1)**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* curr;\\n    void inorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n        if(root->left)\\n        inorder(root->left);\\n        root->left=NULL;\\n        curr->right=root;\\n        curr=root;\\n        if(root->right)\\n        inorder(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n    if(root==NULL)\\n    return NULL;\\n     TreeNode* dummy=new TreeNode(0);\\n     curr=dummy;\\n     inorder(root);\\n     return dummy->right;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<TreeNode*> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,v);\\n        v.push_back(root);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n     vector<TreeNode*> v;\\n     inorder(root,v);\\n     for(int i=0;i<v.size()-1;i++)\\n     {\\n         v[i]->right=v[i+1];\\n         v[i]->left=NULL;\\n     }\\n        v[v.size()-1]->left=NULL;\\n        v[v.size()-1]->right=NULL;\\n        return v[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* curr;\\n    void inorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n        if(root->left)\\n        inorder(root->left);\\n        root->left=NULL;\\n        curr->right=root;\\n        curr=root;\\n        if(root->right)\\n        inorder(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n    if(root==NULL)\\n    return NULL;\\n     TreeNode* dummy=new TreeNode(0);\\n     curr=dummy;\\n     inorder(root);\\n     return dummy->right;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223949,
                "title": "c-increasing-order-search-tree-inorder-traversal-explanation",
                "content": "First we do an inorder traversal and store it in a vector. Due to inorder traversal, the elements of the tree are sorted in ascending inside the vector.\\nNext function then is used to create a  new node recursively so as to create a tree where the leftmost node is the root node and all the node have no left-child.\\nElements for the new tree are obtained from the vector\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&vec)\\n    {\\n        if(root==NULL)\\n            return;\\n        inorder(root->left,vec);\\n        vec.push_back(root->val);\\n        inorder(root->right,vec);\\n    }\\n    TreeNode* build(vector<int>&vec,int start)\\n    {\\n        if(start>vec.size()-1)\\n            return NULL;\\n        TreeNode* newNode=new TreeNode(vec[start]);//new node is created with the value from the vector\\n        start++;\\n        newNode->left=NULL;//left part of the node points to null\\n        newNode->right=build(vec,start);//right part of the node points to the new node which is created by calling the function again\\n        return newNode;\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)\\n            return NULL;\\n        vector<int>vec;\\n        inorder(root,vec);\\n        return build(vec,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&vec)\\n    {\\n        if(root==NULL)\\n            return;\\n        inorder(root->left,vec);\\n        vec.push_back(root->val);\\n        inorder(root->right,vec);\\n    }\\n    TreeNode* build(vector<int>&vec,int start)\\n    {\\n        if(start>vec.size()-1)\\n            return NULL;\\n        TreeNode* newNode=new TreeNode(vec[start]);//new node is created with the value from the vector\\n        start++;\\n        newNode->left=NULL;//left part of the node points to null\\n        newNode->right=build(vec,start);//right part of the node points to the new node which is created by calling the function again\\n        return newNode;\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)\\n            return NULL;\\n        vector<int>vec;\\n        inorder(root,vec);\\n        return build(vec,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204963,
                "title": "easy-java-solution-faster-than-100",
                "content": "The approach can be divided into 2 parts :\\n1. Obtain the InOrder traversal of the given tree.\\n2. Convert the InOrder list to a Tree\\n\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        List<Integer> inorderList = inorder(root);\\n        return getBST(inorderList);\\n    }\\n    public TreeNode getBST(List<Integer> mlist)\\n    {\\n        TreeNode temp = new TreeNode(0);\\n        TreeNode ans= temp;\\n        for(int i=0;i<mlist.size();i++)\\n        {\\n          TreeNode node = new TreeNode(mlist.get(i));\\n          ans.right = node;\\n          ans = ans.right;  \\n        }\\n        return temp.right;\\n     \\n    }\\n    public List<Integer> inorder(TreeNode root)\\n    {\\n        List<Integer> ans = new ArrayList<>();\\n        if(root == null)\\n            return ans;\\n        \\n      List<Integer> left = inorder(root.left);\\n      List<Integer> right = inorder(root.right);\\n      ans.addAll(left);\\n      ans.add(root.val);\\n      ans.addAll(right);\\n        \\n     return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        List<Integer> inorderList = inorder(root);\\n        return getBST(inorderList);\\n    }\\n    public TreeNode getBST(List<Integer> mlist)\\n    {\\n        TreeNode temp = new TreeNode(0);\\n        TreeNode ans= temp;\\n        for(int i=0;i<mlist.size();i++)\\n        {\\n          TreeNode node = new TreeNode(mlist.get(i));\\n          ans.right = node;\\n          ans = ans.right;  \\n        }\\n        return temp.right;\\n     \\n    }\\n    public List<Integer> inorder(TreeNode root)\\n    {\\n        List<Integer> ans = new ArrayList<>();\\n        if(root == null)\\n            return ans;\\n        \\n      List<Integer> left = inorder(root.left);\\n      List<Integer> right = inorder(root.right);\\n      ans.addAll(left);\\n      ans.add(root.val);\\n      ans.addAll(right);\\n        \\n     return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958798,
                "title": "javascript-solution",
                "content": "```\\nvar increasingBST = function(root) {\\n    let arr = []\\n    const getTree = (root) => {\\n        if(!root) return\\n        if (root.left) getTree(root.left)\\n        arr.push(root.val)\\n        if (root.right) getTree(root.right)\\n        \\n    }\\n\\t\\n    getTree(root)\\n\\t\\n    const buildTree = (arr) => {\\n        if (arr.length === 0) return null\\n        let tree = new TreeNode()\\n        tree.val = arr.shift()\\n        tree.right = buildTree(arr)\\n        return tree\\n    }\\n    \\n    return buildTree(arr)\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar increasingBST = function(root) {\\n    let arr = []\\n    const getTree = (root) => {\\n        if(!root) return\\n        if (root.left) getTree(root.left)\\n        arr.push(root.val)\\n        if (root.right) getTree(root.right)\\n        \\n    }\\n\\t\\n    getTree(root)\\n\\t\\n    const buildTree = (arr) => {\\n        if (arr.length === 0) return null\\n        let tree = new TreeNode()\\n        tree.val = arr.shift()\\n        tree.right = buildTree(arr)\\n        return tree\\n    }\\n    \\n    return buildTree(arr)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 958357,
                "title": "c-in-order-traverse",
                "content": "```\\n/*\\nIdea[1]: in-order output the whole tree.\\nStraight forward traverse the tree: result = inorder(root.left) + root + inorder(root.right)\\n*/\\n\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail =NULL) {\\n        if(!root) return tail;        \\n        TreeNode* res= increasingBST(root->left, root);  // step1: left child\\n        root->left = NULL;                               // step2: root\\n        root->right= increasingBST(root->right, tail);   // step3: right child\\n        return res;\\n    }\\n};\\n//Referecen:\\n//[1] https://leetcode.com/problems/increasing-order-search-tree/discuss/165885/C%2B%2BJavaPython-Self-Explained-5-line-O(N)\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nIdea[1]: in-order output the whole tree.\\nStraight forward traverse the tree: result = inorder(root.left) + root + inorder(root.right)\\n*/\\n\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail =NULL) {\\n        if(!root) return tail;        \\n        TreeNode* res= increasingBST(root->left, root);  // step1: left child\\n        root->left = NULL;                               // step2: root\\n        root->right= increasingBST(root->right, tail);   // step3: right child\\n        return res;\\n    }\\n};\\n//Referecen:\\n//[1] https://leetcode.com/problems/increasing-order-search-tree/discuss/165885/C%2B%2BJavaPython-Self-Explained-5-line-O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556967,
                "title": "rust-0ms",
                "content": "```rust\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\nimpl Solution {\\n    pub fn increasing_bst(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        if let Some(node) = root.clone() {\\n            let mut vals = Solution::walk(root.clone());\\n            vals.reverse();\\n            let fst = vals.pop().unwrap();\\n            *node.borrow_mut() = TreeNode::new(fst);\\n            node.borrow_mut().right = Solution::inc_bst(vals)\\n        }\\n        root\\n    }\\n\\n    fn inc_bst(mut vals: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\\n        if vals.is_empty() {\\n            return None;\\n        }\\n        let v = vals.pop().unwrap();\\n        let node = Rc::new(RefCell::new(TreeNode::new(v)));\\n        node.borrow_mut().right = Solution::inc_bst(vals);\\n        Some(node)\\n    }\\n\\n    fn walk(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut vals: Vec<i32> = vec![];\\n        if let Some(node) = root {\\n            let node = node.borrow();\\n            vals.extend(Solution::walk(node.left.clone()));\\n            vals.push(node.val);\\n            vals.extend(Solution::walk(node.right.clone()));\\n        }\\n        vals\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\nimpl Solution {\\n    pub fn increasing_bst(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        if let Some(node) = root.clone() {\\n            let mut vals = Solution::walk(root.clone());\\n            vals.reverse();\\n            let fst = vals.pop().unwrap();\\n            *node.borrow_mut() = TreeNode::new(fst);\\n            node.borrow_mut().right = Solution::inc_bst(vals)\\n        }\\n        root\\n    }\\n\\n    fn inc_bst(mut vals: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\\n        if vals.is_empty() {\\n            return None;\\n        }\\n        let v = vals.pop().unwrap();\\n        let node = Rc::new(RefCell::new(TreeNode::new(v)));\\n        node.borrow_mut().right = Solution::inc_bst(vals);\\n        Some(node)\\n    }\\n\\n    fn walk(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut vals: Vec<i32> = vec![];\\n        if let Some(node) = root {\\n            let node = node.borrow();\\n            vals.extend(Solution::walk(node.left.clone()));\\n            vals.push(node.val);\\n            vals.extend(Solution::walk(node.right.clone()));\\n        }\\n        vals\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526258,
                "title": "python-o-n-sol-by-dfs-90-w-diagram",
                "content": "Python O(n) sol by DFS\\n\\n---\\n\\n**Goal**: \\n\\n**Convert binary search tree** into a **right-skewed linked list** with ascending order.\\n\\n---\\n\\n**Hint**:\\n\\nTake advantage of the **well-order property** of **in-order traveresal in binary search tree**.\\n\\nIn-order traversal in binary search tree yields the sorted sequence with ascending order.\\nSimilarly, the reversed in-order traversal in BST yields the sorted sequence with descending order.\\n\\n---\\n\\n**Algorithm**:\\n\\nMaintain a global node, called **previous traversal node**, initialized to *None*, and update as current node on each DFS traversal.\\n\\n**Previous traversal node** always points to **next larger element for current node**\\n\\nDFS traversal with the ordering: ( Right node, Current node, Left node )\\n\\nStep_#1. Change current node\\'s **right child** as **previous traversal node**.\\n\\nStep_#2. If previous traversal node is not a empty node, change previous traversal node\\'s **left child** as **None**(i.e., NULL)\\n\\nStep_#3. **Update previous traversal node** as current node\\n\\n---\\n\\n**Observation**:\\n\\nFor Current node, Right node is its previous traversal node (i.e., next larger element ).\\nFor Left node, Current node is its previous traversal node (i.e., next larger element ).\\n\\n---\\n\\n**Abstract Model**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583122482.png)\\n\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583122492.png)\\n\\n\\n\\t \\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        \\n        prev_node = None\\n        \\n        def helper( node: TreeNode):\\n                           \\n            if node.right:\\n                helper( node.right )\\n\\n            # prev_novde always points to next larger element for current node\\n            nonlocal prev_node\\n\\n            # update right link points to next larger element\\n            node.right = prev_node\\n\\n            # break the left link of next larger element\\n            if prev_node:\\n                prev_node.left = None\\n\\n            # update previous node as current node\\n            prev_node = node\\n\\n            if node.left:\\n                helper( node.left)\\n                \\n        # ---------------------------------------\\n        helper( root )\\n        \\n        return prev_node\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #114 Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)\\n\\n[Leetcode #538 Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree/)\\n[Leetcode #1038 Binary Search Tree to Greater Sum Tree](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/)\\n\\nNote:\\n#538 and #1038 are twin-challenges, basically, they are identical to the other one.\\n\\n[Leetcode #173 Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: in-order traversal in binary search tree](https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        \\n        prev_node = None\\n        \\n        def helper( node: TreeNode):\\n                           \\n            if node.right:\\n                helper( node.right )\\n\\n            # prev_novde always points to next larger element for current node\\n            nonlocal prev_node\\n\\n            # update right link points to next larger element\\n            node.right = prev_node\\n\\n            # break the left link of next larger element\\n            if prev_node:\\n                prev_node.left = None\\n\\n            # update previous node as current node\\n            prev_node = node\\n\\n            if node.left:\\n                helper( node.left)\\n                \\n        # ---------------------------------------\\n        helper( root )\\n        \\n        return prev_node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244939,
                "title": "swift-88ms",
                "content": "```\\n    var prev: TreeNode?\\n    var head: TreeNode?\\n    \\n    func increasingBST(_ root: TreeNode?) -> TreeNode? {\\n        guard let r = root else { return nil }\\n        increasingBST(r.left)\\n        \\n        if head == nil { head = r }\\n        \\n        r.left = nil\\n        prev?.right = r\\n        prev = r\\n        \\n        increasingBST(r.right)\\n        \\n        return head\\n    }",
                "solutionTags": [],
                "code": "```\\n    var prev: TreeNode?\\n    var head: TreeNode?\\n    \\n    func increasingBST(_ root: TreeNode?) -> TreeNode? {\\n        guard let r = root else { return nil }\\n        increasingBST(r.left)\\n        \\n        if head == nil { head = r }\\n        \\n        r.left = nil\\n        prev?.right = r\\n        prev = r\\n        \\n        increasingBST(r.right)\\n        \\n        return head\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 201081,
                "title": "java-recursive-without-global-variable",
                "content": "We can simplify the problem by assuming that we have solution for left subtree and right subtree for a given node. This means that left subtree has the following structure 1->2->3->4 and right subtree has the following structure 6->7->8->9. Now we only have to link 4 to 5 and 5 to 6 and we are done.\\nOn solving the subproblem we return the leftmost node and rightmost node in an array. This is useful as we need rightmost node of the left subtree and leftmost node of right subtree to link the two subproblems.\\nTBH this was not an easy problem. What do you guys think?\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        return helper(root)[0];\\n    }\\n    \\n    private TreeNode[] helper(TreeNode node) {\\n        if (node == null) { \\n            return new TreeNode[]{null, null};\\n        }\\n        TreeNode[] leftSubtree = helper(node.left);\\n        if (leftSubtree[1] != null) {\\n            leftSubtree[1].right = node;\\n        }\\n        if (leftSubtree[0] == null) {\\n            leftSubtree[0] = node;\\n        }\\n        \\n        node.left = null;\\n        \\n        TreeNode[] rightSubTree = helper(node.right);\\n        if (rightSubTree[0] != null) {\\n            node.right = rightSubTree[0];\\n        }\\n        if (rightSubTree[1] == null) {\\n            rightSubTree[1] = node;\\n        }\\n        \\n        return new TreeNode[]{leftSubtree[0], rightSubTree[1]};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        return helper(root)[0];\\n    }\\n    \\n    private TreeNode[] helper(TreeNode node) {\\n        if (node == null) { \\n            return new TreeNode[]{null, null};\\n        }\\n        TreeNode[] leftSubtree = helper(node.left);\\n        if (leftSubtree[1] != null) {\\n            leftSubtree[1].right = node;\\n        }\\n        if (leftSubtree[0] == null) {\\n            leftSubtree[0] = node;\\n        }\\n        \\n        node.left = null;\\n        \\n        TreeNode[] rightSubTree = helper(node.right);\\n        if (rightSubTree[0] != null) {\\n            node.right = rightSubTree[0];\\n        }\\n        if (rightSubTree[1] == null) {\\n            rightSubTree[1] = node;\\n        }\\n        \\n        return new TreeNode[]{leftSubtree[0], rightSubTree[1]};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185131,
                "title": "python-easy-to-understand-solution",
                "content": "Traverse then reform the entire tree.\n\n    def increasingBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n\n        def mid_order(node, L):\n            if node is None:\n                return\n            mid_order(node.left, L)\n            L.append(node.val)\n            mid_order(node.right, L)\n\n        L = []\n        mid_order(root, L)\n\n        ans = current = TreeNode(None) \n        for value in L:\n            current.right = TreeNode(value)\n            current = current.right \n        return ans.right",
                "solutionTags": [],
                "code": "    def increasingBST(self, root):\n        def mid_order(node, L):\n            mid_order(node.left, L)\n            L.append(node.val)\n            mid_order(node.right, L)\n        L = []\n        mid_order(root, L)\n        ans = current = TreeNode(None) \n            current.right = TreeNode(value)\n            current = current.right ",
                "codeTag": "Python3"
            },
            {
                "id": 165902,
                "title": "python-o-n-time-o-log-n-stack-space-with-explanation-uses-generator-yield",
                "content": "The idea is simple. We effectively build up a linked list, taking the nodes from an inorder-traversal generator. In order to make it in-place, the generator needs to save the right node before yielding the current node, otherwise it\\'d be overwritten by the caller. We don\\'t need to save the left node, because it\\'ll be fully processed before the current node is returned (due to this being an inorder traversal).\\n\\nBy using a generator, we\\'re seperating the \"tree\" logic from the \"linked list\" logic.\\n\\nNote that it does use extra space on the stack. This is unavoidable, even for an iterative solution.\\n\\n```\\nclass Solution:\\n    \\n    def increasingBST(self, root):\\n        \\n        dummy_head = TreeNode(None)\\n        current_node = dummy_head\\n        \\n        for node in self.inorder_iterator(root):\\n            current_node.right = node\\n            current_node = node\\n            current_node.left = None\\n        return dummy_head.right\\n                \\n        \\n    def inorder_iterator(self, root):\\n        if root != None:\\n            yield from self.inorder_iterator(root.left)\\n            right = root.right #Gotta save this as it\\'ll be overwritten.\\n            yield root\\n            yield from self.inorder_iterator(right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def increasingBST(self, root):\\n        \\n        dummy_head = TreeNode(None)\\n        current_node = dummy_head\\n        \\n        for node in self.inorder_iterator(root):\\n            current_node.right = node\\n            current_node = node\\n            current_node.left = None\\n        return dummy_head.right\\n                \\n        \\n    def inorder_iterator(self, root):\\n        if root != None:\\n            yield from self.inorder_iterator(root.left)\\n            right = root.right #Gotta save this as it\\'ll be overwritten.\\n            yield root\\n            yield from self.inorder_iterator(right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409910,
                "title": "python3-beats-99-52-21ms-simple-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    First create a sorted list from BST then create another\\n    BST by using values from the list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1. First we apply inorder traversal on the BST.\\n    2. Append the root value in each traversal in a list.\\n    3. As it is a binary search tree , therefore we have a sorted list.\\n    4. Then we reverse the list and create a new BST with root having\\n    the smallest value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n    O(n)\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        \\n        if not root:\\n            return None\\n\\n        def create_list(root,list1):\\n            \\n            if not root:\\n                return None\\n                \\n            create_list(root.left,list1)\\n            list1.append(root.val)\\n            create_list(root.right,list1)\\n\\n        list1=[]\\n        create_list(root,list1)\\n\\n        def inorder(list1):\\n            list1.reverse()\\n            prev=None\\n            for i in list1:\\n                new=TreeNode(i)\\n                new.right=prev\\n                prev=new\\n            return new\\n        return inorder(list1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        \\n        if not root:\\n            return None\\n\\n        def create_list(root,list1):\\n            \\n            if not root:\\n                return None\\n                \\n            create_list(root.left,list1)\\n            list1.append(root.val)\\n            create_list(root.right,list1)\\n\\n        list1=[]\\n        create_list(root,list1)\\n\\n        def inorder(list1):\\n            list1.reverse()\\n            prev=None\\n            for i in list1:\\n                new=TreeNode(i)\\n                new.right=prev\\n                prev=new\\n            return new\\n        return inorder(list1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384693,
                "title": "java-100",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n import java.util.*;\\nclass Solution {\\n\\n    TreeNode ans = new TreeNode(-1);\\n    TreeNode current = ans;\\n    public TreeNode increasingBST(TreeNode root) {\\n\\n        inorder(root);\\n        \\n        return ans.right;\\n    }\\n    void inorder(TreeNode root)\\n    {\\n        if(root == null)\\n            return;\\n\\n        inorder(root.left);\\n\\n        TreeNode newnode = new TreeNode(root.val);\\n        current.right = newnode;\\n        current = current.right;\\n        \\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n import java.util.*;\\nclass Solution {\\n\\n    TreeNode ans = new TreeNode(-1);\\n    TreeNode current = ans;\\n    public TreeNode increasingBST(TreeNode root) {\\n\\n        inorder(root);\\n        \\n        return ans.right;\\n    }\\n    void inorder(TreeNode root)\\n    {\\n        if(root == null)\\n            return;\\n\\n        inorder(root.left);\\n\\n        TreeNode newnode = new TreeNode(root.val);\\n        current.right = newnode;\\n        current = current.right;\\n        \\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205041,
                "title": "simple-easy-to-understand-beat-100",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void getInorder(TreeNode* root, vector<int>& num){\\n        if(root==NULL) return;\\n\\n        getInorder(root->left, num);\\n        num.push_back(root->val);\\n        getInorder(root->right, num);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL) return NULL;\\n        vector<int>num;\\n        getInorder(root,num);\\n        TreeNode* head = new TreeNode(num[0],NULL, NULL);\\n        TreeNode* temp = head;\\n        for(int i=1;i<num.size();i++){\\n            temp->right = new TreeNode(num[i],NULL,NULL);\\n            temp = temp->right;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void getInorder(TreeNode* root, vector<int>& num){\\n        if(root==NULL) return;\\n\\n        getInorder(root->left, num);\\n        num.push_back(root->val);\\n        getInorder(root->right, num);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL) return NULL;\\n        vector<int>num;\\n        getInorder(root,num);\\n        TreeNode* head = new TreeNode(num[0],NULL, NULL);\\n        TreeNode* temp = head;\\n        for(int i=1;i<num.size();i++){\\n            temp->right = new TreeNode(num[i],NULL,NULL);\\n            temp = temp->right;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941701,
                "title": "easy-c-solution-recursive-approach-vector-approach",
                "content": "# Intuition\\n\\n# Approach\\nThe approach is very simple. firstly we are creating a vector in which we\\'ll be going to store the nodes of current tree inorderly.\\nThen, we\\'ll create a tree in which left will point to NULL and right will print recursively till the size of i will equal to the size of vector.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, vector<int> &ans){\\n        if(root == NULL){\\n            return;\\n        }\\n        solve(root -> left,ans);\\n        ans.push_back(root -> val);\\n        solve(root -> right,ans);\\n    }\\n    TreeNode* newTree(vector<int> &ans, int i, int &n){\\n        if(i == n)\\n        return NULL;\\n\\n            TreeNode* temp = new TreeNode(ans[i]);\\n            temp -> left = NULL;\\n            temp -> right = newTree(ans, i+1,n);\\n            return temp;\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root, ans);\\n        int n = ans.size();\\n        return newTree(ans,0,n);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, vector<int> &ans){\\n        if(root == NULL){\\n            return;\\n        }\\n        solve(root -> left,ans);\\n        ans.push_back(root -> val);\\n        solve(root -> right,ans);\\n    }\\n    TreeNode* newTree(vector<int> &ans, int i, int &n){\\n        if(i == n)\\n        return NULL;\\n\\n            TreeNode* temp = new TreeNode(ans[i]);\\n            temp -> left = NULL;\\n            temp -> right = newTree(ans, i+1,n);\\n            return temp;\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root, ans);\\n        int n = ans.size();\\n        return newTree(ans,0,n);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798195,
                "title": "c-solution-increasing-order-search-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root , vector<int> &inorderVal){\\n        if(root == NULL)\\n            return ;\\n        \\n        inorder(root->left , inorderVal);\\n        inorderVal.push_back(root->val);\\n        inorder(root->right , inorderVal);\\n        \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        // BST to sorted LL logic\\n        \\n        vector<int> inorderVal;\\n        inorder(root , inorderVal);\\n        \\n        TreeNode* newRoot = new TreeNode(inorderVal[0]);\\n        TreeNode* curr = newRoot;\\n        \\n        for(int i = 1 ; i < inorderVal.size() ; i++){\\n            TreeNode* temp = new TreeNode(inorderVal[i]);\\n            \\n            curr->left = NULL;\\n            curr->right = temp;\\n            curr = temp;\\n        }\\n        \\n        //last node\\n        curr->left = NULL;\\n        curr->right = NULL;\\n        \\n        return newRoot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root , vector<int> &inorderVal){\\n        if(root == NULL)\\n            return ;\\n        \\n        inorder(root->left , inorderVal);\\n        inorderVal.push_back(root->val);\\n        inorder(root->right , inorderVal);\\n        \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        // BST to sorted LL logic\\n        \\n        vector<int> inorderVal;\\n        inorder(root , inorderVal);\\n        \\n        TreeNode* newRoot = new TreeNode(inorderVal[0]);\\n        TreeNode* curr = newRoot;\\n        \\n        for(int i = 1 ; i < inorderVal.size() ; i++){\\n            TreeNode* temp = new TreeNode(inorderVal[i]);\\n            \\n            curr->left = NULL;\\n            curr->right = temp;\\n            curr = temp;\\n        }\\n        \\n        //last node\\n        curr->left = NULL;\\n        curr->right = NULL;\\n        \\n        return newRoot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655082,
                "title": "java-100-fast-easy-code-beginner-friendly-recursion-increasing-order-search-tree",
                "content": "**Kindly upvote, if it is useful!!!**\\n\\n```\\nclass Solution {\\n    TreeNode tree = new TreeNode();\\n    TreeNode head = tree;\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;\\n        increasingBST(root.left);\\n        \\n        tree=tree.right=new TreeNode(root.val);\\n        increasingBST(root.right);\\n        return head.right;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode tree = new TreeNode();\\n    TreeNode head = tree;\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;\\n        increasingBST(root.left);\\n        \\n        tree=tree.right=new TreeNode(root.val);\\n        increasingBST(root.right);\\n        return head.right;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307332,
                "title": "javascript-easy-solution",
                "content": "```\\nvar increasingBST = function(root) {\\n    let data=[]\\n    function dfs(root){\\n        if(!root) return null\\n        dfs(root.left)\\n        data.push(root.val)\\n        dfs(root.right)\\n    }\\n    dfs(root)\\n    let node = new TreeNode(data[0])\\n    let curr=node\\n    for(let i =1; i<data.length; i++){\\n        curr.right=new TreeNode(data[i])\\n        curr=curr.right\\n   }\\n    return node\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar increasingBST = function(root) {\\n    let data=[]\\n    function dfs(root){\\n        if(!root) return null\\n        dfs(root.left)\\n        data.push(root.val)\\n        dfs(root.right)\\n    }\\n    dfs(root)\\n    let node = new TreeNode(data[0])\\n    let curr=node\\n    for(let i =1; i<data.length; i++){\\n        curr.right=new TreeNode(data[i])\\n        curr=curr.right\\n   }\\n    return node\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1957273,
                "title": "c-intuitive-recursive-in-order-traversal",
                "content": "![image](https://assets.leetcode.com/users/images/357424fc-c6af-4130-b03d-e68b01280227_1650198162.2402177.png)\\nLet\\'s quickly wrap up example test case 1.\\nWhen we traverse our BST through inorder(Left - Root - Right) traversal, we come across nodes in an increasing order, this shall prompt us that  we have to use inorder traversal. Great!! \\nLet\\'s run inorder in our example test case : 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9\\nBut then the  question is how can we then rearrage our given tree in this manner. \\n\\nWhile doing inorder traversal, when we are at the left most node, we will make it our root node. So in this example when we\\'ll be at 1, that will be our new root node, it\\'s left node will be marked as \\'NULL\\'. For every other node we have to do two things: \\n\\ntake the case of \\'2\\', we have to connect it to the right of prev node(i.e. 1) and it\\'s left should be marked as \\'NULL\\'. For \\'3\\', we have to connect it to the right of prev node(i.e. 2) and it\\'s left should be marked as \\'NULL\\'. We have to do this till we reach our right most node.\\n\\nexample code: \\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode *result, *prev;\\n    //result holds the new updated root node and prev holds previous node.\\n    TreeNode* increasingBST(TreeNode* root) {\\n        inOrder(root);\\n        return result;\\n    }\\nprivate: \\n    void inOrder(TreeNode* root) {\\n        if(root == NULL) return;\\n        inOrder(root -> left);\\n        \\n        if(result == NULL) {\\n            result = root;\\n        } else {\\n            prev -> right = root;\\n        }\\n        \\n        prev = root;\\n        root -> left = NULL;\\n        \\n        inOrder(root -> right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *result, *prev;\\n    //result holds the new updated root node and prev holds previous node.\\n    TreeNode* increasingBST(TreeNode* root) {\\n        inOrder(root);\\n        return result;\\n    }\\nprivate: \\n    void inOrder(TreeNode* root) {\\n        if(root == NULL) return;\\n        inOrder(root -> left);\\n        \\n        if(result == NULL) {\\n            result = root;\\n        } else {\\n            prev -> right = root;\\n        }\\n        \\n        prev = root;\\n        root -> left = NULL;\\n        \\n        inOrder(root -> right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956724,
                "title": "python-inorder",
                "content": "**Please upvote if it helps. Thank you!**\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        dummy = rtree = TreeNode()\\n        \\n        def inorder(node):\\n            nonlocal rtree\\n            if node:\\n                inorder(node.left)\\n                rtree.right = TreeNode(node.val)\\n                rtree = rtree.right\\n                inorder(node.right)\\n        \\n        inorder(root)\\n        \\n        return dummy.right\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        dummy = rtree = TreeNode()\\n        \\n        def inorder(node):\\n            nonlocal rtree\\n            if node:\\n                inorder(node.left)\\n                rtree.right = TreeNode(node.val)\\n                rtree = rtree.right\\n                inorder(node.right)\\n        \\n        inorder(root)\\n        \\n        return dummy.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955041,
                "title": "python-clean-inorder-traversal",
                "content": "```\\nfrom typing import Optional\\n\\n\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(rt: Optional[TreeNode], node: TreeNode) -> TreeNode:\\n            if rt is not None:\\n                node = inorder(rt.left, node)\\n\\n                node.right = TreeNode(val=rt.val)\\n                node = node.right\\n\\n                node = inorder(rt.right, node)\\n\\n            return node\\n\\n        dummy_node = TreeNode()\\n        inorder(root, dummy_node)\\n\\n        return dummy_node.right\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nfrom typing import Optional\\n\\n\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(rt: Optional[TreeNode], node: TreeNode) -> TreeNode:\\n            if rt is not None:\\n                node = inorder(rt.left, node)\\n\\n                node.right = TreeNode(val=rt.val)\\n                node = node.right\\n\\n                node = inorder(rt.right, node)\\n\\n            return node\\n\\n        dummy_node = TreeNode()\\n        inorder(root, dummy_node)\\n\\n        return dummy_node.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826130,
                "title": "c-inorder-recursion",
                "content": "```\\n//We have declare two global varibale which head is main head of final tree and res which store the current state of tree\\n TreeNode*res=NULL;\\n    TreeNode*head=NULL;\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n\\t//if root is NULL we return for NULL\\n        if(root==NULL)\\n        {\\n            return NULL;\\n        }\\n\\t\\t//Moving left as per inorder traversal\\n        increasingBST(root->left);\\n\\t\\t//if res is null means currently No node is find  then we create a node\\n        if(res==NULL){\\n            res=new TreeNode(root->val);\\n\\t\\t\\t//create a node and make it update to head as it become the root of tree\\n            head=res;\\n        }\\n        else{\\n\\t\\t//IF res is not null means we have to place the next node to the res->right asper question and update the res= res->right because place for nect upcoming nodes.\\n\\t\\t    res->right= new TreeNode(root->val);\\n            res=res->right;\\n        }\\n       increasingBST(root->right);\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//We have declare two global varibale which head is main head of final tree and res which store the current state of tree\\n TreeNode*res=NULL;\\n    TreeNode*head=NULL;\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n\\t//if root is NULL we return for NULL\\n        if(root==NULL)\\n        {\\n            return NULL;\\n        }\\n\\t\\t//Moving left as per inorder traversal\\n        increasingBST(root->left);\\n\\t\\t//if res is null means currently No node is find  then we create a node\\n        if(res==NULL){\\n            res=new TreeNode(root->val);\\n\\t\\t\\t//create a node and make it update to head as it become the root of tree\\n            head=res;\\n        }\\n        else{\\n\\t\\t//IF res is not null means we have to place the next node to the res->right asper question and update the res= res->right because place for nect upcoming nodes.\\n\\t\\t    res->right= new TreeNode(root->val);\\n            res=res->right;\\n        }\\n       increasingBST(root->right);\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1764863,
                "title": "c-100-faster-using-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    stack<TreeNode*> st;\\n    //reverse inorder traversal\\n    void reverse_inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        reverse_inorder(root->right);\\n        st.push(root);\\n        reverse_inorder(root->left);\\n    }\\n    \\n    // creation of Increasing Order Search Tree with the values of stack st\\n    TreeNode* iost() //iost: Increasing Order Search Tree\\n    {\\n        if(st.empty())\\n            return NULL;\\n        TreeNode* root=new TreeNode(st.top()->val);\\n        st.pop();\\n        root->right=iost();\\n        return root;\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* ans;\\n        reverse_inorder(root);\\n        ans=iost();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    stack<TreeNode*> st;\\n    //reverse inorder traversal\\n    void reverse_inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        reverse_inorder(root->right);\\n        st.push(root);\\n        reverse_inorder(root->left);\\n    }\\n    \\n    // creation of Increasing Order Search Tree with the values of stack st\\n    TreeNode* iost() //iost: Increasing Order Search Tree\\n    {\\n        if(st.empty())\\n            return NULL;\\n        TreeNode* root=new TreeNode(st.top()->val);\\n        st.pop();\\n        root->right=iost();\\n        return root;\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* ans;\\n        reverse_inorder(root);\\n        ans=iost();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423875,
                "title": "golang-inorder",
                "content": "```\\nvar prev *TreeNode\\n\\nfunc increasingBST(root *TreeNode) *TreeNode {\\n    ans := &TreeNode{}\\n    prev = ans\\n    \\n    inOrder(root)\\n\\n    return ans.Right\\n}\\n\\nfunc inOrder(root *TreeNode) {\\n    if root == nil {\\n        return \\n    }\\n    \\n    inOrder(root.Left)\\n    \\n    // switch\\n    prev.Right = root\\n    prev = root\\n    prev.Left = nil\\n    \\n    inOrder(root.Right)\\n    return \\n}\\n```\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nvar prev *TreeNode\\n\\nfunc increasingBST(root *TreeNode) *TreeNode {\\n    ans := &TreeNode{}\\n    prev = ans\\n    \\n    inOrder(root)\\n\\n    return ans.Right\\n}\\n\\nfunc inOrder(root *TreeNode) {\\n    if root == nil {\\n        return \\n    }\\n    \\n    inOrder(root.Left)\\n    \\n    // switch\\n    prev.Right = root\\n    prev = root\\n    prev.Left = nil\\n    \\n    inOrder(root.Right)\\n    return \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1380845,
                "title": "easy-c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> v;\\n    void inorder(TreeNode* root)\\n    {\\n        if(root!=NULL)\\n        {\\n            inorder(root->left);\\n            v.push_back(root);\\n            inorder(root->right);\\n        }\\n    }\\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        inorder(root);\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            v[i]->left=NULL;\\n            v[i]->right=v[i+1];\\n        }\\n        v[v.size()-1]->left=NULL;\\n        v[v.size()-1]->right=NULL;\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> v;\\n    void inorder(TreeNode* root)\\n    {\\n        if(root!=NULL)\\n        {\\n            inorder(root->left);\\n            v.push_back(root);\\n            inorder(root->right);\\n        }\\n    }\\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        inorder(root);\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            v[i]->left=NULL;\\n            v[i]->right=v[i+1];\\n        }\\n        v[v.size()-1]->left=NULL;\\n        v[v.size()-1]->right=NULL;\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108197,
                "title": "c-simple-faster-than-100",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode * node, TreeNode *& res)\\n    {\\n        if(!node) return;\\n        helper(node->left, res);\\n        res->right= new TreeNode(node->val);\\n        res = res->right;\\n        helper(node->right, res);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode * res = new TreeNode(0);\\n        TreeNode * tmp = res;\\n        helper(root, tmp);\\n        return res->right;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode * node, TreeNode *& res)\\n    {\\n        if(!node) return;\\n        helper(node->left, res);\\n        res->right= new TreeNode(node->val);\\n        res = res->right;\\n        helper(node->right, res);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode * res = new TreeNode(0);\\n        TreeNode * tmp = res;\\n        helper(root, tmp);\\n        return res->right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958819,
                "title": "c-recursive-in-order-solution-explained-100-time-65-space",
                "content": "Nice one, I wanted to play with it with an in-order traversal; I might find better solutions later, but for now this one works.\\n\\nFirst of all we declare 3 extra node variables:\\n* `left` and `right` will take the value of recursive calls to our main function if we have a left or right branch respectively, `NULL` otherwise;\\n* `tmp` will store the current `root`.\\n\\nNow, one important bit we need to do now (and that I initially forgot here giving me an endless cycle), is to cut the current left branch away from `root` before proceeding further.\\n\\nIf we have a `left` (which is going to be already in-order by this time), then we turn it into the new `root` and navigate it to the end, attach the previous root (stored as `tmp`) and move on to attach `right` (similarly to `left`, already sorted by now).\\n\\nFinally, we can return `root` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode *increasingBST(TreeNode *root) {\\n        // support variables and recursively parsing the tree in order\\n        TreeNode *left = root->left ? increasingBST(root->left) : NULL,\\n            *right = root->right ? increasingBST(root->right) : NULL, *tmp = root;\\n        // cutting left node branch from roo\\n        root->left = NULL;\\n        if (left) {\\n            root = left;\\n            // moving to the last element of left\\n            while (left->right) left = left->right;\\n            left->right = tmp;\\n        }\\n        if (right) tmp->right = right;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph",
                    "Binary Search Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode *increasingBST(TreeNode *root) {\\n        // support variables and recursively parsing the tree in order\\n        TreeNode *left = root->left ? increasingBST(root->left) : NULL,\\n            *right = root->right ? increasingBST(root->right) : NULL, *tmp = root;\\n        // cutting left node branch from roo\\n        root->left = NULL;\\n        if (left) {\\n            root = left;\\n            // moving to the last element of left\\n            while (left->right) left = left->right;\\n            left->right = tmp;\\n        }\\n        if (right) tmp->right = right;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958453,
                "title": "python-dfs-recursion",
                "content": "I was having a hard time undertanding the LC write for the recurive relinking solution. So I wanted to rewrite it in a way that was more understandable. We can assing an empty tree structure outside our dfs caller. We write our dfs the usual in order way making changes to this tree outside. In our DFS call, we examine a node and set its left to None. We also set its right to the node we are at, but also move our pointer in our tree outside te caller. Then we decsend right. Since we allocated an empty tree at first, we need to return the right subtree.\\n\\n```\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        newTree = TreeNode(None)\\n        self.temp = newTree\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            node.left = None\\n            self.temp.right = node\\n            self.temp = node\\n            dfs(node.right)\\n        dfs(root)\\n        return newTree.right\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        newTree = TreeNode(None)\\n        self.temp = newTree\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            node.left = None\\n            self.temp.right = node\\n            self.temp = node\\n            dfs(node.right)\\n        dfs(root)\\n        return newTree.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958112,
                "title": "simple-java-solution-o-h-space-o-n-time-0ms-100-faster",
                "content": "here only space taken is call stack space.\\n```\\nclass Solution {\\n    private TreeNode head = new TreeNode(-1);\\n    private TreeNode temp = head;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inOrder(root);\\n        return head.right;\\n    }\\n    private void inOrder(TreeNode root){\\n        if(root!=null) {\\n            inOrder(root.left);\\n            temp.right=root;\\n            root.left=null;\\n            temp=root;\\n            inOrder(root.right);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private TreeNode head = new TreeNode(-1);\\n    private TreeNode temp = head;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inOrder(root);\\n        return head.right;\\n    }\\n    private void inOrder(TreeNode root){\\n        if(root!=null) {\\n            inOrder(root.left);\\n            temp.right=root;\\n            root.left=null;\\n            temp=root;\\n            inOrder(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845950,
                "title": "c-iterative-solution",
                "content": "```\\npublic class Solution {\\n    public TreeNode IncreasingBST(TreeNode root) {                \\n        TreeNode dummy = new TreeNode(-1);\\n        TreeNode curr = dummy;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        stack.Push(root);    \\n        \\n        while(stack.Count > 0)\\n        {\\n            while(root.left != null)\\n            {\\n                stack.Push(root.left);\\n                root = root.left;\\n            }\\n            \\n            TreeNode node = stack.Pop();\\n            curr.right = new TreeNode(node.val);\\n            curr = curr.right;\\n            \\n            if(node.right != null)\\n            {\\n                stack.Push(node.right);\\n                root = node.right;\\n            }\\n        }       \\n        \\n        return dummy.right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n    public TreeNode IncreasingBST(TreeNode root) {                \\n        TreeNode dummy = new TreeNode(-1);\\n        TreeNode curr = dummy;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        stack.Push(root);    \\n        \\n        while(stack.Count > 0)\\n        {\\n            while(root.left != null)\\n            {\\n                stack.Push(root.left);\\n                root = root.left;\\n            }\\n            \\n            TreeNode node = stack.Pop();\\n            curr.right = new TreeNode(node.val);\\n            curr = curr.right;\\n            \\n            if(node.right != null)\\n            {\\n                stack.Push(node.right);\\n                root = node.right;\\n            }\\n        }       \\n        \\n        return dummy.right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830539,
                "title": "simple-recursive-solution-in-c",
                "content": "class Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* tmp = new TreeNode(-1);\\n        TreeNode* res = tmp;\\n        dfs(root, tmp);\\n        return res->right;\\n    }\\n    \\n    TreeNode* dfs(TreeNode* root, TreeNode* res){\\n        if(!root) return res;\\n\\n        res = dfs(root->left, res);\\n        res->right=new TreeNode(root->val);\\n        res=res->right;\\n        res = dfs(root->right, res);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* tmp = new TreeNode(-1);\\n        TreeNode* res = tmp;\\n        dfs(root, tmp);\\n        return res->right;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 570684,
                "title": "2-java-solutions-beat-100-memory-and-complexity",
                "content": "1)\\n```\\nclass Solution {\\n    TreeNode tmp, res;\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n        rec(root);\\n        \\n        return res;\\n    }\\n    \\n    void rec(TreeNode root) {\\n        if (root.left != null)\\n            rec(root.left);\\n        \\n        if (tmp == null) {\\n            res = new TreeNode(root.val);\\n            tmp = res;\\n        } else {\\n            tmp.right = new TreeNode(root.val);;\\n            tmp = tmp.right;\\n        }\\n        \\n        if (root.right != null)\\n            rec(root.right);\\n        \\n    }\\n}\\n```\\n2)\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n        rec(root);\\n        \\n        TreeNode res = null;\\n        TreeNode tmp = null;\\n        \\n        for(Integer i : l) {\\n            if (res == null) {\\n                res = new TreeNode(i);\\n                tmp = res;\\n            } else {\\n                tmp.right = new TreeNode(i);\\n                tmp = tmp.right;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    List<Integer> l = new ArrayList<>();\\n    \\n    void rec(TreeNode root) {\\n        \\n        if (root.left != null)\\n            rec(root.left);\\n        \\n        l.add(root.val);\\n        \\n        if (root.right != null)\\n           rec(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode tmp, res;\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n        rec(root);\\n        \\n        return res;\\n    }\\n    \\n    void rec(TreeNode root) {\\n        if (root.left != null)\\n            rec(root.left);\\n        \\n        if (tmp == null) {\\n            res = new TreeNode(root.val);\\n            tmp = res;\\n        } else {\\n            tmp.right = new TreeNode(root.val);;\\n            tmp = tmp.right;\\n        }\\n        \\n        if (root.right != null)\\n            rec(root.right);\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n        rec(root);\\n        \\n        TreeNode res = null;\\n        TreeNode tmp = null;\\n        \\n        for(Integer i : l) {\\n            if (res == null) {\\n                res = new TreeNode(i);\\n                tmp = res;\\n            } else {\\n                tmp.right = new TreeNode(i);\\n                tmp = tmp.right;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    List<Integer> l = new ArrayList<>();\\n    \\n    void rec(TreeNode root) {\\n        \\n        if (root.left != null)\\n            rec(root.left);\\n        \\n        l.add(root.val);\\n        \\n        if (root.right != null)\\n           rec(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500809,
                "title": "intuitive-javascript-solution-with-relinking",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\nvar increasingBST = function(root) {\\n    // Relink\\n    // start with a fake new root to connect the rest and \\n    // assign the pointer to the current node to the new root\\n    const newRoot = new TreeNode(undefined);\\n    let cur = newRoot;\\n    const inorder = node => {\\n        if (node === null) {\\n            return;\\n        }\\n        inorder(node.left);\\n        // for current node, we want to only link the node to the right\\n        node.left = null;\\n        cur.right = node;\\n        // reassign node to cur for the next operation\\n        cur = node;\\n        inorder(node.right);\\n    }\\n    inorder(root)\\n    return newRoot.right;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\nvar increasingBST = function(root) {\\n    // Relink\\n    // start with a fake new root to connect the rest and \\n    // assign the pointer to the current node to the new root\\n    const newRoot = new TreeNode(undefined);\\n    let cur = newRoot;\\n    const inorder = node => {\\n        if (node === null) {\\n            return;\\n        }\\n        inorder(node.left);\\n        // for current node, we want to only link the node to the right\\n        node.left = null;\\n        cur.right = node;\\n        // reassign node to cur for the next operation\\n        cur = node;\\n        inorder(node.right);\\n    }\\n    inorder(root)\\n    return newRoot.right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331799,
                "title": "java-solution",
                "content": "**Recursive:**\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        return increasingBST(root, null);\\n    }\\n\\n    public TreeNode increasingBST(TreeNode root, TreeNode tail) {\\n        if (root == null) return tail;\\n        TreeNode res = increasingBST(root.left, root);\\n        root.left = null;\\n        root.right = increasingBST(root.right, tail);\\n        return res;\\n    }\\n}\\n```\\n\\nRuntime: 2 ms, faster than 99.97% of Java online submissions for Increasing Order Search Tree.\\nMemory Usage: 39 MB, less than 80.50% of Java online submissions for Increasing Order Search Tree.\\n\\n**Iterative:**\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode dummy = new TreeNode(0), p = dummy;\\n        while(root != null || !stack.empty()){\\n            if(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            else{\\n                TreeNode cur = stack.pop();\\n                root = cur.right;\\n                cur.left = null;\\n                p.right = cur;\\n                p = p.right;\\n            }\\n        }\\n        return dummy.right;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode cur = root, dummy = new TreeNode(0), tree = dummy;   \\n        while(cur != null || !stack.empty()){\\n            while(cur != null){\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            cur.left = null;\\n            tree.right = cur;\\n            cur = cur.right;\\n            tree = tree.right;\\n        }\\n        return dummy.right;\\n    }\\n}\\n```\\n\\nRuntime: 5 ms, faster than 13.11% of Java online submissions for Increasing Order Search Tree.\\nMemory Usage: 44.3 MB, less than 43.05% of Java online submissions for Increasing Order Search Tree.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        return increasingBST(root, null);\\n    }\\n\\n    public TreeNode increasingBST(TreeNode root, TreeNode tail) {\\n        if (root == null) return tail;\\n        TreeNode res = increasingBST(root.left, root);\\n        root.left = null;\\n        root.right = increasingBST(root.right, tail);\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode dummy = new TreeNode(0), p = dummy;\\n        while(root != null || !stack.empty()){\\n            if(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            else{\\n                TreeNode cur = stack.pop();\\n                root = cur.right;\\n                cur.left = null;\\n                p.right = cur;\\n                p = p.right;\\n            }\\n        }\\n        return dummy.right;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode cur = root, dummy = new TreeNode(0), tree = dummy;   \\n        while(cur != null || !stack.empty()){\\n            while(cur != null){\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            cur.left = null;\\n            tree.right = cur;\\n            cur = cur.right;\\n            tree = tree.right;\\n        }\\n        return dummy.right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166019,
                "title": "python-iterative-solution",
                "content": "Algorithm:\\n1. Store the inorder of tree in an array\\n2. Create nodes based on the values in array and then connect them to each other on node.right\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return None\\n        # get inorder list\\n        res = []\\n        stack = []\\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                res.append(node.val)\\n                root = node.right\\n\\n        # adjust node.right\\n        dummy = pre = TreeNode(-1)\\n        i = 0\\n        while i < len(res):\\n            pre.right = TreeNode(res[i])\\n            pre = pre.right\\n            i += 1\\n        return dummy.right\\n        \\n                \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return None\\n        # get inorder list\\n        res = []\\n        stack = []\\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                res.append(node.val)\\n                root = node.right\\n\\n        # adjust node.right\\n        dummy = pre = TreeNode(-1)\\n        i = 0\\n        while i < len(res):\\n            pre.right = TreeNode(res[i])\\n            pre = pre.right\\n            i += 1\\n        return dummy.right\\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653822,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode ans=new TreeNode(-1);\\n    TreeNode curr=ans;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return ans.right;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null) return;\\n\\n        inorder(root.left);\\n        TreeNode newnode= new TreeNode(root.val);\\n        curr.right=newnode;\\n        curr=curr.right;\\n\\n        inorder(root.right);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode ans=new TreeNode(-1);\\n    TreeNode curr=ans;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return ans.right;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null) return;\\n\\n        inorder(root.left);\\n        TreeNode newnode= new TreeNode(root.val);\\n        curr.right=newnode;\\n        curr=curr.right;\\n\\n        inorder(root.right);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496673,
                "title": "c-solution-easy-to-understand-beats-100",
                "content": "# Intuition\\nWe will take the help of a vector to store the **in-order** traversal and then create a chain of tree nodes, only with the right children.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void inOrder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return ;\\n        }\\n\\n        inOrder(root->left,vct);\\n        vct.push_back(root->val);\\n        inOrder(root->right,vct);\\n    }\\n\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int> vct;\\n        \\n        inOrder(root,vct);\\n\\n        TreeNode* ans = new TreeNode(vct[0],NULL,NULL);\\n        TreeNode* temp = ans;\\n\\n        for(int i = 1; i < vct.size(); ++i){\\n            TreeNode* newNode = new TreeNode(vct[i]);\\n            temp->right = newNode;\\n            temp = temp->right;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void inOrder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return ;\\n        }\\n\\n        inOrder(root->left,vct);\\n        vct.push_back(root->val);\\n        inOrder(root->right,vct);\\n    }\\n\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int> vct;\\n        \\n        inOrder(root,vct);\\n\\n        TreeNode* ans = new TreeNode(vct[0],NULL,NULL);\\n        TreeNode* temp = ans;\\n\\n        for(int i = 1; i < vct.size(); ++i){\\n            TreeNode* newNode = new TreeNode(vct[i]);\\n            temp->right = newNode;\\n            temp = temp->right;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411224,
                "title": "c-2-approach-stack-iterative-solution-recursive-solution-well-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrecursive approach\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, TreeNode* &tail)   {\\n        if(!root)   return;\\n        inorder(root->left, tail);\\n        root -> left = NULL;\\n        tail -> right = root;\\n        tail = tail -> right;\\n        inorder(root -> right, tail);\\n    }\\n\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* head = new TreeNode(0);\\n        TreeNode* tail = head;\\n        inorder(root, tail);\\n        return head -> right;\\n    }\\n};\\n```\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstack - iterative solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(!root)   return NULL;\\n        TreeNode* head = NULL;\\n        TreeNode* tail = head;\\n        stack<TreeNode*> st;\\n        \\n        while(!st.empty() || root) {\\n            if(root)    {\\n                st.push(root);\\n                root = root -> left;\\n            }\\n            else    {\\n                root = st.top();\\n                st.pop();\\n                if(!head)   {\\n                    head = new TreeNode(root->val);\\n                    tail = head;\\n                }\\n                else    {\\n                    tail -> right = new TreeNode(root -> val);\\n                    tail = tail -> right;\\n                }\\n                root = root -> right;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, TreeNode* &tail)   {\\n        if(!root)   return;\\n        inorder(root->left, tail);\\n        root -> left = NULL;\\n        tail -> right = root;\\n        tail = tail -> right;\\n        inorder(root -> right, tail);\\n    }\\n\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* head = new TreeNode(0);\\n        TreeNode* tail = head;\\n        inorder(root, tail);\\n        return head -> right;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(!root)   return NULL;\\n        TreeNode* head = NULL;\\n        TreeNode* tail = head;\\n        stack<TreeNode*> st;\\n        \\n        while(!st.empty() || root) {\\n            if(root)    {\\n                st.push(root);\\n                root = root -> left;\\n            }\\n            else    {\\n                root = st.top();\\n                st.pop();\\n                if(!head)   {\\n                    head = new TreeNode(root->val);\\n                    tail = head;\\n                }\\n                else    {\\n                    tail -> right = new TreeNode(root -> val);\\n                    tail = tail -> right;\\n                }\\n                root = root -> right;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386991,
                "title": "use-queue-stack-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nqueue\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, queue<TreeNode*>& q) {\\n        if (!root) return;\\n        inorder(root->left, q);\\n        q.push(root);\\n        inorder(root->right, q);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (!root) return nullptr;\\n        queue<TreeNode*> q;\\n        inorder(root, q);\\n        TreeNode* newRoot = q.front();\\n        TreeNode* node = newRoot;\\n        q.pop();\\n        while (!q.empty()) {\\n            node->left = nullptr;\\n            node->right = q.front();\\n            node = node->right;\\n            q.pop();\\n        }\\n        node->left = nullptr;\\n        node->right = nullptr;\\n        return newRoot;\\n    }\\n};\\n//stack\\nclass Solution {\\npublic:\\n    stack<TreeNode*> st;\\n    void dfs(TreeNode*root){\\n        if(root==nullptr)\\n            return;\\n        if(root->right)\\n            dfs(root->right);\\n        st.push(root);\\n        if(root->left)\\n            dfs(root->left);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        dfs(root);\\n        if(st.empty())\\n            return nullptr;\\n        TreeNode *res = st.top();\\n        st.pop();\\n        TreeNode* temp = res;\\n        while(temp && !st.empty()){\\n            temp->right = st.top();\\n            temp->left=nullptr;\\n            st.pop();\\n            temp = temp->right;\\n        }\\n        temp->left=nullptr;\\n        temp->right=nullptr;\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    void inorder(TreeNode* root, queue<TreeNode*>& q) {\\n        if (!root) return;\\n        inorder(root->left, q);\\n        q.push(root);\\n        inorder(root->right, q);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3302485,
                "title": "simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    ArrayList<TreeNode> arr=new ArrayList<>();\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;\\n        inorder(root);\\n        for(int i=0;i<arr.size()-1;i++){\\n            arr.get(i).right=arr.get(i+1);\\n            arr.get(i).left=null;\\n        }\\n        arr.get(arr.size()-1).left=null;\\n        arr.get(arr.size()-1).right=null;\\n        return arr.get(0);\\n    }\\n    void inorder(TreeNode node){\\n        if(node==null) return;\\n        inorder(node.left);\\n        arr.add(node);\\n        inorder(node.right);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    ArrayList<TreeNode> arr=new ArrayList<>();\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;\\n        inorder(root);\\n        for(int i=0;i<arr.size()-1;i++){\\n            arr.get(i).right=arr.get(i+1);\\n            arr.get(i).left=null;\\n        }\\n        arr.get(arr.size()-1).left=null;\\n        arr.get(arr.size()-1).right=null;\\n        return arr.get(0);\\n    }\\n    void inorder(TreeNode node){\\n        if(node==null) return;\\n        inorder(node.left);\\n        arr.add(node);\\n        inorder(node.right);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301317,
                "title": "c-fastest-possible-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int>v;\\n    dfs(root,v);\\n    TreeNode* ans= NULL;\\n    TreeNode* temp;\\n    for(auto x: v)\\n    {\\n        if(ans == NULL)\\n        {\\n            ans = new TreeNode(x);\\n            temp = ans;\\n        }\\n        else\\n        {\\n        temp->right= new TreeNode(x);\\n        temp = temp->right;\\n        }\\n        \\n    }\\n        return ans;\\n    }\\n\\n    void dfs(TreeNode* node,vector<int>&v)\\n    {\\n        if(node==NULL)return;\\n\\n        dfs(node->left,v);\\n        v.push_back(node->val);\\n        dfs(node->right,v);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int>v;\\n    dfs(root,v);\\n    TreeNode* ans= NULL;\\n    TreeNode* temp;\\n    for(auto x: v)\\n    {\\n        if(ans == NULL)\\n        {\\n            ans = new TreeNode(x);\\n            temp = ans;\\n        }\\n        else\\n        {\\n        temp->right= new TreeNode(x);\\n        temp = temp->right;\\n        }\\n        \\n    }\\n        return ans;\\n    }\\n\\n    void dfs(TreeNode* node,vector<int>&v)\\n    {\\n        if(node==NULL)return;\\n\\n        dfs(node->left,v);\\n        v.push_back(node->val);\\n        dfs(node->right,v);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227033,
                "title": "javascript-solution-beats-96-46-inorder-traversal-approach",
                "content": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\nvar increasingBST = function(root) {\\n    const result = new TreeNode();\\n    let auxPointer = result;\\n    const inorderTraversal = (node) => {\\n        if (!node) return;\\n        inorderTraversal(node.left);\\n        auxPointer.right = new TreeNode(node.val);\\n        auxPointer = auxPointer.right;\\n        inorderTraversal(node.right);\\n    };\\n    inorderTraversal(root);\\n    return result.right;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\nvar increasingBST = function(root) {\\n    const result = new TreeNode();\\n    let auxPointer = result;\\n    const inorderTraversal = (node) => {\\n        if (!node) return;\\n        inorderTraversal(node.left);\\n        auxPointer.right = new TreeNode(node.val);\\n        auxPointer = auxPointer.right;\\n        inorderTraversal(node.right);\\n    };\\n    inorderTraversal(root);\\n    return result.right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3213293,
                "title": "java-easy-0ms-beats-100-simple-inorder",
                "content": "# Code\\n```\\nclass Solution {\\n    TreeNode arr = new TreeNode(0, null, null);\\n    TreeNode pointer = arr;\\n    public TreeNode increasingBST(TreeNode root) {\\n        func(root);\\n        return arr.right;\\n    }\\n    void func (TreeNode root) {\\n        if (root==null) return;\\n        func(root.left);\\n        TreeNode temp = new TreeNode (root.val, null, null);\\n        pointer.right = temp;\\n        pointer = pointer.right;\\n        func(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode arr = new TreeNode(0, null, null);\\n    TreeNode pointer = arr;\\n    public TreeNode increasingBST(TreeNode root) {\\n        func(root);\\n        return arr.right;\\n    }\\n    void func (TreeNode root) {\\n        if (root==null) return;\\n        func(root.left);\\n        TreeNode temp = new TreeNode (root.val, null, null);\\n        pointer.right = temp;\\n        pointer = pointer.right;\\n        func(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213234,
                "title": "python-simple-tree-creation-inorder-traversal-modified",
                "content": "# Code\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        newRoot = TreeNode(0)\\n        self.temp = newRoot\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            new = TreeNode(root.val)\\n            self.temp.right = new\\n            self.temp = self.temp.right\\n            inorder(root.right)\\n        inorder(root)\\n        return newRoot.right\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        newRoot = TreeNode(0)\\n        self.temp = newRoot\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            new = TreeNode(root.val)\\n            self.temp.right = new\\n            self.temp = self.temp.right\\n            inorder(root.right)\\n        inorder(root)\\n        return newRoot.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880173,
                "title": "0-ms-faster-than-100-java-solution",
                "content": "# Runtime: 0 ms, faster than 100.00% of Java online submissions for Increasing Order Search Tree.\\nMemory Usage: 39.7 MB, less than 94.59% of Java online submissions for Increasing Order Search Tree.\\n# class Solution {\\n    ArrayList<TreeNode> a=new ArrayList<>();\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;\\n        inorder(root);\\n        TreeNode t=a.get(0);\\n        TreeNode trav=t;\\n        int i=1;\\n        while(i<a.size())\\n        {\\n           trav.right=a.get(i);\\n            trav=trav.right;\\n            trav.left=null;\\n            i++;\\n        }\\n        return t;\\n    }\\n    public void inorder(TreeNode root)\\n    {\\n        if(root!=null)\\n        {\\n            inorder(root.left);\\n            a.add(root);\\n            inorder(root.right);\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    ArrayList<TreeNode> a=new ArrayList<>();\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;\\n        inorder(root);\\n        TreeNode t=a.get(0);\\n        TreeNode trav=t;\\n        int i=1;\\n        while(i<a.size())\\n        {\\n           trav.right=a.get(i);\\n            trav=trav.right;\\n            trav.left=null;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2681240,
                "title": "92-accepted-solution-simple-and-easy-approach-python",
                "content": "**Yes**, this is not optimized solution but easy to understand for beginners\\nIf you have any **doubts** or **suggestions** put in comments.\\n```\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        def dfs(root, ans):\\n            if not root: return\\n            dfs(root.left, ans)\\n            ans.append(root.val)\\n            dfs(root.right, ans)\\n            return ans\\n        ans = dfs(root, [])\\n        root = right = TreeNode(0)\\n        for i in range(len(ans)):\\n            right.right = TreeNode(ans[i])\\n            right = right.right\\n        return root.right\\n```\\nPlease **UpVote**, if you like it **:)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        def dfs(root, ans):\\n            if not root: return\\n            dfs(root.left, ans)\\n            ans.append(root.val)\\n            dfs(root.right, ans)\\n            return ans\\n        ans = dfs(root, [])\\n        root = right = TreeNode(0)\\n        for i in range(len(ans)):\\n            right.right = TreeNode(ans[i])\\n            right = right.right\\n        return root.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518597,
                "title": "python-dfs-iterative",
                "content": "```\\ndef increasingBST(self, root: TreeNode) -> TreeNode:\\n        \"\"\"\\n        Without extra space\\n        Time -> O(logn)\\n        Space -> O(1) + O(n) (for new TreeNode)\\n        \"\"\"\\n        new = TreeNode()\\n        head = new\\n        def dfs(node):\\n            nonlocal new\\n            if node is None:\\n                return\\n            dfs(node.left)\\n            new.right = TreeNode(node.val)\\n            new = new.right\\n            dfs(node.right)\\n        dfs(root)\\n        return head.right\\n    \\n        \"\"\"\\n        With extra Space\\n        Time -> O(logn)\\n        x -> Number of not null element\\n        Space -> O(x) + O(n) (For new TreeNode)\\n            \"\"\"\\n        # q = []\\n        # def dfs(node):\\n        #     if node is None:\\n        #         return\\n        #     dfs(node.left)\\n        #     q.append(node.val)\\n        #     new = new.right\\n        #     dfs(node.right)\\n        # dfs(root)\\n        # new = TreeNode(q.pop(0))\\n        # head = new\\n        # while q:\\n        #     new.right = TreeNode(q.pop(0))\\n        #     new = new.right\\n        # return head\\n```\\n\\n### \\uD83D\\uDE02 Random Dev Meme\\n<img src=\"https://random-memer.herokuapp.com/\" width=\"512px\"/>",
                "solutionTags": [
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\ndef increasingBST(self, root: TreeNode) -> TreeNode:\\n        \"\"\"\\n        Without extra space\\n        Time -> O(logn)\\n        Space -> O(1) + O(n) (for new TreeNode)\\n        \"\"\"\\n        new = TreeNode()\\n        head = new\\n        def dfs(node):\\n            nonlocal new\\n            if node is None:\\n                return\\n            dfs(node.left)\\n            new.right = TreeNode(node.val)\\n            new = new.right\\n            dfs(node.right)\\n        dfs(root)\\n        return head.right\\n    \\n        \"\"\"\\n        With extra Space\\n        Time -> O(logn)\\n        x -> Number of not null element\\n        Space -> O(x) + O(n) (For new TreeNode)\\n            \"\"\"\\n        # q = []\\n        # def dfs(node):\\n        #     if node is None:\\n        #         return\\n        #     dfs(node.left)\\n        #     q.append(node.val)\\n        #     new = new.right\\n        #     dfs(node.right)\\n        # dfs(root)\\n        # new = TreeNode(q.pop(0))\\n        # head = new\\n        # while q:\\n        #     new.right = TreeNode(q.pop(0))\\n        #     new = new.right\\n        # return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2516557,
                "title": "c-solution-inorder-traversal-tree-building-easy-approach",
                "content": "Difficulty lvl : 3/10\\nConcept use : Inorder traversal & building binary tree\\nsource : \\n[https://www.youtube.com/watch?v=Z_NEgBgbRVI]\\n \\n```\\n// if it help plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    void inorder(TreeNode* root,vector<int> &ans){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        inorder(root->left,ans);\\n        ans.push_back(root->val);\\n        inorder(root->right,ans);\\n    }\\n    \\n    TreeNode* helper(TreeNode* root,int num){\\n        // base case\\n        if(root == NULL){\\n            root = new TreeNode(num);\\n            return root;\\n        }\\n        \\n        if(root->val < num){\\n            root->right = helper(root->right,num);\\n        }\\n        else{\\n            root->left = helper(root->left,num);\\n        }\\n        \\n        return root;\\n    }\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root,ans);\\n        \\n        TreeNode* node = NULL;\\n        for(int i=0;i<ans.size();i++){\\n            int num = ans[i];\\n            node = helper(node,num);\\n        }\\n        \\n        return node;\\n    }\\n};\\n// if it help plz upvote :)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n// if it help plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    void inorder(TreeNode* root,vector<int> &ans){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        inorder(root->left,ans);\\n        ans.push_back(root->val);\\n        inorder(root->right,ans);\\n    }\\n    \\n    TreeNode* helper(TreeNode* root,int num){\\n        // base case\\n        if(root == NULL){\\n            root = new TreeNode(num);\\n            return root;\\n        }\\n        \\n        if(root->val < num){\\n            root->right = helper(root->right,num);\\n        }\\n        else{\\n            root->left = helper(root->left,num);\\n        }\\n        \\n        return root;\\n    }\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root,ans);\\n        \\n        TreeNode* node = NULL;\\n        for(int i=0;i<ans.size();i++){\\n            int num = ans[i];\\n            node = helper(node,num);\\n        }\\n        \\n        return node;\\n    }\\n};\\n// if it help plz upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300088,
                "title": "0ms-c-inorder-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* main = new TreeNode(0);\\n    TreeNode* temp = main;\\n    void fill(TreeNode* root){\\n        if(root == NULL) return;\\n        fill(root -> left);\\n        main -> right = new TreeNode(root -> val);\\n        main -> left = NULL;\\n        main = main -> right;\\n        fill(root -> right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n        fill(root);\\n        return temp -> right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* main = new TreeNode(0);\\n    TreeNode* temp = main;\\n    void fill(TreeNode* root){\\n        if(root == NULL) return;\\n        fill(root -> left);\\n        main -> right = new TreeNode(root -> val);\\n        main -> left = NULL;\\n        main = main -> right;\\n        fill(root -> right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n        fill(root);\\n        return temp -> right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241653,
                "title": "c-solution-faster-than-100",
                "content": "```\\n void inorder(TreeNode* root,vector<int>&vec)\\n    {\\n        if(root==NULL)\\n            return;\\n        inorder(root->left,vec);\\n        vec.push_back(root->val);\\n        inorder(root->right,vec);\\n    }\\n    TreeNode* insert(TreeNode* root, int val)\\n    {\\n        if(root==NULL)\\n        {\\n            root = new TreeNode(val);\\n            return root;\\n        }\\n        if(root->val>val)\\n            root->left = insert(root->left,val);\\n        else\\n            root->right = insert(root->right,val);\\n        return root;\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int>vec;\\n        inorder(root,vec);\\n        root = NULL;\\n        for(int i=0;i<vec.size();i++)\\n            root = insert(root,vec[i]);\\n        return root;\\n    }\\n```\\n\\nIF YOU LIKE THE CODE, DO UPVOTE.",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n void inorder(TreeNode* root,vector<int>&vec)\\n    {\\n        if(root==NULL)\\n            return;\\n        inorder(root->left,vec);\\n        vec.push_back(root->val);\\n        inorder(root->right,vec);\\n    }\\n    TreeNode* insert(TreeNode* root, int val)\\n    {\\n        if(root==NULL)\\n        {\\n            root = new TreeNode(val);\\n            return root;\\n        }\\n        if(root->val>val)\\n            root->left = insert(root->left,val);\\n        else\\n            root->right = insert(root->right,val);\\n        return root;\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int>vec;\\n        inorder(root,vec);\\n        root = NULL;\\n        for(int i=0;i<vec.size();i++)\\n            root = insert(root,vec[i]);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2215089,
                "title": "java-beats-java-submissions-0-ms",
                "content": "(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n```\\nclass Solution {\\n    TreeNode prev;\\n    TreeNode ans;\\n    \\n    public TreeNode increasingBST(TreeNode node) {\\n        \\n        \\n        if (node==null){\\n            return null;\\n        }\\n        \\n        increasingBST(node.left);\\n               \\n        if (ans==null){\\n            ans=node;\\n        }\\n        else{\\n            prev.right=node;\\n        }\\n        \\n        prev=node;\\n        node.left=null;        \\n        \\n        increasingBST(node.right);\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev;\\n    TreeNode ans;\\n    \\n    public TreeNode increasingBST(TreeNode node) {\\n        \\n        \\n        if (node==null){\\n            return null;\\n        }\\n        \\n        increasingBST(node.left);\\n               \\n        if (ans==null){\\n            ans=node;\\n        }\\n        else{\\n            prev.right=node;\\n        }\\n        \\n        prev=node;\\n        node.left=null;        \\n        \\n        increasingBST(node.right);\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144503,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) ->  TreeNode:\\n        \\n        q = [root]\\n        lst = []\\n        \\n        while q:\\n            lst.append(q[0].val)\\n            \\n            if q[0].left:\\n                q.append(q[0].left)\\n                \\n            if q[0].right:\\n                q.append(q[0].right)\\n                \\n            q.pop(0)\\n            \\n        l = sorted(lst)\\n        root1 = TreeNode(l[0])\\n        \\n        def insert(root1 , val):\\n            if root1.right:\\n                return insert(root1.right , val)\\n            else:\\n                root1.right = TreeNode(val)\\n            \\n        for i in l[1:]:\\n            insert(root1,i)\\n        \\n        \\n        return root1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) ->  TreeNode:\\n        \\n        q = [root]\\n        lst = []\\n        \\n        while q:\\n            lst.append(q[0].val)\\n            \\n            if q[0].left:\\n                q.append(q[0].left)\\n                \\n            if q[0].right:\\n                q.append(q[0].right)\\n                \\n            q.pop(0)\\n            \\n        l = sorted(lst)\\n        root1 = TreeNode(l[0])\\n        \\n        def insert(root1 , val):\\n            if root1.right:\\n                return insert(root1.right , val)\\n            else:\\n                root1.right = TreeNode(val)\\n            \\n        for i in l[1:]:\\n            insert(root1,i)\\n        \\n        \\n        return root1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959751,
                "title": "simpler-java-solution-using-recursion-and-global-variable",
                "content": "start adding nodes as they come in inorder traversal to tempNode global variable. and keep building answer.\\n\\n```\\nclass Solution {\\n    private TreeNode newRoot = new TreeNode(-1);\\n\\tprivate TreeNode temp = newRoot;\\n\\n\\tpublic TreeNode increasingBST(TreeNode root) {\\n\\t\\thelper(root);\\n\\t\\treturn newRoot.right;\\n\\t}\\n\\n\\tprivate void helper(TreeNode root) {\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\thelper(root.left);\\n\\t\\t//prepare templist\\n\\t\\ttemp.right = root;\\n\\t\\t//to avoid loop set left child false. it is already visited.\\n\\t\\troot.left = null;\\n\\t\\t//move temp list \\n\\t\\ttemp = temp.right;\\n\\t\\thelper(root.right);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private TreeNode newRoot = new TreeNode(-1);\\n\\tprivate TreeNode temp = newRoot;\\n\\n\\tpublic TreeNode increasingBST(TreeNode root) {\\n\\t\\thelper(root);\\n\\t\\treturn newRoot.right;\\n\\t}\\n\\n\\tprivate void helper(TreeNode root) {\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\thelper(root.left);\\n\\t\\t//prepare templist\\n\\t\\ttemp.right = root;\\n\\t\\t//to avoid loop set left child false. it is already visited.\\n\\t\\troot.left = null;\\n\\t\\t//move temp list \\n\\t\\ttemp = temp.right;\\n\\t\\thelper(root.right);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958177,
                "title": "typescript-recursive-solution",
                "content": "```\\nfunction findBiggest(root: TreeNode): TreeNode {\\n  if (root.right != null) {\\n    return findBiggest(root.right);\\n  }\\n\\n  return root;\\n}\\n\\nfunction increasingBST(root: TreeNode | null): TreeNode | null {\\n  if (root == null) {\\n    return null;\\n  }\\n\\n  let newRoot = root.left;\\n\\n  if (newRoot != null) {\\n    let newRootBiggest = findBiggest(newRoot);\\n    newRootBiggest.right = root;\\n    root.left = null;\\n\\n    return increasingBST(newRoot);\\n  }\\n\\n  root.right = increasingBST(root.right);\\n\\n  return root;\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\nfunction findBiggest(root: TreeNode): TreeNode {\\n  if (root.right != null) {\\n    return findBiggest(root.right);\\n  }\\n\\n  return root;\\n}\\n\\nfunction increasingBST(root: TreeNode | null): TreeNode | null {\\n  if (root == null) {\\n    return null;\\n  }\\n\\n  let newRoot = root.left;\\n\\n  if (newRoot != null) {\\n    let newRootBiggest = findBiggest(newRoot);\\n    newRootBiggest.right = root;\\n    root.left = null;\\n\\n    return increasingBST(newRoot);\\n  }\\n\\n  root.right = increasingBST(root.right);\\n\\n  return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1957849,
                "title": "java-100-faster-inorder-traversal",
                "content": "```\\nclass Solution {\\n    TreeNode tree;\\n    public TreeNode increasingBST(TreeNode root) {\\n        BST(root);\\n        return tree;\\n    }\\n    \\n    public void BST(TreeNode root) {\\n        if(root == null)  return;\\n        BST(root.right);\\n        tree = new TreeNode(root.val, null, tree);\\n        BST(root.left);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode tree;\\n    public TreeNode increasingBST(TreeNode root) {\\n        BST(root);\\n        return tree;\\n    }\\n    \\n    public void BST(TreeNode root) {\\n        if(root == null)  return;\\n        BST(root.right);\\n        tree = new TreeNode(root.val, null, tree);\\n        BST(root.left);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957605,
                "title": "897-increasing-order-search-tree-two-solution-easy",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n \\n \\n \\n \\n \\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n\\t\\t\\n        TreeNode dummy= new TreeNode();\\n        TreeNode preNode = dummy;\\n        Stack<TreeNode> s = new Stack<>();\\n        \\n        while(root!=null || !s.isEmpty()){\\n            \\n            while(root!=null){\\n                s.push(root);\\n                root=root.left;\\n            }\\n            \\n            if(!s.isEmpty()){\\n                root = s.pop();\\n                \\n                preNode.right = root;\\n                preNode = root;\\n                preNode.left = null;\\n                \\n                root=root.right;\\n                \\n            }\\n            \\n        }\\n        return dummy.right;\\n    }\\n    \\n    \\n \\n second using  inorder \\n    \\n       \\n//         List<Integer> ans = new ArrayList<>();\\n//         inorder(root,ans);\\n//         TreeNode result = new TreeNode(0);\\n//         TreeNode curr=result;\\n//         for(int i:ans){\\n//             curr.right=new TreeNode(i);\\n//             curr = curr.right;\\n//         }\\n        \\n//        return result.right;  \\n        \\n        \\n//     }\\n//     public void inorder(TreeNode root,List<Integer> ans ){\\n//         if(root==null) return ;\\n//         inorder(root.left,ans);\\n//         ans.add(root.val);\\n//         inorder(root.right,ans);\\n        \\n//     }\\n    \\n    \\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n \\n \\n \\n \\n \\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n\\t\\t\\n        TreeNode dummy= new TreeNode();\\n        TreeNode preNode = dummy;\\n        Stack<TreeNode> s = new Stack<>();\\n        \\n        while(root!=null || !s.isEmpty()){\\n            \\n            while(root!=null){\\n                s.push(root);\\n                root=root.left;\\n            }\\n            \\n            if(!s.isEmpty()){\\n                root = s.pop();\\n                \\n                preNode.right = root;\\n                preNode = root;\\n                preNode.left = null;\\n                \\n                root=root.right;\\n                \\n            }\\n            \\n        }\\n        return dummy.right;\\n    }\\n    \\n    \\n \\n second using  inorder \\n    \\n       \\n//         List<Integer> ans = new ArrayList<>();\\n//         inorder(root,ans);\\n//         TreeNode result = new TreeNode(0);\\n//         TreeNode curr=result;\\n//         for(int i:ans){\\n//             curr.right=new TreeNode(i);\\n//             curr = curr.right;\\n//         }\\n        \\n//        return result.right;  \\n        \\n        \\n//     }\\n//     public void inorder(TreeNode root,List<Integer> ans ){\\n//         if(root==null) return ;\\n//         inorder(root.left,ans);\\n//         ans.add(root.val);\\n//         inorder(root.right,ans);\\n        \\n//     }\\n    \\n    \\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957514,
                "title": "increasing-order-search-tree",
                "content": "Simple c++ solution ---->\\n Using recursion\\n\\n\\n```\\n\\n       TreeNode* temp=NULL, *res = NULL;\\n     \\n    void inOrder(TreeNode* root){\\n               if(root==NULL) return;\\n        \\n        inOrder(root->left);\\n          \\n        if(res==NULL){\\n            res = new TreeNode(root->val);\\n            temp = res;\\n        }\\n        else {\\n            temp -> right = new TreeNode(root->val);\\n            temp= temp->right;\\n        }\\n        \\n    \\n         inOrder(root->right);\\n\\n        \\n    }\\n    \\n          \\n    TreeNode* increasingBST(TreeNode* root) {\\n           \\n           if(root==NULL) return NULL;\\n        inOrder(root);\\n        \\n        return res;\\n        \\n          \\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\n       TreeNode* temp=NULL, *res = NULL;\\n     \\n    void inOrder(TreeNode* root){\\n               if(root==NULL) return;\\n        \\n        inOrder(root->left);\\n          \\n        if(res==NULL){\\n            res = new TreeNode(root->val);\\n            temp = res;\\n        }\\n        else {\\n            temp -> right = new TreeNode(root->val);\\n            temp= temp->right;\\n        }\\n        \\n    \\n         inOrder(root->right);\\n\\n        \\n    }\\n    \\n          \\n    TreeNode* increasingBST(TreeNode* root) {\\n           \\n           if(root==NULL) return NULL;\\n        inOrder(root);\\n        \\n        return res;\\n        \\n          \\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1956490,
                "title": "2-solutions-c-explained-o-n",
                "content": "2  Approaches while solving this problem :\\n\\n1) using stack:\\n\\n*do reverse inorder traversal of elements and store them in stack (right->root->left) this will get all elements in stack in sorted order ->[1 2 3 4 5 6 7 8 9]\\n*iterate over stack elements, pop out top element->(1), make next top element as its right(1->2),and set its left to NULL\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        stack<TreeNode*> s;\\n        makestack(root,s);\\n        TreeNode *mainroot=s.top();\\n        while(!s.empty()){ //clear stack one by one  \\n            TreeNode *tempnode=s.top(); s.pop();\\n           if(!s.empty()) {\\n               tempnode->right=s.top();\\n               tempnode->left=NULL;\\n           }\\n            //when last element has been popped out \\n            else {\\n                tempnode->right=NULL;\\n                tempnode->left=NULL;\\n            }\\n        \\n        }\\n        return mainroot;\\n    }\\n    \\n    void makestack(TreeNode *root,stack<TreeNode*> &s){\\n        if(!root ) return ;\\n        makestack(root->right,s);\\n        s.push(root);\\n        makestack(root->left,s);\\n    }\\n};\\n```\\n\\n2) Using pointer to previous nodes :\\n```\\nclass Solution {\\npublic:\\n    TreeNode *mainroot=NULL;\\n    TreeNode *prev=NULL;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        inorder(root);\\n        return mainroot;\\n    }\\n    \\n    void inorder(TreeNode* root){\\n        \\n        if(!root) return ;\\n        inorder(root->left);\\n\\t\\t//mainroot is the head of the new binary tree(leftmost node) \\n        if(!mainroot){\\n            mainroot=root;\\n            prev=root;\\n        }\\n        else {\\n\\t\\t//prev is the node traversed before current node \\n            prev->right=root;\\n\\t\\t//update prev for next traversal \\n            prev=root;\\n        }\\n        root->left=NULL;\\n        inorder(root->right);\\n    }\\n};\\n```\\n\\nPlease upvote if you found it helpful :)",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Stack",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        stack<TreeNode*> s;\\n        makestack(root,s);\\n        TreeNode *mainroot=s.top();\\n        while(!s.empty()){ //clear stack one by one  \\n            TreeNode *tempnode=s.top(); s.pop();\\n           if(!s.empty()) {\\n               tempnode->right=s.top();\\n               tempnode->left=NULL;\\n           }\\n            //when last element has been popped out \\n            else {\\n                tempnode->right=NULL;\\n                tempnode->left=NULL;\\n            }\\n        \\n        }\\n        return mainroot;\\n    }\\n    \\n    void makestack(TreeNode *root,stack<TreeNode*> &s){\\n        if(!root ) return ;\\n        makestack(root->right,s);\\n        s.push(root);\\n        makestack(root->left,s);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode *mainroot=NULL;\\n    TreeNode *prev=NULL;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        inorder(root);\\n        return mainroot;\\n    }\\n    \\n    void inorder(TreeNode* root){\\n        \\n        if(!root) return ;\\n        inorder(root->left);\\n\\t\\t//mainroot is the head of the new binary tree(leftmost node) \\n        if(!mainroot){\\n            mainroot=root;\\n            prev=root;\\n        }\\n        else {\\n\\t\\t//prev is the node traversed before current node \\n            prev->right=root;\\n\\t\\t//update prev for next traversal \\n            prev=root;\\n        }\\n        root->left=NULL;\\n        inorder(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956173,
                "title": "c-easy-soln-using-parent-pointer-recursive-inorder-traversal",
                "content": "```\\nTreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *newRoot, *parent = nullptr;\\n        constructTree(root, &parent, &newRoot);\\n        parent->left = nullptr;/*Now parent have the last node.. so we make its left as null to avoid loop*/\\n        \\n        return newRoot;\\n    }\\n    /* This fn will do inorder traversal and update the nodes using parent pointer*/\\n    void constructTree(TreeNode* root, TreeNode** parent, TreeNode** newRoot) {\\n        if(root == nullptr) return;\\n        constructTree(root->left, parent, newRoot);///\\n        \\n        if(*parent != nullptr) { /* parent will have the just prev node in the inorder traversal\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t*so its right should point to currNode.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t*/\\n            (*parent)->right = root;\\n            (*parent)->left  = nullptr;\\n        }\\n        else /* If parent is null then this is the new root */\\n            *newRoot = root;\\n        *parent = root;\\n        \\n        constructTree(root->right, parent, newRoot);///\\n    }\\n```\\n**Upvote if u liked** :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *newRoot, *parent = nullptr;\\n        constructTree(root, &parent, &newRoot);\\n        parent->left = nullptr;/*Now parent have the last node.. so we make its left as null to avoid loop*/\\n        \\n        return newRoot;\\n    }\\n    /* This fn will do inorder traversal and update the nodes using parent pointer*/\\n    void constructTree(TreeNode* root, TreeNode** parent, TreeNode** newRoot) {\\n        if(root == nullptr) return;\\n        constructTree(root->left, parent, newRoot);///\\n        \\n        if(*parent != nullptr) { /* parent will have the just prev node in the inorder traversal\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t*so its right should point to currNode.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t*/\\n            (*parent)->right = root;\\n            (*parent)->left  = nullptr;\\n        }\\n        else /* If parent is null then this is the new root */\\n            *newRoot = root;\\n        *parent = root;\\n        \\n        constructTree(root->right, parent, newRoot);///\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1956113,
                "title": "inorder-traversal-c-with-and-without-extra-array",
                "content": "**APPROACH: 1 (USING EXTRA ARRAY)**\\n* Traverse the tree in inorder fashion, fill the array bucket.\\n* Inorder gives the sorted order.\\n* Create a new tree and Return its root.\\n\\n```\\n void inorder(TreeNode*root,vector<int>&in)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inorder(root->left,in);\\n        in.push_back(root->val);\\n        inorder(root->right,in);\\n        return;\\n    } \\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        \\n        vector<int>in;\\n        inorder(root,in);\\n        TreeNode*curr=new TreeNode(in[0]);\\n        TreeNode*ans=curr;\\n        curr->left=NULL;\\n        for(int i=1;i<in.size();i++)\\n        {\\n           \\n            TreeNode*n=new TreeNode(in[i]);\\n            curr->right=n;\\n            curr->left=NULL;\\n            curr=curr->right;\\n        }\\n        return ans;\\n\\n        \\n    }\\n```\\n\\n**\\t**APPROACH 2: (WITHOUR ARRAY ONE TRAVERSAL)****\\n* Take a ans variable with dummy value which will move as current node of required tree.\\n* take a another res variable to store the root address of ans.\\n* Traverse the tree in inorderer fashion and attach the root->val to right of ans (ans->right)  and left equal to null.\\n* after completing return the right node of res  variable. (as first one is dummy node).\\n\\n\\n```\\n\\n    TreeNode* ans=new TreeNode(0);\\n    TreeNode* res=ans;\\n    \\n    void helper(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        helper(root->left);\\n        TreeNode*newt=new TreeNode(root->val);\\n        ans->right=newt;\\n        ans->left=NULL;\\n        ans=ans->right;\\n        helper(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        helper(root);\\n        return res->right;\\n    }\\n\\t```\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n void inorder(TreeNode*root,vector<int>&in)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inorder(root->left,in);\\n        in.push_back(root->val);\\n        inorder(root->right,in);\\n        return;\\n    } \\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        \\n        vector<int>in;\\n        inorder(root,in);\\n        TreeNode*curr=new TreeNode(in[0]);\\n        TreeNode*ans=curr;\\n        curr->left=NULL;\\n        for(int i=1;i<in.size();i++)\\n        {\\n           \\n            TreeNode*n=new TreeNode(in[i]);\\n            curr->right=n;\\n            curr->left=NULL;\\n            curr=curr->right;\\n        }\\n        return ans;\\n\\n        \\n    }\\n```\n```\\n\\n    TreeNode* ans=new TreeNode(0);\\n    TreeNode* res=ans;\\n    \\n    void helper(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        helper(root->left);\\n        TreeNode*newt=new TreeNode(root->val);\\n        ans->right=newt;\\n        ans->left=NULL;\\n        ans=ans->right;\\n        helper(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        helper(root);\\n        return res->right;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1956015,
                "title": "inorder-solution",
                "content": "First of all, we should notice that it follows Inorder traversal.\\nDeclare a global node variable, so that we may access throughout our program.\\nWe do our Inorder traversal as follow:-\\nvoid Inorder(root){\\n\\tif(root == NULL)\\n\\t\\t\\treturn;\\n\\t//we do recursive call upto leftmost node\\n\\tInorder(root->left)\\n\\t**//ab hmko process krna hai....**\\n\\t// chlo suru krte hai\\n    Inorder(root-> right)\\n}\\nyrr chl ab **process** krte hai..\\nJb recursively hm leftmost root pe pahuchte hai toh ...first make left of that root to **NULL**\\ni.e **root->left = NULL:**\\nab jo hmne global node bna rkha tha uske right me this root assign kr denge.\\ni.e **x->right = NULL;**\\nand then make sure ab uska right assign krdo..\\ni.e **x = x->right;**\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode *f;\\n    void inorder(TreeNode *root){\\n        if(root == NULL)\\n                return;\\n        inorder(root->left);\\n        root->left = NULL;\\n        f -> right = root;\\n        f = f->right;\\n        inorder(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *temp = new TreeNode(0);\\n        f = temp;\\n        // temp = root;\\n        inorder(root);\\n        return temp->right;\\n        \\n    }\\n};\\n```\\n\\nDo upvote if u understand.",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *f;\\n    void inorder(TreeNode *root){\\n        if(root == NULL)\\n                return;\\n        inorder(root->left);\\n        root->left = NULL;\\n        f -> right = root;\\n        f = f->right;\\n        inorder(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *temp = new TreeNode(0);\\n        f = temp;\\n        // temp = root;\\n        inorder(root);\\n        return temp->right;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955997,
                "title": "c-very-easy-to-understand-inorder-traversal",
                "content": "The idea is that we collect all node\\'s value in a vector in inorder.and make a new tree and return its root .\\n```\\nvoid inorder(TreeNode*root,vector<int>&v){\\n        if(!root) return ; \\n        if(root ->left) inorder(root ->left ,v) ;\\n        if(root) v.push_back(root -> val) ;\\n        if(root ->right)  inorder(root ->right,v) ;\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root == nullptr) return root ;\\n        vector<int> v ;\\n        inorder(root ,v);\\n        TreeNode *head = new TreeNode(v[0]);\\n        TreeNode * temp = head;\\n        for(int i=1;i<v.size();i++){\\n            temp->right = new TreeNode(v[i]);\\n            temp = temp->right;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid inorder(TreeNode*root,vector<int>&v){\\n        if(!root) return ; \\n        if(root ->left) inorder(root ->left ,v) ;\\n        if(root) v.push_back(root -> val) ;\\n        if(root ->right)  inorder(root ->right,v) ;\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root == nullptr) return root ;\\n        vector<int> v ;\\n        inorder(root ,v);\\n        TreeNode *head = new TreeNode(v[0]);\\n        TreeNode * temp = head;\\n        for(int i=1;i<v.size();i++){\\n            temp->right = new TreeNode(v[i]);\\n            temp = temp->right;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955975,
                "title": "runtime-0-ms-faster-than-100-00-of-c",
                "content": "```\\nTreeNode* ans = nullptr;\\nTreeNode* p = nullptr;\\nvoid solve(TreeNode* root){\\n\\tif(root==nullptr) return;\\n\\tincreasingBST(root->left);\\n\\tif(ans==nullptr){\\n\\t\\tans = new TreeNode(root->val);\\n\\t\\tp=ans;\\n\\t}\\n\\telse{\\n\\t\\tp->right = new TreeNode(root->val);\\n\\t\\tp=p->right;\\n\\t}\\n\\tcout<<root->val<<\" \";\\n\\tincreasingBST(root->right);\\n}\\nTreeNode* increasingBST(TreeNode* root) {\\n\\tsolve(root);\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nTreeNode* ans = nullptr;\\nTreeNode* p = nullptr;\\nvoid solve(TreeNode* root){\\n\\tif(root==nullptr) return;\\n\\tincreasingBST(root->left);\\n\\tif(ans==nullptr){\\n\\t\\tans = new TreeNode(root->val);\\n\\t\\tp=ans;\\n\\t}\\n\\telse{\\n\\t\\tp->right = new TreeNode(root->val);\\n\\t\\tp=p->right;\\n\\t}\\n\\tcout<<root->val<<\" \";\\n\\tincreasingBST(root->right);\\n}\\nTreeNode* increasingBST(TreeNode* root) {\\n\\tsolve(root);\\n\\treturn ans;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1955897,
                "title": "python-recursive-iterative-stack-solutions-template-explained-similar-questions",
                "content": "My first thought regarding this problem is obviously the keyword `inorder`. This question asks us to convert the tree as a single linked-list-like structure.\\n\\nThis made me immediately thinking about the question that facebook used to ask during phone interviews: **0426.\\xA0Convert Binary Search Tree to Sorted Doubly Linked List** \\nWe use the `head`, `prev` pointer to track the process and easily re-construct the tree **in place** as a different structure: linked-list, which is almost the same as this question.\\n\\nSo in this question we also need to return the root of the new tree, which could be treated as the head of the linked-list.\\nBoth those two questions share similar structures after you find the similarity between them. \\n\\nThe only difference is that in this question, we should make sure it\\'s not a doubly-linked list and cannot have circle. Therefore, everytime we are dealing with the current node, we should: \\n* make sure `node.left == None`.\\n* When we are out of the loop and prev is pointing to the last node, we make sure to call `prev.left == None` again.\\n* For iterative and recursive solutions, making sure you have your own template to do both. It\\'s good to know both approaches and then you could easily refractor one to the other. I quote the \"dealing with current node part\" for both approaches so it\\'s easy to see the template. Hope this is helpful.\\n\\n**Iterative** - \\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        # prev, curr\\n        if not root:\\n            return\\n        \\n        head, prev = None, None\\n        \\n        stack = []\\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            \\n\\t\\t\\t# deal with current node\\n            if head == None:\\n                head = root\\n                head.left = None\\n            \\n            else:\\n                prev.left = None\\n                prev.right = root\\n            \\n            prev = root          \\n\\t\\t\\t# end of dealing with current node\\t\\t\\t\\n\\t\\t\\t\\n            root = root.right\\n        \\n        prev.left = None\\n        \\n        return head\\n```\\n\\n**Recursive** - \\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        # prev, curr\\n        if not root:\\n            return\\n        \\n        head, prev = None, None\\n        \\n        def inorder(node):\\n            nonlocal head, prev\\n            \\n            if not node:\\n                return\\n            \\n            inorder(node.left)\\n            \\n            # dealing with current node\\n            if head == None:\\n                head = node\\n            \\n            else:\\n                prev.left = None\\n                prev.right = node\\n            \\n            prev = node\\n            # end of dealing with current node\\n            \\n            inorder(node.right)\\n        \\n        inorder(root)\\n        \\n        prev.left = None\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        # prev, curr\\n        if not root:\\n            return\\n        \\n        head, prev = None, None\\n        \\n        stack = []\\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            \\n\\t\\t\\t# deal with current node\\n            if head == None:\\n                head = root\\n                head.left = None\\n            \\n            else:\\n                prev.left = None\\n                prev.right = root\\n            \\n            prev = root          \\n\\t\\t\\t# end of dealing with current node\\t\\t\\t\\n\\t\\t\\t\\n            root = root.right\\n        \\n        prev.left = None\\n        \\n        return head\\n```\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        # prev, curr\\n        if not root:\\n            return\\n        \\n        head, prev = None, None\\n        \\n        def inorder(node):\\n            nonlocal head, prev\\n            \\n            if not node:\\n                return\\n            \\n            inorder(node.left)\\n            \\n            # dealing with current node\\n            if head == None:\\n                head = node\\n            \\n            else:\\n                prev.left = None\\n                prev.right = node\\n            \\n            prev = node\\n            # end of dealing with current node\\n            \\n            inorder(node.right)\\n        \\n        inorder(root)\\n        \\n        prev.left = None\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955876,
                "title": "inorder-c-solution",
                "content": "```\\n void inorder(TreeNode*root,vector<int>&v){\\n        if(root==NULL){\\n            return;\\n        }\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL){\\n            return root;\\n        }\\n        vector<int>v;\\n        inorder(root,v);\\n       \\n        TreeNode* head= new TreeNode(v[0]);\\n        TreeNode*temp=head;\\n        for(int i=1;i<v.size();i++){\\n            temp->right=new TreeNode(v[i]);\\n            temp=temp->right;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n void inorder(TreeNode*root,vector<int>&v){\\n        if(root==NULL){\\n            return;\\n        }\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL){\\n            return root;\\n        }\\n        vector<int>v;\\n        inorder(root,v);\\n       \\n        TreeNode* head= new TreeNode(v[0]);\\n        TreeNode*temp=head;\\n        for(int i=1;i<v.size();i++){\\n            temp->right=new TreeNode(v[i]);\\n            temp=temp->right;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955671,
                "title": "cpp-2-sol-runtime-0-ms-faster-than-100-00",
                "content": "**Vector  approch**\\nclass Solution {\\npublic:\\n\\n    vector<int>v;\\n    void inorder(TreeNode* root){\\n        if(root==NULL)return ;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n         inorder(root);\\n        TreeNode *head = new TreeNode();\\n        TreeNode *it=head;\\n        for(auto x:v){\\n            it=it->right=new TreeNode(x);\\n        }\\n        return head->right;\\n    }\\n};\\n\\n**Inorder **\\nclass Solution {\\npublic:\\n\\n    TreeNode *head = new TreeNode();\\n    TreeNode *it=head;\\n    void inorder(TreeNode* root){\\n        if(root==NULL)return ;\\n        inorder(root->left);\\n        it->right = new TreeNode(root->val);\\n        it=it->right;\\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n         inorder(root);\\n        return head->right;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int>v;\\n    void inorder(TreeNode* root){\\n        if(root==NULL)return ;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1955584,
                "title": "increasing-order-search-tree-few-line",
                "content": "```\\nTreeNode *cur=new TreeNode();\\n    void ans(TreeNode *root){\\n        if(root==nullptr)return ;\\n        ans(root->left);\\n        auto newcur=new TreeNode();\\n        newcur->val=root->val;\\n        cur->right=newcur;\\n        cur=cur->right;\\n        ans(root->right);\\n        \\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        auto n = cur;\\n        ans(root);\\n        return n->right;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nTreeNode *cur=new TreeNode();\\n    void ans(TreeNode *root){\\n        if(root==nullptr)return ;\\n        ans(root->left);\\n        auto newcur=new TreeNode();\\n        newcur->val=root->val;\\n        cur->right=newcur;\\n        cur=cur->right;\\n        ans(root->right);\\n        \\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        auto n = cur;\\n        ans(root);\\n        return n->right;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1955547,
                "title": "simple-java-solution-100-faster-code",
                "content": "\\'\\'\\'\\n class Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        return helper(root,null);\\n    }\\n    \\n    private TreeNode helper(TreeNode node,TreeNode next){\\n        if(next!=null){\\n            next.left=null;\\n        }\\n        if(node==null){\\n            return next;\\n        }\\n        node.right=helper(node.right,next);\\n        return helper(node.left,node);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        return helper(root,null);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1955051,
                "title": "java-inorder-tc-o-n-100-no-stack",
                "content": "```\\nclass Solution {\\n    TreeNode ret = null;\\n    TreeNode prev = null;\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        if (root == null) return null;\\n        increasingBST(root.left);\\n        \\n        if (ret == null) {\\n            ret = root;\\n            prev = root;\\n        }\\n        else if (prev != null) {\\n            prev.right = new TreeNode(root.val);\\n            prev = prev.right;\\n        }\\n                \\n        increasingBST(root.right);\\n        return ret;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode ret = null;\\n    TreeNode prev = null;\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        if (root == null) return null;\\n        increasingBST(root.left);\\n        \\n        if (ret == null) {\\n            ret = root;\\n            prev = root;\\n        }\\n        else if (prev != null) {\\n            prev.right = new TreeNode(root.val);\\n            prev = prev.right;\\n        }\\n                \\n        increasingBST(root.right);\\n        return ret;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955042,
                "title": "runtime-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void solve(TreeNode* root)\\n    {\\n        if(!root) return;\\n        solve(root->left);\\n        ans.push_back(root->val);\\n        solve(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(!root) return NULL;\\n        solve(root);\\n        TreeNode* n=new TreeNode(ans[0]);\\n        TreeNode* p=n;\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            TreeNode* q=new TreeNode(ans[i]);\\n            p->right=q;\\n            p=q;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void solve(TreeNode* root)\\n    {\\n        if(!root) return;\\n        solve(root->left);\\n        ans.push_back(root->val);\\n        solve(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(!root) return NULL;\\n        solve(root);\\n        TreeNode* n=new TreeNode(ans[0]);\\n        TreeNode* p=n;\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            TreeNode* q=new TreeNode(ans[i]);\\n            p->right=q;\\n            p=q;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752348,
                "title": "c-solution-using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void solve(TreeNode* root){ // finding inorder //\\n        if(!root)return;\\n        solve(root->left);\\n        ans.push_back(root->val);\\n        solve(root->right);\\n    }\\n    \\n    TreeNode* tree(vector<int> &ans,int i,int &n){ // creating a tree with values present in vector\\n        if(i==n)return NULL; \\n        TreeNode* root = new TreeNode(ans[i]);\\n        root->left = nullptr;\\n        root->right = tree(ans,i+1,n);\\n        return root;\\n        \\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        solve(root);\\n        int n = ans.size();\\n        return tree(ans,0,n);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> ans;\\n    void solve(TreeNode* root){ // finding inorder //\\n        if(!root)return;\\n        solve(root->left);\\n        ans.push_back(root->val);\\n        solve(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1744038,
                "title": "beginner-friendly-java-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode collect;\\n    public TreeNode increasingBST(TreeNode root) {\\n        TreeNode res = new TreeNode();\\n        collect = res;\\n        BST(root);\\n        return res.right;\\n    }\\n    \\n    private void BST(TreeNode root){\\n        if(root == null)    return;\\n        BST(root.left);\\n        collect.right = new TreeNode(root.val);\\n        collect = collect.right;\\n        BST(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode collect;\\n    public TreeNode increasingBST(TreeNode root) {\\n        TreeNode res = new TreeNode();\\n        collect = res;\\n        BST(root);\\n        return res.right;\\n    }\\n    \\n    private void BST(TreeNode root){\\n        if(root == null)    return;\\n        BST(root.left);\\n        collect.right = new TreeNode(root.val);\\n        collect = collect.right;\\n        BST(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735569,
                "title": "another-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var array = [Int]()\\n    \\n    func increasingBST(_ root: TreeNode?) -> TreeNode? {\\n        helper(root)\\n        \\n        let first = TreeNode(0)\\n        var current: TreeNode? = first\\n        \\n        for val in array {\\n            current?.right = TreeNode(val)\\n            current = current?.right\\n        }\\n        \\n        return first.right\\n    }\\n    \\n    func helper(_ node: TreeNode?) {\\n        guard let node = node else { return }\\n        \\n        helper(node.left)\\n        array.append(node.val)\\n        helper(node.right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var array = [Int]()\\n    \\n    func increasingBST(_ root: TreeNode?) -> TreeNode? {\\n        helper(root)\\n        \\n        let first = TreeNode(0)\\n        var current: TreeNode? = first\\n        \\n        for val in array {\\n            current?.right = TreeNode(val)\\n            current = current?.right\\n        }\\n        \\n        return first.right\\n    }\\n    \\n    func helper(_ node: TreeNode?) {\\n        guard let node = node else { return }\\n        \\n        helper(node.left)\\n        array.append(node.val)\\n        helper(node.right)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731515,
                "title": "c-simple-solution-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    TreeNode *prev = NULL, *head = NULL;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        if(root == NULL)\\n            return root;\\n        \\n        increasingBST(root->left);\\n        \\n        if(prev == NULL)\\n            head = root;\\n        else\\n        {\\n            root->left = NULL;\\n            prev->right = root;\\n        }\\n        prev = root;\\n        \\n        increasingBST(root->right);\\n        \\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode *prev = NULL, *head = NULL;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        if(root == NULL)\\n            return root;\\n        \\n        increasingBST(root->left);\\n        \\n        if(prev == NULL)\\n            head = root;\\n        else\\n        {\\n            root->left = NULL;\\n            prev->right = root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1593940,
                "title": "java-uzbcoder-100-understandable",
                "content": "```\\nclass Solution {\\n   TreeNode cur;\\n    public TreeNode increasingBST(TreeNode root) {   \\n         TreeNode result = new TreeNode(0); //new tree to return as result\\n         cur = result;            //we pass throw tree and tree will not change(go throw tree with reference) \\n        inorder(root, result);//inorder traversal\\n        return result.right;\\n    }\\n    public void insert(TreeNode result,int v){            \\n            cur.right = new TreeNode(v);\\n            cur.right.val=v; \\n            cur = cur.right;       \\n    }\\n    public void inorder(TreeNode node, TreeNode result) {\\n        if (node == null) return;\\n        inorder(node.left, result);\\n        insert(result, node.val);\\n        inorder(node.right, result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   TreeNode cur;\\n    public TreeNode increasingBST(TreeNode root) {   \\n         TreeNode result = new TreeNode(0); //new tree to return as result\\n         cur = result;            //we pass throw tree and tree will not change(go throw tree with reference) \\n        inorder(root, result);//inorder traversal\\n        return result.right;\\n    }\\n    public void insert(TreeNode result,int v){            \\n            cur.right = new TreeNode(v);\\n            cur.right.val=v; \\n            cur = cur.right;       \\n    }\\n    public void inorder(TreeNode node, TreeNode result) {\\n        if (node == null) return;\\n        inorder(node.left, result);\\n        insert(result, node.val);\\n        inorder(node.right, result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490540,
                "title": "easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    List<Integer> temp=new ArrayList<>();\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        TreeNode node=new TreeNode(0);\\n        TreeNode curr=node;\\n        for(Integer x:temp){\\n            curr.right=new TreeNode(x);\\n            curr=curr.right;\\n        }\\n        return node.right;\\n    }\\n    public void inorder(TreeNode root)\\n    {\\n        if(root!=null)\\n        {\\n            inorder(root.left);\\n            temp.add(root.val);\\n            inorder(root.right);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<Integer> temp=new ArrayList<>();\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        TreeNode node=new TreeNode(0);\\n        TreeNode curr=node;\\n        for(Integer x:temp){\\n            curr.right=new TreeNode(x);\\n            curr=curr.right;\\n        }\\n        return node.right;\\n    }\\n    public void inorder(TreeNode root)\\n    {\\n        if(root!=null)\\n        {\\n            inorder(root.left);\\n            temp.add(root.val);\\n            inorder(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439968,
                "title": "basic-solution-python-recursion",
                "content": "```\\ndef inorder(root):\\n\\tif root==None:\\n\\t\\treturn\\n\\telse:\\n\\t\\tinorder(root.left)\\n\\t\\tarr.append(root.val)\\n\\t\\tinorder(root.right)\\ndef increasing(arr,root2,start):\\n\\tflag=0\\n\\tfor i in range(0,len(arr)):\\n\\t\\tele=TreeNode(arr[i])\\n\\t\\tele.left=None\\n\\t\\tele.right=None\\n\\t\\tif flag==0:\\n\\t\\t\\troot2=ele\\n\\t\\t\\tstart=ele\\n\\t\\t\\tflag=1\\n\\t\\telse:\\n\\t\\t\\tstart.right=ele\\n\\t\\t\\tstart=start.right\\n\\treturn root2\\narr=[]\\ninorder(root)\\nroot2=None\\nstart=None\\nroot=increasing(arr,root2,start)\\nreturn root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef inorder(root):\\n\\tif root==None:\\n\\t\\treturn\\n\\telse:\\n\\t\\tinorder(root.left)\\n\\t\\tarr.append(root.val)\\n\\t\\tinorder(root.right)\\ndef increasing(arr,root2,start):\\n\\tflag=0\\n\\tfor i in range(0,len(arr)):\\n\\t\\tele=TreeNode(arr[i])\\n\\t\\tele.left=None\\n\\t\\tele.right=None\\n\\t\\tif flag==0:\\n\\t\\t\\troot2=ele\\n\\t\\t\\tstart=ele\\n\\t\\t\\tflag=1\\n\\t\\telse:\\n\\t\\t\\tstart.right=ele\\n\\t\\t\\tstart=start.right\\n\\treturn root2\\narr=[]\\ninorder(root)\\nroot2=None\\nstart=None\\nroot=increasing(arr,root2,start)\\nreturn root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1397864,
                "title": "to-rearrange-the-tree-and-not-to-create-a-new-tree",
                "content": "The question is to rearrange the tree, and not to create a new tree. The optimized (space and time) solution.\\nP.S: Please don\\'t make it ugly with global variables\\n\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        TreeNode leftTree = increasingBST(root.left);\\n        if (leftTree != null) {\\n            TreeNode end = leftTree;\\n            while (end.right != null) {\\n                end = end.right;\\n            }\\n            end.right = root;\\n        } else {\\n            leftTree = root;\\n        }\\n        TreeNode rightTree = increasingBST(root.right);\\n        root.right = rightTree;\\n        root.left = null;\\n        return leftTree;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        TreeNode leftTree = increasingBST(root.left);\\n        if (leftTree != null) {\\n            TreeNode end = leftTree;\\n            while (end.right != null) {\\n                end = end.right;\\n            }\\n            end.right = root;\\n        } else {\\n            leftTree = root;\\n        }\\n        TreeNode rightTree = increasingBST(root.right);\\n        root.right = rightTree;\\n        root.left = null;\\n        return leftTree;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304019,
                "title": "c-self-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void inorder(TreeNode* root){\\n        if (root != NULL)\\n        {\\n            inorder(root->left);\\n            v.push_back(root->val);\\n            inorder(root->right);\\n       }\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        inorder(root);\\n        TreeNode *t=new TreeNode(0);\\n        TreeNode *q=t;\\n        for(int i=0;i<v.size();i++){\\n            t->right=new TreeNode(v[i],NULL,NULL);\\n            t=t->right;\\n        }\\n        return q->right;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void inorder(TreeNode* root){\\n        if (root != NULL)\\n        {\\n            inorder(root->left);\\n            v.push_back(root->val);\\n            inorder(root->right);\\n       }\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        inorder(root);\\n        TreeNode *t=new TreeNode(0);\\n        TreeNode *q=t;\\n        for(int i=0;i<v.size();i++){\\n            t->right=new TreeNode(v[i],NULL,NULL);\\n            t=t->right;\\n        }\\n        return q->right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229980,
                "title": "c-in-place-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL) return NULL;\\n        TreeNode* L=increasingBST(root->left);\\n        TreeNode* R=increasingBST(root->right);\\n        root->left=NULL;\\n        root->right=R;\\n        TreeNode *start=root,*end=root;\\n        if(L!=NULL){\\n            start=L,end=L;\\n            while(end->right!=NULL) end=end->right;\\n            end->right=root;\\n        }\\n        return start;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL) return NULL;\\n        TreeNode* L=increasingBST(root->left);\\n        TreeNode* R=increasingBST(root->right);\\n        root->left=NULL;\\n        root->right=R;\\n        TreeNode *start=root,*end=root;\\n        if(L!=NULL){\\n            start=L,end=L;\\n            while(end->right!=NULL) end=end->right;\\n            end->right=root;\\n        }\\n        return start;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218515,
                "title": "scala-immutable-recursion",
                "content": "\\n```scala\\nobject Solution {\\n\\n  def increasingBST(root: TreeNode): TreeNode = {\\n    def traverse(r: TreeNode, acc: List[Int] = Nil): List[Int] =\\n      if (r != null) traverse(r.left, acc) ++ List(r.value) ++ traverse(r.right, acc)\\n      else acc\\n\\n    def convert(xs: List[Int]): TreeNode = xs match {\\n      case Nil        => null\\n      case head :: tl => new TreeNode(head, null, convert(tl))\\n    }\\n\\n    convert(traverse(root))\\n  }\\n}\\n```\\n\\nNot as efficient in terms of space since we construct a List, but I think it\\'s quite readable.",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n\\n  def increasingBST(root: TreeNode): TreeNode = {\\n    def traverse(r: TreeNode, acc: List[Int] = Nil): List[Int] =\\n      if (r != null) traverse(r.left, acc) ++ List(r.value) ++ traverse(r.right, acc)\\n      else acc\\n\\n    def convert(xs: List[Int]): TreeNode = xs match {\\n      case Nil        => null\\n      case head :: tl => new TreeNode(head, null, convert(tl))\\n    }\\n\\n    convert(traverse(root))\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1212169,
                "title": "c-0ms-solution-with-intuition",
                "content": "## Intuition\\nThe question is to return the tree in inorder, with every node having null as their left child and only the right child. To return the correct order, we will need to return the leftmost node of the left subtree of the root, and modify the children, so that the right child points to the next node in the order.\\n\\nFor any node, there can be four cases:\\n\\n**1. It is a leaf node:**\\nIn this case, we have to link its right pointer to either its parent (if it was a left child) or to its grandparent (if it was a right child). For this purpose, we have a pointer prev that points to the required node to be assigned as the right child of the current node.\\n\\n**2. It only has left child:**\\nIn this case, the current node will become the right child of it\\'s left child, and the parent of the node pointed to by prev. We return the leftmost node in root\\'s left subtree as the answer.\\n\\n**3.  It only has right child:**\\nIn this case, we just call the function recursively on the right subtree with prev as root\\'s value of prev, so that it gets its grandparent (if root was a left child), or great-grandfather (if root was a right child), and set the result as the right child of the current node.\\n\\n**4. It has both left and right children:**\\nIn this case, we combine both the previous cases, we recurse on the left subtree, get the leftmost node of the left subtree returned from it (which will be returned as the new root), and recurse on the right subtree with prev as the second parameter, and set its result to be the right child of the current node.\\n\\nTry dry-running it on some test-cases if you are finding it difficult to understand.\\n<br> \\n\\n## Code\\t\\n```\\nTreeNode *inorder(TreeNode *root, TreeNode *prev) {\\n\\tif(!root) return root;\\n\\tif(!root->left && !root->right) {\\n\\t\\troot->right = prev;\\n\\t\\treturn root;\\n\\t}\\n\\telse if(!root->left) {\\n\\t\\tTreeNode *rightLeftmost = inorder(root->right, prev);\\n\\t\\troot->right = rightLeftmost;\\n\\t\\troot->left = nullptr;\\n\\t\\treturn root;\\n\\t}\\n\\telse if(!root->right) {\\n\\t\\tTreeNode *leftLeftmost = inorder(root->left, root);\\n\\t\\troot->right = prev;\\n\\t\\troot->left = nullptr;\\n\\t\\treturn leftLeftmost;\\n\\t}\\n\\telse {\\n\\t\\tTreeNode *leftLeftmost = inorder(root->left, root);\\n\\t\\tTreeNode *rightLeftmost = inorder(root->right, prev);\\n\\t\\troot->right = rightLeftmost;\\n\\t\\troot->left = nullptr;\\n\\t\\treturn leftLeftmost;\\n\\t}\\n}\\n\\nTreeNode* increasingBST(TreeNode* root) {\\n\\tTreeNode *newRoot = inorder(root, nullptr);\\n\\treturn newRoot;\\n}\\n```\\n\\n<br>\\n\\n## Complexity\\n\\n**Time: O(n)** as we traverse the whole tree just once.\\n**Space: O(n)** again, as we will call the function once for each node, so stack space is O(n), other than that the space used is O(1).\\n\\n\\n## Conclusion\\nIn conclusion, this wasn\\'t such an easy problem, but not a hard one either. It should have been a medium problem.\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode *inorder(TreeNode *root, TreeNode *prev) {\\n\\tif(!root) return root;\\n\\tif(!root->left && !root->right) {\\n\\t\\troot->right = prev;\\n\\t\\treturn root;\\n\\t}\\n\\telse if(!root->left) {\\n\\t\\tTreeNode *rightLeftmost = inorder(root->right, prev);\\n\\t\\troot->right = rightLeftmost;\\n\\t\\troot->left = nullptr;\\n\\t\\treturn root;\\n\\t}\\n\\telse if(!root->right) {\\n\\t\\tTreeNode *leftLeftmost = inorder(root->left, root);\\n\\t\\troot->right = prev;\\n\\t\\troot->left = nullptr;\\n\\t\\treturn leftLeftmost;\\n\\t}\\n\\telse {\\n\\t\\tTreeNode *leftLeftmost = inorder(root->left, root);\\n\\t\\tTreeNode *rightLeftmost = inorder(root->right, prev);\\n\\t\\troot->right = rightLeftmost;\\n\\t\\troot->left = nullptr;\\n\\t\\treturn leftLeftmost;\\n\\t}\\n}\\n\\nTreeNode* increasingBST(TreeNode* root) {\\n\\tTreeNode *newRoot = inorder(root, nullptr);\\n\\treturn newRoot;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174964,
                "title": "rust",
                "content": "```rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn increasing_bst(mut root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        let mut stack = Vec::new();\\n        let mut dm = Rc::new(RefCell::new(TreeNode::new(0)));\\n        let mut cur = Rc::clone(&dm);\\n\\n        while !stack.is_empty() || root.is_some() {\\n            while let Some(node) = root {\\n                root = node.borrow_mut().left.take();\\n                stack.push(node);\\n            }\\n\\n            if let Some(node) = stack.pop() {\\n                root = node.borrow_mut().right.take();\\n                node.borrow_mut().left = None;\\n                cur.borrow_mut().right = Some(Rc::clone(&node));\\n                cur = node;\\n            }\\n        }\\n\\n        let head = dm.borrow_mut().right.take();\\n        head\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn increasing_bst(mut root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        let mut stack = Vec::new();\\n        let mut dm = Rc::new(RefCell::new(TreeNode::new(0)));\\n        let mut cur = Rc::clone(&dm);\\n\\n        while !stack.is_empty() || root.is_some() {\\n            while let Some(node) = root {\\n                root = node.borrow_mut().left.take();\\n                stack.push(node);\\n            }\\n\\n            if let Some(node) = stack.pop() {\\n                root = node.borrow_mut().right.take();\\n                node.borrow_mut().left = None;\\n                cur.borrow_mut().right = Some(Rc::clone(&node));\\n                cur = node;\\n            }\\n        }\\n\\n        let head = dm.borrow_mut().right.take();\\n        head\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1170797,
                "title": "java-0ms-inorder-traversal",
                "content": "```\\nclass Solution {\\n    TreeNode prev,first;\\n    public Solution(){\\n        prev=new TreeNode(-1,null,null);\\n        first=null;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root!=null)\\n        {\\n            inorder(root.left);           \\n            prev.right=new TreeNode(root.val,null,null);\\n            prev=prev.right;\\n            first=(first==null)?prev:first;\\n            inorder(root.right);\\n        }\\n    }\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode prev,first;\\n    public Solution(){\\n        prev=new TreeNode(-1,null,null);\\n        first=null;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root!=null)\\n        {\\n            inorder(root.left);           \\n            prev.right=new TreeNode(root.val,null,null);\\n            prev=prev.right;\\n            first=(first==null)?prev:first;\\n            inorder(root.right);\\n        }\\n    }\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113461,
                "title": "java-solution-using-list-and-iterative-pointer-relinking",
                "content": "**Using List**\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        List<TreeNode> list = new ArrayList<>();\\n        helper(root, list);\\n        \\n        TreeNode head = new TreeNode(-1);\\n        TreeNode dummy = head;\\n        for (TreeNode node : list){\\n            dummy.right = node;\\n            dummy = dummy.right;\\n            dummy.left = null;\\n        }\\n        return head.right;\\n    }\\n    \\n    public void helper(TreeNode node, List<TreeNode> list){\\n        if (node == null) return;\\n        helper(node.left, list);\\n        list.add(node);\\n        helper(node.right, list);\\n    }\\n}\\n```\\n\\n**Iterative Solution**\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n        if (root == null)        return null;\\n        \\n        LinkedList<TreeNode> stack = new LinkedList<>();\\n        TreeNode node = root;\\n        TreeNode prevNode = null;\\n        TreeNode head = null;\\n        \\n        while (!stack.isEmpty() || node != null){\\n            // go all the way to the left\\n            \\n            while(node != null){\\n                stack.push(node);\\n                node = node.left;\\n            }\\n            \\n            // get the current node\\n            // you can print or add to result for inorder\\n            node = stack.pop();\\n               \\n            if (head == null) head = node;\\n            if (prevNode != null){\\n                prevNode.right = node;\\n                node.left = null;\\n            }\\n            prevNode = node;\\n            // make the node point to the right\\n            node = node.right;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        List<TreeNode> list = new ArrayList<>();\\n        helper(root, list);\\n        \\n        TreeNode head = new TreeNode(-1);\\n        TreeNode dummy = head;\\n        for (TreeNode node : list){\\n            dummy.right = node;\\n            dummy = dummy.right;\\n            dummy.left = null;\\n        }\\n        return head.right;\\n    }\\n    \\n    public void helper(TreeNode node, List<TreeNode> list){\\n        if (node == null) return;\\n        helper(node.left, list);\\n        list.add(node);\\n        helper(node.right, list);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n        if (root == null)        return null;\\n        \\n        LinkedList<TreeNode> stack = new LinkedList<>();\\n        TreeNode node = root;\\n        TreeNode prevNode = null;\\n        TreeNode head = null;\\n        \\n        while (!stack.isEmpty() || node != null){\\n            // go all the way to the left\\n            \\n            while(node != null){\\n                stack.push(node);\\n                node = node.left;\\n            }\\n            \\n            // get the current node\\n            // you can print or add to result for inorder\\n            node = stack.pop();\\n               \\n            if (head == null) head = node;\\n            if (prevNode != null){\\n                prevNode.right = node;\\n                node.left = null;\\n            }\\n            prevNode = node;\\n            // make the node point to the right\\n            node = node.right;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018084,
                "title": "simple-c-without-creating-new-node",
                "content": "```\\nvoid inorder(TreeNode *root,TreeNode *&prev)\\n{\\n\\tif(root==NULL)\\n\\t\\treturn ;\\n\\tinorder(root->left,prev);\\n\\tif(prev!=NULL)\\n\\t{\\n\\t\\tprev->right=root;\\n\\t\\troot->left=NULL;\\n\\t}\\n\\tprev=root;\\n\\tinorder(root->right,prev);\\n}\\nTreeNode* increasingBST(TreeNode* root) {\\n\\tTreeNode *prev=NULL,*node=root;\\n\\twhile(node->left!=NULL)\\n\\t\\tnode=node->left;\\n\\tinorder(root,prev);\\n\\treturn node;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid inorder(TreeNode *root,TreeNode *&prev)\\n{\\n\\tif(root==NULL)\\n\\t\\treturn ;\\n\\tinorder(root->left,prev);\\n\\tif(prev!=NULL)\\n\\t{\\n\\t\\tprev->right=root;\\n\\t\\troot->left=NULL;\\n\\t}\\n\\tprev=root;\\n\\tinorder(root->right,prev);\\n}\\nTreeNode* increasingBST(TreeNode* root) {\\n\\tTreeNode *prev=NULL,*node=root;\\n\\twhile(node->left!=NULL)\\n\\t\\tnode=node->left;\\n\\tinorder(root,prev);\\n\\treturn node;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 959065,
                "title": "java-stack-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        Stack<TreeNode> s  = new Stack<>(); \\n        TreeNode res=null;\\n        TreeNode prev = null ;\\n        while(!s.isEmpty() || root!=null){\\n            while(root!=null){\\n                s.push(root); \\n                root = root.left;\\n            }\\n            root = s.pop(); \\n            if(prev ==null) {\\n                prev = root;\\n                res = root; \\n                }\\n            else{\\n                root.left = null ; \\n                prev.right = root; \\n                prev = prev.right; \\n            }\\n            root = root.right; \\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        Stack<TreeNode> s  = new Stack<>(); \\n        TreeNode res=null;\\n        TreeNode prev = null ;\\n        while(!s.isEmpty() || root!=null){\\n            while(root!=null){\\n                s.push(root); \\n                root = root.left;\\n            }\\n            root = s.pop(); \\n            if(prev ==null) {\\n                prev = root;\\n                res = root; \\n                }\\n            else{\\n                root.left = null ; \\n                prev.right = root; \\n                prev = prev.right; \\n            }\\n            root = root.right; \\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959035,
                "title": "0ms-o-n-c-inorder-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, TreeNode* &start)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left,start);\\n        start->right=new TreeNode(root->val);\\n        start=start->right;\\n        inorder(root->right,start);\\n        \\n        \\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* start=new TreeNode(0);\\n        TreeNode* ans=start;\\n        inorder(root,start);\\n        return ans->right;\\n        \\n    }\\n};\\n```\\n*Using pass by reference, the runtime is further reduced.*\\nUpvote if you like the solution.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, TreeNode* &start)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left,start);\\n        start->right=new TreeNode(root->val);\\n        start=start->right;\\n        inorder(root->right,start);\\n        \\n        \\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* start=new TreeNode(0);\\n        TreeNode* ans=start;\\n        inorder(root,start);\\n        return ans->right;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958986,
                "title": "python-3-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=vABwsgqI-_4)\\nhttps://www.youtube.com/watch?v=vABwsgqI-_4\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        if not root:\\n            return None\\n        \\n        dummy = curr = TreeNode()\\n        stack = []\\n        \\n        while stack or root:\\n            \\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            \\n            root = stack.pop()\\n            curr.right = root\\n            \\n            curr = curr.right\\n            root = root.right\\n            \\n            curr.left = None\\n        \\n        return dummy.right\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        if not root:\\n            return None\\n        \\n        dummy = curr = TreeNode()\\n        stack = []\\n        \\n        while stack or root:\\n            \\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            \\n            root = stack.pop()\\n            curr.right = root\\n            \\n            curr = curr.right\\n            root = root.right\\n            \\n            curr.left = None\\n        \\n        return dummy.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958857,
                "title": "java-in-order-traversal-100",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    //dummy goes down the TreeNode\\n    public TreeNode dummy = new TreeNode(0);\\n    public TreeNode increasingBST(TreeNode root) {\\n        //strategy: In Order Traversal\\n        TreeNode answer = dummy;\\n        //traverse each node\\n        helper(root);\\n        return answer.right;\\n    }\\n    public void helper(TreeNode root) {\\n        //not possible\\n        if (root == null) {\\n            return;\\n        }\\n        //first go to the left\\n        helper(root.left);\\n        //set up right and left\\n        dummy.right = new TreeNode(root.val);\\n        dummy.left = null;\\n        //move dummy to the right\\n        dummy = dummy.right;\\n        //traverse right\\n        helper(root.right);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    //dummy goes down the TreeNode\\n    public TreeNode dummy = new TreeNode(0);\\n    public TreeNode increasingBST(TreeNode root) {\\n        //strategy: In Order Traversal\\n        TreeNode answer = dummy;\\n        //traverse each node\\n        helper(root);\\n        return answer.right;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 958809,
                "title": "ruby-o-n",
                "content": "```\\ndef increasing_bst(root, tail = nil)\\n  return tail unless root\\n  \\n  result = increasing_bst(root.left, root)\\n  root.left = nil\\n  root.right = increasing_bst(root.right, tail)\\n  \\n  result\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef increasing_bst(root, tail = nil)\\n  return tail unless root\\n  \\n  result = increasing_bst(root.left, root)\\n  root.left = nil\\n  root.right = increasing_bst(root.right, tail)\\n  \\n  result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 927045,
                "title": "java-inverse-inorder-traversal-100-faster",
                "content": "\\nSince you already might know, an inorder traversal prints elements in an increasing order i.e. `root.left` -> `root` -> `root.right`, the inverse would print in the decreasing order i.e. `root.right` -> `root` -> `root.left`. \\n\\nYou can imagine the output to be a descending order list, with every element pointing to its previous element.\\nSo, all we have to do is bind the previous node to its right and point the left to `null`.\\n\\nBelow is the code.\\n\\n```\\nclass Solution {\\n    \\n    private TreeNode prevNode = null;\\n    \\n    private void inorderTraversal(TreeNode root) {\\n        \\n        if(root != null) {\\n            \\n            inorderTraversal(root.right);\\n\\t\\t\\t\\n            root.right = prevNode;\\n            prevNode = root;\\n\\t\\t\\t\\n            inorderTraversal(root.left);\\n\\t\\t\\t\\n            root.left = null;\\n        }\\n        \\n    }\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        inorderTraversal(root);\\n        return prevNode;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private TreeNode prevNode = null;\\n    \\n    private void inorderTraversal(TreeNode root) {\\n        \\n        if(root != null) {\\n            \\n            inorderTraversal(root.right);\\n\\t\\t\\t\\n            root.right = prevNode;\\n            prevNode = root;\\n\\t\\t\\t\\n            inorderTraversal(root.left);\\n\\t\\t\\t\\n            root.left = null;\\n        }\\n        \\n    }\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        inorderTraversal(root);\\n        return prevNode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914176,
                "title": "c-100-faster-runtime-sadly-at-the-cost-of-some-space",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        vector<int> node_values;\\n        helper(root, node_values);\\n        \\n        TreeNode *def = new TreeNode(0);\\n        TreeNode *res = def;\\n        \\n        for(auto node_val : node_values )\\n        {\\n            res->right = new TreeNode(node_val);\\n            res = res->right;\\n        }\\n        \\n        return def->right;\\n        \\n    }\\n    \\n    void helper(TreeNode *root, vector<int> &temp)\\n    {\\n        if(!root) return;\\n        \\n        helper(root->left, temp);\\n        temp.push_back(root->val);\\n        helper(root->right, temp);\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        vector<int> node_values;\\n        helper(root, node_values);\\n        \\n        TreeNode *def = new TreeNode(0);\\n        TreeNode *res = def;\\n        \\n        for(auto node_val : node_values )\\n        {\\n            res->right = new TreeNode(node_val);\\n            res = res->right;\\n        }\\n        \\n        return def->right;\\n        \\n    }\\n    \\n    void helper(TreeNode *root, vector<int> &temp)\\n    {\\n        if(!root) return;\\n        \\n        helper(root->left, temp);\\n        temp.push_back(root->val);\\n        helper(root->right, temp);\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848267,
                "title": "explan-every-step-easley",
                "content": "# idea is reach  left side until None  and pop one by one node and next reach right side of pop node \\n\\n```\\nif (temp):\\n                stack.append(temp)\\n                temp=temp.left\\n\\n```\\n# this part try to reach left side where low value is available\\n```\\nnode=stack.pop()\\n                if i==0:\\n                    x=root=node\\n                    i+=1\\n\\n```\\n# above section when i reach last left position then required pop the value from stack and make a tree\\n# i==0 means we come here first time and put the value root which i return and with dummy variable for pointing next node\\n```\\n\\nx.right=node\\n                    x=node\\n                    x.left=None\\n                temp=node.right\\n\\n```\\n# when i came here second time we need set the node right side according to questions and next time pop  node attached this node so (x=node) and this most careful thing when youe add pop node then this node come with his left node that reason (x.left=None)\\n\\n# ( temp=node.right) searching right side of pop node \\n\\n```\\n# python code iterative way\\n\\n        if root==None:\\n            return root\\n        stack=[]\\n        x=temp=root\\n        i=0\\n        while(stack or temp):\\n            if (temp):\\n                stack.append(temp)\\n                temp=temp.left\\n            else:\\n                node=stack.pop()\\n                if i==0:\\n                    x=root=node\\n                    i+=1\\n                else:\\n                    x.right=node\\n                    x=node\\n                    x.left=None\\n                temp=node.right\\n        return root\\n            \\n```\\n\\n```\\n# Recursive way\\ndef inorder(node):\\n            if node:\\n                inorder(node.left)\\n                node.left = None\\n                self.cur.right =  node\\n                self.cur = node\\n                inorder(node.right)\\n                \\n        self.cur = ans = TreeNode(None)        \\n        inorder(root)\\n        return ans.right\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nif (temp):\\n                stack.append(temp)\\n                temp=temp.left\\n\\n```\n```\\nnode=stack.pop()\\n                if i==0:\\n                    x=root=node\\n                    i+=1\\n\\n```\n```\\n\\nx.right=node\\n                    x=node\\n                    x.left=None\\n                temp=node.right\\n\\n```\n```\\n# python code iterative way\\n\\n        if root==None:\\n            return root\\n        stack=[]\\n        x=temp=root\\n        i=0\\n        while(stack or temp):\\n            if (temp):\\n                stack.append(temp)\\n                temp=temp.left\\n            else:\\n                node=stack.pop()\\n                if i==0:\\n                    x=root=node\\n                    i+=1\\n                else:\\n                    x.right=node\\n                    x=node\\n                    x.left=None\\n                temp=node.right\\n        return root\\n            \\n```\n```\\n# Recursive way\\ndef inorder(node):\\n            if node:\\n                inorder(node.left)\\n                node.left = None\\n                self.cur.right =  node\\n                self.cur = node\\n                inorder(node.right)\\n                \\n        self.cur = ans = TreeNode(None)        \\n        inorder(root)\\n        return ans.right\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 844808,
                "title": "c-0ms-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (!root) return nullptr;\\n        else if (!root->left && !root->right) return root;\\n        else if (!root->left) {\\n            root->right = increasingBST(root->right);\\n            return root;\\n        }\\n        else {\\n            TreeNode* newroot = increasingBST(root->left);\\n            root->left = nullptr;\\n            TreeNode* tmp = newroot;\\n            while (tmp->right) {\\n                tmp = tmp->right;\\n            }\\n            tmp->right = increasingBST(root);\\n            return newroot;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (!root) return nullptr;\\n        else if (!root->left && !root->right) return root;\\n        else if (!root->left) {\\n            root->right = increasingBST(root->right);\\n            return root;\\n        }\\n        else {\\n            TreeNode* newroot = increasingBST(root->left);\\n            root->left = nullptr;\\n            TreeNode* tmp = newroot;\\n            while (tmp->right) {\\n                tmp = tmp->right;\\n            }\\n            tmp->right = increasingBST(root);\\n            return newroot;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565100,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1567121,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1567397,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1566533,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1572470,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1783474,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1573055,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1728240,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1683393,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1572115,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1565100,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1567121,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1567397,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1566533,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1572470,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1783474,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1573055,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1728240,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1683393,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1572115,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            }
        ]
    }
]